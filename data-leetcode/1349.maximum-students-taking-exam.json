[
    {
        "title": "Angle Between Hands of a Clock",
        "question_content": "Given two numbers, hour and minutes, return the smaller angle (in degrees) formed between the hour and the minute hand.\nAnswers within 10-5 of the actual value will be accepted as correct.\n&nbsp;\nExample 1:\n\nInput: hour = 12, minutes = 30\nOutput: 165\n\nExample 2:\n\nInput: hour = 3, minutes = 30\nOutput: 75\n\nExample 3:\n\nInput: hour = 3, minutes = 15\nOutput: 7.5\n\n&nbsp;\nConstraints:\n\n\t1 <= hour <= 12\n\t0 <= minutes <= 59",
        "solutions": [
            {
                "id": 502738,
                "title": "java-python-c-simple-math-on-clock-angles",
                "content": "**Basic Unitary Method**\\n(Credits - @rajcm)\\n\\n**Hour Hand**\\nIn 12 hours Hour hand complete whole circle and cover 360\\xB0\\nSo, 1 hour = 360\\xB0 / 12 = 30\\xB0\\n\\nSince 1 hours = 30\\xB0\\nIn 1 minute, hours hand rotate -> 30\\xB0 / 60 = 0.5\\xB0\\nSo total angle because of minutes by hour hand is `minutes/60 * 30` or `minutes * 0.5`\\n\\n**Minute Hand**\\nIn 60 minutes Minute Hand completes whole circle and cover 360\\xB0.\\nSo, 1 minute -> 360\\xB0 / 60 = 6\\xB0\\n\\n<br><br>\\n\\n**Java**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n         // Degree covered by hour hand (hour area + minutes area)\\n        double h = (hour%12 * 30) + ((double)minutes/60 * 30);\\n        \\n         // Degree covered by minute hand (Each minute = 6 degree)\\n        double m = minutes * 6;\\n        \\n         // Absolute angle between them\\n        double angle = Math.abs(m - h);\\n        \\n         // If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if (angle > 180) angle = 360.0 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```\\n<br><br>\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Degree covered by hour hand (hour area + minutes area)\\n        h = (hour%12 * 30) + (minutes/60 * 30)\\n        \\n        # Degree covered by minute hand (Each minute = 6 degree)\\n        m = minutes * 6\\n        \\n        # Absolute angle between them\\n        angle = abs(m - h)\\n        \\n        # If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if angle > 180:\\n            angle = 360.0 - angle\\n        \\n        return (angle)\\n```\\n\\n**C++**\\nCredits : [MichaelZ](https://leetcode.com/michaelz/)\\nThanks for the C++ code.\\n```\\ndouble angleClock(int hour, int minutes) {\\n        double minute=minutes*6, hr=hour*30+(double)minutes/2, diff=abs(hr-minute);\\n        return min(diff, 360-diff);\\n    }\\n```\\t\\n\\nPlease upvote if you found this useful.\\nIf you have any queries, please post in comment section.\\nThank you",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n         // Degree covered by hour hand (hour area + minutes area)\\n        double h = (hour%12 * 30) + ((double)minutes/60 * 30);\\n        \\n         // Degree covered by minute hand (Each minute = 6 degree)\\n        double m = minutes * 6;\\n        \\n         // Absolute angle between them\\n        double angle = Math.abs(m - h);\\n        \\n         // If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if (angle > 180) angle = 360.0 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Degree covered by hour hand (hour area + minutes area)\\n        h = (hour%12 * 30) + (minutes/60 * 30)\\n        \\n        # Degree covered by minute hand (Each minute = 6 degree)\\n        m = minutes * 6\\n        \\n        # Absolute angle between them\\n        angle = abs(m - h)\\n        \\n        # If the angle is obtuse (>180), convert it to acute (0<=x<=180)\\n        if angle > 180:\\n            angle = 360.0 - angle\\n        \\n        return (angle)\\n```\n```\\ndouble angleClock(int hour, int minutes) {\\n        double minute=minutes*6, hr=hour*30+(double)minutes/2, diff=abs(hr-minute);\\n        return min(diff, 360-diff);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735395,
                "title": "python-math-solution-oneliner-explained",
                "content": "To solve this problem we need to understand the speeds of Hands of a clock.\\n\\n1. Let us find the place, where **hour hand** is. First, whe have `12` hours in total, for `360` degrees, that means `30` degrees per hour. Also, for every `60` minutes, our hour hand rotated by `1` hour, that is `30` degrees, so for every minute, it is rotated by `0.5` degrees. So, final place for hour hand is `30*hour + 0.5*minutes`\\n2. Let us find the place, where **minute hand** is: every `60` minutes minute hand makes full rotation, that means we have `6` degrees for each minute.\\n3. Finally, we evaluate absolute difference between these two numbers, and if angle is more than `180` degrees, we return complementary angle.\\n\\n**Complexity**: time and space is `O(1)`, we just use some mathematical formulae.\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour, minutes):\\n        H_place = 30*hour + 0.5*minutes\\n        M_place = 6*minutes\\n        diff = abs(H_place - M_place)\\n        return diff if diff <= 180 else 360 - diff\\n```\\n\\n**Oneliner**\\nWe can write this as oneliner as well:\\n```\\nreturn min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour, minutes):\\n        H_place = 30*hour + 0.5*minutes\\n        M_place = 6*minutes\\n        diff = abs(H_place - M_place)\\n        return diff if diff <= 180 else 360 - diff\\n```\n```\\nreturn min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735414,
                "title": "c-easy-with-explanation",
                "content": "### Approach\\n1. Hour hand\\nThe clock is 360deg. Make 4 parts each part is 90deg. 15 min = 90deg. So 5 min = 30 deg.\\nSo every hour our hour hand goes forward 30 deg.\\n2. Minute hand.\\nAs 5 min = 30 deg. So 1 min = 30/5 = 6 deg.\\nif it is 30 min ->  deg is 6 * 30 = 180 deg\\n3. Relation between hour and minute hand (Hint 1)\\nNow if minute hand is at 6 i.e. 30 min hour hand goes to 2.5 min.\\ni.e. out of 60 min hand covers 30 min and out of 5 min hour hand covers 2.5.\\nWe can see the ratio here.\\nso for every minute hour hand goes by 0.5 minutes.\\n\\nSo we can find both hour angle and minute angle and see their difference. Also as the question wants us to return the shorter angle we can to perforn 360 - diff and see if it smaller than diff.\\n#### Steps:\\n1. For hour hand we perform hour % 12 and then mutilply it to magnitude of 30deg.\\n``hour_angle = (hour % 12 ) * 30 + ratio`` - ``ratio = minutes * 0.5``\\n2. For minute hand - ``minutes*6 degrees``\\n3. calculate difference between the two angles - ``abs(h_angle - min_angle)``\\n4. Check the shorter angle ``min(diff,360-diff)``\\n5. Complete\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (hour % 12 ) * 30 + minutes * 0.5;\\n        double minute_angle = minutes * 6;\\n        double diff = abs(hour_angle - minute_angle);\\n        return min(diff, 360 - diff);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (hour % 12 ) * 30 + minutes * 0.5;\\n        double minute_angle = minutes * 6;\\n        double diff = abs(hour_angle - minute_angle);\\n        return min(diff, 360 - diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502816,
                "title": "python-mathematical-solution-with-explanation",
                "content": "The minute hand moves by ```minute_deg_per_min = 360\\xB0 / 60 = 6\\xB0``` per minute.\\nThe hour hand moves by ```hour_deg_per_hour = 360\\xB0 / 12 = 30\\xB0``` per hour.\\nThe hour hand has an additional movement of ```hour_deg_per_min = hour_deg_per_hour / 60 = 30\\xB0 / 60 = 0.5\\xB0``` per minute.\\n\\nTherefore we get the following movements:\\n```\\nhour_hand_deg = hour * hour_deg_per_hour + minutes * hour_deg_per_min = hour * 30 + minutes * 0.5\\nminute_hand_deg = minutes * minute_deg_per_min = minutes * 6\\n```\\n\\nWe need the absolute difference between those two:\\n```\\ndiff_deg = |hour_hand_deg - minute_hand_deg| = |hour * 30 + minutes * 0.5 - minutes * 6| = |hour * 30 - minutes * 5.5|\\n```\\n\\nAs we can easily see when looking at a clock there are two different angles between the hands:\\nThe minimum angle on one side is between 0\\xB0 and 180\\xB0.\\nThe maximum angle on the other side is between 180\\xB0 and 360\\xB0.\\nWe need the minimum angle. If our formular returned a number above 180\\xB0 we got the maximum angle.\\nWe can calculate the minimum angle by subtracting the maximum angle from 360\\xB0.\\n\\nTime and space complexity: ```O(1)```\\n```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        diff = abs(30 * hour - 5.5 * minutes)\\n        return diff if diff <= 180 else 360 - diff\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```minute_deg_per_min = 360\\xB0 / 60 = 6\\xB0```\n```hour_deg_per_hour = 360\\xB0 / 12 = 30\\xB0```\n```hour_deg_per_min = hour_deg_per_hour / 60 = 30\\xB0 / 60 = 0.5\\xB0```\n```\\nhour_hand_deg = hour * hour_deg_per_hour + minutes * hour_deg_per_min = hour * 30 + minutes * 0.5\\nminute_hand_deg = minutes * minute_deg_per_min = minutes * 6\\n```\n```\\ndiff_deg = |hour_hand_deg - minute_hand_deg| = |hour * 30 + minutes * 0.5 - minutes * 6| = |hour * 30 - minutes * 5.5|\\n```\n```O(1)```\n```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        diff = abs(30 * hour - 5.5 * minutes)\\n        return diff if diff <= 180 else 360 - diff\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512733,
                "title": "use-720-for-a-circle-then-divide-by-2-0",
                "content": "\\n```\\n    public double angleClock(int h, int m) {\\n        int hr = 60 * h + m;\\n        int min = 12 * m;\\n        \\n        int angle = Math.abs(hr - min);\\n        return Math.min(angle, 720 - angle)/2.0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double angleClock(int h, int m) {\\n        int hr = 60 * h + m;\\n        int min = 12 * m;\\n        \\n        int angle = Math.abs(hr - min);\\n        return Math.min(angle, 720 - angle)/2.0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503002,
                "title": "c-simple-easy-solution",
                "content": "Get minutes equivalent for hour hand on a scale of 0-60, in the code below hrm is used to denote that.\\nWe know that at max, the difference can be 180 degrees, or 30 units in minute equivalent scale, we use this condition and calculate appropriately.\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrm,mn;\\n        mn=minutes;\\n        hrm = hour%12*5;\\n        hrm+=mn/12.0;\\n        if(abs(mn-hrm)>30)\\n            return mn>hrm?(60-mn+hrm)*6:(60-hrm+mn)*6;\\n        else\\n            return abs(mn-hrm)*6;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrm,mn;\\n        mn=minutes;\\n        hrm = hour%12*5;\\n        hrm+=mn/12.0;\\n        if(abs(mn-hrm)>30)\\n            return mn>hrm?(60-mn+hrm)*6:(60-hrm+mn)*6;\\n        else\\n            return abs(mn-hrm)*6;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2520957,
                "title": "c-1-line-solution-beats-100-submissions",
                "content": "Hey guys,\\nHope you all are doing well!\\nTo be honest, I could have written this code in a single line, but I decided to keep it as simple as possible so that everyone\\xA0can\\xA0easily grasp the logic behind it.\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes){\\n        double hh_angle=(60*hour+minutes)*0.5;  \\n        double mh_angle=minutes*6;\\n        double ans=abs(hh_angle-mh_angle);     //diff liya hai\\n        return ans<=180.0 ? ans : 360.0-ans;   //chhote angle ko return kiya hai\\n    }\\n};\\n```\\nExplaination: \\ni) The minute hand moves 360 degrees in 60 minute => 6 degrees in 1 minute.\\nii) Hour hand moves 360 degrees in 12 hours => 0.5 degrees in 1 minute. \\niii) In h hours and m minutes, the minute hand would move (h*60 + m)*6 and hour hand would move (h*60 + m)*0.5. \\n\\nPlease let me know if you have any questions in the comments. I\\'d be delighted to respond.\\xA0\\nIf you found the solution helpful, please vote it up.\\nHave fun coding.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes){\\n        double hh_angle=(60*hour+minutes)*0.5;  \\n        double mh_angle=minutes*6;\\n        double ans=abs(hh_angle-mh_angle);     //diff liya hai\\n        return ans<=180.0 ? ans : 360.0-ans;   //chhote angle ko return kiya hai\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174887,
                "title": "3-lines-of-code-easiest-cpp-solution-with-explanation-runtime-0ms",
                "content": "**Code:**\\n```\\ndouble angleClock(int hour, int minutes)\\n    {\\n        //1 minutes = 6`    (360/60)\\n        //so firtly calulate minutes travelled by hour hand.\\n        //Every 1 hour in clock consists of 5 minute part, so (hour*5)\\n        //In very minute the movement of hour hand will be (5/60) = (1/12)\\n        //So to calculate movement in the hour hand bcz of minute hand will be (minutes/12)\\n        //So, (hour*5.0) + (minutes/12.0) will give the position of hour hand in respect of minute hand\\n\\t\\t\\n        double hr = (hour*5.0) + (minutes/12.0);  \\n\\t\\t\\n        //to calculate the angle between them\\n        //difference betweem hour hand position and minutes hand position multipled with 6\\n        //So angle 1 = (abs(hr - minutes))*6\\n        //The other angle will be (360 - angle 1)\\n        //return the smaller one\\n\\t\\t\\n        double a = min((abs(hr - minutes))*6, abs(360 - (abs(hr - minutes))*6));\\n\\t\\t\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n    {\\n        //1 minutes = 6`    (360/60)\\n        //so firtly calulate minutes travelled by hour hand.\\n        //Every 1 hour in clock consists of 5 minute part, so (hour*5)\\n        //In very minute the movement of hour hand will be (5/60) = (1/12)\\n        //So to calculate movement in the hour hand bcz of minute hand will be (minutes/12)\\n        //So, (hour*5.0) + (minutes/12.0) will give the position of hour hand in respect of minute hand\\n\\t\\t\\n        double hr = (hour*5.0) + (minutes/12.0);  \\n\\t\\t\\n        //to calculate the angle between them\\n        //difference betweem hour hand position and minutes hand position multipled with 6\\n        //So angle 1 = (abs(hr - minutes))*6\\n        //The other angle will be (360 - angle 1)\\n        //return the smaller one\\n\\t\\t\\n        double a = min((abs(hr - minutes))*6, abs(360 - (abs(hr - minutes))*6));\\n\\t\\t\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436506,
                "title": "100-fastest-simple-math",
                "content": "```\\n double angleClock(int hour, int minutes) {\\n        double num_hours = (30*((double)hour + ((double)(minutes)/60)));  // total time in hours eg 12:30 == 12.5 hours\\n\\t\\t//and multiplying with 30 as 1 hour = 30 degrees \\n        if(num_hours > 360) {\\n            num_hours -= 360; \\n        }// If the result goes above 360 \\n        double ans_min = 6 * minutes;  // every min is 6 degrees \\n        double result = abs(num_hours - ans_min);  // This is first answer but the minimal \\n\\t\\t//could be 360 - answer. Thats why the below line  :) \\n        return min(result, 360 - result);\\n    }\\n\\t// If you understood it then please Upvote , it motivates me !!\\n\\n```",
                "solutionTags": [],
                "code": "```\\n double angleClock(int hour, int minutes) {\\n        double num_hours = (30*((double)hour + ((double)(minutes)/60)));  // total time in hours eg 12:30 == 12.5 hours\\n\\t\\t//and multiplying with 30 as 1 hour = 30 degrees \\n        if(num_hours > 360) {\\n            num_hours -= 360; \\n        }// If the result goes above 360 \\n        double ans_min = 6 * minutes;  // every min is 6 degrees \\n        double result = abs(num_hours - ans_min);  // This is first answer but the minimal \\n\\t\\t//could be 360 - answer. Thats why the below line  :) \\n        return min(result, 360 - result);\\n    }\\n\\t// If you understood it then please Upvote , it motivates me !!\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503033,
                "title": "4-lines-javascript-solution-with-explanation-link-60-ms",
                "content": "Solution:\\n```\\nvar angleClock = function(hour, minutes) {\\n    var minutesAngle = minutes * 6;\\n    var hoursAngle = (hour + minutes / 60) * 30;\\n    var diff = Math.abs(minutesAngle - hoursAngle);\\n    return Math.min(diff, 360 - diff);\\n};\\n```\\n\\nHere is explanation: https://www.varsitytutors.com/sat_math-help/how-to-find-the-angle-of-clock-hands\\n\\n![image](https://assets.leetcode.com/users/eforce/image_1581191938.png)\\n",
                "solutionTags": [],
                "code": "```\\nvar angleClock = function(hour, minutes) {\\n    var minutesAngle = minutes * 6;\\n    var hoursAngle = (hour + minutes / 60) * 30;\\n    var diff = Math.abs(minutesAngle - hoursAngle);\\n    return Math.min(diff, 360 - diff);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502808,
                "title": "simple-java-solution-w-explanation",
                "content": "We can compute the angle between each hand and the vertical line, then take the absolute sum of them.\\nFirst angle (the one between the minute hand and the vertical line): `minutes*360 / 60`\\nSecond angle (the one between the hour hand and the vertical line): `hour offset from 12 o\\'clock` + `minute offset from its hour time`\\n```\\npublic double angleClock(int hour, int minutes) {\\n        double minAngle = minutes*360 / 60;\\n        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\\n        double hourAnglePart2 = (double) (30 * minutes)/ (double) 60;\\n        double hourAngle = hourAnglePart1 + hourAnglePart2;\\n        double preResult = Math.abs(minAngle - (hourAngle));\\n        return preResult > 180 ? 360 - preResult : preResult;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double angleClock(int hour, int minutes) {\\n        double minAngle = minutes*360 / 60;\\n        double hourAnglePart1 = hour != 12 ? (hour * 360) / 12 : 0;\\n        double hourAnglePart2 = (double) (30 * minutes)/ (double) 60;\\n        double hourAngle = hourAnglePart1 + hourAnglePart2;\\n        double preResult = Math.abs(minAngle - (hourAngle));\\n        return preResult > 180 ? 360 - preResult : preResult;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744048,
                "title": "java-simple-small-and-efficient-code",
                "content": "Simple efficient java code.\\n\\n\\tclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n\\t\\tdouble angle = 0;\\n\\t\\tdouble minAngle = minutes * 6;\\n\\t\\tdouble hrAngle = hour * 30 + (minAngle / 360 * 30);\\n\\t\\thrAngle = hrAngle % 360;\\n\\n\\t\\tangle = Math.abs(hrAngle - minAngle);\\n\\n\\t\\tangle = Math.min(angle, 360 - angle);\\n\\n\\t\\treturn angle;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n\\t\\tdouble angle = 0;\\n\\t\\tdouble minAngle = minutes * 6;\\n\\t\\tdouble hrAngle = hour * 30 + (minAngle / 360 * 30);\\n\\t\\thrAngle = hrAngle % 360;\\n\\n\\t\\tangle = Math.abs(hrAngle - minAngle);\\n\\n\\t\\tangle = Math.min(angle, 360 - angle);\\n\\n\\t\\treturn angle;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 735419,
                "title": "simple-c-solution-0ms-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double(abs(5.5*minutes - 30*hour));\\n        if(double(abs(5.5*minutes - 30*hour))>180)\\n            return 360-double(abs(5.5*minutes - 30*hour));\\n        else\\n            return double(abs(5.5*minutes - 30*hour));\\n    }\\n};\\n```\\n\\n# Simple Formula to Calculate the Angle between the hands of a clock\\n**x = 11m/2-30h***",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double(abs(5.5*minutes - 30*hour));\\n        if(double(abs(5.5*minutes - 30*hour))>180)\\n            return 360-double(abs(5.5*minutes - 30*hour));\\n        else\\n            return double(abs(5.5*minutes - 30*hour));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734934,
                "title": "simple-math-python-solution-with-detailed-explanation",
                "content": "Clock is a circle, so the overall angle is 360. \\nThere are 60 minutes, which completes one whole circle, so angle of each minute is 360 / 60 = 6.\\nSimilarly, 12 hours, so angle of each hour is 360 // 12 = 30.\\n\\nWhile calculating hour angle, add minutes into hour because hour hand moves with each second and minute with a minute angle.\\n\\nSo, the actual hours will be hours + minutes / 60 and then multiply by 30 to get the angle.\\n\\n**Note:** In Python, Don\\'t divide by // as it will give you floor number i.e. for 3//2 will give 1 instead of 1.5 and we are interested in that fraction value, So use single forward slash \\'/\\' instead of double \\'//\\'.\\n\\n**Don\\'t forget to upvote if you find it useful!!**\\n\\n**Happy LeetCoding!! :)**\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        one_min_angle = 6\\n        one_hour_angle = 30\\n        \\n        minute_angle = minutes * one_min_angle\\n        hour_angle = (hour + (minutes / 60)) * one_hour_angle      # calculate hour angle by adding minutes into hour\\n        \\n        \\n        diff = abs(hour_angle - minute_angle)            # get absolute difference between angles\\n        \\n        return diff if diff <= 180 else 360 - diff          # return min angle, if diff > 180 then subtract from 360\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        one_min_angle = 6\\n        one_hour_angle = 30\\n        \\n        minute_angle = minutes * one_min_angle\\n        hour_angle = (hour + (minutes / 60)) * one_hour_angle      # calculate hour angle by adding minutes into hour\\n        \\n        \\n        diff = abs(hour_angle - minute_angle)            # get absolute difference between angles\\n        \\n        return diff if diff <= 180 else 360 - diff          # return min angle, if diff > 180 then subtract from 360\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503681,
                "title": "python-faster-than-100",
                "content": "```\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hour %= 12 \\n        h = hour*30 + minutes/2\\n        m = 6 * minutes\\n        return min(abs(h-m), 360-abs(m-h))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hour %= 12 \\n        h = hour*30 + minutes/2\\n        m = 6 * minutes\\n        return min(abs(h-m), 360-abs(m-h))",
                "codeTag": "Python3"
            },
            {
                "id": 2621242,
                "title": "c-beats-100-best-approach-no-explanation-needed",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n\\nif(itHelps)\\n\\t upvote++;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n\\nif(itHelps)\\n\\t upvote++;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735353,
                "title": "java-c-4-line-mathematical-solution-with-explanation",
                "content": "The code uses following facts.\\n1. Every hour, hour hand crosses 30 degree angle. ( 360 degreee / 12 hours = 30 degrees)\\n2. Every minute, minute hand covers 6 degree angle. (360 degree / 60 minutes = 6 degree )\\n3. Every minute, hour hand covers 0.5 degree angle. (30 degree / 60 minutes = 0.5 degree)\\n\\nNow we use above 3 facts to compute hourDegree for hour hand and minuteDegree for \\nminute hands. \\nWe take absolute difference between them and return minimum of (diff, 360 - diff).\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = hour * 30 % 360 + minutes * 0.5;\\n        double minuteDegree = minutes * 6;\\n        \\n        double answer = Math.abs(minuteDegree - hourDegree);\\n        \\n        return Math.min(answer, 360 -answer);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = hour * 30 % 360 + minutes * 0.5;\\n        double minuteDegree = minutes * 6;\\n        \\n        double answer = Math.abs(minuteDegree - hourDegree);\\n        \\n        return Math.min(answer, 360 -answer);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651720,
                "title": "c-easy-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min = minutes*6;\\n        double hr = 30*(hour%12) + 0.5*minutes;\\n\\n        double temp1 = abs(min-hr);\\n        double temp2 = 360-temp1;\\n\\n        if(temp1>temp2){\\n            return temp2;\\n        }\\n        \\n        return temp1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min = minutes*6;\\n        double hr = 30*(hour%12) + 0.5*minutes;\\n\\n        double temp1 = abs(min-hr);\\n        double temp2 = 360-temp1;\\n\\n        if(temp1>temp2){\\n            return temp2;\\n        }\\n        \\n        return temp1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168210,
                "title": "c-solution-using-fractions",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hr, int min) {\\n        double hr1= 360/12, min1= hr1/5 , frac= (double)min/60;\\n        double hrAngle= (hr+frac)*hr1 , minAngle= min*min1;\\n        // cout<<hrAngle<<\" \"<<minAngle;\\n        double ans= abs(hrAngle- minAngle);\\n        return ans<180 ?ans: 360-ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hr, int min) {\\n        double hr1= 360/12, min1= hr1/5 , frac= (double)min/60;\\n        double hrAngle= (hr+frac)*hr1 , minAngle= min*min1;\\n        // cout<<hrAngle<<\" \"<<minAngle;\\n        double ans= abs(hrAngle- minAngle);\\n        return ans<180 ?ans: 360-ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2955410,
                "title": "c-100-faster-o-1-time-and-space-very-simple-concise-solution-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Note:** For complete code, please scroll to the end. Detailed explanation continues below.*\\n\\n*This is a very easy and intuitive problem. Not sure why this is marked as a medium problem in Leetcode.*\\n\\nIf we set a standard unit of position measurement we can use the minute value to count the exact position(including extra displacement) of the hour hand. For example, if the time is 12:30, then hour hand is exactly at middle position of 12 and 1. To find the standard position we can use below formula:\\n\\nhourPosition = hour*(unit/12) + (unit/12)*(minute/60)\\n\\nHere,\\nhourPosition=exact position of hour hand\\nunit=total size of the clock in our new unit of mesaurement\\n\\nFor convenience, we can select unit as 60 minutes(unit=60) which is equivalent to 1 hour. This will mean that we won\\'t have to change our minute value to our new unit of measurement. We can later after finding our answer using this unit, calculate it with respect to 360 degree.\\n\\nNew formula becomes:\\n\\nhourPosition = hour*(5) + (5)*(minute/60)\\n\\nWe only have to keep 1 edge case in mind here that our hour input can have a value of 12. For such cases, we have to convert it to 0.\\n\\nAlso this might give us the bigger angle instead of the smaller angle. For this issue we can subtract the angle found from 360 and take the smaller value of the two.\\n\\n# Detailed Explanation/Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we take care of the edge case inline in our input.\\n\\n```\\nif(hour==12)\\n    hour=0;\\n```\\nNext we find the exact hour positions and minute positions. Since our output needs to be in double we will make the calculation accordingly and store it in a double variable. For hour position we will store it in hourDegree and for minute position we will store it in minDegree.\\n\\nFirst we find the hour position. Since our hour and minute values are integer always but we need double value, we calculate minutes/60.00 instead of minutes/60. This will make the rest of the calculation also happen using doubles due to implicit typecasting.\\n\\n```\\ndouble hourDegree=hour*5+(5*(minutes/60.00));\\n```\\nFor minute position, since our unit is also equivalent to minutes, we simply store the minute value to minPosition. Here also implicit typecasting takes care of integer to double conversion.\\n\\n```\\ndouble minDegree=minutes;\\n```\\nNext we find the difference between the positions and calculate the angle. For that we have to first calcualte the absolute difference of positions i.e. `abs(hourDegree-minDegree)`. Now, since our unit was equivalent to minutes, that means a whole rotation of the clock will give us 60 positions. That means 360 degree is reduced to 60 positions. So to convert it to degree, we have to multiply by 360/60 i.e. 6.\\n\\n```\\ndouble res=abs(hourDegree-minDegree)*6.00;\\n```\\nNow we have our angle in res variable. However, this might be the bigger angle. Since the smaller and bigger angles are complement of each other, we can simply take the difference of 360.00(we need to do calculation in doubles) and res and return the value which is less among res and 360.00-res.\\n\\n```\\nreturn min(res,360.00-res);\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we don\\'t have any loops and our calculations are also basic, the TC is $$O(1)$$.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nOur SC is also $$O(1)$$ as we don\\'t have any variable sized containers.\\n\\n# Complete Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n         hour=0;\\n        double hourDegree=hour*5+(5*(minutes/60.00));\\n        double minDegree=minutes;\\n        double res=abs(hourDegree-minDegree)*6.00;\\n        return min(res,360.00-res);\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/fe61a7ef-7c8d-4bcd-92b4-712cb72cbfee_1672094790.9694436.png)\\n\\nIf this helped you, please leave an upvote. Thanks. \\uD83D\\uDE0A\\uD83C\\uDF08",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nif(hour==12)\\n    hour=0;\\n```\n```\\ndouble hourDegree=hour*5+(5*(minutes/60.00));\\n```\n```\\ndouble minDegree=minutes;\\n```\n```\\ndouble res=abs(hourDegree-minDegree)*6.00;\\n```\n```\\nreturn min(res,360.00-res);\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n         hour=0;\\n        double hourDegree=hour*5+(5*(minutes/60.00));\\n        double minDegree=minutes;\\n        double res=abs(hourDegree-minDegree)*6.00;\\n        return min(res,360.00-res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658342,
                "title": "easy-java-implementation-with-explaination",
                "content": "Approach:\\n* In 12 hours , hour hand can do 360 degrees , so per hour hour hand will do 30 degrees.\\n* Similarly in 60 minutes, minute hand can do 360 degrees, so in 1 minute, the minute hand will do 6 degree rotation.\\n* Also keep in mind while the minute hand is moving the hour hand will move along with it. Like in 60 minutes , the hour hand rotates 30 degrees\\n* So per minute the hour hand rotates 0.5 degrees.\\n\\n* Now simply find the difference between the hour and minute hand store it in result.\\n* Now check whether result or 360 - result, which is smaller and return it as the result.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n         double angleHour = hour*30, angleMinutes = minutes*6;\\n        \\n        angleHour =angleHour + 0.5*(minutes);\\n        \\n        double res = Math.abs(angleHour - angleMinutes);\\n        \\n        return Math.min(res, 360-res);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n         double angleHour = hour*30, angleMinutes = minutes*6;\\n        \\n        angleHour =angleHour + 0.5*(minutes);\\n        \\n        double res = Math.abs(angleHour - angleMinutes);\\n        \\n        return Math.min(res, 360-res);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450691,
                "title": "python-easy-code-with-comments",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        #Angle traversal by hourhand\\n        hAngle = 30*(hour%12)\\n        \\n        #Angle traversal by minuteshand\\n        mAngle = 6*(minutes%60)\\n        \\n        #Extra traversal by hourhand based on minutes hand\\n        extraAngle = (minutes/60)*30\\n        \\n        hAngle+=extraAngle\\n        \\n        #Angle difference\\n        diff = abs(hAngle-mAngle)\\n        \\n        #Always prefer acute angle\\n        return min(diff,360-diff)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        #Angle traversal by hourhand\\n        hAngle = 30*(hour%12)\\n        \\n        #Angle traversal by minuteshand\\n        mAngle = 6*(minutes%60)\\n        \\n        #Extra traversal by hourhand based on minutes hand\\n        extraAngle = (minutes/60)*30\\n        \\n        hAngle+=extraAngle\\n        \\n        #Angle difference\\n        diff = abs(hAngle-mAngle)\\n        \\n        #Always prefer acute angle\\n        return min(diff,360-diff)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424720,
                "title": "100",
                "content": "double angleClock(int ho, int min) {\\n        double x=0,y=0;\\n        if (ho==12)\\n        {\\n            ho=0;\\n        }\\n        x=ho*(30);\\n        x+=(min*0.5);\\n        y=(min*6);\\n        double ans;\\n        if (x>y)\\n        {\\n            ans= x-y;\\n        }\\n       else{\\n            ans= y-x;\\n       }\\n        \\n       \\n        if (ans>180)\\n        {\\n           return 360- ans;\\n        }\\n        return ans;\\n        \\n    }",
                "solutionTags": [],
                "code": "double angleClock(int ho, int min) {\\n        double x=0,y=0;\\n        if (ho==12)\\n        {\\n            ho=0;\\n        }\\n        x=ho*(30);\\n        x+=(min*0.5);\\n        y=(min*6);\\n        double ans;\\n        if (x>y)\\n        {\\n            ans= x-y;\\n        }\\n       else{\\n            ans= y-x;\\n       }\\n        \\n       \\n        if (ans>180)\\n        {\\n           return 360- ans;\\n        }\\n        return ans;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2169417,
                "title": "python-1-liner-o-1",
                "content": "1. The minute hand will move `m_angle = 6*m` degrees.\\n2. The hour hand will move `h_angle = 30*h + 0.5*m` degrees.\\n3. `angle = abs(h_angle - m_angle)`\\n4. Answer is `min(angle,360-angle)`\\n```\\nclass Solution:\\n    def angleClock(self, h: int, m: int) -> float:\\n        return min(abs(6*m - (30*h + 0.5*m )), 360-abs(6*m - (30*h + 0.5*m )))\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, h: int, m: int) -> float:\\n        return min(abs(6*m - (30*h + 0.5*m )), 360-abs(6*m - (30*h + 0.5*m )))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007927,
                "title": "python-easy-solution-full-explanation",
                "content": "12 hours = 360 degree\\n1 hour = 30 degree \\n60 mins = 360 degree\\n1 min = 6 degree\\nso first we will calculate the degree for the minutes hand i.e., \\na=6 * minutes\\nnow we will calculate the dgree for the hour hand,\\nb=(hour+minutes/60) * 30 (minutes/60 is done so that we can get the exact position of the hour hand like what if it is between any hours (ex: 2 and 3 )\\nNow c=abs(a-b)\\nd=(360-c)\\nreturn min(c,d) (what if the degree between hands is coming low from the other side so taking the minimum of the both.\\nHere is the code,\\n \\n \\n\\t\\ta=minutes*6\\n        b=(hour+(minutes/60))*30\\n        c=abs(a-b)\\n        d=abs(360-c)\\n        return min(c,d)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nUpvote it, if you like...",
                "solutionTags": [],
                "code": "12 hours = 360 degree\\n1 hour = 30 degree \\n60 mins = 360 degree\\n1 min = 6 degree\\nso first we will calculate the degree for the minutes hand i.e., \\na=6 * minutes\\nnow we will calculate the dgree for the hour hand,\\nb=(hour+minutes/60) * 30 (minutes/60 is done so that we can get the exact position of the hour hand like what if it is between any hours (ex: 2 and 3 )\\nNow c=abs(a-b)\\nd=(360-c)\\nreturn min(c,d) (what if the degree between hands is coming low from the other side so taking the minimum of the both.\\nHere is the code,\\n \\n \\n\\t\\ta=minutes*6\\n        b=(hour+(minutes/60))*30\\n        c=abs(a-b)\\n        d=abs(360-c)\\n        return min(c,d)\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nUpvote it, if you like...",
                "codeTag": "Unknown"
            },
            {
                "id": 1911342,
                "title": "python-one-line-solution-based-on-aptitude-formula",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(abs(30*hour-5.5*minutes),360-abs(30*hour-5.5*minutes))\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889556,
                "title": "python-easiest-to-understand-comments-clear-and-concise",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def angleClock(self, h, m):\\n        # Convert the hour hand to another minute hand\\n        m2 = (h%12 + m/60)*5\\n        \\n        # Calculate the difference between the two minute hands\\n        diff = abs(m-m2)\\n        \\n        # Convert the difference to an angle\\n        ang = diff*(360/60)\\n        \\n        # Return the smallest angle\\n        return min(360-ang, ang)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, h, m):\\n        # Convert the hour hand to another minute hand\\n        m2 = (h%12 + m/60)*5\\n        \\n        # Calculate the difference between the two minute hands\\n        diff = abs(m-m2)\\n        \\n        # Convert the difference to an angle\\n        ang = diff*(360/60)\\n        \\n        # Return the smallest angle\\n        return min(360-ang, ang)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839139,
                "title": "java-easy-explanation-on-clock-angles",
                "content": "**Find A ( Angle of Hour Hand from start/origin/0 degree)**\\n\\n12 hours = 360 deg\\n1 hour = 30 deg\\n\\nalso 60 minutes = 30 deg\\n**1 min = 0.5 deg**\\n\\nIt means hour hand rotate by 0.5 degrees every minute\\n\\n**A = 30*Hours +  (0.5)Minutes**\\n\\n**30*Hours**  = Rotation of hour hand from start every hour ( as 1 hour = 30 deg , so n hours = 30*n ) \\n**0.5minutes** = Rotation of hour hand from start every minute  \\n\\n![image](https://assets.leetcode.com/users/images/270a4a24-6599-42d6-a689-6ebe75310994_1646986749.7168727.png)\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Find B ( Angle of Minute Hand from start/origin/0 degree)**\\n\\n60 minutes = 360 deg\\n**1 min = 6 deg**\\n\\nIt means minute hand rotate by 6 degrees every minute\\n\\n**B = 6*minutes**\\n\\n![image](https://assets.leetcode.com/users/images/812d1093-311f-4ccf-9852-46e57ec9c475_1646986847.6751308.png)\\n\\n<br>\\n\\n**Difference of A and B will give us Angle Between Hands of a Clock**\\nAngle(C) = Math.abs(A-B)\\n\\n![image](https://assets.leetcode.com/users/images/ed6ca54f-97ab-45e1-bbf8-91a6b2ef238e_1646988496.2992537.png)\\n\\n<br>\\n<hr>\\n<br>\\n\\n**Java Code**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n\\t\\t//Angle of Hour Hand from start\\n        double hourHand = 30*hour + (0.5)*minutes;\\n        \\n\\t\\t//Angle of Minute Hand from start\\n        double minHand = 6 * minutes;\\n        \\n        //Difference of A and B will give us Angle Between Hands of a Clock\\n        double angle = Math.abs(hourHand - minHand);\\n        \\n\\t\\t// to return the smaller angle formed between the hour and the minute hand.\\n        return angle > 180 ? 360 - angle : angle;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n\\t\\t//Angle of Hour Hand from start\\n        double hourHand = 30*hour + (0.5)*minutes;\\n        \\n\\t\\t//Angle of Minute Hand from start\\n        double minHand = 6 * minutes;\\n        \\n        //Difference of A and B will give us Angle Between Hands of a Clock\\n        double angle = Math.abs(hourHand - minHand);\\n        \\n\\t\\t// to return the smaller angle formed between the hour and the minute hand.\\n        return angle > 180 ? 360 - angle : angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1758598,
                "title": "c-0ms-beats-100-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n          return min( abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ), 360 -  abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ));\\n    }\\n};\\n\\n\\n\\n(hr % 12 + min/60 ) * 360/12 - min/60 * 360\\nformula for finding angle \\n\\nupvote if it was helpfull\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n          return min( abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ), 360 -  abs( (hour % 12 + minutes/60.0) * 30 - (minutes*6) ));\\n    }\\n};\\n\\n\\n\\n(hr % 12 + min/60 ) * 360/12 - min/60 * 360\\nformula for finding angle \\n\\nupvote if it was helpfull\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1687385,
                "title": "c-simple-math-solution-2-lines-0ms",
                "content": "It is a simple conversion question.\\nThe angle between hour and minute hand = angle from 12 o\\'clock to hour hand - angle from 12 o\\'clock to minutes hand\\n\\nangle from 12 o\\'clock to hour hand = ((5*hour + (minutes/60)*5))/60)*360 [because hour hand will be slightly moved in clockwise direction because of minutes passed and also converting to degrees]\\n\\nangle from 12 o\\'clock to minutes hand = (minutes/60)*360\\n\\nOn simplification we get,\\nangle between hour hand and minutes hand = 30*hour - 5.5*minutes\\n\\nBecause we should take the smaller angle, we use the min function to find the minimum of (angle, 360 - angle)\\n\\nNOTE: The result angle could be negative so we take the absolute value\\n\\n ```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs(30*hour - (5.5*minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs(30*hour - (5.5*minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1323801,
                "title": "100-c-0ms-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        \\n        if(hour == 12) hour = 0;\\n        double a = ((hour)*30.0 + (minutes)*0.5);\\n        double b = (minutes)*6.0;\\n        \\n        return abs(a-b)>180.0 ? 360.0-abs(a-b) : abs(a-b);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        \\n        if(hour == 12) hour = 0;\\n        double a = ((hour)*30.0 + (minutes)*0.5);\\n        double b = (minutes)*6.0;\\n        \\n        return abs(a-b)>180.0 ? 360.0-abs(a-b) : abs(a-b);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281213,
                "title": "easy-c-100-faster-o-1-space-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        //get the degree of minutes and hours from the 12 (pointing at 12)\\n        \\n        double  minDegree=(minutes* 6);\\n        //30 degree gap in between each hour\\n        double hourDegree=(hour==12) ? 0 : hour*30;\\n        //some degree are gonna add to hour because of the minute hand\\n        //for x minutes the hour degree moves (1/2)*x \\n\\t\\t//ex x= 30 min (pointing at 6 ) and hour is at 12 , then the hour hand moves a extra of (1/2) * 30 = 15 degrees ahead\\n        hourDegree+= (double)(minutes)/2;\\n        \\n\\t\\t//get the angle in degrees between them\\n        double angle=abs(minDegree-hourDegree);\\n        \\n        //there are two possibles angles \\n        return min(angle,360-angle);\\n    }\\n};\\n```\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        //get the degree of minutes and hours from the 12 (pointing at 12)\\n        \\n        double  minDegree=(minutes* 6);\\n        //30 degree gap in between each hour\\n        double hourDegree=(hour==12) ? 0 : hour*30;\\n        //some degree are gonna add to hour because of the minute hand\\n        //for x minutes the hour degree moves (1/2)*x \\n\\t\\t//ex x= 30 min (pointing at 6 ) and hour is at 12 , then the hour hand moves a extra of (1/2) * 30 = 15 degrees ahead\\n        hourDegree+= (double)(minutes)/2;\\n        \\n\\t\\t//get the angle in degrees between them\\n        double angle=abs(minDegree-hourDegree);\\n        \\n        //there are two possibles angles \\n        return min(angle,360-angle);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896674,
                "title": "python-3-simple-faster-than-72-33-and-memort-less-than-100",
                "content": "I didn\\'t think that this is gonna work, but here it is, scoring a perfect memory score. I will first show you the code, and then explain it to you. \\n```\\ndef main(hour, minutes):\\n    minutesAngle = minutes * 6\\n    hourAngle = (((hour % 12) * 30) + ((minutes / 60) * 30))\\n    angle = abs(hourAngle - minutesAngle)\\n    return min(angle, 360 - angle)\\n```\\n\\n\\nFirst of all, we measure the angle at which, minute hand will be. Now, there are 60 minutes and 360 degress, thus, 1 minute is (360 / 60) 6 degrees. \\nhourAngle depends on hour hand, as well has the minutes hand. First of all, every hour except 12 add 30 degrees. Thus, we used modulo. Then, if it is one hour and 60 minutes, its basically two hours. Therefore, to calculate the additional angle, we divide the minutes by 60, and then multiply by 30. You can directly divide by 2, but I felt that is more intuitive. \\nThen, we calculate the difference between minute and hour angle and to return minimum, we return minimum between angle and 360 - angle.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef main(hour, minutes):\\n    minutesAngle = minutes * 6\\n    hourAngle = (((hour % 12) * 30) + ((minutes / 60) * 30))\\n    angle = abs(hourAngle - minutesAngle)\\n    return min(angle, 360 - angle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 820584,
                "title": "javascript-with-detailed-explanation",
                "content": "Idea: Consider 12pm to be degree `0`. Then calculate the degrees of hour hand and minute hand. Return the difference.\\n\\nFor example: `03:30pm`\\n```\\nminute hand: (30 / 60) * 360 = 180\\nmeaning 30 of 60 minutes takes half of a circle (360 degrees)\\n\\nhour hand: (3 * 360 / 12) + (30 / 60 * 360 / 12) = 105\\nmeaning 3 hours take 3 hour sectors (360 / 12) and 30 of 60 minutes takes half of a hour sector (360 / 12)\\n\\n180 - 105 = 75, the answer\\n```\\n\\n##### Javascript\\n```javascript\\nvar angleClock = function(hour, minutes) {\\n    const minuteAngle = minutes / 60 * 360;\\n    const hourAngle = (hour % 12 + minutes / 60 ) * 360 / 12;\\n    let ans = Math.abs(minuteAngle - hourAngle);\\n    return ans >= 180 ? 360 - ans : ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nminute hand: (30 / 60) * 360 = 180\\nmeaning 30 of 60 minutes takes half of a circle (360 degrees)\\n\\nhour hand: (3 * 360 / 12) + (30 / 60 * 360 / 12) = 105\\nmeaning 3 hours take 3 hour sectors (360 / 12) and 30 of 60 minutes takes half of a hour sector (360 / 12)\\n\\n180 - 105 = 75, the answer\\n```\n```javascript\\nvar angleClock = function(hour, minutes) {\\n    const minuteAngle = minutes / 60 * 360;\\n    const hourAngle = (hour % 12 + minutes / 60 ) * 360 / 12;\\n    let ans = Math.abs(minuteAngle - hourAngle);\\n    return ans >= 180 ? 360 - ans : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736348,
                "title": "java-3-line-simple-ans-o-1-time-with-explanation",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        // Find angle made by minute hand\\n        double min = 6.0*minutes;\\n\\t\\t// Find andgle made by hour hand\\n        double hr = 30.0*(hour%12) + 0.5*minutes;\\n        \\n\\t\\t// Return the difference between both hands (We need smaller angle that\\'s why did Math.min())\\n        return Math.min(360.0-Math.abs(min - hr), Math.abs(min - hr));\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        // Find angle made by minute hand\\n        double min = 6.0*minutes;\\n\\t\\t// Find andgle made by hour hand\\n        double hr = 30.0*(hour%12) + 0.5*minutes;\\n        \\n\\t\\t// Return the difference between both hands (We need smaller angle that\\'s why did Math.min())\\n        return Math.min(360.0-Math.abs(min - hr), Math.abs(min - hr));\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736322,
                "title": "python-o-1-o-1",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_pos = (hour%12)*5 + (minutes/60)*5\\n\\t\\tdiff_angle = abs(minutes - hr_pos) * 6\\n\\n        if diff_angle > 180:\\n            return 360-diff_angle\\n\\n        return diff_angle\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_pos = (hour%12)*5 + (minutes/60)*5\\n\\t\\tdiff_angle = abs(minutes - hr_pos) * 6\\n\\n        if diff_angle > 180:\\n            return 360-diff_angle\\n\\n        return diff_angle\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736234,
                "title": "java-o-1-0ms-2-line-solution",
                "content": "**Implementation**\\n```\\npublic double angleClock(int h, int m) {\\n        double theta = Math.abs(30 * h - 5.5 * m);        \\n        return (theta > 180) ? 360 - theta : theta;\\n    }\\n```\\n**Logic**\\nWe need to calculate the difference of angle swept by both hands from *any arbitrary position* to the current position. This will be one of the two angles, using this we can  obtain the result.\\n\\nFor simple understanding lets consider **12:00** as *arbitrary position*. This is one of the position where both hands are overlapping (angle b/w both hands is zero) hence, difference between the two swept angles will give us one of the angles between hour hand and minute hand.\\n\\nNow we can arrive to the solution by following below steps:\\n1. Calculate the angle swept by both hands(\\u2220Hour and \\u2220Minute). Angle swept by any hand can be calculated by considering the fact that Clock can be divided into:\\n* 12 sectors of (360/12=) **30 degrees** for calculating \\u2220Hour,\\n* 60 sectors of (360/60=) **6 degrees** for calculating \\u2220Minute and \\u2220Hour\\n* Hour hand also moves every minute by **(30 / 60) = 0.5 degrees** Hence in *m* minutes it will move by  **(30 *  m / 60) degrees**\\n```\\n    angleH = 30 * (h + m / 60F);  // i.e. (30 * h) + (30 * m / 60)\\n    angleM = 6 * m; // i.e. 360 * m / 60\\n```\\n\\n2. Find the absolute difference between swept angles i.e. (say) **\\u03B8 = |\\u2220Hour - \\u2220Minute|**.\\n*\\u03B8* and *360 - \\u03B8* as the two angles between both hand.\\n```\\n    theta = Math.abs(angleH - angleM);\\n````\\n3. Find the smaller angle between *\\u03B8* and *360 - \\u03B8*. **Result = min(\\u03B8, 360-\\u03B8)**\\n```\\n    return Math.min(theta, 360-theta); \\n```\\nNote: Implementation has simplified expression for ```\\u03B8``` (or ```theta```)\\n\\n![image](https://assets.leetcode.com/users/images/b0a42dbc-f3dc-4e4f-a322-92075a59c9aa_1594890188.0851424.png)\\n\\n\\n\\n     \\n",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic double angleClock(int h, int m) {\\n        double theta = Math.abs(30 * h - 5.5 * m);        \\n        return (theta > 180) ? 360 - theta : theta;\\n    }\\n```\n```\\n    angleH = 30 * (h + m / 60F);  // i.e. (30 * h) + (30 * m / 60)\\n    angleM = 6 * m; // i.e. 360 * m / 60\\n```\n```\\n    theta = Math.abs(angleH - angleM);\\n```\n```\\n    return Math.min(theta, 360-theta); \\n```\n```\\u03B8```\n```theta```",
                "codeTag": "Unknown"
            },
            {
                "id": 632493,
                "title": "java-0ms-beats-100-space-and-time-with-full-explanation",
                "content": "1. The Hour hand moves 30 (360/12) degrees every hour and 1/2 (30/60) a degree every minute.\\n2. The Minute hand moves 6 (360/60) degrees every minute.\\n3. Therefore the total movement of hand hour is : hours  30 + minutes  0.5 or total number of minutes  0.5 which is  : (hour60+minutes)0.5 \\n4. The total movement of minute hour is : minutes  6.\\n5. Now get the difference between both the movements and get the absolute value of it (as angle cannot the negative here).\\n6. Now if the resulting angle comes to be more than 180 degrees then return 360-angle as the answer as the answer requires the smaller angle.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle=Math.abs((hour*60+minutes)*0.5-minutes*6);\\n        return angle>180.0?360.0-angle:angle;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle=Math.abs((hour*60+minutes)*0.5-minutes*6);\\n        return angle>180.0?360.0-angle:angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630465,
                "title": "java-100-runtime-o-1-and-100-space-2-lines",
                "content": "\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\n        double angel = Math.abs((hour + (minutes/60.0))-(minutes/5.0))*30;       \\n        return (angel<=180)? angel : 360-angel;\\n\\t\\t\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\n        double angel = Math.abs((hour + (minutes/60.0))-(minutes/5.0))*30;       \\n        return (angel<=180)? angel : 360-angel;\\n\\t\\t\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 620444,
                "title": "c-6-lines-simple-maths-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n\\t//Distance travelled by hour hand with a speed of 0.5 degree per minute\\n        double hd=m*0.5;\\n\\t//Distance travelled by minute hand with a speed of 6 degree per minute\\n        double md=m*6;\\n\\t//Assuming the minute hand to be initially at 12, the difference will be hour*5*6\\n        double ex=h*5*6;\\n        if(h==12)ex=0;\\n\\t//The actual difference between thehour and minute hand\\n        double ans=abs(md-hd-ex);\\n        return (min(ans,360-ans));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n\\t//Distance travelled by hour hand with a speed of 0.5 degree per minute\\n        double hd=m*0.5;\\n\\t//Distance travelled by minute hand with a speed of 6 degree per minute\\n        double md=m*6;\\n\\t//Assuming the minute hand to be initially at 12, the difference will be hour*5*6\\n        double ex=h*5*6;\\n        if(h==12)ex=0;\\n\\t//The actual difference between thehour and minute hand\\n        double ans=abs(md-hd-ex);\\n        return (min(ans,360-ans));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504101,
                "title": "python-3-math-line-by-line-explanation-16ms-beats-100",
                "content": "```py\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        m = minutes * 6     # Scale up minutes [0, 360): 360/60 = 6\\n        h = (hour%12) * 30  # Hours to [0, 12), then scale up to [0, 360): 360/12 = 30\\n        h += m / 12         # Adjust hour hand: full rotation of minute hand moves hour hand 1/12th of the circle\\n        angle = abs(m - h)  # Get rid of the smallest hand by adjusting it to 0. This moves the largest to -smallest\\n        return angle if angle < 180 else 360 - angle  # Return the smaller angle\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        m = minutes * 6     # Scale up minutes [0, 360): 360/60 = 6\\n        h = (hour%12) * 30  # Hours to [0, 12), then scale up to [0, 360): 360/12 = 30\\n        h += m / 12         # Adjust hour hand: full rotation of minute hand moves hour hand 1/12th of the circle\\n        angle = abs(m - h)  # Get rid of the smallest hand by adjusting it to 0. This moves the largest to -smallest\\n        return angle if angle < 180 else 360 - angle  # Return the smaller angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502773,
                "title": "java-4-liner",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = (Math.abs(hour * 5 - minutes)) * 6.0;\\n        if(hour * 5 >= minutes) ans += (1.0 * minutes) / (2.0);\\n        else ans -= (1.0 * minutes) / (2.0);\\n        return Math.abs(Math.min(ans, 360 * 1.0 - ans));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = (Math.abs(hour * 5 - minutes)) * 6.0;\\n        if(hour * 5 >= minutes) ans += (1.0 * minutes) / (2.0);\\n        else ans -= (1.0 * minutes) / (2.0);\\n        return Math.abs(Math.min(ans, 360 * 1.0 - ans));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 4008455,
                "title": "simple-arithmetics-used",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int totalMinutes=hour*60+minutes;\\n     double hourAngle=totalMinutes*0.5;\\n     double minuteAngle=minutes*6;\\n     if(hourAngle>=360)\\n     hourAngle=hourAngle-360;\\ndouble ans=Math.abs(minuteAngle-hourAngle);\\nif(ans>180.00)\\nans=360.00-ans;\\nreturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int totalMinutes=hour*60+minutes;\\n     double hourAngle=totalMinutes*0.5;\\n     double minuteAngle=minutes*6;\\n     if(hourAngle>=360)\\n     hourAngle=hourAngle-360;\\ndouble ans=Math.abs(minuteAngle-hourAngle);\\nif(ans>180.00)\\nans=360.00-ans;\\nreturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855754,
                "title": "simple-aptitude-o-1-in-time-and-space",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$ \\n\\n- Space complexity: $$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = minutes*6, hourAngle = (hour*30 + minutes/2.0);\\n        if(hourAngle > 360) hourAngle -= 360;\\n\\n       double angle = abs(minuteAngle - hourAngle); //take the difference of angle swept by hour hand and minute hand\\n       return min(angle,360 - angle); //return acute angle\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = minutes*6, hourAngle = (hour*30 + minutes/2.0);\\n        if(hourAngle > 360) hourAngle -= 360;\\n\\n       double angle = abs(minuteAngle - hourAngle); //take the difference of angle swept by hour hand and minute hand\\n       return min(angle,360 - angle); //return acute angle\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762671,
                "title": "solution-python",
                "content": "# Intuition\\n- This is a tricky problem, here any `division` of whole `whole` numbers will be evealuated to `floor` division. \\n*In Python 2.x, the division of two integers returns an integer result (floor division) instead of a float.*\\nMaybe the author wanted to pay respect or whatever.\\nSo:\\n    - You can try `return 1 / 2 ` and see `0` \\n    - That\\'s why you need to divide by a `float` number\\n\\n\\n\\n- Also,  the function `abs` Returns the absolute value of the argument.\\n\\n# Detailed Code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        1 hour = 30\\n        1 minute = 6\\n        \"\"\"\\n        if hour == 12:\\n            hour = 0\\n        hand_one_angle = hour * 30 + (minutes / 2.0)\\n\\n        hand_two_angle = minutes * 6\\n\\n        angle = hand_one_angle - hand_two_angle\\n        angle = abs(angle)  \\n\\n        return angle if angle <= 180 else 360 - angle\\n```\\n# Short code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        if hour == 12:\\n            hour = 0\\n\\n        angle = abs(hour * 30 + (minutes / 2.0) - minutes * 6)\\n        return angle if angle <= 180 else 360 - angle\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        1 hour = 30\\n        1 minute = 6\\n        \"\"\"\\n        if hour == 12:\\n            hour = 0\\n        hand_one_angle = hour * 30 + (minutes / 2.0)\\n\\n        hand_two_angle = minutes * 6\\n\\n        angle = hand_one_angle - hand_two_angle\\n        angle = abs(angle)  \\n\\n        return angle if angle <= 180 else 360 - angle\\n```\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        if hour == 12:\\n            hour = 0\\n\\n        angle = abs(hour * 30 + (minutes / 2.0) - minutes * 6)\\n        return angle if angle <= 180 else 360 - angle\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3759900,
                "title": "simple-math",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min=minutes;\\n        double hr=hour;\\n//taking 12 as reference, hr*30 is the angle rotated by hour hand,min*6 is angle rotated by minute hand and when minute hand rotates by 6deg, hour hand rotates by 0.5deg in same sence...can be proven.\\n        double deg=abs(hr*30-min*6+min/2);\\n        if(deg>180){\\n            deg=360-deg;\\n        }\\n        return deg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double min=minutes;\\n        double hr=hour;\\n//taking 12 as reference, hr*30 is the angle rotated by hour hand,min*6 is angle rotated by minute hand and when minute hand rotates by 6deg, hour hand rotates by 0.5deg in same sence...can be proven.\\n        double deg=abs(hr*30-min*6+min/2);\\n        if(deg>180){\\n            deg=360-deg;\\n        }\\n        return deg;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655543,
                "title": "simple-and-easy-c-solution-t-n-o-1",
                "content": "# Intuition\\nJust have to figure out how the angles of the hands of the clocks are changing.So,\\n\\nthe minute hand of the clock moves 360 degree in one hour(60 min) which means (360/60)= 6 degree in a minute, using this you can find out the angle of minutes hand.\\n\\nThe hour hand of the clock moves 360 degree in 12 hours(12x60 min) which means (360/(12x60)) =0.5 degree in a minute. Then you calculate angle of hour hand by adding the angle changed by the hour hand by minutes passed in that hour plus the angle it already had at the hour time like 5 O\\'clock or 3 O\\'clock (you can calulate by looking at the hour and multiply it by 30 as every 5 min where the notation for hour is given is 30 degree).\\n\\n# Approach\\nminute_hand_angle= 6* minutes\\n\\nhour_hand_angle=(0.5*minutes) + (hour%12)*30\\n\\nreturn the difference between the angles.     \\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ma=minutes*6,ha=(0.5*minutes)+((hour%12)*30);\\n        return min(abs(ma-ha),360-abs(ma-ha));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ma=minutes*6,ha=(0.5*minutes)+((hour%12)*30);\\n        return min(abs(ma-ha),360-abs(ma-ha));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549353,
                "title": "c-3-line-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int dom = minutes*6;\\n        double doh = hour*30 + minutes*0.5;\\n        return min(abs(doh-dom) , 360-abs(doh-dom));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int dom = minutes*6;\\n        double doh = hour*30 + minutes*0.5;\\n        return min(abs(doh-dom) , 360-abs(doh-dom));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511956,
                "title": "easy-mathematical-solution-in-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhour hand covers 30 degree in 60 mins and minute hand covers 360 degree in 60 minutes\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntaking 12 as 0 degree\\n\\nhour hand position in degree = initial postion + minutes * speed;\\nspeed of hour hand = 0.5 degree per minute\\nminute hand position in degree = initial position + minutes * speed;\\nspeed of minute hand = 6 degree per minute\\n# Complexity\\n- Time complexity:$$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n\\n        double h_moves = hour * 30.0 + minutes * 0.5;\\n        double m_moves = 0.0 + minutes * 6.0;\\n\\n        double a1 = abs(m_moves - h_moves);\\n\\n        return min(a1, 360.0 - a1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n\\n        double h_moves = hour * 30.0 + minutes * 0.5;\\n        double m_moves = 0.0 + minutes * 6.0;\\n\\n        double a1 = abs(m_moves - h_moves);\\n\\n        return min(a1, 360.0 - a1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2995635,
                "title": "easy-c-solution-o-1-time-complexity",
                "content": "# Approach\\n1) Initialize two doubles hour1 and minutes1\\n2) hour1 is the distance of hour clock from 12 and minutes1 is the distance of the minute clock from 12\\n3) We then calculate the absolute difference between the distances and multiply it with 360/no of partitions(12) i.e. 30 and that will give us the angle between hour hand and minute hand\\n4) .\\n    ->If the result is less than 180 i.e. acute then it is the smaller angle and so we return the result\\n    ->If the result is more than 180 i.e. obtuse then it is the larger angle and so we return the smaller angle which will be 180-result\\n\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour1 =hour%12+ minutes/60.0;\\n        double minutes1 =(minutes/60.0)*12;\\n        double result =abs(hour1-minutes1)*30.0;\\n        if(result<=180)return result;\\n        else return 360.0-result;\\n    }\\n};\\n//Upvote the answer if it was helpful ..Thank You\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour1 =hour%12+ minutes/60.0;\\n        double minutes1 =(minutes/60.0)*12;\\n        double result =abs(hour1-minutes1)*30.0;\\n        if(result<=180)return result;\\n        else return 360.0-result;\\n    }\\n};\\n//Upvote the answer if it was helpful ..Thank You\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2879501,
                "title": "basic-math-solution",
                "content": "\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        double mAngle= m*6;\\n        double a=mAngle/12;\\n        if(h==12)\\n            h=0;\\n        double hAngle=((h*5*6)+a);\\n        double ans=max(mAngle,hAngle)-min(mAngle,hAngle);\\n        double temp=360-ans;\\n        return min(ans,temp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        double mAngle= m*6;\\n        double a=mAngle/12;\\n        if(h==12)\\n            h=0;\\n        double hAngle=((h*5*6)+a);\\n        double ans=max(mAngle,hAngle)-min(mAngle,hAngle);\\n        double temp=360-ans;\\n        return min(ans,temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872418,
                "title": "o-1-space-and-time-solution-c-using-formula",
                "content": "# Approach\\nAngle = [(11/2)M-30H]\\nif it is greater than 180 return it after subtracting from 360.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:<b>$$O(1)$$</b>\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n        return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n        return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813551,
                "title": "c-easy-solution-0ms-100-fast-with-comments",
                "content": "```\\ndouble angleClock(int hour, int minutes){\\n    double maffhr=(double)minutes*30/60; //calculating the angle by which the hour hand is affected due to the minutes hand\\n    double hrangle=(double)hour*30+maffhr; //calculating the angle made by hour hand with 12\\n    double miangle=(double)minutes*30/5; //calculating the angle made by minutes hand with 12\\n    double ang=fabs(hrangle-miangle); //calculating the angle difference between the hour and minutes hand\\n    return fmin(ang,360-ang); //returns the minimum angle as been told in the description\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes){\\n    double maffhr=(double)minutes*30/60; //calculating the angle by which the hour hand is affected due to the minutes hand\\n    double hrangle=(double)hour*30+maffhr; //calculating the angle made by hour hand with 12\\n    double miangle=(double)minutes*30/5; //calculating the angle made by minutes hand with 12\\n    double ang=fabs(hrangle-miangle); //calculating the angle difference between the hour and minutes hand\\n    return fmin(ang,360-ang); //returns the minimum angle as been told in the description\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769436,
                "title": "c-one-liner-formula-based",
                "content": "Formula for angle between Minute and Hour hand of a clock = 11/2 * minutes - 30 * hour\\n```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes){\\n            return min(abs((11 / 2.0) *minutes - 30 *hour), 360 - abs((11 / 2.0) *minutes - 30 *hour));\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes){\\n            return min(abs((11 / 2.0) *minutes - 30 *hour), 360 - abs((11 / 2.0) *minutes - 30 *hour));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666246,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour*30) + (minutes*0.5);\\n        double minuteDegree = (minutes*6);\\n        double angleBetween = Math.abs(hourDegree - minuteDegree);\\n        return Math.min(angleBetween, 360-angleBetween);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour*30) + (minutes*0.5);\\n        double minuteDegree = (minutes*6);\\n        double angleBetween = Math.abs(hourDegree - minuteDegree);\\n        return Math.min(angleBetween, 360-angleBetween);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2632938,
                "title": "c-100-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minDegree=6*minutes;\\n        if(hour==12)\\n            hour=0;\\n        double hourDegree=double(hour+minutes/60.0)*30;\\n        double angle1=abs(minDegree-hourDegree);\\n        double angle2=360-angle1;\\n        return min(angle1,angle2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2593806,
                "title": "c-simple-100-0ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double t=30*hour;\\n        double t1=5.5*minutes;\\n        double ans=t-t1;\\n        if(ans<0) ans*=-1;\\n        if(ans>180) ans=360-ans;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double t=30*hour;\\n        double t1=5.5*minutes;\\n        double ans=t-t1;\\n        if(ans<0) ans*=-1;\\n        if(ans>180) ans=360-ans;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548929,
                "title": "1344-angle-between-hands-of-a-clock-in-java-time-o-1-space-o-1",
                "content": "class Solution {\\n  public double angleClock(int hour, int minutes) {\\n    final double hourHand = (hour % 12 + minutes / 60.0) * 30;\\n    final double minuteHand = minutes * 6;\\n    final double diff = Math.abs(hourHand - minuteHand);\\n    return Math.min(diff, 360 - diff);\\n  }\\n}\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\n  public double angleClock(int hour, int minutes) {\\n    final double hourHand = (hour % 12 + minutes / 60.0) * 30;\\n    final double minuteHand = minutes * 6;\\n    final double diff = Math.abs(hourHand - minuteHand);\\n    return Math.min(diff, 360 - diff);\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2546912,
                "title": "java-100-fastest-method-with-simple-math",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double anglePerHour = 30;\\n        double anglePerMin = 6;\\n        \\n        double diffHour = Math.abs(minutes / 5.0 - hour) * anglePerHour;\\n        double diffMin = (minutes / 60.0) * 5 * anglePerMin;\\n        \\n        double cwdiff = 0;\\n        //if minute hand is before hour hand;\\n        if(minutes / 5 - hour < 0){\\n            cwdiff = diffHour + diffMin;\\n        }\\n        \\n        //if minute hand is after hour hand;\\n        else{\\n            cwdiff = Math.abs(diffHour - diffMin);\\n        }\\n        \\n        double ccwdiff = 360 - cwdiff;\\n        return Math.min(cwdiff, ccwdiff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double anglePerHour = 30;\\n        double anglePerMin = 6;\\n        \\n        double diffHour = Math.abs(minutes / 5.0 - hour) * anglePerHour;\\n        double diffMin = (minutes / 60.0) * 5 * anglePerMin;\\n        \\n        double cwdiff = 0;\\n        //if minute hand is before hour hand;\\n        if(minutes / 5 - hour < 0){\\n            cwdiff = diffHour + diffMin;\\n        }\\n        \\n        //if minute hand is after hour hand;\\n        else{\\n            cwdiff = Math.abs(diffHour - diffMin);\\n        }\\n        \\n        double ccwdiff = 360 - cwdiff;\\n        return Math.min(cwdiff, ccwdiff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387730,
                "title": "c-solution-math",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs((30 * hour) - (5.5 * minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = abs((30 * hour) - (5.5 * minutes));\\n        return min(ans, 360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2383792,
                "title": "beginner-friendly-explanation-and-solution-java-0-ms",
                "content": "# Approach\\nImagine the clock as a circle, and then think through this:\\n- one complete rotation around the circle is 360 degrees\\n- the clock (circle) is divided into 12 labels (hours from 1 through 12)\\n- what is the angle between two consecutive labels? 360 / 12 = 30\\n- - another way to think this is the opposite way: if 30 is added 12 times it makes 360!\\n\\nMoving forward\\n- observe that when needle shows 5 minutes, it is physically at label 1. For 15 minutes it is at label 3, for 45 at label 9.\\n- - the above fact can be represented as `min / 5 = label`\\n\\nWhy the above stuff?\\nImage it\\'s 12:30 on the clock, so hour label is obviously 12. What about the minute label? 30 / 5 = 6. So, 12 to 6. What\\'s the difference: 12 - 6 = 6. In other words, the clock shows two needles which have covered 6 consecutive labels from hour label to minute label. What is the angle between these labels: 6 * 30 = 180. **(Not exactly, as explained below - but undertanding like this will make it easier to get to the tricky part)**\\n\\n# **Tricky part**\\nOur assumptions in the above walkthrough have kept the hour needle constant. That is, we assume that the hour needle **does not** move from its position and just jumps to next label when an hour passes. \\uD83D\\uDE27 This is not the case:\\n- observe that as the minute needle moves through, the hour needle slowly moves too.\\n- as 60 minutes pass, the hour needle slowly progresses to the next hour\\n\\nIf you observe the images in the problem description tab, there are 3 images of clocks. Take, for example, the clock with 12:30. Observe that the hour needle is not exactly at 12. Its **halfway** through 12 and 1.\\n- when the minutes needle is at 30, hour needle moves *halfway or 50% or 0.5* to the next hour\\n- when the minutes needle is at 15, hour neendle moves to 25% or 0.25 to the next hour\\n\\nThis can be represented mathematically as `minutes / 60`\\n>30 / 60 = 0.50\\\\\\n>45 / 60 = 0.75\\n>60 / 60 = 1.00\\n>15 / 60 = 0.25\\n>23 / 60 = 0.38\\n\\nSo, we have to keep in mind this displacement of hour needle as well and add it to the original hour needle position.\\n\\n## Another tricky bit\\n*(This one kept me scratching my head for 20 minutes - It shouldnt have but still...)*\\n\\nNote that two needles in a clock can be at 180 degrees at max, not beyond that. So, if the calculated angle becomes greater than 180, just subtract it from 360.\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n        double minToHLabel = minutes / 5.0;\\n  \\n        double disp = (double) 1/60 * minutes;\\n        \\n        double diff = (hour + disp) - minToHLabel;\\n        \\n\\t\\t// absolute difference (Math.abs can be used aswell) \\n        if (diff < 0){\\n            diff = diff * - 1;\\n        }\\n        \\n\\t\\t// if the calculated angle is greater than 180, return after subtracting from 360\\n        if (diff * 30 > 180){\\n            return 360 - diff * 30;\\n        }\\n        else {\\n            return diff * 30;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\n        double minToHLabel = minutes / 5.0;\\n  \\n        double disp = (double) 1/60 * minutes;\\n        \\n        double diff = (hour + disp) - minToHLabel;\\n        \\n\\t\\t// absolute difference (Math.abs can be used aswell) \\n        if (diff < 0){\\n            diff = diff * - 1;\\n        }\\n        \\n\\t\\t// if the calculated angle is greater than 180, return after subtracting from 360\\n        if (diff * 30 > 180){\\n            return 360 - diff * 30;\\n        }\\n        else {\\n            return diff * 30;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2368840,
                "title": "c-o-1-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hr=30*hour+(0.5*minutes);\\n        hr=hr>=360?hr-360:hr;\\n        double m=6*minutes;\\n        if(m>hr)\\n        return m-hr<hr+(360-m)?m-hr:hr+(360-m);\\n        return hr-m<(360-hr)+m?hr-m:(360-hr)+m;\\n    }\\n};\\n```\\nAs we know \\n**One hour** = 30 degress + 0.5 * Minutes.\\n**One Minute** = 6 degress.\\nNow we apply simple mathematic formula to yield the result.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hr=30*hour+(0.5*minutes);\\n        hr=hr>=360?hr-360:hr;\\n        double m=6*minutes;\\n        if(m>hr)\\n        return m-hr<hr+(360-m)?m-hr:hr+(360-m);\\n        return hr-m<(360-hr)+m?hr-m:(360-hr)+m;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306119,
                "title": "on-line-or-two-lines-python",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        x = abs(minutes * 6 -(hour * 30 + minutes/2))\\n        return min(360-x , x)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        x = abs(minutes * 6 -(hour * 30 + minutes/2))\\n        return min(360-x , x)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2258116,
                "title": "3-o-1-time-o-1-space-illustrated-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/97c6441b-71ae-4045-b52c-69c5f97894c3_1657362262.4013243.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        h = 360 / 12 * (hour + minutes / 60)\\n        m = 360 / 60 * minutes\\n        return min(a := abs(h - m), 360 - a)\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/ab16870a-4834-444f-936c-5c071d410f3c_1657362277.5164502.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        return min(a := abs(30 * hour - 5.5 * minutes), 360 - a)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/97c6441b-71ae-4045-b52c-69c5f97894c3_1657362262.4013243.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        h = 360 / 12 * (hour + minutes / 60)\\n        m = 360 / 60 * minutes\\n        return min(a := abs(h - m), 360 - a)\\n\\t\\t\\n\\t\\t\\n![image](https://assets.leetcode.com/users/images/ab16870a-4834-444f-936c-5c071d410f3c_1657362277.5164502.png)\\n\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \"\"\" O(1)TS \"\"\"\\n        return min(a := abs(30 * hour - 5.5 * minutes), 360 - a)",
                "codeTag": "Python3"
            },
            {
                "id": 2191114,
                "title": "simple-math-solution-easy-explanation",
                "content": "* First we have to calculate perMinute and perHour angles.\\n**perMinute angle = 360 (total angle) / 60 (minutes) \\nSimilarly perHour angle= 360 /12 (hours)**\\n* if(hour ==12 ) convert it to 0, So angle fits in 360 degrees  to avoid unneccesary calculations.\\n\\n* Now as the minute hand moves hour hand angle also changes. To find out that angle :\\nwe can see that between any two hours  30 degree angle exists.\\n**So perMinute Movement of hour hand between two hours = 30( angle between two hours)/60(total minutes).**\\n**So totalHourAngle= perHourAngle( 30 ) * hours + 0.5 * minutes.\\nMinuteHandAngle = perMinuteAngle( 6 )  * minutes.**\\n \\n*  **then angle1=abs(hourAngle - minuteAngle);**\\n       **angle2 =360 - angle1**\\n \\n*  **RequiredAns = min(angle1,angle2)**.\\n\\n* Please note that all angle are calculated with respect to 12:00.\\n\\n\\tPlease upvote if found Helpful!!\\n\\n```\\nclass Solution{\\npublic:\\n   double angleClock(int hour, int minutes){\\n      int perMinute = 6;  \\n      int perHour = 30;   \\n      if (hour == 12)\\n         hour = 0;\\n      double minuteAngle = 6 * minutes;\\n      double hourAngle = 30 * hour + minutes * 0.5;\\n      double angle1 = abs(hourAngle - minuteAngle);\\n      double angle2 = abs(360 - angle1);\\n      return min(angle1, angle2);\\n   }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n   double angleClock(int hour, int minutes){\\n      int perMinute = 6;  \\n      int perHour = 30;   \\n      if (hour == 12)\\n         hour = 0;\\n      double minuteAngle = 6 * minutes;\\n      double hourAngle = 30 * hour + minutes * 0.5;\\n      double angle1 = abs(hourAngle - minuteAngle);\\n      double angle2 = abs(360 - angle1);\\n      return min(angle1, angle2);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163214,
                "title": "angle-between-hands-of-a-clock-python-solution",
                "content": "def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        \"\"\"\\n        As hour clock move by (360/12) is per hour + ((360/12)/60) per minutes\\n        \"\"\"\\n        hours_degree = (360/12)*hour+(360/720)*minutes\\n        minute_degree = (360/60)*minutes\\n        res =  abs(hours_degree-minute_degree)\\n        if res > 180:\\n            return 360-res\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        \"\"\"\\n        As hour clock move by (360/12) is per hour + ((360/12)/60) per minutes\\n        \"\"\"\\n        hours_degree = (360/12)*hour+(360/720)*minutes\\n        minute_degree = (360/60)*minutes\\n        res =  abs(hours_degree-minute_degree)\\n        if res > 180:\\n            return 360-res\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2102837,
                "title": "python-naive-approach-explained-with-comments",
                "content": "**Code**\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Normalizing minute position in range (1-12)\\n        min_clock = minutes/5\\n\\n        # If time is 12.00 returning 0\\n        if minutes == 0 and hour*30 == 360:\\n            return 0\\n        \\n        # If minutes is 0 then multiply hour by 30 degree as each hour consists of 30 degree\\n        elif minutes == 0:\\n            only_hour = hour*30\\n            \\n            # Check whether it is shorter in opposite direction\\n            if only_hour > 180:\\n                return 360-(only_hour)\\n            return only_hour\\n        \\n        else:\\n            # Finding the degree between minute hand and closest hour of the hour hand\\n            time = abs(hour-min_clock)*30\\n            \\n            # Finding the difference that needs to added/subtracted\\n            diff = 30/(60/minutes)\\n            \\n            # Subtracting when minute hand is at greater value that hour hand\\n            if min_clock > hour:\\n                fin_time = time-diff\\n                \\n            # Adding when minute hand is at lesser value that hour hand\\n            else:\\n                fin_time = time+diff\\n            \\n            # Check the shorter direction\\n            if fin_time > 180:\\n                diff = fin_time-180\\n                return abs(180-diff)\\n            else:\\n                return abs(fin_time)\\n            \\n```\\n\\n\\n**Space & Time Analysis**\\n![image](https://assets.leetcode.com/users/images/3c439212-1a7d-45ff-a31d-630b871e2e81_1654181622.2073946.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        \\n        # Normalizing minute position in range (1-12)\\n        min_clock = minutes/5\\n\\n        # If time is 12.00 returning 0\\n        if minutes == 0 and hour*30 == 360:\\n            return 0\\n        \\n        # If minutes is 0 then multiply hour by 30 degree as each hour consists of 30 degree\\n        elif minutes == 0:\\n            only_hour = hour*30\\n            \\n            # Check whether it is shorter in opposite direction\\n            if only_hour > 180:\\n                return 360-(only_hour)\\n            return only_hour\\n        \\n        else:\\n            # Finding the degree between minute hand and closest hour of the hour hand\\n            time = abs(hour-min_clock)*30\\n            \\n            # Finding the difference that needs to added/subtracted\\n            diff = 30/(60/minutes)\\n            \\n            # Subtracting when minute hand is at greater value that hour hand\\n            if min_clock > hour:\\n                fin_time = time-diff\\n                \\n            # Adding when minute hand is at lesser value that hour hand\\n            else:\\n                fin_time = time+diff\\n            \\n            # Check the shorter direction\\n            if fin_time > 180:\\n                diff = fin_time-180\\n                return abs(180-diff)\\n            else:\\n                return abs(fin_time)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2061780,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        // Few helpful notes for problem solving\\n        // Considering the clock as a total of 360 degree space\\n        // we have 12 hours, each hour moves 360/12 = 30 degrees\\n        // we have 60 mins, each minute moves 360/60 = 6 degrees\\n        // 60 minutes of time moves hour needle by 30 degrees; 1 minute will move hours extra by 30/60 mins\\n        \\n        double oneHourDegrees = 30;\\n        double oneMinDegrees = 6;\\n\\n        double minuteAngle = minutes * oneMinDegrees;\\n        \\n        double hourAngle = (hour % 12) * oneHourDegrees;\\n        double hourAngleExtraMovement = minutes * (oneHourDegrees / 60);\\n        \\n        \\n        double diff = Math.abs((hourAngle + hourAngleExtraMovement) - minuteAngle);\\n        return Math.min(diff, 360-diff);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        // Few helpful notes for problem solving\\n        // Considering the clock as a total of 360 degree space\\n        // we have 12 hours, each hour moves 360/12 = 30 degrees\\n        // we have 60 mins, each minute moves 360/60 = 6 degrees\\n        // 60 minutes of time moves hour needle by 30 degrees; 1 minute will move hours extra by 30/60 mins\\n        \\n        double oneHourDegrees = 30;\\n        double oneMinDegrees = 6;\\n\\n        double minuteAngle = minutes * oneMinDegrees;\\n        \\n        double hourAngle = (hour % 12) * oneHourDegrees;\\n        double hourAngleExtraMovement = minutes * (oneHourDegrees / 60);\\n        \\n        \\n        double diff = Math.abs((hourAngle + hourAngleExtraMovement) - minuteAngle);\\n        return Math.min(diff, 360-diff);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023508,
                "title": "beats-100-percent-cpp-solution-very-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double a1_h =hour*30 +minutes/2.0 ;\\n          double a1_m =minutes*6 ;\\n     \\n        double ang1 =abs(a1_h-a1_m);\\n        double ang2 =360 -ang1;\\n        return min(ang1,ang2);\\n    }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double a1_h =hour*30 +minutes/2.0 ;\\n          double a1_m =minutes*6 ;\\n     \\n        double ang1 =abs(a1_h-a1_m);\\n        double ang2 =360 -ang1;\\n        return min(ang1,ang2);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1925864,
                "title": "c-100-fatsest-easy",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hr, int m) {\\n        \\n        double Am=(double)m*6;\\n        double th;\\n        if(hr!=12){\\n        th=hr + (double)m/60;\\n        }\\n        else\\n        th=(double)m/60;\\n        \\n        double Ah=(double)th*30;\\n        \\n        \\n        if((th<=6 && m<=30) || (th>=6 && m>=30))\\n        return abs(Ah-Am);\\n        else \\n        {\\n            return min(abs(Ah-Am),(360-abs(Ah-Am)));\\n        }\\n    }\\n};\\n\\nI hope you liked it...",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hr, int m) {\\n        \\n        double Am=(double)m*6;\\n        double th;\\n        if(hr!=12){\\n        th=hr + (double)m/60;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1885653,
                "title": "pure-maths-simple-one-line-soln-beats-100",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n  return min (abs(-(30*hour)+(5.5*minutes)),360.0-abs((-30*hour)+(5.5*minutes)));\\n      }\\n};",
                "solutionTags": [
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n  return min (abs(-(30*hour)+(5.5*minutes)),360.0-abs((-30*hour)+(5.5*minutes)));\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 1883807,
                "title": "javascript-1344-angle-between-hands-of-a-clock",
                "content": "---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar angleClock = function (hour, minutes) {\\n    const degh = hour + minutes / 60; // convert to hours\\n    const degm = minutes / 5; //         convert to hours\\n\\n    const angle = Math.abs(degm - degh) * 30; // 30 degrees per 1 hour\\n    return Math.min(angle, 360 - angle);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/211173a3-6c7c-4be3-bb0d-b56a6298ab6c_1648257885.2183793.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar angleClock = function (hour, minutes) {\\n    const degh = hour + minutes / 60; // convert to hours\\n    const degm = minutes / 5; //         convert to hours\\n\\n    const angle = Math.abs(degm - degh) * 30; // 30 degrees per 1 hour\\n    return Math.min(angle, 360 - angle);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786555,
                "title": "easy-c-100-faster",
                "content": "```\\ndouble angleClock(int hour, int minutes)\\n{\\n    if (hour == 12)\\n        hour = 0;\\n\\n    double hour_d = minutes;\\n\\n    hour_d = (hour * 30) + (hour_d / 2);\\n    double min_d = minutes * 6;\\n\\n    cout << hour_d << \" \" << min_d << endl;\\n\\n    if (hour_d > min_d)\\n        return min(hour_d - min_d, 360.0 - hour_d + min_d);\\n\\n    else\\n        return min(min_d - hour_d, 360.0 - min_d + hour_d);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n{\\n    if (hour == 12)\\n        hour = 0;\\n\\n    double hour_d = minutes;\\n\\n    hour_d = (hour * 30) + (hour_d / 2);\\n    double min_d = minutes * 6;\\n\\n    cout << hour_d << \" \" << min_d << endl;\\n\\n    if (hour_d > min_d)\\n        return min(hour_d - min_d, 360.0 - hour_d + min_d);\\n\\n    else\\n        return min(min_d - hour_d, 360.0 - min_d + hour_d);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1724461,
                "title": "simple-one-line-java-solution-with-proper-explanation",
                "content": "```\\npublic double angleClock(int hour, int minutes) {\\n\\t\\t//Hour hand roatation per hour = 360/12 = 30\\n\\t\\t// Hour hand rotation per min = 30/60 = 0.5\\n\\t\\t// Min hand rotation per min = 360/60 = 6\\n        double diff = Math.abs((hour%12)*30 + minutes*0.5- minutes*6);\\n        return diff>180? (360-diff):diff;\\n}\\n```\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\npublic double angleClock(int hour, int minutes) {\\n\\t\\t//Hour hand roatation per hour = 360/12 = 30\\n\\t\\t// Hour hand rotation per min = 30/60 = 0.5\\n\\t\\t// Min hand rotation per min = 360/60 = 6\\n        double diff = Math.abs((hour%12)*30 + minutes*0.5- minutes*6);\\n        return diff>180? (360-diff):diff;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1722685,
                "title": "c-clock-math-explained",
                "content": "```\\n    /*\\n    Mathwise-        \\n        1 hour = 60 minutes = 360 degrees on a clock.\\n        every time minute hand travels 360 degrees, hour hand travels by 1 hour\\'s worth - 30 degrees (360/12)\\n        every time minute hand travels 6 degrees (1 minute), hour hand travels (30*6)/360: 0.5 degrees\\n        \\n        minute hand would be at the 6*minute angle\\n        hour hand would be at the 30*hour + 0.5*minute.\\n        \\n        compute the angle difference \\n        if angle is bigger than 180, return the 360 - angle result\\n        minute hand goes 6 degrees per minute\\n        \\n        angle will be minute angle - hour angle (abs);\\n    */\\nclass Solution {\\npublic:\\n\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = 6 * minutes;\\n        double hourAngle = 30 * hour + 0.5 * minutes;\\n        \\n        double angle = abs(minuteAngle - hourAngle);\\n        return min(angle, 360-angle); //as thought earlier, we could use a conditional like if(angle > 180) {return 360-angle};\\n    }\\n    \\n    //TIME - O(1) //no matter what happens, we have a constant time\\n    //SPACE - O(1) //no matter what happens, we have a constant space\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    /*\\n    Mathwise-        \\n        1 hour = 60 minutes = 360 degrees on a clock.\\n        every time minute hand travels 360 degrees, hour hand travels by 1 hour\\'s worth - 30 degrees (360/12)\\n        every time minute hand travels 6 degrees (1 minute), hour hand travels (30*6)/360: 0.5 degrees\\n        \\n        minute hand would be at the 6*minute angle\\n        hour hand would be at the 30*hour + 0.5*minute.\\n        \\n        compute the angle difference \\n        if angle is bigger than 180, return the 360 - angle result\\n        minute hand goes 6 degrees per minute\\n        \\n        angle will be minute angle - hour angle (abs);\\n    */\\nclass Solution {\\npublic:\\n\\n    double angleClock(int hour, int minutes) {\\n        double minuteAngle = 6 * minutes;\\n        double hourAngle = 30 * hour + 0.5 * minutes;\\n        \\n        double angle = abs(minuteAngle - hourAngle);\\n        return min(angle, 360-angle); //as thought earlier, we could use a conditional like if(angle > 180) {return 360-angle};\\n    }\\n    \\n    //TIME - O(1) //no matter what happens, we have a constant time\\n    //SPACE - O(1) //no matter what happens, we have a constant space\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575773,
                "title": "java-math-on-clock-angles-faster-than-100",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {      \\n        \\n        int oneMinAngle = 6;\\n        int oneHourAngle = 30;\\n        \\n        //calculating the effect of minutes on the hour hand\\n        double minFrac = (double)minutes/60.0;\\n        double hHandMove = minFrac * oneHourAngle;\\n       \\n        //calculating the angles of hour hand the minute hand from 0degree\\n        double hAngle = (hour%12) * oneHourAngle + hHandMove;\\n        double minAngle = minutes * oneMinAngle;\\n        \\n        //calculating both the angles formed \\n        double firstDiff = Math.abs(hAngle - minAngle);\\n        double secondDiff = 360 - firstDiff;\\n        \\n        return Math.min(firstDiff, secondDiff);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {      \\n        \\n        int oneMinAngle = 6;\\n        int oneHourAngle = 30;\\n        \\n        //calculating the effect of minutes on the hour hand\\n        double minFrac = (double)minutes/60.0;\\n        double hHandMove = minFrac * oneHourAngle;\\n       \\n        //calculating the angles of hour hand the minute hand from 0degree\\n        double hAngle = (hour%12) * oneHourAngle + hHandMove;\\n        double minAngle = minutes * oneMinAngle;\\n        \\n        //calculating both the angles formed \\n        double firstDiff = Math.abs(hAngle - minAngle);\\n        double secondDiff = 360 - firstDiff;\\n        \\n        return Math.min(firstDiff, secondDiff);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538731,
                "title": "easy-to-understand-python-code",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        # cloclwise\\n\\t\\t# 30 degrees is the angle of one hour\\n        hour_angle = hour * 30 + 30 * minutes / 60\\n        minute_angle = 360 * minutes / 60\\n        return min(360 - abs(minute_angle - hour_angle), abs(minute_angle - hour_angle))",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        # cloclwise\\n\\t\\t# 30 degrees is the angle of one hour\\n        hour_angle = hour * 30 + 30 * minutes / 60\\n        minute_angle = 360 * minutes / 60\\n        return min(360 - abs(minute_angle - hour_angle), abs(minute_angle - hour_angle))",
                "codeTag": "Java"
            },
            {
                "id": 1464436,
                "title": "java-math-with-explanation",
                "content": "1. For every 1 hour (60 minutes) that is completed on a clock, the minutes pointer rotates 360 degrees. This means that for every 1 minute, the minutes pointer moved 6 degrees.\\n2. For every 12 hours, the hours pointer completes 360 degrees, which means that the hour pointer moves 30 degrees every hour.\\n3. The main point to remember here is that the hour pointer doesn\\'t remain at a static position between every hour that passes, but it covers a certain degree as the minutes keep passing by. It is important to calculate the degree of movement and add it to the total degree that the hours pointer moves.\\n\\nAs an example, let us consider when the time is 12:30. While the minutes pointer moves by 180 degrees at this time (30 * 6), the hour pointer moves by 0.5 degrees every 1 minute,as calculated below:\\n\\n360 degrees = 12 hours\\n30 degrees = 1 hour\\n30 degrees = 60 minutes => 0.5 degrees every minute. In this example, where the minutes is at 30, we can thus infer that the hours pointer has moved 15 degrees. We thus calculate the hoursAngle and minutesAngle.\\n\\n```\\n public double angleClock(int hour, int minutes) {\\n        double hourAngle = 30*(hour%12) + 0.5*(minutes);\\n        double minuteAngle = 6*(minutes);\\n        \\n        double result = Math.abs(hourAngle-minuteAngle);\\n        //min angle to be returned.\\n        return Math.min(result, 360-result);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n public double angleClock(int hour, int minutes) {\\n        double hourAngle = 30*(hour%12) + 0.5*(minutes);\\n        double minuteAngle = 6*(minutes);\\n        \\n        double result = Math.abs(hourAngle-minuteAngle);\\n        //min angle to be returned.\\n        return Math.min(result, 360-result);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432604,
                "title": "3-line-100-c-code",
                "content": "```\\n//please upvote  if you like the solution \\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hA = 30*hour + (double)minutes/2;\\n        double mA = 6*minutes;\\n        return min(360 - abs(hA - mA), abs(hA - mA));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//please upvote  if you like the solution \\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hA = 30*hour + (double)minutes/2;\\n        double mA = 6*minutes;\\n        return min(360 - abs(hA - mA), abs(hA - mA));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314494,
                "title": "c-easy-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tdouble angleClock(int hour, int minutes) {\\n\\n\\t\\t\\tdouble n=static_cast<double>(minutes)/60;        \\n\\t\\t\\tdouble min=n*360;        \\n\\t\\t\\tdouble hou=(n+hour)*30;\\n\\n\\t\\t\\treturn abs(hou-min)>360-abs(hou-min)?360-abs(hou-min):abs(hou-min);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tdouble angleClock(int hour, int minutes) {\\n\\n\\t\\t\\tdouble n=static_cast<double>(minutes)/60;        \\n\\t\\t\\tdouble min=n*360;        \\n\\t\\t\\tdouble hou=(n+hour)*30;\\n\\n\\t\\t\\treturn abs(hou-min)>360-abs(hou-min)?360-abs(hou-min):abs(hou-min);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1298871,
                "title": "detailed-solution-with-full-explanation",
                "content": "class Solution {\\n    \\n    public double angleClock(int hour, int minutes) {\\n        /*\\n            This method calculates the angles difference \\n            between HOUR HAND and MINUTE HAND\\n        */\\n\\n        /*\\n        ALGORITHM:\\n            #   Calculate the angles for each hands from \\n                the origin(i.e. 12 o\\'clock)\\n            #   1 hour makes 30 degrees\\n            #   1 minute makes 6 degrees\\n        */\\n\\n        double angleHourHand = (hour * 30) % 360 + minutes * 0.5;\\n        // one hour makes 30 degrees\\n        // 12 o\\'clock is 0 degrees, that is why modulues applied\\n        // 60 minutes is 1 hour and that is 30 degrees\\n        // so 1 minute is 0.5 degree\\n\\n        double angleMinuteHand = minutes * 6; \\n        // 60 minutes is 360 degrees\\n        // 1 minute is 6 degrees\\n\\n        double difference = angleHourHand - angleMinuteHand;\\n\\n        // IF NEGATIVE, MAKE POSITIVE\\n        if (difference < 0){\\n            difference *= -1;\\n        }\\n\\n        // There are two angles \\n        // One is definitely smaller than 180, find it \\n        if(difference > 180){\\n            difference = 360 - difference; // the other angles that completes to 360\\n        }\\n        \\n        \\n        return difference;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public double angleClock(int hour, int minutes) {\\n        /*\\n            This method calculates the angles difference \\n            between HOUR HAND and MINUTE HAND\\n        */\\n\\n        /*\\n        ALGORITHM:\\n            #   Calculate the angles for each hands from \\n                the origin(i.e. 12 o\\'clock)\\n            #   1 hour makes 30 degrees\\n            #   1 minute makes 6 degrees\\n        */\\n\\n        double angleHourHand = (hour * 30) % 360 + minutes * 0.5;\\n        // one hour makes 30 degrees\\n        // 12 o\\'clock is 0 degrees, that is why modulues applied\\n        // 60 minutes is 1 hour and that is 30 degrees\\n        // so 1 minute is 0.5 degree\\n\\n        double angleMinuteHand = minutes * 6; \\n        // 60 minutes is 360 degrees\\n        // 1 minute is 6 degrees\\n\\n        double difference = angleHourHand - angleMinuteHand;\\n\\n        // IF NEGATIVE, MAKE POSITIVE\\n        if (difference < 0){\\n            difference *= -1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1260232,
                "title": "php-solution-100-faster-2-lines-of-code",
                "content": "```\\n\\tfunction angleClock($hour, $minutes) {\\n        $delta = abs($hour * 30 - $minutes / 2 * 11);\\n        return $delta <= 180 ? $delta : 360 - $delta;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfunction angleClock($hour, $minutes) {\\n        $delta = abs($hour * 30 - $minutes / 2 * 11);\\n        return $delta <= 180 ? $delta : 360 - $delta;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1260171,
                "title": "php-solution-100-faster",
                "content": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $hour\\n     * @param Integer $minutes\\n     * @return Float\\n     */\\n    function angleClock($hour, $minutes) {\\n        if($hour > 12) $hour -= 12; \\n        $delta = abs(($minutes * 6) - (0.5 * ($hour * 60 + $minutes)));\\n        if($delta < 180) \\n            return $delta;\\n        return 360-$delta;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer $hour\\n     * @param Integer $minutes\\n     * @return Float\\n     */\\n    function angleClock($hour, $minutes) {\\n        if($hour > 12) $hour -= 12; \\n        $delta = abs(($minutes * 6) - (0.5 * ($hour * 60 + $minutes)));\\n        if($delta < 180) \\n            return $delta;\\n        return 360-$delta;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192482,
                "title": "two-liner-c-solution-100-faster",
                "content": "Formula for finding angle between hour hand and minute hand:\\nAngle= (30 * Hour - (11/2) * Minutes))\\nIf the Angle is greater than 180 degree ( reflex angle ) then subtract it from 360 degree to get the correct angle.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double x= abs(30*hour - 11/(double)2*minutes);\\n        return min(x,360.00000-x);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double x= abs(30*hour - 11/(double)2*minutes);\\n        return min(x,360.00000-x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1182338,
                "title": "100-faster-solution",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n    double  hour_hand_angle = hour*30 + minutes*0.5;\\n    double minute_hand_angle = minutes*6;\\n    double angle = abs(hour_hand_angle - minute_hand_angle);\\n        if(angle<=180)\\n            return angle;\\n        else \\n            return 360 - angle;\\n    }\\n};\\n```\\n```\\n# Quick Explanation\\n1. Hour hand makes angle of 360\\xB0 in 12 hours , so in 1 hour it will make 360/12 = 30\\xB0. In 1 hour(60 minutes) it is making 30\\xB0 so in 1 minute it will make 30/60 = 0.5\\xB0.\\n2. Minute hand makes angle of 360\\xB0 in 1 hour(60 minutes) , so in 1 minute it will make 360/60 = 6\\xB0.\\n3. Subtract both angles to give absolute value.\\n4. We have to return smallest angle ,so check if its greater than 180\\xB0 then subract it from 360\\xB0.\\nUpvote if it helped!\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n    double  hour_hand_angle = hour*30 + minutes*0.5;\\n    double minute_hand_angle = minutes*6;\\n    double angle = abs(hour_hand_angle - minute_hand_angle);\\n        if(angle<=180)\\n            return angle;\\n        else \\n            return 360 - angle;\\n    }\\n};\\n```\n```\\n# Quick Explanation\\n1. Hour hand makes angle of 360\\xB0 in 12 hours , so in 1 hour it will make 360/12 = 30\\xB0. In 1 hour(60 minutes) it is making 30\\xB0 so in 1 minute it will make 30/60 = 0.5\\xB0.\\n2. Minute hand makes angle of 360\\xB0 in 1 hour(60 minutes) , so in 1 minute it will make 360/60 = 6\\xB0.\\n3. Subtract both angles to give absolute value.\\n4. We have to return smallest angle ,so check if its greater than 180\\xB0 then subract it from 360\\xB0.\\nUpvote if it helped!\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144549,
                "title": "c-with-explanation",
                "content": "```\\n    /*\\n     * Solution is to find the angle between hours hand and\\n     * minutes hand, need to see how much hours hand will\\n     * deviate with respect to minute hand.\\n     *\\n     * The hours hand will complete angle of 360 only when it\\n     * completes 12 hours i.e..,\\n     *       360degrees -> 12 hours\\n     *        30degrees -> 1 hour\\n     *\\n     * As we can see tha there is a 30degree deviation in the\\n     * hour hand which corresponds to 0.5degree in 1 minute\\n     *        30degrees -> 1 hour\\n     *        30degress -> 60 minutes\\n     *        0.5degree -> 1 minute\\n     *\\n     * Now lets check the minutes hand, the minutes hand will\\n     * complete 360degree in 60 minutes\\n     *        360degree -> 60 minutes\\n     *         60degree -> 1 minute\\n     *\\n     * Absolute difference of both hours angle and minutes angle\\n     * will give the result.\\n     *\\n     * Base Case:\\n     * If the hour is 12, then hour hand is at 0\\n     * If the hour, minutes < 0 or hour > 12 or min > 60, invalid\\n    */\\n    double angleClock(int hour, int minutes) {\\n        if (hour < 0 || minutes < 0 || hour > 12 || minutes > 60) {\\n            // Invalid input\\n            return 0.0;\\n        }\\n        \\n        // Check if the hour is 12, then hour hand is at 0\\n        if (hour == 12) {\\n            // Replace with zero\\n            hour = 0;\\n        }\\n        \\n        // As minutes hand effects the hours hand, calculate the hour\\n        // angle by including the minutes hand. As angle between the\\n        // hours hand for a minute is known(0.5), hours hand needs\\n        // to be converted to minutes and multiply with 0.5 so that we\\n        // get the total angle\\n        //       (h*60 + m) >> 1\\n        double hoursAngle = (hour * 60 + minutes) * 0.5;\\n        \\n        // Calculate the minutes angle, as we know the angle at each\\n        // minute directly multiple with 6\\n        double minutesAngle = minutes * 6;\\n        \\n        // Get the absolute difference and return\\n        double angle = abs(hoursAngle - minutesAngle);\\n        \\n        // Return the smaller angle of two possible angles\\n        angle = min(360 - angle, angle);\\n        \\n        return angle;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n     * Solution is to find the angle between hours hand and\\n     * minutes hand, need to see how much hours hand will\\n     * deviate with respect to minute hand.\\n     *\\n     * The hours hand will complete angle of 360 only when it\\n     * completes 12 hours i.e..,\\n     *       360degrees -> 12 hours\\n     *        30degrees -> 1 hour\\n     *\\n     * As we can see tha there is a 30degree deviation in the\\n     * hour hand which corresponds to 0.5degree in 1 minute\\n     *        30degrees -> 1 hour\\n     *        30degress -> 60 minutes\\n     *        0.5degree -> 1 minute\\n     *\\n     * Now lets check the minutes hand, the minutes hand will\\n     * complete 360degree in 60 minutes\\n     *        360degree -> 60 minutes\\n     *         60degree -> 1 minute\\n     *\\n     * Absolute difference of both hours angle and minutes angle\\n     * will give the result.\\n     *\\n     * Base Case:\\n     * If the hour is 12, then hour hand is at 0\\n     * If the hour, minutes < 0 or hour > 12 or min > 60, invalid\\n    */\\n    double angleClock(int hour, int minutes) {\\n        if (hour < 0 || minutes < 0 || hour > 12 || minutes > 60) {\\n            // Invalid input\\n            return 0.0;\\n        }\\n        \\n        // Check if the hour is 12, then hour hand is at 0\\n        if (hour == 12) {\\n            // Replace with zero\\n            hour = 0;\\n        }\\n        \\n        // As minutes hand effects the hours hand, calculate the hour\\n        // angle by including the minutes hand. As angle between the\\n        // hours hand for a minute is known(0.5), hours hand needs\\n        // to be converted to minutes and multiply with 0.5 so that we\\n        // get the total angle\\n        //       (h*60 + m) >> 1\\n        double hoursAngle = (hour * 60 + minutes) * 0.5;\\n        \\n        // Calculate the minutes angle, as we know the angle at each\\n        // minute directly multiple with 6\\n        double minutesAngle = minutes * 6;\\n        \\n        // Get the absolute difference and return\\n        double angle = abs(hoursAngle - minutesAngle);\\n        \\n        // Return the smaller angle of two possible angles\\n        angle = min(360 - angle, angle);\\n        \\n        return angle;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1098587,
                "title": "java-easy-solution-runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\n\\npublic double angleClock(int hour, int minutes) \\n    {\\n        double m=0;\\n        m=minutes*6;\\n        double h=hour%12;;\\n        h=(h*30)+(minutes*0.5);\\n        double angle = Math.abs(m - h);\\n        \\n        if((angle)>180)\\n          return (360-angle);\\n        else\\n             return (angle);\\n\\t\\t\\t }\\n",
                "solutionTags": [],
                "code": "```\\n\\npublic double angleClock(int hour, int minutes) \\n    {\\n        double m=0;\\n        m=minutes*6;\\n        double h=hour%12;;\\n        h=(h*30)+(minutes*0.5);\\n        double angle = Math.abs(m - h);\\n        \\n        if((angle)>180)\\n          return (360-angle);\\n        else\\n             return (angle);\\n\\t\\t\\t }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1013332,
                "title": "python-simulation-math",
                "content": "```py\\n\\'\\'\\'\\nsimulation + math\\nh: 1 hour: hour hand: 360/12 + 30/60*minutes\\n           minute hand 360/60\\n\\'\\'\\'\\n\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        mDegree = 360/60 * minutes\\n        hDegree = 360/12 * hour + 360/(60*12)*minutes\\n\\n        return min(abs(mDegree-hDegree), 360-abs(mDegree-hDegree))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n\\'\\'\\'\\nsimulation + math\\nh: 1 hour: hour hand: 360/12 + 30/60*minutes\\n           minute hand 360/60\\n\\'\\'\\'\\n\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        mDegree = 360/60 * minutes\\n        hDegree = 360/12 * hour + 360/(60*12)*minutes\\n\\n        return min(abs(mDegree-hDegree), 360-abs(mDegree-hDegree))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1000569,
                "title": "c-0ms-math-two-solution-with-comments",
                "content": "if this isnt simply, we can separate ... and have second solution \\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ang = abs((h%12)*30 - m*5.5);\\n      return min (ang , 360 - ang); \\n    }\\n};\\n```\\n_____________\\n\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ah = (h%12)*30 + m*0.5;             //calculate angle of hours hand\\n      double am = m*6.0;                         //calculate angle of minutes hand\\n      double ang;\\n      if(ah > am) ang = ah - am;                 //calculate angle beetween minutes hand and hours hand\\n      else ang = am - ah;\\n      \\n      if(ang>180) ang = 360 - ang;               //if our angle isnt sharp\\n      return ang;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ang = abs((h%12)*30 - m*5.5);\\n      return min (ang , 360 - ang); \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n      double ah = (h%12)*30 + m*0.5;             //calculate angle of hours hand\\n      double am = m*6.0;                         //calculate angle of minutes hand\\n      double ang;\\n      if(ah > am) ang = ah - am;                 //calculate angle beetween minutes hand and hours hand\\n      else ang = am - ah;\\n      \\n      if(ang>180) ang = 360 - ang;               //if our angle isnt sharp\\n      return ang;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922724,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        \\n        if(hour==12)\\n            hour=0;\\n        double min=minutes*6.0;\\n        double hrs=hour*30.0+minutes*0.5;\\n        double diff=Math.abs(min-hrs);\\n        if(diff>180)\\n        {\\n            return 360-diff;\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        \\n        if(hour==12)\\n            hour=0;\\n        double min=minutes*6.0;\\n        double hrs=hour*30.0+minutes*0.5;\\n        double diff=Math.abs(min-hrs);\\n        if(diff>180)\\n        {\\n            return 360-diff;\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803854,
                "title": "python-3-explanation",
                "content": "* We can break this question down into two separate functions:\\n1. `getMinuteAngle`: For a given `minutes` value, what is the angle from the 0 position to where the minute hand is.\\n2. `getHourAngle`: For a given `minutes` **and** `hours` value, what is the angle from the 0 position to where the hour hand is.\\n\\t * We need to factor in both the `minutes` and `hours` values for the hours hand since it moves a little bit for each minute that goes by.\\n* For `getMinuteAngle`, we calculate the angle between the 0 position and one minute \\'notch\\' on the clock as `360 / 60 == 6`.\\n\\t* We then multiply this by however many `minutes` we have.\\n* For `getHourAngle`, we calculate the angle between the 0 position and one hour \\'noth\\' on the clock as `360 / 12 == 30`.\\n\\t* We also need to calculate the `minuteOffsetAngle`, which is the fractional amount the hour hand moves for each passing minute.\\n\\t* This value is the proportion of `oneHourAngle` multiplied by how many minutes in a total hour have passed.\\n\\t* In our return statement we need to be sure to modulo the `hour` value by `12` since a clock can represent 24 hours by looping around the clock twice.\\n* After we have both the `minuteAngle` and the `hourAngle`, we calculate the `angleDifference` as an `abs`olute value, and return the smaller angle in the circle using a ternary operator.\\n```\\nclass Solution:\\n    \\n    def getMinuteAngle(self, minutes: int) -> int:\\n        oneMinuteAngle = 6\\n        \\n        return minutes * oneMinuteAngle\\n    \\n    def getHourAngle(self, hour: int, minutes: int) -> float:\\n        oneHourAngle = 30\\n        minuteOffsetAngle = oneHourAngle * (minutes / 60)\\n        \\n        return ((hour % 12) * oneHourAngle) + minuteOffsetAngle\\n    \\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = self.getMinuteAngle(minutes)\\n        hourAngle = self.getHourAngle(hour, minutes)\\n\\n        angleDifference = abs(hourAngle - minuteAngle)\\n        return angleDifference if angleDifference <= 180 else 360 - angleDifference\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def getMinuteAngle(self, minutes: int) -> int:\\n        oneMinuteAngle = 6\\n        \\n        return minutes * oneMinuteAngle\\n    \\n    def getHourAngle(self, hour: int, minutes: int) -> float:\\n        oneHourAngle = 30\\n        minuteOffsetAngle = oneHourAngle * (minutes / 60)\\n        \\n        return ((hour % 12) * oneHourAngle) + minuteOffsetAngle\\n    \\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = self.getMinuteAngle(minutes)\\n        hourAngle = self.getHourAngle(hour, minutes)\\n\\n        angleDifference = abs(hourAngle - minuteAngle)\\n        return angleDifference if angleDifference <= 180 else 360 - angleDifference\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786183,
                "title": "c-0ms-solution-using-formula",
                "content": "```\\n double a1,a2;\\n        a1=(double)(11*minutes)/2;\\n        a1=a1-(30*hour);\\n        a1=abs(a1);\\n        a2=abs(360-a1);\\n        if(a1<a2)\\n            return a1;\\n        else\\n            return a2;\\n```",
                "solutionTags": [],
                "code": "```\\n double a1,a2;\\n        a1=(double)(11*minutes)/2;\\n        a1=a1-(30*hour);\\n        a1=abs(a1);\\n        a2=abs(360-a1);\\n        if(a1<a2)\\n            return a1;\\n        else\\n            return a2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784649,
                "title": "simple-java-solution-0ms-beat-100",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if(hour<1 || hour >12 || minutes <0 || minutes >59) return -1;\\n        double handle1 = (double) hour + (double)minutes/60;\\n        double handle2 = (double)minutes / 60 * 12;\\n\\n        double res = Math.abs(handle1 - handle2) / 12 * 360;\\n        if(res > 180) res = 360 - res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if(hour<1 || hour >12 || minutes <0 || minutes >59) return -1;\\n        double handle1 = (double) hour + (double)minutes/60;\\n        double handle2 = (double)minutes / 60 * 12;\\n\\n        double res = Math.abs(handle1 - handle2) / 12 * 360;\\n        if(res > 180) res = 360 - res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758827,
                "title": "clear-python-solution-faster-than-98",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = 6 * minutes\\n        hourAngle = (hour % 12) * 30\\n        add = minutes * 0.5\\n        hourAngle += add\\n        angle = abs(hourAngle - minuteAngle)\\n        return min(angle, 360 - angle)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        minuteAngle = 6 * minutes\\n        hourAngle = (hour % 12) * 30\\n        add = minutes * 0.5\\n        hourAngle += add\\n        angle = abs(hourAngle - minuteAngle)\\n        return min(angle, 360 - angle)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 742053,
                "title": "java-solution-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double h_ang, minu_ang, angle=0.0;\\n        minu_ang = (minutes % 60) * 6;\\n        h_ang = (hour % 12) * 30 + minutes * 0.5;\\n        angle = Math.abs(h_ang - minu_ang);\\n      \\n        if(angle>180)\\n         angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double h_ang, minu_ang, angle=0.0;\\n        minu_ang = (minutes % 60) * 6;\\n        h_ang = (hour % 12) * 30 + minutes * 0.5;\\n        angle = Math.abs(h_ang - minu_ang);\\n      \\n        if(angle>180)\\n         angle = 360 - angle;\\n        \\n        return angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 737105,
                "title": "simple-java-math-solution",
                "content": "*Check out this desmos playground to visualize the graph :)*\\n***https://www.desmos.com/calculator/n7xtljtues***\\n\\nA full circle has `360 degrees` - and `60 minutes`. `360/60 = 6`\\n*Every minute* is **6 degrees clockwise for the minute hand**. \\n\\nEvery `hour` moves the hour-hand over `5` ticks, or `5 * 6 = 30 degrees`. \\nSo, *every minute* is **1/60 of an hour, or 30/60 degrees = .5 degrees clockwise for the hour hand**.\\n\\nSo, as time moves forward each minute, the angle grows by `5.5 degrees`(because 6 - 0.5 = 5.5). When the value goes over `180`, you take the extra and count backward. \\nStarting from `12:00`, or `0 degrees`, you can simply count forward by `5.5`. Ex: When the value reaches `181.5`, you take the shorter angle: `180 - 1.5 = 178.5`\\n\\n```\\n//hour * 60 gives us the number of ticks forward from the hour\\n//minutes tells us how many additional ticks forward\\n//multiply by 5.5 degrees per tick\\n//mod by 360 because it doesn\\'t matter if it\\'s rotated a full circle\\n//use min to get the smaller of the 2 angles formed\\n\\ndouble b = (((hour % 12) * 60 + minutes) * 5.5) % 360;\\nreturn Math.min(b, 360 - b);\\n```\\nThe `hour % 12` is so that 12:00 is treated as the beginning, aka 0 steps forward in time, rather than the end, 720 steps forward in time.\\n\\nAnother thing to note is that there are 361 unique outputs for this function, so you could easily precompute all the values, and store them if this method was going to be called many many times. The possible output values are `[0, 180]` *in steps of* `0.5`\\n\\nAdditionally, if you\\'re allowing complex numbers, you can use the following function to directly compute the result with all arithmetic:\\n![image](https://assets.leetcode.com/users/images/cdfe5fe3-28ba-4229-a9dd-f440093a0d3d_1594795935.0496445.png)\\n\\n`Re` means only the `real` portion of the complex number, and `Im` means only the imaginary part.\\n\\nThe input `x` is the number of minutes since the angle between the hands was `0 degrees`. The graph of the function looks like this:\\n![image](https://assets.leetcode.com/users/images/4b1cb2af-ada0-41ce-bd98-d0c63711f672_1594794620.6631007.png)\\n\\nCheck out this desmos playground to visualize the graph :)\\nhttps://www.desmos.com/calculator/n7xtljtues\\n<iframe src=\"https://www.desmos.com/calculator/n7xtljtues?embed\" width=\"500px\" height=\"500px\" style=\"border: 1px solid #ccc\" frameborder=0></iframe>",
                "solutionTags": [],
                "code": "```\\n//hour * 60 gives us the number of ticks forward from the hour\\n//minutes tells us how many additional ticks forward\\n//multiply by 5.5 degrees per tick\\n//mod by 360 because it doesn\\'t matter if it\\'s rotated a full circle\\n//use min to get the smaller of the 2 angles formed\\n\\ndouble b = (((hour % 12) * 60 + minutes) * 5.5) % 360;\\nreturn Math.min(b, 360 - b);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736991,
                "title": "logical-solution-over-optimized-solution",
                "content": "The first thing we want to do is map minutes to degrees. A simple way to logically do so is to solve for the ratio D in the proportion:\\nD = 360deg/60min = 6deg/1min;\\n\\nThen, x minutes in degrees is represented by:\\nM(x) = (x)min * D \\n\\t\\t = (x)min * (6)deg/min\\n\\t\\t = (6x)deg\\n\\nGiven that 5 minute increments also correspond to one hour on the clock:\\nM(5) = (6(5))deg\\n\\t\\t= 30deg;\\n\\nThe ith hour in degrees can be found by:\\nH_base(i) = i * 30deg;\\n\\nTo find the hour hand\\'s actual offset from it\\'s base:\\nH_offset(m) = M(5) * (M(m) / 360deg)\\n\\t\\t\\t\\t\\t= 30deg * ((6m)deg / 360deg)\\n\\t\\t\\t\\t\\t= 30deg * 6m/360\\n\\t\\t\\t\\t\\t= (m/2)deg\\n\\nThe total displacement, therefore, is:\\nH(h, m) = H_base(h) + H_offset(m)\\n\\t\\t\\t = h * 30deg + (m/2)deg\\n\\t\\t\\t = (30h + m/2)deg\\n\\nNow that we have H(h,m) and M(m), we can take the absolute value of their difference:\\nLet L = ABS(m - h).\\nBasically, the distance between the minute and hour hands is the angle, and that distance has to be positive.\\n\\nThe last requirement is that we take the smaller of the two resulting angles:\\nMIN (L, 360 - L)\\n\\nSo, in code:\\n\\n```\\nclass Solution {\\n#define M(m) 6 *m\\n#define H_base(h) h * 30\\n#define H_offset(m) (double)m / 2\\n#define H(h, m) H_base(h) + H_offset(m)\\npublic:\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble M = M(minutes);\\n\\t\\tdouble H = H(hour, minutes);\\n\\t\\tdouble L = abs(M - H);\\n\\t\\treturn min(L, 360 - L);\\n    }\\n};\\n```\\n### Below are unnecessary optimizations, especially considering that this problem is \\'locked\\' now. I also assume the reader\\'s familiarity with algebra and C/C++\\nI considered two optimizations, both based on refactoring the expression, abs(M - H), which expands to: \\n```\\n\\tabs( 6 * minutes - (30 * hour + (minutes / 2) ) );\\n```\\nWith some algebra, we can bring the arithmetic operations down to 1 SUB and 2 MULT (the compiler knows to make (double)11/2 a constant. To skip the explicit cast, you can write it as a literal, 5.5):\\n```\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble L = abs(5.5*minutes - 30.0*hour);\\n\\t\\treturn L > 180 ? 360 - L : L;\\n\\t}\\n```\\nWhile this alone might seem like the most optimal solution, the corresponding assembler output (clang++-9, -O1) will show many conversions and move operations that exist just because the abs function takes a double instead of an integer. So, maybe we can do better by refactoring the abs(M-H) expression so that M-H remains an integer? Yes:\\n```\\n\\tdouble L = abs(11*minutes - 60*hour) * 0.5;\\n```\\nEven further, we can keep the result of abs as an int and delay the conversion to a double (that happens when multiplying by 0.5) until after the final conditional statement:\\n```\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n```\\nIn order to allow the L * 0.5 expression to become the function\\'s last instructions, we double the constants, 180 and 360, to return the correct values. If you looked at the compiler output, you would\\'ve been able to see that the constants 180 and 360 had to be moved into XMM registers to compare against L when it was a double. Now that L is an int, the new constants (360 and 720) are immediate operands to the instructions. Here is a CE link to a comparison of this change: https://godbolt.org/z/YMWWaz\\n\\nBasically, the premise of the optimizations comes from a general rule to minimize data conversions.\\n# Optimized Solution:\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define M(m) 6 *m\\n#define H_base(h) h * 30\\n#define H_offset(m) (double)m / 2\\n#define H(h, m) H_base(h) + H_offset(m)\\npublic:\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble M = M(minutes);\\n\\t\\tdouble H = H(hour, minutes);\\n\\t\\tdouble L = abs(M - H);\\n\\t\\treturn min(L, 360 - L);\\n    }\\n};\\n```\n```\\n\\tabs( 6 * minutes - (30 * hour + (minutes / 2) ) );\\n```\n```\\n    double angleClock(int hour, int minutes) {\\n\\t\\tdouble L = abs(5.5*minutes - 30.0*hour);\\n\\t\\treturn L > 180 ? 360 - L : L;\\n\\t}\\n```\n```\\n\\tdouble L = abs(11*minutes - 60*hour) * 0.5;\\n```\n```\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int L = abs(11*minutes - 60*hour);\\n        return (L > 360 ? 720 - L : L) * 0.5;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736893,
                "title": "java-solution-angle-between-hands-of-a-clock-0-ms-beat-100-5-lines-easy-to-understand",
                "content": "* Consider the clock as a 360 degree circle\\n* Each minute as a 6 degree leap, thus 60 minutes -> 360 degrees\\n* And each hour is a 30 degree leap, thus 12 hours -> 360 degrees\\n* Given the hour and minutes, calculate the respective angles\\n* Return the minimum of the diff and 360 - diff.\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int minuteAngle = minutes*6;\\n        double hourAngle = hour == 12 ? 0 : hour*30;\\n        hourAngle += ((minuteAngle*30)/360.0);\\n        double angle = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(360 - angle, angle);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        int minuteAngle = minutes*6;\\n        double hourAngle = hour == 12 ? 0 : hour*30;\\n        hourAngle += ((minuteAngle*30)/360.0);\\n        double angle = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(360 - angle, angle);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736818,
                "title": "python-easy-solution",
                "content": "Just see if hour hand is ahead of minutes hand in clockwise direction.\\n```\\ndef angleClock(self, hour: int, minutes: int) -> float:\\n        mins_diff = (hour%12)*5 - minutes\\n        if mins_diff < 0:\\n            angle = abs(abs(mins_diff)*6 - minutes*0.5)\\n            return min(angle, 360-angle)\\n        else:\\n            angle = mins_diff*6 + minutes*0.5\\n            return min(angle, 360-angle)\\n```",
                "solutionTags": [],
                "code": "```\\ndef angleClock(self, hour: int, minutes: int) -> float:\\n        mins_diff = (hour%12)*5 - minutes\\n        if mins_diff < 0:\\n            angle = abs(abs(mins_diff)*6 - minutes*0.5)\\n            return min(angle, 360-angle)\\n        else:\\n            angle = mins_diff*6 + minutes*0.5\\n            return min(angle, 360-angle)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 736731,
                "title": "python-3-lines",
                "content": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        m = minutes*6\\n        h = hour*30 + float(minutes*30)/60\\n    \\n        return min(abs(m-h), 360-abs(m-h))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        m = minutes*6\\n        h = hour*30 + float(minutes*30)/60\\n    \\n        return min(abs(m-h), 360-abs(m-h))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736695,
                "title": "c-avoids-double-arithmetic-almost",
                "content": "Since calculations using doubles are more inefficient than ints, we keep the angles in half-degrees(0-720 instead of 0-360) until the very end.\\n\\nRemove unnecessary addition in delta calculation which should look like this:\\n```var delta = (hour == 12 ? 0 : hour * 60) + minutes - (minutes * 12);```\\nBut can be reduced to the line below.\\n\\nAvoids using Math.Abs\\n\\n```\\n    public double AngleClock(int hour, int minutes) {\\n        var delta = (hour == 12 ? 0 : hour * 60) - (minutes * 11);\\n        if (delta < 0) delta += 720;\\n        if (delta > 360) delta = 720 - delta;\\n        return delta / 2D;\\n    }\\n```",
                "solutionTags": [],
                "code": "```var delta = (hour == 12 ? 0 : hour * 60) + minutes - (minutes * 12);```\n```\\n    public double AngleClock(int hour, int minutes) {\\n        var delta = (hour == 12 ? 0 : hour * 60) - (minutes * 11);\\n        if (delta < 0) delta += 720;\\n        if (delta > 360) delta = 720 - delta;\\n        return delta / 2D;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736596,
                "title": "c-angle-between-h-and-m-with-proof-and-explaination",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        /*\\n        \\n        total clock is divided into 12 sectors with 30 degree angle each as (360/12)=30\\n        \\n        each sector contributes 5 minutes so ->  30/5 = 6 degrees on each minute\\n        \\n        30*(hour%12) because we will calculate the shift with respect to 12 hour hand\\n        \\n        if some x minutes  past then how much does this contribute the hour hand rotation ? \\n        \\n        well, for 60 minutes it will turn 30 deg\\n        \\n            then for x minutes it will turn 30*x/60= x/2;\\n        \\n        so that is it take the difference of hour and minute hand then check which is minimum clockwise or anti             clockwise \\n        \\n        \\n        Please upvote if i was able to explain well  :-)\\n        \\n        */\\n        \\n        \\n        \\n        double ans= abs(30*(hour%12) + minutes/2.0 - 6*(minutes));\\n        \\n        \\n        return min(360-ans,ans);        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        /*\\n        \\n        total clock is divided into 12 sectors with 30 degree angle each as (360/12)=30\\n        \\n        each sector contributes 5 minutes so ->  30/5 = 6 degrees on each minute\\n        \\n        30*(hour%12) because we will calculate the shift with respect to 12 hour hand\\n        \\n        if some x minutes  past then how much does this contribute the hour hand rotation ? \\n        \\n        well, for 60 minutes it will turn 30 deg\\n        \\n            then for x minutes it will turn 30*x/60= x/2;\\n        \\n        so that is it take the difference of hour and minute hand then check which is minimum clockwise or anti             clockwise \\n        \\n        \\n        Please upvote if i was able to explain well  :-)\\n        \\n        */\\n        \\n        \\n        \\n        double ans= abs(30*(hour%12) + minutes/2.0 - 6*(minutes));\\n        \\n        \\n        return min(360-ans,ans);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736594,
                "title": "faster-than-100-java",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n    \\n        double minuteAngle = (360/60)*minutes;\\n        double hourAngle = (360/12)*hour + minutes * (30.0/60.0);\\n        \\n        return Math.min(Math.abs(hourAngle-minuteAngle), 360-Math.abs(hourAngle-minuteAngle));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n    \\n        double minuteAngle = (360/60)*minutes;\\n        double hourAngle = (360/12)*hour + minutes * (30.0/60.0);\\n        \\n        return Math.min(Math.abs(hourAngle-minuteAngle), 360-Math.abs(hourAngle-minuteAngle));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736545,
                "title": "c-simple-oneliner-explained-100-time-95-space",
                "content": "In order to solve it in one line, I used the trick to declare an extra variable (`diff`) as a parameter.\\n\\nIn the body of my function, I then used the parentheses to assign it the result of my operation and then just use its result for the conditional of the ternary operator, whose clauses were now just using the updated value of `diff`.\\n\\nFor the math, I just grouped: the angle formed by the hours is computed as `h * 30 + m / 2.0`, since each full hour can only take `1 / 12` of the whole clock, so `360 / 12 == 30`, plus the portion matching how many minutes have passed since the last \"o\\'clock\" moment, ie: `m * 30 / 60.0 == m / 2.0`. For the minutes is even easier: each minute equates to `360 / 60`, that is to say, `6` degrees.\\n\\nYou end up having `h * 30 + m / 2.0 - m * 6` or, if you group another bit: `h * 30.0 - m * 11 / 2.0`.\\n\\nFinally, if the difference is bigger than half a circle (`180` degreess), then I take the smaller angle, computed as `360 - diff`; if it is smaller, I just take `diff` directly :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double diff = 0) {\\n        return (diff = abs(h * 30.0 - m * 11 / 2.0)) > 180 ? 360 - diff : diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double diff = 0) {\\n        return (diff = abs(h * 30.0 - m * 11 / 2.0)) > 180 ? 360 - diff : diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736198,
                "title": "angle-between-hands-o-a-clock-answer-using-formula",
                "content": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double x =abs((11/2.0)*minutes-30*hour);\\n        if(x<180)\\n            return x;\\n        else\\n            return 360-x;\\n    }\\n};\\n\\nuse   angle=|(11/2.0)*minutes-30 * hour |\\nif angle>180 then 360-angle is the answer.\\nelse\\nangle is the answer.",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double x =abs((11/2.0)*minutes-30*hour);\\n        if(x<180)\\n            return x;\\n        else\\n            return 360-x;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 736142,
                "title": "easiest-mathematical-explanation-with-4-line-readable-java-code",
                "content": "For **minutes angle** - \\n60 minutes = 360 angle\\ngiven minutes = ? angle\\n**minutesAngle = minutes\\\\*360/60 = minutes\\\\*6**\\n\\nFor **hour angle** - \\n1 hours = 30 angle\\ngiven hours = ? angle\\n**hourAngle = hour*30 + (angle due to minutes)**\\n**Exception :** for hour 12, hour angle will be 0 and total angle will be only due to minutes.\\n\\nFor **angle due to minutes** -\\n60 minutes = 30 angle\\ngiven minutes = ? angle\\n**angle due to minutes = minutes*30/60 = minutes/2**\\n```\\nclass Solution {\\n    public double angleClock(int hour, int min) {\\n        double minutes = min, minuteAngle=minutes*6;   //minutes variable is only for converting minutes to double from int\\n        double hoursAngle = (hour==12) ? minutes/2 : (hour*30)+(minutes/2);\\n        double angle = Math.abs(minuteAngle-hoursAngle);   //difference between both angles\\n        return angle>180 ? 360-angle : angle;   // for minimum angle, if angle is greater than 180, subtract it from 360\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int min) {\\n        double minutes = min, minuteAngle=minutes*6;   //minutes variable is only for converting minutes to double from int\\n        double hoursAngle = (hour==12) ? minutes/2 : (hour*30)+(minutes/2);\\n        double angle = Math.abs(minuteAngle-hoursAngle);   //difference between both angles\\n        return angle>180 ? 360-angle : angle;   // for minimum angle, if angle is greater than 180, subtract it from 360\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 736042,
                "title": "angle-between-hands-of-a-clock-clean-java-code",
                "content": "```\\nclass Solution {\\n    \\n    final double MIN_P_H     = 5.0;\\n    final double CIRCLE      = 360.0;\\n    final double SEMI_CIRCLE = 180.0;\\n    final double HOURS       = 12.0;\\n    final double MINUTES     = 60.0;\\n    final double DEGREE_P_H  = 30.0;\\n    \\n    public double angleClock(int hour, int minutes) {\\n        if(minutes == hour/MIN_P_H) return 0.0;\\n        \\n        double result = 0.0;\\n        \\n        double minutes_d = degreeOfMin(minutes);\\n        double hour_d    = degreeOfHour(hour, minutes);\\n        result = Math.abs(minutes_d - hour_d);\\n        \\n        if(result > SEMI_CIRCLE) result = Math.abs(result - CIRCLE);\\n        return result;\\n    }\\n    \\n    private double degreeOfMin(int m){\\n        if(m == 0) return 0.0;\\n        \\n        double minutes_ratio = m / MINUTES;\\n        return minutes_ratio * CIRCLE;\\n    }\\n    \\n    private double degreeOfHour(int h, int m){\\n        if(h == HOURS && m == 0) return 0.0;\\n        \\n        double hours_ratio = h / HOURS;\\n        double minutes_ratio = m / MINUTES;\\n        double hours_degree = (hours_ratio * CIRCLE) + (minutes_ratio * DEGREE_P_H);\\n        \\n        if(hours_degree > CIRCLE) hours_degree -= CIRCLE;\\n        return hours_degree;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    final double MIN_P_H     = 5.0;\\n    final double CIRCLE      = 360.0;\\n    final double SEMI_CIRCLE = 180.0;\\n    final double HOURS       = 12.0;\\n    final double MINUTES     = 60.0;\\n    final double DEGREE_P_H  = 30.0;\\n    \\n    public double angleClock(int hour, int minutes) {\\n        if(minutes == hour/MIN_P_H) return 0.0;\\n        \\n        double result = 0.0;\\n        \\n        double minutes_d = degreeOfMin(minutes);\\n        double hour_d    = degreeOfHour(hour, minutes);\\n        result = Math.abs(minutes_d - hour_d);\\n        \\n        if(result > SEMI_CIRCLE) result = Math.abs(result - CIRCLE);\\n        return result;\\n    }\\n    \\n    private double degreeOfMin(int m){\\n        if(m == 0) return 0.0;\\n        \\n        double minutes_ratio = m / MINUTES;\\n        return minutes_ratio * CIRCLE;\\n    }\\n    \\n    private double degreeOfHour(int h, int m){\\n        if(h == HOURS && m == 0) return 0.0;\\n        \\n        double hours_ratio = h / HOURS;\\n        double minutes_ratio = m / MINUTES;\\n        double hours_degree = (hours_ratio * CIRCLE) + (minutes_ratio * DEGREE_P_H);\\n        \\n        if(hours_degree > CIRCLE) hours_degree -= CIRCLE;\\n        return hours_degree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735918,
                "title": "python-readable-solution",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if hour == 12:\\n            hour = 0\\n        time_minutes = hour*60 + minutes\\n        hour_angle = (time_minutes * 360) / (12*60)\\n        minute_angle = (minutes * 360) / 60\\n        ans = abs(minute_angle - hour_angle)\\n        if ans > 180:\\n            ans = 360 - ans\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if hour == 12:\\n            hour = 0\\n        time_minutes = hour*60 + minutes\\n        hour_angle = (time_minutes * 360) / (12*60)\\n        minute_angle = (minutes * 360) / 60\\n        ans = abs(minute_angle - hour_angle)\\n        if ans > 180:\\n            ans = 360 - ans\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735846,
                "title": "c-just-1-line-easy-peasy-japanesey",
                "content": "For every one hour, the bigger hand rotates by 30\\xB0. And for every minute past that hour, the bigger hand further rotates by 0.5\\xB0. The minute hand rotates at 6\\xB0 per minute. Return the difference between both the hands. \\n```\\ndouble angleClock(int hour, int minutes)\\n        return min(abs(hour*30 - minutes*5.5), 360-abs(hour*30 - minutes*5.5));\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\ndouble angleClock(int hour, int minutes)\\n        return min(abs(hour*30 - minutes*5.5), 360-abs(hour*30 - minutes*5.5));\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735783,
                "title": "java-o-1-math-formula",
                "content": "Explanation: For the hours, you have 12 different values. For the minutes you have 60 different values. You can then divide 360 degrees into 12 parts for the hours (result is 30), and divide 360 degrees into 60 parts for the minutes (result: 6).\\n\\nNow you can easily calculate how many degrees there are between the beginning of each pointer and their current position. For the hours it would be `30*hours` and for the minutes it would be `6*minutes`. But be careful! The hour pointer can be anywhere between the current and the next hour, so you can\\'t just take the hours value, you need to use the minutes to calculate where, in between the current and the next hour, the pointer is. You do that by using `30 * (hours + minutes/60)`.\\n\\nNow, in order to calculate the angle between, you take the difference between the two calculated degrees. Beware that the result can be negative, as you won\\'t know which pointer is ahead of the other, so you take the absolute value of that difference. Also, you do not know if you calculated the bigger or the smaller angle, so you do take the minimum between the calculated angle and its complement: `min(calculated,360-calculated)`.\\n\\nThe formula can then be worked.\\n1. `| 6minutes - 30 * (hours + minutes/60) |`\\n2. `| 6minutes - 30hours - 30minutes/60 |`\\n3. `| 6minutes - 30hours - minutes/2 |`\\n4. `| 12minutes/2 - 60hours/2 - minutes/2 |`\\n5. `| 11minutes/2 - 60hours/2 |`\\n6. `| (11minutes - 60hours)/2 |`\\n\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double a = Math.abs((11*minutes - 60*hour)/2.0);\\n        return Math.min(a,360-a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double a = Math.abs((11*minutes - 60*hour)/2.0);\\n        return Math.min(a,360-a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735712,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double diff = (minutes/60.0)*30;\\n        \\n        double hourHand = hour * 30 + diff;\\n        double minuteHand = minutes * 6;\\n        \\n        double ans = hourHand - minuteHand;\\n        if(ans < 0){\\n            ans = -ans;\\n        }\\n        if(ans > 180){\\n            ans = 360 - ans;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        \\n        double diff = (minutes/60.0)*30;\\n        \\n        double hourHand = hour * 30 + diff;\\n        double minuteHand = minutes * 6;\\n        \\n        double ans = hourHand - minuteHand;\\n        if(ans < 0){\\n            ans = -ans;\\n        }\\n        if(ans > 180){\\n            ans = 360 - ans;\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735664,
                "title": "go-0ms-faster-than-100",
                "content": "```go\\nfunc angleClock(hour int, minutes int) float64 {\\n    hour %= 12\\n    ma, ha := 360.0/60.0*float64(minutes), 360.0/12.0*float64(hour) + 360.0/12.0*float64(minutes)/60.0\\n    a := math.Max(ma, ha) - math.Min(ma, ha)\\n    \\n    if a > 180.0 {\\n        return 360.0 - a\\n    }\\n    \\n    return a\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc angleClock(hour int, minutes int) float64 {\\n    hour %= 12\\n    ma, ha := 360.0/60.0*float64(minutes), 360.0/12.0*float64(hour) + 360.0/12.0*float64(minutes)/60.0\\n    a := math.Max(ma, ha) - math.Min(ma, ha)\\n    \\n    if a > 180.0 {\\n        return 360.0 - a\\n    }\\n    \\n    return a\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735651,
                "title": "suddh-desi-math",
                "content": "```\\n public static double angleClock(int hour, int minutes) {\\n\\n        /**\\n         * What do i know :\\n         *\\n         * Total Degrees = 360. For 12 hours\\n         * In 1 hour = 360/12 = 30 degrees.\\n         * In 1 hour(60 minutes) = 30 degree, So 1 minute = 30/60 ==> 1/2;\\n         *\\n         * Now how much hour has moved in corresponding to minute.\\n         * HourDegree = hour * 30 + (minutes/60) * 30;\\n         *\\n         * Or we can also write as\\n         * HourDegree = hour * 30 + minute/2\\n         *\\n         * For Minutes it\\'s simple :\\n         * In 1 minute = 360/60 ==> 6 degree.\\n         *\\n         * So for given minutes\\n         * MinutesDegree = minutes * 6;\\n         *\\n         * Edge case if someone has given time 12:30....we have to consider time from 0 to 11... else 12 * 30 will overshoot\\n         */\\n        double hourDegree = hour * 30 + (minutes / 2d);\\n        double minuteDegree = minutes * 6;\\n\\n        double absoluteDifferenceInDegree = Math.abs(hourDegree - minuteDegree);\\n\\n        return absoluteDifferenceInDegree > 180 ? 360 - absoluteDifferenceInDegree : absoluteDifferenceInDegree;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n public static double angleClock(int hour, int minutes) {\\n\\n        /**\\n         * What do i know :\\n         *\\n         * Total Degrees = 360. For 12 hours\\n         * In 1 hour = 360/12 = 30 degrees.\\n         * In 1 hour(60 minutes) = 30 degree, So 1 minute = 30/60 ==> 1/2;\\n         *\\n         * Now how much hour has moved in corresponding to minute.\\n         * HourDegree = hour * 30 + (minutes/60) * 30;\\n         *\\n         * Or we can also write as\\n         * HourDegree = hour * 30 + minute/2\\n         *\\n         * For Minutes it\\'s simple :\\n         * In 1 minute = 360/60 ==> 6 degree.\\n         *\\n         * So for given minutes\\n         * MinutesDegree = minutes * 6;\\n         *\\n         * Edge case if someone has given time 12:30....we have to consider time from 0 to 11... else 12 * 30 will overshoot\\n         */\\n        double hourDegree = hour * 30 + (minutes / 2d);\\n        double minuteDegree = minutes * 6;\\n\\n        double absoluteDifferenceInDegree = Math.abs(hourDegree - minuteDegree);\\n\\n        return absoluteDifferenceInDegree > 180 ? 360 - absoluteDifferenceInDegree : absoluteDifferenceInDegree;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 735567,
                "title": "c-simple-straightforward-solution-100-00",
                "content": "```\\n// Please, UpVote, if you like it :-)\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble minutesAngle = (360 / 60) * minutes;\\n\\tdouble hoursAngle = (360 / 12) * (hour % 12);\\n\\thoursAngle += (360 / 12) * (minutes / 60.0); // minutes for adding to hours\\n\\tdouble angle = abs(minutesAngle - hoursAngle);\\n\\treturn min(angle, 360 - angle);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Please, UpVote, if you like it :-)\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble minutesAngle = (360 / 60) * minutes;\\n\\tdouble hoursAngle = (360 / 12) * (hour % 12);\\n\\thoursAngle += (360 / 12) * (minutes / 60.0); // minutes for adding to hours\\n\\tdouble angle = abs(minutesAngle - hoursAngle);\\n\\treturn min(angle, 360 - angle);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 735478,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        return min(abs(h*30- 5.5*m), 360-abs(h*30- 5.5*m));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        return min(abs(h*30- 5.5*m), 360-abs(h*30- 5.5*m));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735467,
                "title": "c-simple-maths-0ms-soln-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrNeedle=(hour+(minutes/60.0))*30;\\n        double minNeedle=minutes*6.0;\\n        double diff=abs(hrNeedle-minNeedle);\\n        return min(diff,360.0-diff);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hrNeedle=(hour+(minutes/60.0))*30;\\n        double minNeedle=minutes*6.0;\\n        double diff=abs(hrNeedle-minNeedle);\\n        return min(diff,360.0-diff);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735435,
                "title": "java-3-lines-100-with-0ms",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\t//The absolute degree between two needles.\\n\\t\\t//Minute: 1minute = 6 degrees\\n\\t\\t//Hour: 1hour = 30 degrees\\n\\t\\t//For Hour needle, we take modulus 12 because the degree of 12 o\\'clock is 0.\\n\\t\\t//However the degree of Hour needle needs to take into account the progress\\n\\t\\t// of the Minute needle, which is min/60, with min varies from 0 to 60. During this \\n\\t\\t// progression, the Hour needle can move a total of 30 degrees, that\\'s why we add \\n\\t\\t// 30* min/60 to the Hour needle angle.\\n        double ans=Math.abs(((hour%12)*30+(double)minutes/2)-minutes*6);\\n\\t\\t\\n        if(ans>180)ans=360-ans;\\n\\t\\t//We want the smaller angle.\\n\\t\\t//Math.min() is avoided as it slows down the code.\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n\\t\\t//The absolute degree between two needles.\\n\\t\\t//Minute: 1minute = 6 degrees\\n\\t\\t//Hour: 1hour = 30 degrees\\n\\t\\t//For Hour needle, we take modulus 12 because the degree of 12 o\\'clock is 0.\\n\\t\\t//However the degree of Hour needle needs to take into account the progress\\n\\t\\t// of the Minute needle, which is min/60, with min varies from 0 to 60. During this \\n\\t\\t// progression, the Hour needle can move a total of 30 degrees, that\\'s why we add \\n\\t\\t// 30* min/60 to the Hour needle angle.\\n        double ans=Math.abs(((hour%12)*30+(double)minutes/2)-minutes*6);\\n\\t\\t\\n        if(ans>180)ans=360-ans;\\n\\t\\t//We want the smaller angle.\\n\\t\\t//Math.min() is avoided as it slows down the code.\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 735425,
                "title": "c-solution-in-two-line",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double g=abs(30*hour-5.5*minutes);\\n        return min(g,360-g);\\n    }\\n};\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double g=abs(30*hour-5.5*minutes);\\n        return min(g,360-g);\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 735368,
                "title": "c-4-line-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour+(minutes/60.00))*30.00; // Hour*30 for degrees hour needle has covered + extra degrees covered by hour according to minute.\\n        double minDegree = minutes*6.00; // 1 minute is 6 degrees\\n        \\n        double diff = abs(hourDegree - minDegree);\\n        \\n        return min(diff, 360.00-diff);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hourDegree = (hour+(minutes/60.00))*30.00; // Hour*30 for degrees hour needle has covered + extra degrees covered by hour according to minute.\\n        double minDegree = minutes*6.00; // 1 minute is 6 degrees\\n        \\n        double diff = abs(hourDegree - minDegree);\\n        \\n        return min(diff, 360.00-diff);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724080,
                "title": "100-faster-cpp",
                "content": "```\\n double angleClock(int h, int m) {\\n        double d,x,d1;\\n        if(h==12)\\n            h=0;\\n        d=abs(h*30-5.5*m);\\n        d1=min(d,360-d);\\n        \\n        \\n        return d1;\\n    }\\n\\t",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n double angleClock(int h, int m) {\\n        double d,x,d1;\\n        if(h==12)\\n            h=0;\\n        d=abs(h*30-5.5*m);\\n        d1=min(d,360-d);\\n        \\n        \\n        return d1;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 641291,
                "title": "java-0ms-100",
                "content": "```\\n    public double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n        double tmp = minutes * 1.0 / 60 * 30;\\n        double hourAngle = hour * 30 + tmp;\\n        double minuteAngle = tmp * 12;\\n        double gap = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(gap, 360 - gap);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public double angleClock(int hour, int minutes) {\\n        hour = hour % 12;\\n        double tmp = minutes * 1.0 / 60 * 30;\\n        double hourAngle = hour * 30 + tmp;\\n        double minuteAngle = tmp * 12;\\n        double gap = Math.abs(hourAngle - minuteAngle);\\n        return Math.min(gap, 360 - gap);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 634685,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    if(hour == 12){\\n        hour = 0\\n    }\\n    let min = minutes/5\\n    \\n    let newHour = Math.abs(hour + minutes/60)\\n    let angle = Math.abs(newHour-min)*30\\n    return Math.min((360-angle),angle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    if(hour == 12){\\n        hour = 0\\n    }\\n    let min = minutes/5\\n    \\n    let newHour = Math.abs(hour + minutes/60)\\n    let angle = Math.abs(newHour-min)*30\\n    return Math.min((360-angle),angle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 615354,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) \\n    {\\n        double hourAngle = (hour % 12) * 30 + 1.0 * minutes / 2, minuteAngle = minutes * 6;\\n        return min(abs(hourAngle - minuteAngle), 360 - abs(hourAngle - minuteAngle));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) \\n    {\\n        double hourAngle = (hour % 12) * 30 + 1.0 * minutes / 2, minuteAngle = minutes * 6;\\n        return min(abs(hourAngle - minuteAngle), 360 - abs(hourAngle - minuteAngle));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568481,
                "title": "python-99-one-liner-explained",
                "content": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n        d = abs(h-m)\\n        return d if d<180 else 360 - d\\n```\\n\\nLet\\'s start with a 3 liner. There are a couple catches here.\\n\\n1. if we start from 0, the minutes never go above 60. But the hours can be actually above 12 (like if we get 12:59 - that\\'s almost 1:00), so we need to add minutes to the hours:\\n\\n```\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n```\\n\\nThe hours can go from 0:00 - that\\'s 0 to 12:00 - that\\'s 360 and even higher to 12:59 - that\\'s above 360. So if our hour angle goes above 360 - we need to bring reduce it by 360, that\\'s done by `% 360`\\n\\n3. The angle between the arrows can\\'t be more than 180, so we need to find the diff. We do it in two steps:\\n\\n```\\n        d = abs(h-m)\\n\\t\\treturn d if d<180 else 360 - d\\n```\\n\\nThat looks somewhat random, but there is meaning to it. The angle between arrows is relative and can be measured in two ways - clockwise and counterclockwise. One if those angles is going to be <=180, another one is >=180 . So we need to pick the smaller angle regardless of the direction. The first `abs()` call basically means we don\\'t care if the angle is measured clockwise or counterwise. And the 2nd `if` statement says that we need to pick the smaller one.\\n\\nOk, so where is the one-liner? Here you go, the same code, just re-packaged:\\n\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return d if (d := abs(30*(hour+minutes/60) % 360 - 6*minutes)) <180 else 360 - d\\n ```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n        d = abs(h-m)\\n        return d if d<180 else 360 - d\\n```\n```\\n        h,m = (360*(hour+minutes/60)/12) % 360 , (360*minutes/60) \\n```\n```\\n        d = abs(h-m)\\n\\t\\treturn d if d<180 else 360 - d\\n```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return d if (d := abs(30*(hour+minutes/60) % 360 - 6*minutes)) <180 else 360 - d\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 565039,
                "title": "java-simple-and-easy-to-understand",
                "content": "class Solution {\\n\\n\\tpublic double angleClock(int hour, int minutes) {\\n\\t\\t\\n\\t\\tdouble h = (hour % 12) * 30 + (minutes / 60.0) * 30;\\n\\t\\tdouble m = minutes * 6;\\n\\t\\tdouble abs = Math.abs(h - m);\\n\\n\\t\\treturn abs > 180 ? 360 - abs : abs;\\n\\t}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\tpublic double angleClock(int hour, int minutes) {\\n\\t\\t\\n\\t\\tdouble h = (hour % 12) * 30 + (minutes / 60.0) * 30;\\n\\t\\tdouble m = minutes * 6;\\n\\t\\tdouble abs = Math.abs(h - m);\\n\\n\\t\\treturn abs > 180 ? 360 - abs : abs;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 555054,
                "title": "java-beats-100-time-space",
                "content": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double h_dev = (minutes != 60 && minutes != 0) ? (((double)minutes/60) / 12 ) * 360 : 0;\\n        double h = hour != 12 ? ((double)hour / 12 ) * 360 : 0;\\n        double h_angle_from_12 = h + h_dev;\\n        double m_angle_from_12 = minutes != 60 ? ((double)minutes / 60) * 360 : 0;\\n        \\n        return Math.min(Math.abs(h_angle_from_12 - m_angle_from_12),Math.abs(360 - Math.abs(h_angle_from_12 - m_angle_from_12)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double h_dev = (minutes != 60 && minutes != 0) ? (((double)minutes/60) / 12 ) * 360 : 0;\\n        double h = hour != 12 ? ((double)hour / 12 ) * 360 : 0;\\n        double h_angle_from_12 = h + h_dev;\\n        double m_angle_from_12 = minutes != 60 ? ((double)minutes / 60) * 360 : 0;\\n        \\n        return Math.min(Math.abs(h_angle_from_12 - m_angle_from_12),Math.abs(360 - Math.abs(h_angle_from_12 - m_angle_from_12)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550569,
                "title": "c-one-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return abs((hour % 12) * 30.0 - minutes * 5.5) > 180 ? 360.0 - abs((hour % 12) * 30.0 - minutes * 5.5) : abs((hour % 12) * 30.0 - minutes * 5.5);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return abs((hour % 12) * 30.0 - minutes * 5.5) > 180 ? 360.0 - abs((hour % 12) * 30.0 - minutes * 5.5) : abs((hour % 12) * 30.0 - minutes * 5.5);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549352,
                "title": "java-solution-beats-100-time-space",
                "content": "360 for 12h -> 1 h has 30\\n360 for 60m -> 1 m has 6\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if (hour == 12) hour = 0;\\n\\n        double hh = (hour + minutes * 1.0 / 60) * 30;\\n        double mm = minutes * 6;\\n\\n        double diff = Math.abs(hh - mm);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```\\n\\nMore concise code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double diff = Math.abs(hour * 30 - minutes * 5.5);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        if (hour == 12) hour = 0;\\n\\n        double hh = (hour + minutes * 1.0 / 60) * 30;\\n        double mm = minutes * 6;\\n\\n        double diff = Math.abs(hh - mm);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double diff = Math.abs(hour * 30 - minutes * 5.5);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509782,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nCalculate the degree of the hour hand and the degree of the minute hand.  Return the answer as the difference between these two degrees.\\n\\n**Note:** if this difference is greater-than `180` degrees, then subtract `180` from the answer (ie. it is a smaller degree difference between the two hands on the other side of the clock).  For example, let\\'s say the degree difference is `270`, then `270 - 180 = 90`.  This is the same value as `360 - 270 = 90`.  So we can simply return the minimum of the `answer` and `360 - answer`.\\n\\n**Formulas:**\\n```\\nh = hours\\nm = minutes\\n\\t\\t\\t \\nhour degree = h * 360 / 12 + 30 * m / 60\\n            = h * 30 + m / 2\\n\\nminute degree = m / 60 * 360\\n              = m * 6\\n\\nanswer degree = abs(hour degree - minute degree)\\n              = abs(h * 30 + m / 2 - m * 6)\\n              = abs(h * 30 - m * 5.5)\\n```\\n\\n**Runtime:** O(1)\\n\\n---\\n\\n**Concise Solutions:**\\n\\n*Javascript*\\n```\\nlet angleClock = (h, m) => {\\n    let degree = Math.abs(h * 30 - m * 5.5);\\n    return Math.min(degree, 360 - degree);\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        auto degree = abs(h * 30 - m * 5.5);\\n        return min(degree, 360 - degree);\\n    }\\n};\\n```\\n\\n---\\n\\n**Verbose Solutions:**\\n\\n*Javascript*\\n```\\nlet angleClock = (h, m) => {\\n    if (h == 12)\\n        h = 0;\\n    h = 30 * h + 0.5 * m;\\n    m = 6 * m;\\n    let degree = Math.max(h, m) - Math.min(h, m);\\n    return Math.min(degree, 360 - degree)\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double offset = 1e5) {\\n        if (h == 12)\\n            h = 0;\\n        h = offset * (30 * h + 0.5 * m);\\n        m = offset * (6 * m);\\n        auto degree = max(h, m) - min(h, m);\\n        return min(degree / offset, 360 - degree / offset);\\n    }\\n};\\n```\\n\\n---\\n\\n**Supplemental Notes:**\\n\\n60 minutes for 360 degrees -> 1 minute for every 6 degrees\\n\\n12 hours for 360 degrees -> 1 hour for every 30 degrees\\n\\nwithin that 30 degrees, the minute hand alters the hour hand\\n\\n60 minutes for 30 degrees -> 1 minute for every 0.5 degrees\\n\\nformulas:\\n\\nh = 30 * h + 0.5 * m\\nm = 6 * m\\n\\nexamples:\\n\\nInput: hour = 12, minutes = 30\\nOutput: 165\\n\\nhour = 12 -> degree = 0 + 30 * 0.5 = 15\\nmin = 30 -> degree = 30 * 6 = 180\\n180 - 15 = 165\\n\\nInput: hour = 3, minutes = 30\\nOutput: 75\\n\\nhour = 3 -> degree = 3 * 30 = 90 + 30 * 0.5 = 105\\nmin = 30 -> degree = 30 * 6 = 180\\n180 - 105 = 75\\n\\nInput: hour = 3, minutes = 15\\nOutput: 7.5\\n\\nhour = 3 -> degree = 3 * 30 = 90 + 15 * 0.5 = 97.5\\nmin = 15 -> degree = 15 * 6 = 90\\n97.5 - 80 = 7.5\\n\\nInput: hour = 4, minutes = 50\\nOutput: 155\\n\\nhour = 4 -> degree = 4 * 30 = 120 + 50 * 0.5 = 145\\nmin = 50 -> degree = 50 * 6 = 300\\n300 - 145 = 155",
                "solutionTags": [],
                "code": "```\\nh = hours\\nm = minutes\\n\\t\\t\\t \\nhour degree = h * 360 / 12 + 30 * m / 60\\n            = h * 30 + m / 2\\n\\nminute degree = m / 60 * 360\\n              = m * 6\\n\\nanswer degree = abs(hour degree - minute degree)\\n              = abs(h * 30 + m / 2 - m * 6)\\n              = abs(h * 30 - m * 5.5)\\n```\n```\\nlet angleClock = (h, m) => {\\n    let degree = Math.abs(h * 30 - m * 5.5);\\n    return Math.min(degree, 360 - degree);\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m) {\\n        auto degree = abs(h * 30 - m * 5.5);\\n        return min(degree, 360 - degree);\\n    }\\n};\\n```\n```\\nlet angleClock = (h, m) => {\\n    if (h == 12)\\n        h = 0;\\n    h = 30 * h + 0.5 * m;\\n    m = 6 * m;\\n    let degree = Math.max(h, m) - Math.min(h, m);\\n    return Math.min(degree, 360 - degree)\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    double angleClock(int h, int m, double offset = 1e5) {\\n        if (h == 12)\\n            h = 0;\\n        h = offset * (30 * h + 0.5 * m);\\n        m = offset * (6 * m);\\n        auto degree = max(h, m) - min(h, m);\\n        return min(degree / offset, 360 - degree / offset);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504892,
                "title": "c-very-easy-solution-4-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minute_angle = (360*minutes)/60;\\n        double hour_angle = (hour%12)*30 + (30*(double)minutes)/60;\\n        double ans = abs(minute_angle - hour_angle);\\n        return min(ans,360-ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double minute_angle = (360*minutes)/60;\\n        double hour_angle = (hour%12)*30 + (30*(double)minutes)/60;\\n        double ans = abs(minute_angle - hour_angle);\\n        return min(ans,360-ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503917,
                "title": "java-simple-solution-using-basic-maths",
                "content": "12 hours = 360 degree => 1 hour = 30 degree angle\\n60 minutes =  360 degree => 1 minute = 6 degree angle\\n1hour = 60 minutes => 1 minute = 1/60 hour\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle = Math.abs(30.0 * (hour % 12 + (double) minutes / 60) - 6 * minutes);\\n        return (angle <= 180.0) ? angle : 360 - angle;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double angle = Math.abs(30.0 * (hour % 12 + (double) minutes / 60) - 6 * minutes);\\n        return (angle <= 180.0) ? angle : 360 - angle;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503266,
                "title": "java-4-line-very-simple-code-easy-to-understand",
                "content": "**step1**: compute the clockwise minutess angle difference from \"12\" \\n**step2**: compute the clockwise hours angle difference from \"12\" (which may be influnced by minutes hand)\\n**step3**: compute the absolute difference between the previous diff and return the smaller one: ```min(diff, 360 - diff)```\\n\\n\\n**Code**:\\n```java\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double minAngle = minutes * 6.0;     // Clockwise Angle difference from \"12\"\\n        double hourAngle = (hour % 12) * 30.0 + minutes * 0.5;  // min/60 * 30\\n        double diff = Math.abs(hourAngle - minAngle);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```min(diff, 360 - diff)```\n```java\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double minAngle = minutes * 6.0;     // Clockwise Angle difference from \"12\"\\n        double hourAngle = (hour % 12) * 30.0 + minutes * 0.5;  // min/60 * 30\\n        double diff = Math.abs(hourAngle - minAngle);\\n        return Math.min(diff, 360 - diff);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502810,
                "title": "c-simple-solution",
                "content": "We multiple minutes to 6 (because 360 / 60 = 6), also we transfer haur  to minutes and divide it to 2 (because 360/720 = 0.5).\\n360 total angel in clock\\n60 is minutes in 1 hour \\n720 is 12 hours in minutes\\n```\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble res = 0;\\n\\tdouble minAngle = (double)minutes * 6;\\n\\tdouble hourAngle = ((double)hour * 60 + (double)minutes) / 2;\\n\\tres = abs(hourAngle - minAngle);\\n\\tres = min(res, 360 - res);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble angleClock(int hour, int minutes) {\\n\\tdouble res = 0;\\n\\tdouble minAngle = (double)minutes * 6;\\n\\tdouble hourAngle = ((double)hour * 60 + (double)minutes) / 2;\\n\\tres = abs(hourAngle - minAngle);\\n\\tres = min(res, 360 - res);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502709,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if (hour == 12): \\n            hour = 0\\n        if (minutes == 60): \\n            minutes = 0\\n        hour_angle = 0.5 * (hour * 60 + minutes) \\n        minute_angle = 6 * minutes\\n\\n        angle = abs(hour_angle - minute_angle)  \\n        angle = min(360 - angle, angle) \\n\\n        return angle",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        if (hour == 12): \\n            hour = 0\\n        if (minutes == 60): \\n            minutes = 0\\n        hour_angle = 0.5 * (hour * 60 + minutes) \\n        minute_angle = 6 * minutes\\n\\n        angle = abs(hour_angle - minute_angle)  \\n        angle = min(360 - angle, angle) \\n\\n        return angle",
                "codeTag": "Java"
            },
            {
                "id": 4072348,
                "title": "as-simple-as-you-done-in-your-schooling",
                "content": "# Intuition\\nJust as you done in aptitude\\n\\n# Approach\\nCalcuate minute spaces and thats it....\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int hr_mul=30;\\n        double hr_min_mul=0.5;\\n        int min_mul=6;\\n        double i=hour*hr_mul;\\n        double j=minutes*hr_min_mul;\\n        double k=fmod(i+j,360.0);\\n        double l=minutes*min_mul;\\n        return min(fabs(k - l), 360.0 - fabs(k - l));;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        int hr_mul=30;\\n        double hr_min_mul=0.5;\\n        int min_mul=6;\\n        double i=hour*hr_mul;\\n        double j=minutes*hr_min_mul;\\n        double k=fmod(i+j,360.0);\\n        double l=minutes*min_mul;\\n        return min(fabs(k - l), 360.0 - fabs(k - l));;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046543,
                "title": "python-solution-with-formula",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery minute, the minute hand moves 6 degrees.(because 360/60 = 6 degrees)\\nEvery minute, the hour hand moves half a degree (there are 720 minutes in half a day).\\nSo At h:mm, the hour hand has moved (60h + m) * 0.5 degrees = 30h + m/2\\nThe minute hand is at 6m degrees\\nThe difference between is (30h + m/2) - 6m = 30h - (11/2)m.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo find other angle,we just have to subtract with 360\\ni.e., 360-(30h)+5.5*m\\nFinally return the minimum angle of these angles\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n      a = abs(30*hour-5.5*minutes)\\n      b = abs(360-a)\\n      return b if a>b else a\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n      a = abs(30*hour-5.5*minutes)\\n      b = abs(360-a)\\n      return b if a>b else a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037869,
                "title": "easy-4-line-python3-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_ang = (hour*30+0.5*minutes)%360\\n        min_ang = minutes*6%360\\n        diff =  abs(min_ang - hr_ang)\\n        return min(diff,360-diff)\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        hr_ang = (hour*30+0.5*minutes)%360\\n        min_ang = minutes*6%360\\n        diff =  abs(min_ang - hr_ang)\\n        return min(diff,360-diff)\\n        \\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036069,
                "title": "c-solution-0ms-beats-100",
                "content": "**Explanation:**\\n\\nFirst find the angle that the hour hand makes:\\nThe hour hand will complete 30\\xB0 in one hour and using this we can deduce that if the hour hand moves 30\\xB0 in 1 hour (60 minutes) then it will move 30\\xB0/60 = 0.5\\xB0 in a minute. \\nTherefore, we can say the angle moved by the hour hand `= (30 * hour) + (0.5 * minutes)`.\\n\\nSimilarily, find the angle that the minute hand makes:\\nWe know that the 60 minutes equals one hour and so, minute hand completes 360\\xB0 (one revolution) in 60 minutes. Thus, the minute hand covers 360\\xB0/60 = 6\\xB0 in a minute.\\nTherefore, we can say the angle moved by the minute hand `= (6 * minutes)`.\\n\\nThe total angle between the hands equals to the absolute difference of the two angles.\\nNext, simply check if the angle calculated is greater than 180\\xB0, if so, then to return the smallest angle subtract the angle from 360\\xB0.\\n\\n**Solution:**\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (30*hour)+(0.5*minutes);\\n        double minute_angle = (6*minutes);\\n        double angle = abs(hour_angle - minute_angle);\\n        if(angle > 180) return (double)(360-angle);\\n        return angle;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double hour_angle = (30*hour)+(0.5*minutes);\\n        double minute_angle = (6*minutes);\\n        double angle = abs(hour_angle - minute_angle);\\n        if(angle > 180) return (double)(360-angle);\\n        return angle;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035218,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        // find for minutes\\n        double a = (minutes / 60.0000) * 360.0000;\\n\\n        // find for hour\\n        double b = 0;\\n        if(hour < 12) b = (hour / 12.0000) * 360.0000;\\n\\n        b += (minutes / 60.0000) * 30.0000;\\n \\n        cout << a << \" \" << b << endl;\\n        if(abs(a - b) <= 180)  return abs(a - b);\\n\\n        if(a > 180) return 360 - a + b;\\n        return 360 - b + a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        // find for minutes\\n        double a = (minutes / 60.0000) * 360.0000;\\n\\n        // find for hour\\n        double b = 0;\\n        if(hour < 12) b = (hour / 12.0000) * 360.0000;\\n\\n        b += (minutes / 60.0000) * 30.0000;\\n \\n        cout << a << \" \" << b << endl;\\n        if(abs(a - b) <= 180)  return abs(a - b);\\n\\n        if(a > 180) return 360 - a + b;\\n        return 360 - b + a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4023269,
                "title": "easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes)\\n        {\\n            double total_hour = double(hour) + double(minutes) / 60;\\n\\n           \\t//12 hr -> 360 degrees\\n           \\t//1 hr  -> 30 degress\\n           \\t//x hr  -> x*30;\\n            double angle_hour_hand = total_hour * 30;\\n\\n           \\t//60 min -> 360 degrees\\n           \\t//1 min  -> 6 degrees\\n           \\t//y min  -> y*6\\n\\n            double angle_minute_hand = minutes * 6;\\n            if(angle_hour_hand >= 360)\\n              angle_hour_hand = angle_hour_hand-360;\\n\\n            double result = abs(angle_minute_hand - angle_hour_hand);\\n            if(result > 180)\\n              return 360-result;\\n            return result;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        double angleClock(int hour, int minutes)\\n        {\\n            double total_hour = double(hour) + double(minutes) / 60;\\n\\n           \\t//12 hr -> 360 degrees\\n           \\t//1 hr  -> 30 degress\\n           \\t//x hr  -> x*30;\\n            double angle_hour_hand = total_hour * 30;\\n\\n           \\t//60 min -> 360 degrees\\n           \\t//1 min  -> 6 degrees\\n           \\t//y min  -> y*6\\n\\n            double angle_minute_hand = minutes * 6;\\n            if(angle_hour_hand >= 360)\\n              angle_hour_hand = angle_hour_hand-360;\\n\\n            double result = abs(angle_minute_hand - angle_hour_hand);\\n            if(result > 180)\\n              return 360-result;\\n            return result;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991811,
                "title": "100-beats-cpp-easy-and-simple-solution-with-the-approach",
                "content": "double angleClock(int hour, int minutes) {\\n       if(hour==12)\\n           hour=0;\\n\\t\\t   \\n\\t\\t   /*    12 hour=360;\\n\\t\\t     1hour=30 deg rotate;\\n\\t\\t\\t 60 min=30 deg\\n\\t\\t\\t 1 min=1/2deg;\\n\\t\\t\\t so n minutes=n/2 deg\\n\\t\\t\\t hour=hour+minutes/2deg;\\n\\t\\t\\t */\\n        double h1=(minutes/5.0-0)*30;             \\n        double angle=(hour-0)*30+minutes/2.0;\\n       \\n        return min(abs(angle-h1),360-abs(angle-h1));\\n       \\n        \\n    }",
                "solutionTags": [],
                "code": "double angleClock(int hour, int minutes) {\\n       if(hour==12)\\n           hour=0;\\n\\t\\t   \\n\\t\\t   /*    12 hour=360;\\n\\t\\t     1hour=30 deg rotate;\\n\\t\\t\\t 60 min=30 deg\\n\\t\\t\\t 1 min=1/2deg;\\n\\t\\t\\t so n minutes=n/2 deg\\n\\t\\t\\t hour=hour+minutes/2deg;\\n\\t\\t\\t */\\n        double h1=(minutes/5.0-0)*30;             \\n        double angle=(hour-0)*30+minutes/2.0;\\n       \\n        return min(abs(angle-h1),360-abs(angle-h1));\\n       \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3985725,
                "title": "beats-100-best-and-o-1-time-and-space-complexity",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n        hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n            return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        if(hour==12)\\n        hour=0;\\n        double x=abs((60*hour)-(11*minutes));\\n        if(x/2<=180)\\n            return (x/2);\\n        else\\n            return 360-(x/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978899,
                "title": "clock-angle-direct-formula",
                "content": "# Approach\\nFormula for angle: \\n**angle = (11 / 2) * Minutes - 30 * Hours**\\nIf angle is greater than 180, return 360 - angle\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n- Space complexity: O(1) \\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = Math.abs(5.5 * minutes - 30 * hour);\\n        return ans < 180 ? ans : 360 - ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double angleClock(int hour, int minutes) {\\n        double ans = Math.abs(5.5 * minutes - 30 * hour);\\n        return ans < 180 ? ans : 360 - ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947037,
                "title": "c-1-line",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return min(abs(30.0 * (hour % 12) - 5.5 * minutes), 360 - abs(30.0 * (hour % 12) - 5.5 * minutes));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        return min(abs(30.0 * (hour % 12) - 5.5 * minutes), 360 - abs(30.0 * (hour % 12) - 5.5 * minutes));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943814,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    // calculate one minute angle -> 360deg / 60mins = 6deg\\n    let oneMinuteAngle = 6;\\n\\n    // calculate one hour angle -> 360deg / 12hrs = 30deg\\n    let oneHourAngle = 30;\\n\\n    // Minutes angle\\n    let minutesAngle = oneMinuteAngle * minutes;\\n\\n    // Hour Angle\\n    let hourAngle = (hour % 12 + minutes/60) * oneHourAngle;\\n\\n    let diff = Math.abs(hourAngle - minutesAngle);\\n\\n    return Math.min(diff, 360 - diff);\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} hour\\n * @param {number} minutes\\n * @return {number}\\n */\\nvar angleClock = function(hour, minutes) {\\n    // calculate one minute angle -> 360deg / 60mins = 6deg\\n    let oneMinuteAngle = 6;\\n\\n    // calculate one hour angle -> 360deg / 12hrs = 30deg\\n    let oneHourAngle = 30;\\n\\n    // Minutes angle\\n    let minutesAngle = oneMinuteAngle * minutes;\\n\\n    // Hour Angle\\n    let hourAngle = (hour % 12 + minutes/60) * oneHourAngle;\\n\\n    let diff = Math.abs(hourAngle - minutesAngle);\\n\\n    return Math.min(diff, 360 - diff);\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929774,
                "title": "c-simple-solution",
                "content": "\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = ((double)hour + (double)minutes/60)*30;\\n        ans -= (double)minutes*6;\\n        ans = fabs(ans);\\n        return (ans > 180) ? 360-ans : ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double ans = ((double)hour + (double)minutes/60)*30;\\n        ans -= (double)minutes*6;\\n        ans = fabs(ans);\\n        return (ans > 180) ? 360-ans : ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929196,
                "title": "easiest-two-line-c-solution",
                "content": "# Intuition\\nThere is this formula to calculate angles between hands of the clock.\\nAngles between the hands of the clock=30H-11/2*M.\\nUse this formula in the code.\\n\\n# Approach\\n1) Calculate the value of the angle using the formula. Make sure to include decimal points.\\n\\n2) Next, check if its negative (since, angle cannot be negative).\\n3) If it is negative multiply the angle by -1.\\n\\n4) Now calculate the minimum of the angle and its reflex angle (since, the minimum is considered as the angle of the clock)\\nReturn this answer;\\n\\n5) Use sample test cases to get this logic intuitively.\\n\\n# Complexity\\n- Time complexity:\\n0(1)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double d=30*hour-(11.0/2.0)*minutes;\\n        if(d<0)\\n        d*=-1;\\n        return min(d,360-d);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        double d=30*hour-(11.0/2.0)*minutes;\\n        if(d<0)\\n        d*=-1;\\n        return min(d,360-d);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908900,
                "title": "have-a-look",
                "content": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double h=hour*30 + minutes*0.5;\\n        double m=hour*0 + minutes*6;\\n        \\n        double alpha=abs(h-m);\\n        \\n        return min(alpha,360-alpha);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        double h=hour*30 + minutes*0.5;\\n        double m=hour*0 + minutes*6;\\n        \\n        double alpha=abs(h-m);\\n        \\n        return min(alpha,360-alpha);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881205,
                "title": "one-line-solution-with-explanation",
                "content": "# Approach\\n```\\nminHandDegrees = 360 * minutes/60\\nhourComponent = 360 * hour/12\\nminuteComponent = 360 * 1/12 * minutes/60\\nhourHandDegrees = hourComponent + minuteComponent\\n```\\n\\nIf ```abs(hourHandDegrees - minHandDegrees) > 180``` then min angle is ```360 - abs(hourDeg - minDeg)```.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$.\\n\\n- Space complexity: $$O(1)$$.\\n\\n# Code\\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(d := abs(30*hour - 5.5*minutes), 360 - d)\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nminHandDegrees = 360 * minutes/60\\nhourComponent = 360 * hour/12\\nminuteComponent = 360 * 1/12 * minutes/60\\nhourHandDegrees = hourComponent + minuteComponent\\n```\n```abs(hourHandDegrees - minHandDegrees) > 180```\n```360 - abs(hourDeg - minDeg)```\n```\\nclass Solution:\\n    def angleClock(self, hour: int, minutes: int) -> float:\\n        return min(d := abs(30*hour - 5.5*minutes), 360 - d)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3867306,
                "title": "python-beginner-friendly-solution",
                "content": "# Intuition\\nUse Maths and describe angle at hour hand\\n\\n# Approach\\nFind how much hour hand will move in certain minutes, make a list of all the degree when hour hand is at hours like 1:00 , 2:00, find degree of minute hand. Find absolute value of hour angle - minute angle if it is greater than 180 return 360 - angle.\\nUpvote if you like the solution\\n\\n# Code\\n```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        degree = 30*float(minutes)/60\\n        anh = [30,60,90,120,150,180,210,240,270,300,330,0]\\n        deg = 6*minutes\\n        print(anh[hour-1] , deg , degree)\\n        angle = abs(anh[hour-1] - deg + degree)\\n        if angle > 180:\\n            return 360 - angle\\n        return angle\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def angleClock(self, hour, minutes):\\n        \"\"\"\\n        :type hour: int\\n        :type minutes: int\\n        :rtype: float\\n        \"\"\"\\n        degree = 30*float(minutes)/60\\n        anh = [30,60,90,120,150,180,210,240,270,300,330,0]\\n        deg = 6*minutes\\n        print(anh[hour-1] , deg , degree)\\n        angle = abs(anh[hour-1] - deg + degree)\\n        if angle > 180:\\n            return 360 - angle\\n        return angle\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564980,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1574050,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1574514,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 2039881,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1969160,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1882191,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1730514,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1724523,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            },
            {
                "id": 1707148,
                "content": [
                    {
                        "username": "axiomaticuncertainty",
                        "content": "This problem is too simple to fit into the medium category; should be changed."
                    },
                    {
                        "username": "akshaysuri",
                        "content": "Easy 4 line solution in java with detailed explanation. Solution runs in 0 ms and is 100% faster than submissions. \\n[Java 4 line solution for clock angle problem](https://qr.ae/pNs1l7)"
                    },
                    {
                        "username": "cbidici",
                        "content": "This question is not a medium questions because even secondary (maybe even primary) school students are capable to do math required to solve this question.\\nLeveling of questions in here are not accurate for many questions."
                    },
                    {
                        "username": "strahd",
                        "content": "This question requires nothing more than simple arithmetic.  It needs to be categorized as easy."
                    },
                    {
                        "username": "a_andreasian",
                        "content": "The `division` is swapped with `floor division` in this example. \nTry `1/2` and get `0` instead of `0.5`. \nAnd nah, this is not written on Python 2.x, in that case the `from __future__ import division` would not be prohibited. \n"
                    },
                    {
                        "username": "Ganes123",
                        "content": "Differing by single position at 4th decimal position in the output solution.\\n\\nclass Solution {\\npublic:\\n    double angleClock(int hour, int minutes) {\\n        \\n        if(hour==12)\\n        {\\n            hour=0;\\n        }\\n\\n        float extra = (float)(minutes)/(float)(12);\\n\\n        // cout<<extra<<\" \"<<minutes<<endl;\\n        \\n        float hours= (float)(hour)*(float)(5)+extra;\\n\\n        float minute=(float)(minutes);\\n\\n        cout<<hours<<\" \"<<minutes<<endl;\\n\\n        float angle = abs(minute-hours);\\n\\n        angle = min(60-angle,angle);\\n\\n        return angle*6;\\n\\n        }\\n};"
                    },
                    {
                        "username": "jannatmaruf",
                        "content": "h = int(input(\"Enter your Hour\"\":\"))\\nm = int(input(\"Enter your Minute\"\":\"))\\nif h < 0 or m < 0 or h > 12 or m > 60:\\n    print(\"Wrong input\")\\n\\nhour_angle = 0.5*(h*60+m)\\nminut_angle = m*6\\n\\nif hour_angle > minut_angle:\\n    Angle=hour_angle-minut_angle\\nelse:\\n    Angle=minut_angle-hour_angle\\n\\nif Angle > 180:\\n    Angle=min(360-Angle,Angle)\\nprint(Angle)\\n\\nwhat wrong this code?"
                    },
                    {
                        "username": "Vipin_121",
                        "content": " `class Solution {\\n    public double angleClock(int hour, int minutes) {\\n     double ang1=Math.abs((double)(60*hour-11*minutes))/2;   \\n        double ang2=360-ang1;\\n        return ang1<ang2 ?ang1:ang2;\\n    }\\n}`"
                    },
                    {
                        "username": "sabarishsindiri789",
                        "content": "        m=minutes*6\\n        if hour == 12:\\n            n=(30*(m/360))\\n        else:\\n            n=(hour*30) + (30*(m/360))\\n        return abs(m-n)\\nwhy this code is not running in py?\\n"
                    },
                    {
                        "username": "Vinit171",
                        "content": "instead of \\'return abs(m-n) , write \"return min(abs(m-n),360-abs(m-n))\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Jump Game IV",
        "question_content": "<p>Given an array of&nbsp;integers <code>arr</code>, you are initially positioned at the first index of the array.</p>\n\n<p>In one step you can jump from index <code>i</code> to index:</p>\n\n<ul>\n\t<li><code>i + 1</code> where:&nbsp;<code>i + 1 &lt; arr.length</code>.</li>\n\t<li><code>i - 1</code> where:&nbsp;<code>i - 1 &gt;= 0</code>.</li>\n\t<li><code>j</code> where: <code>arr[i] == arr[j]</code> and <code>i != j</code>.</li>\n</ul>\n\n<p>Return <em>the minimum number of steps</em> to reach the <strong>last index</strong> of the array.</p>\n\n<p>Notice that you can not jump outside of the array at any time.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [100,-23,-23,404,100,23,23,23,3,404]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> You need three jumps from index 0 --&gt; 4 --&gt; 3 --&gt; 9. Note that index 9 is the last index of the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> Start index is the last index. You do not need to jump.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [7,6,9,6,9,6,9,7]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> You can jump directly from index 0 to index 7 which is last index of the array.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= arr.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>8</sup> &lt;= arr[i] &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1690813,
                "title": "best-explanation-ever-possible-for-this-question",
                "content": "Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F\\n\\n**So Ladies n Gentlemen without any further due let\\'s start,**\\n```\\nLet\\'s understood with an example - [100,-23,-23,404,100,23,23,23,3,404] and using this example we create a map. \\nWhere Key is the number present and the value as an the index in which it is present. \\nSo, we would get something like this:\\n```\\n![image](https://assets.leetcode.com/users/images/262653d1-38ec-4dd0-8671-d71b6bf8892b_1642214744.1664274.png)\\n\\n\\nAs we see the key is **100** and value part **0,4** which would give us the **indexes** where this **value** is found. So, that whenever we want to jump we can found at **4 index** also we have **100** we can **jump directly** on that apart from going to **i + 1, i - 1**. So, now with that will take a **queue**, where we will going to store the element that we are going to process at each step. \\nSince we are **positioned at index 0** will **add 0** in the **queue** and the steps would be **0** as we have not taken any of these steps till now. Now from here we can go to different places.\\n\\n![image](https://assets.leetcode.com/users/images/8c3fd5c3-0490-45e8-80d1-555ca905f1ef_1642215457.224442.png)\\n\\nTo state all the possible jumps at each step. I had **marked a vertical line** in the **queue**. So, **starting is 0** from here we can jump to some other steps. \\nSo, now in the first step we can jump to `idx - 1, idx + 1 or values in map`. Which gives us **-1, 1** & the value in map **0, 4**. In this one **0** is **current index** and **4th** one is this **100**.\\n\\n![image](https://assets.leetcode.com/users/images/53996ad6-d5e1-4077-a443-06e07fb508a7_1642216339.8178186.png)\\n\\nFrom these **-1 & 0** are not reachable & we can just reach to **1 & 4**. We put these in the **queue**. And that line mark the end of the position we can reach in **1st step**. Now we had already process the **100** we will **removing** from the **map**. So, that we do not process this again, there will be cases where we can get a **tle** if we keep the processes index in map for **example** if all these are **100**. We\\'ll keep on processing the **i - 1 i + 1 i - 1 i + 1** and every other index **multiple** no of times and we\\'ll get a **tle**. So, for that reason we are just **removing** from our **map**.\\n\\nNow, in this we know that in the first step we can reach to **1 & 4**. So, in the **next step** where can we reach. So we will be **popping** the element out of **queue and calculating jumps** from that particular index.\\nSo, for that since we are calculating **2nd step**. We do `step = step + 1` and we find the step from the 1st index which is **-23** : **we can go to 0 or 2 or 1 but 0 & 1 are not reachable**. So, we will add **2** in the **queue**.\\n\\n![image](https://assets.leetcode.com/users/images/aa94f3db-e4b5-4c89-97f2-b4076f4443ed_1642218629.943465.png)\\n\\n\\nNow we will again **remove -23 from our Map**.\\nNext we will go to **4th index**. So, from **4th index** we can go to **-1, +1** & we could have also gone to **index 0** but since **100** is not **present** in **map**. We couldn\\'t be going to 100 or 0 sice it is already remove from the map. So here will add **5 & 3 in our queue**. Now we have already got places where we can jump in **2**. We are finding where will be ending up in **step 3**. Will do a `step++` and start processing our indexes.\\n\\n**From 2 we can reach to 3**. So, we **add 3**. But from **5 we can reach to 6 & 7** so we add these two. And from **3 we can reach to 9**. Now here we can see **9 is indeed our last index**. So, here we will be `returning 3`.\\nWhich is minimum step we would be needed to reach the index 9 or last index. So, we return 3.\\n\\n![image](https://assets.leetcode.com/users/images/04238d68-3276-4a69-acc6-750a05c43a73_1642218510.5799263.png)\\n\\n**Now let\\'s code it up** \\n\\n*code each line explained*\\n\\n* Step 1 :\\n```\\n{\\n        // creating variable\\n        int n = arr.length;\\n        if(n == 1) return 0; // base case\\n        \\n        // craeted map holding integer & list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0; // intial step is 0\\n        \\n        // Our 1st job is \"fill the map\"\\n        for(int i = 0; i < n; i++){\\n            // so, using this function it will check is arr[i] is present or not, if it\\'s not present it would create a new arraylist\\n            // and if it\\'s already present we will add index in it\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n```\\n\\n* Step 2 :\\n```\\n// next we need a queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);// in queue we will add our 1st index which is 0;\\n        \\n        while(!q.isEmpty()){ // looping until queue is not empty\\n            step++; // incrementing our step\\n            int size = q.size(); // taking queue size\\n            for(int i = 0; i < size; i++){ // now for each element in this queue for this particulart size running a loop\\n                // so, here we will perform 3 steps\\n                int j = q.poll(); // getting element from queue\\n                \\n                // Jump to j - 1\\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    // there could be 2 conditions\\n                    if(j + 1 == n - 1) return step; // if j+1 is equals to last element\\n                    q.offer(j + 1); // otherwise add in queue\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                if(map.containsKey(arr[j])){ // if this particular element hasn\\'t processed\\n                    for(int k : map.get(arr[j])){ // so, we will iterate over each k\\n                        if(k != j){ // in this we first check if they are not equal, positions are not same\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]); // removing from map\\n            }\\n        }\\n```\\n\\n* Final Step :\\n```\\nreturn step;\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        if(n == 1) return 0;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // fill the map\\n        for(int i = 0; i < n; i++){\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()){\\n            step++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int j = q.poll();\\n            \\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    if(j + 1 == n - 1) return step;\\n                    q.offer(j + 1);\\n                }\\n\\n                if(map.containsKey(arr[j])){\\n                    for(int k : map.get(arr[j])){\\n                        if(k != j){\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}\\n```\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(N)\\n\\nIf you have some \\uD83E\\uDD14 doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nLet\\'s understood with an example - [100,-23,-23,404,100,23,23,23,3,404] and using this example we create a map. \\nWhere Key is the number present and the value as an the index in which it is present. \\nSo, we would get something like this:\\n```\n```\\n{\\n        // creating variable\\n        int n = arr.length;\\n        if(n == 1) return 0; // base case\\n        \\n        // craeted map holding integer & list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0; // intial step is 0\\n        \\n        // Our 1st job is \"fill the map\"\\n        for(int i = 0; i < n; i++){\\n            // so, using this function it will check is arr[i] is present or not, if it\\'s not present it would create a new arraylist\\n            // and if it\\'s already present we will add index in it\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n```\n```\\n// next we need a queue.\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);// in queue we will add our 1st index which is 0;\\n        \\n        while(!q.isEmpty()){ // looping until queue is not empty\\n            step++; // incrementing our step\\n            int size = q.size(); // taking queue size\\n            for(int i = 0; i < size; i++){ // now for each element in this queue for this particulart size running a loop\\n                // so, here we will perform 3 steps\\n                int j = q.poll(); // getting element from queue\\n                \\n                // Jump to j - 1\\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    // there could be 2 conditions\\n                    if(j + 1 == n - 1) return step; // if j+1 is equals to last element\\n                    q.offer(j + 1); // otherwise add in queue\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                if(map.containsKey(arr[j])){ // if this particular element hasn\\'t processed\\n                    for(int k : map.get(arr[j])){ // so, we will iterate over each k\\n                        if(k != j){ // in this we first check if they are not equal, positions are not same\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]); // removing from map\\n            }\\n        }\\n```\n```\\nreturn step;\\n```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        if(n == 1) return 0;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // fill the map\\n        for(int i = 0; i < n; i++){\\n            map.computeIfAbsent(arr[i], v -> new ArrayList()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        \\n        while(!q.isEmpty()){\\n            step++;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++){\\n                int j = q.poll();\\n            \\n                if(j - 1 >= 0 && map.containsKey(arr[j - 1])){\\n                    q.offer(j - 1);\\n                }\\n\\n                if(j + 1 < n && map.containsKey(arr[j + 1])){\\n                    if(j + 1 == n - 1) return step;\\n                    q.offer(j + 1);\\n                }\\n\\n                if(map.containsKey(arr[j])){\\n                    for(int k : map.get(arr[j])){\\n                        if(k != j){\\n                            if(k == n - 1) return step;\\n                            q.offer(k);\\n                        }\\n                    }\\n                }\\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502699,
                "title": "java-c-bfs-solution-clean-code-o-n",
                "content": "**Java**\\n```java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> indicesOfValue = new HashMap<>();\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.poll();\\n                if (i == n - 1) return step; // Reached to last index\\n                List<Integer> next = indicesOfValue.get(arr[i]);\\n                next.add(i - 1); next.add(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n**C++**\\n```C++\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Complexity**\\n- Time & Space: `O(N)`\\n\\n**Expain Time O(N):** In the case where each index has the same value, the algorithm goes to the neighbor (the same value) once then breaks all the edge by using: `next.clear()`\\nSo the algorithm will traverse up to `N` edges for `j` and `2N` edges for `(i+1, i-1)`.\\nThat\\'s why time complexity is `O(3N)` ~ `O(N)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> indicesOfValue = new HashMap<>();\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        int step = 0;\\n        while (!q.isEmpty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.poll();\\n                if (i == n - 1) return step; // Reached to last index\\n                List<Integer> next = indicesOfValue.get(arr[i]);\\n                next.add(i - 1); next.add(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n}\\n```\n```C++\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316467,
                "title": "jump-game-iv-why-dfs-will-not-work-explained",
                "content": "This problem has same issue using on using dfs as in problem [Open the Lock](https://leetcode.com/problems/open-the-lock/) \\nYou may find its editorial [here](https://leetcode.com/problems/open-the-lock/discuss/1253043/open-the-lock-why-dfs-or-recursion-traversal-will-not-work-explainition)\\n\\n### **Explanation** :\\n\\nAs asked in ques , we try to use recursion and travel all possible direction (i+1, i-1, a[i]==a[j] & i != j)\\n\\nRecursion :\\nWe start with simple recursion. And it goes like this:\\n```\\nunordered_map<int, vector<int>> mp;\\n    vector<bool> visit;\\n    int rec(vector<int>& arr, int start, vector<bool>& visit){\\n        if(start <0 || start > arr.size()-1) return 1000000; //out of range \\n        if(visit[start]==true) return 1000000; //already wisited in a node\\n        if(start == arr.size()-1) return 0; //base case when we reach the last index\\n        int step = 1000000; \\n        visit[start]=true; //marking as visited \\n        step = min(step, 1+rec(arr, start+1, visit));  //recurse on i+1\\n        step = min(step, 1+rec(arr, start-1, visit));  //recurse on i-1\\n        for(int i =0;i<mp[arr[start]].size(); i++){   //recurse on a[i]==a[j] & i!=j\\n          if(mp[arr[start]][i] != start)  step = min(step, 1+ rec(arr, mp[arr[start]][i], visit));   \\n        }\\n        visit[start] = false;  //unmarking as visited when done\\n        return step; \\n     }\\n    \\n    int minJumps(vector<int>& arr) {\\n        visit.resize(arr.size(), false);\\n        for(int i =0; i<arr.size(); i++){\\n            mp[arr[i]].push_back(i);  //use array to store a[i]==a[j]\\n        }\\n        return rec(arr, 0, visit);\\n        \\n    }\\n```\\n\\n1. Brute-force : So here we try all nodes that are possible to be jumped. Also, we are using visited array but we are unmarking the node as unvisited after it has been traverse in a path. This is done so that if we we dont unmark it, and we traverse a longer path before, then on traversing a relatively shorter path having any common node , will break the dfs traversal. This is called backtracking. Where we are undoing what was done.\\n\\nThis solves our one problem of not marking any node which as visited if it could be used in any other path too. **When a node is common in multiple paths, we mark and then unmark it visited.**\\n\\n2. Using DP : Next, this solution give us correct answer, but computes path which are common in various paths. There re-computation is involved. To solve this, we can think of memoization (dp), to store the computed paths.\\n\\nAlthough, this seems at first like it would work, but think of the where we traversed a path via  node x. Lets, dp[x] will store the min path from x to last index. Then when we are done with this path, we backtrack and release node x. Then, we might have some path via node x, which follows another path form node x to last index and is actually shorter, but because we have already stored some value in dp[x], we get wrong value.\\n\\nExplained in below fig:\\n[100,-23,-23,404,100,23,23,23,3,404]\\n\\n![image](https://assets.leetcode.com/users/images/cfdbd13a-0505-47c5-956b-22fda8677df8_1625434352.598207.png)\\n\\n\\nYellow path -> correct ans\\nRed path -> path 1 , that we traversed first\\nblack path -> path 2 , traversed next\\nHere, we traversed node node 4 (arr[4] = 100) in red path first, and we get the value of path from node 4 to last node 9 as dp[4] = 4. (From node 4 , node 3 is already marked visited, so node 4 has just this path of length 4 )\\nNext we traversed path black, and node 4 has already value stored dp[4] = 4 , so our min path is not correctly calculated.\\nTherefore, there are multiple paths to reach last index from node 4, and also to reach node 4 , therefore, the dp[4] may not be the minimum value;\\n\\n\\n### **Conclusion** :\\n\\nSo, we tried solving below problems:\\n1.) **Multiple paths with common node** : Used backtracking to mark and unmark the node.\\n\\t\\tIts a bruteforce, will give TLE.\\n2.) **Multiple paths from node x to last index** : Used dp[x] to store computed value for a node x in a path. Will not work, as stored value may not be the min value. WA\\n\\nHence, Dfs will not work. as we have end up tracking multiple paths from that stop and considering the minimum. As commented by [@iamninja in solution comments section](https://leetcode.com/problems/jump-game-iv/solution/765888) : \\n**Due to duplicates relation problem becomes a graph with cycles and you needs to find a shortest path.**\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nunordered_map<int, vector<int>> mp;\\n    vector<bool> visit;\\n    int rec(vector<int>& arr, int start, vector<bool>& visit){\\n        if(start <0 || start > arr.size()-1) return 1000000; //out of range \\n        if(visit[start]==true) return 1000000; //already wisited in a node\\n        if(start == arr.size()-1) return 0; //base case when we reach the last index\\n        int step = 1000000; \\n        visit[start]=true; //marking as visited \\n        step = min(step, 1+rec(arr, start+1, visit));  //recurse on i+1\\n        step = min(step, 1+rec(arr, start-1, visit));  //recurse on i-1\\n        for(int i =0;i<mp[arr[start]].size(); i++){   //recurse on a[i]==a[j] & i!=j\\n          if(mp[arr[start]][i] != start)  step = min(step, 1+ rec(arr, mp[arr[start]][i], visit));   \\n        }\\n        visit[start] = false;  //unmarking as visited when done\\n        return step; \\n     }\\n    \\n    int minJumps(vector<int>& arr) {\\n        visit.resize(arr.size(), false);\\n        for(int i =0; i<arr.size(); i++){\\n            mp[arr[i]].push_back(i);  //use array to store a[i]==a[j]\\n        }\\n        return rec(arr, 0, visit);\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 988714,
                "title": "python-bfs-with-small-trick-explained",
                "content": "In this problem we are asked to find shortest path between two nodes in some graph, so the first idea you should think is bfs (or Dijkstra algorithm). Actually, bfs is almost sufficient here, but we need to do one optimization which increase our speed dramatically.\\n\\n1. Let us use `d`: defaultdict, where for each value we keep list of all possible indexes for this value. We need this to make fast steps of type 3.\\n2. Let `visited` be as usual set of visited nodes, we need it in usual bfs, not to visit any node two times.\\n3. Let `visited_groups` be set of visited **values**: we need it for the following reason. Imagine, we have `arr = [1, 1, 1, 1, 1, 1, 1, 1, 1, 2]`. Then first time we see `1`, we visit all other `1`. Second time we see `1`, we do not need to check its neibors of type `3`, we already know that we visited them. Without this optimization time complexity can be potentially `O(n^2)`.\\n4. What we do next is classical **bfs**: we extract node from queue, visit two neibors of types `1` and `2` and if we did not visit value of this node yet, we visit its all neibors of type `3`.\\n\\n**Complexity**: time complexity is `O(n)`: we visit every index only once and try to visit every node no more than `3` times: for each type of neighbors. Space complexity is `O(n)` as well: to keep `visited` and `visited_groups` sets.\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            d[num].append(i)\\n            \\n        queue = deque([(0, 0)])\\n        visited, visited_groups = set(), set()\\n        \\n        while queue:\\n            steps, index = queue.popleft()\\n            if index == n - 1: return steps\\n            \\n            for neib in [index - 1, index + 1]:\\n                if 0 <= neib < n and neib not in visited:\\n                    visited.add(neib)\\n                    queue.append((steps + 1, neib))\\n            \\n            if arr[index] not in visited_groups:\\n                for neib in d[arr[index]]:\\n                    if neib not in visited:\\n                        visited.add(neib)\\n                        queue.append((steps + 1, neib))\\n                visited_groups.add(arr[index])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, num in enumerate(arr):\\n            d[num].append(i)\\n            \\n        queue = deque([(0, 0)])\\n        visited, visited_groups = set(), set()\\n        \\n        while queue:\\n            steps, index = queue.popleft()\\n            if index == n - 1: return steps\\n            \\n            for neib in [index - 1, index + 1]:\\n                if 0 <= neib < n and neib not in visited:\\n                    visited.add(neib)\\n                    queue.append((steps + 1, neib))\\n            \\n            if arr[index] not in visited_groups:\\n                for neib in d[arr[index]]:\\n                    if neib not in visited:\\n                        visited.add(neib)\\n                        queue.append((steps + 1, neib))\\n                visited_groups.add(arr[index])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257792,
                "title": "c-simple-bfs-reason-to-clear-the-map-explained-with-image",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                //================================================================\\n                //EXPLORE ALL POSSIBLE OPTIONS\\n                if (currIdx + 1 < n && !visited[currIdx + 1])  //OPTION-1 (Move Forward)\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) //OPTION-2 (Move Backward)\\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  //OPTION-3 (Move to same valued idx)\\n                {                                 //newIdx coud be before currIdx or after currIdx\\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                //===================================================================\\n                mp[arr[currIdx]].clear();    //EXPLAINED BELOW :)\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Why to clear the map when you already marked \"visited = true\"?????**\\n#**\"Visited = true\", will work completely fine** to prevent visiting any index that is \\n (already explored) or (waiting in the queue to be explored)\\n#So whenever we iterate the \"map\" of similar valued indexes we can check whether the \\n index is visited. If visited it will not consider that path.\\n\\n//========================================================================\\n#**But there is one problem of time constraint** with the traditional approach\\n#**There could be a large number of indexes with same value**\\n#So after the first index for a value is encountered we add all the occurances of that value in the queue\\n**and mark those indexes as visited**\\n#When we encounter that similar valued index (after popping from queue) then we\\n again iterate over all those redundant indexes and \\n **every time the condition \"visited = true\" becomes true** and we just iterate those \\n large number of indexes for no reason \\n#So we can prevent this redundant iteration just by \"**CLEARING THE MAP FOR ALREADY VISITED VALUES**\"\\n\\nSo \\n**OPTION-1 => Iterate all already visited indexes, visited becomes true, exit the loop, no harm done\\nOPTION-2 => Clear the map -> Don\\'t even iterate the already visited indexes, no harm done :)  <== USE THIS ONE**\\n\\n![image](https://assets.leetcode.com/users/images/c069416b-711b-4768-b897-ea8a34750642_1677988681.620403.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                //================================================================\\n                //EXPLORE ALL POSSIBLE OPTIONS\\n                if (currIdx + 1 < n && !visited[currIdx + 1])  //OPTION-1 (Move Forward)\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) //OPTION-2 (Move Backward)\\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  //OPTION-3 (Move to same valued idx)\\n                {                                 //newIdx coud be before currIdx or after currIdx\\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                //===================================================================\\n                mp[arr[currIdx]].clear();    //EXPLAINED BELOW :)\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257895,
                "title": "java-easy-bfs",
                "content": "**We can use a BFS (breadth first search) approach to find the minimum number of steps to reach the last index. Starting from the first index, we can visit all the neighbouring indices and add them to a queue. We can then repeat this process for all the indices in the queue until we reach the last index. To efficiently find the neighboring indices, we can use an HashMap to store the indices of each value in the List. This allows us to easily find the neighbouring indices of a given index using the values at that index. We can mark the visited indices to avoid visiting them again and keep track of the number of steps taken to reach each index. Once we reach the last index, we can return the number of steps taken to reach it. If we cannot reach the last index, we can return -1 to indicate that it is not possible to reach the last index.\\nExplanation credits :- https://leetcode.com/singhabhinash/\\nLink of explanation :- https://leetcode.com/problems/jump-game-iv/discuss/3257846/Day-64-oror-BFS-oror-O(n)-time-and-O(n)-space-oror-Easiest-Beginner-Friendly-Sol**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int steps=0;\\n        int  n=arr.length;\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                List<Integer> temp =new ArrayList<>();\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n            else{\\n                List<Integer> temp=hm.get(arr[i]);\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n        }\\n        boolean vis[]=new boolean[n];\\n        vis[0]=true;\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        while(!qu.isEmpty()){\\n            int size=qu.size();\\n            for(int i=0;i<size;i++){\\n                int curridx=qu.poll();\\n                if(curridx==n-1)\\n                    return steps;\\n                List<Integer> jumptoindexes=hm.get(arr[curridx]);\\n                jumptoindexes.add(curridx+1);\\n                jumptoindexes.add(curridx-1);\\n                for(int q:jumptoindexes){\\n                    if(q>=0 && q<n && !vis[q]){\\n                        vis[q]=true;\\n                        qu.add(q);\\n                    }\\n                }\\n                jumptoindexes.clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/28b6d959-485e-4322-820e-f53989be39f8_1677982432.0934901.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int steps=0;\\n        int  n=arr.length;\\n        HashMap<Integer,List<Integer>> hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(!hm.containsKey(arr[i])){\\n                List<Integer> temp =new ArrayList<>();\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n            else{\\n                List<Integer> temp=hm.get(arr[i]);\\n                temp.add(i);\\n                hm.put(arr[i],temp);\\n            }\\n        }\\n        boolean vis[]=new boolean[n];\\n        vis[0]=true;\\n        Queue<Integer> qu=new LinkedList<>();\\n        qu.add(0);\\n        while(!qu.isEmpty()){\\n            int size=qu.size();\\n            for(int i=0;i<size;i++){\\n                int curridx=qu.poll();\\n                if(curridx==n-1)\\n                    return steps;\\n                List<Integer> jumptoindexes=hm.get(arr[curridx]);\\n                jumptoindexes.add(curridx+1);\\n                jumptoindexes.add(curridx-1);\\n                for(int q:jumptoindexes){\\n                    if(q>=0 && q<n && !vis[q]){\\n                        vis[q]=true;\\n                        qu.add(q);\\n                    }\\n                }\\n                jumptoindexes.clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502711,
                "title": "python-simple-solution-with-explanations",
                "content": "**Idea**\\nStart from position 0. Use breadth first search until the last position is found. \\n\\n**Trick**\\n1. Track all the values we have explored. For a given value, we only add it to the frontier once\\n2. Track all the positions we have explored.\\n3. Python trick: `nei[num] * (num not in num_met)`\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3**\\n```\\ndef minJumps(self, arr):\\n    nei = collections.defaultdict(list)\\n    _ = [nei[x].append(i) for i, x in enumerate(arr)]\\n\\n    frontier = collections.deque([(0,0)])\\n    num_met, pos_met = set(), set()\\n    while frontier:\\n        pos, step = frontier.popleft() # state: position, step\\n        if pos == len(arr) - 1: return step\\n        num = arr[pos]\\n        pos_met.add(pos) # track explored positions\\n\\n        for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\\n            if p in pos_met or not 0 <= p < len(arr): continue\\n            frontier.append((p, step + 1))\\n\\n        num_met.add(num) # track explored values\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minJumps(self, arr):\\n    nei = collections.defaultdict(list)\\n    _ = [nei[x].append(i) for i, x in enumerate(arr)]\\n\\n    frontier = collections.deque([(0,0)])\\n    num_met, pos_met = set(), set()\\n    while frontier:\\n        pos, step = frontier.popleft() # state: position, step\\n        if pos == len(arr) - 1: return step\\n        num = arr[pos]\\n        pos_met.add(pos) # track explored positions\\n\\n        for p in [pos - 1, pos + 1] + nei[num] * (num not in num_met):\\n            if p in pos_met or not 0 <= p < len(arr): continue\\n            frontier.append((p, step + 1))\\n\\n        num_met.add(num) # track explored values\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257817,
                "title": "easy-solutions-in-java-python-and-c-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can start at the first index and try to reach the last index by taking jumps as given in the problem. If we can reach the last index in one of these jumps, we can return the number of jumps. However, we might need to take jumps to indices we have already visited before, so we need to keep track of visited indices to avoid infinite loops.\\n\\n# Approach\\n1. Create a dictionary to store the indices of each value in the array.\\n2. Use a queue to perform a breadth-first search of the indices.\\n3. For each index in the queue, add the indices corresponding to the adjacent values in the\\ndictionary and to the left and right of the current index.\\n4. If the last index is reached, return the number of jumps taken so far.\\n5. If the queue is emptied and the last index is not reached, return -1 to indicate that it is\\nnot possible to reach the last index.\\n\\n\\n# Complexity\\n- Time complexity: The worst-case time complexity is $$O(n)$$, where n is the length of the array. In the worst case, we might need to visit all the indices in the array to reach the last index.\\n\\n- Space complexity: The space complexity is also $$O(n)$$, where n is the length of the array. We need to store the dictionary, visited indices, and the queue. The size of the queue can be up\\nto n in the worst case.\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n\\n# Code\\n\\n``` Java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> valueToIndex = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int steps = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    queue.offer(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    queue.offer(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex.getOrDefault(arr[curr], Collections.emptyList())) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        queue.offer(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.remove(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        unordered_map<int, vector<int>> valueToIndex;\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex[arr[curr]]) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        q.push(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\\n``` Python []\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Build a dictionary to store the positions of each value in the array\\n        positions = {}\\n        for i in range(n):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        # BFS algorithm to find the minimum number of jumps\\n        visited = set()\\n        q = [(0, 0)]  # (position, jumps)\\n        while q:\\n            pos, jumps = q.pop(0)\\n            \\n            # Check if we\\'ve reached the end of the array\\n            if pos == n - 1:\\n                return jumps\\n            \\n            # Jump to adjacent indices\\n            for next_pos in [pos-1, pos+1]:\\n                if 0 <= next_pos < n and next_pos not in visited:\\n                    visited.add(next_pos)\\n                    q.append((next_pos, jumps+1))\\n            \\n            # Jump to indices with the same value\\n            if arr[pos] in positions:\\n                for next_pos in positions[arr[pos]]:\\n                    if next_pos not in visited:\\n                        visited.add(next_pos)\\n                        q.append((next_pos, jumps+1))\\n                \\n                # We don\\'t need to keep track of the positions anymore\\n                del positions[arr[pos]]\\n        \\n        return -1  # It\\'s not possible to reach the end of the array\\n\\n```\\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\nExample 1:\\n\\narr = [100,-23,-23,404,100,23,23,23,3,404]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  100            -23, 1, 4               1\\n1  -23            100, -23, 2, 3          2\\n3  404            4                       3\\n4  100            -23, 1, 3, 5, 9         4\\n5  23             100, 23, 6, 7, 8        4\\n6  23             100, 23, 5, 7, 8        4\\n7  23             100, 23, 5, 6, 8        4\\n8  23             100, 23, 5, 6, 7        4\\n9  3              404                     3\\n----------------------------------------------------------------------\\nExample 2:\\n\\narr = [7]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  7              None                     0\\n----------------------------------------------------------------------\\nExample 3:\\n\\narr = [7,6,9,6,9,6,9,7]\\ni  Current Value  Next Possible Values   Jumps\\n0  7              7, 1, 7                  1\\n1  6              9, 3, 7                  2\\n2  9              6, 4, 6, 7               2\\n4  9              6, 2, 6, 7               2\\n6  9              7, 5                     2\\n7  7              7, 0                     1\\n\\n\\n```\\n\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> valueToIndex = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int steps = 0;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = queue.poll();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    queue.offer(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    queue.offer(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex.getOrDefault(arr[curr], Collections.emptyList())) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        queue.offer(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.remove(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        unordered_map<int, vector<int>> valueToIndex;\\n        for (int i = 0; i < n; i++) {\\n            valueToIndex[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        \\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) {\\n                    return steps;\\n                }\\n                \\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                \\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                \\n                for (int index : valueToIndex[arr[curr]]) {\\n                    if (!visited[index]) {\\n                        visited[index] = true;\\n                        q.push(index);\\n                    }\\n                }\\n                \\n                // remove the indices with the same value to avoid revisiting them\\n                valueToIndex.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n\\n```\n``` Python []\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Build a dictionary to store the positions of each value in the array\\n        positions = {}\\n        for i in range(n):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        # BFS algorithm to find the minimum number of jumps\\n        visited = set()\\n        q = [(0, 0)]  # (position, jumps)\\n        while q:\\n            pos, jumps = q.pop(0)\\n            \\n            # Check if we\\'ve reached the end of the array\\n            if pos == n - 1:\\n                return jumps\\n            \\n            # Jump to adjacent indices\\n            for next_pos in [pos-1, pos+1]:\\n                if 0 <= next_pos < n and next_pos not in visited:\\n                    visited.add(next_pos)\\n                    q.append((next_pos, jumps+1))\\n            \\n            # Jump to indices with the same value\\n            if arr[pos] in positions:\\n                for next_pos in positions[arr[pos]]:\\n                    if next_pos not in visited:\\n                        visited.add(next_pos)\\n                        q.append((next_pos, jumps+1))\\n                \\n                # We don\\'t need to keep track of the positions anymore\\n                del positions[arr[pos]]\\n        \\n        return -1  # It\\'s not possible to reach the end of the array\\n\\n```\n```\\nTable Representation of the iteration for given example\\nI hope you will like it \\uD83D\\uDE0A\\n----------------------------------------------------------------------\\nExample 1:\\n\\narr = [100,-23,-23,404,100,23,23,23,3,404]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  100            -23, 1, 4               1\\n1  -23            100, -23, 2, 3          2\\n3  404            4                       3\\n4  100            -23, 1, 3, 5, 9         4\\n5  23             100, 23, 6, 7, 8        4\\n6  23             100, 23, 5, 7, 8        4\\n7  23             100, 23, 5, 6, 8        4\\n8  23             100, 23, 5, 6, 7        4\\n9  3              404                     3\\n----------------------------------------------------------------------\\nExample 2:\\n\\narr = [7]\\n\\ni  Current Value  Next Possible Values   Jumps\\n0  7              None                     0\\n----------------------------------------------------------------------\\nExample 3:\\n\\narr = [7,6,9,6,9,6,9,7]\\ni  Current Value  Next Possible Values   Jumps\\n0  7              7, 1, 7                  1\\n1  6              9, 3, 7                  2\\n2  9              6, 4, 6, 7               2\\n4  9              6, 2, 6, 7               2\\n6  9              7, 5                     2\\n7  7              7, 0                     1\\n\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509868,
                "title": "java-bfs",
                "content": "```\\npublic int minJumps(int[] arr) {\\n        if(arr.length<=1) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<arr.length;i++) {\\n            map.putIfAbsent(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        visited.add(0);\\n        int count = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0;i<size;i++) {\\n                int pop = queue.poll();\\n                if(pop==arr.length-1) {\\n                    return count;\\n                }\\n                if(pop>0 && visited.add(pop-1)) {\\n                    queue.add(pop-1);\\n                }\\n                if(pop<arr.length-1 && visited.add(pop+1)) {\\n                    queue.add(pop+1);\\n                }\\n                if(map.containsKey(arr[pop])) {\\n                    for (int index : map.get(arr[pop])) {\\n                        if(visited.add(index)) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    map.remove(arr[pop]); // Since we have already taken all indexes into account, we don\\'t need to traverse them again.\\n                    // Consider example: [1,1,1,1,1,1,.....(5000 terms), 11] -> Answer =2;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minJumps(int[] arr) {\\n        if(arr.length<=1) {\\n            return 0;\\n        }\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i=0;i<arr.length;i++) {\\n            map.putIfAbsent(arr[i],new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        visited.add(0);\\n        int count = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0;i<size;i++) {\\n                int pop = queue.poll();\\n                if(pop==arr.length-1) {\\n                    return count;\\n                }\\n                if(pop>0 && visited.add(pop-1)) {\\n                    queue.add(pop-1);\\n                }\\n                if(pop<arr.length-1 && visited.add(pop+1)) {\\n                    queue.add(pop+1);\\n                }\\n                if(map.containsKey(arr[pop])) {\\n                    for (int index : map.get(arr[pop])) {\\n                        if(visited.add(index)) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    map.remove(arr[pop]); // Since we have already taken all indexes into account, we don\\'t need to traverse them again.\\n                    // Consider example: [1,1,1,1,1,1,.....(5000 terms), 11] -> Answer =2;\\n                }\\n            }\\n            count++;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690840,
                "title": "python-bfs-o-n-100-faster-image-explanation",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n\\n![image](https://assets.leetcode.com/users/images/877c253f-58c4-4553-983e-5aa79b649b66_1642222089.0379643.png)\\n\\n\\n```\\nRuntime: 512 ms, faster than 100.00% of Python online submissions for Jump Game IV.\\nMemory Usage: 27.6 MB, less than 87.72% of Python online submissions for Jump Game IV.\\n```\\n\\n```\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        if len(arr) == 1: return 0  # obviously\\n\\n        adj = defaultdict(list)\\n        for i, n in enumerate(arr):\\n            adj[n].append(i)\\n\\n        ans = [0] * len(arr)  # the return value is ans[0], once we find it, we can return immediately.\\n        dq = deque([len(arr) - 1])  # obviously, ans[-1] == 0, so we fill in ans from ans[-1] to ans[0] iteratively\\n\\n        while dq:\\n            i = dq.popleft()\\n\\n            # move forward if the next one has not seen before that is ans[i + 1] == 0\\n            # note that the ans[len(arr) - 1] is always 0, we should NOT update it, so i < len(arr) - 1\\n            if i < len(arr) - 2 and ans[i + 1] == 0:\\n                ans[i + 1] = ans[i] + 1\\n                dq.append(i + 1)\\n\\n            # move backward if the previous one has not seen before that is ans[i - 1] == 0\\n            if i > 0 and ans[i - 1] == 0:\\n                ans[i - 1] = ans[i] + 1\\n                if i - 1 == 0: return ans[0]\\n                dq.append(i - 1)\\n\\n            # move to j where arr[i] == arr[j]\\n            for j in adj[arr[i]]:\\n                if ans[j] == 0 and j < len(arr) - 1:\\n                    ans[j] = ans[i] + 1\\n                    if j == 0: return ans[0]\\n                    dq.append(j)\\n            adj.pop(arr[i])  # pop arr[i] from the adj, very very important to avoid double calculating\\n```\\n\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nRuntime: 512 ms, faster than 100.00% of Python online submissions for Jump Game IV.\\nMemory Usage: 27.6 MB, less than 87.72% of Python online submissions for Jump Game IV.\\n```\n```\\nclass Solution(object):\\n    def minJumps(self, arr):\\n        if len(arr) == 1: return 0  # obviously\\n\\n        adj = defaultdict(list)\\n        for i, n in enumerate(arr):\\n            adj[n].append(i)\\n\\n        ans = [0] * len(arr)  # the return value is ans[0], once we find it, we can return immediately.\\n        dq = deque([len(arr) - 1])  # obviously, ans[-1] == 0, so we fill in ans from ans[-1] to ans[0] iteratively\\n\\n        while dq:\\n            i = dq.popleft()\\n\\n            # move forward if the next one has not seen before that is ans[i + 1] == 0\\n            # note that the ans[len(arr) - 1] is always 0, we should NOT update it, so i < len(arr) - 1\\n            if i < len(arr) - 2 and ans[i + 1] == 0:\\n                ans[i + 1] = ans[i] + 1\\n                dq.append(i + 1)\\n\\n            # move backward if the previous one has not seen before that is ans[i - 1] == 0\\n            if i > 0 and ans[i - 1] == 0:\\n                ans[i - 1] = ans[i] + 1\\n                if i - 1 == 0: return ans[0]\\n                dq.append(i - 1)\\n\\n            # move to j where arr[i] == arr[j]\\n            for j in adj[arr[i]]:\\n                if ans[j] == 0 and j < len(arr) - 1:\\n                    ans[j] = ans[i] + 1\\n                    if j == 0: return ans[0]\\n                    dq.append(j)\\n            adj.pop(arr[i])  # pop arr[i] from the adj, very very important to avoid double calculating\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712669,
                "title": "c-o-n-bfs-w-explanation",
                "content": "The idea is to find the underlying graph, where all edges  have same weight and indices represent nodes. There is an edge between the nodes corresponding to the surrounding indices and also the other indices which have the same value. Then this problem reduces to simple shortest path finding, which can be solved by any shortest path algorithm. Since the edge weights are unity, BFS will also suffice.\\n```\\nint minJumps(vector<int>& arr) \\n{\\n\\tunordered_map<int,vector<int>> adj;\\n    int n=arr.size();\\n    for(int i=0;i<n;++i)\\n    \\tif(adj.find(arr[i])==adj.end())\\n    \\t\\tadj[arr[i]]={i};\\n    \\telse adj[arr[i]].push_back(i);\\n    vector<int> grey(n,0);\\n    grey[0]=1;\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    int ret=INT_MAX;\\n    while(!q.empty())\\n    {\\n    \\tpair<int,int> temp=q.front();\\n        q.pop();\\n    \\tint u=temp.first;\\n    \\tint d=temp.second;\\n    \\tif(u==n-1)\\n    \\t\\treturn d;\\n    \\telse\\n    \\t{\\n    \\t\\tif(u>0&&!grey[u-1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u-1,d+1});\\n    \\t\\t\\tgrey[u-1]=1;\\n    \\t\\t}\\n    \\t\\tif(u+1<n&&!grey[u+1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u+1,d+1});\\n    \\t\\t\\tgrey[u+1]=1;\\n    \\t\\t}\\n    \\t\\tfor(int v:adj[arr[u]])\\n    \\t\\t\\tif(!grey[v])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tq.push({v,d+1});\\n    \\t\\t\\t\\tgrey[v]=1;\\n    \\t\\t\\t}\\n            adj[arr[u]]={};\\n    \\t}\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minJumps(vector<int>& arr) \\n{\\n\\tunordered_map<int,vector<int>> adj;\\n    int n=arr.size();\\n    for(int i=0;i<n;++i)\\n    \\tif(adj.find(arr[i])==adj.end())\\n    \\t\\tadj[arr[i]]={i};\\n    \\telse adj[arr[i]].push_back(i);\\n    vector<int> grey(n,0);\\n    grey[0]=1;\\n    queue<pair<int,int>> q;\\n    q.push({0,0});\\n    int ret=INT_MAX;\\n    while(!q.empty())\\n    {\\n    \\tpair<int,int> temp=q.front();\\n        q.pop();\\n    \\tint u=temp.first;\\n    \\tint d=temp.second;\\n    \\tif(u==n-1)\\n    \\t\\treturn d;\\n    \\telse\\n    \\t{\\n    \\t\\tif(u>0&&!grey[u-1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u-1,d+1});\\n    \\t\\t\\tgrey[u-1]=1;\\n    \\t\\t}\\n    \\t\\tif(u+1<n&&!grey[u+1])\\n    \\t\\t{\\n    \\t\\t\\tq.push({u+1,d+1});\\n    \\t\\t\\tgrey[u+1]=1;\\n    \\t\\t}\\n    \\t\\tfor(int v:adj[arr[u]])\\n    \\t\\t\\tif(!grey[v])\\n    \\t\\t\\t{\\n    \\t\\t\\t\\tq.push({v,d+1});\\n    \\t\\t\\t\\tgrey[v]=1;\\n    \\t\\t\\t}\\n            adj[arr[u]]={};\\n    \\t}\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690949,
                "title": "c-bfs-solution-o-n-time-and-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1) return 0;\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        int step = 0;\\n        \\n        //fill map\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        //queue\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            step++;\\n            int size = q.size();\\n            \\n            for(int i = 0; i<size; i++){\\n                int j = q.front();\\n                q.pop();\\n                \\n                //jump to j-1\\n                if(j-1 >= 0 && mp.find(arr[j-1]) != mp.end()){\\n                    q.push(j-1);\\n                }\\n                \\n                //jump to j+1\\n                if(j+1 < n && mp.find(arr[j+1]) != mp.end()){\\n                    if(j+1 == n-1) return step;\\n                    q.push(j+1);\\n                }\\n                \\n                // jump to equal\\n                if(mp.find(arr[j]) != mp.end()){\\n                    for(auto k: mp[arr[j]]){\\n                        if(k != j){\\n                            if(k == n-1) return step;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[j]);\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```\\n\\nPlease **Upvote** :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1) return 0;\\n        \\n        unordered_map<int, vector<int>> mp;\\n        \\n        int step = 0;\\n        \\n        //fill map\\n        for(int i = 0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        //queue\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            step++;\\n            int size = q.size();\\n            \\n            for(int i = 0; i<size; i++){\\n                int j = q.front();\\n                q.pop();\\n                \\n                //jump to j-1\\n                if(j-1 >= 0 && mp.find(arr[j-1]) != mp.end()){\\n                    q.push(j-1);\\n                }\\n                \\n                //jump to j+1\\n                if(j+1 < n && mp.find(arr[j+1]) != mp.end()){\\n                    if(j+1 == n-1) return step;\\n                    q.push(j+1);\\n                }\\n                \\n                // jump to equal\\n                if(mp.find(arr[j]) != mp.end()){\\n                    for(auto k: mp[arr[j]]){\\n                        if(k != j){\\n                            if(k == n-1) return step;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[j]);\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503171,
                "title": "9-lines-python-bfs",
                "content": "```\\ndef minJumps(self, A):\\n    indices = collections.defaultdict(list)\\n    for i, a in enumerate(A):\\n        indices[a].append(i)\\n    done, now = {-1}, {0}\\n    for steps in itertools.count():\\n        done |= now\\n        if len(A) - 1 in done:\\n            return steps\\n        now = {j for i in now for j in [i-1, i+1] + indices.pop(A[i], [])} - done\\n```\\nAvoids stepping outside on the left by putting `-1` in `done`. No need to avoid stepping outside on the right, that\\'s only possible from the goal index, and from the goal we don\\'t move further.\\n\\nFirst time we step off some value, we `pop` all its indices so we don\\'t use them again later.",
                "solutionTags": [],
                "code": "```\\ndef minJumps(self, A):\\n    indices = collections.defaultdict(list)\\n    for i, a in enumerate(A):\\n        indices[a].append(i)\\n    done, now = {-1}, {0}\\n    for steps in itertools.count():\\n        done |= now\\n        if len(A) - 1 in done:\\n            return steps\\n        now = {j for i in now for j in [i-1, i+1] + indices.pop(A[i], [])} - done\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257971,
                "title": "clean-codes-full-explanation-breadth-first-search-c-java-python3",
                "content": "# Intuition :\\n- We ha ve to find the minimum number of jumps needed to reach the last index of an array. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach :\\n- The idea is to use a **Breadth First Search** approach to explore all the possible paths starting from the first index.\\n\\n---\\n\\n\\n\\n# Steps needed to solve the Problem :\\n\\n ***\\u27A1\\uFE0FStep 1: Initialize data structures***\\n- The first step is to initialize few data structures that will be used later in the algorithm. \\n- Create a map to store the indices of each value in the input array, a queue to store the indices of the current nodes to be visited, and a boolean array to mark whether each index has been seen before:\\n```\\nfinal int n = arr.length;\\n\\n// Initialize a map to store the indices of each value in the array\\nMap<Integer, List<Integer>> graph = new HashMap<>();\\n\\n// Initialize a queue with the first index and mark it as seen\\nQueue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n\\n// Initialize a boolean array to keep track of visited indices\\nboolean[] seen = new boolean[n];\\nseen[0] = true;\\n\\n```\\n***\\u27A1\\uFE0FStep 2: Build the graph***\\n- Next step is to build a graph that represents the relationships between the elements in the input array. And loop through the array and add each index to the list of indices for its corresponding value in the map:\\n```\\nfor (int i = 0; i < n; ++i) \\n{\\n  // Add the current index to the list of indices for its corresponding value\\n  graph.putIfAbsent(arr[i], new ArrayList<>());\\n  graph.get(arr[i]).add(i);\\n}\\n\\n```\\n***\\u27A1\\uFE0FStep 3: BFS Algorithm***\\n- Now, in this step enter a loop that performs a BFS algorithm to find the minimum number of jumps needed to reach the end of the array.\\n-  At each iteration of the loop, dequeue the next node from the queue, check if it\\'s the last index of the array, and mark it as visited.\\n-  Then add the adjacent nodes to the list of indices for their corresponding value in the map, and enqueue any adjacent nodes that have not been visited yet:\\n```\\nfor (int steps = 0; !q.isEmpty(); ++steps) \\n{\\n  // Iterate over all the nodes at the current level of the BFS\\n  for (int sz = q.size(); sz > 0; --sz) \\n  {\\n    // Dequeue the next node and check if it\\'s the last index of the array\\n    final int i = q.poll();\\n    if (i == n - 1)\\n      return steps;\\n    seen[i] = true;\\n    final int u = arr[i];\\n    // Add the adjacent nodes to the list of indices for their corresponding value\\n    if (i + 1 < n)\\n      graph.get(u).add(i + 1);\\n    if (i - 1 >= 0)\\n      graph.get(u).add(i - 1);\\n    // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n    for (final int v : graph.get(u)) \\n    {\\n      if (seen[v])\\n        continue;\\n      q.offer(v);\\n    }\\n    // Clear the list of indices for the current node value to avoid revisiting it\\n    graph.get(u).clear();\\n  }\\n}\\n\\n```\\n***\\u27A1\\uFE0FStep 4: Return the minimum number of jumps***\\n- If the end of the array is reached, return the number of steps it took to get there. Otherwise, throw an error:\\n```\\n// If the last index is not reached, throw an exception\\nthrow new IllegalArgumentException();\\n\\n```\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(N+K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N+K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n***Let\\'s Code it Up .\\nThere may be minor syntax difference in C++ and Python***\\n# Codes [C++ |Java |Python3] : With Comments\\n```C++ []\\nclass Solution {\\npublic:\\n  int minJumps(vector<int>& arr) {\\n    const int n = arr.size();\\n    // {a: indices}\\n    unordered_map<int, vector<int>> graph;\\n    // Initialize queue with first index and mark as seen\\n    queue<int> q{{0}};\\n    vector<bool> seen(n);\\n    seen[0] = true;\\n\\n    // Create graph where keys are elements and values are their indices in arr\\n    for (int i = 0; i < n; ++i)\\n      graph[arr[i]].push_back(i);\\n\\n    // BFS\\n    for (int steps = 0; !q.empty(); ++steps) {\\n      // Process all nodes at current level\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int i = q.front();\\n        q.pop();\\n        // If last index is reached, return number of steps\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        const int u = arr[i];\\n        // Add adjacent indices to graph\\n        if (i + 1 < n)\\n          graph[u].push_back(i + 1);\\n        if (i - 1 >= 0)\\n          graph[u].push_back(i - 1);\\n        // Process all adjacent nodes\\n        for (const int v : graph[u]) {\\n          if (seen[v])\\n            continue;\\n          q.push(v);\\n        }\\n        // Clear indices in graph to avoid revisiting\\n        graph[u].clear();\\n      }\\n    }\\n    // Should never reach here\\n    throw;\\n  }\\n};\\n```\\n```Java []\\nclass Solution \\n{\\n  public int minJumps(int[] arr) \\n  {\\n    final int n = arr.length;\\n    // {a: indices}\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    // Initialize a map to store the indices of each value in the array\\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n    // Initialize a queue with the first index and mark it as seen\\n    boolean[] seen = new boolean[n];\\n    seen[0] = true;\\n\\n    for (int i = 0; i < n; ++i) \\n    {\\n      // Add the current index to the list of indices for its corresponding value\\n      graph.putIfAbsent(arr[i], new ArrayList<>());\\n      graph.get(arr[i]).add(i);\\n    }\\n\\n    for (int steps = 0; !q.isEmpty(); ++steps) \\n    {\\n      // Iterate over all the nodes at the current level of the BFS\\n      for (int sz = q.size(); sz > 0; --sz) \\n      {\\n        // Dequeue the next node and check if it\\'s the last index of the array\\n        final int i = q.poll();\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        final int u = arr[i];\\n        // Add the adjacent nodes to the list of indices for their corresponding value\\n        if (i + 1 < n)\\n          graph.get(u).add(i + 1);\\n        if (i - 1 >= 0)\\n          graph.get(u).add(i - 1);\\n        // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n        for (final int v : graph.get(u)) \\n        {\\n          if (seen[v])\\n            continue;\\n          q.offer(v);\\n        }\\n        // Clear the list of indices for the current node value to avoid revisiting it\\n        graph.get(u).clear();\\n      }\\n    }\\n    // If the last index is not reached, throw an exception\\n    throw new IllegalArgumentException();\\n  }\\n}\\n```\\n```Python []\\nclass Solution:\\n  def minJumps(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    # {num: indices}\\n    graph = collections.defaultdict(list)\\n    steps = 0\\n    q = collections.deque([0])\\n    seen = {0}\\n\\n    # Create graph where keys are elements and values are their indices in arr\\n    for i, a in enumerate(arr):\\n      graph[a].append(i)\\n\\n    # BFS\\n    while q:\\n      # Process all nodes at current level\\n      for _ in range(len(q)):\\n        i = q.popleft()\\n        # If last index is reached, return number of steps\\n        if i == n - 1:\\n          return steps\\n        seen.add(i)\\n        u = arr[i]\\n        # Add adjacent indices to graph\\n        if i + 1 < n:\\n          graph[u].append(i + 1)\\n        if i - 1 >= 0:\\n          graph[u].append(i - 1)\\n        # Process all adjacent nodes\\n        for v in graph[u]:\\n          if v in seen:\\n            continue\\n          q.append(v)\\n        # Clear indices in graph to avoid revisiting\\n        graph[u].clear()\\n      steps += 1\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/93d3956d-8e55-4c8b-a784-65a8618dd010_1677985041.7690272.gif)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfinal int n = arr.length;\\n\\n// Initialize a map to store the indices of each value in the array\\nMap<Integer, List<Integer>> graph = new HashMap<>();\\n\\n// Initialize a queue with the first index and mark it as seen\\nQueue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n\\n// Initialize a boolean array to keep track of visited indices\\nboolean[] seen = new boolean[n];\\nseen[0] = true;\\n\\n```\n```\\nfor (int i = 0; i < n; ++i) \\n{\\n  // Add the current index to the list of indices for its corresponding value\\n  graph.putIfAbsent(arr[i], new ArrayList<>());\\n  graph.get(arr[i]).add(i);\\n}\\n\\n```\n```\\nfor (int steps = 0; !q.isEmpty(); ++steps) \\n{\\n  // Iterate over all the nodes at the current level of the BFS\\n  for (int sz = q.size(); sz > 0; --sz) \\n  {\\n    // Dequeue the next node and check if it\\'s the last index of the array\\n    final int i = q.poll();\\n    if (i == n - 1)\\n      return steps;\\n    seen[i] = true;\\n    final int u = arr[i];\\n    // Add the adjacent nodes to the list of indices for their corresponding value\\n    if (i + 1 < n)\\n      graph.get(u).add(i + 1);\\n    if (i - 1 >= 0)\\n      graph.get(u).add(i - 1);\\n    // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n    for (final int v : graph.get(u)) \\n    {\\n      if (seen[v])\\n        continue;\\n      q.offer(v);\\n    }\\n    // Clear the list of indices for the current node value to avoid revisiting it\\n    graph.get(u).clear();\\n  }\\n}\\n\\n```\n```\\n// If the last index is not reached, throw an exception\\nthrow new IllegalArgumentException();\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\n```C++ []\\nclass Solution {\\npublic:\\n  int minJumps(vector<int>& arr) {\\n    const int n = arr.size();\\n    // {a: indices}\\n    unordered_map<int, vector<int>> graph;\\n    // Initialize queue with first index and mark as seen\\n    queue<int> q{{0}};\\n    vector<bool> seen(n);\\n    seen[0] = true;\\n\\n    // Create graph where keys are elements and values are their indices in arr\\n    for (int i = 0; i < n; ++i)\\n      graph[arr[i]].push_back(i);\\n\\n    // BFS\\n    for (int steps = 0; !q.empty(); ++steps) {\\n      // Process all nodes at current level\\n      for (int sz = q.size(); sz > 0; --sz) {\\n        const int i = q.front();\\n        q.pop();\\n        // If last index is reached, return number of steps\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        const int u = arr[i];\\n        // Add adjacent indices to graph\\n        if (i + 1 < n)\\n          graph[u].push_back(i + 1);\\n        if (i - 1 >= 0)\\n          graph[u].push_back(i - 1);\\n        // Process all adjacent nodes\\n        for (const int v : graph[u]) {\\n          if (seen[v])\\n            continue;\\n          q.push(v);\\n        }\\n        // Clear indices in graph to avoid revisiting\\n        graph[u].clear();\\n      }\\n    }\\n    // Should never reach here\\n    throw;\\n  }\\n};\\n```\n```Java []\\nclass Solution \\n{\\n  public int minJumps(int[] arr) \\n  {\\n    final int n = arr.length;\\n    // {a: indices}\\n    Map<Integer, List<Integer>> graph = new HashMap<>();\\n    // Initialize a map to store the indices of each value in the array\\n    Queue<Integer> q = new ArrayDeque<>(Arrays.asList(0));\\n    // Initialize a queue with the first index and mark it as seen\\n    boolean[] seen = new boolean[n];\\n    seen[0] = true;\\n\\n    for (int i = 0; i < n; ++i) \\n    {\\n      // Add the current index to the list of indices for its corresponding value\\n      graph.putIfAbsent(arr[i], new ArrayList<>());\\n      graph.get(arr[i]).add(i);\\n    }\\n\\n    for (int steps = 0; !q.isEmpty(); ++steps) \\n    {\\n      // Iterate over all the nodes at the current level of the BFS\\n      for (int sz = q.size(); sz > 0; --sz) \\n      {\\n        // Dequeue the next node and check if it\\'s the last index of the array\\n        final int i = q.poll();\\n        if (i == n - 1)\\n          return steps;\\n        seen[i] = true;\\n        final int u = arr[i];\\n        // Add the adjacent nodes to the list of indices for their corresponding value\\n        if (i + 1 < n)\\n          graph.get(u).add(i + 1);\\n        if (i - 1 >= 0)\\n          graph.get(u).add(i - 1);\\n        // Iterate over all the adjacent nodes and enqueue them if they haven\\'t been seen yet\\n        for (final int v : graph.get(u)) \\n        {\\n          if (seen[v])\\n            continue;\\n          q.offer(v);\\n        }\\n        // Clear the list of indices for the current node value to avoid revisiting it\\n        graph.get(u).clear();\\n      }\\n    }\\n    // If the last index is not reached, throw an exception\\n    throw new IllegalArgumentException();\\n  }\\n}\\n```\n```Python []\\nclass Solution:\\n  def minJumps(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    # {num: indices}\\n    graph = collections.defaultdict(list)\\n    steps = 0\\n    q = collections.deque([0])\\n    seen = {0}\\n\\n    # Create graph where keys are elements and values are their indices in arr\\n    for i, a in enumerate(arr):\\n      graph[a].append(i)\\n\\n    # BFS\\n    while q:\\n      # Process all nodes at current level\\n      for _ in range(len(q)):\\n        i = q.popleft()\\n        # If last index is reached, return number of steps\\n        if i == n - 1:\\n          return steps\\n        seen.add(i)\\n        u = arr[i]\\n        # Add adjacent indices to graph\\n        if i + 1 < n:\\n          graph[u].append(i + 1)\\n        if i - 1 >= 0:\\n          graph[u].append(i - 1)\\n        # Process all adjacent nodes\\n        for v in graph[u]:\\n          if v in seen:\\n            continue\\n          q.append(v)\\n        # Clear indices in graph to avoid revisiting\\n        graph[u].clear()\\n      steps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2288991,
                "title": "bfs-c-with-intuition-100-and-simple-explanation",
                "content": "**OBSERVATIONS** \\n1. Given that we can **jump to the previous and next neighbour if they are within the limits** from the current position.\\n2. We can also **jump to the same element which is present in the array but at different index** .\\n\\nAtlast we have to return the **minimum number of steps to reach the end (n-1 th index )**\\n\\n**LOGIC**\\n**1**. Here we are using BFS Algorithm. \\nThen the immediate question is why???? \\n\\n**Reason**\\n\\n**Whenever there is an unwieghted graph and we want to retrive the shortest path or minimum steps to reach the destination** , we use **BFS**  , **as it takes all the neighbouring guys from the current node and this process repeats for every node** .\\n\\n**Thus the total visualisation will be like we are generating hotspots/ rainbows on each node. Therefore the spread to the entire graph takes minimum effort** .\\n\\nThus , by moving forward\\n**2**. The question is very easy but few changes to be made on applying BFS.\\n**3**. According to Observations, here **for the current element its friends are the previous and next neighbours, and same guys** . \\nSo we will create **a hashmap of node and his same guys**\\n\\nThe other data structures needed are :- ***queue :- Pushing the indexes  ; \\nVisited array (bool type ) :- To mark which nodes are visited***\\nAnd a **step variable** :- Counts the steps to till we have reach the end.\\n**4**. Starting the BFS,  push 0 as its the first index and mark it as visted. Begin the loop until the queue becomes empty :\\n\\t\\t* Take the **front element** . **If its the n-1 th index , directly return the step** ;\\n\\t\\t* **Else take its previous and next guys and put in its friends list** ;\\n\\t\\t* Start **traversing the neighbours list which contains same guys, prev guy and next guy**.\\n    \\t* If they are **within the range and still not visited** :- Mark them as visited and push them\\n    \\t\\n**One important point of this whole question is, after visiting the neighbours list, plz clear the list** The reason is : \\n\\n**Removing the visited ones to reduce the repetitive work;\\nAs the children are already visted and no use for the coming iterations for \\nany further guy in coming iterations bcz we have already used that path and didnt got the answer ,so not allowing to use this path**\\n\\n\" **To tell in simple manner, everytime we are reducing the size of the friendslist, so that the search space is reducing.** \"\\n\\n*Code* \\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=size(arr);\\n        if(n==1) return 0;   //  edge case : )\\n        unordered_map<int,list<int>>mp;    // ele -> all its same guys \\n        for(int i=0;i<n;i++) mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        vector<bool>vis(n,false);\\n        q.push(0); vis[0]=true;\\n        int step=0;\\n        while(!q.empty()){\\n            \\n            int sz=size(q);\\n            while(sz--){\\n                int fr=q.front(); q.pop();\\n                if(fr==n-1) return step; // if u reached the last ind then return count step;\\n                // else now vist all its neighs who are i+1,i-1 and same guys \\n                list<int>& neigh=mp[arr[fr]];\\n                neigh.push_back(fr-1); \\n                neigh.push_back(fr+1);\\n                // since the left and right guys of ith ele are not there in its list\\n\\t\\t\\t\\t\\n                // so now iterate through neigh who are within the range and not vis\\n                for(auto x: neigh){\\n                    if(x>=0 and x<n and !vis[x]){q.push(x); vis[x]=true;}\\n                }\\n                neigh.clear();  // removing the visited ones to reduce the reptiive work;\\n                // as the children are already visted and no use for the coming iterations for \\n                // any further guy in coming iterations; bcz we have already used that path and didnt got the ans ,so not allowing to use this path;\\n            }\\n            step++; // counting the steps\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n**Thanks for reading.\\nIf you like it , Do upvote\\nHappy Learning :)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=size(arr);\\n        if(n==1) return 0;   //  edge case : )\\n        unordered_map<int,list<int>>mp;    // ele -> all its same guys \\n        for(int i=0;i<n;i++) mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        vector<bool>vis(n,false);\\n        q.push(0); vis[0]=true;\\n        int step=0;\\n        while(!q.empty()){\\n            \\n            int sz=size(q);\\n            while(sz--){\\n                int fr=q.front(); q.pop();\\n                if(fr==n-1) return step; // if u reached the last ind then return count step;\\n                // else now vist all its neighs who are i+1,i-1 and same guys \\n                list<int>& neigh=mp[arr[fr]];\\n                neigh.push_back(fr-1); \\n                neigh.push_back(fr+1);\\n                // since the left and right guys of ith ele are not there in its list\\n\\t\\t\\t\\t\\n                // so now iterate through neigh who are within the range and not vis\\n                for(auto x: neigh){\\n                    if(x>=0 and x<n and !vis[x]){q.push(x); vis[x]=true;}\\n                }\\n                neigh.clear();  // removing the visited ones to reduce the reptiive work;\\n                // as the children are already visted and no use for the coming iterations for \\n                // any further guy in coming iterations; bcz we have already used that path and didnt got the ans ,so not allowing to use this path;\\n            }\\n            step++; // counting the steps\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198853,
                "title": "c-bfs-solution-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>m; //to store the index of the same value\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n);\\n        int level=0;\\n        while(q.empty()==false){\\n            int sz=q.size();\\n            while(sz--){\\n                auto front=q.front();\\n                q.pop();\\n                if(front==n-1){         //if current node is last node return current level\\n                    return level;\\n                }\\n                vis[front]=1;                   //mark current node\\n                auto &temp=m[arr[front]];           //get list of nodes which are having same value as current node\\n                for(auto &i:temp){\\n                    if(vis[i]==0){             //if any node is not visited \\n                        if(i==n-1)            // check if it is last node return level+1 (because it will be find it in next round)\\n                            return level+1;\\n                        q.push(i);           // otherwise mark as visited and add in queue\\n                        vis[i]=1;\\n                    }\\n                }\\n                temp.clear();            //clear the array since we have visited all the nodes or will be visiting in future but added in queue\\n                if(front+1==n-1){       //if front+1 is last then we can directly jump to it and reach to destination so return level +1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //no need to check for front-1 is the last or not because if we are at index n then only we can reach to n-1 by jumping left but we can never go to n (mention in question)\\n                    return level+1;\\n                }\\n                if(front-1>=0 and vis[front-1]==0){        //check if we can jump to the left then we will add in the queue and mark as visited\\n                    q.push(front-1);\\n                    vis[front-1]=1;\\n                }\\n                if(front+1<n and vis[front+1]==0){         //check if we can jump to the right then we will add in the queue and mark as visited\\n                    q.push(front+1);\\n                    vis[front+1]=1;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>m; //to store the index of the same value\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        vector<int>vis(n);\\n        int level=0;\\n        while(q.empty()==false){\\n            int sz=q.size();\\n            while(sz--){\\n                auto front=q.front();\\n                q.pop();\\n                if(front==n-1){         //if current node is last node return current level\\n                    return level;\\n                }\\n                vis[front]=1;                   //mark current node\\n                auto &temp=m[arr[front]];           //get list of nodes which are having same value as current node\\n                for(auto &i:temp){\\n                    if(vis[i]==0){             //if any node is not visited \\n                        if(i==n-1)            // check if it is last node return level+1 (because it will be find it in next round)\\n                            return level+1;\\n                        q.push(i);           // otherwise mark as visited and add in queue\\n                        vis[i]=1;\\n                    }\\n                }\\n                temp.clear();            //clear the array since we have visited all the nodes or will be visiting in future but added in queue\\n                if(front+1==n-1){       //if front+1 is last then we can directly jump to it and reach to destination so return level +1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  //no need to check for front-1 is the last or not because if we are at index n then only we can reach to n-1 by jumping left but we can never go to n (mention in question)\\n                    return level+1;\\n                }\\n                if(front-1>=0 and vis[front-1]==0){        //check if we can jump to the left then we will add in the queue and mark as visited\\n                    q.push(front-1);\\n                    vis[front-1]=1;\\n                }\\n                if(front+1<n and vis[front+1]==0){         //check if we can jump to the right then we will add in the queue and mark as visited\\n                    q.push(front+1);\\n                    vis[front+1]=1;\\n                }\\n            }\\n            level++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258666,
                "title": "c-bfs-readable-code",
                "content": "# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        const int inf = 1e9;\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        vector<int> dist(n, inf);\\n        dist[0] = 0;\\n\\n        while (!q.empty())\\n        {\\n            auto idx = q.front().first;\\n            auto moves = q.front().second;\\n            q.pop();\\n\\n            assert(idx >= 0 and idx < n);\\n\\n            if (idx == n - 1)\\n                return moves;\\n\\n            if (idx - 1 >= 0 and moves + 1 < dist[idx - 1])\\n            {\\n                dist[idx - 1] = moves + 1;\\n                q.push({idx - 1, moves + 1});\\n            }\\n\\n            if (idx + 1 < n and moves + 1 < dist[idx + 1])\\n            {\\n                dist[idx + 1] = moves + 1;\\n                q.push({idx + 1, moves + 1});\\n            }\\n\\n            for (auto i : mp[arr[idx]])\\n            {\\n                if (i != idx and moves + 1 < dist[i])\\n                {\\n                    dist[i] = moves + 1;\\n                    q.push({i, moves + 1});\\n                }\\n            }\\n            mp.erase(arr[idx]);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        const int inf = 1e9;\\n\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        \\n        vector<int> dist(n, inf);\\n        dist[0] = 0;\\n\\n        while (!q.empty())\\n        {\\n            auto idx = q.front().first;\\n            auto moves = q.front().second;\\n            q.pop();\\n\\n            assert(idx >= 0 and idx < n);\\n\\n            if (idx == n - 1)\\n                return moves;\\n\\n            if (idx - 1 >= 0 and moves + 1 < dist[idx - 1])\\n            {\\n                dist[idx - 1] = moves + 1;\\n                q.push({idx - 1, moves + 1});\\n            }\\n\\n            if (idx + 1 < n and moves + 1 < dist[idx + 1])\\n            {\\n                dist[idx + 1] = moves + 1;\\n                q.push({idx + 1, moves + 1});\\n            }\\n\\n            for (auto i : mp[arr[idx]])\\n            {\\n                if (i != idx and moves + 1 < dist[i])\\n                {\\n                    dist[i] = moves + 1;\\n                    q.push({i, moves + 1});\\n                }\\n            }\\n            mp.erase(arr[idx]);\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258651,
                "title": "c-easiest-optimised-approach-line-by-line-explanation-beats-100",
                "content": "# Intuition\\nThe given problem is to find the minimum number of steps to reach the last index of the array, where in one step, we can either move to the adjacent indices or to any index having the same value as the current index.\\n\\nThe approach used to solve this problem is Breadth-First Search (BFS), where we start traversing the array from the first index, and at each step, we explore all the possible jumps that can be made from the current index. We keep track of the visited indices to avoid revisiting the same indices again, and we also maintain a queue to keep track of the indices that need to be explored in the next step.\\n\\n\\n# Approach\\nFor each index, we explore three possible jumps:\\n\\ni + 1, where i + 1 < arr.length\\ni - 1, where i - 1 >= 0\\nj where arr[i] == arr[j] and i != j\\n\\nIf any of the next indices haven\\'t been visited before, we mark them as visited and add them to the queue. We repeat this process until we reach the last index of the array or until there are no more indices to explore in the queue.\\n\\nThe minimum number of steps to reach the last index of the array is the number of steps required to reach the last index from the first index, which is the number of levels in the BFS tree.\\n\\nTherefore, the intuition behind this approach is to explore all the possible jumps from each index of the array in a breadth-first manner until we reach the last index, and we maintain a count of the number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the BFS algorithm used to solve this problem is O(n), where n is the number of elements in the array. This is because we visit each element of the array exactly once, and for each element, we explore at most three possible jumps.\\n\\n- Space complexity:\\nThe space complexity of the algorithm is also O(n), as we need to store the visited array of size n and the queue of size at most n, which can happen in the worst case when all elements have the same value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) return 0;\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) return steps;\\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                for (int nextIndex : indices[arr[curr]]) {\\n                    if (nextIndex != curr && !visited[nextIndex]) {\\n                        visited[nextIndex] = true;\\n                        q.push(nextIndex);\\n                    }\\n                }\\n                indices[arr[curr]].clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n//\\uD83D\\uDC47UPVOTE IF YOU LIKED MY SOLUTION\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) return 0;\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.front();\\n                q.pop();\\n                if (curr == n - 1) return steps;\\n                if (curr + 1 < n && !visited[curr + 1]) {\\n                    visited[curr + 1] = true;\\n                    q.push(curr + 1);\\n                }\\n                if (curr - 1 >= 0 && !visited[curr - 1]) {\\n                    visited[curr - 1] = true;\\n                    q.push(curr - 1);\\n                }\\n                for (int nextIndex : indices[arr[curr]]) {\\n                    if (nextIndex != curr && !visited[nextIndex]) {\\n                        visited[nextIndex] = true;\\n                        q.push(nextIndex);\\n                    }\\n                }\\n                indices[arr[curr]].clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n//\\uD83D\\uDC47UPVOTE IF YOU LIKED MY SOLUTION\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258907,
                "title": "leetcode-the-hard-way-bidirectional-bfs-explained",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=S6hagPEHjAY&list=PLBu4Bche1aEWeSa2dtoFf---oF0hwokdE&index=5) if you are interested.\\n\\n---\\n\\n```py\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        loc = defaultdict(list)\\n        # v can go to index i\\n        for i, v in enumerate(arr): loc[v].append(i)\\n        # q: from left to right\\n        # q2: from right to left\\n        q, q2 = deque([0]), deque([n - 1])\\n        # vis: visited state for q\\n        # vis2: visited state for q2\\n        vis, vis2 = {0}, {n - 1}\\n        ans = 0\\n        # Bidirectional BFS\\n        while q:\\n            # process the shortest queue\\n            if len(q2) < len(q):\\n                q, q2 = q2, q\\n                vis, vis2 = vis2, vis\\n            for _ in range(len(q)):\\n                # get the current element\\n                x = q.popleft()\\n                # if `x` exists in vis2, \\n                # that means we\\'ve processed the rest already\\n                if x in vis2:\\n                    return ans\\n                # otherwise, we can either jump to \\n                # - prev index or \\n                # - next index or\\n                # - any index j where arr[i] == arr[j] and i != j\\n                for i in [x - 1, x + 1] + loc[arr[x]]:\\n                    # check if the next index is within the bound \\n                    # and visitied or not\\n                    if 0 <= i < n and i not in vis:\\n                        # mark it visited\\n                        vis.add(i)\\n                        # add to the queue\\n                        q.append(i)\\n                # remove loc[arr[x]] to speed up since we\\'ve processed it\\n                del loc[arr[x]]\\n            # add one step\\n            ans += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```py\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        loc = defaultdict(list)\\n        # v can go to index i\\n        for i, v in enumerate(arr): loc[v].append(i)\\n        # q: from left to right\\n        # q2: from right to left\\n        q, q2 = deque([0]), deque([n - 1])\\n        # vis: visited state for q\\n        # vis2: visited state for q2\\n        vis, vis2 = {0}, {n - 1}\\n        ans = 0\\n        # Bidirectional BFS\\n        while q:\\n            # process the shortest queue\\n            if len(q2) < len(q):\\n                q, q2 = q2, q\\n                vis, vis2 = vis2, vis\\n            for _ in range(len(q)):\\n                # get the current element\\n                x = q.popleft()\\n                # if `x` exists in vis2, \\n                # that means we\\'ve processed the rest already\\n                if x in vis2:\\n                    return ans\\n                # otherwise, we can either jump to \\n                # - prev index or \\n                # - next index or\\n                # - any index j where arr[i] == arr[j] and i != j\\n                for i in [x - 1, x + 1] + loc[arr[x]]:\\n                    # check if the next index is within the bound \\n                    # and visitied or not\\n                    if 0 <= i < n and i not in vis:\\n                        # mark it visited\\n                        vis.add(i)\\n                        # add to the queue\\n                        q.append(i)\\n                # remove loc[arr[x]] to speed up since we\\'ve processed it\\n                del loc[arr[x]]\\n            # add one step\\n            ans += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691093,
                "title": "python3-recursive-bfs-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThis problem can be approached as finding the shortest path in a graph. If we take an index of the `arr` as a node, we can see that from that node we can go to `i-1`, `i+1` and to `j` where `arr[i] == arr[j]`. We could build an adjacency list but it\\'s not necessary because `i-1` and `i+1` can be calculated from the index. The only thing we need is a hashmap `groups` with the list of elements where we can jump directly from the current element.\\n\\nWhen the hashmap is ready, we can traverse the graph level by level using standard BFS and find the shortest distance to the last element. There is one catch here though. It\\'s not enough to keep a set of visited nodes. For example, this array `[7,7,7,7,7,7,7 .......,11]` with max number of elements will give us a TME since we have to visit 7s on every iteration which will give us an `O(n^2)` complexity. We need to ignore such groups after we visited them once. That is why we have another set for visited groups along with the set of visited nodes.\\n\\nTime: **O(E+V)** - BFS\\nSpace: **O(n)** - hashmap\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N, groups = len(arr), defaultdict(list)\\n\\n        for i, el in enumerate(arr): \\n            groups[el].append(i)\\n\\n        vis, vis_groups = set(), set()\\n        \\n        def bfs(lvl, dist):\\n            nextLvl = set()\\n            \\n            for i in lvl:\\n                if i in vis: continue\\n                if i == N-1: return dist\\n                \\n                vis.add(i)\\n                \\n                if i: nextLvl.add(i-1)\\n                if i+1 < N: nextLvl.add(i+1)\\n                \\n                if not arr[i] in vis_groups:\\n                    vis_groups.add(arr[i])\\n                    nextLvl.update(groups[arr[i]])\\n            \\n            return bfs(nextLvl, dist + 1)\\n            \\n        return bfs(set([0]), 0)\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N, groups = len(arr), defaultdict(list)\\n\\n        for i, el in enumerate(arr): \\n            groups[el].append(i)\\n\\n        vis, vis_groups = set(), set()\\n        \\n        def bfs(lvl, dist):\\n            nextLvl = set()\\n            \\n            for i in lvl:\\n                if i in vis: continue\\n                if i == N-1: return dist\\n                \\n                vis.add(i)\\n                \\n                if i: nextLvl.add(i-1)\\n                if i+1 < N: nextLvl.add(i+1)\\n                \\n                if not arr[i] in vis_groups:\\n                    vis_groups.add(arr[i])\\n                    nextLvl.update(groups[arr[i]])\\n            \\n            return bfs(nextLvl, dist + 1)\\n            \\n        return bfs(set([0]), 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690827,
                "title": "c-bfs-solution",
                "content": "```\\n int minJumps(vector<int>& arr) {\\n        \\n       unordered_map<int,vector<int>> mp;\\n        \\n       for(int i=0;i<arr.size();i++){\\n           mp[arr[i]].push_back(i);\\n       }\\n       \\n        queue<int> q;\\n        q.push(0);\\n        \\n        vector<int> dis(arr.size(),1e9);\\n        \\n        dis[0]=0;\\n        \\n        while(!q.empty()){\\n            \\n            int index=q.front();\\n            q.pop();\\n            \\n            if(index==arr.size() - 1) return dis[index];\\n            \\n            vector<int> &list=mp[arr[index]];\\n            list.push_back(index - 1);\\n            list.push_back(index + 1);\\n            \\n            \\n            for(auto  &x : list){\\n                \\n                if(x>=0 and x<arr.size() and dis[x]>dis[index] + 1){\\n                    dis[x] = dis[index] + 1;\\n                    q.push(x);\\n                }\\n            }\\n            list.clear();\\n        }\\n        \\n        return -1;\\n    }\\n```\\nConnect with me :[ Linkedin ](https://www.linkedin.com/in/sarvesh-khandelwal-206b171a7/)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n int minJumps(vector<int>& arr) {\\n        \\n       unordered_map<int,vector<int>> mp;\\n        \\n       for(int i=0;i<arr.size();i++){\\n           mp[arr[i]].push_back(i);\\n       }\\n       \\n        queue<int> q;\\n        q.push(0);\\n        \\n        vector<int> dis(arr.size(),1e9);\\n        \\n        dis[0]=0;\\n        \\n        while(!q.empty()){\\n            \\n            int index=q.front();\\n            q.pop();\\n            \\n            if(index==arr.size() - 1) return dis[index];\\n            \\n            vector<int> &list=mp[arr[index]];\\n            list.push_back(index - 1);\\n            list.push_back(index + 1);\\n            \\n            \\n            for(auto  &x : list){\\n                \\n                if(x>=0 and x<arr.size() and dis[x]>dis[index] + 1){\\n                    dis[x] = dis[index] + 1;\\n                    q.push(x);\\n                }\\n            }\\n            list.clear();\\n        }\\n        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1502824,
                "title": "simple-bfs-transversal-c-clean-code",
                "content": "Idea is simple, create a graph connecting all the idexes which satisfy the given conditions, \\nlike:- i + 1 where: i + 1 < arr.length.\\n        i - 1 where: i - 1 >= 0.\\n       j where: arr[i] == arr[j] and i != j.\\nfor third condition we are maintaing a graph.\\nNow we have a directed, unweighted graph and our task is to find the shorted distance between index 0 and n-1. Use BFS for it and maintain a visited which will also keep track of distance of node from 0.\\nBelow is the simple implementation of it,\\n\\n````\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);     // keep track of visit\\n        \\n        map<int,vector<int>>mp;      // store the index for which values are same \\n        for(int i=0;i<n;i++)\\n        { \\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int> adj[n];         //create adjancy list \\n        // build graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-1>=0)\\n            adj[i].push_back(i-1);\\n            if(i+1<n)\\n            adj[i].push_back(i+1);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        // BFS transversal\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n\\t\\t    int u=q.front();\\n\\t\\t    q.pop();\\n            if(u==n-1)\\n                return visited[u]-1;\\n\\t\\t    for(int v : adj[u])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    q.push(v);\\n                    visited[v]=visited[u]+1;\\n                }\\n\\t\\t    }\\n            for(auto v:mp[arr[u]])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    visited[v]=visited[u]+1;\\n                    q.push(v);\\n\\t\\t        }\\n            }\\n            mp[arr[u]].clear();\\n        }\\n        return visited[n-1]-1;      // return distance of n-1 index from 0\\n       }\\n};\\n````\\nPlaese upvote it if found helpful\\nHappy Coding!!",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>visited(n,0);     // keep track of visit\\n        \\n        map<int,vector<int>>mp;      // store the index for which values are same \\n        for(int i=0;i<n;i++)\\n        { \\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<int> adj[n];         //create adjancy list \\n        // build graph\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i-1>=0)\\n            adj[i].push_back(i-1);\\n            if(i+1<n)\\n            adj[i].push_back(i+1);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        visited[0]=1;\\n        // BFS transversal\\n\\t\\twhile(!q.empty())\\n\\t\\t{\\n\\t\\t    int u=q.front();\\n\\t\\t    q.pop();\\n            if(u==n-1)\\n                return visited[u]-1;\\n\\t\\t    for(int v : adj[u])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    q.push(v);\\n                    visited[v]=visited[u]+1;\\n                }\\n\\t\\t    }\\n            for(auto v:mp[arr[u]])\\n            {\\n                if(visited[v]==0)\\n                {\\n                    visited[v]=visited[u]+1;\\n                    q.push(v);\\n\\t\\t        }\\n            }\\n            mp[arr[u]].clear();\\n        }\\n        return visited[n-1]-1;      // return distance of n-1 index from 0\\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256637,
                "title": "clean-and-concise-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<bool>vis(n, false);\\n        unordered_map<int, vector<int> >mp;\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        q.push(0);\\n        vis[0] = true;\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if(i == n-1)return step;\\n                if(i+1 < n && !vis[i+1])vis[i+1] = true, q.push(i+1);\\n                if(i-1 >= 0 && !vis[i-1])vis[i-1] = true, q.push(i-1);\\n                for(auto &j : mp[arr[i]])\\n                    if(!vis[j])vis[j] = true, q.push(j);\\n                mp.erase(arr[i]); // Comment this line..You will get TLE\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<bool>vis(n, false);\\n        unordered_map<int, vector<int> >mp;\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        queue<int>q;\\n        q.push(0);\\n        vis[0] = true;\\n        int step = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if(i == n-1)return step;\\n                if(i+1 < n && !vis[i+1])vis[i+1] = true, q.push(i+1);\\n                if(i-1 >= 0 && !vis[i-1])vis[i-1] = true, q.push(i-1);\\n                for(auto &j : mp[arr[i]])\\n                    if(!vis[j])vis[j] = true, q.push(j);\\n                mp.erase(arr[i]); // Comment this line..You will get TLE\\n            }\\n            step++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691583,
                "title": "java-23ms-100-super-fast-bfs-optimizations-explained",
                "content": "UPDATE March 2023:  The test cases for this leetcode problem have changed, so that this code is now much slower, with a runtime of 1500ms.  In many leetcode problems, when passed an arrays, it is frequently assumed that the arrays will be processed from low-index start to high-index end.  The test cases contain a few test cases that are frequently designed to be difficult when processed from start to end, but usually no test cases that are difficult when processed backward, from end back to start.  After this code was faster than all other code on the runtime graph, someone added test case(s) that are difficult when processing the passed array from end to start.  This has happened in multiple other leetcode problems, where I had code that was very fast when processing arrays backward.  I\\'m glad people have added more robust test cases, even though some of my very fast code now runs much slower.  In one case, someone added new test cases that are difficult when processing the array from end back to start, so I changed my code to process the array from center outward very quickly.  Then someone added difficult test cases when processing the array from the center outward.  It is good to find leetcoders that can create test cases that fill these processing gaps, and be more difficult for more types of algorithms.\\n\\nORIGINAL Januaray 2022:\\nThe Java code below runs as fast as 23ms on 2022-01-15.  The next fastest entry on the graph at this date was 33ms.  Clicking the \"Submit\" button in a leetcode problem multiple times, can result in different runtimes for each submit.  The code below had runtimes from 23ms to 91ms.  Runtimes may also change when leetcode adds new test cases in the future.\\n\\nFor leetcode problem #1345 \"Jump Game IV\":  The code below uses a Breadth First Search (BFS) algorithm.  A BFS algorithm usually searches layer-by-layer from a defined starting point, until the goal of the search is found.  The code below starts at a pre-defined index in the array `arr[]`.  All possible valid moves from that pre-defined index in `arr[]`, are saved as indexes in the next \"layer\" of the search.  Then the BFS uses all the indexes from that saved layer, to try all possible valid moves from those indexes, and save those indexes in a new layer.  The BFS advances the search layer by layer, until reaching the end of the search.\\n\\nThe code below is optimized for speed.  Several optimizations are used to gain speed.  Some of these optimizations are basic to many Breadth First Search implementations.  Some optimizations are specific to this leetcode problem.  Optimizations are:\\n\\n**Search backward:**  This leetcode problem discussion says to start at index 0 and find the minimum number of valid moves to \"jump\" to index `arr.length-1`.  The rules of \"jumps\" in this problem are symmetric, so that the answer will be the same using going from start to end, or from end to start.  The code below uses the Breadth First Search going from the end-point of the game (the last index in the array; `arr[arr.length-1]`) backward to the start-point in the game (index zero; `arr[0]`). In leetcode problems, when processing can be done either from start to end, or from end to start, it is frequently faster to process backward.  Processing backward in leetcode problems is usually faster because of the test cases that were designed to be difficult for most problem code.  However some test cases are faster when processed backward.  This leetcode problem has been faster processing in the backward direction.  Therefore the code below starts the BFS at `arr[arr.length-1]` and jumps to `arr[0]`.\\n\\nIn some problems with known start-point and end-point of a Breadth First Search (BFS), it is faster to start a BFS from each end and have the two Breadth First Searches meet in the middle.  This method can be faster when the BFS tree will spread wider and wider for each layer.  By starting at each end and working toward the middle, the BFS trees don\\'t spread as wide and there may be fewer nodes to search.  However, in this leetcode problem, searching from both end toward the middle was slightly slower in my implementation.\\n\\n**Ignore interior values of repeated consecutive values:**  In the passed `arr[]` array, if the same value is repeated multiple times in a row, then only the first and last value of that repeated value are significant for the \"Jump Game IV\" rules.  For example, if\\n ` ` ` ` ` ` ` ` `arr[] = [1,8,8,8,8,8,8,1,4,8,8,7,8]`\\nthen values in `arr[]` can be handled as:\\n ` ` ` ` ` ` ` ` `arr[] = [1,8,*,*,*,*,8,1,4,8,8,7,8]`\\nwhere \"\\\\*\" represents a value that can be ignored for this game.  This is because of the definition of the jump rules.  If we jumped to the first \"8\" at index 1, then there would be no reason to set to index 1+1 when we could jump directly to any other \"8\" and have fewer jumps.\\n \\nThe code below creates a HashMap so that any value in `arr[]` can be looked-up in the HashMap to get a List of all indexes where that same value occurs in `arr[]`.  For example, the HashMap entry for \"1\" would contain the list `{0,7}`.  The HashMap entry for \"8\" would contain the list `{1,6,9,10,12}`.  The \"8\"s at index 2 through 5, the \"\\\\*\"s in the example above, are not saved in this list because they could NOT be on the minimum path in this game.  Ignoring the interior values of repeated consecutive values keep these lists shorter and runtime faster.\\n \\nA test case for this leetcode problem has over 49_000 consecutive \"7\"s.  By ignoring interior values of multiply repeated values in a row, this reduces the HashMap list for \"7\" from over 49_000 indexes to be processes, to a list length of only two \"7\"s to be processed.\\n \\n**Don\\'t reallocate Arrays:**  In the code below, the Breadth First Search (BFS) uses Arrays of `int` to contain the indexes for each layer of the BFS.  The BFS has one array for the current indexes to start a jump from, and another array being filled with the next layer of indexes jumped to.  When the array of current indexes has been fully processed, the two arrays are swapped, which saves the time of deallocating an old array and allocating a new array of the same length.\\n \\nIn Java, an array variable is only a reference, or a pointer, to the array data allocated in memory.  In the following pseudo-code fragment, the process of swapping which array data the variables `curLayer` and `nextLayer` are referencing is shown with the variable name on the left, and lines pointing to which allocated data they are referencing or pointing to.  A temporary variable is used to help swap which data goes with the array variables.  Sorry for the crude text graphics.\\n ```\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ntmpLayer = curLayer;\\n         int[] tmpLayer ------------v\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ncurLayer = nextLayer;\\n         int[] tmpLayer ----------> {...array #1...}\\n         int[] curLayer ------------v\\n         int[] nextLayer ---------> {...array #2...}\\nnextLayer = tmpLayer;\\n                             /----> {...array #1...}\\n         int[] curLayer ----(--\\\\\\n         int[] nextLayer --/    \\\\-> {...array #2...}\\n ```\\n**Use Arrays of primitive type instead of Lists for BFS layers:**  Arrays of primitive types such as `int`, `long`, `boolean`, `byte`, etc. are usually faster runtime than using List or other Collection data types, and are also faster than Arrays of objects such as `Integer`, `Long`, `Boolean`, `Byte`, etc.  Arrays are used in the code below to hold the layers of the Breadth First Search (BFS).  Arrays can be used because the maximum possible length needed for these arrays is known and is not extremely large.  In cases where the maximum possible length is unknown or is extremely large, a List would be better.  This is because an Array\\'s size can NOT be changed, while a List will expand in size as needed.\\n \\n The use of Arrays in the code below was a choice for optimizing for speed.  But Lists would be better for readability, maintaining code, simplifying code, and generally are considered a better programming practice.  In real-world programming, if the requirements have limits on runtime or memory size, Arrays and less readable code may be needed.  These types of speed and memory requirements often happen in real-time and embedded programming, and in some frequently called low-level run-time routines.\\n \\n\\n**If useful, please upvote.**\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        if (len <= 1)  return 0;\\n        if (arr[0] == arr[len - 1])  return 1;\\n\\n        // Put all arr[] values in a HashMap so we can find matching values faster.\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        list.add(0);\\n        map.put(arr[0], list);              // Add arr[0] to the HashMap.\\n        list = new ArrayList<Integer>();\\n        list.add(len - 1);\\n        map.put(arr[len - 1], list);        // Add arr[len - 1] to the HashMap.\\n        // Loop to add arr[1..len-2] to HashMap.\\n        for (int i = 1; i < len - 1; i++) { \\n            list = map.get(arr[i]);\\n            if (list == null) {             // If arr[i] not yet in HashMap...\\n                list = new ArrayList<Integer>();\\n                map.put(arr[i], list);\\n            }\\n            // Add arr[i] to the HashMap only if arr[i] is a different value from \\n            // arr[i-1] or arr[i+1].  Repeated consecutive values can be reduced \\n            // to only the first and last of those repeated consecutive values.  \\n            // Interior values of repeated consecutive values aren\\'t needed because \\n            // we want the minimum number of jumps and we could always jump from \\n            // the same arr[n] value to the start or the end of the same repeated \\n            // consecutive values.  Jumping to the middle of the repeated \\n            // consecutive values would increase the number of jumps beyond the \\n            // minimum number of jumps.  so we ignore interior values of repeated \\n            // consecutive values.  One leetcode test case has more than 49_000 \"7\"s \\n            // in a row.  We can ignore all but the first and last \"7\" of the \\n            // repeated consecutive \"7\"s, which makes the Breadth First Search much \\n            // faster.\\n            if (arr[i - 1] != arr[i] || arr[i + 1] != arr[i])\\n                list.add(i);\\n        }\\n        \\n        // Setup the Breadth First Search (BFS) values to start at the end-point \\n        // of the jumps (last index in arr[]) and work the jumps back to the \\n        // start-point of the jumps (index zero in arr[]).  This is faster than \\n        // going forward, because of test cases for this leetcode problem that \\n        // are designed to be more difficult when going forward.\\n        boolean[] used = new boolean[len];\\n        used[arr.length - 1] = true;\\n        int[] curLayer = new int[len];\\n        int curIdx = 0;\\n        curLayer[curIdx++] = arr.length - 1;\\n        int[] nextLayer = new int[len];\\n        int nextIdx = 0;\\n        int layerLevel = 1;\\n        int[] tmpLayer;\\n        \\n        // Loop until the Breadth First Search (BFS) finds its goal.  The goal is to \\n        // jump to index 0 in arr[] because we are doing the jumps from end-point \\n        // to start-point.\\n        while (true) {\\n            nextIdx = 0;\\n\\n            // Loop through all nodes in the current level of the BFS.\\n            for (int i1 = 0; i1 < curIdx; i1++) {\\n                int i = curLayer[i1];\\n                // Save jump to previous array index, unless we already visited the \\n                // previous array index, or we are at index 1 and therefore the previous \\n                // index is 0 which means that we end the search at index 0.\\n                if (i > 0 && !used[i - 1]) {\\n                    if (i == 1)  return layerLevel;\\n                    used[i - 1] = true;\\n                    nextLayer[nextIdx++] = i - 1;\\n                }\\n                // Save jump to next array index, unless we already visited the next \\n                // array index, or there is no next array index.\\n                if (i < arr.length - 1 && !used[i + 1]) {\\n                    used[i + 1] = true;\\n                    nextLayer[nextIdx++] = i + 1;\\n                }\\n                // Save jump to all other arr[] index that contain the same value as \\n                // arr[i] (the current array entry).  The HashMap contains a list of \\n                // arr[] indexes that contain the same value as arr[i].  If any of \\n                // these jumps are to index 0, then the Breadth First Search is done.\\n                ArrayList<Integer> sameNumIndexes = map.get(arr[i]);\\n                if (sameNumIndexes.size() > 1) {\\n                    for (int j : sameNumIndexes) {\\n                        if (!used[j]) {\\n                            if (j == 0)  return layerLevel;\\n                            used[j] = true;\\n                            nextLayer[nextIdx++] = j;\\n                        }\\n                    }\\n                }\\n                // sameNumIndexes.clear();\\n            }\\n            // Swap the lext level of the BFS to become the new current level of the \\n            // BFS for the next time through the main BFS loop.\\n            tmpLayer = curLayer;\\n            curLayer = nextLayer;\\n            nextLayer = tmpLayer;\\n            curIdx = nextIdx;\\n            layerLevel++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ntmpLayer = curLayer;\\n         int[] tmpLayer ------------v\\n         int[] curLayer ----------> {...array #1...}\\n         int[] nextLayer ---------> {...array #2...}\\ncurLayer = nextLayer;\\n         int[] tmpLayer ----------> {...array #1...}\\n         int[] curLayer ------------v\\n         int[] nextLayer ---------> {...array #2...}\\nnextLayer = tmpLayer;\\n                             /----> {...array #1...}\\n         int[] curLayer ----(--\\\\\\n         int[] nextLayer --/    \\\\-> {...array #2...}\\n ```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        if (len <= 1)  return 0;\\n        if (arr[0] == arr[len - 1])  return 1;\\n\\n        // Put all arr[] values in a HashMap so we can find matching values faster.\\n        HashMap<Integer, ArrayList<Integer>> map = new HashMap();\\n        ArrayList<Integer> list = new ArrayList<Integer>();\\n        list.add(0);\\n        map.put(arr[0], list);              // Add arr[0] to the HashMap.\\n        list = new ArrayList<Integer>();\\n        list.add(len - 1);\\n        map.put(arr[len - 1], list);        // Add arr[len - 1] to the HashMap.\\n        // Loop to add arr[1..len-2] to HashMap.\\n        for (int i = 1; i < len - 1; i++) { \\n            list = map.get(arr[i]);\\n            if (list == null) {             // If arr[i] not yet in HashMap...\\n                list = new ArrayList<Integer>();\\n                map.put(arr[i], list);\\n            }\\n            // Add arr[i] to the HashMap only if arr[i] is a different value from \\n            // arr[i-1] or arr[i+1].  Repeated consecutive values can be reduced \\n            // to only the first and last of those repeated consecutive values.  \\n            // Interior values of repeated consecutive values aren\\'t needed because \\n            // we want the minimum number of jumps and we could always jump from \\n            // the same arr[n] value to the start or the end of the same repeated \\n            // consecutive values.  Jumping to the middle of the repeated \\n            // consecutive values would increase the number of jumps beyond the \\n            // minimum number of jumps.  so we ignore interior values of repeated \\n            // consecutive values.  One leetcode test case has more than 49_000 \"7\"s \\n            // in a row.  We can ignore all but the first and last \"7\" of the \\n            // repeated consecutive \"7\"s, which makes the Breadth First Search much \\n            // faster.\\n            if (arr[i - 1] != arr[i] || arr[i + 1] != arr[i])\\n                list.add(i);\\n        }\\n        \\n        // Setup the Breadth First Search (BFS) values to start at the end-point \\n        // of the jumps (last index in arr[]) and work the jumps back to the \\n        // start-point of the jumps (index zero in arr[]).  This is faster than \\n        // going forward, because of test cases for this leetcode problem that \\n        // are designed to be more difficult when going forward.\\n        boolean[] used = new boolean[len];\\n        used[arr.length - 1] = true;\\n        int[] curLayer = new int[len];\\n        int curIdx = 0;\\n        curLayer[curIdx++] = arr.length - 1;\\n        int[] nextLayer = new int[len];\\n        int nextIdx = 0;\\n        int layerLevel = 1;\\n        int[] tmpLayer;\\n        \\n        // Loop until the Breadth First Search (BFS) finds its goal.  The goal is to \\n        // jump to index 0 in arr[] because we are doing the jumps from end-point \\n        // to start-point.\\n        while (true) {\\n            nextIdx = 0;\\n\\n            // Loop through all nodes in the current level of the BFS.\\n            for (int i1 = 0; i1 < curIdx; i1++) {\\n                int i = curLayer[i1];\\n                // Save jump to previous array index, unless we already visited the \\n                // previous array index, or we are at index 1 and therefore the previous \\n                // index is 0 which means that we end the search at index 0.\\n                if (i > 0 && !used[i - 1]) {\\n                    if (i == 1)  return layerLevel;\\n                    used[i - 1] = true;\\n                    nextLayer[nextIdx++] = i - 1;\\n                }\\n                // Save jump to next array index, unless we already visited the next \\n                // array index, or there is no next array index.\\n                if (i < arr.length - 1 && !used[i + 1]) {\\n                    used[i + 1] = true;\\n                    nextLayer[nextIdx++] = i + 1;\\n                }\\n                // Save jump to all other arr[] index that contain the same value as \\n                // arr[i] (the current array entry).  The HashMap contains a list of \\n                // arr[] indexes that contain the same value as arr[i].  If any of \\n                // these jumps are to index 0, then the Breadth First Search is done.\\n                ArrayList<Integer> sameNumIndexes = map.get(arr[i]);\\n                if (sameNumIndexes.size() > 1) {\\n                    for (int j : sameNumIndexes) {\\n                        if (!used[j]) {\\n                            if (j == 0)  return layerLevel;\\n                            used[j] = true;\\n                            nextLayer[nextIdx++] = j;\\n                        }\\n                    }\\n                }\\n                // sameNumIndexes.clear();\\n            }\\n            // Swap the lext level of the BFS to become the new current level of the \\n            // BFS for the next time through the main BFS loop.\\n            tmpLayer = curLayer;\\n            curLayer = nextLayer;\\n            nextLayer = tmpLayer;\\n            curIdx = nextIdx;\\n            layerLevel++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258509,
                "title": "javascript-beats-100-runtime-167-ms",
                "content": "# Intuition\\nMy thought was to use a Breadth First Search (BFS) algorithm to solve this problem. This type of algorithm searches for a solution by exploring neighboring nodes before moving on to the next layer of nodes (step). The goal of this algorithm is to find the shortest path from the starting node to the destination node.\\n\\n# Approach\\nI used a Map to store the index of each element in the array, and then used a Set to keep track of the indexes that have already been checked. I performed a BFS traversal of the array, starting from the last element, and going towards the beginning. I used the Map to check if the current element had any jumps associated with it and add those indexes to the Set of next indexes to be checked. I also added the adjacent indexes to the Set of next indexes to be checked. Finally, I incremented the step count each time I traversed the array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function (arr) {\\n    const targetIndex = arr.length - 1;\\n    if (targetIndex < 1) return 0;\\n\\n    const map = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!map.has(arr[i])) map.set(arr[i], []);\\n        map.get(arr[i]).push(i);\\n    }\\n\\n    let checkedIndexes = new Set();\\n    let stepCount = 0;\\n    let currentStepIndexes = new Set();\\n    currentStepIndexes.add(targetIndex);\\n    // from right to left. end to start. arr.length - 1 to 0\\n    while (currentStepIndexes.size > 0) {\\n        let nextStepIndexes = new Set();\\n        for (const currentStepIndex of currentStepIndexes.values()) {\\n            checkedIndexes.add(currentStepIndex);\\n\\n            if (currentStepIndex == 0) return stepCount;\\n            // -1\\n            if (currentStepIndex > 0 && !checkedIndexes.has(currentStepIndex - 1)) {\\n                if ((currentStepIndex - 1) == 0) return ++stepCount;\\n                nextStepIndexes.add(currentStepIndex - 1);\\n            }\\n            // jumps\\n            const jumps = map.get(arr[currentStepIndex]);\\n            if (jumps) {\\n                map.delete(arr[currentStepIndex]);\\n                let limit = 0;\\n                for (const jumpIndex of jumps) {\\n                    if (jumpIndex !== currentStepIndex && !checkedIndexes.has(jumpIndex)) {\\n                        limit++;\\n                        if (limit > 5) break;\\n                        if (jumpIndex == 0) return ++stepCount;\\n                        nextStepIndexes.add(jumpIndex);\\n                    }\\n                }\\n            }\\n            // +1\\n            if (currentStepIndex < targetIndex && !checkedIndexes.has(currentStepIndex + 1)) {\\n                nextStepIndexes.add(currentStepIndex + 1);\\n            }\\n        }\\n        currentStepIndexes = nextStepIndexes;\\n        stepCount++;\\n    }\\n    return stepCount;\\n}\\n```\\n\\n**If my work was useful for you, please upvote!**\\n\\n\\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Shortest Path"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function (arr) {\\n    const targetIndex = arr.length - 1;\\n    if (targetIndex < 1) return 0;\\n\\n    const map = new Map();\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!map.has(arr[i])) map.set(arr[i], []);\\n        map.get(arr[i]).push(i);\\n    }\\n\\n    let checkedIndexes = new Set();\\n    let stepCount = 0;\\n    let currentStepIndexes = new Set();\\n    currentStepIndexes.add(targetIndex);\\n    // from right to left. end to start. arr.length - 1 to 0\\n    while (currentStepIndexes.size > 0) {\\n        let nextStepIndexes = new Set();\\n        for (const currentStepIndex of currentStepIndexes.values()) {\\n            checkedIndexes.add(currentStepIndex);\\n\\n            if (currentStepIndex == 0) return stepCount;\\n            // -1\\n            if (currentStepIndex > 0 && !checkedIndexes.has(currentStepIndex - 1)) {\\n                if ((currentStepIndex - 1) == 0) return ++stepCount;\\n                nextStepIndexes.add(currentStepIndex - 1);\\n            }\\n            // jumps\\n            const jumps = map.get(arr[currentStepIndex]);\\n            if (jumps) {\\n                map.delete(arr[currentStepIndex]);\\n                let limit = 0;\\n                for (const jumpIndex of jumps) {\\n                    if (jumpIndex !== currentStepIndex && !checkedIndexes.has(jumpIndex)) {\\n                        limit++;\\n                        if (limit > 5) break;\\n                        if (jumpIndex == 0) return ++stepCount;\\n                        nextStepIndexes.add(jumpIndex);\\n                    }\\n                }\\n            }\\n            // +1\\n            if (currentStepIndex < targetIndex && !checkedIndexes.has(currentStepIndex + 1)) {\\n                nextStepIndexes.add(currentStepIndex + 1);\\n            }\\n        }\\n        currentStepIndexes = nextStepIndexes;\\n        stepCount++;\\n    }\\n    return stepCount;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502756,
                "title": "bfs-get-rid-of-tle",
                "content": "Naive implementation of BFS will get TLE, we can use two ways to get rid of TLE.\\n1) build the children nodes from highest index to lowest indes as highest index is close to target.\\n2) early pruning.\\n\\nI will explain those approach as follows.\\n\\n**1) build the children nodes from highest index to lowest indes**\\nTraverse nodes reversely to build the next children nodes during BFS process as our target is last element of the array and do the searching reversely will make the similar effect of A* algorithm. We search from the close to target element firstly.\\n\\nReversely works very good on the test case below\\n\\n[7,\\u2026,7,7,11] it has many 7s at the beginning of the list.\\n\\nPython code is here:\\n\\nThe critical part to get rid of TLE is using\\n\\na_i[arr[i]][::-1]\\n\\ninstead of a_i[arr[i]].\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i = collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i[a].append(i)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]][::-1]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\\nC++ code is here.\\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```\\n\\n**2) early pruning.**\\nWe can also get rid of TLE by early pruning.\\nSuch as in the following example, the bolded 23 is unnecessary to be explored, we can safely remove it from candidates during early stage.\\n[100,-23,-23,404,100,23,**23**,23,3,404]\\nPython code\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i_,a_i = collections.defaultdict(list),collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i_[a].append(i)\\n        #early pruning.\\n        for key in a_i_:\\n            for j, v in enumerate(a_i_[key]):\\n                #print(j,v)\\n                if j>=1 and j<len(a_i_[key])-1 and a_i_[key][j-1]==v-1 and a_i_[key][j+1]==v+1:continue\\n                a_i[key].append(v)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\\nC++ code\\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n         \\n         // traverse in order get TLE, prune unnesessary nodes can get AC\\n         //[7,..7,11]\\n        unordered_map<int, vector<int>> a_i_;\\n        for(int i=0;i<n;++i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto it=a_i_.begin();it!=a_i_.end();++it){\\n            int k=it->first;\\n            for(int j=0;j<a_i_[k].size();++j){\\n                if(j>=1 && j<a_i_[k].size()-1 && a_i_[k][j+1]==a_i_[k][j]+1 &&a_i_[k][j-1]==a_i_[k][j]-1)continue;\\n                a_i[k].push_back(a_i_[k][j]);\\n            }\\n        }\\n        /*\\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i = collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i[a].append(i)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]][::-1]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        a_i_,a_i = collections.defaultdict(list),collections.defaultdict(list)\\n        for i, a in enumerate(arr):\\n            a_i_[a].append(i)\\n        #early pruning.\\n        for key in a_i_:\\n            for j, v in enumerate(a_i_[key]):\\n                #print(j,v)\\n                if j>=1 and j<len(a_i_[key])-1 and a_i_[key][j-1]==v-1 and a_i_[key][j+1]==v+1:continue\\n                a_i[key].append(v)\\n        def bfs():\\n            from collections import deque\\n            Q = deque([(0,0)])\\n            seen = {0}\\n            while Q:\\n                i, d = Q.popleft()\\n                if i==len(arr)-1:return d\\n                for j in [i-1, i+1]+a_i[arr[i]]:\\n                    if 0<=j<len(arr) and j!=i and j not in seen:\\n                        seen.add(j)\\n                        if j==len(arr)-1:return d+1\\n                        Q.append((j,d+1))\\n        return bfs()\\n```\n```\\nclass Solution {\\n     vector<int> dir = {-1, 1};\\npublic:\\n     int bfs(int n,unordered_map<int, vector<int>> &a_i,vector<int>& arr){\\n            unordered_set<int> visited;\\n            deque<pair<int, int>> Q = {{0,0}};\\n            while(!Q.empty()){\\n                auto this_p = Q.front();\\n                Q.pop_front();\\n                int i=this_p.first, d= this_p.second;\\n                if (i == n-1)return d;\\n                for (auto &di:dir){\\n                    int j=i+di;\\n                    if(j>=0 && j<n){\\n                        //if(j==this_p.first)continue;\\n                        auto it=visited.find(j);\\n                        if(it==visited.end()){\\n                            if(j==n-1)return d+1;\\n                            visited.insert(j);\\n                            Q.emplace_back(j, d+1);\\n                    }\\n                }\\n                }\\n                \\n                for (auto &j:a_i[arr[i]]){\\n                    if(j==i)continue;\\n                    auto it=visited.find(j);\\n                    if(it==visited.end()){\\n                        if(j==n-1)return d+1;\\n                        visited.insert(j);\\n                        Q.emplace_back(make_pair(j, d+1));\\n                    }\\n                }\\n                \\n            }\\n         return 0;\\n        }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> a_i;\\n        int n = arr.size();\\n        /*\\n         // traverse in order get TLE at the fllowing case:\\n         [7,..7,11]\\n        for(int i=0;i<n;++i){\\n            a_i[arr[i]].push_back(i);\\n        }\\n        */\\n         \\n         // traverse in order get TLE, prune unnesessary nodes can get AC\\n         //[7,..7,11]\\n        unordered_map<int, vector<int>> a_i_;\\n        for(int i=0;i<n;++i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        \\n        for(auto it=a_i_.begin();it!=a_i_.end();++it){\\n            int k=it->first;\\n            for(int j=0;j<a_i_[k].size();++j){\\n                if(j>=1 && j<a_i_[k].size()-1 && a_i_[k][j+1]==a_i_[k][j]+1 &&a_i_[k][j-1]==a_i_[k][j]-1)continue;\\n                a_i[k].push_back(a_i_[k][j]);\\n            }\\n        }\\n        /*\\n        // traverse reversely\\n        for(int i=n-1;i>=0;--i){\\n            a_i_[arr[i]].push_back(i);\\n        }\\n        */\\n        \\n       \\n        return bfs(n, a_i,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260466,
                "title": "solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1]) \\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                \\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1]) \\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                \\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694469,
                "title": "why-dp-memoization-is-not-working",
                "content": "I was wondering why DP + Memo is not working , however recursive solution gives TLE. I don\\'t know why the simple memoization technique is not working.Here is my code. Please help - \\n```\\npublic static int minJumpsv2(int[] arr) {\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        boolean [] visited = new boolean[arr.length];\\n        int [] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        Arrays.fill(visited,false);\\n        for (int i=0;i<arr.length;i++) hm.computeIfAbsent(arr[i],v -> new ArrayList<>()).add(i);\\n        return helperv2(arr,0,hm,visited,dp);\\n    }\\n\\t\\n\\tpublic static int helperv2(int [] arr, int i,HashMap<Integer,List<Integer>> hm,boolean [] visited,int[] dp){\\n        if (i<0 || i>=arr.length || visited[i]) return Integer.MAX_VALUE;\\n        if (i== arr.length-1)return 0;\\n        if (dp[i] != -1)return dp[i];\\n        visited[i] = true;\\n        int p1 = helperv2(arr,i+1,hm,visited,dp); \\n        int p2 = helperv2(arr,i-1,hm,visited,dp);\\n        int p3 = Integer.MAX_VALUE;\\n        if (hm.containsKey(arr[i])){\\n            List<Integer> list = hm.get(arr[i]);\\n            for (int index : list) p3 = Math.min(p3,helperv2(arr,index,hm,visited,dp));\\n        }\\n        visited[i] = false;\\n        int min = Math.min(p1, Math.min(p2, p3));\\n        dp[i] = min==Integer.MAX_VALUE ? 0 : min+1;\\n        return dp[i];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\npublic static int minJumpsv2(int[] arr) {\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        boolean [] visited = new boolean[arr.length];\\n        int [] dp = new int[arr.length];\\n        Arrays.fill(dp,-1);\\n        Arrays.fill(visited,false);\\n        for (int i=0;i<arr.length;i++) hm.computeIfAbsent(arr[i],v -> new ArrayList<>()).add(i);\\n        return helperv2(arr,0,hm,visited,dp);\\n    }\\n\\t\\n\\tpublic static int helperv2(int [] arr, int i,HashMap<Integer,List<Integer>> hm,boolean [] visited,int[] dp){\\n        if (i<0 || i>=arr.length || visited[i]) return Integer.MAX_VALUE;\\n        if (i== arr.length-1)return 0;\\n        if (dp[i] != -1)return dp[i];\\n        visited[i] = true;\\n        int p1 = helperv2(arr,i+1,hm,visited,dp); \\n        int p2 = helperv2(arr,i-1,hm,visited,dp);\\n        int p3 = Integer.MAX_VALUE;\\n        if (hm.containsKey(arr[i])){\\n            List<Integer> list = hm.get(arr[i]);\\n            for (int index : list) p3 = Math.min(p3,helperv2(arr,index,hm,visited,dp));\\n        }\\n        visited[i] = false;\\n        int min = Math.min(p1, Math.min(p2, p3));\\n        dp[i] = min==Integer.MAX_VALUE ? 0 : min+1;\\n        return dp[i];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507950,
                "title": "java-bidirectional-bfs",
                "content": "Maintain two queue from head and tail of the array respectively, pick the one with smaller size each time to do the BFS until they meet at the middle.\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int res = 0, n = arr.length;\\n        if(n == 1){\\n            return 0;\\n        }\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> head = new HashSet<>(), tail = new HashSet<>();\\n        head.add(0);\\n        tail.add(n - 1);\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        while(head.size() > 0 && tail.size() > 0){\\n            if(head.size() > tail.size()){\\n                Set<Integer> temp = tail;\\n                tail = head;\\n                head = temp;\\n            }\\n            Set<Integer> next = new HashSet<>();\\n            for(int i : head){\\n                int x = i + 1, y = i - 1;\\n                if(tail.contains(x) || tail.contains(y)){\\n                    return res + 1;\\n                }\\n                if(x < n && !visited[x]){\\n                    visited[x] = true;\\n                    next.add(x);\\n                }\\n                if(y >= 0 && !visited[y]){\\n                    visited[y] = true;\\n                    next.add(y);\\n                }\\n                for(int z : map.get(arr[i])){\\n                    if(z == i){\\n                        continue;\\n                    }\\n                    if(tail.contains(z)){\\n                        return res + 1;\\n                    }\\n                    if(!visited[z]){\\n                        visited[z] = true;\\n                        next.add(z);\\n                    }\\n                }\\n            }\\n            head = next;\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int res = 0, n = arr.length;\\n        if(n == 1){\\n            return 0;\\n        }\\n        boolean[] visited = new boolean[n];\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        }\\n        Set<Integer> head = new HashSet<>(), tail = new HashSet<>();\\n        head.add(0);\\n        tail.add(n - 1);\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        while(head.size() > 0 && tail.size() > 0){\\n            if(head.size() > tail.size()){\\n                Set<Integer> temp = tail;\\n                tail = head;\\n                head = temp;\\n            }\\n            Set<Integer> next = new HashSet<>();\\n            for(int i : head){\\n                int x = i + 1, y = i - 1;\\n                if(tail.contains(x) || tail.contains(y)){\\n                    return res + 1;\\n                }\\n                if(x < n && !visited[x]){\\n                    visited[x] = true;\\n                    next.add(x);\\n                }\\n                if(y >= 0 && !visited[y]){\\n                    visited[y] = true;\\n                    next.add(y);\\n                }\\n                for(int z : map.get(arr[i])){\\n                    if(z == i){\\n                        continue;\\n                    }\\n                    if(tail.contains(z)){\\n                        return res + 1;\\n                    }\\n                    if(!visited[z]){\\n                        visited[z] = true;\\n                        next.add(z);\\n                    }\\n                }\\n            }\\n            head = next;\\n            res++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502972,
                "title": "javascript-bfs-better-than-100",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n  if (arr.length === 1) return 0;\\n  const sameValIdx = new Map();\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    const val = arr[i];\\n    if (!sameValIdx.has(val)) sameValIdx.set(val, []);\\n    sameValIdx.get(val).push(i);\\n  }\\n  \\n  const seen = new Set();\\n  seen.add(0);\\n  const queue = [[0, 0]];\\n  while (queue.length) {\\n    const [idx, step] = queue.shift();\\n    \\n    if (idx - 1 >= 0 && !seen.has(idx - 1)) {\\n      queue.push([idx - 1, step + 1]);\\n      seen.add(idx - 1);\\n    }\\n    if (idx + 1 < arr.length && !seen.has(idx + 1)) {\\n      if (idx + 1 === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n      queue.push([idx + 1, step + 1]);\\n      seen.add(idx + 1);\\n    }\\n    \\n    const targetArr = sameValIdx.get(arr[idx]);\\n    for (let j = 0; j < targetArr.length; j++) {\\n      const i = targetArr[j];\\n      if (!seen.has(i) && i !== idx - 1 && i !== idx + 1) {\\n        if (i === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n        queue.push([i, step + 1]);\\n        seen.add(i);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n  if (arr.length === 1) return 0;\\n  const sameValIdx = new Map();\\n  for (let i = arr.length - 1; i >= 0; i--) {\\n    const val = arr[i];\\n    if (!sameValIdx.has(val)) sameValIdx.set(val, []);\\n    sameValIdx.get(val).push(i);\\n  }\\n  \\n  const seen = new Set();\\n  seen.add(0);\\n  const queue = [[0, 0]];\\n  while (queue.length) {\\n    const [idx, step] = queue.shift();\\n    \\n    if (idx - 1 >= 0 && !seen.has(idx - 1)) {\\n      queue.push([idx - 1, step + 1]);\\n      seen.add(idx - 1);\\n    }\\n    if (idx + 1 < arr.length && !seen.has(idx + 1)) {\\n      if (idx + 1 === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n      queue.push([idx + 1, step + 1]);\\n      seen.add(idx + 1);\\n    }\\n    \\n    const targetArr = sameValIdx.get(arr[idx]);\\n    for (let j = 0; j < targetArr.length; j++) {\\n      const i = targetArr[j];\\n      if (!seen.has(i) && i !== idx - 1 && i !== idx + 1) {\\n        if (i === arr.length - 1) return step + 1; // You have to check here to handle this case [7,7,7,7,7...]\\n        queue.push([i, step + 1]);\\n        seen.add(i);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502765,
                "title": "c-bfs-greedy",
                "content": "* Precompute in map value to list of indices\\n* Greedily try to take the farthest node \\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n            mp[arr[i]].push_back(i);\\n        int n = arr.size();\\n        vector<int> vis(n, false);\\n        q.push({ n - 1, 0 });\\n        vis[n - 1] = 1;\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n\\t\\t\\tint f = q.front().first;\\n\\t\\t\\tint steps = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(f == 0)\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\tif(f - 1 >= 0 && !vis[f - 1]) {\\n\\t\\t\\t\\tq.push({ f - 1, steps + 1 });\\n\\t\\t\\t\\tvis[f - 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(f + 1 < n && !vis[f + 1]) {\\n\\t\\t\\t\\tq.push({ f + 1, steps + 1 });\\n\\t\\t\\t\\tvis[f + 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto j : mp[arr[f]]) {\\n\\t\\t\\t\\tif(j == f)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(!vis[j]) {\\n\\t\\t\\t\\t\\tvis[j] = true;\\n\\t\\t\\t\\t\\tq.push({ j, steps + 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return -1; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n            mp[arr[i]].push_back(i);\\n        int n = arr.size();\\n        vector<int> vis(n, false);\\n        q.push({ n - 1, 0 });\\n        vis[n - 1] = 1;\\n        int steps = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n\\t\\t\\tint f = q.front().first;\\n\\t\\t\\tint steps = q.front().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tif(f == 0)\\n\\t\\t\\t\\treturn steps;\\n\\t\\t\\tif(f - 1 >= 0 && !vis[f - 1]) {\\n\\t\\t\\t\\tq.push({ f - 1, steps + 1 });\\n\\t\\t\\t\\tvis[f - 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tif(f + 1 < n && !vis[f + 1]) {\\n\\t\\t\\t\\tq.push({ f + 1, steps + 1 });\\n\\t\\t\\t\\tvis[f + 1] = true;\\n\\t\\t\\t}\\n\\t\\t\\tfor(auto j : mp[arr[f]]) {\\n\\t\\t\\t\\tif(j == f)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tif(!vis[j]) {\\n\\t\\t\\t\\t\\tvis[j] = true;\\n\\t\\t\\t\\t\\tq.push({ j, steps + 1 });\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return -1; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259383,
                "title": "very-easy-100-easiest-logic-ever-fully-explained-step-by-step-c-javascript-java-python",
                "content": "# Intuition\\nThe main idea is to build a graph where each node represents a value in the input array, and each edge represents a connection between two indexes with the same value or between two adjacent indexes. Then, we perform a Breadth-First Search (BFS) starting from index 0 to find the shortest path to the last index, where each step corresponds to a jump.\\n\\n# Approach\\nIn this implementation, we use a Map object to represent the graph, a jumps array to keep track of the minimum number of jumps to reach each index, and a queue q to store the indexes to visit. We initialize the jumps array to -1, except for the first index which has a free jump. We also delete the nodes from the graph as we visit them to avoid revisiting them.\\n\\n# Complexity\\n- Time complexity:\\nThis solution has a time complexity of O(n + k log k), where n is the length of the input array and k is the number of distinct values in the array. \\n- Space complexity:\\nThe space complexity is also O(n + k), to store the graph and the jumps array.\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\n\\nvar minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; // edge case: only one element, no jumps needed\\n    const jumps = new Array(n).fill(-1); // initialize jumps array to -1\\n    const graph = new Map(); // create a map to represent the graph of connections\\n    for (let i = 0; i < n; i++) {\\n        if (!graph.has(arr[i])) graph.set(arr[i], []);\\n        graph.get(arr[i]).push(i); // add current index to the list of indexes with the same value\\n    }\\n    const q = [0]; // start BFS from index 0\\n    jumps[0] = 0; // first jump is free\\n    while (q.length > 0) {\\n        const currIndex = q.shift();\\n        const currValue = arr[currIndex];\\n        const neighbors = graph.get(currValue);\\n        if (neighbors) { // add a check for truthy value\\n            for (const neighborIndex of neighbors) {\\n                if (jumps[neighborIndex] === -1) { // if neighbor has not been visited yet\\n                    jumps[neighborIndex] = jumps[currIndex] + 1; // update number of jumps\\n                    q.push(neighborIndex); // add neighbor to the queue\\n                }\\n            }\\n            graph.delete(currValue); // remove current value from the graph to avoid revisiting it\\n        }\\n        if (currIndex - 1 >= 0 && jumps[currIndex - 1] === -1) { // check left neighbor\\n            jumps[currIndex - 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex - 1); // add left neighbor to the queue\\n        }\\n        if (currIndex + 1 < n && jumps[currIndex + 1] === -1) { // check right neighbor\\n            jumps[currIndex + 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex + 1); // add right neighbor to the queue\\n        }\\n    }\\n    return jumps[n - 1]; // return minimum number of jumps to reach the last index\\n};\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/67e34a02-d9d5-4376-a343-20c2fad7b455_1678004108.3564777.png)\\n\\n# Please Upvote\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\n\\nvar minJumps = function(arr) {\\n    const n = arr.length;\\n    if (n === 1) return 0; // edge case: only one element, no jumps needed\\n    const jumps = new Array(n).fill(-1); // initialize jumps array to -1\\n    const graph = new Map(); // create a map to represent the graph of connections\\n    for (let i = 0; i < n; i++) {\\n        if (!graph.has(arr[i])) graph.set(arr[i], []);\\n        graph.get(arr[i]).push(i); // add current index to the list of indexes with the same value\\n    }\\n    const q = [0]; // start BFS from index 0\\n    jumps[0] = 0; // first jump is free\\n    while (q.length > 0) {\\n        const currIndex = q.shift();\\n        const currValue = arr[currIndex];\\n        const neighbors = graph.get(currValue);\\n        if (neighbors) { // add a check for truthy value\\n            for (const neighborIndex of neighbors) {\\n                if (jumps[neighborIndex] === -1) { // if neighbor has not been visited yet\\n                    jumps[neighborIndex] = jumps[currIndex] + 1; // update number of jumps\\n                    q.push(neighborIndex); // add neighbor to the queue\\n                }\\n            }\\n            graph.delete(currValue); // remove current value from the graph to avoid revisiting it\\n        }\\n        if (currIndex - 1 >= 0 && jumps[currIndex - 1] === -1) { // check left neighbor\\n            jumps[currIndex - 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex - 1); // add left neighbor to the queue\\n        }\\n        if (currIndex + 1 < n && jumps[currIndex + 1] === -1) { // check right neighbor\\n            jumps[currIndex + 1] = jumps[currIndex] + 1; // update number of jumps\\n            q.push(currIndex + 1); // add right neighbor to the queue\\n        }\\n    }\\n    return jumps[n - 1]; // return minimum number of jumps to reach the last index\\n};\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257984,
                "title": "jump-game-iv-solving-the-leetcode-challenge-march-5-2023-fully-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/d5bd5c46-5f44-4fa7-820f-dd165a96fb91_1677816522.0925934.png)\\n\\n# Full explaination at : [Solution](https://yoichiisagi.hashnode.dev/jump-game-iv-solving-the-leetcode-challenge-march-5-2023)\\n\\n![image.png](https://assets.leetcode.com/users/images/6907ce4f-a766-4668-bd51-1cedade65e46_1677816533.0083919.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic int minJumps(int[] arr) {\\n    int n = arr.length;\\n    if(n == 1) return 0;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    for(int i = 0; i < n; i++) {\\n        List<Integer> list = map.get(arr[i]);\\n        if(list == null) map.put(arr[i], list = new ArrayList<>());\\n        list.add(i);\\n    }\\n    int[] visited = new int[n];\\n    Deque<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n    visited[0] = 1;\\n    forward.add(0);\\n    visited[n - 1] = 2;\\n    backward.add(n - 1);\\n    for(int res = 1, dir = 1; ; res++) {\\n        if(forward.size() > backward.size()) {\\n            Deque<Integer> temp = forward; forward = backward; backward = temp;\\n            dir = 3 - dir;\\n        }\\n        for(int size = forward.size(); size-- > 0; ) {\\n            int i = forward.poll();\\n            List<Integer> list = map.get(arr[i]);\\n            if(i - 1 >= 0) list.add(i - 1);\\n            if(i + 1 < n) list.add(i + 1);\\n            for(int j: list) {\\n                if(visited[j] == 0) {\\n                    visited[j] = dir;\\n                    forward.add(j);\\n                } else if(visited[j] != dir) return res;\\n            }\\n            list.clear();\\n        }\\n    }\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int minJumps(int[] arr) {\\n    int n = arr.length;\\n    if(n == 1) return 0;\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    for(int i = 0; i < n; i++) {\\n        List<Integer> list = map.get(arr[i]);\\n        if(list == null) map.put(arr[i], list = new ArrayList<>());\\n        list.add(i);\\n    }\\n    int[] visited = new int[n];\\n    Deque<Integer> forward = new LinkedList<>(), backward = new LinkedList<>();\\n    visited[0] = 1;\\n    forward.add(0);\\n    visited[n - 1] = 2;\\n    backward.add(n - 1);\\n    for(int res = 1, dir = 1; ; res++) {\\n        if(forward.size() > backward.size()) {\\n            Deque<Integer> temp = forward; forward = backward; backward = temp;\\n            dir = 3 - dir;\\n        }\\n        for(int size = forward.size(); size-- > 0; ) {\\n            int i = forward.poll();\\n            List<Integer> list = map.get(arr[i]);\\n            if(i - 1 >= 0) list.add(i - 1);\\n            if(i + 1 < n) list.add(i + 1);\\n            for(int j: list) {\\n                if(visited[j] == 0) {\\n                    visited[j] = dir;\\n                    forward.add(j);\\n                } else if(visited[j] != dir) return res;\\n            }\\n            list.clear();\\n        }\\n    }\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691100,
                "title": "this-solution-is-what-you-are-looking-for-unordered-map-int-vector-int-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]].push_back(i);\\n\\n        int ans = -1;\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto idx = q.front(); q.pop();\\n\\n                if(idx == arr.size()-1) return ans;\\n\\n                if(idx+1 < arr.size() and mp.count(arr[idx+1]))\\n                    q.push(idx+1);\\n\\n                if(idx-1 >= 0 and mp.count(arr[idx-1]))\\n                    q.push(idx-1);\\n\\n                for(auto nextIdx : mp[arr[idx]]){\\n                    if(idx == nextIdx) continue;\\n                    q.push(nextIdx);\\n                }\\n\\n                mp.erase(arr[idx]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n            mp[arr[i]].push_back(i);\\n\\n        int ans = -1;\\n        queue<int> q;\\n        q.push(0);\\n\\n        while(q.size()){\\n            int sz = q.size();\\n            ans++;\\n            while(sz--){\\n                auto idx = q.front(); q.pop();\\n\\n                if(idx == arr.size()-1) return ans;\\n\\n                if(idx+1 < arr.size() and mp.count(arr[idx+1]))\\n                    q.push(idx+1);\\n\\n                if(idx-1 >= 0 and mp.count(arr[idx-1]))\\n                    q.push(idx-1);\\n\\n                for(auto nextIdx : mp[arr[idx]]){\\n                    if(idx == nextIdx) continue;\\n                    q.push(nextIdx);\\n                }\\n\\n                mp.erase(arr[idx]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696842,
                "title": "python-bfs-solution",
                "content": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(arr)):\\n            graph[arr[i]].append(i)\\n            \\n        visited = set()\\n        src,dest = 0,len(arr)-1\\n        queue = deque()\\n        queue.append((src,0))\\n        visited.add(src)\\n        while queue:\\n            node,dist = queue.popleft()\\n            if node == dest:\\n                return dist\\n            for child in [node-1, node+1] + graph[arr[node]][::-1]:\\n                if 0 <= child < len(arr) and child != node and child not in visited:\\n                    visited.add(child)\\n                    if child == dest:\\n                        return dist+1\\n                    queue.append((child,dist+1))\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(arr)):\\n            graph[arr[i]].append(i)\\n            \\n        visited = set()\\n        src,dest = 0,len(arr)-1\\n        queue = deque()\\n        queue.append((src,0))\\n        visited.add(src)\\n        while queue:\\n            node,dist = queue.popleft()\\n            if node == dest:\\n                return dist\\n            for child in [node-1, node+1] + graph[arr[node]][::-1]:\\n                if 0 <= child < len(arr) and child != node and child not in visited:\\n                    visited.add(child)\\n                    if child == dest:\\n                        return dist+1\\n                    queue.append((child,dist+1))\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258857,
                "title": "c-bfs-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& v) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<v.size();i++){\\n            m[v[i]].push_back(i);\\n        }\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n                auto j = q.front();\\n                int ct=j.second;\\n                int in=j.first;\\n                q.pop();\\n                if(in==n-1)return ct;\\n                if(in-1>=0 && !vis[in-1]){\\n                    q.push({in-1,ct+1});\\n                }\\n                if(in+1<n && !vis[in+1]){\\n                    q.push({in+1,ct+1});\\n                }\\n                if(!vis[in]){\\n                    vis[in]=1;\\n                    vector<int>vec=m[v[in]];\\n                    for(int g=0;g<vec.size();g++){\\n                        if(!vis[vec[g]]){\\n                            vis[vec[g]]=1;\\n                            q.push({vec[g],ct+1});\\n                        }\\n                    }\\n                }\\n        }\\n        return 1; //it doesn\\'t matter\\n    }\\n};\\n```\\n![upvote (3).jpg](https://assets.leetcode.com/users/images/8043040d-d34a-4272-9ec5-f22791d1051f_1677996638.420801.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& v) {\\n        map<int,vector<int>>m;\\n        for(int i=0;i<v.size();i++){\\n            m[v[i]].push_back(i);\\n        }\\n        int n=v.size();\\n        vector<int>vis(n,0);\\n        queue<pair<int,int>>q;\\n        q.push({0,0});\\n        while(q.size()){\\n                auto j = q.front();\\n                int ct=j.second;\\n                int in=j.first;\\n                q.pop();\\n                if(in==n-1)return ct;\\n                if(in-1>=0 && !vis[in-1]){\\n                    q.push({in-1,ct+1});\\n                }\\n                if(in+1<n && !vis[in+1]){\\n                    q.push({in+1,ct+1});\\n                }\\n                if(!vis[in]){\\n                    vis[in]=1;\\n                    vector<int>vec=m[v[in]];\\n                    for(int g=0;g<vec.size();g++){\\n                        if(!vis[vec[g]]){\\n                            vis[vec[g]]=1;\\n                            q.push({vec[g],ct+1});\\n                        }\\n                    }\\n                }\\n        }\\n        return 1; //it doesn\\'t matter\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257899,
                "title": "c-beats-94-using-bfs-and-set",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>&arr) \\n    {\\n        //BFS\\n        vector<bool>reachedindex(arr.size(),false);\\n        unordered_map<int,vector<int>>indexofval;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            indexofval[arr[i]].push_back(i);\\n        }\\n        queue<int>toreach;\\n        toreach.push(0);\\n        reachedindex[0]=true;\\n        int steps=0;\\n        while(!toreach.empty())\\n        {\\n            int n=toreach.size();\\n            while(n--)\\n            {\\n                int x=toreach.front();\\n                if(x==arr.size()-1)\\n                {\\n                    return steps;\\n                }\\n                toreach.pop();\\n                for(auto j:indexofval[arr[x]])\\n                {\\n                    if(!reachedindex[j])\\n                    {\\n                        toreach.push(j);\\n                        reachedindex[j]=true;\\n                    }\\n                }\\n                if((x-1)>0 && !reachedindex[x-1])\\n                {\\n                    toreach.push(x-1);\\n                    reachedindex[x-1]=true;\\n                }\\n                if((x+1)<arr.size() && !reachedindex[x+1])\\n                {\\n                    toreach.push(x+1);\\n                    reachedindex[x+1]=true;\\n                }\\n                indexofval[arr[x]].clear();//wihtout this line code gives TLE\\n                /*since we already reached those nodes with a particular value in less steps, then why do we need to check again to reach for those nodes with some steps \\n                more than optimised steps which in worst case we need to check O(N^2) times at test case 26 I suppose....thus we clear the vector so that it never checks again*/\\n            }\\n            steps++;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>&arr) \\n    {\\n        //BFS\\n        vector<bool>reachedindex(arr.size(),false);\\n        unordered_map<int,vector<int>>indexofval;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            indexofval[arr[i]].push_back(i);\\n        }\\n        queue<int>toreach;\\n        toreach.push(0);\\n        reachedindex[0]=true;\\n        int steps=0;\\n        while(!toreach.empty())\\n        {\\n            int n=toreach.size();\\n            while(n--)\\n            {\\n                int x=toreach.front();\\n                if(x==arr.size()-1)\\n                {\\n                    return steps;\\n                }\\n                toreach.pop();\\n                for(auto j:indexofval[arr[x]])\\n                {\\n                    if(!reachedindex[j])\\n                    {\\n                        toreach.push(j);\\n                        reachedindex[j]=true;\\n                    }\\n                }\\n                if((x-1)>0 && !reachedindex[x-1])\\n                {\\n                    toreach.push(x-1);\\n                    reachedindex[x-1]=true;\\n                }\\n                if((x+1)<arr.size() && !reachedindex[x+1])\\n                {\\n                    toreach.push(x+1);\\n                    reachedindex[x+1]=true;\\n                }\\n                indexofval[arr[x]].clear();//wihtout this line code gives TLE\\n                /*since we already reached those nodes with a particular value in less steps, then why do we need to check again to reach for those nodes with some steps \\n                more than optimised steps which in worst case we need to check O(N^2) times at test case 26 I suppose....thus we clear the vector so that it never checks again*/\\n            }\\n            steps++;\\n        }\\n        return arr.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012876,
                "title": "c-image-explanation-easy-to-understand",
                "content": "Let\\'s understand the problem and solve it step by step:\\n\\n```\\nGiven an array of integers arr, you are initially positioned at the first index of the array.\\n\\nIn one step you can jump from index i to index:\\n\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\nReturn the minimum number of steps to reach the last index of the array.\\n```\\n\\nSo from an index you can go to index + 1, index -1, and to the index where the arr[index] is same.\\nConsider each index as a node and take this as finding the shortest distance between source and destination !! \\n![image](https://assets.leetcode.com/users/images/40109ce8-2918-4ccf-a018-3f5d5b9a01f4_1651818625.0956626.jpeg)\\n\\nNow lets understand the code step by step !!\\n\\n **Step 1 :**   Take a map and map the values to the indices its present in the given array\\n **Step 2 :**  Take a visited array and init the 0th index as True and now init a queue ( BFS BABY !! ) \\n and then push the 0th index, cause its the source\\n **Step 3 :**  Usual BFS !! take the front element, pop it and check if its equal to destination index, if yes, return steps\\n **Step 4 :**  Now take a vector and use the & because, you dont want to create copies and run out of memory and then push the index + 1 and index -1 into it\\n **Step 5 :**  Now we have a vector of indices where that current index can jump to, and now check if the index is in bounds, and check if its visited or not !! and if every condtion satisfies, mark that index as visited and push it into the queue\\n **Step 6 :**  ***THE MOST IMP STEP !!*** - You must remove the mapped indices to the curr node as keeping them will give you TLE, imagine a case where every value is 100, 100, 100, . i+1, i-1....it\\'lll loop forever !! \\n **Step 7:** As usual, increment the steps by 1\\n \\n\\n```\\n    int minJumps(vector<int>& arr){\\n        //step 1;\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++){\\n            indicesOfValue[arr[i]].push_back(i);\\n        }\\n        //step 2;\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int step = 0;\\n        //step 3\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1){ // Reached to last index\\n                    return step;\\n                }\\n                // step 4;\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1);\\n                next.push_back(i + 1);\\n                // step 5\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // step 6\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            // step 7\\n            step++;\\n        }\\n        return 0;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nGiven an array of integers arr, you are initially positioned at the first index of the array.\\n\\nIn one step you can jump from index i to index:\\n\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\nReturn the minimum number of steps to reach the last index of the array.\\n```\n```\\n    int minJumps(vector<int>& arr){\\n        //step 1;\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++){\\n            indicesOfValue[arr[i]].push_back(i);\\n        }\\n        //step 2;\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int step = 0;\\n        //step 3\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1){ // Reached to last index\\n                    return step;\\n                }\\n                // step 4;\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1);\\n                next.push_back(i + 1);\\n                // step 5\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // step 6\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            // step 7\\n            step++;\\n        }\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071440,
                "title": "c-bfs-getting-rid-of-adjacent-equivalent-numbers-to-avoid-tle",
                "content": "The trick is that if we have [1 6 6 6 9], then the middle 6 is useless, don\\'t add it to the adjacency list. That\\'s it.\\n\\n```\\nclass Solution {\\n    unordered_map<int, vector<int>> idx_of_num;\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) {\\n            if (i > 0 && i+1 < arr.size() && arr[i] == arr[i+1] && arr[i] == arr[i-1]) {\\n\\t\\t\\t    // don\\'t add the number if its adjacent numbers are all the same.\\n                continue;\\n            }\\n            idx_of_num[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(arr.size());\\n        visited[0] = true;\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            int idx = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            if (idx == arr.size()-1) {\\n                return step;\\n            }\\n            \\n            // prev.\\n            if (idx > 0 && !visited[idx-1]) {\\n                q.push({idx-1, step+1});\\n                visited[idx-1] = true;\\n            }\\n            \\n            // next.\\n            if (idx+1 < arr.size() && !visited[idx+1]) {\\n                q.push({idx+1, step+1});\\n                visited[idx+1] = true;\\n            }\\n            \\n            // same.\\n            for (int next : idx_of_num[arr[idx]]) {\\n                if (!visited[next]) {\\n                    q.push({next, step+1});\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map<int, vector<int>> idx_of_num;\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        for (int i = 0; i < arr.size(); ++i) {\\n            if (i > 0 && i+1 < arr.size() && arr[i] == arr[i+1] && arr[i] == arr[i-1]) {\\n\\t\\t\\t    // don\\'t add the number if its adjacent numbers are all the same.\\n                continue;\\n            }\\n            idx_of_num[arr[i]].push_back(i);\\n        }\\n        \\n        vector<bool> visited(arr.size());\\n        visited[0] = true;\\n        queue<pair<int, int>> q;\\n        q.push({0, 0});\\n        while (!q.empty()) {\\n            int idx = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            if (idx == arr.size()-1) {\\n                return step;\\n            }\\n            \\n            // prev.\\n            if (idx > 0 && !visited[idx-1]) {\\n                q.push({idx-1, step+1});\\n                visited[idx-1] = true;\\n            }\\n            \\n            // next.\\n            if (idx+1 < arr.size() && !visited[idx+1]) {\\n                q.push({idx+1, step+1});\\n                visited[idx+1] = true;\\n            }\\n            \\n            // same.\\n            for (int next : idx_of_num[arr[idx]]) {\\n                if (!visited[next]) {\\n                    q.push({next, step+1});\\n                    visited[next] = true;\\n                }\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997608,
                "title": "why-no-dp-but-bfs-solution-c",
                "content": "**Explain NO DP** - \\nOne of the conditions for Dynamic programming is that the topological ordering must exists which means that there     should not be any cycles. However, in this case, because of the back edges, there is a cycle. Therefore, DP cannot be       used. However , DP can be used but it will not be efficient. \\n**BFS **\\nJust a simple breadth first search, at any index where can you go. \\n    (1). All nodes which have same value as the index you are currently on.\\n    (2). Previous node (index - 1)\\n    (3). Next node (index + 1)\\n**Why should it return minimum jumps?**\\n    In traversal, we put a condition that whenever we reach last node, we return our answer, hence its minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        unordered_map<int,vector<int>> Map;\\n        for(int i=0;i<n;i++){\\n            Map[arr[i]].push_back(i);\\n        }\\n        int jumps = 0;\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            queue<int> q1;\\n            while(!q.empty()){\\n                int i = q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    return jumps;\\n                }\\n                vector<int>& next = Map[arr[i]];\\n                next.push_back(i-1);\\n                next.push_back(i+1);\\n                for(auto j: next){\\n                    if(j>=0 && j<n && !vis[j]){\\n                        q1.push(j);\\n                        vis[j]=true;\\n                    }\\n                }\\n                next.clear();\\n            }\\n            jumps++;\\n            swap(q,q1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        unordered_map<int,vector<int>> Map;\\n        for(int i=0;i<n;i++){\\n            Map[arr[i]].push_back(i);\\n        }\\n        int jumps = 0;\\n        vector<bool> vis(n,false);\\n        queue<int> q;\\n        q.push(0);\\n        vis[0]=true;\\n        while(!q.empty()){\\n            queue<int> q1;\\n            while(!q.empty()){\\n                int i = q.front();\\n                q.pop();\\n                if(i==n-1){\\n                    return jumps;\\n                }\\n                vector<int>& next = Map[arr[i]];\\n                next.push_back(i-1);\\n                next.push_back(i+1);\\n                for(auto j: next){\\n                    if(j>=0 && j<n && !vis[j]){\\n                        q1.push(j);\\n                        vis[j]=true;\\n                    }\\n                }\\n                next.clear();\\n            }\\n            jumps++;\\n            swap(q,q1);\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989433,
                "title": "c-python-bfs-solution-from-easy-to-hard-version",
                "content": "\\'Easy\\' Version: \\nIt is actually not easy, it is a version after so many repeated optmization.  This just to illustrate, in case you saw a beautiful solution, do not worry. Just begin with the straightforward and ugly solution. And you will get there when you get enough training. Let time be our friend.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\n\\n\\'Hard\\' Version: \\nwith comments. This is actually a more natural version at first thought when I encounter this question.\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;\\n        //unordered_map<int, unordered_set<int>> equals; \\n        //for(int i = 0; i < n; i++) equals[arr[i]].insert(i);\\n        //The following 2-line snippet is preferred than above 2-line snippet. Always be stringent on the data structure to control memory\\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                for(int next:{cur+1, cur-1})\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                \\n                \\n                auto& nexts = equals[arr[cur]];\\n                for(int next: nexts)\\n                    if(!visited[next]) q.push(next), visited[next]=1;\\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\n\\nApproach 3: A tiny speed-up\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n\\t\\t//for(int i = 0; i < n; i++) equals[arr[i]].push_back(i); //ok, but redandent on handling i=0\\n        for(int i = 1; i < n; i++) equals[arr[i]].push_back(i);   //{{7,{0,1,2,...,49998},{11,50000}}}             \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                //equals.erase(arr[cur]); // okay, but not efficient enough\\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]; //test case: [7*49999 11], where * means repeating\\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\\nFollow-up:\\nTo further speed-up,\\nBi-directional BFS can be employed.\\n\\nApproach 4: simple python coding\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        q = collections.deque([(0,0)])\\n        visited_index = set([0])\\n        equal_neibors = collections.defaultdict(list)\\n        for i, v in enumerate(arr):equal_neibors[v].append(i)\\n        while q:\\n            step, cur = q.popleft()\\n            if cur == n - 1: return step\\n            for nxt in [cur - 1, cur + 1, *equal_neibors[arr[cur]]]:\\n                if 0 <= nxt < n and nxt not in visited_index:\\n                    q.append((step+1,nxt))\\n                    visited_index.add(nxt)  \\n            del equal_neibors[arr[cur]] # VIP: avoid revisiting  \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;\\n        //unordered_map<int, unordered_set<int>> equals; \\n        //for(int i = 0; i < n; i++) equals[arr[i]].insert(i);\\n        //The following 2-line snippet is preferred than above 2-line snippet. Always be stringent on the data structure to control memory\\n        unordered_map<int, vector<int>> equals;\\n        for(int i = 0; i < n; i++) equals[arr[i]].push_back(i);                \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                for(int next:{cur+1, cur-1})\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                \\n                \\n                auto& nexts = equals[arr[cur]];\\n                for(int next: nexts)\\n                    if(!visited[next]) q.push(next), visited[next]=1;\\n                \\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]                \\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        queue<int> q{{0}};\\n        const int n = arr.size();        \\n        vector<int> visited(n, 0);\\n        visited[0]=1;        \\n        unordered_map<int, vector<int>> equals;\\n\\t\\t//for(int i = 0; i < n; i++) equals[arr[i]].push_back(i); //ok, but redandent on handling i=0\\n        for(int i = 1; i < n; i++) equals[arr[i]].push_back(i);   //{{7,{0,1,2,...,49998},{11,50000}}}             \\n        for(int step = 0;!q.empty(); step++){\\n            for(int i = q.size(); i>0;i--){\\n                auto cur = q.front(); q.pop();\\n                if(cur == n - 1) return step;                \\n                auto& nexts = equals[arr[cur]];nexts.push_back(cur-1); nexts.push_back(cur+1);\\n                for(int next: nexts)\\n                    if(next >=0 && next < n && !visited[next]) q.push(next), visited[next]=1;                     \\n                //equals.erase(arr[cur]); // okay, but not efficient enough\\n                nexts.clear(); // Important. Avoid later lookup equals arr[i]; //test case: [7*49999 11], where * means repeating\\n            }\\n        }\\n        return n - 1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        q = collections.deque([(0,0)])\\n        visited_index = set([0])\\n        equal_neibors = collections.defaultdict(list)\\n        for i, v in enumerate(arr):equal_neibors[v].append(i)\\n        while q:\\n            step, cur = q.popleft()\\n            if cur == n - 1: return step\\n            for nxt in [cur - 1, cur + 1, *equal_neibors[arr[cur]]]:\\n                if 0 <= nxt < n and nxt not in visited_index:\\n                    q.append((step+1,nxt))\\n                    visited_index.add(nxt)  \\n            del equal_neibors[arr[cur]] # VIP: avoid revisiting  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 829482,
                "title": "javascript-97",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let valuePositionsMap = getValuePositionsMap(arr);\\n    let mySet = new Set();\\n    mySet.add(0);\\n    let aoArray = [0];\\n    let counter = 0;\\n    while(!mySet.has(arr.length-1)){\\n        counter++;\\n        let newArray = [];\\n        for(let currP of aoArray){\\n            for(let item of findAllOptions(arr, currP, mySet, valuePositionsMap)){\\n                newArray.push(item);\\n                mySet.add(item);\\n                if(item == arr.length-1){\\n                    break;\\n                }\\n            }\\n            if(mySet.has(arr.length-1)){\\n                break;\\n            }\\n        }\\n        aoArray = newArray;\\n    }\\n    return counter;\\n};\\n\\nfunction getValuePositionsMap(arr){\\n    let result = new Map();\\n    for(let i=arr.length-1;i>=0;i--){\\n        if(!result.has(arr[i])){\\n            result.set(arr[i], []); \\n        }\\n        result.get(arr[i]).push(i);\\n    }\\n    return result;\\n}\\n\\nfunction findAllOptions(arr, currP, mySet, valuePositionsMap){\\n    let result = [];\\n    if(currP > 0 && arr[currP-1] != arr[currP] && !mySet.has(currP-1)){\\n        result.push(currP-1);\\n    }\\n    if(currP < arr.length-1 && arr[currP+1] != arr[currP] && !mySet.has(currP+1)){\\n        result.push(currP+1);\\n    }\\n    if(valuePositionsMap.has(arr[currP])){\\n        for(let i of valuePositionsMap.get(arr[currP])){\\n            if(i != currP && !mySet.has(i)){\\n                result.push(i);\\n            }\\n        }\\n        valuePositionsMap.delete(arr[currP]);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let valuePositionsMap = getValuePositionsMap(arr);\\n    let mySet = new Set();\\n    mySet.add(0);\\n    let aoArray = [0];\\n    let counter = 0;\\n    while(!mySet.has(arr.length-1)){\\n        counter++;\\n        let newArray = [];\\n        for(let currP of aoArray){\\n            for(let item of findAllOptions(arr, currP, mySet, valuePositionsMap)){\\n                newArray.push(item);\\n                mySet.add(item);\\n                if(item == arr.length-1){\\n                    break;\\n                }\\n            }\\n            if(mySet.has(arr.length-1)){\\n                break;\\n            }\\n        }\\n        aoArray = newArray;\\n    }\\n    return counter;\\n};\\n\\nfunction getValuePositionsMap(arr){\\n    let result = new Map();\\n    for(let i=arr.length-1;i>=0;i--){\\n        if(!result.has(arr[i])){\\n            result.set(arr[i], []); \\n        }\\n        result.get(arr[i]).push(i);\\n    }\\n    return result;\\n}\\n\\nfunction findAllOptions(arr, currP, mySet, valuePositionsMap){\\n    let result = [];\\n    if(currP > 0 && arr[currP-1] != arr[currP] && !mySet.has(currP-1)){\\n        result.push(currP-1);\\n    }\\n    if(currP < arr.length-1 && arr[currP+1] != arr[currP] && !mySet.has(currP+1)){\\n        result.push(currP+1);\\n    }\\n    if(valuePositionsMap.has(arr[currP])){\\n        for(let i of valuePositionsMap.get(arr[currP])){\\n            if(i != currP && !mySet.has(i)){\\n                result.push(i);\\n            }\\n        }\\n        valuePositionsMap.delete(arr[currP]);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 502786,
                "title": "dp-21-26-passed-dynamic-programming-wa-help",
                "content": "I tried solving using dynamic programming but my code **passes only 21/26 cases**.Can someone *please help me figure out what am I missing in my logic/code*.\\nPlease comment ...thanks\\n\\n```\\npublic int minJumps(int[] arr) {\\n\\n\\n\\t\\tint n=arr.length;\\n\\t\\tif(n==1 || n==0) return 0;\\n\\t\\tif( arr[0]==arr[n-1]) return 1;\\n\\n\\t\\tint [] dp=new int[n];\\n\\t\\tArrays.fill(dp,100000002);          \\n\\t\\tdp[0]=0;\\n\\n\\t\\tfor( int i=1;i<n;i++){\\n\\n\\t\\t\\tfor(int j=0;j<i;j++){\\n\\n\\t\\t\\t\\tif(arr[i]==arr[j]){\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+1);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[i]!=arr[j]) {\\n\\t\\t\\t\\t\\tif(j!=0 && arr[i]==arr[j-1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j!=i-1 && arr[i]==arr[j+1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}  \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i]=Math.min(dp[i],dp[i-1]+1);\\n\\t\\t\\tif(i!=n-1) dp[i]=Math.min(dp[i],dp[i+1]+1);\\n\\t\\t}\\n\\t\\treturn dp[n-1];\\n\\n\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int minJumps(int[] arr) {\\n\\n\\n\\t\\tint n=arr.length;\\n\\t\\tif(n==1 || n==0) return 0;\\n\\t\\tif( arr[0]==arr[n-1]) return 1;\\n\\n\\t\\tint [] dp=new int[n];\\n\\t\\tArrays.fill(dp,100000002);          \\n\\t\\tdp[0]=0;\\n\\n\\t\\tfor( int i=1;i<n;i++){\\n\\n\\t\\t\\tfor(int j=0;j<i;j++){\\n\\n\\t\\t\\t\\tif(arr[i]==arr[j]){\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+1);\\n\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[i]!=arr[j]) {\\n\\t\\t\\t\\t\\tif(j!=0 && arr[i]==arr[j-1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(j!=i-1 && arr[i]==arr[j+1]) {\\n\\n\\t\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[j]+2);\\n\\t\\t\\t\\t\\t}  \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tdp[i]=Math.min(dp[i],dp[i-1]+1);\\n\\t\\t\\tif(i!=n-1) dp[i]=Math.min(dp[i],dp[i+1]+1);\\n\\t\\t}\\n\\t\\treturn dp[n-1];\\n\\n\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 502775,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList());\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<int[]> q = new LinkedList<>();\\n        q.add(new int[]{0, 0});\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        while(q.size() > 0) {\\n            int[] pair = q.remove();\\n            if(pair[0] == n - 1) return pair[1];\\n            if(pair[0] + 1 < n && !visited[pair[0] + 1]) {\\n                if(pair[0] + 1 == n - 1) return pair[1] + 1;\\n                q.add(new int[]{pair[0] + 1, pair[1] + 1});\\n                visited[pair[0] + 1] = true;\\n            }\\n            if(pair[0] - 1 >= 0 && !visited[pair[0] - 1]) {\\n                if(pair[0] - 1 == n - 1) return pair[1] + 1;\\n                q.add(new int[]{pair[0] - 1, pair[1] + 1});\\n                visited[pair[0] - 1] = true;\\n            }\\n            List<Integer> possible = map.get(arr[pair[0]]);\\n            for(int i = possible.size() - 1; i >= 0; i--) {\\n                if(possible.get(i) == n - 1) return pair[1] + 1;\\n                if(!visited[possible.get(i)]) {\\n                    q.add(new int[]{possible.get(i), pair[1] + 1});\\n                    visited[possible.get(i)] = true;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(!map.containsKey(arr[i])) map.put(arr[i], new ArrayList());\\n            map.get(arr[i]).add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3621067,
                "title": "only-bfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        if(arr.size()==1)return 0;\\n        queue<int> q;\\n        q.push(0);\\n        unordered_map<int,vector<int>> mp;\\n        int n=arr.size(),i,x,y;\\n        for(i = 0; i < n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        i = 0;\\n        x = -1;\\n        \\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        while(!q.empty()){\\n            y = q.size();\\n            x++;\\n            while(y--){\\n                i = q.front();\\n                q.pop();\\n                if(i==n-1)return x;\\n                if(i-1>=0&&!vis[i-1]){q.push(i-1);vis[i-1] = true;}\\n                if(i+1<n&&!vis[i+1]){q.push(i+1);vis[i+1]=true;}\\n                for(auto &j: mp[arr[i]]){\\n                    if(!vis[j]){\\n                        vis[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                mp.erase(arr[i]);\\n            }\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        if(arr.size()==1)return 0;\\n        queue<int> q;\\n        q.push(0);\\n        unordered_map<int,vector<int>> mp;\\n        int n=arr.size(),i,x,y;\\n        for(i = 0; i < n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        i = 0;\\n        x = -1;\\n        \\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        while(!q.empty()){\\n            y = q.size();\\n            x++;\\n            while(y--){\\n                i = q.front();\\n                q.pop();\\n                if(i==n-1)return x;\\n                if(i-1>=0&&!vis[i-1]){q.push(i-1);vis[i-1] = true;}\\n                if(i+1<n&&!vis[i+1]){q.push(i+1);vis[i+1]=true;}\\n                for(auto &j: mp[arr[i]]){\\n                    if(!vis[j]){\\n                        vis[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                mp.erase(arr[i]);\\n            }\\n        }\\n        return arr.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260574,
                "title": "simple-java-using-set-map-queue-linkedlist",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n\\n        int n=arr.length;\\n        Map<Integer,List<Integer>> valIndex=new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n            valIndex.computeIfAbsent(arr[i],l->new ArrayList<>()).add(i);\\n\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n\\n        Set<Integer> visited=new HashSet<>();\\n        visited.add(0);\\n\\n        int step=0;\\n\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int i=q.poll();\\n\\n\\n                if(i==n-1)\\n                    return step;\\n\\n                List<Integer> adjList=valIndex.get(arr[i]);\\n\\n                adjList.add(i-1);\\n                adjList.add(i+1);\\n\\n                for(int j:adjList)\\n                {\\n                    if(j>=0&& j<n && !visited.contains(j))\\n                        {\\n                            q.add(j);\\n                            visited.add(j);\\n                        }\\n                }\\n                adjList.clear();   \\n            }\\n\\n\\n\\n            step++;\\n        }\\n\\n\\n\\n      return -1;  \\n    }\\n}\\n```\\n\\n![7abc56.jpg](https://assets.leetcode.com/users/images/d0a632d5-0e09-41aa-b3ac-84abc4071673_1678026786.5923662.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n\\n        int n=arr.length;\\n        Map<Integer,List<Integer>> valIndex=new HashMap<>();\\n\\n        for(int i=0;i<n;i++)\\n            valIndex.computeIfAbsent(arr[i],l->new ArrayList<>()).add(i);\\n\\n        Queue<Integer> q=new LinkedList<>();\\n        q.add(0);\\n\\n        Set<Integer> visited=new HashSet<>();\\n        visited.add(0);\\n\\n        int step=0;\\n\\n\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                int i=q.poll();\\n\\n\\n                if(i==n-1)\\n                    return step;\\n\\n                List<Integer> adjList=valIndex.get(arr[i]);\\n\\n                adjList.add(i-1);\\n                adjList.add(i+1);\\n\\n                for(int j:adjList)\\n                {\\n                    if(j>=0&& j<n && !visited.contains(j))\\n                        {\\n                            q.add(j);\\n                            visited.add(j);\\n                        }\\n                }\\n                adjList.clear();   \\n            }\\n\\n\\n\\n            step++;\\n        }\\n\\n\\n\\n      return -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259615,
                "title": "jump-game-iv-c-easy-approach-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n\\t    int n = arr.size(), ans = 0;\\n\\t    map<int, vector<int>> m;\\n\\t    vector<bool> vis(n, 0);\\n\\t    for (auto i = 0; i < n; i++) {\\n\\t    \\tm[arr[i]].push_back(i);\\n\\t    }\\n\\t    queue<int> q;\\n\\t    q.push(0);\\n\\t    vis[0] = true;\\n\\t    while (!q.empty()) {\\n\\t    \\tint sz = q.size();\\n\\t    \\twhile (sz--) {\\n\\t    \\t\\tint curr = q.front();\\n\\t    \\t\\tq.pop();\\n\\t    \\t\\tif (curr == n - 1) return ans;\\n\\t    \\t\\tif (curr > 0) {\\n\\t    \\t\\t\\tif (!vis[curr - 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr - 1);\\n\\t    \\t\\t\\t\\tvis[curr - 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif (curr < n - 1) {\\n\\t    \\t\\t\\tif (!vis[curr + 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr + 1);\\n\\t    \\t\\t\\t\\tvis[curr + 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif(m[arr[curr]][0] == -1) continue;\\n\\t    \\t\\tfor (auto i : m[arr[curr]]) {\\n\\t    \\t\\t\\tif (!vis[i]) {\\n\\t    \\t\\t\\t\\tq.push(i);\\n\\t    \\t\\t\\t\\tvis[i] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tm[arr[curr]] = {-1};\\n\\t    \\t}\\n\\t    \\tans++;\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n\\t    int n = arr.size(), ans = 0;\\n\\t    map<int, vector<int>> m;\\n\\t    vector<bool> vis(n, 0);\\n\\t    for (auto i = 0; i < n; i++) {\\n\\t    \\tm[arr[i]].push_back(i);\\n\\t    }\\n\\t    queue<int> q;\\n\\t    q.push(0);\\n\\t    vis[0] = true;\\n\\t    while (!q.empty()) {\\n\\t    \\tint sz = q.size();\\n\\t    \\twhile (sz--) {\\n\\t    \\t\\tint curr = q.front();\\n\\t    \\t\\tq.pop();\\n\\t    \\t\\tif (curr == n - 1) return ans;\\n\\t    \\t\\tif (curr > 0) {\\n\\t    \\t\\t\\tif (!vis[curr - 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr - 1);\\n\\t    \\t\\t\\t\\tvis[curr - 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif (curr < n - 1) {\\n\\t    \\t\\t\\tif (!vis[curr + 1]) {\\n\\t    \\t\\t\\t\\tq.push(curr + 1);\\n\\t    \\t\\t\\t\\tvis[curr + 1] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tif(m[arr[curr]][0] == -1) continue;\\n\\t    \\t\\tfor (auto i : m[arr[curr]]) {\\n\\t    \\t\\t\\tif (!vis[i]) {\\n\\t    \\t\\t\\t\\tq.push(i);\\n\\t    \\t\\t\\t\\tvis[i] = true;\\n\\t    \\t\\t\\t}\\n\\t    \\t\\t}\\n\\t    \\t\\tm[arr[curr]] = {-1};\\n\\t    \\t}\\n\\t    \\tans++;\\n\\t    }\\n\\t    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258987,
                "title": "java-easy-understanding-hash-table-bfs-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer,ArrayList<Integer>>hm=new HashMap<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hm.containsKey(arr[i])){\\n                ArrayList<Integer>al=hm.get(arr[i]);\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n            else{\\n                ArrayList<Integer>al=new ArrayList<>();\\n                al.add(i);\\n                hm.put(arr[i],al);\\n            }\\n        }\\n        boolean vis[]=new boolean[arr.length];\\n        Queue<Integer>q=new LinkedList<>();\\n        q.add(0);\\n        int cnt=0;\\n        while(!q.isEmpty()){\\n            for(int k=q.size();k>0;k--){\\n                int n=q.remove();\\n                vis[n]=true;\\n                if(n==arr.length-1) return cnt;\\n                ArrayList<Integer>al=hm.get(arr[n]);\\n                al.add(n-1);\\n                al.add(n+1);\\n                for(int i:al){\\n                    if(i>=0&&i<arr.length&&!vis[i]){\\n                        q.add(i);\\n                    }\\n                }\\n                al.clear();\\n            }\\n            cnt++;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258986,
                "title": "bfs-or-dfs-detailed-explanation-containing-hints-efficient-solution",
                "content": "# Intuition\\nI assume you have some idea of [Jump Game](https://leetcode.com/problems/jump-game/), [Jump Game II](https://leetcode.com/problems/jump-game-ii/) and [Jump Game III](https://leetcode.com/problems/jump-game-iii/) by now. This problem contains similar approach but we need some additional understanding.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe question says that at any index i:\\n- we can jump to index $$i-1$$.\\n- we can jump to index $$i+1$$.\\n- or we can jump to those indices that have the same jump value as current index. \\nSuppose given $$jumps = [1, 1, 2, 1, 1]$$. We are in index $$i = 0$$ currently. We can go to $$i-1$$ or, $$i+1$$. \\n  -  So, $$i-1 = 0-1 = -1$$. It is out of bound. So, we cannot take it.\\n  - $$i+1 = 0 + 1 = 1$$. We can go to that index.\\n  - You can see from the examples that index $$i = 0$$ has $$jump = 1$$. You can see that indices 1, 3 and 4 also have same value. According to the specification we should also consider those indices.\\n  - So, we can also go to $$i = 3$$ and $$i = 4$$.\\n\\n# Hints:\\nSo, first thing is you have to keep the indices with same jump value.\\nYou probably thinking of a map of list values. The key will be jump length and the values will be indices.\\n\\nWe start from index $$0$$ and we need to keep the **stepsTaken** in a variable. We want the minimum steps. Can we do a **dfs** search in this case? No, **dfs** will go deep into the tree. But for minimum finding case, we should probably use **bfs**. Because **bfs** traverses all the nodes in level order. Gradually from up to bottom. So, we will be good to use **bfs** in this case.\\n\\nWe can see the same indices can come more than once. For this case, we need to keep an array of **boolean** to keep the indices that were visited.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUsing **BFS** would take time complexity of $$O(n+k)$$. Here, $$n$$ is the number of elements and the $$k$$ is the maximum edge connecting an element. In worst case, all the elements can be same. But as we are not calculating repeating elements, it is good to go. The time complexity will stay around $$O(n)$$.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we are keeping a queue and also Clearing it out. There won\\'t be all the $$n$$ elements at one time in the queue. But we have also used an array of **boolean[] visited** which is of size $$n$$. So, the space complexity would be $$O(n)$$.\\n\\n# Code \\n``` java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        // storing indices having same jump length..\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                // we reached the end\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                // get all the indices with same jump length\\n                List<Integer> next = map.get(arr[idx]);\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(idx-1>=0){\\n                    next.add(idx-1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(idx+1<len){\\n                    next.add(idx+1);\\n                }\\n                // iterate for all indices\\n                for(int i : next){\\n                    // we don\\'t want to check the already visited indices again!\\n                    if(!visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> sameValueIndicesMap;\\n        for (int i = 0; i < n; i++)\\n            sameValueIndicesMap[arr[i]].push_back(i);\\n        vector<bool> visited(n); \\n        queue<int> q; \\n        q.push(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            stepsTaken++;\\n            while (size-->0) {\\n                int i = q.front(); \\n                q.pop();\\n                // Reached to last index\\n                if (i == n - 1) {\\n                    return stepsTaken;\\n                }\\n                // get all the indices with same jump length\\n                vector<int>& next = sameValueIndicesMap[arr[i]];\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(i-1 >=0){\\n                    next.push_back(i - 1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(i+1 < n){\\n                    next.push_back(i + 1);\\n                }\\n                // iterate for all indices\\n                for (int j : next) {\\n                    // we don\\'t want to check the already visited indices again!\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                next.clear();\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/58ea33a3-d47b-44a1-9a1e-7af583173d20_1670178091.0691743.png)\\n![image](https://assets.leetcode.com/users/images/0ad03c10-9b0d-4d2c-8451-bb5a171c70ff_1670178117.9879165.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        // storing indices having same jump length..\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                // we reached the end\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                // get all the indices with same jump length\\n                List<Integer> next = map.get(arr[idx]);\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(idx-1>=0){\\n                    next.add(idx-1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(idx+1<len){\\n                    next.add(idx+1);\\n                }\\n                // iterate for all indices\\n                for(int i : next){\\n                    // we don\\'t want to check the already visited indices again!\\n                    if(!visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> sameValueIndicesMap;\\n        for (int i = 0; i < n; i++)\\n            sameValueIndicesMap[arr[i]].push_back(i);\\n        vector<bool> visited(n); \\n        queue<int> q; \\n        q.push(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            stepsTaken++;\\n            while (size-->0) {\\n                int i = q.front(); \\n                q.pop();\\n                // Reached to last index\\n                if (i == n - 1) {\\n                    return stepsTaken;\\n                }\\n                // get all the indices with same jump length\\n                vector<int>& next = sameValueIndicesMap[arr[i]];\\n                // we can jump to i-1 or i+1\\n                // we don\\'t want to go out of bound...\\n                if(i-1 >=0){\\n                    next.push_back(i - 1);\\n                }\\n                // we don\\'t want to go out of bound...\\n                if(i+1 < n){\\n                    next.push_back(i + 1);\\n                }\\n                // iterate for all indices\\n                for (int j : next) {\\n                    // we don\\'t want to check the already visited indices again!\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                // avoid later lookup sameValueIndicesMap arr[i]\\n                next.clear();\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658643,
                "title": "python3-solution-faster-than-56-bfs-bahut-tez",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        h={}\\n        for i,e in enumerate(arr):\\n            if e not in h:\\n                h[e] = []\\n            h[e].append(i)\\n        q = [(0,0)]\\n        while q:\\n            n,d = q.pop(0)\\n            if n == len(arr)-1:\\n                return d\\n            if n+1 == len(arr)-1:\\n                return d+1\\n            if n+1 < len(arr) and h.get(arr[n+1]):\\n                q.append((n+1,d+1))\\n            if n-1 >= 0 and h.get(arr[n-1]):\\n                q.append((n-1,d+1))\\n            for i in h[arr[n]]:\\n                if i != n:\\n                    q.append((i,d+1))\\n                if i == len(arr)-1:\\n                    return d+1\\n            h[arr[n]] = []",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        h={}",
                "codeTag": "Java"
            },
            {
                "id": 1224573,
                "title": "c-dfs-tle-bfs-accepted-easy-comments-why-dfs-memo-won-t-work",
                "content": "DFS -> TLE\\n\\n    DFS+Memoization does not work, when all of the following 3 dependency exists: \\n      - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n      - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n      - jump dependency, i.e., mem[start] depends on mem[x];\\n    You mark an index visited and return the value of that index if it was visited in past\\n    but, that value may not be optimal (shotest) in DFS because DFS traverses nodes in random    \\n    order, and we only cache the first result it finds.\\n\\n    Why BFS ?\\n    With BFS you can stop as soon as you reach the goal. With DFS you might reach the goal (or memoize any result) via a sub-optimal path.\\n    To be sure you get the optimal solution with DFS, you can\\'t use memoization because you might still find a shorter path at any point in the future.\\n\\n```\\n//Approach-1 (DFS - TLE)\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    vector<int> t;\\n    unordered_map<int, vector<int>> mp;\\n    int solve_DFS(vector<int>& arr, int idx) {\\n        //reached destination\\n        if(idx == arr.size()-1)\\n            return 0;\\n        \\n\\t\\t//No memoization check because it won\\'t give optimal result always\\n\\t\\t\\n        int min_step = INT_MAX;\\n        // jump to idx + 1\\n        if (idx + 1 < arr.size() && !visited[idx+1]) {\\n            visited[idx+1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx+1) + 1);\\n            visited[idx+1] = false; //you need to do this for trying (idx-1) and same number indices\\n        }\\n        // jump to idx - 1\\n        if (idx - 1 >= 0 && !visited[idx-1]) {\\n            visited[idx-1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx-1) + 1);\\n            visited[idx-1] = false;\\n        }\\n        // jump to same number with different idx\\n        for (int next_idx : mp[arr[idx]]) {\\n            if (next_idx == idx) {continue;}\\n            if (!visited[next_idx]) {\\n                visited[next_idx] = true;\\n                min_step = min(min_step, solve_DFS(arr, next_idx) + 1);\\n                visited[next_idx] = false;\\n            }\\n        }\\n        \\n        t[idx] = min(t[idx], min_step);\\n        return t[idx];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        visited.resize(n);\\n        t.resize(n, INT_MAX);\\n        mp.clear();\\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        visited[0] = true;\\n        return solve_DFS(arr, 0);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (BFS : Accepted)\\nclass Solution {\\npublic:\\n    int solve_BFS(vector<int>& arr, int& n) {\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> mp; //why ?  Because, we need to access those indices where arr[i] == arr[j]\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        queue<int> que;\\n        que.push(0);\\n        visited[0] = true;\\n        int steps = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size();\\n            \\n            //check this level\\n            while(size--) {\\n                int curr = que.front();\\n                que.pop();\\n                \\n                if(curr == n-1) {\\n                    //BFS ensures minimum steps\\n                    //We are moving level by level\\n                    return steps;\\n                }\\n                \\n                int left  = curr-1;\\n                int right = curr+1;\\n                \\n                if(left >= 0 && !visited[left]) {\\n                    que.push(left);\\n                    visited[left] = true;\\n                }\\n                \\n                if(right < n && !visited[right]) {\\n                    que.push(right);\\n                    visited[right] = true;\\n                }\\n                \\n                for(const int &idx : mp[arr[curr]]) {\\n                    if(!visited[idx]) {\\n                        que.push(idx);\\n                        visited[idx] = true;\\n                    }\\n                }\\n                //If you don\\'t erase it, you may be again checking for it\\n                //in future. It will cause TLE\\n                mp.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n            return 0;\\n        return solve_BFS(arr, n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (DFS - TLE)\\nclass Solution {\\npublic:\\n    vector<bool> visited;\\n    vector<int> t;\\n    unordered_map<int, vector<int>> mp;\\n    int solve_DFS(vector<int>& arr, int idx) {\\n        //reached destination\\n        if(idx == arr.size()-1)\\n            return 0;\\n        \\n\\t\\t//No memoization check because it won\\'t give optimal result always\\n\\t\\t\\n        int min_step = INT_MAX;\\n        // jump to idx + 1\\n        if (idx + 1 < arr.size() && !visited[idx+1]) {\\n            visited[idx+1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx+1) + 1);\\n            visited[idx+1] = false; //you need to do this for trying (idx-1) and same number indices\\n        }\\n        // jump to idx - 1\\n        if (idx - 1 >= 0 && !visited[idx-1]) {\\n            visited[idx-1] = true;\\n            min_step = min(min_step, solve_DFS(arr, idx-1) + 1);\\n            visited[idx-1] = false;\\n        }\\n        // jump to same number with different idx\\n        for (int next_idx : mp[arr[idx]]) {\\n            if (next_idx == idx) {continue;}\\n            if (!visited[next_idx]) {\\n                visited[next_idx] = true;\\n                min_step = min(min_step, solve_DFS(arr, next_idx) + 1);\\n                visited[next_idx] = false;\\n            }\\n        }\\n        \\n        t[idx] = min(t[idx], min_step);\\n        return t[idx];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        visited.resize(n);\\n        t.resize(n, INT_MAX);\\n        mp.clear();\\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        visited[0] = true;\\n        return solve_DFS(arr, 0);\\n    }\\n};\\n```\n```\\n//Approach-2 (BFS : Accepted)\\nclass Solution {\\npublic:\\n    int solve_BFS(vector<int>& arr, int& n) {\\n        vector<bool> visited(n, false);\\n        unordered_map<int, vector<int>> mp; //why ?  Because, we need to access those indices where arr[i] == arr[j]\\n        \\n        for(int i = 0; i<n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        queue<int> que;\\n        que.push(0);\\n        visited[0] = true;\\n        int steps = 0;\\n        \\n        while(!que.empty()) {\\n            int size = que.size();\\n            \\n            //check this level\\n            while(size--) {\\n                int curr = que.front();\\n                que.pop();\\n                \\n                if(curr == n-1) {\\n                    //BFS ensures minimum steps\\n                    //We are moving level by level\\n                    return steps;\\n                }\\n                \\n                int left  = curr-1;\\n                int right = curr+1;\\n                \\n                if(left >= 0 && !visited[left]) {\\n                    que.push(left);\\n                    visited[left] = true;\\n                }\\n                \\n                if(right < n && !visited[right]) {\\n                    que.push(right);\\n                    visited[right] = true;\\n                }\\n                \\n                for(const int &idx : mp[arr[curr]]) {\\n                    if(!visited[idx]) {\\n                        que.push(idx);\\n                        visited[idx] = true;\\n                    }\\n                }\\n                //If you don\\'t erase it, you may be again checking for it\\n                //in future. It will cause TLE\\n                mp.erase(arr[curr]);\\n            }\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n            return 0;\\n        return solve_BFS(arr, n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988895,
                "title": "jump-game-iv-python-bfs-with-explanation",
                "content": "Breadth first search (BFS) for the single-source shortest distance in an one-dimensional space. \\n\\nThe twist here is the \"jump\" operation. To support jump, maintain a dict (`val2id`) that collects all the positions that hold the same value. At each point during the BFS, besides expand to the direct left and right, also expand to the locations where the value is the same (`val2id[a[i]]`). \\n\\nOnce you expanded for a certain value, you can delete that entry from `val2id` because even if you reach the same value later, it won\\'t give you a shorter distance. This will also ensure that you only visit the value of each location at most once, and thus bounds the time complexity  by O(n), where n being the array length.\\n\\n```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```\\n\\n---\\nIf you find this helpful, please consider **upvote**. It will encourage me to write more explanations like this. Thank you! :-)",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, a: List[int]) -> int:\\n        n = len(a)\\n        val2id = {}\\n        for i, x in enumerate(a):\\n            val2id.setdefault(x, []).append(i)\\n        d = [inf] * n\\n        d[0] = 0\\n        q = [0]\\n        while len(q) and q[0] != n - 1:\\n            i = q.pop(0)\\n            ii = i - 1\\n            if 0 <= ii and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            ii = i + 1\\n            if ii < n and d[ii] is inf:\\n                d[ii] = d[i] + 1\\n                q.append(ii)\\n            if a[i] in val2id:\\n                for ii in val2id[a[i]]:\\n                    if d[ii] is inf:\\n                        d[ii] = d[i] + 1\\n                        q.append(ii)\\n                del val2id[a[i]]\\n        return d[n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504143,
                "title": "c-solution-with-comments-and-explanation",
                "content": "As most people have already pointed out, this problem can be reduced to a basic shortest path problem, where edges have uniform weight of 1. This means we can use a BFS to get the answer quite easily. There are a few things to realize here though.\\n1. The indices of the argument array can be thought of as the vertices in a graph.\\n2. You use the \"rules\" of the game to determine the structure of the graph, as in, how the vertices are connected.\\n3. If there are multiple values in the argument array in a row which are the same (i.e. if arr was {1, 2, 2, 2, 2, 7}), you technically only need to consider the end-points of this sub-array. That is, you could treat the array as if it was {1, 2, 2, 7} and end up with the same result. Doing this will increase the efficiency of the algorithm in some cases and one of these cases was specifically tested for (final test case).\\n```java\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        if (arr.Length == 1) return 0;        \\n        \\n        // Basic shortest path setup:\\n        int[] d = new int[arr.Length];                                      // Tracks # of jumps from index 0\\n        Dictionary<int, List<int>> vd = new Dictionary<int, List<int>>();   // Maps values to indices\\n        bool[] seen = new bool[arr.Length];                                 // Tracks which indices have been seen\\n        Queue<int> q = new Queue<int>();                                    // BFS queue\\n        \\n        // Initializing \"vd\"\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (!vd.ContainsKey(arr[i])) vd[arr[i]] = new List<int>() { i };\\n            else {\\n                vd[arr[i]].Add(i);\\n                // If there are multiple values that are equal in a row, we only want the endpoints for extra efficiency.\\n                // This is needed to pass the final test case.\\n                while (i < arr.Length - 1 && arr[i] == arr[i + 1]) i++;\\n                if (vd[arr[i]][vd[arr[i]].Count - 1] != i) vd[arr[i]].Add(i);\\n            }\\n        }\\n        \\n        // Setting known values\\n        d[0] = 0;               // # of jumps to index 0 from index 0 is obviously 0\\n        seen[0] = true;         // We\\'ve seen index 0\\n        q.Enqueue(0);           // Queue index 0\\n\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();                                // Dequeue (standard BFS)\\n            foreach (int v in Adj(arr, u, vd))                  // Iterate over \"adjacent vertices\" (indices we can jump to)\\n                if (!seen[v]) {                                 // We only need to consider \"unseen\" vertices\\n                    seen[v] = true;                             // Mark \"vertex\" (index) as seen\\n                    d[v] = 1 + d[u];                            // Record # of jumps from \"source vertex\" (index 0)\\n                    if (v == arr.Length - 1) return d[v];       // As soon as we reach the last index, we are done.\\n                    q.Enqueue(v);                               // Queue up the unseen adjacent \"vertex\" (standard BFS)\\n                }\\n        }\\n        return -1;      // Shouldn\\'t ever return this, since there is always a \"path\" from index 0 to the last index.\\n    }\\n    \\n    // Returns a list of \"adjacent\" vertices, using the rules of the game.\\n    public static List<int> Adj(int[] arr, int i, Dictionary<int, List<int>> valueDict) {\\n        List<int> res = new List<int>();\\n        if (i > 0)res.Add(i - 1);                   // If i > 0, we can jump to the previous index\\n        if (i < arr.Length - 1)res.Add(i + 1);      // If i < arr.Length, we can jump to the next index\\n        \\n        // We can also jump to any index where the values are equal.\\n        valueDict[arr[i]].ForEach(index => { if (index != i) res.Add(index); });\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        if (arr.Length == 1) return 0;        \\n        \\n        // Basic shortest path setup:\\n        int[] d = new int[arr.Length];                                      // Tracks # of jumps from index 0\\n        Dictionary<int, List<int>> vd = new Dictionary<int, List<int>>();   // Maps values to indices\\n        bool[] seen = new bool[arr.Length];                                 // Tracks which indices have been seen\\n        Queue<int> q = new Queue<int>();                                    // BFS queue\\n        \\n        // Initializing \"vd\"\\n        for (int i = 0; i < arr.Length; i++) {\\n            if (!vd.ContainsKey(arr[i])) vd[arr[i]] = new List<int>() { i };\\n            else {\\n                vd[arr[i]].Add(i);\\n                // If there are multiple values that are equal in a row, we only want the endpoints for extra efficiency.\\n                // This is needed to pass the final test case.\\n                while (i < arr.Length - 1 && arr[i] == arr[i + 1]) i++;\\n                if (vd[arr[i]][vd[arr[i]].Count - 1] != i) vd[arr[i]].Add(i);\\n            }\\n        }\\n        \\n        // Setting known values\\n        d[0] = 0;               // # of jumps to index 0 from index 0 is obviously 0\\n        seen[0] = true;         // We\\'ve seen index 0\\n        q.Enqueue(0);           // Queue index 0\\n\\n        while (q.Count > 0) {\\n            int u = q.Dequeue();                                // Dequeue (standard BFS)\\n            foreach (int v in Adj(arr, u, vd))                  // Iterate over \"adjacent vertices\" (indices we can jump to)\\n                if (!seen[v]) {                                 // We only need to consider \"unseen\" vertices\\n                    seen[v] = true;                             // Mark \"vertex\" (index) as seen\\n                    d[v] = 1 + d[u];                            // Record # of jumps from \"source vertex\" (index 0)\\n                    if (v == arr.Length - 1) return d[v];       // As soon as we reach the last index, we are done.\\n                    q.Enqueue(v);                               // Queue up the unseen adjacent \"vertex\" (standard BFS)\\n                }\\n        }\\n        return -1;      // Shouldn\\'t ever return this, since there is always a \"path\" from index 0 to the last index.\\n    }\\n    \\n    // Returns a list of \"adjacent\" vertices, using the rules of the game.\\n    public static List<int> Adj(int[] arr, int i, Dictionary<int, List<int>> valueDict) {\\n        List<int> res = new List<int>();\\n        if (i > 0)res.Add(i - 1);                   // If i > 0, we can jump to the previous index\\n        if (i < arr.Length - 1)res.Add(i + 1);      // If i < arr.Length, we can jump to the next index\\n        \\n        // We can also jump to any index where the values are equal.\\n        valueDict[arr[i]].ForEach(index => { if (index != i) res.Add(index); });\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260687,
                "title": "java-extra-trick-with-bfs-to-make-it-o-n",
                "content": "BFS solution is straigh forward.\\n\\n1. Make a hashmap from number to list indices which will store a number mapped to list of indices where it is seen.\\n2. Do a BFS with visited array and every index we will do four case.\\n\\t1.  if currently polled index from queue is n-1 then we found answer.\\n\\t2.  add index+1 to bfs queue if its not visited.\\n\\t3. add index-1 to bfs queue if not visited.\\n\\t4. Iterate through the list which contains same number as arr[index] and add indices which are not visited.\\nwith this we will get solution.\\n\\n**NOTE:**\\nMain trick here is that as soon we iterate through the list of matches arr[index], I am clearing the list, because if indices in a list are already added once, we don\\'t need to iterate through list because next time iterating through same list only results in not adding them to queue as they will already be visited. Since we are doing clear part inside for loop we don\\'t need to use visited array we can just use (pos != index) if condition.\\n\\n\\nTime: O(N)\\nSpace: O(N)\\n\\n\\n\\n\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        Map<Integer, List<Integer>> finder = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            finder.computeIfAbsent(arr[i], v -> new ArrayList<Integer>());\\n            finder.get(arr[i]).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        Queue<Integer> current = new LinkedList<Integer>();\\n        \\n        current.add(0);\\n        visited[0] = true;\\n        \\n        int steps = 0;\\n        while (!current.isEmpty()) {\\n            int x = current.size();\\n            \\n            for (int i = 0; i < x; ++i) {\\n                int index = current.poll();\\n                if (index == n-1) {\\n                    return steps;\\n                }\\n                \\n                if ((index + 1) < n && !visited[index+1]) {\\n                    visited[index + 1] = true;\\n                    current.add(index + 1);\\n                }\\n                \\n                if (index - 1 >= 0 && !visited[index-1]) {\\n                    visited[index - 1] = true;\\n                    current.add(index - 1);\\n                }\\n                \\n                for (int pos : finder.get(arr[index])) {\\n                    if (pos != index) {\\n                        visited[pos] = true;\\n                        current.add(pos);\\n                    }\\n                }\\n                \\n                // Clearing the list so we won\\'t stuck in forloop at step 39 every time. \\n                finder.get(arr[index]).clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        \\n        Map<Integer, List<Integer>> finder = new HashMap<>();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            finder.computeIfAbsent(arr[i], v -> new ArrayList<Integer>());\\n            finder.get(arr[i]).add(i);\\n        }\\n        \\n        boolean[] visited = new boolean[n];\\n        \\n        Queue<Integer> current = new LinkedList<Integer>();\\n        \\n        current.add(0);\\n        visited[0] = true;\\n        \\n        int steps = 0;\\n        while (!current.isEmpty()) {\\n            int x = current.size();\\n            \\n            for (int i = 0; i < x; ++i) {\\n                int index = current.poll();\\n                if (index == n-1) {\\n                    return steps;\\n                }\\n                \\n                if ((index + 1) < n && !visited[index+1]) {\\n                    visited[index + 1] = true;\\n                    current.add(index + 1);\\n                }\\n                \\n                if (index - 1 >= 0 && !visited[index-1]) {\\n                    visited[index - 1] = true;\\n                    current.add(index - 1);\\n                }\\n                \\n                for (int pos : finder.get(arr[index])) {\\n                    if (pos != index) {\\n                        visited[pos] = true;\\n                        current.add(pos);\\n                    }\\n                }\\n                \\n                // Clearing the list so we won\\'t stuck in forloop at step 39 every time. \\n                finder.get(arr[index]).clear();\\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257955,
                "title": "rust-elixir-hashing-bfs",
                "content": "# Approach\\nUse a HashMap to store the list of indices for each arr value.\\nAfter each BFS move, delete the respective indices list from the HashMap so it won\\'t be iterated over again.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n# Rust\\n```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        let mut hash = HashMap::new();\\n        for (i, &x) in arr.iter().enumerate() {\\n            hash.entry(x).or_insert(Vec::new()).push(i);\\n        }\\n        let mut visited = vec![false; arr.len()];\\n        visited[0] = true;\\n        \\n        let mut curr = vec![0];\\n        let mut next = Vec::new();\\n        for step in 0.. {\\n            for i in curr.drain(..) {\\n                if i == arr.len() - 1 {\\n                    return step;\\n                }\\n                for j in hash.remove(&arr[i])\\n                            .unwrap_or(Vec::new())\\n                            .into_iter()\\n                            .chain(vec![i.saturating_sub(1), i + 1].into_iter()) {\\n                    if !visited[j] {\\n                        next.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut curr, &mut next);\\n        }\\n        unreachable!()\\n    }\\n}\\n```\\n# Elixir\\n```elixir\\ndefmodule Solution do\\n  @spec min_jumps(arr :: [integer]) :: integer\\n  def min_jumps(arr) do\\n    map =\\n      Enum.with_index(arr)\\n      |> Enum.reduce(%{}, fn {x, i}, map ->\\n        Map.update(map, x, [i], &([i | &1]))\\n      end)\\n    \\n    bfs([0], [], 0, MapSet.new([0]), List.to_tuple(arr), map)\\n  end\\n\\n  defp bfs([i | _], _, step, _, t, _) when i == tuple_size(t) - 1, do: step\\n  defp bfs([i | tail], list2, step, visited, t, map) do\\n    Map.get(map, elem(t, i), [])\\n    |> Kernel.++([i - 1, i + 1])\\n    |> Enum.reduce({list2, visited}, fn j, {list2, visited} ->\\n      if j >= 0 and j < tuple_size(t) and not MapSet.member?(visited, j) do\\n        {[j | list2], MapSet.put(visited, j)}\\n      else\\n        {list2, visited}\\n      end\\n    end)\\n    |> then(fn {list2, visited} ->\\n      bfs(tail, list2, step, visited, t, Map.delete(map, elem(t, i)))\\n    end)\\n  end\\n  defp bfs([], list2, step, visited, t, map) do\\n    bfs(list2, [], step + 1, visited, t, map)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Rust",
                    "Elixir",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        let mut hash = HashMap::new();\\n        for (i, &x) in arr.iter().enumerate() {\\n            hash.entry(x).or_insert(Vec::new()).push(i);\\n        }\\n        let mut visited = vec![false; arr.len()];\\n        visited[0] = true;\\n        \\n        let mut curr = vec![0];\\n        let mut next = Vec::new();\\n        for step in 0.. {\\n            for i in curr.drain(..) {\\n                if i == arr.len() - 1 {\\n                    return step;\\n                }\\n                for j in hash.remove(&arr[i])\\n                            .unwrap_or(Vec::new())\\n                            .into_iter()\\n                            .chain(vec![i.saturating_sub(1), i + 1].into_iter()) {\\n                    if !visited[j] {\\n                        next.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n            }\\n            std::mem::swap(&mut curr, &mut next);\\n        }\\n        unreachable!()\\n    }\\n}\\n```\n```elixir\\ndefmodule Solution do\\n  @spec min_jumps(arr :: [integer]) :: integer\\n  def min_jumps(arr) do\\n    map =\\n      Enum.with_index(arr)\\n      |> Enum.reduce(%{}, fn {x, i}, map ->\\n        Map.update(map, x, [i], &([i | &1]))\\n      end)\\n    \\n    bfs([0], [], 0, MapSet.new([0]), List.to_tuple(arr), map)\\n  end\\n\\n  defp bfs([i | _], _, step, _, t, _) when i == tuple_size(t) - 1, do: step\\n  defp bfs([i | tail], list2, step, visited, t, map) do\\n    Map.get(map, elem(t, i), [])\\n    |> Kernel.++([i - 1, i + 1])\\n    |> Enum.reduce({list2, visited}, fn j, {list2, visited} ->\\n      if j >= 0 and j < tuple_size(t) and not MapSet.member?(visited, j) do\\n        {[j | list2], MapSet.put(visited, j)}\\n      else\\n        {list2, visited}\\n      end\\n    end)\\n    |> then(fn {list2, visited} ->\\n      bfs(tail, list2, step, visited, t, Map.delete(map, elem(t, i)))\\n    end)\\n  end\\n  defp bfs([], list2, step, visited, t, map) do\\n    bfs(list2, [], step + 1, visited, t, map)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2953698,
                "title": "simple-c-solution-with-various-optimization-to-reduce-sample-spaces",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> vis(n,0);\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0] = 1;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        unordered_set<int> us;\\n        \\n        while(!q.empty())\\n        {\\n            \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n            int i = q.front().first;\\n            int step = q.front().second;\\n            //cout<<i<<\" \"<<step<<endl;\\n            q.pop();\\n            \\n            if(i==n-1) return step;\\n                \\n            if(i+1<n && !vis[i+1] && arr[i+1]!=arr[i])\\n            {\\n                q.push({i+1,step+1});\\n                vis[i+1]=1;\\n            }\\n                \\n            if(i-1>=0 && !vis[i-1] && arr[i-1]!=arr[i])\\n            {\\n                q.push({i-1,step+1});\\n                vis[i-1]=1;\\n            }   \\n               \\n            if(us.count(arr[i])) continue;\\n            us.insert(arr[i]);\\n                \\n            for(int j=0; j<mp[arr[i]].size(); j++)\\n            {\\n                if(!vis[mp[arr[i]][j]] && mp[arr[i]][j] != i)\\n                {\\n                    q.push({mp[arr[i]][j],step+1});\\n                    vis[mp[arr[i]][j]]=1;\\n                }\\n            }\\n            \\n            }\\n            //cout<<\"ek kaam\"<<endl;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> vis(n,0);\\n        queue<pair<int,int>> q;\\n        q.push({0,0});\\n        vis[0] = 1;\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        unordered_set<int> us;\\n        \\n        while(!q.empty())\\n        {\\n            \\n            int sz = q.size();\\n            while(sz--)\\n            {\\n            int i = q.front().first;\\n            int step = q.front().second;\\n            //cout<<i<<\" \"<<step<<endl;\\n            q.pop();\\n            \\n            if(i==n-1) return step;\\n                \\n            if(i+1<n && !vis[i+1] && arr[i+1]!=arr[i])\\n            {\\n                q.push({i+1,step+1});\\n                vis[i+1]=1;\\n            }\\n                \\n            if(i-1>=0 && !vis[i-1] && arr[i-1]!=arr[i])\\n            {\\n                q.push({i-1,step+1});\\n                vis[i-1]=1;\\n            }   \\n               \\n            if(us.count(arr[i])) continue;\\n            us.insert(arr[i]);\\n                \\n            for(int j=0; j<mp[arr[i]].size(); j++)\\n            {\\n                if(!vis[mp[arr[i]][j]] && mp[arr[i]][j] != i)\\n                {\\n                    q.push({mp[arr[i]][j],step+1});\\n                    vis[mp[arr[i]][j]]=1;\\n                }\\n            }\\n            \\n            }\\n            //cout<<\"ek kaam\"<<endl;\\n        }\\n        return INT_MAX;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1691313,
                "title": "simple-easy-to-understand",
                "content": "**Idea?**\\n* Do a simple **breadth first search** to find out the minimum number of jumps required.\\n* Visit adjacent indices for every current index, provided they are still unvisited.\\n* Also, for a particular index i, **visit all those indices j which has same value as of arr[i]**, and there is **no need to visit those indices again.**\\n* Check Code below.\\n\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp; // unique elements to their indices\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]].push_back(i);\\n        queue<pair<int,int>> q; // {element,jumps}\\n        vector<bool> vis(n);\\n        vis[0] = true;\\n        q.push({0,0});\\n        int ans;\\n        while(!q.empty()){\\n            int v = q.front().first,jumps = q.front().second;\\n            q.pop();\\n            if(v==n-1){\\n                ans = jumps;\\n                break;\\n            }\\n            if(v+1<n and !vis[v+1]){\\n                vis[v+1] = true;\\n                q.push({v+1,jumps+1});\\n            }\\n            if(v-1>=0 and !vis[v-1]){\\n                vis[v-1] = true;\\n                q.push({v-1,jumps+1});\\n            }\\n            if(!mp.count(arr[v]))\\n                continue;\\n            for(auto& j:mp[arr[v]]){\\n                if(!vis[j]){\\n                    vis[j] = true;\\n                    q.push({j,jumps+1});\\n                }\\n            }\\n            mp.erase(arr[v]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Don\\'t Forget to Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp; // unique elements to their indices\\n        for(int i=0;i<n;i++)\\n            mp[arr[i]].push_back(i);\\n        queue<pair<int,int>> q; // {element,jumps}\\n        vector<bool> vis(n);\\n        vis[0] = true;\\n        q.push({0,0});\\n        int ans;\\n        while(!q.empty()){\\n            int v = q.front().first,jumps = q.front().second;\\n            q.pop();\\n            if(v==n-1){\\n                ans = jumps;\\n                break;\\n            }\\n            if(v+1<n and !vis[v+1]){\\n                vis[v+1] = true;\\n                q.push({v+1,jumps+1});\\n            }\\n            if(v-1>=0 and !vis[v-1]){\\n                vis[v-1] = true;\\n                q.push({v-1,jumps+1});\\n            }\\n            if(!mp.count(arr[v]))\\n                continue;\\n            for(auto& j:mp[arr[v]]){\\n                if(!vis[j]){\\n                    vis[j] = true;\\n                    q.push({j,jumps+1});\\n                }\\n            }\\n            mp.erase(arr[v]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690927,
                "title": "python3-recursion-gives-tle-check-out-bfs-solution",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, i in enumerate(arr):\\n            d[i].append(j)\\n        ans = float(\"inf\")\\n        visited = set()\\n\\n        def rec(i, jump):\\n            nonlocal ans, visited, d\\n            if 0 > i or i >= len(arr) or i in visited:\\n                return\\n\\n            if i == len(arr)-1:\\n                ans = min(ans, jump)\\n                return\\n            visited.add(i)\\n            rec(i-1, jump+1)\\n            rec(i+1, jump+1)\\n            for ele in d[arr[i]]:\\n                if ele > i:\\n                    rec(ele, jump+1)\\n            visited.remove(i)\\n\\n        rec(0, 0)\\n        return ans\\n```\\n\\nIt gives TLE for [51,64,-15,58,98,31,48,72,78,-63,92,-5,64,-64,51,-48,64,48,-76,-86,-5,-64,-86,-47,92,-41,58,72,31,78,-15,-76,72,-5,-97,98,78,-97,-41,\\n-47,-86,-97,78,-97,58,-41,72,-41,72,-25,-76,51,-86,-65,78,-63,72,-15,48,-15,-63,-65,31,-41,95,51,-47,51,-41,-76,58,-81,-41,88,58,-81,88,88,-47,-48,72,-25,-86,-41,-86,-64,-15,-63]\\n\\n*If you can make the above work, then pls comment the solution, thanks in advance!! :)*\\n\\n**BFS Solution:**\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, ele in enumerate(arr):\\n            d[ele].append(j)\\n\\n        queue = deque([0])\\n        steps = 0\\n        visited = {0}\\n        n = len(arr)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i = queue.popleft()\\n                if i == n - 1:\\n                    return steps\\n                for ele in [*d[arr[i]], i-1, i+1]:\\n                    if ele not in visited and 0 <= ele <= n:\\n                        visited.add(ele)\\n                        queue.append(ele)\\n                d[arr[i]].clear() # We should clear the list of index, to avoid recalculation at line **for ele in [*d[arr[i]], i-1, i+1]:**\\n            steps += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, i in enumerate(arr):\\n            d[i].append(j)\\n        ans = float(\"inf\")\\n        visited = set()\\n\\n        def rec(i, jump):\\n            nonlocal ans, visited, d\\n            if 0 > i or i >= len(arr) or i in visited:\\n                return\\n\\n            if i == len(arr)-1:\\n                ans = min(ans, jump)\\n                return\\n            visited.add(i)\\n            rec(i-1, jump+1)\\n            rec(i+1, jump+1)\\n            for ele in d[arr[i]]:\\n                if ele > i:\\n                    rec(ele, jump+1)\\n            visited.remove(i)\\n\\n        rec(0, 0)\\n        return ans\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        d = defaultdict(list)\\n        for j, ele in enumerate(arr):\\n            d[ele].append(j)\\n\\n        queue = deque([0])\\n        steps = 0\\n        visited = {0}\\n        n = len(arr)\\n        while queue:\\n            for _ in range(len(queue)):\\n                i = queue.popleft()\\n                if i == n - 1:\\n                    return steps\\n                for ele in [*d[arr[i]], i-1, i+1]:\\n                    if ele not in visited and 0 <= ele <= n:\\n                        visited.add(ele)\\n                        queue.append(ele)\\n                d[arr[i]].clear() # We should clear the list of index, to avoid recalculation at line **for ele in [*d[arr[i]], i-1, i+1]:**\\n            steps += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055395,
                "title": "python-bfs-w-comment",
                "content": "```py\\n\\'\\'\\'\\nw: minimum steps --> BFS\\nh: 1) build a graph where node is index of the arr\\n   2) for each node, we have three choices:\\n        1) index + 1\\n        2) index - 1\\n        3) index_i to index_j where arr[i]==arr[j]\\n   3) process like regular BFS until we hit the last index\\nNote that if we only use BFS to solve, we might encounter a memory limit problem\\nthis is because [7,....,7, 11] if all the numbers are the same except the last one, the graph and queue are huge, so we need to do a compression on original arr, note that\\n[7,....,7,11] is actually the same as [7,7,11] -- this may be the hard part of this problem\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        if arr[0] == arr[-1]:\\n            return 1\\n        \\n        # compress the original array\\n        compressedArr = arr[0:2]\\n        for num in arr[2:]:\\n            if num == compressedArr[-1] == compressedArr[-2]:\\n                continue\\n            compressedArr.append(num)\\n        arr = compressedArr\\n        \\n        indexDic = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            indexDic[num].append(idx)\\n        \\n        graph = collections.defaultdict(set)\\n        for idx, num in enumerate(arr):\\n            # 1. idx + 1 or idx-1 or both\\n            if idx == 0:\\n                graph[idx].add(idx+1)\\n            elif idx == len(arr)-1:\\n                graph[idx].add(idx-1)\\n            else:\\n                graph[idx].add(idx-1)\\n                graph[idx].add(idx+1)\\n            \\n            # 2. arr[i] == arr[j], i != j\\n            for v in indexDic[num]:\\n                if v != idx:\\n                    graph[idx].add(v)\\n        \\n        #print(graph)\\n        seen = set()\\n        deque = collections.deque([0])\\n        steps = 0\\n        \\n        while deque:\\n            size = len(deque)\\n            for _ in range(size):\\n                curr = deque.popleft()\\n                seen.add(curr)\\n                if curr == len(arr) - 1:\\n                    return steps # note that we will always hit the last index\\n                \\n                for child in graph[curr]:\\n                    if child not in seen:\\n                        deque.append(child)\\n                        seen.add(child)\\n                \\n                \\n            steps += 1   \\n            #print(deque)   \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```py\\n\\'\\'\\'\\nw: minimum steps --> BFS\\nh: 1) build a graph where node is index of the arr\\n   2) for each node, we have three choices:\\n        1) index + 1\\n        2) index - 1\\n        3) index_i to index_j where arr[i]==arr[j]\\n   3) process like regular BFS until we hit the last index\\nNote that if we only use BFS to solve, we might encounter a memory limit problem\\nthis is because [7,....,7, 11] if all the numbers are the same except the last one, the graph and queue are huge, so we need to do a compression on original arr, note that\\n[7,....,7,11] is actually the same as [7,7,11] -- this may be the hard part of this problem\\n\\'\\'\\'\\n\\nimport collections\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 0\\n        \\n        if arr[0] == arr[-1]:\\n            return 1\\n        \\n        # compress the original array\\n        compressedArr = arr[0:2]\\n        for num in arr[2:]:\\n            if num == compressedArr[-1] == compressedArr[-2]:\\n                continue\\n            compressedArr.append(num)\\n        arr = compressedArr\\n        \\n        indexDic = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            indexDic[num].append(idx)\\n        \\n        graph = collections.defaultdict(set)\\n        for idx, num in enumerate(arr):\\n            # 1. idx + 1 or idx-1 or both\\n            if idx == 0:\\n                graph[idx].add(idx+1)\\n            elif idx == len(arr)-1:\\n                graph[idx].add(idx-1)\\n            else:\\n                graph[idx].add(idx-1)\\n                graph[idx].add(idx+1)\\n            \\n            # 2. arr[i] == arr[j], i != j\\n            for v in indexDic[num]:\\n                if v != idx:\\n                    graph[idx].add(v)\\n        \\n        #print(graph)\\n        seen = set()\\n        deque = collections.deque([0])\\n        steps = 0\\n        \\n        while deque:\\n            size = len(deque)\\n            for _ in range(size):\\n                curr = deque.popleft()\\n                seen.add(curr)\\n                if curr == len(arr) - 1:\\n                    return steps # note that we will always hit the last index\\n                \\n                for child in graph[curr]:\\n                    if child not in seen:\\n                        deque.append(child)\\n                        seen.add(child)\\n                \\n                \\n            steps += 1   \\n            #print(deque)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988982,
                "title": "c-with-expl-on-why-dfs-fails-and-how-to-efficiently-pass-bfs",
                "content": "Crucial Part to get rid of BFS TLE:\\n\\n\"indexMap[arr[index]].clear();\"\\nWe should be clearing the map and you might be wondering that visited array might be taking care of that which is correct but it still is iterarting over the map and hence makes sense to clear the map.\\n\\nDFS will work but will give TLE. If you try memoizing it, TLE would go away but ans would be wrong bcz you are just calculating first value you find which may not be min(optimal) bcz DFS is random order only.\\n\\nConclusion: Using BFS bcz MINIMUM distance is req and clearing map helps!\\n```\\nclass Solution {\\npublic:\\n  /**  int rec(vector<int> &arr, vector<int> visited, map<int, vector<int>> &indexMap, vector<int> &dp, int index){\\n        int ans=-1;\\n        if(index==arr.size()-1){\\n            return 0;\\n        }\\n        if(index>= arr.size() || index<0){\\n           return INT_MAX;\\n        }\\n        cout<<dp[index];\\n        \\n        visited[index]=true;\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans1=INT_MAX, ans2=INT_MAX, ans3=INT_MAX;   \\n        if(index-1>=0 && !visited[index-1])\\n            ans1= rec(arr, visited, indexMap, dp,index-1);\\n        if(index+1<arr.size() && !visited[index+1])\\n            ans2= rec(arr, visited, indexMap, dp,index+1);\\n        vector<int> temp= indexMap[arr[index]];\\n        for(int i=0;i<temp.size();i++){\\n           if(temp[i]!=index && !visited[temp[i]]){\\n               ans3=rec(arr, visited, indexMap, dp,temp[i]);\\n           }\\n        }\\n        cout<<ans1<<ans2<<ans3<<endl;\\n        ans=min(ans1, min(ans2, ans3));\\n        if(ans==INT_MAX) { dp[index]=0; return 0;}\\n        else\\n         {dp[index]=ans+1; return ans+1;}\\n    }\\n    **/\\n    \\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> indexMap;\\n        for(int i=0;i<arr.size();i++){\\n            indexMap[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(arr.size(),0);\\n        vector<int> dp(arr.size()+1,-1);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        int steps=0;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz--){\\n                int index= q.front();\\n                q.pop();\\n                if(index==arr.size()-1) return steps;\\n                if(index-1>=0 && !visited[index-1]){\\n                    q.push(index-1);\\n                    visited[index-1]=1;\\n                }\\n                if(index+1<arr.size() && !visited[index+1]){\\n                    if(index+1==arr.size()-1) return steps+1;\\n                    q.push(index+1);\\n                    visited[index+1]=1;\\n                }\\n                vector<int> temp= indexMap[arr[index]];\\n                for(int i=0;i<temp.size();i++){     \\n                    if(temp[i]==arr.size()-1) return steps+1;\\n                   if(temp[i]!=index && temp[i]!=index-1 && temp[i]!=index-1 &&!visited[temp[i]]){\\n                       \\n                       q.push(temp[i]);\\n                       visited[temp[i]]=1;\\n                   }\\n                }\\n                indexMap[arr[index]].clear();\\n                \\n                \\n            }\\n            \\n            steps++;\\n            \\n            \\n        }\\n        return steps;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  /**  int rec(vector<int> &arr, vector<int> visited, map<int, vector<int>> &indexMap, vector<int> &dp, int index){\\n        int ans=-1;\\n        if(index==arr.size()-1){\\n            return 0;\\n        }\\n        if(index>= arr.size() || index<0){\\n           return INT_MAX;\\n        }\\n        cout<<dp[index];\\n        \\n        visited[index]=true;\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int ans1=INT_MAX, ans2=INT_MAX, ans3=INT_MAX;   \\n        if(index-1>=0 && !visited[index-1])\\n            ans1= rec(arr, visited, indexMap, dp,index-1);\\n        if(index+1<arr.size() && !visited[index+1])\\n            ans2= rec(arr, visited, indexMap, dp,index+1);\\n        vector<int> temp= indexMap[arr[index]];\\n        for(int i=0;i<temp.size();i++){\\n           if(temp[i]!=index && !visited[temp[i]]){\\n               ans3=rec(arr, visited, indexMap, dp,temp[i]);\\n           }\\n        }\\n        cout<<ans1<<ans2<<ans3<<endl;\\n        ans=min(ans1, min(ans2, ans3));\\n        if(ans==INT_MAX) { dp[index]=0; return 0;}\\n        else\\n         {dp[index]=ans+1; return ans+1;}\\n    }\\n    **/\\n    \\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> indexMap;\\n        for(int i=0;i<arr.size();i++){\\n            indexMap[arr[i]].push_back(i);\\n        }\\n        vector<int> visited(arr.size(),0);\\n        vector<int> dp(arr.size()+1,-1);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        visited[0]=1;\\n        int steps=0;\\n        while(q.size()>0){\\n            int sz=q.size();\\n            while(sz--){\\n                int index= q.front();\\n                q.pop();\\n                if(index==arr.size()-1) return steps;\\n                if(index-1>=0 && !visited[index-1]){\\n                    q.push(index-1);\\n                    visited[index-1]=1;\\n                }\\n                if(index+1<arr.size() && !visited[index+1]){\\n                    if(index+1==arr.size()-1) return steps+1;\\n                    q.push(index+1);\\n                    visited[index+1]=1;\\n                }\\n                vector<int> temp= indexMap[arr[index]];\\n                for(int i=0;i<temp.size();i++){     \\n                    if(temp[i]==arr.size()-1) return steps+1;\\n                   if(temp[i]!=index && temp[i]!=index-1 && temp[i]!=index-1 &&!visited[temp[i]]){\\n                       \\n                       q.push(temp[i]);\\n                       visited[temp[i]]=1;\\n                   }\\n                }\\n                indexMap[arr[index]].clear();\\n                \\n                \\n            }\\n            \\n            steps++;\\n            \\n            \\n        }\\n        return steps;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 876699,
                "title": "rust-translated-32ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n\\n        let n = arr.len();\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        for i in 0..n {\\n            graph.entry(arr[i as usize]).or_default().push(i as i32);\\n        }\\n        let mut visited = vec![false; n];\\n        visited[0] = true;\\n        let mut q = VecDeque::<i32>::new();\\n        q.push_back(0);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let i = q.pop_front().unwrap();\\n                if i == n as i32 - 1 {\\n                    return step;\\n                }\\n                let next = graph.get_mut(&arr[i as usize]).unwrap();\\n                next.push(i - 1);\\n                next.push(i + 1);\\n                for &j in next.iter() {\\n                    if j >= 0 && j < n as i32 && !visited[j as usize] {\\n                        visited[j as usize] = true;\\n                        q.push_back(j);\\n                    }\\n                }\\n                next.clear()\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_jumps() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![100, -23, -23, 404, 100, 23, 23, 23, 3, 404]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_02() {\\n        assert_eq!(Solution::min_jumps(vec![7]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_03() {\\n        assert_eq!(Solution::min_jumps(vec![7, 6, 9, 6, 9, 6, 9, 7]), 1);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_04() {\\n        assert_eq!(Solution::min_jumps(vec![6, 1, 9]), 2);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_05() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![11, 22, 7, 7, 7, 7, 7, 7, 7, 22, 13]),\\n            3\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn min_jumps(arr: Vec<i32>) -> i32 {\\n        use std::collections::{HashMap, VecDeque};\\n\\n        let n = arr.len();\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        for i in 0..n {\\n            graph.entry(arr[i as usize]).or_default().push(i as i32);\\n        }\\n        let mut visited = vec![false; n];\\n        visited[0] = true;\\n        let mut q = VecDeque::<i32>::new();\\n        q.push_back(0);\\n        let mut step = 0;\\n        while !q.is_empty() {\\n            let size = q.len();\\n            for _ in 0..size {\\n                let i = q.pop_front().unwrap();\\n                if i == n as i32 - 1 {\\n                    return step;\\n                }\\n                let next = graph.get_mut(&arr[i as usize]).unwrap();\\n                next.push(i - 1);\\n                next.push(i + 1);\\n                for &j in next.iter() {\\n                    if j >= 0 && j < n as i32 && !visited[j as usize] {\\n                        visited[j as usize] = true;\\n                        q.push_back(j);\\n                    }\\n                }\\n                next.clear()\\n            }\\n            step += 1;\\n        }\\n        -1\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_min_jumps() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![100, -23, -23, 404, 100, 23, 23, 23, 3, 404]),\\n            3\\n        );\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_02() {\\n        assert_eq!(Solution::min_jumps(vec![7]), 0);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_03() {\\n        assert_eq!(Solution::min_jumps(vec![7, 6, 9, 6, 9, 6, 9, 7]), 1);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_04() {\\n        assert_eq!(Solution::min_jumps(vec![6, 1, 9]), 2);\\n    }\\n\\n    #[test]\\n    fn test_min_jumps_05() {\\n        assert_eq!(\\n            Solution::min_jumps(vec![11, 22, 7, 7, 7, 7, 7, 7, 7, 22, 13]),\\n            3\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 853365,
                "title": "no-dp-faster-bidirectional-bfs-with-explanation",
                "content": "**Updated on 2020.10.16**\\nI found my previous code and the official\\'s were not concise.\\n\\nActually, if we use bidirectional BFS in this task, \\nwe don\\'t need extra DP cache to memo any past visits\\nbecause we only need to check whether any our current side\\'s nodes\\' child nodes exist in the opposite queue. \\nIf they don\\'t not meet each other, we keep them. \\n\\nTherefore, we don\\'t need to memo visited nodes(even appear again, dumping it is easy by set() and deleting node\\'s connection) \\nand can make code more concise and cleaner as possible. (the same better efficiency)\\n****\\n\\nIntuitively, we can solve this task with BFS.\\n\\nWe can see each index as an node of three kinds of search space,\\n1. move backwards(index - 1)\\n2. in place(jump to the index of the same assigned num)\\n3. move forwards(index + 1).\\n\\nTherefore, we need a map first to check where the jumping goes, the connection of nodes.\\n\\nDuring searching, \\nwe can move search level next and next until we find the end node appears in our search level. \\n\\nBFS has a downside, as searching deeper and deeper, \\nthe space of each level will become larger and larger if the end nodes are unlimited. \\nBut in this task, the end node is only one, so the search space will shrink.\\n\\nIn other words, we can ***search forwards or backwards exchangedly***, \\nbecause if we are closed to two end-side, the search space of each level will smaller than in the middle. \\nWe can ***have chance to find all nodes by the connection in smaller space*** of level, not the larger in the middle level. \\nThat will speed search and be faster than normal BFS in some extension. \\n\\n***We only need to check when the search levels of two sides intersect.***\\n\\nCode with clear comments as below.\\nWelcome suggestion, question, comments\\nIf helpful, ***please upvote! Thanks a lot!***\\n\\n```\\nclass Solution: # bidirectional, best 368 ms\\n    def minJumps(self, array):\\n        length = len(array)\\n        if len(set(array)) == length: return length - 1\\n        if array[0] == array[-1]: return 1\\n\\n        _map = defaultdict(list) # connection map\\n        for i, val in enumerate(array): _map[val].append(i)\\n\\n        curs, other = {0}, {length - 1}\\n        for step in count():\\n            # choose smaller side\\n            if len(curs) > len(other): curs, other = other, curs\\n\\n            thisLevel = set()\\n            for i in curs:\\n                # add backward and forward moves into current jumping space\\n                # make the same operation accomplished in only one loop\\n                for j in (i + 1, i - 1):\\n                    if 0 < j < length: _map[array[i]].append(j)\\n\\n                for j in _map[array[i]]:\\n                    if j in other: return step\\n                    else: thisLevel.add(j)\\n                del _map[array[i]]\\n\\n            # update current side for next round          \\n            curs = thisLevel\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution: # bidirectional, best 368 ms\\n    def minJumps(self, array):\\n        length = len(array)\\n        if len(set(array)) == length: return length - 1\\n        if array[0] == array[-1]: return 1\\n\\n        _map = defaultdict(list) # connection map\\n        for i, val in enumerate(array): _map[val].append(i)\\n\\n        curs, other = {0}, {length - 1}\\n        for step in count():\\n            # choose smaller side\\n            if len(curs) > len(other): curs, other = other, curs\\n\\n            thisLevel = set()\\n            for i in curs:\\n                # add backward and forward moves into current jumping space\\n                # make the same operation accomplished in only one loop\\n                for j in (i + 1, i - 1):\\n                    if 0 < j < length: _map[array[i]].append(j)\\n\\n                for j in _map[array[i]]:\\n                    if j in other: return step\\n                    else: thisLevel.add(j)\\n                del _map[array[i]]\\n\\n            # update current side for next round          \\n            curs = thisLevel\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503724,
                "title": "c-solution-bfs",
                "content": "```\\npublic class Solution \\n{\\n    public int MinJumps(int[] arr) \\n    {\\n        int n = arr.Length;\\n        var numToIndex = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!numToIndex.ContainsKey(arr[i])) \\n                numToIndex[arr[i]] = new List<int>();\\n            numToIndex[arr[i]].Add(i);\\n        }\\n        \\n        var visited = new bool[n];\\n        var queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int level = 0;\\n        while(queue.Count != 0)\\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(curr == n - 1) return level;\\n                var list =  numToIndex[arr[curr]];\\n                if(curr - 1 >= 0) list.Add(curr - 1);\\n                if(curr + 1 < n) list.Add(curr + 1);\\n                foreach(var i in list)\\n                {\\n                    if(!visited[i])\\n                    {\\n                        visited[i] = true;\\n                        queue.Enqueue(i);\\n                    }\\n                }\\n                \\n                numToIndex[arr[curr]] = new List<int>();\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return n - 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int MinJumps(int[] arr) \\n    {\\n        int n = arr.Length;\\n        var numToIndex = new Dictionary<int, List<int>>();\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(!numToIndex.ContainsKey(arr[i])) \\n                numToIndex[arr[i]] = new List<int>();\\n            numToIndex[arr[i]].Add(i);\\n        }\\n        \\n        var visited = new bool[n];\\n        var queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int level = 0;\\n        while(queue.Count != 0)\\n        {\\n            int count = queue.Count;\\n            for(int cnt = 0; cnt < count; cnt++)\\n            {\\n                var curr = queue.Dequeue();\\n                if(curr == n - 1) return level;\\n                var list =  numToIndex[arr[curr]];\\n                if(curr - 1 >= 0) list.Add(curr - 1);\\n                if(curr + 1 < n) list.Add(curr + 1);\\n                foreach(var i in list)\\n                {\\n                    if(!visited[i])\\n                    {\\n                        visited[i] = true;\\n                        queue.Enqueue(i);\\n                    }\\n                }\\n                \\n                numToIndex[arr[curr]] = new List<int>();\\n            }\\n            \\n            level++;\\n        }\\n        \\n        return n - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502721,
                "title": "python-bfs",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(set(arr)) == len(arr):return len(arr)-1\\n        conn = collections.defaultdict(set)\\n        for i,val in enumerate(arr):\\n            conn[val].add(i)\\n        res,cur,seen,visit = 0, {0}, {0},set()\\n        while len(arr)-1 not in seen:\\n            res += 1\\n            tmp = set()\\n            for node in seen:\\n                if node -1 > 0 and node-1 not in seen: tmp.add(node-1)\\n                if arr[node] not in visit:\\n                    tmp |= (conn[arr[node]] - seen)\\n                    visit.add(arr[node])\\n                if node +1 < len(arr) and node +1 not in seen: tmp.add(node + 1)\\n            tmp -= seen\\n            seen |= tmp\\n            cur = tmp\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        if len(set(arr)) == len(arr):return len(arr)-1\\n        conn = collections.defaultdict(set)\\n        for i,val in enumerate(arr):\\n            conn[val].add(i)\\n        res,cur,seen,visit = 0, {0}, {0},set()\\n        while len(arr)-1 not in seen:\\n            res += 1\\n            tmp = set()\\n            for node in seen:\\n                if node -1 > 0 and node-1 not in seen: tmp.add(node-1)\\n                if arr[node] not in visit:\\n                    tmp |= (conn[arr[node]] - seen)\\n                    visit.add(arr[node])\\n                if node +1 < len(arr) and node +1 not in seen: tmp.add(node + 1)\\n            tmp -= seen\\n            seen |= tmp\\n            cur = tmp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361905,
                "title": "bfs-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;\\n        unordered_map<int, vector<int>> m;\\n        for(int i=n-1; i>=0; i--) m[arr[i]].push_back(i);\\n        \\n        queue<pair<int, int>> q;\\n        q.push({arr[0], 0});\\n\\n        vector<int> vis(n);\\n        vis[0] = 1;\\n\\n        while(q.size()) {\\n            int l = q.size();\\n            while(l--) {\\n                int val = q.front().first, idx = q.front().second;\\n                q.pop();\\n                if(idx == n - 1) return ans;\\n\\n                if(idx + 1 < n && !vis[idx + 1]) {\\n                    q.push({arr[idx + 1], idx + 1});\\n                    vis[idx + 1] = 1;\\n                }\\n                if(idx - 1 >= 0 && !vis[idx - 1]) {\\n                    q.push({arr[idx - 1], idx - 1});\\n                    vis[idx - 1] = 1;\\n                }\\n                for(int j : m[val]) {\\n                    if(idx == j || vis[j]) continue;\\n                    q.push({arr[j], j});\\n                    vis[j] = 1;\\n                }\\n                m.erase(val);\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;\\n        unordered_map<int, vector<int>> m;\\n        for(int i=n-1; i>=0; i--) m[arr[i]].push_back(i);\\n        \\n        queue<pair<int, int>> q;\\n        q.push({arr[0], 0});\\n\\n        vector<int> vis(n);\\n        vis[0] = 1;\\n\\n        while(q.size()) {\\n            int l = q.size();\\n            while(l--) {\\n                int val = q.front().first, idx = q.front().second;\\n                q.pop();\\n                if(idx == n - 1) return ans;\\n\\n                if(idx + 1 < n && !vis[idx + 1]) {\\n                    q.push({arr[idx + 1], idx + 1});\\n                    vis[idx + 1] = 1;\\n                }\\n                if(idx - 1 >= 0 && !vis[idx - 1]) {\\n                    q.push({arr[idx - 1], idx - 1});\\n                    vis[idx - 1] = 1;\\n                }\\n                for(int j : m[val]) {\\n                    if(idx == j || vis[j]) continue;\\n                    q.push({arr[j], j});\\n                    vis[j] = 1;\\n                }\\n                m.erase(val);\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261706,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    int n, vis[50005], dis[50005];\\n\\n    int bfs(int s, vector<int>& arr) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if(u == n-1) return dis[n-1];\\n            if(u-1 >= 0 and !vis[u-1]) {\\n                vis[u-1] = 1;\\n                dis[u-1] = dis[u] + 1;\\n                q.push(u-1);\\n            }\\n            if(u+1 < n and !vis[u+1]) {\\n                vis[u+1] = 1;\\n                dis[u+1] = dis[u] + 1;\\n                q.push(u+1);;\\n            }\\n            for(auto v: g[arr[u]]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n            g[arr[u]].clear();\\n        }\\n        return dis[n-1];\\n    }\\n\\n    int minJumps(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0; i<n; i++) {\\n            g[arr[i]].push_back(i);\\n        }\\n        int ans = bfs(0, arr);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    int n, vis[50005], dis[50005];\\n\\n    int bfs(int s, vector<int>& arr) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if(u == n-1) return dis[n-1];\\n            if(u-1 >= 0 and !vis[u-1]) {\\n                vis[u-1] = 1;\\n                dis[u-1] = dis[u] + 1;\\n                q.push(u-1);\\n            }\\n            if(u+1 < n and !vis[u+1]) {\\n                vis[u+1] = 1;\\n                dis[u+1] = dis[u] + 1;\\n                q.push(u+1);;\\n            }\\n            for(auto v: g[arr[u]]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n            g[arr[u]].clear();\\n        }\\n        return dis[n-1];\\n    }\\n\\n    int minJumps(vector<int>& arr) {\\n        n = arr.size();\\n        for(int i=0; i<n; i++) {\\n            g[arr[i]].push_back(i);\\n        }\\n        int ans = bfs(0, arr);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261395,
                "title": "easy-solution-c-bfs",
                "content": "\\n\\n# Approach\\n# Use Graph (BFS)\\n\\n**We will make a hashmap and store the value and index**\\nelements = 100, -23, -23, 404, 100, 23, 27, 23, 3, 404\\n index   =      0  ,   1 ,   2 ,   3  ,    4 ,  5 ,  6 , 7 ,  8 ,  9\\n \\n*HashMap*\\n100 -> 0,4\\n -23 -> 1,2\\n404 ->  3,9\\n  23 ->  5,6,7\\n    3 ->  8\\n\\t\\t\\nIn this way we have make the hashmap wherein all the values which are same we have store their index.\\n\\nfrom 0 index we  have two ways to go either go to 1index or go to 4\\nThere are two ways to go from 4 you can either go to 3 or go to 5\\nFrom this 3 you can go to wither 9 or 2 or 4 but as we have already taken 4 so don\\'t consisder it.\\n\\n**We can see this is forming a graph where index denotes the nodes of the graph and steps denotes the edges and we need to find the shortest path to reach the end**\\n\\n***We will use BFS two find the Shortest Path***\\nIn BFS we take  a Queue and a Visited Array.\\nwe will also take a step variable.\\nAs in the question it is mentioned the initially we are at 0th index so we will add 0th index to our Queue.\\n\\nNow start the BFS Traversal\\n\\nfor node = 0   next = [ 1, -1, 0, 4 ]   (next denotes the next positions we can go from zero)\\n\\nif i>=0 & i<n  and should not be visited then it is val\\n\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg](https://assets.leetcode.com/users/images/2a444788-e8cc-4cfb-ab3b-83aa2a940eef_1678039979.9747372.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indicesOfValue;\\n        for (int i = 0; i < n; i++)\\n            indicesOfValue[arr[i]].push_back(i);\\n        vector<bool> visited(n); visited[0] = true;\\n        queue<int> q; q.push(0);\\n        int step = 0;\\n        while (!q.empty()) {\\n            for (int size = q.size(); size > 0; --size) {\\n                int i = q.front(); q.pop();\\n                if (i == n - 1) return step; // Reached to last index\\n                vector<int>& next = indicesOfValue[arr[i]];\\n                next.push_back(i - 1); next.push_back(i + 1);\\n                for (int j : next) {\\n                    if (j >= 0 && j < n && !visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indicesOfValue[arr[i]].clear(); // avoid later lookup indicesOfValue arr[i]\\n            }\\n            step++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260817,
                "title": "hash-table-bread-first-search-o-n-beats-91-c",
                "content": "# Code\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int bfs(int src, vector<int> &arr, int n, unordered_map<int, vector<int>> &m)\\n    {\\n        vector<bool> visited(n, false);\\n        queue<int> q;\\n\\n        q.push(src);\\n        int steps = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n\\n                visited[i] = true;\\n\\n                if (i == n - 1)\\n                    return steps;\\n\\n                int val = arr[i];\\n\\n                for (auto &j: m[val]) {\\n                    if (i == j || visited[j])\\n                        continue;\\n\\n                    q.push(j);\\n                }\\n\\n                m[val].clear();\\n\\n                if (i - 1 >= 0 && !visited[i - 1])\\n                    q.push(i - 1);\\n\\n                if (i + 1 < n && !visited[i + 1])\\n                    q.push(i + 1);\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int minJumps(vector<int> &arr) {\\n        int n = arr.size();\\n\\n        if (n == 1)\\n            return 0;\\n\\n        if (arr[0] == arr[n - 1])\\n            return 1;\\n\\n        unordered_map<int, vector<int>> m;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            m[arr[i]].push_back(i);\\n\\n        return bfs(0, arr, n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int bfs(int src, vector<int> &arr, int n, unordered_map<int, vector<int>> &m)\\n    {\\n        vector<bool> visited(n, false);\\n        queue<int> q;\\n\\n        q.push(src);\\n        int steps = 0;\\n\\n        while (!q.empty()) {\\n            int size = q.size();\\n\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n\\n                visited[i] = true;\\n\\n                if (i == n - 1)\\n                    return steps;\\n\\n                int val = arr[i];\\n\\n                for (auto &j: m[val]) {\\n                    if (i == j || visited[j])\\n                        continue;\\n\\n                    q.push(j);\\n                }\\n\\n                m[val].clear();\\n\\n                if (i - 1 >= 0 && !visited[i - 1])\\n                    q.push(i - 1);\\n\\n                if (i + 1 < n && !visited[i + 1])\\n                    q.push(i + 1);\\n            }\\n\\n            steps++;\\n        }\\n\\n        return -1;\\n    }\\n\\n    int minJumps(vector<int> &arr) {\\n        int n = arr.size();\\n\\n        if (n == 1)\\n            return 0;\\n\\n        if (arr[0] == arr[n - 1])\\n            return 1;\\n\\n        unordered_map<int, vector<int>> m;\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            m[arr[i]].push_back(i);\\n\\n        return bfs(0, arr, n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260716,
                "title": "in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can modify the BFS approach to keep track of the number of steps taken to reach a certain index. For this, we can use a separate vector to keep track of the minimum number of steps taken to reach each index. We can initialize this vector to a large value and update it with the minimum number of steps whenever we visit an index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can modify the BFS approach to keep track of the number of steps taken to reach a certain index. For this, we can use a separate vector to keep track of the minimum number of steps taken to reach each index. We can initialize this vector to a large value and update it with the minimum number of steps whenever we visit an index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> minSteps(n, INT_MAX);\\n        minSteps[0] = 0; // starting index\\n\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while (!q.empty()) {\\n            int currIndex = q.front();\\n            q.pop();\\n\\n            if (currIndex == n-1) {\\n                return minSteps[currIndex];\\n            }\\n\\n            if (currIndex-1 >= 0 && minSteps[currIndex-1] == INT_MAX) {\\n                minSteps[currIndex-1] = minSteps[currIndex]+1;\\n                q.push(currIndex-1);\\n            }\\n\\n            if (currIndex+1 < n && minSteps[currIndex+1] == INT_MAX) {\\n                minSteps[currIndex+1] = minSteps[currIndex]+1;\\n                q.push(currIndex+1);\\n            }\\n\\n            for (int index : indices[arr[currIndex]]) {\\n                if (index != currIndex && minSteps[index] == INT_MAX) {\\n                    minSteps[index] = minSteps[currIndex]+1;\\n                    q.push(index);\\n                }\\n            }\\n\\n            // clear the used indices to avoid revisiting them unnecessarily\\n            indices[arr[currIndex]].clear();\\n        }\\n\\n        return -1; // unreachable\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<int> minSteps(n, INT_MAX);\\n        minSteps[0] = 0; // starting index\\n\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n\\n        queue<int> q;\\n        q.push(0);\\n\\n        while (!q.empty()) {\\n            int currIndex = q.front();\\n            q.pop();\\n\\n            if (currIndex == n-1) {\\n                return minSteps[currIndex];\\n            }\\n\\n            if (currIndex-1 >= 0 && minSteps[currIndex-1] == INT_MAX) {\\n                minSteps[currIndex-1] = minSteps[currIndex]+1;\\n                q.push(currIndex-1);\\n            }\\n\\n            if (currIndex+1 < n && minSteps[currIndex+1] == INT_MAX) {\\n                minSteps[currIndex+1] = minSteps[currIndex]+1;\\n                q.push(currIndex+1);\\n            }\\n\\n            for (int index : indices[arr[currIndex]]) {\\n                if (index != currIndex && minSteps[index] == INT_MAX) {\\n                    minSteps[index] = minSteps[currIndex]+1;\\n                    q.push(index);\\n                }\\n            }\\n\\n            // clear the used indices to avoid revisiting them unnecessarily\\n            indices[arr[currIndex]].clear();\\n        }\\n\\n        return -1; // unreachable\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260616,
                "title": "jump-game-iv-most-optimised-bfs-with-coolest-explanation-comments-gauravthinks",
                "content": "# Intuition\\nThe given problem is to find the minimum number of steps to reach the last index of the array, where in one step, we can either move to the adjacent indices or to any index having the same value as the current index.\\n\\nThe approach used to solve this problem is Breadth-First Search (BFS), where we start traversing the array from the first index, and at each step, we explore all the possible jumps that can be made from the current index. We keep track of the visited indices to avoid revisiting the same indices again, and we also maintain a queue to keep track of the indices that need to be explored in the next step.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each index, we explore three possible jumps:\\n\\ni + 1, where i + 1 < arr.length\\ni - 1, where i - 1 >= 0\\nj where arr[i] == arr[j] and i != j\\n\\nIf any of the next indices haven\\'t been visited before, we mark them as visited and add them to the queue. We repeat this process until we reach the last index of the array or until there are no more indices to explore in the queue.\\n\\nThe minimum number of steps to reach the last index of the array is the number of steps required to reach the last index from the first index, which is the number of levels in the BFS tree.\\n\\nTherefore, the intuition behind this approach is to explore all the possible jumps from each index of the array in a breadth-first manner until we reach the last index, and we maintain a count of the number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the BFS algorithm used to solve this problem is O(n), where n is the number of elements in the array. This is because we visit each element of the array exactly once, and for each element, we explore at most three possible jumps.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the algorithm is also O(n), as we need to store the visited array of size n and the queue of size at most n, which can happen in the worst case when all elements have the same value.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        // declaring a map to store the same elements at different indices\\nunordered_map<int, vector<int>> naksha;\\nfor(auto i=0; i<arr.size(); i++){\\n    naksha[arr[i]].push_back(i); // push the indices into a vector in front of the element\\n    //i.e. for a given element, at how many indices it is present, is stored into the above map\\n}\\n//making visited array(which keeps record of elements already touched ) and queue(which stores the indices of the elements)\\nvector<int> vis(n,0);\\nvis[0]=1;\\nqueue<int> koo;\\nkoo.push(0); //pushing indexes\\n\\n\\nint level=0; // this is the result or the number of level in a graph to reach the last index\\n\\nwhile(!koo.empty()){\\n   int  size= koo.size();\\n   while(size--){\\n       int  top=koo.front();\\n       koo.pop();\\n        if(top== n-1) return level; // if the  top element is the last index, return the level of the index\\n        // check for the top+1-th index , if it is valid, push the elements into queue\\n        if(top+1 <n and !vis[top+1]){\\n             vis[top+1]=1; koo.push(top+1);\\n             }\\n             // check for the top-1-th index , if it is valid, push the elements into queue\\n             if(top-1>=0 and !vis[top-1]){\\n                 vis[top-1]=1;\\n                 koo.push(top-1);\\n             }\\n\\n             //push the other indices of the elements, from \\'\\'naksha\\' map\\n             for(int nxt: naksha[arr[top]]){\\n                 if(nxt!=top and !vis[nxt]){\\n\\n                     vis[nxt]=1;\\n                     koo.push(nxt);\\n                 }\\n             }\\n             naksha[arr[top]].clear();\\n       \\n   }\\n//    when one iteration is completed, increase the level by 1\\n\\n   level++;\\n}\\nreturn -1;\\n\\n\\n           }\\n};\\n```\\nIf you liked the solution and explation, do UPVOTE the solution and subscribe to our YouTube channel \\n# @GauravThinks\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n==1)return 0;\\n        // declaring a map to store the same elements at different indices\\nunordered_map<int, vector<int>> naksha;\\nfor(auto i=0; i<arr.size(); i++){\\n    naksha[arr[i]].push_back(i); // push the indices into a vector in front of the element\\n    //i.e. for a given element, at how many indices it is present, is stored into the above map\\n}\\n//making visited array(which keeps record of elements already touched ) and queue(which stores the indices of the elements)\\nvector<int> vis(n,0);\\nvis[0]=1;\\nqueue<int> koo;\\nkoo.push(0); //pushing indexes\\n\\n\\nint level=0; // this is the result or the number of level in a graph to reach the last index\\n\\nwhile(!koo.empty()){\\n   int  size= koo.size();\\n   while(size--){\\n       int  top=koo.front();\\n       koo.pop();\\n        if(top== n-1) return level; // if the  top element is the last index, return the level of the index\\n        // check for the top+1-th index , if it is valid, push the elements into queue\\n        if(top+1 <n and !vis[top+1]){\\n             vis[top+1]=1; koo.push(top+1);\\n             }\\n             // check for the top-1-th index , if it is valid, push the elements into queue\\n             if(top-1>=0 and !vis[top-1]){\\n                 vis[top-1]=1;\\n                 koo.push(top-1);\\n             }\\n\\n             //push the other indices of the elements, from \\'\\'naksha\\' map\\n             for(int nxt: naksha[arr[top]]){\\n                 if(nxt!=top and !vis[nxt]){\\n\\n                     vis[nxt]=1;\\n                     koo.push(nxt);\\n                 }\\n             }\\n             naksha[arr[top]].clear();\\n       \\n   }\\n//    when one iteration is completed, increase the level by 1\\n\\n   level++;\\n}\\nreturn -1;\\n\\n\\n           }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259956,
                "title": "typescript-o-n-time-and-space",
                "content": "# Intuition\\n\\nUse two queue to preform BFS: `cur` and `next` to keep track on the current node we are checking\\n\\n# Approach\\n\\nExample: [0, 1, 2, 0, 5, 6, 1, 3]\\n\\n```ts\\n// x represents being checked in this round,\\n// while n represents the JumpNode be checked in the next round\\n\\n// Round 0\\ncur = [0]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7] // because the map contains idx0, it will\\nval = [0, 1, 2, 0, 5, 6, 1, 3] // still be added to the next, but we will \\n       x  n     n              // skip it during the process\\n\\n// Round 1\\ncur = [0, 1, 3]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  n  x  n     n\\n\\n// Round 2\\ncur = [1, 2, 4, 6]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  n  x  n\\n\\n\\n// Round 3\\ncur = [2, 4, 5, 7]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  x  x  x\\n```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n\\n```ts\\ntype JumpNode = {\\n    val: number;\\n    used: boolean;\\n    minStep: number;\\n}\\n\\nfunction minJumps(arr: number[]): number {\\n    const jompNode: Array<JumpNode> = [];\\n    \\n    // represents value: Array<idx of the value in the arr>\\n    const mp: Record<number, number[]> = {};\\n    const len = arr.length;\\n\\n    // initialisation\\n    for (let i = 0; i < len; ++i) {\\n        jompNode.push({ val: arr[i], used: false, minStep: len - 1 });\\n        if (mp[arr[i]] === undefined) { mp[arr[i]] = []; }\\n        mp[arr[i]].push(i);\\n    }\\n\\n    // cnt starts from -1 because the queue starts from index 0\\n    let cnt = -1;\\n    let cur: Array<number> = [0];\\n    let next: Set<number> = new Set<number>();\\n\\n    // whenever cur is not empty, we continue processing\\n    while (cur.length > 0) {\\n        for (const i of cur) {\\n            if (jompNode[i].used) { continue; }\\n            jompNode[i].used = true;\\n            jompNode[i].minStep = Math.min(jompNode[i].minStep, cnt + 1);\\n\\n            // if we find the last index, return directly\\n            if (i === len - 1) { return jompNode[i].minStep; }\\n\\n            // add the next and the previous idx of JumpNode to queue next\\n            if (i < len - 1 && !jompNode[i + 1].used) { next.add(i + 1); }\\n            if (i > 0 && !jompNode[i - 1].used) { next.add(i - 1); }\\n\\n            const curVal = jompNode[i].val;\\n\\n            // add idx with the same value to queue next\\n            // remove the mp to identify whether the value is already been checked\\n            if (mp[curVal]) {\\n                mp[curVal].forEach(nextIdx => next.add(nextIdx));\\n                delete mp[curVal];\\n            }\\n        }\\n        \\n        // change cur to next, clear the next\\n        cur = Array.from(next);\\n        next = new Set<number>();\\n        ++cnt;\\n    }\\n    \\n    return jompNode[len - 1].minStep;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\n// x represents being checked in this round,\\n// while n represents the JumpNode be checked in the next round\\n\\n// Round 0\\ncur = [0]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7] // because the map contains idx0, it will\\nval = [0, 1, 2, 0, 5, 6, 1, 3] // still be added to the next, but we will \\n       x  n     n              // skip it during the process\\n\\n// Round 1\\ncur = [0, 1, 3]\\n\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  n  x  n     n\\n\\n// Round 2\\ncur = [1, 2, 4, 6]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  n  x  n\\n\\n\\n// Round 3\\ncur = [2, 4, 5, 7]\\nidx = [0, 1, 2, 3, 4, 5, 6, 7]\\nval = [0, 1, 2, 0, 5, 6, 1, 3]\\n       x  x  x  x  x  x  x  x\\n```\n```ts\\ntype JumpNode = {\\n    val: number;\\n    used: boolean;\\n    minStep: number;\\n}\\n\\nfunction minJumps(arr: number[]): number {\\n    const jompNode: Array<JumpNode> = [];\\n    \\n    // represents value: Array<idx of the value in the arr>\\n    const mp: Record<number, number[]> = {};\\n    const len = arr.length;\\n\\n    // initialisation\\n    for (let i = 0; i < len; ++i) {\\n        jompNode.push({ val: arr[i], used: false, minStep: len - 1 });\\n        if (mp[arr[i]] === undefined) { mp[arr[i]] = []; }\\n        mp[arr[i]].push(i);\\n    }\\n\\n    // cnt starts from -1 because the queue starts from index 0\\n    let cnt = -1;\\n    let cur: Array<number> = [0];\\n    let next: Set<number> = new Set<number>();\\n\\n    // whenever cur is not empty, we continue processing\\n    while (cur.length > 0) {\\n        for (const i of cur) {\\n            if (jompNode[i].used) { continue; }\\n            jompNode[i].used = true;\\n            jompNode[i].minStep = Math.min(jompNode[i].minStep, cnt + 1);\\n\\n            // if we find the last index, return directly\\n            if (i === len - 1) { return jompNode[i].minStep; }\\n\\n            // add the next and the previous idx of JumpNode to queue next\\n            if (i < len - 1 && !jompNode[i + 1].used) { next.add(i + 1); }\\n            if (i > 0 && !jompNode[i - 1].used) { next.add(i - 1); }\\n\\n            const curVal = jompNode[i].val;\\n\\n            // add idx with the same value to queue next\\n            // remove the mp to identify whether the value is already been checked\\n            if (mp[curVal]) {\\n                mp[curVal].forEach(nextIdx => next.add(nextIdx));\\n                delete mp[curVal];\\n            }\\n        }\\n        \\n        // change cur to next, clear the next\\n        cur = Array.from(next);\\n        next = new Set<number>();\\n        ++cnt;\\n    }\\n    \\n    return jompNode[len - 1].minStep;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259634,
                "title": "bfs-explained-commented-easy-to-understand-c",
                "content": "# Complexity\\n- Time complexity:\\n  $$O(n)$$  \\n\\n- Space complexity:\\n $$O(n)$$  \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // total 3 steps \\n        // first -> go backward \\n        // second -> go forward \\n        // third -> remain at same pos and jump to next occurence of that element \\n        //Apply BFS\\n        unordered_map<int,vector<int>>index;\\n         int n = arr.size() , jump=0;\\n         for(int i=0;i<n;i++){\\n             index[arr[i]].push_back(i);\\n         }\\n        //make a visited vector which tells whether the path already visited or not \\n           vector<int>visited(n,0);\\n           queue<int>q; \\n           //initially,at 0 pos thus push 0 in queue \\n           q.push(0);\\n           while(!q.empty()){\\n               int size_to_traverse = q.size();\\n               while(size_to_traverse--){\\n                   int pos = q.front();\\n                   q.pop();\\n                   int backward = pos-1 ; \\n                   int forward = pos+1 ; \\n                   //if at last Pos we have reached destination \\n                   if(pos==n-1) return jump;\\n                   //Step 1 :- go backward if possible and not visited path \\n                   if(backward>=0 && !visited[backward]){\\n                       //push in queue and mark as visited \\n                       q.push(backward);\\n                       visited[backward]=1;\\n                   }\\n                   //Step 2 :- go forward if possible and not visited path \\n                   if(forward<n && !visited[forward]){\\n                       //push in queue and mark as visited \\n                       q.push(forward);\\n                       visited[forward]=1;\\n                   }\\n                    //Step 3 :- remain at same pos and jump to next occurence of that element \\n                    for(auto nextPos : index[arr[pos]]){\\n                        //if not visited path push in queue and mark as visited \\n                     if(!visited[nextPos]){\\n                          q.push(nextPos);  \\n                          visited[nextPos]=1;\\n                     }\\n                    }\\n                //to remove tle after taking a path for a pos don\\'t explore the remaining path \\n                // as already visited[pos] is true and we are doing unnecessary traversal i.e revisiting\\n                index[arr[pos]].clear();\\n               }\\n            jump++;\\n           }\\n           return 0;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // total 3 steps \\n        // first -> go backward \\n        // second -> go forward \\n        // third -> remain at same pos and jump to next occurence of that element \\n        //Apply BFS\\n        unordered_map<int,vector<int>>index;\\n         int n = arr.size() , jump=0;\\n         for(int i=0;i<n;i++){\\n             index[arr[i]].push_back(i);\\n         }\\n        //make a visited vector which tells whether the path already visited or not \\n           vector<int>visited(n,0);\\n           queue<int>q; \\n           //initially,at 0 pos thus push 0 in queue \\n           q.push(0);\\n           while(!q.empty()){\\n               int size_to_traverse = q.size();\\n               while(size_to_traverse--){\\n                   int pos = q.front();\\n                   q.pop();\\n                   int backward = pos-1 ; \\n                   int forward = pos+1 ; \\n                   //if at last Pos we have reached destination \\n                   if(pos==n-1) return jump;\\n                   //Step 1 :- go backward if possible and not visited path \\n                   if(backward>=0 && !visited[backward]){\\n                       //push in queue and mark as visited \\n                       q.push(backward);\\n                       visited[backward]=1;\\n                   }\\n                   //Step 2 :- go forward if possible and not visited path \\n                   if(forward<n && !visited[forward]){\\n                       //push in queue and mark as visited \\n                       q.push(forward);\\n                       visited[forward]=1;\\n                   }\\n                    //Step 3 :- remain at same pos and jump to next occurence of that element \\n                    for(auto nextPos : index[arr[pos]]){\\n                        //if not visited path push in queue and mark as visited \\n                     if(!visited[nextPos]){\\n                          q.push(nextPos);  \\n                          visited[nextPos]=1;\\n                     }\\n                    }\\n                //to remove tle after taking a path for a pos don\\'t explore the remaining path \\n                // as already visited[pos] is true and we are doing unnecessary traversal i.e revisiting\\n                index[arr[pos]].clear();\\n               }\\n            jump++;\\n           }\\n           return 0;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259612,
                "title": "easy-and-fast-golang-solution-with-explanation",
                "content": "# Intuition\\nThe problem can be thought of as a graph problem where each index is a node and there are edges between nodes that can be reached in one step. The goal is to find the shortest path from the first node to the last node.\\n\\n# Approach\\nFirst, we create a graph where each value in the array maps to a list of indices where that value appears. This allows us to quickly find all indices with the same value as the current index.\\n\\nWe then use breadth-first search (BFS) to find the shortest path from the first index to the last index. We start by adding the first index to a queue and marking it as visited. Then we iterate through each level of BFS until we reach the last index.\\n\\nAt each level, we iterate through all nodes in the queue and add their neighbors (indices reachable in one step) to the queue if they haven\\u2019t been visited before. We also mark them as visited.\\n\\nTo optimize this solution further, we delete values from our graph once we have processed all indices with that value. This prevents us from processing these indices again in future levels of BFS.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ since we visit each node once.\\n\\n- Space complexity: $$O(n)$$ since we need to store our graph and visited array.\\n\\n# Code\\n```\\nfunc minJumps(arr []int) int {\\n    n := len(arr)\\n    if n <= 1 {\\n        return 0\\n    }\\n    graph := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        if _, ok := graph[arr[i]]; !ok {\\n            graph[arr[i]] = []int{i}\\n        } else {\\n            graph[arr[i]] = append(graph[arr[i]], i)\\n        }\\n    }\\n    visited := make([]bool, n)\\n    visited[0] = true\\n    queue := []int{0}\\n    step := 0\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr == n-1 {\\n                return step\\n            }\\n            nexts := append(graph[arr[curr]], curr-1)\\n            nexts = append(nexts, curr+1)\\n\\n            for _, next := range nexts {\\n                if next >= 0 && next < n && !visited[next] {\\n                    visited[next] = true\\n                    queue = append(queue, next)\\n                }\\n            }\\n\\n            delete(graph, arr[curr])\\n        }\\n        step++\\n    }\\n\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc minJumps(arr []int) int {\\n    n := len(arr)\\n    if n <= 1 {\\n        return 0\\n    }\\n    graph := make(map[int][]int)\\n    for i := 0; i < n; i++ {\\n        if _, ok := graph[arr[i]]; !ok {\\n            graph[arr[i]] = []int{i}\\n        } else {\\n            graph[arr[i]] = append(graph[arr[i]], i)\\n        }\\n    }\\n    visited := make([]bool, n)\\n    visited[0] = true\\n    queue := []int{0}\\n    step := 0\\n\\n    for len(queue) > 0 {\\n        size := len(queue)\\n        for i := 0; i < size; i++ {\\n            curr := queue[0]\\n            queue = queue[1:]\\n            if curr == n-1 {\\n                return step\\n            }\\n            nexts := append(graph[arr[curr]], curr-1)\\n            nexts = append(nexts, curr+1)\\n\\n            for _, next := range nexts {\\n                if next >= 0 && next < n && !visited[next] {\\n                    visited[next] = true\\n                    queue = append(queue, next)\\n                }\\n            }\\n\\n            delete(graph, arr[curr])\\n        }\\n        step++\\n    }\\n\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259403,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) \\n     {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        int ans=INT_MAX;\\n        queue<pair<pair<int,int>,int>>q;  \\n        q.push({{arr[0],0},0});\\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }  \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            q.pop();\\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            } \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) \\n     {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        int ans=INT_MAX;\\n        queue<pair<pair<int,int>,int>>q;  \\n        q.push({{arr[0],0},0});\\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }  \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            q.pop();\\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            } \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259309,
                "title": "python3-623-ms-faster-than-98-86-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/d5e657e7-ac49-41ee-912e-91677f662469_1678002372.3302972.png)\\n```\\ndef minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1: return 0\\n        dict = collections.defaultdict(list)\\n        for i , n in enumerate(arr): dict[n].append(i)\\n\\n        N = len(arr)        \\n        visited = {0, N - 1}\\n        s1, s2 = {0}, {N - 1}\\n        step = 0\\n        while s1:\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n\\n            s3 = set()\\n            while s1:\\n                i = s1.pop()\\n                for n in [i - 1, i + 1] + dict[arr[i]]:\\n                    if n in s2: return step + 1\\n                    if n in visited: continue\\n                    if not 0 <= n < N: continue\\n                    visited.add(n)\\n                    s3.add(n)\\n                del dict[arr[i]]\\n\\n            s1 = s3\\n            if s1: step = step + 1\\n        return -1\\n```\\nThe given code is for finding the minimum number of jumps required to reach the end of an array of integers, where each integer represents the maximum number of steps that can be taken forward from that position.\\n\\nHere\\'s a stepwise explanation of the code:\\n\\n1. First, check if the length of the given array is 1, then return 0 as there is no need to jump in this case.\\n1. Create a dictionary to store the indices of all the occurrences of each element in the array.\\n1. Initialize two sets s1 and s2 with the starting and ending indices of the array, respectively.\\n1. Initialize a variable step to 0 to keep track of the number of jumps required.\\n1. While s1 is not empty, do the following:\\n\\t1. If the length of s1 is greater than s2, swap them so that s1 always contains the smaller set.\\n\\t1. Create a new set s3 to store the indices that can be reached from s1 in one jump.\\n\\t1. For each index i in s1, do the following:\\n\\t\\t1. For each index j that can be reached from i in one jump (i.e., i-1, i+1, and all the indices in the dictionary that have the same value as arr[i]), do the following:\\n\\t\\t\\t1. If j is in s2, return step+1 as we have reached the end.\\n\\t\\t\\t1.  If j is already visited, skip to the next index.  \\n\\t\\t\\t1. \\tIf j is not within the range of the array, skip to the next index.  \\n\\t\\t\\t1. \\tOtherwise, add j to the set s3 and mark it as visited.  \\n\\t\\t1. \\tRemove the key-value pair corresponding to arr[i] from the dictionary.\\n\\t1. Set s1 to s3 and increment the variable step by 1.\\n1. If we have not returned in the while loop, return -1 as it means that we have not reached the end of the array.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\ndef minJumps(self, arr: List[int]) -> int:\\n        if len(arr) == 1: return 0\\n        dict = collections.defaultdict(list)\\n        for i , n in enumerate(arr): dict[n].append(i)\\n\\n        N = len(arr)        \\n        visited = {0, N - 1}\\n        s1, s2 = {0}, {N - 1}\\n        step = 0\\n        while s1:\\n            if len(s1) > len(s2): s1, s2 = s2, s1\\n\\n            s3 = set()\\n            while s1:\\n                i = s1.pop()\\n                for n in [i - 1, i + 1] + dict[arr[i]]:\\n                    if n in s2: return step + 1\\n                    if n in visited: continue\\n                    if not 0 <= n < N: continue\\n                    visited.add(n)\\n                    s3.add(n)\\n                del dict[arr[i]]\\n\\n            s1 = s3\\n            if s1: step = step + 1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3259262,
                "title": "javascript-with-explanation",
                "content": "# Code\\n```\\nvar minJumps = function(arr) {\\n    const l = arr.length;\\n    const map = new Map();\\n\\n    // Create array of indexes for each value\\n    for (let i=0; i<l; i++){\\n        if (map.has(arr[i])) map.get(arr[i]).push(i)\\n        else map.set(arr[i],[i])\\n    }\\n    \\n    // Each value in indexes have to be check.\\n    // When indexes array in updated, 1 step increased\\n    let indexes = [0], steps = 0;\\n\\n    while (true) {\\n        const newIndexes = [];\\n        \\n        // For each index in indexes\\n        for (let i=0; i<indexes.length; i++) {\\n            const index = indexes[i];\\n\\n            // If we reach to the last index\\n            if (index === l-1) return steps\\n\\n            const num = arr[index]; // Get value from array\\n            arr[index] = null; // Mark as visited\\n\\n// In next 3 cases we are checking i-1, i+1 and same value conditions\\n\\n            // If arr have prev element not visited\\n            if (index-1>0 && arr[index-1]!==null) newIndexes.push(index-1)\\n\\n            // If arr have next element not visited\\n            if (arr[index+1] !== null) newIndexes.push(index + 1)\\n\\n            // If we have any of the similar element in arr not visited\\n            if (map.has(num)) {\\n                map.get(num).forEach(ind => arr[ind]!==null && newIndexes.push(ind))\\n                // This value no longer needed\\n                map.delete(num);\\n            }\\n        }\\n        \\n        // Update indexes array and increse one step\\n        indexes = newIndexes;\\n        steps++;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minJumps = function(arr) {\\n    const l = arr.length;\\n    const map = new Map();\\n\\n    // Create array of indexes for each value\\n    for (let i=0; i<l; i++){\\n        if (map.has(arr[i])) map.get(arr[i]).push(i)\\n        else map.set(arr[i],[i])\\n    }\\n    \\n    // Each value in indexes have to be check.\\n    // When indexes array in updated, 1 step increased\\n    let indexes = [0], steps = 0;\\n\\n    while (true) {\\n        const newIndexes = [];\\n        \\n        // For each index in indexes\\n        for (let i=0; i<indexes.length; i++) {\\n            const index = indexes[i];\\n\\n            // If we reach to the last index\\n            if (index === l-1) return steps\\n\\n            const num = arr[index]; // Get value from array\\n            arr[index] = null; // Mark as visited\\n\\n// In next 3 cases we are checking i-1, i+1 and same value conditions\\n\\n            // If arr have prev element not visited\\n            if (index-1>0 && arr[index-1]!==null) newIndexes.push(index-1)\\n\\n            // If arr have next element not visited\\n            if (arr[index+1] !== null) newIndexes.push(index + 1)\\n\\n            // If we have any of the similar element in arr not visited\\n            if (map.has(num)) {\\n                map.get(num).forEach(ind => arr[ind]!==null && newIndexes.push(ind))\\n                // This value no longer needed\\n                map.delete(num);\\n            }\\n        }\\n        \\n        // Update indexes array and increse one step\\n        indexes = newIndexes;\\n        steps++;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258903,
                "title": "easiest-solution-using-simple-bfs-beats-97-rt-90-mem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We use simple BFS to find out our required path. We just need to select the proper node connections as per given constrints.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> As per question, the nodes, from a selected index i is i-1(if exists), i+1(if exists) and all values j such that i!=j and arr[i]==arr[j]. We create an unordered map to hash all these j indices for every i. We then create a visited array and start our iterative BFS using queue starting from the first index. We get our desired answer as soon as we reach index n-1. We also push appropriate nodes into the queue as mentioned. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ <!-- Add your time complexity here, e.g. $$O(n)$$ --> Although there is a loop inside a loop, but all in all we are visiting every index at most once.\\n\\n- Space complexity: $$O(n)$$ <!-- Add your space complexity here, e.g. $$O(n)$$ --> Extra space is required for hashing,visited array and queue.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size(),jumps[n],ans=0;\\n        unordered_map<int,vector<int>> um;\\n        for(int i=0;i<n;i++) um[arr[i]].push_back(i);\\n        vector<bool> vis(n,0);vis[0]=1;\\n        queue<int> q;q.push(0);\\n        while(!q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                int f=q.front();q.pop();\\n                if(f==n-1) return ans;\\n                if(f+1<n and !vis[f+1]) q.push(f+1),vis[f+1]=1;\\n                if(f>0 and !vis[f-1]) q.push(f-1),vis[f-1]=1;\\n                for(int j:um[arr[f]]) if(!vis[j]) q.push(j),vis[j]=1;\\n                um[arr[f]].clear();\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n>  Please do upvote if it helps",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size(),jumps[n],ans=0;\\n        unordered_map<int,vector<int>> um;\\n        for(int i=0;i<n;i++) um[arr[i]].push_back(i);\\n        vector<bool> vis(n,0);vis[0]=1;\\n        queue<int> q;q.push(0);\\n        while(!q.empty()){\\n            int s=q.size();\\n            while(s--){\\n                int f=q.front();q.pop();\\n                if(f==n-1) return ans;\\n                if(f+1<n and !vis[f+1]) q.push(f+1),vis[f+1]=1;\\n                if(f>0 and !vis[f-1]) q.push(f-1),vis[f-1]=1;\\n                for(int j:um[arr[f]]) if(!vis[j]) q.push(j),vis[j]=1;\\n                um[arr[f]].clear();\\n            }\\n            ans++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257902,
                "title": "c-language",
                "content": "```\\ntypedef struct {\\n    int key;\\n    struct ListNode *ptr;\\n    UT_hash_handle hh;\\n}node;\\ntypedef struct{\\n    int val;\\n    int *next;\\n}ListNode;\\ntypedef struct {\\n    int pos;\\n    int step;\\n}status;\\n\\nint minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }\\n        tp = (struct ListNode*)calloc(1, sizeof(struct ListNode));\\n        tp->val = i;\\n        tp->next = s->ptr;\\n        s->ptr = tp;\\n    } \\n\\n    // initialization\\n    int top = 1, left = 0, pos, val; \\n    obj[0].step = obj[0].pos = 0;\\n    visit[0] = 1;\\n\\n    while (left < top) {\\n        if (obj[left].pos == arrSize-1)//done\\n            break;\\n        \\n        val = arr[obj[left].pos];\\n        HASH_FIND_INT(hash, &val, s);        \\n        if (s) {\\n            tp = s->ptr; \\n            while (tp) {\\n                pos = tp->val;\\n                if (!visit[pos]) {\\n                    visit[pos] = 1;\\n                    obj[top].step = obj[left].step + 1;\\n                    obj[top].pos = pos;\\n                    top++;\\n                } \\n                tp = tp->next;\\n            }\\n            HASH_DEL(hash, s);\\n        }\\n\\n        for (int i = 0; i < 2; i++) {\\n            pos = obj[left].pos + (i ? 1 : -1);\\n            if (pos < 0 || pos >= arrSize)//jump outside\\n                continue;\\n            if (visit[pos])//visited\\n                continue;\\n            obj[top].step = obj[left].step + 1;\\n            obj[top].pos = pos;\\n            visit[pos] = 1;\\n            top++;\\n        }\\n\\n        left++;\\n    }\\n    free(tp);\\n    return obj[left].step; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int key;\\n    struct ListNode *ptr;\\n    UT_hash_handle hh;\\n}node;\\ntypedef struct{\\n    int val;\\n    int *next;\\n}ListNode;\\ntypedef struct {\\n    int pos;\\n    int step;\\n}status;\\n\\nint minJumps(int* arr, int arrSize){\\n\\n    if (arrSize <= 1) return 0;\\n\\n    status obj[arrSize];\\n    int visit[arrSize];\\n    memset(visit, 0, arrSize*sizeof(int));\\n    node *hash = NULL, *s;\\n\\n    struct ListNode *tp;\\n\\n    //add all into hash and linked list\\n    for (int i = 0; i < arrSize; i++) {\\n        HASH_FIND_INT(hash, &arr[i], s);\\n        if (!s) {\\n            s = (node*)calloc(1, sizeof(node));\\n            s->key = arr[i];\\n            HASH_ADD_INT(hash, key, s);\\n        }\\n        tp = (struct ListNode*)calloc(1, sizeof(struct ListNode));\\n        tp->val = i;\\n        tp->next = s->ptr;\\n        s->ptr = tp;\\n    } \\n\\n    // initialization\\n    int top = 1, left = 0, pos, val; \\n    obj[0].step = obj[0].pos = 0;\\n    visit[0] = 1;\\n\\n    while (left < top) {\\n        if (obj[left].pos == arrSize-1)//done\\n            break;\\n        \\n        val = arr[obj[left].pos];\\n        HASH_FIND_INT(hash, &val, s);        \\n        if (s) {\\n            tp = s->ptr; \\n            while (tp) {\\n                pos = tp->val;\\n                if (!visit[pos]) {\\n                    visit[pos] = 1;\\n                    obj[top].step = obj[left].step + 1;\\n                    obj[top].pos = pos;\\n                    top++;\\n                } \\n                tp = tp->next;\\n            }\\n            HASH_DEL(hash, s);\\n        }\\n\\n        for (int i = 0; i < 2; i++) {\\n            pos = obj[left].pos + (i ? 1 : -1);\\n            if (pos < 0 || pos >= arrSize)//jump outside\\n                continue;\\n            if (visit[pos])//visited\\n                continue;\\n            obj[top].step = obj[left].step + 1;\\n            obj[top].pos = pos;\\n            visit[pos] = 1;\\n            top++;\\n        }\\n\\n        left++;\\n    }\\n    free(tp);\\n    return obj[left].step; \\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257872,
                "title": "291-ms",
                "content": "```ruby\\ndef min_jumps a\\n    return 0 if (t = a.size - 1) < 1\\n    g = a.each_index.group_by { a[_1] }\\n    s, q, v = 0, [0], [false] * t\\n    v[0] = true\\n    loop do\\n        (s += 1; q.size).times do\\n            i = q.shift\\n            c = (g[a[i]] || []) << i + 1\\n            g.delete a[i]\\n            c << i - 1 if i > 0\\n            c.each do | x |\\n                return s if x == t\\n                next if v[x]\\n                v[x] = true\\n                q << x\\n            end\\n        end\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef min_jumps a\\n    return 0 if (t = a.size - 1) < 1\\n    g = a.each_index.group_by { a[_1] }\\n    s, q, v = 0, [0], [false] * t\\n    v[0] = true\\n    loop do\\n        (s += 1; q.size).times do\\n            i = q.shift\\n            c = (g[a[i]] || []) << i + 1\\n            g.delete a[i]\\n            c << i - 1 if i > 0\\n            c.each do | x |\\n                return s if x == t\\n                next if v[x]\\n                v[x] = true\\n                q << x\\n            end\\n        end\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3257723,
                "title": "daily-leetcoding-challenge-march-day-5",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2260356,
                "title": "bfs-c-o-n-solution",
                "content": "```\\n//BFS Solution because DFS stucks in a loop\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                if(x==arr.size()-1)return steps;\\n                q.pop();\\n                if(x-1>=0)\\n                {\\n                    if(mp.find(arr[x-1])!=mp.end())\\n                    {\\n                        q.push(x-1);\\n                    }\\n                        \\n                }\\n                if(x+1<arr.size())\\n                {\\n                    if(mp.find(arr[x+1])!=mp.end())\\n                    {\\n                        q.push(x+1);\\n                    }                        \\n                }\\n                for(auto i:mp[arr[x]])\\n                {\\n                    if(mp.find(arr[i])!=mp.end()&&i!=x)\\n                    {\\n                        q.push(i);\\n                    }\\n                }\\n                mp.erase(arr[x]);\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n//BFS Solution because DFS stucks in a loop\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            while(n--)\\n            {\\n                int x=q.front();\\n                if(x==arr.size()-1)return steps;\\n                q.pop();\\n                if(x-1>=0)\\n                {\\n                    if(mp.find(arr[x-1])!=mp.end())\\n                    {\\n                        q.push(x-1);\\n                    }\\n                        \\n                }\\n                if(x+1<arr.size())\\n                {\\n                    if(mp.find(arr[x+1])!=mp.end())\\n                    {\\n                        q.push(x+1);\\n                    }                        \\n                }\\n                for(auto i:mp[arr[x]])\\n                {\\n                    if(mp.find(arr[i])!=mp.end()&&i!=x)\\n                    {\\n                        q.push(i);\\n                    }\\n                }\\n                mp.erase(arr[x]);\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2183694,
                "title": "easy-c-bfs-solution-good-comments",
                "content": "A BFS Solution in C++ with comments\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        // Map to store All the indices where value is present\\n        map < int, vector<int> > allIndices;;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            allIndices[arr[i]].push_back(i);\\n        }\\n          \\n        queue<int> Q;\\n        // Vector to check we only travel indice strictly once\\n        vector<bool> alreadyTravelled(arr.size(), false);\\n        \\n        Q.push(0);\\n        alreadyTravelled[0] = true;\\n        int step = 0, Qcount, currentIndex, n = arr.size();\\n        \\n        // To store the value of map locally \\n        vector<int> a;\\n        \\n        // Our BFS solution Starts Here\\n        // if we reach indice \"n-1\" we have completed our BFS\\n        while(!alreadyTravelled[n-1])\\n        {\\n            Qcount = Q.size();\\n            \\n            // Iterate all Q element one by one at each step\\n            for(int i=0;i<Qcount;i++)\\n            {\\n                currentIndex = Q.front();\\n                Q.pop();\\n                \\n                // checking the left indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex-1 >0 && !alreadyTravelled[currentIndex-1])\\n                {\\n                    Q.push(currentIndex-1);\\n                    alreadyTravelled[currentIndex-1] = true;\\n                }\\n                \\n                // checking the right indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex+1 <n && !alreadyTravelled[currentIndex+1])\\n                {\\n                    Q.push(currentIndex+1);\\n                    alreadyTravelled[currentIndex+1] = true;\\n                }\\n                \\n                // fetching vector of current Index Value from map\\n                a = allIndices[arr[currentIndex]];\\n                \\n                // if value is present we will have non empty vector\\n                if(!a.empty())\\n                {   \\n                    // iterate each vector item\\n                    for(int k=0;k< a.size(); k++)\\n                    {\\n                        // pushing all other indices except current into Q\\n                        if(a[k] != currentIndex)\\n                        {\\n                            Q.push(a[k]);\\n                            alreadyTravelled[a[k]] = true;\\n                        }\\n                    }\\n                    \\n                    // erasing the map for currentIndex value \\n                    // this will help in not causing infinite loops\\n                    // Eg: {0,1,2} - indices for some value at index 0\\n                    // we will insert {1, 2} in the Q\\n                    // not erasing the map will insert \"0\" again when checking map for \"1\"\\n                    allIndices.erase(arr[currentIndex]);\\n                }\\n                a.clear(); // Clearing the vector for further use   \\n            }\\n            step++; // A BFS step counter\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        \\n        // Map to store All the indices where value is present\\n        map < int, vector<int> > allIndices;;\\n        \\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            allIndices[arr[i]].push_back(i);\\n        }\\n          \\n        queue<int> Q;\\n        // Vector to check we only travel indice strictly once\\n        vector<bool> alreadyTravelled(arr.size(), false);\\n        \\n        Q.push(0);\\n        alreadyTravelled[0] = true;\\n        int step = 0, Qcount, currentIndex, n = arr.size();\\n        \\n        // To store the value of map locally \\n        vector<int> a;\\n        \\n        // Our BFS solution Starts Here\\n        // if we reach indice \"n-1\" we have completed our BFS\\n        while(!alreadyTravelled[n-1])\\n        {\\n            Qcount = Q.size();\\n            \\n            // Iterate all Q element one by one at each step\\n            for(int i=0;i<Qcount;i++)\\n            {\\n                currentIndex = Q.front();\\n                Q.pop();\\n                \\n                // checking the left indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex-1 >0 && !alreadyTravelled[currentIndex-1])\\n                {\\n                    Q.push(currentIndex-1);\\n                    alreadyTravelled[currentIndex-1] = true;\\n                }\\n                \\n                // checking the right indice if alreadt travelled or not\\n                // and inserting into Q\\n                if(currentIndex+1 <n && !alreadyTravelled[currentIndex+1])\\n                {\\n                    Q.push(currentIndex+1);\\n                    alreadyTravelled[currentIndex+1] = true;\\n                }\\n                \\n                // fetching vector of current Index Value from map\\n                a = allIndices[arr[currentIndex]];\\n                \\n                // if value is present we will have non empty vector\\n                if(!a.empty())\\n                {   \\n                    // iterate each vector item\\n                    for(int k=0;k< a.size(); k++)\\n                    {\\n                        // pushing all other indices except current into Q\\n                        if(a[k] != currentIndex)\\n                        {\\n                            Q.push(a[k]);\\n                            alreadyTravelled[a[k]] = true;\\n                        }\\n                    }\\n                    \\n                    // erasing the map for currentIndex value \\n                    // this will help in not causing infinite loops\\n                    // Eg: {0,1,2} - indices for some value at index 0\\n                    // we will insert {1, 2} in the Q\\n                    // not erasing the map will insert \"0\" again when checking map for \"1\"\\n                    allIndices.erase(arr[currentIndex]);\\n                }\\n                a.clear(); // Clearing the vector for further use   \\n            }\\n            step++; // A BFS step counter\\n        }\\n        \\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702543,
                "title": "bfs-javascript-solution-o-n-explanation",
                "content": "The intuition is that we go from the 0th position and queue all the possible paths (which counts as one step) and then queue all of it\\'s path\\'s (second step) so on and so forth until we reach the destination (the last index or length of array - 1)\\n\\nThis is sounding a lot like Breadth First Search (BFS).  We can use a queue for this implementation.\\n\\nFrom any \"node\" we can calculate the neighboring nodes as such:\\n\\n1. i - 1 (one step backwards)\\n2. i + 2 (one step forwards)\\n3. any node that is the same value\\n\\nNow 1 and 2 seem pretty easy to do, however 3 seems like it would require some work up front because it would be less optimal to find all the occurence of a value as we are traversing this graph (and possibly giving it an exponential run-time).\\n\\nBecause of this, we\\'ll first iterate through the array and create a map that will allow us to get an array of all indexes for a given value.\\n\\nSo for a given array as such:\\n\\n```\\n[100,-23,-23,404,100,23,23,23,3,404]\\n```\\n\\nWe\\'ll have a map like so:\\n```\\n{\\n  \\'3\\': [ 8 ],\\n  \\'23\\': [ 5, 6, 7 ],\\n  \\'100\\': [ 0, 4 ],\\n  \\'404\\': [ 3, 9 ],\\n  \\'-23\\': [ 1, 2 ]\\n}\\n```\\n\\nWe\\'ll start by initializing our queue with the 0th index.  We\\'ll then push any valid neighbors onto the queue (for number `1` & `2` check if values exist AND exists on the map (or else we traversed it already).\\n\\nAs we traverse through the graph, it\\'s important that we delete the key of this map.  Because otherwise we might run into TLE.  And if you think about it logically, when you come across a specific value, we\\'re able to calculate all the nodes of that value at once so there\\'s no need to calculate it again.\\n\\nThe calculation we do for every neighboring node is considered one step so after we iterate through the entirety of the queue, we increment steps or jumps (is what I called it).  So with every jump, we\\'re emptying out the queue and pushing onto it.\\n\\nBecause I increment jump before doing the traversal, it\\'s important for this implementation to check if the nodes i\\'m pushing onto the queue is the final destination so I can return it.  This is the reason for such code:  ```if (curr + 1 === arr.length - 1) return jumps```\\n\\nNotice that I did not do this check when calculating ```i - 1 ``` because it\\'s impossible for us to visit the previos node and have it be the destination :).\\n\\nJavascript Implementation:\\n\\n```\\n\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    \\n    if (arr.length === 1) return 0\\n    \\n    let map = {};\\n    \\n    for (let i = 0; i < arr.length; i++){\\n        if (map[arr[i]]){\\n            map[arr[i]].push(i);\\n        } else {\\n            map[arr[i]] = [i];\\n        }\\n    }\\n    \\n    let jumps = 0;\\n    \\n    let q = [0];\\n    while (q.length != 0){\\n                \\n        jumps++;\\n        \\n        let clone = [...q];\\n        q = [];\\n        \\n        for (let i = 0 ; i < clone.length; i++){\\n            let curr = clone[i];\\n            \\n            if (arr[curr - 1] != undefined && map[arr[curr - 1]]) q.push(curr - 1);\\n            if (arr[curr + 1] != undefined && map[arr[curr + 1]]) {\\n                if (curr + 1 === arr.length - 1) return jumps\\n                q.push(curr + 1);\\n            }\\n            \\n            if (map[arr[curr]]){\\n                for (let j = 0; j < map[arr[curr]].length; j++){\\n                    if (map[arr[curr]][j] === arr.length - 1) return jumps\\n                }\\n                q = [...q, ...map[arr[curr]].filter((x) => x != curr)];\\n            }\\n            \\n            delete map[arr[curr]];\\n        }\\n    }\\n    \\n    return jumps;\\n};\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n[100,-23,-23,404,100,23,23,23,3,404]\\n```\n```\\n{\\n  \\'3\\': [ 8 ],\\n  \\'23\\': [ 5, 6, 7 ],\\n  \\'100\\': [ 0, 4 ],\\n  \\'404\\': [ 3, 9 ],\\n  \\'-23\\': [ 1, 2 ]\\n}\\n```\n```if (curr + 1 === arr.length - 1) return jumps```\n```i - 1 ```\n```\\n\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    \\n    if (arr.length === 1) return 0\\n    \\n    let map = {};\\n    \\n    for (let i = 0; i < arr.length; i++){\\n        if (map[arr[i]]){\\n            map[arr[i]].push(i);\\n        } else {\\n            map[arr[i]] = [i];\\n        }\\n    }\\n    \\n    let jumps = 0;\\n    \\n    let q = [0];\\n    while (q.length != 0){\\n                \\n        jumps++;\\n        \\n        let clone = [...q];\\n        q = [];\\n        \\n        for (let i = 0 ; i < clone.length; i++){\\n            let curr = clone[i];\\n            \\n            if (arr[curr - 1] != undefined && map[arr[curr - 1]]) q.push(curr - 1);\\n            if (arr[curr + 1] != undefined && map[arr[curr + 1]]) {\\n                if (curr + 1 === arr.length - 1) return jumps\\n                q.push(curr + 1);\\n            }\\n            \\n            if (map[arr[curr]]){\\n                for (let j = 0; j < map[arr[curr]].length; j++){\\n                    if (map[arr[curr]][j] === arr.length - 1) return jumps\\n                }\\n                q = [...q, ...map[arr[curr]].filter((x) => x != curr)];\\n            }\\n            \\n            delete map[arr[curr]];\\n        }\\n    }\\n    \\n    return jumps;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692762,
                "title": "c-simple-bfs-vs-double-ended-bfs-solutions-explained-100-time-60-space",
                "content": "This problem is oddly a hard, but all it takes it is just to recognise we have a graph to navigate from a starting point (the first element of `arr`) to an ending one (the last node of `arr`), following rules; and usually when we need to compute how many steps it takes to come out of a graph, a BFS approach is a solid one!\\n\\nTo do so, we will first rule an edge case that would make any further effort pointless (when the array has `1` or `2` elements, the result is trivially the `arr.size() - 1`, no way to do less steps than that) and then declare a few support variables:\\n* `res` will store the current number of \"steps\" we have made so far (ie: how many BFS outer loop iterations we have ground to this point);\\n* `len` will store the length of the the original input;\\n* `qLen` will store the length of our `q`, initially set to `1`, since we will always have a sole starting point;\\n* `curr`, `prev` and `nxt` will be used in our inner BFS loop to keep track of what node we are currently processing and its neighbours;\\n* `target` stores our final destination, initialised with the value of the last element of `arr`;\\n* `connected` is an array showing us how similarly valued nodes are linked, forming the backbone of our graph traversal logic later;\\n* `unexplored` will keep track of the nodes we must still visit;\\n* `mustContinue` is a microoptimisation to let us know when we are in the last or penultimate cycle of our BFS search, initially set to `true`;\\n* `q` is the queue that will store the current and next level of our traversal, as in most standard BFS approaches - initially set to contain only the first node (our starting point).\\n\\nWe will then initialise all the values in `unexplored` to be `true` and populate `connected` so that each value of `arr` (key) will tell use what nodes share it and are thus linked (value).\\n\\nOkay, time for the main course, our BFS loops!\\n\\nWe  will have a main loop that will as long as we have a reason to go on (ie: `mustContinue != false`) and in it we will:\\n* run our level traversal, valid as long as `qLen-- != 0`, that is to say it will run `qLen` times and:\\n\\t* extract the current front of `q` and assign its value to `curr`;\\n\\t* pop that element out of the queue;\\n\\t* check if we reached our target, in which case we can just stop here and `return` `res`;\\n\\t* check if we will reach it on the next run (ie: `arr[curr] == target`, meaning we are on a cell that can teleport us to destination), in which case we do not quit immediately (we might have in the queue some node which is ALREADY the destination, so one less step!), but flag this situation turning `mustContinue` to `false`;\\n\\t* in case `mustContinue` is still `true`, we will then:\\n\\t\\t* flag the current node as explored;\\n\\t\\t* check the previous node `prev = curr - 1`, assuming it was not explored already or out of bonds, adding it to the queue;\\n\\t\\t* check the next node `nxt = curr - 1`, assuming it was not explored already or out of bonds, adding it to the queue;\\n\\t\\t* check all the connected nodes (if any) adding them to the queue (we know they were all not explored yet, since once you explore one of the connected ones, you get them all) and then removing that subnetwork from `connected`, in order to avoid parsing it again;\\n* prepare for the next iteration, increasing `res` by `1` and updating `qLen` with its new value.\\n\\nFinally, if we reached the end of the loop, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = 0, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool unexplored[len], mustContinue = true;\\n        queue<int> q{{0}};\\n        // preparing unexplored and connected\\n        fill(unexplored, unexplored + len--, true);\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (mustContinue) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = q.front();\\n                q.pop();\\n                if (curr == len) return res;\\n                // checking if we will go there in the next step\\n                if (arr[curr] == target) mustContinue = false;\\n                // the rest of the logic matters only if we know we have to proceed\\n                if (mustContinue) {\\n                    // marking curr as unexplored\\n                    unexplored[curr] = false;\\n                    // checking before curr\\n                    prev = curr - 1;\\n                    if (prev >= 0 && unexplored[prev]) q.push(prev);\\n                    // checking after curr\\n                    nxt = curr + 1;\\n                    if (nxt <= len && unexplored[nxt]) q.push(nxt);\\n                    // checking the connected ones if any and clearing that subnetwork\\n                    for (int conn: connected[arr[curr]]) q.push(conn);\\n                    connected[arr[curr]].clear();\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\\nCan we do better?\\n\\nWell, yes, burning a bit more memory for the `explored` boolean maps, so that we have now `2` of them (and `2` queues, but that would actually use less memory overall) to run the same logic, but as a double ended BFS.\\n\\nThis alternative is much faster on average and the extra memory consumption is overall moderate:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = -1, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool *currExplored = new bool[len], *nextExplored = new bool[len];\\n        queue<int> currQ{{0}}, nextQ{{len - 1}};\\n        // preparing unexplored and connected\\n        fill(currExplored + 1, currExplored + len, false);\\n        fill(nextExplored, nextExplored + --len, false);\\n        currExplored[0] = true;\\n        nextExplored[len] = true;\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (qLen) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = currQ.front();\\n                currQ.pop();\\n                if (nextExplored[curr]) return res;\\n                // marking curr as unexplored\\n                currExplored[curr] = true;\\n                // checking before curr\\n                prev = curr - 1;\\n                if (prev >= 0 && !currExplored[prev]) currQ.push(prev);\\n                // checking after curr\\n                nxt = curr + 1;\\n                if (nxt <= len && !currExplored[nxt]) currQ.push(nxt);\\n                // checking the connected ones if any and clearing that subnetwork\\n                for (int conn: connected[arr[curr]]) currQ.push(conn);\\n                connected[arr[curr]].clear();\\n\\t\\t\\t}\\n\\t\\t\\t// preparing for the next loop\\n\\t\\t\\tres++;\\n\\t\\t\\tqLen = nextQ.size();\\n\\t\\t\\tswap(currQ, nextQ);\\n            swap(currExplored, nextExplored);\\n\\t\\t\\t// swap(currExplored, nextExplored);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = 0, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool unexplored[len], mustContinue = true;\\n        queue<int> q{{0}};\\n        // preparing unexplored and connected\\n        fill(unexplored, unexplored + len--, true);\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (mustContinue) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = q.front();\\n                q.pop();\\n                if (curr == len) return res;\\n                // checking if we will go there in the next step\\n                if (arr[curr] == target) mustContinue = false;\\n                // the rest of the logic matters only if we know we have to proceed\\n                if (mustContinue) {\\n                    // marking curr as unexplored\\n                    unexplored[curr] = false;\\n                    // checking before curr\\n                    prev = curr - 1;\\n                    if (prev >= 0 && unexplored[prev]) q.push(prev);\\n                    // checking after curr\\n                    nxt = curr + 1;\\n                    if (nxt <= len && unexplored[nxt]) q.push(nxt);\\n                    // checking the connected ones if any and clearing that subnetwork\\n                    for (int conn: connected[arr[curr]]) q.push(conn);\\n                    connected[arr[curr]].clear();\\n                }\\n            }\\n            // preparing for the next loop\\n            res++;\\n            qLen = q.size();\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        // edge cases\\n        if (arr.size() < 3) return arr.size() - 1;\\n        // support variables\\n        int res = -1, len = arr.size(), qLen = 1, curr, prev, nxt, target = arr.back();\\n        unordered_map<int, vector<int>> connected;\\n        bool *currExplored = new bool[len], *nextExplored = new bool[len];\\n        queue<int> currQ{{0}}, nextQ{{len - 1}};\\n        // preparing unexplored and connected\\n        fill(currExplored + 1, currExplored + len, false);\\n        fill(nextExplored, nextExplored + --len, false);\\n        currExplored[0] = true;\\n        nextExplored[len] = true;\\n        for (int i = 0; i <= len; i++) connected[arr[i]].push_back(i);\\n\\t\\t// BFS time!\\n        while (qLen) {\\n\\t\\t\\t// level traversal\\n            while (qLen--) {\\n                // extracting the current front from the q and checking if we arrived\\n                curr = currQ.front();\\n                currQ.pop();\\n                if (nextExplored[curr]) return res;\\n                // marking curr as unexplored\\n                currExplored[curr] = true;\\n                // checking before curr\\n                prev = curr - 1;\\n                if (prev >= 0 && !currExplored[prev]) currQ.push(prev);\\n                // checking after curr\\n                nxt = curr + 1;\\n                if (nxt <= len && !currExplored[nxt]) currQ.push(nxt);\\n                // checking the connected ones if any and clearing that subnetwork\\n                for (int conn: connected[arr[curr]]) currQ.push(conn);\\n                connected[arr[curr]].clear();\\n\\t\\t\\t}\\n\\t\\t\\t// preparing for the next loop\\n\\t\\t\\tres++;\\n\\t\\t\\tqLen = nextQ.size();\\n\\t\\t\\tswap(currQ, nextQ);\\n            swap(currExplored, nextExplored);\\n\\t\\t\\t// swap(currExplored, nextExplored);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692424,
                "title": "ruby-adjacency-list-bfs-by-layers-clear-list-element",
                "content": "## Leetcode: 1345. Jump Game IV.\\n\\n\\n**Ruby: Adjacency List, BFS by layers, clear Liset element.**\\n\\n- Create a weird Adjacency List, where are values of the array are nodes as well. For each value add a set of indices.\\n- Implement BFS by layers. Where on each iteration new array for a layer is created.\\n- And a most important thing! After adding to layer all elements from the value of a weird Adjacency list, clear it! This is the only way to escape from LTS.\\n\\nBased on the [described problem solution](https://leetcode.com/problems/jump-game-iv/solution/). Really appreciate it.\\n  \\nRuby code:\\n```Ruby\\n# Leetcode: 1345. Jump Game IV.\\n# https://leetcode.com/problems/jump-game-iv/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# Runtime: 710 ms, faster than 100.00% of Ruby online submissions for Jump Game IV.\\n# Memory Usage: 227.2 MB, less than 100.00% of Ruby online submissions for Jump Game IV.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef min_jumps(arr)\\n  @d = false\\n  puts \"input: #{arr}\" if @d\\n  last_index = arr.size - 1\\n  return 0 if arr.size <= 1\\n  graph = {}\\n  arr.each_with_index do |value,index|\\n    graph[value] ||= []\\n    graph[value].push(index)\\n  end\\n  puts \"graph: #{graph.inspect}\" if @d\\n  layer = [0]\\n  used = {}\\n  used[0] = true\\n  step = 0\\n  while ! layer.empty?\\n    nxt = []\\n    layer.each do |i|\\n      puts  \"i: #{i}\" if @d\\n      return step if last_index == i\\n      [i+1,i-1].each do |j|\\n        if j.between?(0,last_index) && (!used[j])\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      puts \"i=#{i}, arr[i] = #{arr[i]}\" if @d\\n      graph[arr[i]].each do |j|\\n        if ! used[j]\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      # Most important line!\\n      graph[arr[i]].clear()\\n    end\\n    puts \"step #{step}: #{nxt.inspect}\" if @d\\n    step += 1\\n    layer = nxt\\n  end\\n  raise \"Must return in the BFS list.\"\\nend\\n```\\n",
                "solutionTags": [
                    "Ruby",
                    "Breadth-First Search"
                ],
                "code": "```Ruby\\n# Leetcode: 1345. Jump Game IV.\\n# https://leetcode.com/problems/jump-game-iv/\\n# = = = = = = =\\n# Accepted.\\n# Thanks God!\\n# = = = = = = =\\n# Runtime: 710 ms, faster than 100.00% of Ruby online submissions for Jump Game IV.\\n# Memory Usage: 227.2 MB, less than 100.00% of Ruby online submissions for Jump Game IV.\\n# @param {Integer[]} arr\\n# @return {Integer}\\ndef min_jumps(arr)\\n  @d = false\\n  puts \"input: #{arr}\" if @d\\n  last_index = arr.size - 1\\n  return 0 if arr.size <= 1\\n  graph = {}\\n  arr.each_with_index do |value,index|\\n    graph[value] ||= []\\n    graph[value].push(index)\\n  end\\n  puts \"graph: #{graph.inspect}\" if @d\\n  layer = [0]\\n  used = {}\\n  used[0] = true\\n  step = 0\\n  while ! layer.empty?\\n    nxt = []\\n    layer.each do |i|\\n      puts  \"i: #{i}\" if @d\\n      return step if last_index == i\\n      [i+1,i-1].each do |j|\\n        if j.between?(0,last_index) && (!used[j])\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      puts \"i=#{i}, arr[i] = #{arr[i]}\" if @d\\n      graph[arr[i]].each do |j|\\n        if ! used[j]\\n          used[j] = true\\n          nxt.push(j)\\n        end\\n      end\\n      # Most important line!\\n      graph[arr[i]].clear()\\n    end\\n    puts \"step #{step}: #{nxt.inspect}\" if @d\\n    step += 1\\n    layer = nxt\\n  end\\n  raise \"Must return in the BFS list.\"\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1692116,
                "title": "can-someone-explain-what-is-wrong-with-dp-failing-for-few-test-cases",
                "content": "The idea is, put all the duplicate values in the map for the condition III and keep checking the min value. \\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(map.containsKey(arr[i])) {        \\n                 map.get(arr[i]).add(i);\\n                continue;\\n            }\\n            map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        } \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n - 1] = 0;\\n        for(int i = n - 1; i >= 0; i-- ) {\\n            if(i - 1 >= 0 && dp[i - 1] != Integer.MAX_VALUE){\\n                dp[i] =  Math.min(dp[i - 1] + 1 ,  dp[i]);\\n            }\\n            if(i + 1 < n && dp[i + 1] != Integer.MAX_VALUE) {\\n                dp[i] =  Math.min(dp[i + 1] + 1,  dp[i]);\\n            }\\n            int key = arr[i];\\n           \\n            if(map.containsKey(key)) {  \\n                for(int k: map.get(key)) {\\n                    if(k != i ) {\\n                        dp[k] = Math.min(dp[i] + 1, dp[k]);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        Map<Integer, ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            if(map.containsKey(arr[i])) {        \\n                 map.get(arr[i]).add(i);\\n                continue;\\n            }\\n            map.put(arr[i], new ArrayList<>());\\n            map.get(arr[i]).add(i);\\n        } \\n        int[] dp = new int[n];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n - 1] = 0;\\n        for(int i = n - 1; i >= 0; i-- ) {\\n            if(i - 1 >= 0 && dp[i - 1] != Integer.MAX_VALUE){\\n                dp[i] =  Math.min(dp[i - 1] + 1 ,  dp[i]);\\n            }\\n            if(i + 1 < n && dp[i + 1] != Integer.MAX_VALUE) {\\n                dp[i] =  Math.min(dp[i + 1] + 1,  dp[i]);\\n            }\\n            int key = arr[i];\\n           \\n            if(map.containsKey(key)) {  \\n                for(int k: map.get(key)) {\\n                    if(k != i ) {\\n                        dp[k] = Math.min(dp[i] + 1, dp[k]);\\n                    }\\n                    \\n                }\\n            }\\n\\n        }\\n        \\n        return dp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1691025,
                "title": "javascript-efficient-bfs",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let visited={},queue=[],node,map={},index,jumps,neighbour;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]] = [];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    //console.log(map)\\n    visited[0]=true;\\n    queue.push([0,0]);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        index = node[0];\\n        jumps = node[1];\\n        if(index===arr.length-1){\\n            return jumps;\\n        }\\n        if(map[arr[index]]!==undefined){\\n            for(let i=0;i<map[arr[index]].length;i++){\\n                neighbour = map[arr[index]][i];\\n                if(visited[neighbour]===undefined){\\n                    visited[neighbour] = true;\\n                    queue.push([neighbour,jumps+1]);\\n                }\\n            }\\n        }\\n        //***IMPORTANT remove this key from map to prevent redundant searches, otherwise we will get Time Limit Exceeded error\\n        delete map[arr[index]];\\n        neighbour = index+1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n        neighbour = index-1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {number}\\n */\\nvar minJumps = function(arr) {\\n    let visited={},queue=[],node,map={},index,jumps,neighbour;\\n    for(let i=0;i<arr.length;i++){\\n        if(map[arr[i]]===undefined){\\n            map[arr[i]] = [];\\n        }\\n        map[arr[i]].push(i);\\n    }\\n    //console.log(map)\\n    visited[0]=true;\\n    queue.push([0,0]);\\n    while(queue[0]!==undefined){\\n        node = queue.shift();\\n        index = node[0];\\n        jumps = node[1];\\n        if(index===arr.length-1){\\n            return jumps;\\n        }\\n        if(map[arr[index]]!==undefined){\\n            for(let i=0;i<map[arr[index]].length;i++){\\n                neighbour = map[arr[index]][i];\\n                if(visited[neighbour]===undefined){\\n                    visited[neighbour] = true;\\n                    queue.push([neighbour,jumps+1]);\\n                }\\n            }\\n        }\\n        //***IMPORTANT remove this key from map to prevent redundant searches, otherwise we will get Time Limit Exceeded error\\n        delete map[arr[index]];\\n        neighbour = index+1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n        neighbour = index-1;\\n        if(neighbour>=0 && neighbour<=arr.length-1){\\n            if(visited[neighbour]===undefined){\\n                visited[neighbour] = true;\\n                queue.push([neighbour,jumps+1]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1690887,
                "title": "java-bfs-with-explanations",
                "content": "**Idea**: \\n\\n- Use a Map to group all the indexes with the same value together.\\n\\n- Set `arr[i]` to `INT_MAX` to mark as visited\\n- Use BFS to find the shortest Path.\\n\\n- When we add all the indexes with a certain value into the BFS queue, make sure to either clear the whole list or use a set so we skip them next time. This prevents them from getting added again, which will result in TLE.\\n\\nI commented out the code that uses set, but it is worth noting that calling .clear() is twice slower than using a set to track according to LeetCode Submission Runtime (90ms for Set, 162ms for .clear()).\\n```Java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++)\\n            map.computeIfAbsent(arr[i], o -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> queue = new ArrayDeque<>(List.of(0));\\n        // Set<Integer> seen = new HashSet<>();\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            while(--sz >= 0){\\n                int cur = queue.poll(), tmp = arr[cur];\\n                if (!ok(arr, cur)) continue;\\n                if (cur == arr.length - 1) return ans;\\n                arr[cur] = Integer.MAX_VALUE;\\n                if (ok(arr, cur - 1)) queue.offer(cur - 1);\\n                if (ok(arr, cur + 1)) queue.offer(cur + 1);\\n                // if (seen.contains(tmp)) continue;\\n                for (int next : map.getOrDefault(tmp, Collections.emptyList()))\\n                    if (ok(arr, next))\\n                        queue.offer(next);\\n                map.get(tmp).clear();\\n                // seen.add(tmp);\\n            }\\n\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean ok(int[] arr, int idx){\\n        return idx >= 0 && idx < arr.length && arr[idx] != Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++)\\n            map.computeIfAbsent(arr[i], o -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> queue = new ArrayDeque<>(List.of(0));\\n        // Set<Integer> seen = new HashSet<>();\\n        int ans = 0;\\n        while(!queue.isEmpty()){\\n            int sz = queue.size();\\n            while(--sz >= 0){\\n                int cur = queue.poll(), tmp = arr[cur];\\n                if (!ok(arr, cur)) continue;\\n                if (cur == arr.length - 1) return ans;\\n                arr[cur] = Integer.MAX_VALUE;\\n                if (ok(arr, cur - 1)) queue.offer(cur - 1);\\n                if (ok(arr, cur + 1)) queue.offer(cur + 1);\\n                // if (seen.contains(tmp)) continue;\\n                for (int next : map.getOrDefault(tmp, Collections.emptyList()))\\n                    if (ok(arr, next))\\n                        queue.offer(next);\\n                map.get(tmp).clear();\\n                // seen.add(tmp);\\n            }\\n\\n            ans++;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private boolean ok(int[] arr, int idx){\\n        return idx >= 0 && idx < arr.length && arr[idx] != Integer.MAX_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690774,
                "title": "python3-bfs-memory-limit-solution",
                "content": "This was hard. The idea of the algorithm is simple. We need a minimum path to the n-1 node. BFS is a simple algorithm to reach the minimum path with edges of weight 1.\\n\\nEach node will have as adjacents the node+1, node-1, and all the nodes with the same value. To speed up the algorithm, we need to first calculate the nodes with the same value and store them in a dictionary.\\n\\nThe problem was a test that has a lot of elements 7,7,7,7,7 where we can get a memory limit. The solution is to delete the entry on the dictionary for the key = node. Line:\\n`\\nsame_value[arr[node]].clear()\\n`\\n\\nI recall that BFS is O(V+E) being V the number of nodes and E number of edges. The number of edges could be bigger than N (and it fact it is). The node 1 in example, is related to node 0 and 2 at least. If the node 1 has another node with the same value, the number of edges is going to be even bigger. So, I would state O(E) worst case being E the number of links due to E > N in this problem.\\n\\nThe other trick I\\'ve used is to keep the level in the same stack. So, I can return the length of the path directly from there.\\n\\nHere is the code:\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        visited = set()\\n        \\n        \\n        if n <= 1:\\n            return 0\\n        \\n        same_value = dict()\\n        \\n        for i, v in enumerate(arr):\\n            if v not in same_value.keys():\\n                same_value[v]= [i]\\n            else:\\n                same_value[v].append(i)\\n                \\n        stack = list()\\n        level = 0\\n        \\n        stack.append((0,0))\\n        total = -1\\n        \\n        \\n        while stack:\\n            level,node = stack.pop(0)\\n        \\n            visited.add(node)\\n            \\n            if node == n-1:\\n                return level\\n            else:\\n                for a in same_value[arr[node]] :\\n                    if a != node and a not in visited:\\n                        stack.append((level+1,a))\\n                \\n                same_value[arr[node]].clear()\\n                \\n                if node+1 < n and node+1 not in visited:\\n                    stack.append((level+1,node+1))\\n                 \\n                if node-1 >=0 and node-1 not in visited:\\n                    stack.append((level+1,node-1))\\n                    \\n\\n                                 \\n        return level\\n                    \\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        n = len(arr)\\n        visited = set()\\n        \\n        \\n        if n <= 1:\\n            return 0\\n        \\n        same_value = dict()\\n        \\n        for i, v in enumerate(arr):\\n            if v not in same_value.keys():\\n                same_value[v]= [i]\\n            else:\\n                same_value[v].append(i)\\n                \\n        stack = list()\\n        level = 0\\n        \\n        stack.append((0,0))\\n        total = -1\\n        \\n        \\n        while stack:\\n            level,node = stack.pop(0)\\n        \\n            visited.add(node)\\n            \\n            if node == n-1:\\n                return level\\n            else:\\n                for a in same_value[arr[node]] :\\n                    if a != node and a not in visited:\\n                        stack.append((level+1,a))\\n                \\n                same_value[arr[node]].clear()\\n                \\n                if node+1 < n and node+1 not in visited:\\n                    stack.append((level+1,node+1))\\n                 \\n                if node-1 >=0 and node-1 not in visited:\\n                    stack.append((level+1,node-1))\\n                    \\n\\n                                 \\n        return level\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690651,
                "title": "python-bfs-with-use-hyperlink-once-trick",
                "content": "If you use a hyperlink, you can erase them so they aren\\'t used again. This way it runs in O(n) time and extra space.\\n(See `matches[arr[i]] = []` below.)\\n\\n```\\nfrom typing import List\\nfrom collections import defaultdict, Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        start, end = 0, n-1\\n\\n        reached, frontier, matches = set(), {start}, defaultdict(list)\\n        for i, num in enumerate(arr):\\n            matches[num].append(i)\\n\\n        def next_states(i):\\n            yield from (j for j in chain([i-1, i+1], matches[arr[i]]) if i != j and 0 <= j < n)\\n            matches[arr[i]] = []\\n\\n        levels = 0\\n        while  frontier:\\n            if end in frontier:\\n                return levels\\n            newfrontier = {j for i in frontier for j in next_states(i)}\\n            reached.update(frontier)\\n            frontier = newfrontier.difference(reached)\\n            levels += 1\\n\\n        return levels\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nfrom collections import defaultdict, Counter\\nfrom itertools import chain\\n\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        start, end = 0, n-1\\n\\n        reached, frontier, matches = set(), {start}, defaultdict(list)\\n        for i, num in enumerate(arr):\\n            matches[num].append(i)\\n\\n        def next_states(i):\\n            yield from (j for j in chain([i-1, i+1], matches[arr[i]]) if i != j and 0 <= j < n)\\n            matches[arr[i]] = []\\n\\n        levels = 0\\n        while  frontier:\\n            if end in frontier:\\n                return levels\\n            newfrontier = {j for i in frontier for j in next_states(i)}\\n            reached.update(frontier)\\n            frontier = newfrontier.difference(reached)\\n            levels += 1\\n\\n        return levels\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1690629,
                "title": "python-bfs-o-n-time",
                "content": "This problem asks the `minumum number of steps`. The BFS (Breadth-first-search) is known for the solution of this subject.\\n\\nLet\\'s take a look of the example `arr = [100,-23,-23,404,100,23,23,23,3,404]`\\n\\nStep0\\n![image](https://assets.leetcode.com/users/images/41c8b282-bac8-4807-b210-2ab21ba08cdf_1642207727.6492648.png)\\n\\nstep1\\n![image](https://assets.leetcode.com/users/images/0b85df85-8ddb-42e7-bd98-f13827b5925c_1642207737.4827814.png)\\n\\nstep2\\n![image](https://assets.leetcode.com/users/images/e53519f2-9eac-4abf-b3c9-14c9f60b3836_1642207746.250499.png)\\n\\nstep3\\n![image](https://assets.leetcode.com/users/images/46a9a228-1af5-4bf3-8707-d333239427fc_1642207757.079583.png)\\n\\nAs you can see above images, we visit (almost of ) all nodes only once.\\nTo prevent a cycled path, we need to mark `visited[i] = True`.\\n\\nSo, the time complexity is `O(N)`, and the space complexity is also `O(N)`.\\n\\n----\\n\\nThe `BFS` is implemented using `queue` typically, but in this problem, `(i +/- 1)` and `nums[i] == nums[j]` are duplicated sometimes.\\nOf course, we manage visiting, so it\\'s not a big problem, but to reduce the number of iteration, we use `set()` instead.\\n\\n\\n\\n```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        if (N == 1):\\n            return 0\\n        \\n        # We build a key-values(list) dictionary\\n        # where the key is value of the array element,\\n        # and values are indicies of the elements\\n        positions = {}\\n        for i in range(N):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        visited = [False] * N\\n        \\n        # BFS search\\n        queue = set()\\n        queue.add(0)\\n        stepCnt = 0\\n        lastIdx = N - 1\\n        \\n        while(queue):\\n            \\n            nextQ = set()\\n            for i in queue:\\n\\n                # If visited, ignore this path\\n                if visited[i]:\\n                    continue\\n                visited[i] = True\\n                \\n\\n                if i == lastIdx:\\n                    return stepCnt\\n\\n                #\\n                # i - 1 or i + 1\\n                # \\n                if (i - 1 >= 0) and (visited[i - 1] == False) and (arr[i -1] != arr[i]):\\n                    nextQ.add(i - 1)\\n                    \\n                if (i + 1 < N) and (visited[i + 1] == False) and (arr[i + 1] != arr[i]):\\n                    nextQ.add(i + 1)\\n\\n                #\\n                # Jump to the same value indicies\\n                # \\n                if (arr[i] not in positions):\\n                    continue\\n                indiciesOfsameValues = positions[arr[i]]\\n                for idx in indiciesOfsameValues:\\n                    if (visited[idx]):\\n                        continue\\n                    \\n                    nextQ.add(idx)\\n\\n                del positions[arr[i]]\\n            stepCnt += 1\\n\\n            queue = nextQ\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        N = len(arr)\\n        if (N == 1):\\n            return 0\\n        \\n        # We build a key-values(list) dictionary\\n        # where the key is value of the array element,\\n        # and values are indicies of the elements\\n        positions = {}\\n        for i in range(N):\\n            if arr[i] not in positions:\\n                positions[arr[i]] = []\\n            positions[arr[i]].append(i)\\n        \\n        visited = [False] * N\\n        \\n        # BFS search\\n        queue = set()\\n        queue.add(0)\\n        stepCnt = 0\\n        lastIdx = N - 1\\n        \\n        while(queue):\\n            \\n            nextQ = set()\\n            for i in queue:\\n\\n                # If visited, ignore this path\\n                if visited[i]:\\n                    continue\\n                visited[i] = True\\n                \\n\\n                if i == lastIdx:\\n                    return stepCnt\\n\\n                #\\n                # i - 1 or i + 1\\n                # \\n                if (i - 1 >= 0) and (visited[i - 1] == False) and (arr[i -1] != arr[i]):\\n                    nextQ.add(i - 1)\\n                    \\n                if (i + 1 < N) and (visited[i + 1] == False) and (arr[i + 1] != arr[i]):\\n                    nextQ.add(i + 1)\\n\\n                #\\n                # Jump to the same value indicies\\n                # \\n                if (arr[i] not in positions):\\n                    continue\\n                indiciesOfsameValues = positions[arr[i]]\\n                for idx in indiciesOfsameValues:\\n                    if (visited[idx]):\\n                        continue\\n                    \\n                    nextQ.add(idx)\\n\\n                del positions[arr[i]]\\n            stepCnt += 1\\n\\n            queue = nextQ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1635412,
                "title": "python-bfs-optimized-with-comments-that-explain",
                "content": "Comments explain the algorithm in detail.\\n\\nTime complexity should be O(N) where N represents the number of nodes in our graph\\n\\nSpace complexity is O(N)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # store all possible jump candidates\\n        m = {num: [] for num in arr}\\n        \\n        for i, num in enumerate(arr):\\n            # we dismiss all nodes that we could already visit by the other mean of being able to step one up and one down\\n\\t\\t\\t# (so if a node had the same value as another and they were bordering, why store it?, \\n\\t\\t\\t# it will not matter and just adds to our unnecessary nodes to visit)\\n            if 0 < i < len(arr)-1 and arr[i - 1] == num and num == arr[i + 1]:\\n                continue\\n            m[num].append(i)\\n        \\n        # dont want to revisit the same index\\n        visited = set()\\n        \\n        n = len(arr)\\n    \\n        q = deque()\\n        # add the 0th node in our queue as that is our starting point\\n        q.append(0)\\n        res = 0\\n        while q:\\n            children = len(q)\\n\\t\\t\\t# Here we are currently doing as many iterations as there are nodes in the queue right now\\n\\t\\t\\t# The reason being that we do not want to accidentally visit nodes that were not meant to be\\n\\t\\t\\t# Visited right now\\n            for _ in range(children):\\n                i = q.popleft()\\n                # don\\'t want to revisit the same node\\n                if i in visited:\\n                    continue\\n                # if we reached the end then gg, we won\\n                if i == n-1:\\n                    return res\\n                visited.add(i)\\n                # can we move one forward?, if we can then let\\'s try that\\n                if (i+1) not in visited:\\n                    q.append(i+1)\\n                    \\n                # can we move one back? if we can then let\\'s try that\\n                if (i-1) not in visited and (i-1) >= 0:\\n                    q.append(i-1)\\n                    \\n\\n                # let\\'s add every possible value that has the same value as the current one to our list to visit\\n                for neighbor in m[arr[i]]:\\n                    if neighbor in visited:\\n                        continue\\n                    q.append(neighbor)\\n                # No longer need to visit this node\\'s partner values ever again, \\n                # so let\\'s remove all of it\\'s partner values. \\n                # This also stops the partner nodes from visiting each other again\\n                # As that is a possibility (You visit all 100s, then when you are visiting\\n                # the next 100 in your graph, you have to iterate through all 100s again, \\n\\t\\t\\t\\t# that is inefficient so we empty the 100s connections)\\n                m[arr[i]] = []\\n            res += 1\\t\\t\\t\\n        # if we don\\'t get an answer, return -1. Not needed as we are guaranteed an answer but some error checking is a best practice so why not\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # store all possible jump candidates\\n        m = {num: [] for num in arr}\\n        \\n        for i, num in enumerate(arr):\\n            # we dismiss all nodes that we could already visit by the other mean of being able to step one up and one down\\n\\t\\t\\t# (so if a node had the same value as another and they were bordering, why store it?, \\n\\t\\t\\t# it will not matter and just adds to our unnecessary nodes to visit)\\n            if 0 < i < len(arr)-1 and arr[i - 1] == num and num == arr[i + 1]:\\n                continue\\n            m[num].append(i)\\n        \\n        # dont want to revisit the same index\\n        visited = set()\\n        \\n        n = len(arr)\\n    \\n        q = deque()\\n        # add the 0th node in our queue as that is our starting point\\n        q.append(0)\\n        res = 0\\n        while q:\\n            children = len(q)\\n\\t\\t\\t# Here we are currently doing as many iterations as there are nodes in the queue right now\\n\\t\\t\\t# The reason being that we do not want to accidentally visit nodes that were not meant to be\\n\\t\\t\\t# Visited right now\\n            for _ in range(children):\\n                i = q.popleft()\\n                # don\\'t want to revisit the same node\\n                if i in visited:\\n                    continue\\n                # if we reached the end then gg, we won\\n                if i == n-1:\\n                    return res\\n                visited.add(i)\\n                # can we move one forward?, if we can then let\\'s try that\\n                if (i+1) not in visited:\\n                    q.append(i+1)\\n                    \\n                # can we move one back? if we can then let\\'s try that\\n                if (i-1) not in visited and (i-1) >= 0:\\n                    q.append(i-1)\\n                    \\n\\n                # let\\'s add every possible value that has the same value as the current one to our list to visit\\n                for neighbor in m[arr[i]]:\\n                    if neighbor in visited:\\n                        continue\\n                    q.append(neighbor)\\n                # No longer need to visit this node\\'s partner values ever again, \\n                # so let\\'s remove all of it\\'s partner values. \\n                # This also stops the partner nodes from visiting each other again\\n                # As that is a possibility (You visit all 100s, then when you are visiting\\n                # the next 100 in your graph, you have to iterate through all 100s again, \\n\\t\\t\\t\\t# that is inefficient so we empty the 100s connections)\\n                m[arr[i]] = []\\n            res += 1\\t\\t\\t\\n        # if we don\\'t get an answer, return -1. Not needed as we are guaranteed an answer but some error checking is a best practice so why not\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458025,
                "title": "java-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        \\n        if(n<=1){\\n            return 0;\\n        }\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.putIfAbsent(arr[i],new HashSet<>());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.offer(0);\\n        \\n        int steps=0;\\n        \\n        while(!queue.isEmpty()){\\n            steps++;\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                int jump = queue.poll();\\n                \\n                // jump-1\\n                \\n                if(jump-1>=0&&graph.containsKey(arr[jump-1])){\\n                    queue.offer(jump-1);\\n                }\\n                \\n                // jump+1\\n                if(jump+1<n&&graph.containsKey(arr[jump+1])){\\n                    if(jump+1==n-1){\\n                        return steps;\\n                    }\\n                    queue.offer(jump+1);\\n                }\\n                \\n                if(graph.containsKey(arr[jump])){\\n                    \\n                    for(int k : graph.get(arr[jump])){\\n                        if(k!=jump){\\n                            if(k==n-1){\\n                                return steps;\\n                            }\\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                graph.remove(arr[jump]);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        \\n        int n = arr.length;\\n        \\n        if(n<=1){\\n            return 0;\\n        }\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            graph.putIfAbsent(arr[i],new HashSet<>());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        \\n        queue.offer(0);\\n        \\n        int steps=0;\\n        \\n        while(!queue.isEmpty()){\\n            steps++;\\n            \\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++){\\n                \\n                int jump = queue.poll();\\n                \\n                // jump-1\\n                \\n                if(jump-1>=0&&graph.containsKey(arr[jump-1])){\\n                    queue.offer(jump-1);\\n                }\\n                \\n                // jump+1\\n                if(jump+1<n&&graph.containsKey(arr[jump+1])){\\n                    if(jump+1==n-1){\\n                        return steps;\\n                    }\\n                    queue.offer(jump+1);\\n                }\\n                \\n                if(graph.containsKey(arr[jump])){\\n                    \\n                    for(int k : graph.get(arr[jump])){\\n                        if(k!=jump){\\n                            if(k==n-1){\\n                                return steps;\\n                            }\\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                graph.remove(arr[jump]);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263812,
                "title": "c-o-n-bfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        /*\\n        Logic is to apply bfs traversal and the level at which last index is found is the shortest distance.\\n        For a parent (ith index) its children will be:\\n        -> i-1, if i-1>=0\\n        -> i+1, if i+1<n\\n        -> all its duplicate element indexes except i\\n        */\\n        int n=arr.size(), level=0;\\n        vector<bool> visited(n, false);\\n        // To store nodes during bfs\\n        queue<int> bfs;\\n        //To store duplicate indexes\\n        unordered_map<int, stack<int>> duplicate_index;\\n        for (int i=0; i<n; i++)\\n            duplicate_index[arr[i]].push(i);\\n        bfs.push(0);\\n        visited[0] = true;\\n        while(!bfs.empty()){\\n            int size=bfs.size();\\n            // after while loop ends level is increased\\n            while(size--){\\n                int i=bfs.front();\\n                bfs.pop();\\n                if (i==n-1)\\n                    return level;\\n                //i-1 jump\\n                if (i-1>=0 && !visited[i-1]){\\n                    bfs.push(i-1);\\n                    visited[i-1]=true;\\n                }\\n                //i+1 jump\\n                if (i+1<n && !visited[i+1]){\\n                    bfs.push(i+1);\\n                    visited[i+1]=true;\\n                }\\n                // jump to duplicate element\\n                while (!duplicate_index[arr[i]].empty()){\\n                    int dup_i = duplicate_index[arr[i]].top();\\n                    duplicate_index[arr[i]].pop();\\n                    if (!visited[dup_i]){\\n                        bfs.push(dup_i);\\n                        visited[dup_i]=true;\\n                    }\\n                } \\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        /*\\n        Logic is to apply bfs traversal and the level at which last index is found is the shortest distance.\\n        For a parent (ith index) its children will be:\\n        -> i-1, if i-1>=0\\n        -> i+1, if i+1<n\\n        -> all its duplicate element indexes except i\\n        */\\n        int n=arr.size(), level=0;\\n        vector<bool> visited(n, false);\\n        // To store nodes during bfs\\n        queue<int> bfs;\\n        //To store duplicate indexes\\n        unordered_map<int, stack<int>> duplicate_index;\\n        for (int i=0; i<n; i++)\\n            duplicate_index[arr[i]].push(i);\\n        bfs.push(0);\\n        visited[0] = true;\\n        while(!bfs.empty()){\\n            int size=bfs.size();\\n            // after while loop ends level is increased\\n            while(size--){\\n                int i=bfs.front();\\n                bfs.pop();\\n                if (i==n-1)\\n                    return level;\\n                //i-1 jump\\n                if (i-1>=0 && !visited[i-1]){\\n                    bfs.push(i-1);\\n                    visited[i-1]=true;\\n                }\\n                //i+1 jump\\n                if (i+1<n && !visited[i+1]){\\n                    bfs.push(i+1);\\n                    visited[i+1]=true;\\n                }\\n                // jump to duplicate element\\n                while (!duplicate_index[arr[i]].empty()){\\n                    int dup_i = duplicate_index[arr[i]].top();\\n                    duplicate_index[arr[i]].pop();\\n                    if (!visited[dup_i]){\\n                        bfs.push(dup_i);\\n                        visited[dup_i]=true;\\n                    }\\n                } \\n            }\\n            level++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202192,
                "title": "java-simple-and-easy-to-understand-solution-44-ms-faster-than-90-47-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        HashMap<Integer, ArrayList<Integer>> graph = new HashMap();\\n        \\n        for(int i = 0; i< n; i++){\\n            graph.putIfAbsent(arr[i], new ArrayList());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        \\n        HashSet<Integer> curr = new HashSet();\\n        curr.add(0);\\n        \\n        HashSet<Integer> other = new HashSet();\\n        other.add(n - 1);\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        \\n        int steps = 0;\\n        while(!curr.isEmpty()){\\n            \\n            //consider small size set\\n            if(curr.size() > other.size()){\\n                //swap sets\\n                HashSet<Integer> temp = curr;\\n                curr = other;\\n                other = temp;\\n            }\\n            \\n            HashSet<Integer> next = new HashSet();\\n            \\n            for(int currIndex : curr){\\n                \\n                //check same value\\n                for(int index : graph.get(arr[currIndex])){\\n                    \\n                    //check already reached to this index from other end\\n                    if(other.contains(index)) return steps + 1;\\n                \\n                    if(!visited[index]){\\n                        visited[index] = true;\\n                        next.add(index);\\n                    }\\n                }\\n                \\n                \\n                graph.get(arr[currIndex]).clear();\\n                \\n                //check already reached to this index (neighbors) from other end\\n                if(other.contains(currIndex + 1) || other.contains(currIndex - 1)) return steps + 1;\\n                \\n                \\n                //check left index\\n                if(currIndex - 1 >= 0 && !visited[currIndex - 1]){\\n                    visited[currIndex - 1] = true;\\n                    next.add(currIndex - 1);\\n                }\\n                \\n                //check right index\\n                if(currIndex + 1 <= n - 1 && !visited[currIndex + 1]){\\n                    visited[currIndex + 1] = true;\\n                    next.add(currIndex + 1);\\n                }\\n                \\n                \\n            }\\n            \\n            curr = next;\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n <= 1) {\\n            return 0;\\n        }\\n        \\n        HashMap<Integer, ArrayList<Integer>> graph = new HashMap();\\n        \\n        for(int i = 0; i< n; i++){\\n            graph.putIfAbsent(arr[i], new ArrayList());\\n            graph.get(arr[i]).add(i);\\n        }\\n        \\n        \\n        HashSet<Integer> curr = new HashSet();\\n        curr.add(0);\\n        \\n        HashSet<Integer> other = new HashSet();\\n        other.add(n - 1);\\n        \\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        visited[n - 1] = true;\\n        \\n        int steps = 0;\\n        while(!curr.isEmpty()){\\n            \\n            //consider small size set\\n            if(curr.size() > other.size()){\\n                //swap sets\\n                HashSet<Integer> temp = curr;\\n                curr = other;\\n                other = temp;\\n            }\\n            \\n            HashSet<Integer> next = new HashSet();\\n            \\n            for(int currIndex : curr){\\n                \\n                //check same value\\n                for(int index : graph.get(arr[currIndex])){\\n                    \\n                    //check already reached to this index from other end\\n                    if(other.contains(index)) return steps + 1;\\n                \\n                    if(!visited[index]){\\n                        visited[index] = true;\\n                        next.add(index);\\n                    }\\n                }\\n                \\n                \\n                graph.get(arr[currIndex]).clear();\\n                \\n                //check already reached to this index (neighbors) from other end\\n                if(other.contains(currIndex + 1) || other.contains(currIndex - 1)) return steps + 1;\\n                \\n                \\n                //check left index\\n                if(currIndex - 1 >= 0 && !visited[currIndex - 1]){\\n                    visited[currIndex - 1] = true;\\n                    next.add(currIndex - 1);\\n                }\\n                \\n                //check right index\\n                if(currIndex + 1 <= n - 1 && !visited[currIndex + 1]){\\n                    visited[currIndex + 1] = true;\\n                    next.add(currIndex + 1);\\n                }\\n                \\n                \\n            }\\n            \\n            curr = next;\\n            steps++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1194004,
                "title": "c-bfs-solution",
                "content": "```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        \\n        if(arr == null || arr.Length <= 1)\\n            return 0;\\n        \\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(!dic.ContainsKey(arr[i]))\\n                dic.Add(arr[i], new List<int>(){i});\\n            else\\n                dic[arr[i]].Add(i);\\n        }\\n        \\n        bool[] visited = new bool[arr.Length];\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int res = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                int curr = queue.Dequeue();\\n                if(curr == arr.Length - 1)\\n                    return res;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n                if(left >= 0 && !visited[left])\\n                {\\n                    queue.Enqueue(left);\\n                    visited[left] = true;\\n                }\\n                if(right < arr.Length && !visited[right])\\n                {\\n                    queue.Enqueue(right);\\n                    visited[right] = true;\\n                }\\n                foreach(int next in dic[arr[curr]])\\n                {\\n                    if(!visited[next])\\n                    {\\n                        queue.Enqueue(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n                dic[arr[curr]].Clear(); // this is critical. Once the all cells with current value are visited, no need to checck again\\n            }         \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        \\n        if(arr == null || arr.Length <= 1)\\n            return 0;\\n        \\n        Dictionary<int,List<int>> dic = new Dictionary<int,List<int>>();\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(!dic.ContainsKey(arr[i]))\\n                dic.Add(arr[i], new List<int>(){i});\\n            else\\n                dic[arr[i]].Add(i);\\n        }\\n        \\n        bool[] visited = new bool[arr.Length];\\n        Queue<int> queue = new Queue<int>();\\n        queue.Enqueue(0);\\n        visited[0] = true;\\n        int res = 0;\\n        while(queue.Count > 0)\\n        {\\n            int size = queue.Count;\\n            for(int i = 0; i < size; i++)\\n            {\\n                int curr = queue.Dequeue();\\n                if(curr == arr.Length - 1)\\n                    return res;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n                if(left >= 0 && !visited[left])\\n                {\\n                    queue.Enqueue(left);\\n                    visited[left] = true;\\n                }\\n                if(right < arr.Length && !visited[right])\\n                {\\n                    queue.Enqueue(right);\\n                    visited[right] = true;\\n                }\\n                foreach(int next in dic[arr[curr]])\\n                {\\n                    if(!visited[next])\\n                    {\\n                        queue.Enqueue(next);\\n                        visited[next] = true;\\n                    }\\n                }\\n                dic[arr[curr]].Clear(); // this is critical. Once the all cells with current value are visited, no need to checck again\\n            }         \\n            res++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1171202,
                "title": "java-bfs-49ms-beats-81-t-c-o-n-s-c-o-n",
                "content": "\\n    class Pair {\\n\\n\\t\\tint idx;\\n\\t\\tint jump;\\n\\n\\t\\tpublic Pair(int idx, int jump) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.jump = jump;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minJumps(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tboolean[] visited = new boolean[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tList<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n\\t\\t\\tlist.add(i);\\n\\t\\t\\tmap.put(arr[i], list);\\n\\t\\t}\\n\\n\\t\\tqueue.add(new Pair(0, 0));\\n\\t\\tvisited[0] = true;\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.poll();\\n\\t\\t\\tint idx = temp.idx;\\n\\t\\t\\tint jump = temp.jump;\\n\\n\\t\\t\\tif (idx == len - 1)\\n\\t\\t\\t\\treturn temp.jump;\\n\\n\\t\\t\\tif (idx - 1 >= 0 && !visited[idx - 1]) {\\n\\t\\t\\t\\tvisited[idx - 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx - 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tif (idx + 1 < len && !visited[idx + 1]) {\\n\\t\\t\\t\\tvisited[idx + 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx + 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tList<Integer> nbrs = map.get(arr[idx]);\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (nbr != idx && !visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.add(new Pair(nbr, jump + 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnbrs.clear();\\n\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    class Pair {\\n\\n\\t\\tint idx;\\n\\t\\tint jump;\\n\\n\\t\\tpublic Pair(int idx, int jump) {\\n\\t\\t\\tthis.idx = idx;\\n\\t\\t\\tthis.jump = jump;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tpublic int minJumps(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashMap<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tboolean[] visited = new boolean[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tList<Integer> list = map.getOrDefault(arr[i], new ArrayList<>());\\n\\t\\t\\tlist.add(i);\\n\\t\\t\\tmap.put(arr[i], list);\\n\\t\\t}\\n\\n\\t\\tqueue.add(new Pair(0, 0));\\n\\t\\tvisited[0] = true;\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.poll();\\n\\t\\t\\tint idx = temp.idx;\\n\\t\\t\\tint jump = temp.jump;\\n\\n\\t\\t\\tif (idx == len - 1)\\n\\t\\t\\t\\treturn temp.jump;\\n\\n\\t\\t\\tif (idx - 1 >= 0 && !visited[idx - 1]) {\\n\\t\\t\\t\\tvisited[idx - 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx - 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tif (idx + 1 < len && !visited[idx + 1]) {\\n\\t\\t\\t\\tvisited[idx + 1] = true;\\n\\t\\t\\t\\tqueue.add(new Pair(idx + 1, jump + 1));\\n\\t\\t\\t}\\n\\t\\t\\tList<Integer> nbrs = map.get(arr[idx]);\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (nbr != idx && !visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.add(new Pair(nbr, jump + 1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tnbrs.clear();\\n\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1102518,
                "title": "dfs-memoization-does-not-work-explanation-and-example",
                "content": "I am trying to explain why DFS + Memoization does not work, using an example. \\nI feel my explanation is still vague.\\nI eagerly want to see any better explanation or **chracterization of this kind of problems**.\\n\\n```\\n// DFS + Memoization does not work: see the comments below\\n// The following algorithm gives \"6\" and the correct value is \"5\"\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        vector<int> mem(n, INT_MAX);\\n        mem[n - 1] = 0;\\n        int start = 0;\\n        mj(arr, n, mp, 0, mem);\\n        return mem[0];\\n    }\\n\\nprivate:\\n    void mj(vector<int>& arr, int n, unordered_map<int, vector<int>>& mp, int start, vector<int>& mem) {\\n        if (start >= n || start < 0 || mem[start] != INT_MAX) {\\n            // this is incorrect, when mem[start] value is looked up\\n            // mem[start] value may not be the min value, when mem[start] is looked up;\\n            // e.g., for arr = [3, 9, 12, 11, 3, 2, 2, 11, 4, 13, 4];\\n            // mem[3] is not the min value 3, when mem[3] is looked up by mem[4] in the \"if (start - 1 >= 0)\" branch;\\n            // mem[3] is the value 4, when it is looked up in that branch.\\n            // This problem exists because mem[3] is updated later in the \"for (int x ...)\" block;\\n            //\\n            // Memoization may not work, when all of the following 3 depency exist: \\n            //  - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n            //  - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n            //  - jump dependency, i.e., mem[start] depends on mem[x];\\n            return;\\n        }\\n\\n        if (start + 1 < n) {\\n            mj(arr, n, mp, start + 1, mem);\\n            mem[start] = min(mem[start], mem[start + 1]);\\n        }\\n\\n        if (start - 1 >= 0) {\\n            mj(arr, n, mp, start - 1, mem);\\n            mem[start] = min(mem[start], mem[start - 1]);\\n        }\\n\\n        for (int x : mp[arr[start]]) {\\n            if (x != start) {\\n                mj(arr, n, mp, x, mem);\\n                mem[start] = min(mem[start], mem[x]);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// DFS + Memoization does not work: see the comments below\\n// The following algorithm gives \"6\" and the correct value is \"5\"\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        vector<int> mem(n, INT_MAX);\\n        mem[n - 1] = 0;\\n        int start = 0;\\n        mj(arr, n, mp, 0, mem);\\n        return mem[0];\\n    }\\n\\nprivate:\\n    void mj(vector<int>& arr, int n, unordered_map<int, vector<int>>& mp, int start, vector<int>& mem) {\\n        if (start >= n || start < 0 || mem[start] != INT_MAX) {\\n            // this is incorrect, when mem[start] value is looked up\\n            // mem[start] value may not be the min value, when mem[start] is looked up;\\n            // e.g., for arr = [3, 9, 12, 11, 3, 2, 2, 11, 4, 13, 4];\\n            // mem[3] is not the min value 3, when mem[3] is looked up by mem[4] in the \"if (start - 1 >= 0)\" branch;\\n            // mem[3] is the value 4, when it is looked up in that branch.\\n            // This problem exists because mem[3] is updated later in the \"for (int x ...)\" block;\\n            //\\n            // Memoization may not work, when all of the following 3 depency exist: \\n            //  - forward dependency, i.e., mem[start] depends on mem[start + 1];\\n            //  - backward dependncy, i.e., mem[start] depends on mem[start - 1];\\n            //  - jump dependency, i.e., mem[start] depends on mem[x];\\n            return;\\n        }\\n\\n        if (start + 1 < n) {\\n            mj(arr, n, mp, start + 1, mem);\\n            mem[start] = min(mem[start], mem[start + 1]);\\n        }\\n\\n        if (start - 1 >= 0) {\\n            mj(arr, n, mp, start - 1, mem);\\n            mem[start] = min(mem[start], mem[start - 1]);\\n        }\\n\\n        for (int x : mp[arr[start]]) {\\n            if (x != start) {\\n                mj(arr, n, mp, x, mem);\\n                mem[start] = min(mem[start], mem[x]);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989513,
                "title": "swift-solution-beats-100",
                "content": "Swift solution beats 100%\\n```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        let c = arr.count\\n        var equals = [Int: [Int]](), unvisited = [Bool](repeating: true, count: c), nextQueue = [Int](), result = 0\\n        func appendQueue(_ index: Int) {\\n            if unvisited[index] {\\n                nextQueue.append(index)\\n                unvisited[index] = false\\n            }\\n        }\\n        for i in 0..<c {\\n            equals[arr[i], default: [Int]()].append(i)\\n        }\\n        if c > 1 {\\n            nextQueue.append(0)\\n            unvisited[0] = false\\n        }\\n        while !nextQueue.isEmpty {\\n            let queue = nextQueue\\n            nextQueue = []\\n            result += 1\\n            for index in queue {\\n                if index == c - 2 {\\n                    return result\\n                }\\n                if index < c - 1 {\\n                    appendQueue(index + 1)\\n                }\\n                if index > 0 {\\n                    appendQueue(index - 1)\\n                }\\n                for nextIndex in equals[arr[index], default: [Int]()] {\\n                    if nextIndex == c - 1 {\\n                        return result\\n                    }\\n                    appendQueue(nextIndex)\\n                }\\n                equals[arr[index]] = nil\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        let c = arr.count\\n        var equals = [Int: [Int]](), unvisited = [Bool](repeating: true, count: c), nextQueue = [Int](), result = 0\\n        func appendQueue(_ index: Int) {\\n            if unvisited[index] {\\n                nextQueue.append(index)\\n                unvisited[index] = false\\n            }\\n        }\\n        for i in 0..<c {\\n            equals[arr[i], default: [Int]()].append(i)\\n        }\\n        if c > 1 {\\n            nextQueue.append(0)\\n            unvisited[0] = false\\n        }\\n        while !nextQueue.isEmpty {\\n            let queue = nextQueue\\n            nextQueue = []\\n            result += 1\\n            for index in queue {\\n                if index == c - 2 {\\n                    return result\\n                }\\n                if index < c - 1 {\\n                    appendQueue(index + 1)\\n                }\\n                if index > 0 {\\n                    appendQueue(index - 1)\\n                }\\n                for nextIndex in equals[arr[index], default: [Int]()] {\\n                    if nextIndex == c - 1 {\\n                        return result\\n                    }\\n                    appendQueue(nextIndex)\\n                }\\n                equals[arr[index]] = nil\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988847,
                "title": "c-intuitive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<a.size();i++)\\n            mp[a[i]].push_back(i);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> used(a.size());\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int i=q.front();\\n                q.pop();\\n                \\n                if(i==a.size()-1)\\n                    return ans;\\n                \\n                used[i]=1;\\n                //i+1\\n                if(!used[i+1]&&a[i+1]!=a[i])\\n                    used[i+1]=1,q.push(i+1);\\n                //i-1\\n                if(i&&!used[i-1]&&a[i-1]!=a[i])\\n                    used[i-1]=1,q.push(i-1);\\n                //i==x\\n                for(int x : mp[a[i]]){\\n                    if(x^i&&!used[x])\\n                        used[x]=1,q.push(x);\\n                }\\n                mp[a[i]]={};\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<a.size();i++)\\n            mp[a[i]].push_back(i);\\n        \\n        queue<int> q;\\n        q.push(0);\\n        vector<int> used(a.size());\\n        int ans=0;\\n        \\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int i=q.front();\\n                q.pop();\\n                \\n                if(i==a.size()-1)\\n                    return ans;\\n                \\n                used[i]=1;\\n                //i+1\\n                if(!used[i+1]&&a[i+1]!=a[i])\\n                    used[i+1]=1,q.push(i+1);\\n                //i-1\\n                if(i&&!used[i-1]&&a[i-1]!=a[i])\\n                    used[i-1]=1,q.push(i-1);\\n                //i==x\\n                for(int x : mp[a[i]]){\\n                    if(x^i&&!used[x])\\n                        used[x]=1,q.push(x);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 919830,
                "title": "c-bfs-clean-code-with-explanation",
                "content": "We use an unordered_set to check whether the index we have already visited. We use the queue to find the minimum length to get to the end. We use a hash map to restore same number\\'s index into an array. \\n**Notice:** We need to check the same number array from end to start to reduce searching time (closer to the end are always better :)\\n```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int>& arr)\\n    {\\n        if(arr.size() == 1)\\n            return 0;\\n        map<int, vector<int>> mp;\\n        unordered_set<int> vis;\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        int ret = 1;\\n        queue<int> q;\\n        vis.insert(0);\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            for(int i = q.size(); i >= 1; i--)\\n            {\\n                auto idx = q.front();\\n                q.pop();\\n                for(int j = mp[arr[idx]].size() - 1; j >= 0; j--)\\n                {\\n                    if(mp[arr[idx]][j] == n - 1)\\n                        return ret;\\n                    if(mp[arr[idx]][j] != idx && !vis.count(mp[arr[idx]][j]))\\n                    {\\n                        vis.insert(mp[arr[idx]][j]);\\n                        q.push(mp[arr[idx]][j]);\\n                    }\\n                }\\n                if(idx + 1 == n - 1)\\n                    return ret;\\n                else if(!vis.count(idx + 1))\\n                {\\n                    vis.insert(idx + 1);\\n                    q.push(idx + 1);\\n                }\\n                if(idx - 1 >= 0 && !vis.count(idx - 1))\\n                {\\n                    vis.insert(idx - 1);\\n                    q.push(idx - 1);\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minJumps(vector<int>& arr)\\n    {\\n        if(arr.size() == 1)\\n            return 0;\\n        map<int, vector<int>> mp;\\n        unordered_set<int> vis;\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++)\\n            mp[arr[i]].push_back(i);\\n        int ret = 1;\\n        queue<int> q;\\n        vis.insert(0);\\n        q.push(0);\\n        while(!q.empty())\\n        {\\n            for(int i = q.size(); i >= 1; i--)\\n            {\\n                auto idx = q.front();\\n                q.pop();\\n                for(int j = mp[arr[idx]].size() - 1; j >= 0; j--)\\n                {\\n                    if(mp[arr[idx]][j] == n - 1)\\n                        return ret;\\n                    if(mp[arr[idx]][j] != idx && !vis.count(mp[arr[idx]][j]))\\n                    {\\n                        vis.insert(mp[arr[idx]][j]);\\n                        q.push(mp[arr[idx]][j]);\\n                    }\\n                }\\n                if(idx + 1 == n - 1)\\n                    return ret;\\n                else if(!vis.count(idx + 1))\\n                {\\n                    vis.insert(idx + 1);\\n                    q.push(idx + 1);\\n                }\\n                if(idx - 1 >= 0 && !vis.count(idx - 1))\\n                {\\n                    vis.insert(idx - 1);\\n                    q.push(idx - 1);\\n                }\\n            }\\n            ret++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657917,
                "title": "java-simple-bfs-solution",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        if(arr == null || arr.length<=2) return 0;\\n\\t\\t\\tMap<Integer, List<Integer>> map = new HashMap<>(); //contains values with their index occurences.\\n        for(int i = 0;i<arr.length;i++) {\\n            if(!map.containsKey(arr[i])) {\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        /* start from the first index and add that to the queue.\\n\\t\\t For each index i we pick from queue, see if we can visit i+1, i-1\\n\\t\\t (if we don\\'t go out of bounds and we haven\\'t already visited it yet). We also need to\\n\\t\\t visit all the indexes for which arr[i] == arr[j] and i != j.\\n\\t\\t All these values in array are considered to be on the same level or same distance from i.\\n\\t\\t for next set of indexes increment jump by 1. if at any point we reach arr.length-1 simply return the jumps.\\n\\t\\t*/\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        int jumps = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++) {\\n                int idx = queue.poll();\\n                visited.add(idx);\\n                if(idx == arr.length-1) {\\n                    return jumps;\\n                }\\n                if(idx+1 <arr.length && !visited.contains(idx+1)) {\\n                    queue.add(idx+1);\\n                }\\n                if(idx-1>=0 && !visited.contains(idx-1)) {\\n                    queue.add(idx-1);\\n                }\\n                if(map.containsKey(arr[idx])) {\\n                    for(int position : map.get(arr[idx])) {\\n                        if(!visited.contains(position)) {\\n                            queue.add(position);\\n                        }\\n                    }\\n                    map.remove(arr[idx]);\\n                }\\n            }\\n            \\n            jumps++;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        if(arr == null || arr.length<=2) return 0;\\n\\t\\t\\tMap<Integer, List<Integer>> map = new HashMap<>(); //contains values with their index occurences.\\n        for(int i = 0;i<arr.length;i++) {\\n            if(!map.containsKey(arr[i])) {\\n                map.put(arr[i], new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        /* start from the first index and add that to the queue.\\n\\t\\t For each index i we pick from queue, see if we can visit i+1, i-1\\n\\t\\t (if we don\\'t go out of bounds and we haven\\'t already visited it yet). We also need to\\n\\t\\t visit all the indexes for which arr[i] == arr[j] and i != j.\\n\\t\\t All these values in array are considered to be on the same level or same distance from i.\\n\\t\\t for next set of indexes increment jump by 1. if at any point we reach arr.length-1 simply return the jumps.\\n\\t\\t*/\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        int jumps = 0;\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            \\n            for(int i=0;i<size;i++) {\\n                int idx = queue.poll();\\n                visited.add(idx);\\n                if(idx == arr.length-1) {\\n                    return jumps;\\n                }\\n                if(idx+1 <arr.length && !visited.contains(idx+1)) {\\n                    queue.add(idx+1);\\n                }\\n                if(idx-1>=0 && !visited.contains(idx-1)) {\\n                    queue.add(idx-1);\\n                }\\n                if(map.containsKey(arr[idx])) {\\n                    for(int position : map.get(arr[idx])) {\\n                        if(!visited.contains(position)) {\\n                            queue.add(position);\\n                        }\\n                    }\\n                    map.remove(arr[idx]);\\n                }\\n            }\\n            \\n            jumps++;\\n        }\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 633365,
                "title": "c-bfs-approach",
                "content": "//Do bfs\\n//From a particular index, visit all the index possible\\n\\nclass Solution {\\npublic:\\n\\n    int minJumps(vector<int>& arr) {\\n     if(arr.size()<=1) return 0;\\n     vector<int>distance(arr.size(),INT_MAX);\\n     distance[0]=0;\\n     unordered_map<int,vector<int>>mp;\\n     for(int i=0;i<arr.size();i++)\\n         mp[arr[i]].push_back(i);\\n     queue<int>q;\\n     q.push(0);\\n     while(!q.empty())\\n     {\\n         int f=q.front();\\n         q.pop();\\n         \\n         for(int dest:mp[arr[f]])\\n         {\\n             if(distance[dest]==INT_MAX) q.push(dest); //Visit neighbour if not visited\\n             distance[dest]=min(distance[dest],distance[f]+1); //Update smallest distance\\n         }\\n         if(f-1>=0)\\n         {\\n            if(distance[f-1]==INT_MAX) q.push(f-1);//Not visited\\n            distance[f-1]=min(distance[f-1],distance[f]+1);\\n         }\\n         if(f+1<arr.size())\\n         {\\n            if(distance[f+1]==INT_MAX) q.push(f+1);\\n            distance[f+1]=min(distance[f+1],distance[f]+1);\\n         }\\n         mp.erase(arr[f]);//Without this TLE //Erase all the similar elements //Because it will then search for it again \\n     }\\n    return distance[arr.size()-1];\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minJumps(vector<int>& arr) {\\n     if(arr.size()<=1) return 0;\\n     vector<int>distance(arr.size(),INT_MAX);\\n     distance[0]=0;\\n     unordered_map<int,vector<int>>mp;\\n     for(int i=0;i<arr.size();i++)\\n         mp[arr[i]].push_back(i);\\n     queue<int>q;\\n     q.push(0);\\n     while(!q.empty())\\n     {\\n         int f=q.front();\\n         q.pop();\\n         \\n         for(int dest:mp[arr[f]])\\n         {\\n             if(distance[dest]==INT_MAX) q.push(dest); //Visit neighbour if not visited\\n             distance[dest]=min(distance[dest],distance[f]+1); //Update smallest distance\\n         }",
                "codeTag": "Java"
            },
            {
                "id": 3606451,
                "title": "c-clean-bfs-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp;\\n\\n        for(int i=0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        int visited[100000] = {0};\\n        queue<int> q;\\n        q.push(0);\\n        visited[0] = 1;\\n\\n        int steps = 0;\\n\\n        while(!q.empty()){\\n            int cap = q.size();\\n\\n            while(cap--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(curr == n-1) return steps;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n\\n                if(left >= 0 && !visited[left]){\\n                    q.push(left);\\n                    visited[left] = 1;\\n                }\\n\\n                if(right <= n-1 && !visited[right]){\\n                    q.push(right);\\n                    visited[right] = 1;\\n                }\\n                int ele = arr[curr];\\n                for(int idx : mp[ele]){\\n                    if(!visited[idx]){\\n                        visited[idx] = 1;\\n                        q.push(idx);\\n                    }\\n                }\\n\\n                mp[ele].clear();\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int,vector<int>> mp;\\n\\n        for(int i=0; i<n; i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        int visited[100000] = {0};\\n        queue<int> q;\\n        q.push(0);\\n        visited[0] = 1;\\n\\n        int steps = 0;\\n\\n        while(!q.empty()){\\n            int cap = q.size();\\n\\n            while(cap--){\\n                int curr = q.front();\\n                q.pop();\\n\\n                if(curr == n-1) return steps;\\n\\n                int left = curr - 1;\\n                int right = curr + 1;\\n\\n                if(left >= 0 && !visited[left]){\\n                    q.push(left);\\n                    visited[left] = 1;\\n                }\\n\\n                if(right <= n-1 && !visited[right]){\\n                    q.push(right);\\n                    visited[right] = 1;\\n                }\\n                int ele = arr[curr];\\n                for(int idx : mp[ele]){\\n                    if(!visited[idx]){\\n                        visited[idx] = 1;\\n                        q.push(idx);\\n                    }\\n                }\\n\\n                mp[ele].clear();\\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261819,
                "title": "kotlin-java-optimized-bfs-approach-explained",
                "content": "# Approach\\nIt is pretty intuitive to treat array items as nodes and the possible paths between them as edges in a graph.\\n\\nSimplest approach to find a shortest path between two nodes is to do a BFS search from start and stop when target node is encountered.\\n\\nThis solution sadly gives a TLE and we must optimize.\\n\\nThe trick is to not repeat already traversed paths. The biggest problem seem to be running through the \"same value\" paths multiple times. \\nIf we traversed all neighbors of node of some value, we don\\'t want to iterate this array again, because we\\'ll find out that every one of them is already visited. Simplest way to prevent this is to remove the value key after first visit.\\nThis optimizes greatly for that evil testcase, when there is a very large array where all nodes but last have same value.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - every node is visited once\\n\\n- Space complexity:\\n$$O(n)$$ - can be maximally allocated either in queue or visited array\\n\\n```kotlin []\\nclass Solution {\\n    fun minJumps(arr: IntArray): Int {\\n        val q: Queue<Int> = LinkedList()\\n        val visited = hashSetOf<Int>()\\n\\n        q.add(0)\\n        visited.add(0)\\n        val nodesByValue = hashMapOf<Int, ArrayList<Int>>()\\n\\n        for (i in arr.indices) {\\n            nodesByValue.computeIfAbsent(arr[i]) { arrayListOf() }.add(i)\\n        }\\n\\n        var dist = 0\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val curr = q.poll()\\n                if (curr == arr.size-1) return dist\\n                for (node in nodesByValue[arr[curr]] ?: arrayListOf()) {\\n                    if (visited.contains(node)) continue\\n                    if (node == arr.size-1) return dist+1\\n                    visited.add(node)\\n                    q.add(node)\\n                }\\n\\n                nodesByValue.remove(arr[curr])\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    q.add(curr-1)\\n                    visited.add(curr-1)\\n                }\\n\\n                if (curr+1 < arr.size && !visited.contains(curr+1)) {\\n                    if (curr+1 == arr.size-1) return dist+1\\n                    q.add(curr+1)\\n                    visited.add(curr+1)\\n                }\\n            }\\n\\n            dist++\\n        }\\n\\n        return dist\\n    }\\n}\\n```\\n```java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> nodesByValue = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            nodesByValue.computeIfAbsent(arr[i], (key) -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        int dist = 0;\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                if (curr == n-1) return dist;\\n\\n                for (int node: nodesByValue.getOrDefault(arr[curr], new ArrayList<>())) {\\n                    if (node == n-1) return dist+1;\\n                    if (visited.contains(node)) continue;\\n                    visited.add(node);\\n                    q.add(node);\\n                }\\n\\n                nodesByValue.remove(arr[curr]);\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    visited.add(curr-1);\\n                    q.add(curr-1);\\n                }\\n\\n                if (curr+1 < n && !visited.contains(curr+1)) {\\n                    if (curr+1 == n-1) return dist+1;\\n                    visited.add(curr+1);\\n                    q.add(curr+1);\\n                }\\n            }\\n\\n            dist++;\\n        }\\n\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Breadth-First Search"
                ],
                "code": "```kotlin []\\nclass Solution {\\n    fun minJumps(arr: IntArray): Int {\\n        val q: Queue<Int> = LinkedList()\\n        val visited = hashSetOf<Int>()\\n\\n        q.add(0)\\n        visited.add(0)\\n        val nodesByValue = hashMapOf<Int, ArrayList<Int>>()\\n\\n        for (i in arr.indices) {\\n            nodesByValue.computeIfAbsent(arr[i]) { arrayListOf() }.add(i)\\n        }\\n\\n        var dist = 0\\n\\n        while (q.isNotEmpty()) {\\n            val size = q.size\\n\\n            for (i in 0 until size) {\\n                val curr = q.poll()\\n                if (curr == arr.size-1) return dist\\n                for (node in nodesByValue[arr[curr]] ?: arrayListOf()) {\\n                    if (visited.contains(node)) continue\\n                    if (node == arr.size-1) return dist+1\\n                    visited.add(node)\\n                    q.add(node)\\n                }\\n\\n                nodesByValue.remove(arr[curr])\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    q.add(curr-1)\\n                    visited.add(curr-1)\\n                }\\n\\n                if (curr+1 < arr.size && !visited.contains(curr+1)) {\\n                    if (curr+1 == arr.size-1) return dist+1\\n                    q.add(curr+1)\\n                    visited.add(curr+1)\\n                }\\n            }\\n\\n            dist++\\n        }\\n\\n        return dist\\n    }\\n}\\n```\n```java []\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> nodesByValue = new HashMap<>();\\n        \\n        for (int i=0; i < n; i++) {\\n            nodesByValue.computeIfAbsent(arr[i], (key) -> new ArrayList<Integer>()).add(i);\\n        }\\n\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(0);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(0);\\n        int dist = 0;\\n\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                int curr = q.poll();\\n                if (curr == n-1) return dist;\\n\\n                for (int node: nodesByValue.getOrDefault(arr[curr], new ArrayList<>())) {\\n                    if (node == n-1) return dist+1;\\n                    if (visited.contains(node)) continue;\\n                    visited.add(node);\\n                    q.add(node);\\n                }\\n\\n                nodesByValue.remove(arr[curr]);\\n\\n                if (curr-1 >= 0 && !visited.contains(curr-1)) {\\n                    visited.add(curr-1);\\n                    q.add(curr-1);\\n                }\\n\\n                if (curr+1 < n && !visited.contains(curr+1)) {\\n                    if (curr+1 == n-1) return dist+1;\\n                    visited.add(curr+1);\\n                    q.add(curr+1);\\n                }\\n            }\\n\\n            dist++;\\n        }\\n\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261815,
                "title": "treat-indexes-as-nodes-and-given-rules-as-edges",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        \\n        unordered_map<int , vector<int>> mp;\\n        int n  = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int ind = q.front();\\n                if(ind==n-1) return ans;\\n                int val = a[ind];\\n                q.pop();\\n                vector<int> v = mp[val];\\n                vis[ind] = true;\\n                v.push_back(ind+1);\\n                v.push_back(ind-1);\\n                for(auto i : v)\\n                {\\n                    if(i>=n || i<0 || vis[i]) continue;\\n                    q.push(i);\\n                }\\n                mp[val].clear();\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& a) {\\n        \\n        unordered_map<int , vector<int>> mp;\\n        int n  = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[a[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> vis(n,false);\\n        vis[0] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int ind = q.front();\\n                if(ind==n-1) return ans;\\n                int val = a[ind];\\n                q.pop();\\n                vector<int> v = mp[val];\\n                vis[ind] = true;\\n                v.push_back(ind+1);\\n                v.push_back(ind-1);\\n                for(auto i : v)\\n                {\\n                    if(i>=n || i<0 || vis[i]) continue;\\n                    q.push(i);\\n                }\\n                mp[val].clear();\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261617,
                "title": "solution-swift-bfs-beats-100",
                "content": "**TC:** O(n)\\n**SC:** O(n)\\n```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        var steps = 0\\n        var queue = Set<Int>()\\n        var visited = Set<Int>()\\n\\n        var map = [Int: [Int]]()\\n        for i in 0..<arr.count {\\n            map[arr[i], default: [Int]()].append(i)\\n        }\\n\\n        queue.insert(0)\\n        visited.insert(0)\\n\\n        while !queue.isEmpty {\\n            var next = Set<Int>()\\n            while !queue.isEmpty {\\n                let node = queue.popFirst()!\\n                if node == arr.count - 1 {\\n                    return steps\\n                }\\n\\n                visited.insert(node)\\n                if node - 1 >= 0, !visited.contains(node - 1) {\\n                    next.insert(node - 1)\\n                    visited.insert(node - 1)\\n                }\\n                if node + 1 < arr.count, !visited.contains(node + 1) {\\n                    next.insert(node + 1)\\n                    visited.insert(node + 1)\\n                }\\n                for element in (map[arr[node]] ?? []) {\\n                    if !visited.contains(element) {\\n                        next.insert(element)\\n                        visited.insert(element)\\n                    }\\n                }\\n                // Key step to avoid TLE\\n                // We don\\'t need to get back to the indecies where we were\\n                map[arr[node]] = nil\\n            }\\n            queue = next\\n            steps += 1\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ arr: [Int]) -> Int {\\n        var steps = 0\\n        var queue = Set<Int>()\\n        var visited = Set<Int>()\\n\\n        var map = [Int: [Int]]()\\n        for i in 0..<arr.count {\\n            map[arr[i], default: [Int]()].append(i)\\n        }\\n\\n        queue.insert(0)\\n        visited.insert(0)\\n\\n        while !queue.isEmpty {\\n            var next = Set<Int>()\\n            while !queue.isEmpty {\\n                let node = queue.popFirst()!\\n                if node == arr.count - 1 {\\n                    return steps\\n                }\\n\\n                visited.insert(node)\\n                if node - 1 >= 0, !visited.contains(node - 1) {\\n                    next.insert(node - 1)\\n                    visited.insert(node - 1)\\n                }\\n                if node + 1 < arr.count, !visited.contains(node + 1) {\\n                    next.insert(node + 1)\\n                    visited.insert(node + 1)\\n                }\\n                for element in (map[arr[node]] ?? []) {\\n                    if !visited.contains(element) {\\n                        next.insert(element)\\n                        visited.insert(element)\\n                    }\\n                }\\n                // Key step to avoid TLE\\n                // We don\\'t need to get back to the indecies where we were\\n                map[arr[node]] = nil\\n            }\\n            queue = next\\n            steps += 1\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261565,
                "title": "c-bfs-iv",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n =arr.size();\\n        unordered_map<int,vector<int>>indexmap; // store every element index value in vector form\\n        for(int i=0;i<n;i++){\\n        indexmap[arr[i]].push_back(i); // 100-> [0,4] and so on\\n        }\\n        // simple bfs things\\n        vector<bool>vis(n); \\n        \\n        vis[0]=true;\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            // traversing the developed graph by bfs\\n            for(int i=q.size();i>0;i--){\\n            int node =q.front();\\n            q.pop();\\n                \\n            if(node==n-1) \\n                return steps; // reached last index\\n            vector<int>&next =indexmap[arr[node]]; // ek node pe pahuch ke usse aage kha ja sakte bi btayega ye\\n            next.push_back(node-1);\\n            next.push_back(node+1);\\n                \\n            for(auto it : next){ \\n                if(it>=0&&it<n&&!vis[it]){ // all condition\\n                        vis[it]=true;\\n                        q.push(it);\\n                }\\n            }\\n                indexmap[arr[node]].clear(); //ye map pe index di gai value ko hta dega jisse                                             //dubara na traver kar de\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n =arr.size();\\n        unordered_map<int,vector<int>>indexmap; // store every element index value in vector form\\n        for(int i=0;i<n;i++){\\n        indexmap[arr[i]].push_back(i); // 100-> [0,4] and so on\\n        }\\n        // simple bfs things\\n        vector<bool>vis(n); \\n        \\n        vis[0]=true;\\n        queue<int>q;\\n        q.push(0);\\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            // traversing the developed graph by bfs\\n            for(int i=q.size();i>0;i--){\\n            int node =q.front();\\n            q.pop();\\n                \\n            if(node==n-1) \\n                return steps; // reached last index\\n            vector<int>&next =indexmap[arr[node]]; // ek node pe pahuch ke usse aage kha ja sakte bi btayega ye\\n            next.push_back(node-1);\\n            next.push_back(node+1);\\n                \\n            for(auto it : next){ \\n                if(it>=0&&it<n&&!vis[it]){ // all condition\\n                        vis[it]=true;\\n                        q.push(it);\\n                }\\n            }\\n                indexmap[arr[node]].clear(); //ye map pe index di gai value ko hta dega jisse                                             //dubara na traver kar de\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261216,
                "title": "you-will-understand",
                "content": "\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\nI tried to figure it out and found obiously it is a good graph problem hell we can think hours for it solution and can figure out others but best go for simple graph and BFS approach that make life easier for now. \\n\\n- So lets take my first appraoch what i did first form the adj list mostly that we form but here we have some conditions.\\n- Okay what are those conditions lets see-\\n```\\nIn one step you can jump from index i to index:\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\n```\\n- Point is here we can only go for same or for ```current-1``` or ```current+1``` thats all. \\n- Okay so how we gonna make our adj list for nodes \\n- No worry about it only we gonna make duplicates one storing all index for same elements [] and thats all at first stage \\n- wait but haven\\'t condition says that we can go for ```curr+1``` or ```curr-1``` \\n- yeah it says while doing BFS we will also take care of both condions so no worry. \\n\\n## Here is My first solultion \\uD83D\\uDC47(SImple BFS )\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        int step = 0;\\n        Set<Integer> vis = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int item = q.poll();\\n                vis.add(item);\\n                if(item==n-1){\\n                    return step;\\n                }\\n                // check for same values \\n                for(int child: hm.get(arr[item])){\\n                    if(!vis.contains(child)){\\n                        q.offer(child);\\n                    }\\n                }\\n                // check sides \\n                if(item+1<n && !vis.contains(item+1)){\\n                    q.offer(item+1);\\n                }\\n                if(item-1>=0 && !vis.contains(item-1)){\\n                    q.offer(item-1);\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\\n- Here solution is good and correct the problem causing it is TLE \\n- lets take look what we are doing here \\n- a simple ```var steps``` that we increasing after all bfs of each step traversal. the point is it is like shortest way from node we can reach \\n- when we reached out we will return number of ```steps``` that we took. \\n\\nWell It is also an O(n) solution so why it is causing TLE problem \\n- right the simple reason for it is ```redundant search``` or you can say checks \\n\\n### okay then how we gonna make it more optimized \\n- No problem by simple analysis the whole point is ```node+1``` or ```node-1``` it matters and ```duplicate``` matters but here we only have to take look when it reached out ```n-1``` last index thats the point \\n- so by considering it you can already make it vis at once \\n- and also clear the list of duplicates to ```prevent redundant search``` thats all optimization it will takes \\n\\n## Solution is given \\uD83D\\uDC47\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        List<Integer> cur = new LinkedList<>();\\n        cur.add(0);\\n        Set<Integer> vis = new HashSet<>();\\n        int step = 0;\\n        // so currently we have node 0 \\n        // our map is ready with same values \\n        // and in our bfs we also have to include node-1 and node+1\\n        while(!cur.isEmpty()){\\n            List<Integer> p = new LinkedList<>();\\n            for(int node:cur){\\n                if(node==n-1){\\n                    return step;\\n                }\\n                // this will chek for same values \\n                for(int child:hm.get(arr[node])){\\n                    if(!vis.contains(child)){\\n                        vis.add(child);\\n                        p.add(child);\\n                    }\\n                }\\n                hm.get(arr[node]).clear();\\n                // checking for sides +1 and -1\\n                if(node+1<n && !vis.contains(node+1)){\\n                    vis.add(node+1);\\n                    p.add(node+1);\\n                }\\n                if(node-1>=0 && !vis.contains(node-1)){\\n                    vis.add(node-1);\\n                    p.add(node-1);\\n                }\\n            }\\n            cur = p;\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIn one step you can jump from index i to index:\\ni + 1 where: i + 1 < arr.length.\\ni - 1 where: i - 1 >= 0.\\nj where: arr[i] == arr[j] and i != j.\\n```\n```current-1```\n```current+1```\n```curr+1```\n```curr-1```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        int step = 0;\\n        Set<Integer> vis = new HashSet<>();\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                int item = q.poll();\\n                vis.add(item);\\n                if(item==n-1){\\n                    return step;\\n                }\\n                // check for same values \\n                for(int child: hm.get(arr[item])){\\n                    if(!vis.contains(child)){\\n                        q.offer(child);\\n                    }\\n                }\\n                // check sides \\n                if(item+1<n && !vis.contains(item+1)){\\n                    q.offer(item+1);\\n                }\\n                if(item-1>=0 && !vis.contains(item-1)){\\n                    q.offer(item-1);\\n                }\\n            }\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```\n```var steps```\n```steps```\n```redundant search```\n```node+1```\n```node-1```\n```duplicate```\n```n-1```\n```prevent redundant search```\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if(n<=1){\\n            return 0;\\n        }\\n        HashMap<Integer, List<Integer>> hm = new HashMap<>();\\n\\n        for(int i=0; i<n; i++){\\n            hm.computeIfAbsent(arr[i], v->new LinkedList<>()).add(i);\\n        }\\n        List<Integer> cur = new LinkedList<>();\\n        cur.add(0);\\n        Set<Integer> vis = new HashSet<>();\\n        int step = 0;\\n        // so currently we have node 0 \\n        // our map is ready with same values \\n        // and in our bfs we also have to include node-1 and node+1\\n        while(!cur.isEmpty()){\\n            List<Integer> p = new LinkedList<>();\\n            for(int node:cur){\\n                if(node==n-1){\\n                    return step;\\n                }\\n                // this will chek for same values \\n                for(int child:hm.get(arr[node])){\\n                    if(!vis.contains(child)){\\n                        vis.add(child);\\n                        p.add(child);\\n                    }\\n                }\\n                hm.get(arr[node]).clear();\\n                // checking for sides +1 and -1\\n                if(node+1<n && !vis.contains(node+1)){\\n                    vis.add(node+1);\\n                    p.add(node+1);\\n                }\\n                if(node-1>=0 && !vis.contains(node-1)){\\n                    vis.add(node-1);\\n                    p.add(node-1);\\n                }\\n            }\\n            cur = p;\\n            step++;\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260992,
                "title": "c-fully-optimised-explained-solution-using-bfs",
                "content": "# Intuition\\nTo solve this problem, we can use BFS (breadth-first search) algorithm. We will start from the first index of the array and visit all possible positions that we can jump to in one step. For each position, we will calculate the number of steps required to reach that position and add it to a queue. We will continue this process until we reach the last index of the array. At each step, we will also keep track of the indices that have been visited to avoid revisiting them.\\n\\n# Approach\\nIn this code, we first create a map indices that maps each integer value in the array to the indices where it occurs. This will allow us to efficiently find the indices that have the same value as the current index. We also create a visited array to keep track of the indices that have been visited.\\n\\nWe then add the first index (i.e., index 0) to the queue and start the BFS process. At each step, we dequeue an index from the queue and try to visit all possible positions that can be reached in one step. We add the new positions to the queue if they have not been visited before. If we reach the last index of the array, we return the number of steps required to reach it. If we cannot reach the last index, we return -1.\\n\\nNote that we use a while loop inside the main while loop to handle all the indices at the current level before moving to the next level. This ensures that we count the minimum number of steps required to reach the last index.\\n\\n# Complexity\\n- Time complexity:\\nO(N + klogk), where N is the length of the input array and k is the number of distinct values in the array.\\n\\n- Space complexity:\\nO(N + k), where N is the length of the input array and k is the number of distinct values in the array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1) {\\n                    return steps;\\n                }\\n                if (i + 1 < n && !visited[i + 1]) {\\n                    visited[i + 1] = true;\\n                    q.push(i + 1);\\n                }\\n                if (i - 1 >= 0 && !visited[i - 1]) {\\n                    visited[i - 1] = true;\\n                    q.push(i - 1);\\n                }\\n                for (int j : indices[arr[i]]) {\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indices[arr[i]].clear(); // optimization: avoid revisiting indices\\n            }\\n            steps++;\\n        }\\n        return -1; // the last index cannot be reached\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>> indices;\\n        for (int i = 0; i < n; i++) {\\n            indices[arr[i]].push_back(i);\\n        }\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        while (!q.empty()) {\\n            int size = q.size();\\n            while (size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n - 1) {\\n                    return steps;\\n                }\\n                if (i + 1 < n && !visited[i + 1]) {\\n                    visited[i + 1] = true;\\n                    q.push(i + 1);\\n                }\\n                if (i - 1 >= 0 && !visited[i - 1]) {\\n                    visited[i - 1] = true;\\n                    q.push(i - 1);\\n                }\\n                for (int j : indices[arr[i]]) {\\n                    if (!visited[j]) {\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                indices[arr[i]].clear(); // optimization: avoid revisiting indices\\n            }\\n            steps++;\\n        }\\n        return -1; // the last index cannot be reached\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260869,
                "title": "bfs-using-queue",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n\\n        # set pos[x][0] = True as unvisited indicator\\n        pos = collections.defaultdict(lambda: [True])\\n\\n        # Store positions i based on value x=arr[i]\\n        # reverse is essential as we are finding shortest path backward\\n        for i, x in reversed(list(enumerate(arr))):\\n            pos[x].append(i)\\n\\n        # res = result table, q = BFS queue\\n        n = len(arr)\\n        res = list(range(n-1, -1, -1))\\n        q = collections.deque()\\n\\n        # start the search backward\\n        for k in range(n-1, -1, -1):\\n            q.append(k)\\n            while q:\\n                i = q.popleft()\\n                if pos[arr[i]][0]: # if unvisited\\n                    pos[arr[i]][0] = False\\n\\n                    # create jump portal for all positions with same value\\n                    for j in pos[arr[i]][1:]:\\n                        res[j] = min(res[j], res[i]+1)\\n                        q.append(j)\\n\\n                    # add adjcent posisitons to queue\\n                    for j in pos[arr[i]][1:]:\\n                        if j > 0:\\n                            res[j-1] = min(res[j-1], res[j]+1)\\n                            q.append(j-1)\\n                        if j < n-1:\\n                            res[j+1] = min(res[j+1], res[j]+1)\\n                            q.append(j+1)\\n        return res[0]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n\\n        # set pos[x][0] = True as unvisited indicator\\n        pos = collections.defaultdict(lambda: [True])\\n\\n        # Store positions i based on value x=arr[i]\\n        # reverse is essential as we are finding shortest path backward\\n        for i, x in reversed(list(enumerate(arr))):\\n            pos[x].append(i)\\n\\n        # res = result table, q = BFS queue\\n        n = len(arr)\\n        res = list(range(n-1, -1, -1))\\n        q = collections.deque()\\n\\n        # start the search backward\\n        for k in range(n-1, -1, -1):\\n            q.append(k)\\n            while q:\\n                i = q.popleft()\\n                if pos[arr[i]][0]: # if unvisited\\n                    pos[arr[i]][0] = False\\n\\n                    # create jump portal for all positions with same value\\n                    for j in pos[arr[i]][1:]:\\n                        res[j] = min(res[j], res[i]+1)\\n                        q.append(j)\\n\\n                    # add adjcent posisitons to queue\\n                    for j in pos[arr[i]][1:]:\\n                        if j > 0:\\n                            res[j-1] = min(res[j-1], res[j]+1)\\n                            q.append(j-1)\\n                        if j < n-1:\\n                            res[j+1] = min(res[j+1], res[j]+1)\\n                            q.append(j+1)\\n        return res[0]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260690,
                "title": "efficiently-solving-the-jump-game-iv-problem-with-python-s-breadth-first-search-algorithm",
                "content": "\\n## 1.  Problem Statement:\\n\\nImagine you\\'re standing on a number line that has a bunch of numbers on it. Each number represents a place you can jump to. You start at the first number, which is called the origin, and you want to jump to the last number, which is called the destination. But there\\'s a catch! Some of the numbers on the number line are the same, and if you land on one of those numbers, you can jump to any other place that has the same number.\\n\\nThe problem is that you want to get to the destination in the fewest possible jumps. Can you figure out how many jumps it will take to get from the origin to the destination?\\n\\n## 2.  Methodology:\\n\\nThe solution to this problem uses a Breadth-First Search (BFS) algorithm to find the shortest path from the origin to the destination. In order to implement the BFS algorithm, we use a queue to keep track of the indices that we need to visit, and we use a distance array to keep track of the minimum number of jumps it takes to get to each index.\\n\\nWe start by creating a dictionary that maps each number in the array to a list of indices where that number appears. Then we add the origin to the queue and set its distance to 0. We then loop through the queue, visiting each index in the queue and adding its neighbors to the queue if they haven\\'t been visited yet. We also keep track of the minimum distance it takes to get to each index.\\n\\nIf we reach the destination index while visiting the indices in the queue, we return the distance to the destination. If we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, it means we can\\'t get to the destination, so we return -1.\\n\\n## 3.  Time and Space Complexity:\\n\\nThe time complexity of this algorithm is $$O(n)$$, where n is the length of the input array. This is because we visit each index in the array exactly once.\\n\\nThe space complexity of this algorithm is $$O(n)$$, where n is the length of the input array. This is because we use a queue and a distance array to keep track of the indices we need to visit and their minimum distances from the origin.\\n\\n## 4.  Explanation of the Code:\\n\\nThe code starts by importing the deque function from the collections module. We then define a class called Solution and a method called minJumps that takes an array of integers called arr as input and returns an integer.\\n\\nThe first few lines of the method are used to handle some special cases. If the length of the array is 1, we return 0 since we don\\'t need to make any jumps to get to the destination. We then create a dictionary called indices that maps each number in the array to a list of indices where that number appears.\\n\\nWe then use a deque called queue to keep track of the indices we need to visit. We add the origin index (which is 0) to the queue and create a distance array of size n (where n is the length of the input array). We set all the elements in the distance array to infinity except for the first element, which we set to 0 since the distance from the origin to the origin is 0.\\n\\nWe then start the BFS algorithm by looping through the indices in the queue. We pop the first index from the queue and get its distance from the origin. We check if we\\'ve reached the destination index, and if we have, we return the distance to the destination.\\n\\nWe then add the indices that have the same value as the current index to the queue. We also update their distances in the distance array if their current distances are infinity (meaning they haven\\'t been visited yet).\\n\\nWe then clear the queue, since we don\\'t need to visit the current index again, and move on to the next index in the queue. We continue this process until we reach the destination index or we\\'ve visited all the indices in the queue.\\n\\nIf we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, it means we can\\'t get to the destination, so we return -1.\\n\\n## 5.  Summary:\\n\\nTo summarize, the problem asks us to find the minimum number of jumps it takes to get from the origin to the destination on a number line with some repeating numbers. We solve this problem by using a BFS algorithm that keeps track of the minimum distance it takes to get to each index. We create a dictionary that maps each number in the array to a list of indices where that number appears, and we use a queue to keep track of the indices we need to visit. We start the BFS algorithm by visiting the origin index and adding its neighbors to the queue. We update the distances in the distance array as we visit each index, and we return the distance to the destination index if we reach it. If we\\'ve visited all the indices in the queue and still haven\\'t reached the destination, we return -1. The time complexity of this algorithm is O(n), and the space complexity is also O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # Get the length of the array and check if there is only one element in the array. If there is only one element, no jumps are needed, so return 0\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Create a dictionary to store the indices of each value in the array\\n        indices = {}\\n        for i, val in enumerate(arr):\\n            if val not in indices:\\n                indices[val] = []\\n            indices[val].append(i)\\n        \\n        # Use BFS to traverse the array and find the minimum number of jumps required to reach the end\\n        # Create a queue using the deque function and add the first index of the array to the queue\\n        queue = deque()\\n        queue.append(0)\\n        # Create a distance array of size n and set all the elements to infinity, except for the first element which should be set to 0\\n        distance = [float(\\'inf\\')] * n\\n        distance[0] = 0\\n        \\n        # Start the BFS algorithm by visiting each index in the queue\\n        while queue:\\n            # Pop the first index from the queue and get its distance from the start\\n            curr_index = queue.popleft()\\n            curr_distance = distance[curr_index]\\n            \\n            # Check if we have reached the end of the array. If we have, return the current distance\\n            if curr_index == n-1:\\n                return curr_distance\\n            \\n            # Add the indices that have the same value as the current index to the queue\\n            for next_index in indices[arr[curr_index]]:\\n                if next_index != curr_index and distance[next_index] == float(\\'inf\\'):\\n                    distance[next_index] = curr_distance + 1\\n                    queue.append(next_index)\\n            \\n            # Clear the dictionary entry for the current index to avoid revisiting it\\n            indices[arr[curr_index]] = []\\n            \\n            # Add the adjacent indices to the queue if they haven\\'t been visited yet\\n            if curr_index > 0 and distance[curr_index-1] == float(\\'inf\\'):\\n                distance[curr_index-1] = curr_distance + 1\\n                queue.append(curr_index-1)\\n            if curr_index < n-1 and distance[curr_index+1] == float(\\'inf\\'):\\n                distance[curr_index+1] = curr_distance + 1\\n                queue.append(curr_index+1)\\n        \\n        # If we cannot reach the end of the array, return -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # Get the length of the array and check if there is only one element in the array. If there is only one element, no jumps are needed, so return 0\\n        n = len(arr)\\n        if n == 1:\\n            return 0\\n        \\n        # Create a dictionary to store the indices of each value in the array\\n        indices = {}\\n        for i, val in enumerate(arr):\\n            if val not in indices:\\n                indices[val] = []\\n            indices[val].append(i)\\n        \\n        # Use BFS to traverse the array and find the minimum number of jumps required to reach the end\\n        # Create a queue using the deque function and add the first index of the array to the queue\\n        queue = deque()\\n        queue.append(0)\\n        # Create a distance array of size n and set all the elements to infinity, except for the first element which should be set to 0\\n        distance = [float(\\'inf\\')] * n\\n        distance[0] = 0\\n        \\n        # Start the BFS algorithm by visiting each index in the queue\\n        while queue:\\n            # Pop the first index from the queue and get its distance from the start\\n            curr_index = queue.popleft()\\n            curr_distance = distance[curr_index]\\n            \\n            # Check if we have reached the end of the array. If we have, return the current distance\\n            if curr_index == n-1:\\n                return curr_distance\\n            \\n            # Add the indices that have the same value as the current index to the queue\\n            for next_index in indices[arr[curr_index]]:\\n                if next_index != curr_index and distance[next_index] == float(\\'inf\\'):\\n                    distance[next_index] = curr_distance + 1\\n                    queue.append(next_index)\\n            \\n            # Clear the dictionary entry for the current index to avoid revisiting it\\n            indices[arr[curr_index]] = []\\n            \\n            # Add the adjacent indices to the queue if they haven\\'t been visited yet\\n            if curr_index > 0 and distance[curr_index-1] == float(\\'inf\\'):\\n                distance[curr_index-1] = curr_distance + 1\\n                queue.append(curr_index-1)\\n            if curr_index < n-1 and distance[curr_index+1] == float(\\'inf\\'):\\n                distance[curr_index+1] = curr_distance + 1\\n                queue.append(curr_index+1)\\n        \\n        # If we cannot reach the end of the array, return -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260573,
                "title": "c-hard-problem-made-easy",
                "content": "```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<pi> q;\\n        q.push({arr[0],{0,0}});\\n        vector<int> vis(n,0);\\n        vis[0]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int ind=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            vis[ind]=1;\\n            if(ind==n-1)\\n                return cnt;\\n            q.pop();\\n            if(ind-1>=0 and !vis[ind-1])\\n            {\\n                 q.push({arr[ind-1],{ind-1,cnt+1}});\\n                vis[ind-1]=1;\\n            }\\n            if(ind+1<n and !vis[ind+1])\\n            {\\n                   q.push({arr[ind+1],{ind+1,cnt+1}});\\n                   vis[ind+1]=1;\\n            }\\n            for(int y:mp[x])\\n            {\\n                if(y!=ind and !vis[y])\\n                {\\n                    q.push({arr[y],{y,cnt+1}});\\n                    vis[y]=1;\\n                }\\n            }\\n            mp.erase(x);\\n         }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\ntypedef pair<int,pair<int,int>> pi;\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        queue<pi> q;\\n        q.push({arr[0],{0,0}});\\n        vector<int> vis(n,0);\\n        vis[0]=1;\\n        while(!q.empty())\\n        {\\n            int x=q.front().first;\\n            int ind=q.front().second.first;\\n            int cnt=q.front().second.second;\\n            vis[ind]=1;\\n            if(ind==n-1)\\n                return cnt;\\n            q.pop();\\n            if(ind-1>=0 and !vis[ind-1])\\n            {\\n                 q.push({arr[ind-1],{ind-1,cnt+1}});\\n                vis[ind-1]=1;\\n            }\\n            if(ind+1<n and !vis[ind+1])\\n            {\\n                   q.push({arr[ind+1],{ind+1,cnt+1}});\\n                   vis[ind+1]=1;\\n            }\\n            for(int y:mp[x])\\n            {\\n                if(y!=ind and !vis[y])\\n                {\\n                    q.push({arr[y],{y,cnt+1}});\\n                    vis[y]=1;\\n                }\\n            }\\n            mp.erase(x);\\n         }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260516,
                "title": "basic-approach-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Map And Deque\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        mapping = {}\\n        for i in range(n):\\n            if arr[i] not in mapping:\\n                mapping[arr[i]] = []\\n            mapping[arr[i]].append(i)\\n\\n        visited = [False] * n\\n        q = deque()\\n        q.append(0)\\n        visited[0] = True\\n        steps = 0\\n\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                i = q.popleft()\\n                if i == n - 1:\\n                    return steps\\n                if i - 1 >= 0 and not visited[i - 1]:\\n                    q.append(i - 1)\\n                    visited[i - 1] = True\\n                if i + 1 < n and not visited[i + 1]:\\n                    q.append(i + 1)\\n                    visited[i + 1] = True\\n                if arr[i] in mapping:\\n                    for neigh in mapping[arr[i]]:\\n                        if not visited[neigh]:\\n                            q.append(neigh)\\n                            visited[neigh] = True\\n                    del mapping[arr[i]]\\n            steps += 1\\n\\n        return -1 #unreachable code\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import deque\\n\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        mapping = {}\\n        for i in range(n):\\n            if arr[i] not in mapping:\\n                mapping[arr[i]] = []\\n            mapping[arr[i]].append(i)\\n\\n        visited = [False] * n\\n        q = deque()\\n        q.append(0)\\n        visited[0] = True\\n        steps = 0\\n\\n        while q:\\n            qsize = len(q)\\n            for _ in range(qsize):\\n                i = q.popleft()\\n                if i == n - 1:\\n                    return steps\\n                if i - 1 >= 0 and not visited[i - 1]:\\n                    q.append(i - 1)\\n                    visited[i - 1] = True\\n                if i + 1 < n and not visited[i + 1]:\\n                    q.append(i + 1)\\n                    visited[i + 1] = True\\n                if arr[i] in mapping:\\n                    for neigh in mapping[arr[i]]:\\n                        if not visited[neigh]:\\n                            q.append(neigh)\\n                            visited[neigh] = True\\n                    del mapping[arr[i]]\\n            steps += 1\\n\\n        return -1 #unreachable code\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260295,
                "title": "go-solution-with-hash-map-and-buffirized-channel",
                "content": "# Approach\\n1) Make mapping hash-table for array values\\n2) Start deque from 0 element.\\n3) Go through every element from mapping dict and add element to queue if path to given element is None\\n4) On final step - check neighbour elements\\n5) Return answer\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\ntype Pair struct {\\n\\tidx   int\\n\\tvalue int\\n}\\n\\nfunc minJumps(arr []int) int {\\n\\tmapping := make(map[int]map[Pair]bool)\\n\\tfor ind, elem := range arr {\\n\\t\\t_, ok := mapping[elem]\\n\\t\\tp := Pair{\\n\\t\\t\\tidx:   ind,\\n\\t\\t\\tvalue: elem,\\n\\t\\t}\\n\\t\\tif !ok {\\n\\t\\t\\tmm := make(map[Pair]bool)\\n\\t\\t\\tmm[p] = true\\n\\t\\t\\tmapping[elem] = mm\\n\\t\\t} else {\\n\\t\\t\\tmapping[elem][p] = true\\n\\t\\t}\\n\\t}\\n\\tpath := make(map[int]int)\\n\\tpath[0] = 0\\n\\tq := make(chan Pair, len(arr))\\n\\tq <- Pair{\\n\\t\\tidx:   0,\\n\\t\\tvalue: arr[0],\\n\\t}\\n\\tused := make(map[int]bool)\\n\\tfor {\\n\\t\\tfrom_ch := <-q\\n\\t\\tif from_ch.idx == len(arr)-1 {\\n\\t\\t\\tclose(q)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t_, ok := used[from_ch.value]\\n\\t\\tif !ok {\\n\\t\\t\\tfor key, _ := range mapping[from_ch.value] {\\n\\t\\t\\t\\t_, ok := path[key.idx]\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\tpath[key.idx] = path[from_ch.idx] + 1\\n\\t\\t\\t\\t\\tq <- key\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            used[from_ch.value] = true\\n\\t\\t}\\n\\t\\tif from_ch.idx-1 >= 0 {\\n\\t\\t\\t_, ok := path[from_ch.idx-1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx-1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx - 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx-1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from_ch.idx+1 < len(arr) {\\n\\t\\t\\t_, ok := path[from_ch.idx+1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx+1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx + 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx+1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn path[len(arr)-1]\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\ntype Pair struct {\\n\\tidx   int\\n\\tvalue int\\n}\\n\\nfunc minJumps(arr []int) int {\\n\\tmapping := make(map[int]map[Pair]bool)\\n\\tfor ind, elem := range arr {\\n\\t\\t_, ok := mapping[elem]\\n\\t\\tp := Pair{\\n\\t\\t\\tidx:   ind,\\n\\t\\t\\tvalue: elem,\\n\\t\\t}\\n\\t\\tif !ok {\\n\\t\\t\\tmm := make(map[Pair]bool)\\n\\t\\t\\tmm[p] = true\\n\\t\\t\\tmapping[elem] = mm\\n\\t\\t} else {\\n\\t\\t\\tmapping[elem][p] = true\\n\\t\\t}\\n\\t}\\n\\tpath := make(map[int]int)\\n\\tpath[0] = 0\\n\\tq := make(chan Pair, len(arr))\\n\\tq <- Pair{\\n\\t\\tidx:   0,\\n\\t\\tvalue: arr[0],\\n\\t}\\n\\tused := make(map[int]bool)\\n\\tfor {\\n\\t\\tfrom_ch := <-q\\n\\t\\tif from_ch.idx == len(arr)-1 {\\n\\t\\t\\tclose(q)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\t_, ok := used[from_ch.value]\\n\\t\\tif !ok {\\n\\t\\t\\tfor key, _ := range mapping[from_ch.value] {\\n\\t\\t\\t\\t_, ok := path[key.idx]\\n\\t\\t\\t\\tif !ok {\\n\\t\\t\\t\\t\\tpath[key.idx] = path[from_ch.idx] + 1\\n\\t\\t\\t\\t\\tq <- key\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            used[from_ch.value] = true\\n\\t\\t}\\n\\t\\tif from_ch.idx-1 >= 0 {\\n\\t\\t\\t_, ok := path[from_ch.idx-1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx-1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx - 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx-1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif from_ch.idx+1 < len(arr) {\\n\\t\\t\\t_, ok := path[from_ch.idx+1]\\n\\t\\t\\tif !ok {\\n\\t\\t\\t\\tpath[from_ch.idx+1] = path[from_ch.idx] + 1\\n\\t\\t\\t\\tq <- Pair{\\n\\t\\t\\t\\t\\tidx:   from_ch.idx + 1,\\n\\t\\t\\t\\t\\tvalue: arr[from_ch.idx+1],\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn path[len(arr)-1]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259696,
                "title": "bfs-beats-94-python-3-solution",
                "content": "\\n\\n# Approach\\nThis code finds the minimum number of jumps needed to reach the end of an array by performing a breadth-first search. It uses a dictionary to store indices of elements with the same value, a queue to track indices to visit, and a set to track visited indices. It returns the number of steps required to reach the end.\\n\\n# Complexity\\n- Time complexity:  **O(N)**\\n- Not 100% sure about that one. If you think it\\'s different, please write down below. \\n\\n\\n\\n---\\n\\n\\n\\n- Space complexity: **O(N)**\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        edges, n = defaultdict(list), len(arr)\\n        for i in range(n):\\n            edges[arr[i]].append(i)\\n        queue, visited, steps = deque([0]), set([0]), 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                idx = queue.popleft()\\n                if idx == n-1:\\n                    return steps\\n                for new_idx in [idx-1, idx+1] + edges.pop(arr[idx], []):\\n                    if 0 <= new_idx < n and new_idx not in visited:\\n                        if new_idx == n-1:\\n                            return steps + 1\\n                        queue.append(new_idx)\\n                        visited.add(new_idx)\\n            steps += 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        edges, n = defaultdict(list), len(arr)\\n        for i in range(n):\\n            edges[arr[i]].append(i)\\n        queue, visited, steps = deque([0]), set([0]), 0\\n        while queue:\\n            for _ in range(len(queue)):\\n                idx = queue.popleft()\\n                if idx == n-1:\\n                    return steps\\n                for new_idx in [idx-1, idx+1] + edges.pop(arr[idx], []):\\n                    if 0 <= new_idx < n and new_idx not in visited:\\n                        if new_idx == n-1:\\n                            return steps + 1\\n                        queue.append(new_idx)\\n                        visited.add(new_idx)\\n            steps += 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259647,
                "title": "c-simplest-solution-bfs-hash-table",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int, vector<int>> hashmap;\\n        int n = arr.size();\\n        for (int i=0; i<n; i++) hashmap[arr[i]].emplace_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        while (!q.empty()) {\\n            for (int size=q.size(); size>0; size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1) return steps;\\n                vector<int> &next = hashmap[arr[i]];\\n                next.emplace_back(i-1);\\n                next.emplace_back(i+1);\\n                for (auto &ind:next) {\\n                    if (ind >=0 && ind < n && !visited[ind]) {\\n                        visited[ind] = true;\\n                        q.push(ind);\\n                    }\\n                }\\n                hashmap[arr[i]].clear();\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        map<int, vector<int>> hashmap;\\n        int n = arr.size();\\n        for (int i=0; i<n; i++) hashmap[arr[i]].emplace_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        int steps = 0;\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        while (!q.empty()) {\\n            for (int size=q.size(); size>0; size--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1) return steps;\\n                vector<int> &next = hashmap[arr[i]];\\n                next.emplace_back(i-1);\\n                next.emplace_back(i+1);\\n                for (auto &ind:next) {\\n                    if (ind >=0 && ind < n && !visited[ind]) {\\n                        visited[ind] = true;\\n                        q.push(ind);\\n                    }\\n                }\\n                hashmap[arr[i]].clear();\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259450,
                "title": "golang-bfs",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc minJumps(arr []int) int {\\n    dict := make(map[int][]int)\\n    \\n    for id, num := range arr {\\n        dict[num] = append(dict[num], id)\\n    }\\n    \\n    visited := make([]bool , len(arr))\\n    queue := []int{0}\\n    visited[0] = true\\n    \\n    jumps := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            idx := queue[0]\\n            queue = queue[1:]            \\n            \\n            if idx == len(arr)-1 {\\n                return jumps\\n            }\\n            \\n            for _, next := range dict[arr[idx]] {\\n                if !visited[next] {\\n                    queue = append(queue, next)\\n                    visited[next] = true\\n                }\\n            }\\n            // Optimization we may check entries again and find it is already visited\\n            delete(dict, arr[idx])\\n            \\n            if idx != 0 && !visited[idx-1] {\\n                queue = append(queue, idx-1)\\n                visited[idx-1] = true\\n            }\\n            \\n            if idx+1 < len(arr) && !visited[idx+1] {\\n                queue = append(queue, idx+1)\\n                visited[idx+1] = true                \\n            }\\n        }\\n        jumps++\\n    }\\n    \\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minJumps(arr []int) int {\\n    dict := make(map[int][]int)\\n    \\n    for id, num := range arr {\\n        dict[num] = append(dict[num], id)\\n    }\\n    \\n    visited := make([]bool , len(arr))\\n    queue := []int{0}\\n    visited[0] = true\\n    \\n    jumps := 0\\n    for len(queue) > 0 {\\n        l := len(queue)\\n        for i := 0; i < l; i++ {\\n            idx := queue[0]\\n            queue = queue[1:]            \\n            \\n            if idx == len(arr)-1 {\\n                return jumps\\n            }\\n            \\n            for _, next := range dict[arr[idx]] {\\n                if !visited[next] {\\n                    queue = append(queue, next)\\n                    visited[next] = true\\n                }\\n            }\\n            // Optimization we may check entries again and find it is already visited\\n            delete(dict, arr[idx])\\n            \\n            if idx != 0 && !visited[idx-1] {\\n                queue = append(queue, idx-1)\\n                visited[idx-1] = true\\n            }\\n            \\n            if idx+1 < len(arr) && !visited[idx+1] {\\n                queue = append(queue, idx+1)\\n                visited[idx+1] = true                \\n            }\\n        }\\n        jumps++\\n    }\\n    \\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3259091,
                "title": "easy-code-to-understand-bfs",
                "content": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        HashMap<Integer , ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i] , new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int dis = 0;\\n        boolean[] isVis = new boolean[arr.length];\\n        isVis[0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == arr.length - 1) return dis;\\n                for(int ele : map.get(arr[curNode])){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        queue.offer(ele);\\n                    }\\n                }\\n                map.put(arr[curNode] , new ArrayList<>()); // Removing the entry from Map,\\n\\t\\t\\t\\t//because these nodes will already be visited.\\n\\t\\t\\t\\t//For Why need to check for every same number , for loop will be active and this will cost \\n\\t\\t\\t\\t//us in time. That\\'s why I am removing the List after its first use :) \\n                if(curNode - 1 >= 0 && !isVis[curNode-1]){\\n                    isVis[curNode-1] = true;\\n                    queue.offer(curNode-1);\\n                }\\n                if(curNode + 1 < arr.length && !isVis[curNode+1]){\\n                    isVis[curNode + 1] = true;\\n                    queue.offer(curNode + 1);\\n                }\\n                \\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```\\n**If you found it helpful, please Upvote :))))**",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        HashMap<Integer , ArrayList<Integer>> map = new HashMap<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(!map.containsKey(arr[i])){\\n                map.put(arr[i] , new ArrayList<>());\\n            }\\n            map.get(arr[i]).add(i);\\n        }\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int dis = 0;\\n        boolean[] isVis = new boolean[arr.length];\\n        isVis[0] = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-- > 0){\\n                int curNode = queue.poll();\\n                if(curNode == arr.length - 1) return dis;\\n                for(int ele : map.get(arr[curNode])){\\n                    if(!isVis[ele]){\\n                        isVis[ele] = true;\\n                        queue.offer(ele);\\n                    }\\n                }\\n                map.put(arr[curNode] , new ArrayList<>()); // Removing the entry from Map,\\n\\t\\t\\t\\t//because these nodes will already be visited.\\n\\t\\t\\t\\t//For Why need to check for every same number , for loop will be active and this will cost \\n\\t\\t\\t\\t//us in time. That\\'s why I am removing the List after its first use :) \\n                if(curNode - 1 >= 0 && !isVis[curNode-1]){\\n                    isVis[curNode-1] = true;\\n                    queue.offer(curNode-1);\\n                }\\n                if(curNode + 1 < arr.length && !isVis[curNode+1]){\\n                    isVis[curNode + 1] = true;\\n                    queue.offer(curNode + 1);\\n                }\\n                \\n            }\\n            dis++;\\n        }\\n        return -1;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259037,
                "title": "swift-breadth-first-search-beats-100-memory-runtime",
                "content": "# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N + K*log(K)), where N is the length of the input vector nums and K is the number of distinct elements in the input vector.\\n\\n- Space complexity:\\nThe space complexity of the code is O(N) because we use a map m to store the indexes of each element, and a queue q to implement BFS. We also use a vector vis to keep track of visited indexes. All these data structures require O(N) space in the worst case.\\n\\n# Code\\n```\\nclass Solution {\\n    func minJumps(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var m = [Int: [Int]]()\\n        var vis = Array(repeating: 0, count: n)\\n        \\n        for i in 0..<n {\\n            m[nums[i], default: []].append(i)\\n        }\\n        \\n        var q = [Int]()\\n        q.append(0)\\n        vis[0] = 1\\n        var f = false\\n        var c = 0\\n        \\n        while !q.isEmpty {\\n            let sz = q.count\\n            for _ in 0..<sz {\\n                let i = q.removeFirst()\\n                if i == n-1 {\\n                    f = true\\n                    break\\n                }\\n                if i+1 < n && vis[i+1] == 0 {\\n                    q.append(i+1)\\n                    vis[i+1] = 1\\n                }\\n                if i-1 >= 0 && vis[i-1] == 0 {\\n                    q.append(i-1)\\n                    vis[i-1] = 1\\n                }\\n                if let indexes = m[nums[i]], !indexes.isEmpty {\\n                    for x in indexes {\\n                        if vis[x] == 0 {\\n                            q.append(x)\\n                            vis[x] = 1\\n                        }\\n                    }\\n                    m[nums[i]] = nil\\n                }\\n            }\\n            if f { break }\\n            else { c += 1 }\\n        }\\n        return c\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minJumps(_ nums: [Int]) -> Int {\\n        let n = nums.count\\n        var m = [Int: [Int]]()\\n        var vis = Array(repeating: 0, count: n)\\n        \\n        for i in 0..<n {\\n            m[nums[i], default: []].append(i)\\n        }\\n        \\n        var q = [Int]()\\n        q.append(0)\\n        vis[0] = 1\\n        var f = false\\n        var c = 0\\n        \\n        while !q.isEmpty {\\n            let sz = q.count\\n            for _ in 0..<sz {\\n                let i = q.removeFirst()\\n                if i == n-1 {\\n                    f = true\\n                    break\\n                }\\n                if i+1 < n && vis[i+1] == 0 {\\n                    q.append(i+1)\\n                    vis[i+1] = 1\\n                }\\n                if i-1 >= 0 && vis[i-1] == 0 {\\n                    q.append(i-1)\\n                    vis[i-1] = 1\\n                }\\n                if let indexes = m[nums[i]], !indexes.isEmpty {\\n                    for x in indexes {\\n                        if vis[x] == 0 {\\n                            q.append(x)\\n                            vis[x] = 1\\n                        }\\n                    }\\n                    m[nums[i]] = nil\\n                }\\n            }\\n            if f { break }\\n            else { c += 1 }\\n        }\\n        return c\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259008,
                "title": "c-solution-bfs-beats-97-of-other-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1])\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }\\n                if (currIdx - 1 >= 0 && !visited[currIdx - 1]) \\n                {\\n                    visited[currIdx - 1] = true;\\n                    q.push(currIdx - 1);\\n                }\\n                for (int newIdx : mp[arr[currIdx]])  \\n                {                                 \\n                    if (!visited[newIdx]) \\n                    {\\n                        visited[newIdx] = true;\\n                        q.push(newIdx);\\n                    }\\n                }\\n                mp[arr[currIdx]].clear();    \\n            }\\n            steps++;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        unordered_map<int, vector<int>>mp;\\n        for (int i = 0; i < n; i++) mp[arr[i]].push_back(i);\\n        \\n        queue<int>q;\\n        vector<bool>visited(n, false);\\n        q.push(0);\\n        int steps = 0;\\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            while(size--)\\n            {\\n                int currIdx = q.front();\\n                q.pop();\\n                if (currIdx == n - 1) return steps;\\n                if (currIdx + 1 < n && !visited[currIdx + 1])\\n                {\\n                    visited[currIdx + 1] = true;\\n                    q.push(currIdx + 1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3258959,
                "title": "easy-implementation-bfs-using-queue-of-indices",
                "content": "$$intuition$$\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst make the graph properly. in this case using a adjacency list will be very very costly.\\nand will be approximately O(n^2) time complexity\\nso we abort that idea\\ninstead of that we make a unordered map of the values and the indices that have the same values as of that index.\\nit is more economical.\\nafter that it is just easy bfs implementation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe make a queue of pair of integers pair<int,int> in which implies that we are at the pair.second index at the pair.first time.\\nand then implement the bfs.\\nwe have to delete the used elements also accordingly because as the number of indices having the same value can be very high as well that is why we have to keep deleting the used rqdundant items. along with keeping a proper visited array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n       \\n        unordered_map<int,set<int>>adj;\\n        for(int i=0;i<arr.size();i++){\\n            adj[arr[i]].insert(i);\\n        }\\n      \\n      \\n      queue<pair<int,int>>q;\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        q.push({0,0});\\n        int ans=1e9;\\n        while(!q.empty()){\\n            auto data=q.front();\\n            int currtime=data.first;\\n            int currind=data.second;\\n           \\n            vis[currind]=1;\\n            q.pop();\\n\\n            if(currind==n-1) {\\n              ans=min(ans,currtime);\\n            }\\n            if(currind+1<n && !vis[currind+1]){\\n                q.push({currtime+1,currind+1});\\n            }\\n             if(currind-1>=0 && !vis[currind-1]){\\n                q.push({currtime+1,currind-1});\\n            }\\n            for(auto &it:adj[arr[currind]]){\\n                if(!vis[it]){\\n                    q.push({currtime+1,it});\\n                }\\n            }\\n           adj[arr[currind]].clear();\\n        \\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n=arr.size();\\n       \\n        unordered_map<int,set<int>>adj;\\n        for(int i=0;i<arr.size();i++){\\n            adj[arr[i]].insert(i);\\n        }\\n      \\n      \\n      queue<pair<int,int>>q;\\n        vector<int>vis(n,0);\\n        vis[0]=1;\\n        q.push({0,0});\\n        int ans=1e9;\\n        while(!q.empty()){\\n            auto data=q.front();\\n            int currtime=data.first;\\n            int currind=data.second;\\n           \\n            vis[currind]=1;\\n            q.pop();\\n\\n            if(currind==n-1) {\\n              ans=min(ans,currtime);\\n            }\\n            if(currind+1<n && !vis[currind+1]){\\n                q.push({currtime+1,currind+1});\\n            }\\n             if(currind-1>=0 && !vis[currind-1]){\\n                q.push({currtime+1,currind-1});\\n            }\\n            for(auto &it:adj[arr[currind]]){\\n                if(!vis[it]){\\n                    q.push({currtime+1,it});\\n                }\\n            }\\n           adj[arr[currind]].clear();\\n        \\n        }\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258893,
                "title": "c-bfs-intuition-explained",
                "content": "# Intuition\\nAfter reading the question first thing that came in my mind is that we have to store the indexes of same value in a map. Then after giving some more time to problem, I concluded that our map will work as a graph and therefore we can do a BFS on it.\\n\\n# Approach\\nCreate a map and store the indexes of the element. \\nLike arr = [1,2,1] \\nthen our map will look like this: \\n1: 0,2 this means element 1 is present at 0th index and 2nd index.\\n2: 1\\nNow do a simple BFS.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        int ans = INT_MAX;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{arr[0],0}}); // {count,{arr[i],i}}\\n        vector<int> vis(n,0);\\n        vis[0] = 1;\\n\\n        while(!q.empty())\\n        {\\n            int count = q.front().first;\\n            int num = q.front().second.first;\\n            int idx = q.front().second.second;\\n            q.pop();\\n            vis[idx] = 1;\\n            if(idx == n - 1)\\n            {\\n                //there can be many ways to reach the last index of the array, therefore store the minimum count or steps in the answer.\\n                ans = min(ans,count);\\n                continue;\\n            }\\n            if(mp.find(num) != mp.end())\\n            {\\n                //add the same elements in the queue which we have not visited.\\n                for(auto &it : mp[num])\\n                {\\n                    if(idx != it && !vis[it])\\n                    {\\n                        q.push({count + 1,{num,it}});\\n                        vis[it] = 1;\\n                    }\\n                }\\n                mp[num].clear();\\n            }\\n            // we also need to add arr[i + 1] and arr[i - 1] in our queue and make sure that add these element only if they are not visited.\\n            if(!vis[idx + 1])\\n            {\\n                q.push({count + 1,{arr[idx + 1],idx + 1}});\\n                vis[idx + 1] = 1;\\n            }\\n            if(idx > 0 && !vis[idx - 1])\\n            {\\n                q.push({count + 1,{arr[idx - 1],idx - 1}});\\n                vis[idx - 1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n == 1)\\n        {\\n            return 0;\\n        }\\n        unordered_map<int,vector<int>> mp;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        int ans = INT_MAX;\\n        queue<pair<int,pair<int,int>>> q;\\n        q.push({0,{arr[0],0}}); // {count,{arr[i],i}}\\n        vector<int> vis(n,0);\\n        vis[0] = 1;\\n\\n        while(!q.empty())\\n        {\\n            int count = q.front().first;\\n            int num = q.front().second.first;\\n            int idx = q.front().second.second;\\n            q.pop();\\n            vis[idx] = 1;\\n            if(idx == n - 1)\\n            {\\n                //there can be many ways to reach the last index of the array, therefore store the minimum count or steps in the answer.\\n                ans = min(ans,count);\\n                continue;\\n            }\\n            if(mp.find(num) != mp.end())\\n            {\\n                //add the same elements in the queue which we have not visited.\\n                for(auto &it : mp[num])\\n                {\\n                    if(idx != it && !vis[it])\\n                    {\\n                        q.push({count + 1,{num,it}});\\n                        vis[it] = 1;\\n                    }\\n                }\\n                mp[num].clear();\\n            }\\n            // we also need to add arr[i + 1] and arr[i - 1] in our queue and make sure that add these element only if they are not visited.\\n            if(!vis[idx + 1])\\n            {\\n                q.push({count + 1,{arr[idx + 1],idx + 1}});\\n                vis[idx + 1] = 1;\\n            }\\n            if(idx > 0 && !vis[idx - 1])\\n            {\\n                q.push({count + 1,{arr[idx - 1],idx - 1}});\\n                vis[idx - 1] = 1;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258799,
                "title": "bfs-cpp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Problem can be solved using simple bfs.\\n    Adjacent vertices of node i = [i+1, i-1, k] where arr[i] = arr[k];\\n    time[j] = Needs minimum time to reach possition j.\\n    We need to jump only if(time[i]+1 < time[j]) means the node j not explored yet.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = size(arr);\\n        map<int,vector<int>> graph;\\n        vector<int> time(n,1e9);\\n        queue<int> q;\\n        q.push(0); time[0] = 0;\\n        for(int i=0; i<n; i++) graph[arr[i]].push_back(i);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            auto & v = graph[arr[i]];\\n            v.push_back(i-1), v.push_back(i+1);\\n            for(auto & j : v){\\n                if(j>=0 && j<n && time[j] > time[i]+1) time[j] = time[i]+1, q.push(j);\\n            }\\n            v.clear();\\n        }\\n        return time[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = size(arr);\\n        map<int,vector<int>> graph;\\n        vector<int> time(n,1e9);\\n        queue<int> q;\\n        q.push(0); time[0] = 0;\\n        for(int i=0; i<n; i++) graph[arr[i]].push_back(i);\\n        while(!q.empty()){\\n            int i = q.front(); q.pop();\\n            auto & v = graph[arr[i]];\\n            v.push_back(i-1), v.push_back(i+1);\\n            for(auto & j : v){\\n                if(j>=0 && j<n && time[j] > time[i]+1) time[j] = time[i]+1, q.push(j);\\n            }\\n            v.clear();\\n        }\\n        return time[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258649,
                "title": "easy-method-using-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr):\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()  \\n        vstd_val = set()  \\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       \\n        queue.append(0)  \\n        while queue:\\n            for _ in range(len(queue)): \\n                ndx = queue.popleft()   \\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      \\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val]) \\n                    vstd_val.add(val)      \\n                if ndx < arr_l:   queue.append(ndx + 1)\\n                if ndx > 0:       queue.append(ndx - 1)\\n             \\n            st_nmb += 1   \\n        return -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr):\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()  \\n        vstd_val = set()  \\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       \\n        queue.append(0)  \\n        while queue:\\n            for _ in range(len(queue)): \\n                ndx = queue.popleft()   \\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      \\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val]) \\n                    vstd_val.add(val)      \\n                if ndx < arr_l:   queue.append(ndx + 1)\\n                if ndx > 0:       queue.append(ndx - 1)\\n             \\n            st_nmb += 1   \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258497,
                "title": "bfs-hashmap-solution-c-o-n-time-space-beats-87",
                "content": "# Proper BFS Solution written below\\n    Also DFS solution given but TLE (in Comments)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bfs(vector<int>&arr, int src, unordered_map<int,vector<int>>&pos, vector<bool>&vis){\\n        int n=arr.size();\\n        queue<int> q;\\n        vector<int> jumps(n,INT_MAX);\\n        q.push(src);\\n        jumps[src]=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(int j: pos[arr[u]]){\\n                if(!vis[j] && j!=u){\\n                    vis[j]=true;\\n                    jumps[j]=min(jumps[j], jumps[u]+1);\\n                    q.push(j);\\n                }\\n                else if(j==u) continue;\\n                else break;\\n\\n            }\\n            if(u-1>=0 && !vis[u-1]){\\n                jumps[u-1]=min(jumps[u-1], jumps[u]+1);\\n                q.push(u-1);\\n            }\\n            if(u+1<n && !vis[u+1]){\\n                jumps[u+1]=min(jumps[u+1], jumps[u]+1);\\n                q.push(u+1);\\n            }\\n            \\n        }\\n        return jumps[n-1];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> pos;\\n        for(int i=0; i<arr.size(); i++){\\n            pos[arr[i]].push_back(i);\\n        }\\n        vector<bool>  vis(arr.size(),false);\\n        // long long int ans=dfs(arr,0,pos,vis);\\n        int ans=bfs(arr,0,pos, vis);\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n    // long long int dfs(vector<int>&arr, int i, unordered_map<int,vector<int>>&pos,vector<bool>&vis){\\n    //     if(i>=arr.size() || i<0 || vis[i]) return INT_MAX;\\n    //     if(i==arr.size()-1) return 0;\\n    //     vis[i]=true;\\n    //     long long int a=dfs(arr,i+1,pos,vis);\\n    //     long long int b=dfs(arr,i-1,pos,vis);\\n    //     long long int x=INT_MAX;\\n    //     for(int j: pos[arr[i]]){\\n    //         if(!vis[j])\\n    //             x=min(x,dfs(arr,j,pos,vis));\\n    //     }\\n    //     vis[i]=false;\\n    //     return min(a,min(b,x))+1;\\n    // }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bfs(vector<int>&arr, int src, unordered_map<int,vector<int>>&pos, vector<bool>&vis){\\n        int n=arr.size();\\n        queue<int> q;\\n        vector<int> jumps(n,INT_MAX);\\n        q.push(src);\\n        jumps[src]=0;\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(int j: pos[arr[u]]){\\n                if(!vis[j] && j!=u){\\n                    vis[j]=true;\\n                    jumps[j]=min(jumps[j], jumps[u]+1);\\n                    q.push(j);\\n                }\\n                else if(j==u) continue;\\n                else break;\\n\\n            }\\n            if(u-1>=0 && !vis[u-1]){\\n                jumps[u-1]=min(jumps[u-1], jumps[u]+1);\\n                q.push(u-1);\\n            }\\n            if(u+1<n && !vis[u+1]){\\n                jumps[u+1]=min(jumps[u+1], jumps[u]+1);\\n                q.push(u+1);\\n            }\\n            \\n        }\\n        return jumps[n-1];\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> pos;\\n        for(int i=0; i<arr.size(); i++){\\n            pos[arr[i]].push_back(i);\\n        }\\n        vector<bool>  vis(arr.size(),false);\\n        // long long int ans=dfs(arr,0,pos,vis);\\n        int ans=bfs(arr,0,pos, vis);\\n        return ans>=INT_MAX?-1:ans;\\n    }\\n    // long long int dfs(vector<int>&arr, int i, unordered_map<int,vector<int>>&pos,vector<bool>&vis){\\n    //     if(i>=arr.size() || i<0 || vis[i]) return INT_MAX;\\n    //     if(i==arr.size()-1) return 0;\\n    //     vis[i]=true;\\n    //     long long int a=dfs(arr,i+1,pos,vis);\\n    //     long long int b=dfs(arr,i-1,pos,vis);\\n    //     long long int x=INT_MAX;\\n    //     for(int j: pos[arr[i]]){\\n    //         if(!vis[j])\\n    //             x=min(x,dfs(arr,j,pos,vis));\\n    //     }\\n    //     vis[i]=false;\\n    //     return min(a,min(b,x))+1;\\n    // }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258441,
                "title": "c-bfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> m;\\n        int n = size(arr);\\n        for (int i = 0; i < n; ++i)\\n            m[arr[i]].push_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int sz = size(q);\\n            while (sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1)\\n                    return ans;\\n                if (i+1 < n && !visited[i+1]) {\\n                    q.push(i+1);\\n                    visited[i+1] = true;\\n                }\\n                if (i-1 >= 0 && !visited[i-1]) {\\n                    q.push(i-1);\\n                    visited[i-1] = true;\\n                }\\n                for (int j: m[arr[i]]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n                m[arr[i]].clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> m;\\n        int n = size(arr);\\n        for (int i = 0; i < n; ++i)\\n            m[arr[i]].push_back(i);\\n        queue<int> q;\\n        q.push(0);\\n        vector<bool> visited(n);\\n        visited[0] = true;\\n        int ans = 0;\\n        while (!q.empty()) {\\n            int sz = size(q);\\n            while (sz--) {\\n                int i = q.front();\\n                q.pop();\\n                if (i == n-1)\\n                    return ans;\\n                if (i+1 < n && !visited[i+1]) {\\n                    q.push(i+1);\\n                    visited[i+1] = true;\\n                }\\n                if (i-1 >= 0 && !visited[i-1]) {\\n                    q.push(i-1);\\n                    visited[i-1] = true;\\n                }\\n                for (int j: m[arr[i]]) {\\n                    if (!visited[j]) {\\n                        q.push(j);\\n                        visited[j] = true;\\n                    }\\n                }\\n                m[arr[i]].clear();\\n            }\\n            ++ans;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258023,
                "title": "java-easy-explained-beginner-friendly",
                "content": "- The algorithm used in the code is based on Breadth First Search (BFS). The basic idea is to traverse the graph level by level, starting from the source node, and to keep track of the nodes visited so far. In this problem, the graph is represented by an array where each element is a list of indices of other elements that can be reached from it.\\n\\n- The algorithm maintains a queue of nodes to be visited next. Initially, the source node is added to the queue with a distance of 0. In each iteration, the algorithm removes a node from the front of the queue, and for each neighbor of the node that has not been visited yet, it adds the neighbor to the queue with a distance of one more than the distance of the current node.\\n\\n- In this particular implementation, the queue is implemented as a LinkedList, which provides O(1) time complexity for both adding and removing elements. The visited nodes are marked using a boolean array, which also provides O(1) time complexity for checking whether a node has been visited or not.\\n\\n- To optimize the algorithm further, the code uses a HashMap to keep track of the indices of elements with the same value. This avoids the need to scan the entire array to find all elements with the same value, which would have a time complexity of O(n).\\n\\n- Finally, the algorithm returns the distance to the last element of the array, which is the target node.\\n\\n- Overall, the time complexity of the algorithm is O(n), where n is the number of elements in the array, since each element is visited at most once. The space complexity is also O(n), since the queue and the visited array both require O(n) space. The additional space used by the HashMap is at most O(kn), where k is the maximum number of elements with the same value in the array. However, in practice, k is usually much smaller than n, so the overall space complexity is still O(n).\\n- PLEASE UPVOTE IT . THANK YOU\\n\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int jumps = 0;\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                if (cur == n - 1) {\\n                    return jumps;\\n                }\\n                List<Integer> nextPositions = map.get(arr[cur]);\\n                nextPositions.add(cur - 1);\\n                nextPositions.add(cur + 1);\\n                for (int next : nextPositions) {\\n                    if (next >= 0 && next < n && !visited[next]) {\\n                        visited[next] = true;\\n                        queue.offer(next);\\n                    }\\n                }\\n                nextPositions.clear();\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], k -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        int jumps = 0;\\n        boolean[] visited = new boolean[n];\\n        visited[0] = true;\\n        \\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int cur = queue.poll();\\n                if (cur == n - 1) {\\n                    return jumps;\\n                }\\n                List<Integer> nextPositions = map.get(arr[cur]);\\n                nextPositions.add(cur - 1);\\n                nextPositions.add(cur + 1);\\n                for (int next : nextPositions) {\\n                    if (next >= 0 && next < n && !visited[next]) {\\n                        visited[next] = true;\\n                        queue.offer(next);\\n                    }\\n                }\\n                nextPositions.clear();\\n            }\\n            jumps++;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257976,
                "title": "bfs-detailed-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDDD\\uD835\\uDDEE\\uD835\\uDE03\\uD835\\uDDEE\\uD835\\uDDE6\\uD835\\uDDF0\\uD835\\uDDFF\\uD835\\uDDF6\\uD835\\uDDFD\\uD835\\uDE01 | \\uD835\\uDDE6\\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDF2 \\uD835\\uDDE9\\uD835\\uDDF6\\uD835\\uDDF1\\uD835\\uDDF2\\uD835\\uDDFC \\uD835\\uDDE6\\uD835\\uDDFC\\uD835\\uDDF9\\uD835\\uDE02\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB | \\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/dOYfnnBxb-s\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar minJumps = function(arr) {\\n    let n = arr.length\\n    let map = new Map()\\n    for (let i = 0; i < n; i++) {\\n        let array = []\\n        if (map.has(arr[i])) array = map.get(arr[i])\\n        array.push(i)\\n        map.set(arr[i], array)\\n    }\\n\\n    let visited = new Set()\\n    let queue = [[0,0]]\\n    visited.add(0)\\n\\n    while (queue.length) {\\n        let [cur, step] = queue.shift()\\n        if (cur == n-1) return step\\n\\n        if (cur + 1 < n && !visited.has(cur+1)) {\\n            queue.push([cur+1, step+1])\\n            visited.add(cur+1)\\n        }\\n\\n        if (cur - 1 >= 0 && !visited.has(cur-1)) {\\n            queue.push([cur-1, step+1])\\n            visited.add(cur-1)\\n        }\\n        if (!map.has(arr[cur])) continue\\n        for (let idx of map.get(arr[cur])) {\\n            if (!visited.has(idx) && idx != cur) {\\n                queue.push([idx, step+1])\\n                visited.add(idx)\\n            }\\n        }  \\n\\n        map.delete(arr[cur])      \\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar minJumps = function(arr) {\\n    let n = arr.length\\n    let map = new Map()\\n    for (let i = 0; i < n; i++) {\\n        let array = []\\n        if (map.has(arr[i])) array = map.get(arr[i])\\n        array.push(i)\\n        map.set(arr[i], array)\\n    }\\n\\n    let visited = new Set()\\n    let queue = [[0,0]]\\n    visited.add(0)\\n\\n    while (queue.length) {\\n        let [cur, step] = queue.shift()\\n        if (cur == n-1) return step\\n\\n        if (cur + 1 < n && !visited.has(cur+1)) {\\n            queue.push([cur+1, step+1])\\n            visited.add(cur+1)\\n        }\\n\\n        if (cur - 1 >= 0 && !visited.has(cur-1)) {\\n            queue.push([cur-1, step+1])\\n            visited.add(cur-1)\\n        }\\n        if (!map.has(arr[cur])) continue\\n        for (let idx of map.get(arr[cur])) {\\n            if (!visited.has(idx) && idx != cur) {\\n                queue.push([idx, step+1])\\n                visited.add(idx)\\n            }\\n        }  \\n\\n        map.delete(arr[cur])      \\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3257883,
                "title": "python-clear-the-visited-index-save-my-day",
                "content": "This is a standard BFS problem. \\n\\nHowever, we can get TLE without one trick below:\\n```\\n# clear the transport as we have already visited all the index in the list\\ntransport_map[arr[cur_idx]].clear()\\n```\\n\\nAfter we visited all the connected index, we need to clear this hash map. Otherwise, we will check the same index again and again which causes TLE.\\n\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # try BFS\\n        # there exits a transport from A to B if A == B\\n        transport_map = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            transport_map[num].append(idx)\\n        \\n        len_a = len(arr)\\n        target = len_a - 1\\n        queue = collections.deque([(0, 0)])\\n        visited = {0,}\\n        while queue:\\n            cur_idx, step = queue.popleft()\\n            if cur_idx == target:\\n                return step\\n            \\n            for nstep in [1, -1]:\\n                nidx = cur_idx + nstep\\n                if nidx >= 0 and nidx < len_a and nidx not in visited:\\n                    queue.append((nidx, step + 1))\\n                    visited.add(nidx)\\n                \\n            if arr[cur_idx] in transport_map:\\n                for nidx in transport_map[arr[cur_idx]]:\\n                    if nidx not in visited:\\n                        queue.append((nidx, step + 1))\\n                        visited.add(nidx)\\n                # clear the transport as we have already visited all the index in the list\\n                transport_map[arr[cur_idx]].clear()\\n                \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\n# clear the transport as we have already visited all the index in the list\\ntransport_map[arr[cur_idx]].clear()\\n```\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        # try BFS\\n        # there exits a transport from A to B if A == B\\n        transport_map = collections.defaultdict(list)\\n        for idx, num in enumerate(arr):\\n            transport_map[num].append(idx)\\n        \\n        len_a = len(arr)\\n        target = len_a - 1\\n        queue = collections.deque([(0, 0)])\\n        visited = {0,}\\n        while queue:\\n            cur_idx, step = queue.popleft()\\n            if cur_idx == target:\\n                return step\\n            \\n            for nstep in [1, -1]:\\n                nidx = cur_idx + nstep\\n                if nidx >= 0 and nidx < len_a and nidx not in visited:\\n                    queue.append((nidx, step + 1))\\n                    visited.add(nidx)\\n                \\n            if arr[cur_idx] in transport_map:\\n                for nidx in transport_map[arr[cur_idx]]:\\n                    if nidx not in visited:\\n                        queue.append((nidx, step + 1))\\n                        visited.add(nidx)\\n                # clear the transport as we have already visited all the index in the list\\n                transport_map[arr[cur_idx]].clear()\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257809,
                "title": "readable-code-c-simple-bfs-solution-using-dictionary-hashset-and-queue",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n    {\\n        public int MinJumps(int[] arr)\\n        {\\n            var moveDict = new Dictionary<int, HashSet<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                if (!moveDict.ContainsKey(arr[i]))\\n                {\\n                    moveDict[arr[i]] = new HashSet<int>();\\n                }\\n\\n                moveDict[arr[i]].Add(i);\\n            }\\n\\n            var visited = new bool[arr.Length];\\n            visited[0] = true;\\n            var queue = new Queue<(int, int)>();\\n            queue.Enqueue((0, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var (itemIndex, depth) = queue.Dequeue();\\n\\n                var currentItem = arr[itemIndex];\\n\\n                if (itemIndex == arr.Length - 1)\\n                {\\n                    return depth;\\n                }\\n\\n                if (arr[arr.Length - 1] == currentItem)\\n                {\\n                    return depth + 1;\\n                }\\n\\n                if (itemIndex > 0 && !visited[itemIndex - 1])\\n                {\\n                    visited[itemIndex - 1] = true;\\n                    queue.Enqueue((itemIndex - 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex - 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                if (itemIndex < arr.Length && !visited[itemIndex + 1])\\n                {\\n                    visited[itemIndex + 1] = true;\\n                    queue.Enqueue((itemIndex + 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex + 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                foreach (var numIndex in moveDict[currentItem])\\n                {\\n                    if (!visited[numIndex])\\n                    {\\n                        visited[numIndex] = true;\\n                        queue.Enqueue((numIndex, depth + 1));\\n\\n                        if (arr.Length - 1 == numIndex)\\n                        {\\n                            return depth + 1;\\n                        }\\n                    }\\n                }\\n\\n                moveDict[currentItem] = new HashSet<int>();\\n            }\\n\\n            return -1;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public int MinJumps(int[] arr)\\n        {\\n            var moveDict = new Dictionary<int, HashSet<int>>();\\n\\n            for (int i = 0; i < arr.Length; i++)\\n            {\\n                if (!moveDict.ContainsKey(arr[i]))\\n                {\\n                    moveDict[arr[i]] = new HashSet<int>();\\n                }\\n\\n                moveDict[arr[i]].Add(i);\\n            }\\n\\n            var visited = new bool[arr.Length];\\n            visited[0] = true;\\n            var queue = new Queue<(int, int)>();\\n            queue.Enqueue((0, 0));\\n\\n            while (queue.Count > 0)\\n            {\\n                var (itemIndex, depth) = queue.Dequeue();\\n\\n                var currentItem = arr[itemIndex];\\n\\n                if (itemIndex == arr.Length - 1)\\n                {\\n                    return depth;\\n                }\\n\\n                if (arr[arr.Length - 1] == currentItem)\\n                {\\n                    return depth + 1;\\n                }\\n\\n                if (itemIndex > 0 && !visited[itemIndex - 1])\\n                {\\n                    visited[itemIndex - 1] = true;\\n                    queue.Enqueue((itemIndex - 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex - 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                if (itemIndex < arr.Length && !visited[itemIndex + 1])\\n                {\\n                    visited[itemIndex + 1] = true;\\n                    queue.Enqueue((itemIndex + 1, depth + 1));\\n\\n                    if (arr.Length - 1 == itemIndex + 1)\\n                    {\\n                        return depth + 1;\\n                    }\\n                }\\n\\n                foreach (var numIndex in moveDict[currentItem])\\n                {\\n                    if (!visited[numIndex])\\n                    {\\n                        visited[numIndex] = true;\\n                        queue.Enqueue((numIndex, depth + 1));\\n\\n                        if (arr.Length - 1 == numIndex)\\n                        {\\n                            return depth + 1;\\n                        }\\n                    }\\n                }\\n\\n                moveDict[currentItem] = new HashSet<int>();\\n            }\\n\\n            return -1;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257797,
                "title": "php-solution-beats-100-at-runtime-and-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a Breadth-First Search (BFS) algorithm.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea behind using BFS is to consider the indices of the array as nodes in a graph and the valid jumps between indices as edges in the graph. We can start the BFS from index 0 and keep track of the minimum number of steps required to reach each index. We can terminate the BFS as soon as we reach the last index, since that will give us the minimum number of steps required to reach the end.\\n\\nDuring the BFS, we need to consider three types of jumps: forward jumps to the next index, backward jumps to the previous index, and jumps to indices with the same value. We can use a queue to keep track of the nodes to be visited, and a visited array to avoid visiting the same node multiple times.\\n\\nOne optimization we can make is to pre-process the input array and create a mapping of each value to its indices. This will allow us to quickly identify the indices that can be reached by jumping to a value, without having to search the entire array every time.\\n\\n# Complexity\\n- Time complexity: O(n + v), where n is the length of the input array `arr` and v is the number of distinct values in `arr`.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n + v)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function minJumps($arr) {\\n        $n = count($arr);\\n        if ($n == 1) {\\n            return 0;\\n        }\\n        // Create a mapping of each value to its indices\\n        $valueToIndices = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $value = $arr[$i];\\n            if (!isset($valueToIndices[$value])) {\\n                $valueToIndices[$value] = [];\\n            }\\n            $valueToIndices[$value][] = $i;\\n        }\\n        // Perform BFS starting from index 0\\n        $queue = new SplQueue();\\n        $queue->enqueue([0, 0]); // [index, steps]\\n        $visited = array_fill(0, $n, false);\\n        $visited[0] = true;\\n        while (!$queue->isEmpty()) {\\n            [$index, $steps] = $queue->dequeue();\\n            if ($index == $n - 1) {\\n                return $steps;\\n            }\\n            // Try jumping to the next index\\n            if ($index + 1 < $n && !$visited[$index + 1]) {\\n                $queue->enqueue([$index + 1, $steps + 1]);\\n                $visited[$index + 1] = true;\\n            }\\n            // Try jumping to the previous index\\n            if ($index - 1 >= 0 && !$visited[$index - 1]) {\\n                $queue->enqueue([$index - 1, $steps + 1]);\\n                $visited[$index - 1] = true;\\n            }\\n            // Try jumping to indices with the same value\\n            $value = $arr[$index];\\n            if (isset($valueToIndices[$value])) {\\n                foreach ($valueToIndices[$value] as $nextIndex) {\\n                    if ($nextIndex != $index && !$visited[$nextIndex]) {\\n                        $queue->enqueue([$nextIndex, $steps + 1]);\\n                        $visited[$nextIndex] = true;\\n                    }\\n                }\\n                unset($valueToIndices[$value]); // optimization to avoid redundant checks\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Array",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $arr\\n     * @return Integer\\n     */\\n    function minJumps($arr) {\\n        $n = count($arr);\\n        if ($n == 1) {\\n            return 0;\\n        }\\n        // Create a mapping of each value to its indices\\n        $valueToIndices = [];\\n        for ($i = 0; $i < $n; $i++) {\\n            $value = $arr[$i];\\n            if (!isset($valueToIndices[$value])) {\\n                $valueToIndices[$value] = [];\\n            }\\n            $valueToIndices[$value][] = $i;\\n        }\\n        // Perform BFS starting from index 0\\n        $queue = new SplQueue();\\n        $queue->enqueue([0, 0]); // [index, steps]\\n        $visited = array_fill(0, $n, false);\\n        $visited[0] = true;\\n        while (!$queue->isEmpty()) {\\n            [$index, $steps] = $queue->dequeue();\\n            if ($index == $n - 1) {\\n                return $steps;\\n            }\\n            // Try jumping to the next index\\n            if ($index + 1 < $n && !$visited[$index + 1]) {\\n                $queue->enqueue([$index + 1, $steps + 1]);\\n                $visited[$index + 1] = true;\\n            }\\n            // Try jumping to the previous index\\n            if ($index - 1 >= 0 && !$visited[$index - 1]) {\\n                $queue->enqueue([$index - 1, $steps + 1]);\\n                $visited[$index - 1] = true;\\n            }\\n            // Try jumping to indices with the same value\\n            $value = $arr[$index];\\n            if (isset($valueToIndices[$value])) {\\n                foreach ($valueToIndices[$value] as $nextIndex) {\\n                    if ($nextIndex != $index && !$visited[$nextIndex]) {\\n                        $queue->enqueue([$nextIndex, $steps + 1]);\\n                        $visited[$nextIndex] = true;\\n                    }\\n                }\\n                unset($valueToIndices[$value]); // optimization to avoid redundant checks\\n            }\\n        }\\n        return -1; // unreachable\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929800,
                "title": "python-3-fast-95-easy-to-understand",
                "content": "![image.png](https://assets.leetcode.com/users/images/9d93c549-98f0-408a-9d6f-a2623aba7506_1671480630.9626029.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()    # 2 memorizations:   vstd_ndx - for visited indexes    \\n        vstd_val = set()    #                    vstd_val - for visited values  (arr[ndx])\\n        \\n        # create dictionary {val: [ndx_100, ndx_99 ...]}\\n        # we ordered indexes in descending order \\n        # so that we could reduce number of iterations\\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       # number of steps\\n        queue.append(0)  # start from index 0\\n        while queue:\\n            for _ in range(len(queue)): # iterate level by level\\n                ndx = queue.popleft()   # FIFO method: take index from the left (and add to the right)\\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      # add current index to visited set\\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val])  # add all indexes with the same value\\n                    vstd_val.add(val)       # add current value to visited set\\n                if ndx < arr_l:   queue.append(ndx + 1) # add index to the right\\n                if ndx > 0:       queue.append(ndx - 1) # add index to the left\\n             \\n            st_nmb += 1   # increase number of steps by one\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        queue    = deque()  \\n        dct      = defaultdict(list)\\n        vstd_ndx = set()    # 2 memorizations:   vstd_ndx - for visited indexes    \\n        vstd_val = set()    #                    vstd_val - for visited values  (arr[ndx])\\n        \\n        # create dictionary {val: [ndx_100, ndx_99 ...]}\\n        # we ordered indexes in descending order \\n        # so that we could reduce number of iterations\\n        arr_l = len(arr)\\n        for i in range(arr_l - 1, -1, -1):\\n            dct[arr[i]].append(i)\\n        \\n        st_nmb = 0       # number of steps\\n        queue.append(0)  # start from index 0\\n        while queue:\\n            for _ in range(len(queue)): # iterate level by level\\n                ndx = queue.popleft()   # FIFO method: take index from the left (and add to the right)\\n                \\n                if ndx in vstd_ndx:    continue\\n                if ndx == arr_l - 1:   return st_nmb\\n                vstd_ndx.add(ndx)      # add current index to visited set\\n\\n                val = arr[ndx]\\n                if val not in vstd_val:  \\n                    queue.extend(dct[val])  # add all indexes with the same value\\n                    vstd_val.add(val)       # add current value to visited set\\n                if ndx < arr_l:   queue.append(ndx + 1) # add index to the right\\n                if ndx > 0:       queue.append(ndx - 1) # add index to the left\\n             \\n            st_nmb += 1   # increase number of steps by one\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877943,
                "title": "bfs-detail-explanation-with-analysis-efficient-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs this is a minimum path problem, the first thing to click into our mind would be using **BFS**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will perform an interative bfs. But we have to be careful of recalculating the same steps. For this, we will need an array of **boolean[] visited** to keep track of the visited **indices**. Also, when iterating for same values, we will ignore that. For this reason, when the value is first calculated in the queue, we will remove all the indices of the same value element. This way we can make this problem efficient. I got TLE several times while solving this problem.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nUsing BFS would take time complexity of *O(n+k)*. Here, *n* is the number of elements and the *k* is the maximum edge connecting an element. In worst case, all the elements can be same. But as we are not calculating repeating elements, it is good to go. The time complexity will stay around *O(n)*.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAs we are keeping a queue and also Clearing it out. There won\\'t be all the *n* elements at one time in the queue. But we have also used an array of **boolean[] visited** which is of size *n*. So, the space complexity would be *O(n)*.\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                List<Integer> next = map.get(arr[idx]);\\n                next.add(idx-1); next.add(idx+1);\\n                for(int i : next){\\n                    if(i>=0 && i<len && !visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/58ea33a3-d47b-44a1-9a1e-7af583173d20_1670178091.0691743.png)\\n![image](https://assets.leetcode.com/users/images/0ad03c10-9b0d-4d2c-8451-bb5a171c70ff_1670178117.9879165.png)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int len = arr.length;\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i=0; i<len; i++){\\n            map.computeIfAbsent(arr[i], x -> new LinkedList<>()).add(i);\\n        }\\n        boolean[] visited = new boolean[len];\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(0);\\n        visited[0] = true;\\n        int stepsTaken = -1;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            stepsTaken++;\\n            while(size-->0){\\n                int idx = q.remove();\\n                if(idx==len-1)\\n                    return stepsTaken;\\n                List<Integer> next = map.get(arr[idx]);\\n                next.add(idx-1); next.add(idx+1);\\n                for(int i : next){\\n                    if(i>=0 && i<len && !visited[i]){\\n                        visited[i] = true;\\n                        q.offer(i);\\n                    }\\n                }\\n                map.get(arr[idx]).clear();\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839288,
                "title": "c-bfs-model-problem-as-the-graph-problem",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> graph;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i) {\\n            graph[arr[i]].push_back(i);\\n        }\\n        auto isValid = [&] (const int _n) {\\n            return (_n >= 0 && _n < n);  \\n        };\\n        //this problem can also be modeled as the graph problems\\n        //where the adjancent cells are\\n        //(i - 1), (i + 1) indices and all the indices where arr[i] is present\\n        int steps = 0;\\n        queue<int> q;\\n        //since we are already doing the BFS on \\n        //array indices, so dont need to create a graph out of it\\n        q.push(0);\\n        vector<bool> vis(n, 0);\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while(N--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == n - 1) return steps;\\n                for (int child: graph[arr[node]]) {\\n                    if (!vis[child]) {\\n                        q.push(child);\\n                        vis[child] = 1;\\n                    }\\n                }\\n                graph[arr[node]].clear();\\n                vis[node] = true;\\n                int dir[] = {-1, 1};\\n                for (int i = 0; i < 2; ++i) {\\n                    int _node = node + dir[i];\\n                    if (isValid(_node) && !vis[_node]) {\\n                        q.push(_node);\\n                        vis[_node] = 1;\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int, vector<int>> graph;\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i) {\\n            graph[arr[i]].push_back(i);\\n        }\\n        auto isValid = [&] (const int _n) {\\n            return (_n >= 0 && _n < n);  \\n        };\\n        //this problem can also be modeled as the graph problems\\n        //where the adjancent cells are\\n        //(i - 1), (i + 1) indices and all the indices where arr[i] is present\\n        int steps = 0;\\n        queue<int> q;\\n        //since we are already doing the BFS on \\n        //array indices, so dont need to create a graph out of it\\n        q.push(0);\\n        vector<bool> vis(n, 0);\\n        while(q.size() > 0) {\\n            int N = q.size();\\n            while(N--) {\\n                int node = q.front();\\n                q.pop();\\n                if (node == n - 1) return steps;\\n                for (int child: graph[arr[node]]) {\\n                    if (!vis[child]) {\\n                        q.push(child);\\n                        vis[child] = 1;\\n                    }\\n                }\\n                graph[arr[node]].clear();\\n                vis[node] = true;\\n                int dir[] = {-1, 1};\\n                for (int i = 0; i < 2; ++i) {\\n                    int _node = node + dir[i];\\n                    if (isValid(_node) && !vis[_node]) {\\n                        q.push(_node);\\n                        vis[_node] = 1;\\n                    }\\n                }\\n            }\\n            ++steps;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2815095,
                "title": "sketch-explains-better-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n![1871. Jump Game IV.png](https://assets.leetcode.com/users/images/cda2f5c0-384c-43a5-b752-72ba954e57ec_1668451790.7851596.png)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n> *Next indices* for index `i` are the indices that can be reached from index `i` by doing just one jump\\n\\n> index `i`\\'s next indices are:\\n>  1. index `i - 1`\\n>   2. index `i + 1`\\n>   3. all indices that have same value as index `i`\\n>   ** All these next indices have same minimum jumps = `dp[i] + 1` (assuming the next indices haven\\'t been processed already)\\n\\n> How to find the next indices `i` ?\\n    1.Create a Map `indices`: map each value to list of indices having same value\\n    2.Now the next indices of index `i` are `i+1`, `i-1`, and `indices.get(arr[i])`\\n\\n\\n1. Create a `dp[]` that stores minimum jumps needed for each index.\\n\\n3. Start by adding index `0` to the queue with current`jump = 0`\\n\\n4. Now for each index `i` in the queue do\\n    * poll `i` from the queue\\n    * `dp[i] = jump` and\\n    *  add the `i`\\'s next indices to the queue\\n    >**Important for O(n) and not getting TLE**:\\n    It is possible that `i`\\'s next indices are already in the queue. So adding it again makes no sense. So use a `visiting` boolean array or set  that tells you if it has been added in the queue already so you can avoid adding duplicates. \\n\\n5. Do `jump++`\\n\\n6. Repeat steps 4, 5 until queue is empty\\n7. Return `dp[n-1]`\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        boolean[] processed = new boolean[n]; // tells if dp[i] is calculated\\n        Set<Integer> visiting = new HashSet<>(); // for optimization. tells if arr[i] in queue\\n        Map<Integer, List<Integer>> indices = new HashMap<>(); // Map value to indices having same value\\n\\n        // construct the map\\n        for (int i = 0; i < n; i++) indices.computeIfAbsent(arr[i], (key) -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> positionsToProcess = new ArrayDeque<>();\\n        positionsToProcess.add(0);\\n\\n        // do BFS and each BFS level represents no of jumps.\\n        int jumps = 0;\\n        while (!positionsToProcess.isEmpty()) {\\n            int queueLength = positionsToProcess.size();\\n\\n            for (int i = 0; i < queueLength; i++) {\\n\\n                int position = positionsToProcess.poll();\\n                if (processed[position]) continue;\\n                dp[position] = jumps;\\n                processed[position] = true;\\n\\n                // add only those next jump indices that are not already in the queue\\n                if (position - 1 >= 0 && !visiting.contains(arr[position - 1]))\\n                    positionsToProcess.add(position - 1);\\n                if (position + 1 < n && !visiting.contains(arr[position + 1]))\\n                    positionsToProcess.add(position + 1);\\n                if (!visiting.contains(arr[position]))\\n                    positionsToProcess.addAll(indices.get(arr[position]));\\n\\n                visiting.add(arr[position]);\\n            }\\n\\n            jumps++;\\n        }\\n\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        int[] dp = new int[n];\\n        boolean[] processed = new boolean[n]; // tells if dp[i] is calculated\\n        Set<Integer> visiting = new HashSet<>(); // for optimization. tells if arr[i] in queue\\n        Map<Integer, List<Integer>> indices = new HashMap<>(); // Map value to indices having same value\\n\\n        // construct the map\\n        for (int i = 0; i < n; i++) indices.computeIfAbsent(arr[i], (key) -> new ArrayList<>()).add(i);\\n\\n        Queue<Integer> positionsToProcess = new ArrayDeque<>();\\n        positionsToProcess.add(0);\\n\\n        // do BFS and each BFS level represents no of jumps.\\n        int jumps = 0;\\n        while (!positionsToProcess.isEmpty()) {\\n            int queueLength = positionsToProcess.size();\\n\\n            for (int i = 0; i < queueLength; i++) {\\n\\n                int position = positionsToProcess.poll();\\n                if (processed[position]) continue;\\n                dp[position] = jumps;\\n                processed[position] = true;\\n\\n                // add only those next jump indices that are not already in the queue\\n                if (position - 1 >= 0 && !visiting.contains(arr[position - 1]))\\n                    positionsToProcess.add(position - 1);\\n                if (position + 1 < n && !visiting.contains(arr[position + 1]))\\n                    positionsToProcess.add(position + 1);\\n                if (!visiting.contains(arr[position]))\\n                    positionsToProcess.addAll(indices.get(arr[position]));\\n\\n                visiting.add(arr[position]);\\n            }\\n\\n            jumps++;\\n        }\\n\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2775990,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  \\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  \\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730977,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>vis;\\n    unordered_map<int,vector<int>>mp;\\n    int minJumps(vector<int>& arr) \\n    {\\n        //preprocessing\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n\\n        int steps=0;\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            for(int j=0;j<size;j++)\\n            {\\n               int i = q.front();\\n               q.pop();\\n\\n               vis.insert(i);\\n\\n               if(i==arr.size()-1)\\n               {\\n                  return steps;\\n               }\\n\\n                //i+1\\n               if((i+1)<arr.size() and vis.find(i+1)==vis.end())\\n               {\\n                  q.push(i+1);\\n                  vis.insert(i+1);\\n               }\\n               if((i-1)>=0 and vis.find(i-1)==vis.end())\\n               {\\n                  q.push(i-1);\\t\\n                  vis.insert(i-1);\\n               }\\t\\n               if(mp[arr[i]].size()>0)\\n               {\\n                  for(auto pos : mp[arr[i]])\\n                  {\\n                     if(vis.find(pos)==vis.end())\\n                     q.push(pos);\\n                  }  \\n                  mp[arr[i]].clear();\\n               }\\n               \\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_set<int>vis;\\n    unordered_map<int,vector<int>>mp;\\n    int minJumps(vector<int>& arr) \\n    {\\n        //preprocessing\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n\\n        queue<int>q;\\n        q.push(0);\\n\\n        int steps=0;\\n\\n        while(!q.empty())\\n        {\\n            int size=q.size();\\n\\n            for(int j=0;j<size;j++)\\n            {\\n               int i = q.front();\\n               q.pop();\\n\\n               vis.insert(i);\\n\\n               if(i==arr.size()-1)\\n               {\\n                  return steps;\\n               }\\n\\n                //i+1\\n               if((i+1)<arr.size() and vis.find(i+1)==vis.end())\\n               {\\n                  q.push(i+1);\\n                  vis.insert(i+1);\\n               }\\n               if((i-1)>=0 and vis.find(i-1)==vis.end())\\n               {\\n                  q.push(i-1);\\t\\n                  vis.insert(i-1);\\n               }\\t\\n               if(mp[arr[i]].size()>0)\\n               {\\n                  for(auto pos : mp[arr[i]])\\n                  {\\n                     if(vis.find(pos)==vis.end())\\n                     q.push(pos);\\n                  }  \\n                  mp[arr[i]].clear();\\n               }\\n               \\n            }\\n            steps++;\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730258,
                "title": "c-bfs-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  //map will store the index of duplicates\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  // {{steps,ele},idx}\\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>>mp;  //map will store the index of duplicates\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        vector<bool>vis(arr.size(),false);   \\n        \\n        int ans=INT_MAX;\\n        \\n        queue<pair<pair<int,int>,int>>q;  // {{steps,ele},idx}\\n        \\n        q.push({{arr[0],0},0});\\n        \\n        while(!q.empty())\\n        {\\n            int idx=q.front().second;\\n            int c=q.front().first.second;\\n            int ele=q.front().first.first;\\n            \\n            if(vis[idx]==false)\\n            {\\n                vis[idx]=true;\\n            }\\n            \\n            if(idx==arr.size()-1)\\n            {\\n                ans=min(ans,c);\\n            }\\n            \\n            q.pop();\\n            \\n            if(idx>0 and vis[idx-1]==false)\\n            {\\n                q.push({{arr[idx-1],c+1},idx-1});\\n                vis[idx-1]=true;\\n            }\\n            \\n            if(idx<arr.size()-1 and vis[idx+1]==false)\\n            {\\n                q.push({{arr[idx+1],c+1},idx+1});\\n                vis[idx+1]=true;\\n            }\\n            \\n            for(int j=0;j<mp[ele].size();j++)\\n            {\\n                if(mp[ele][j]!=idx and vis[mp[ele][j]]==false)\\n                {\\n                    q.push({{ele,c+1},mp[ele][j]});\\n                    vis[mp[ele][j]]=true;\\n                }\\n            }\\n            mp[ele].clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499078,
                "title": "jump-game-iv-c-bfs-with-explaination-96-17-faster",
                "content": "O(N) Time and Space Complexity\\n```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        // map stores all the indices of each unique element\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        // visited make sures that i always visit unvisited indices\\n        vector<bool> visited(n,false); \\n        queue<int> q;\\n        \\n        visited[0] = true; //visiting the first index \\n        q.push(0);\\n        \\n        int count = 0;\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            // traversing on size so that i can maintain the count of levels as we have to return the shortest path\\n            for (int i = 0;i < size;i++) \\n            {\\n                //visiting the index at front of queue\\n                int front = q.front();\\n                q.pop();\\n                visited[front] = true;\\n                \\n                //if front comes out to be last index then simply return true\\n                if (front == n - 1)\\n                {\\n                    return count;// Reached to last index\\n                }\\n                \\n                vector<int>& next = mp[arr[front]];\\n                if(front - 1 >= 0 && !visited[front-1])\\n                {\\n                    next.push_back(front - 1); \\n                }\\n                if(front + 1 < n && !visited[front+1])\\n                {\\n                    next.push_back(front + 1);\\n                }\\n                // next finally stores all the possible next steps from the front index\\n                \\n                //we travers on all the possible next steps \\n                for (int j : next) \\n                {\\n                    //if the next step we try to visit is already visited then there is no point in visiting the same visited node again\\n                    if (!visited[j]) \\n                    {\\n                        //mark the index as visited\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup mp[arr[i]]\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        // map stores all the indices of each unique element\\n        unordered_map<int, vector<int>> mp;\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[arr[i]].push_back(i);\\n        }\\n        \\n        // visited make sures that i always visit unvisited indices\\n        vector<bool> visited(n,false); \\n        queue<int> q;\\n        \\n        visited[0] = true; //visiting the first index \\n        q.push(0);\\n        \\n        int count = 0;\\n        while (!q.empty()) \\n        {\\n            int size = q.size();\\n            // traversing on size so that i can maintain the count of levels as we have to return the shortest path\\n            for (int i = 0;i < size;i++) \\n            {\\n                //visiting the index at front of queue\\n                int front = q.front();\\n                q.pop();\\n                visited[front] = true;\\n                \\n                //if front comes out to be last index then simply return true\\n                if (front == n - 1)\\n                {\\n                    return count;// Reached to last index\\n                }\\n                \\n                vector<int>& next = mp[arr[front]];\\n                if(front - 1 >= 0 && !visited[front-1])\\n                {\\n                    next.push_back(front - 1); \\n                }\\n                if(front + 1 < n && !visited[front+1])\\n                {\\n                    next.push_back(front + 1);\\n                }\\n                // next finally stores all the possible next steps from the front index\\n                \\n                //we travers on all the possible next steps \\n                for (int j : next) \\n                {\\n                    //if the next step we try to visit is already visited then there is no point in visiting the same visited node again\\n                    if (!visited[j]) \\n                    {\\n                        //mark the index as visited\\n                        visited[j] = true;\\n                        q.push(j);\\n                    }\\n                }\\n                next.clear(); // avoid later lookup mp[arr[i]]\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263873,
                "title": "easy-bfs-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        // putting elements in map\\n        for(int i=0;i<n;i++) {\\n            mp[arr[i]].push_back(i);\\n        }\\n        // bfs for shortest path\\n        queue<int> q;\\n        q.push(0); // start index\\n        vector<bool> visited(n, false);\\n        visited[0] = true;\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int curr = q.front(); q.pop();\\n                if(curr == n-1)\\n                    return cnt;\\n                if(curr-1 >= 0 && !visited[curr-1]) {\\n                    visited[curr-1] = true;\\n                    q.push(curr-1);\\n                }\\n                if(curr+1<n && !visited[curr+1]) {\\n                    visited[curr+1] = true;\\n                    q.push(curr+1);\\n                }\\n                if(mp.count(arr[curr])) {\\n                    // cout << curr << endl;\\n                    for(int indx : mp[arr[curr]]) {\\n                        if(indx != curr && !visited[indx]) {\\n                            visited[indx] = true;\\n                            q.push(indx);\\n                        }\\n                    }\\n                }\\n                mp.erase(arr[curr]); // to stop recomputing the on the same index \\n            }\\n            cnt++;\\n        }\\n        return -1; // return -1 if can\\'t reach end of the array\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        // putting elements in map\\n        for(int i=0;i<n;i++) {\\n            mp[arr[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2258178,
                "title": "java-all-jump-game-solutions",
                "content": "https://leetcode.com/problems/jump-game/\\n**55. Jump Game: `TC: / SC: O(n) / O(1)`**\\n```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-ii/\\n**45. Jump Game II: `TC: / SC: O(n) / O(1)`**\\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iii/\\n**1306. Jump Game III: `TC: / SC: O(n) / O(n)`**\\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-iv/\\n\\u2705**1345. Jump Game IV: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vi/submissions/\\n**1696. Jump Game VI: `TC: / SC: O(n) / O(n)`**\\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\\nhttps://leetcode.com/problems/jump-game-vii/submissions/\\n**1871. Jump Game VII: `TC: / SC: O(n) / O(n)`**\\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public boolean canJump(int[] nums) {\\n        int max_reach = 0;\\n        \\n        for(int i =0; i < nums.length; i++) {\\n            if(i > max_reach) return false;\\n            \\n            max_reach = Math.max(max_reach, i + nums[i]);\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    public int jump(int[] nums) {\\n        if(nums.length == 1) return 0;\\n        \\n        int temp = 0, max = 0, count = 0;\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > temp) {\\n                temp = max;\\n                max = 0;\\n                count++;\\n            }\\n            max = Math.max(max, nums[i] + i);\\n        }\\n        \\n        return count;\\n    }\\n```\n```\\n    public static boolean[] jumped;\\n    public boolean canReach(int[] arr, int start) {\\n        jumped = new boolean[arr.length];\\n        \\n        return check(arr, start);\\n    }\\n    public boolean check(int[] arr, int i) {\\n        if(i >= arr.length || i < 0 || jumped[i]) return false;\\n        if(arr[i] == 0) return true;\\n        jumped[i] = true;\\n        \\n        return check(arr, i + arr[i]) || check(arr, i - arr[i]);\\n    }\\n```\n```\\n    public int minJumps(int[] arr) {\\n        int steps = 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < arr.length; i++) \\n            map.computeIfAbsent(arr[i], li -> new ArrayList()).add(i);\\n        \\n        boolean[] jumped = new boolean[arr.length]; \\n        jumped[0] = true;\\n        Queue<Integer> q = new LinkedList<>(); \\n        q.offer(0);\\n        \\n        while(!q.isEmpty()) {\\n            for(int i = q.size(); i > 0; i--) {\\n                int temp = q.poll();\\n                if(temp == arr.length - 1) return steps;\\n                \\n                List<Integer> li = map.get(arr[temp]);\\n                if(temp != 0) li.add(temp - 1);\\n                if(temp != arr.length) li.add(temp + 1);\\n                \\n                for(int j : li) {\\n                    if(!jumped[j]) {\\n                        jumped[j] = true;\\n                        q.offer(j);\\n                    }\\n                }\\n                li.clear();\\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n```\n```\\n    public int maxResult(int[] nums, int k) {\\n        Deque<Integer> dq = new ArrayDeque<>();\\n        dq.offer(0);\\n        \\n        for(int i = 1; i < nums.length; i++) {\\n            nums[i] += nums[dq.peekFirst()];\\n            \\n            while(!dq.isEmpty() && nums[dq.peekLast()] <= nums[i])\\n                dq.pollLast();\\n            dq.offer(i);\\n            \\n            if(i - dq.peekFirst() >= k) dq.pollFirst();\\n        } \\n        \\n        return nums[nums.length - 1];\\n    }\\n```\n```\\n    public boolean canReach(String s, int minJump, int maxJump) {\\n        int n = s.length(), available = 0;\\n        if(s.charAt(n - 1) == \\'1\\') return false;\\n        \\n        boolean[] dp = new boolean[n];\\n        dp[0] = true;\\n        \\n        for(int i = 1; i < n; i++) {\\n            if(i >= minJump) available += dp[i - minJump] ? 1 : 0;\\n            if(i > maxJump) available -= dp[i - maxJump - 1] ? 1 : 0;\\n            \\n            dp[i] = available > 0 && s.charAt(i) == \\'0\\';\\n        }\\n        \\n        return dp[n - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2191176,
                "title": "java-clean-bfs",
                "content": "```\\nclass Solution {\\n    \\n    private boolean isValidNeighb(int neighb, int n, boolean[] visited) {\\n        if(neighb>=0 && neighb<n && !visited[neighb]) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void populateFreqMap(Map<Integer, List<Integer>> freqMap, int[] arr, int n) {\\n        for(int i = 0; i<n; i++) {\\n            int value = arr[i];\\n            freqMap.putIfAbsent(value, new ArrayList<>());\\n            freqMap.get(value).add(i);\\n        }        \\n    }\\n    \\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> freqMap = new HashMap<>();\\n        int n = arr.length;\\n        populateFreqMap(freqMap, arr, n);\\n                                \\n        Queue<Integer> bfs = new LinkedList<>();\\n        boolean[] visited = new boolean[n];  \\n        int distance = 0, destination = n-1; \\n        bfs.add(0);\\n        while(bfs.size() > 0) {\\n          \\n            int size = bfs.size();\\n            for(int i = 0; i<size; i++) {\\n                int front = bfs.poll();\\n                visited[front] = true;\\n                \\n                if(front == destination) {\\n                    return distance;\\n                }\\n                   \\n                int value = arr[front];\\n                List<Integer> neighbList = freqMap.get(value);\\n                neighbList.add(front-1);\\n                neighbList.add(front+1);\\n                \\n                for(Integer neighb : neighbList) {\\n                    if(isValidNeighb(neighb, n, visited)) {\\n                        bfs.add(neighb);\\n                    }\\n                }\\n                \\n                neighbList.clear(); // traverse graph of one value single time, otherwise time complexity will bo n2 when all elements are equal\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private boolean isValidNeighb(int neighb, int n, boolean[] visited) {\\n        if(neighb>=0 && neighb<n && !visited[neighb]) {\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private void populateFreqMap(Map<Integer, List<Integer>> freqMap, int[] arr, int n) {\\n        for(int i = 0; i<n; i++) {\\n            int value = arr[i];\\n            freqMap.putIfAbsent(value, new ArrayList<>());\\n            freqMap.get(value).add(i);\\n        }        \\n    }\\n    \\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> freqMap = new HashMap<>();\\n        int n = arr.length;\\n        populateFreqMap(freqMap, arr, n);\\n                                \\n        Queue<Integer> bfs = new LinkedList<>();\\n        boolean[] visited = new boolean[n];  \\n        int distance = 0, destination = n-1; \\n        bfs.add(0);\\n        while(bfs.size() > 0) {\\n          \\n            int size = bfs.size();\\n            for(int i = 0; i<size; i++) {\\n                int front = bfs.poll();\\n                visited[front] = true;\\n                \\n                if(front == destination) {\\n                    return distance;\\n                }\\n                   \\n                int value = arr[front];\\n                List<Integer> neighbList = freqMap.get(value);\\n                neighbList.add(front-1);\\n                neighbList.add(front+1);\\n                \\n                for(Integer neighb : neighbList) {\\n                    if(isValidNeighb(neighb, n, visited)) {\\n                        bfs.add(neighb);\\n                    }\\n                }\\n                \\n                neighbList.clear(); // traverse graph of one value single time, otherwise time complexity will bo n2 when all elements are equal\\n            }\\n            \\n            distance++;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099481,
                "title": "bfs-easy-solution",
                "content": "```\\nint minJumps(vector<int>& arr) {\\n if(arr.size()==1)return 0;\\n        map<int,vector<int>>m;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        \\n        int step=0;\\n       q.push(0);\\n        \\n       \\n        while(!q.empty()){\\n        step++;\\n            int si=q.size();\\n            for(int i=0;i<si;i++){\\n               int t=q.front();\\n                q.pop();\\n                \\n                if(t-1>=0 && m[arr[t-1]].size()>0){\\n                    q.push(t-1);\\n                }\\n                if(t+1<arr.size() && m[arr[t+1]].size()>0){\\n                    if(t+1==arr.size()-1)return step;\\n                    else q.push(t+1);\\n                }\\n                if(m[arr[t]].size()>0){\\n                    for(auto k:m[arr[t]]){\\n                        if(k != t){\\n                            if(k==arr.size()-1)return step;\\n                             else q.push(k);\\n                        }\\n                       \\n                    }\\n                }\\n                  m.erase(arr[t]);\\n            }\\n          \\n            \\n        }\\n        return step;\\n\\t\\t}\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nint minJumps(vector<int>& arr) {\\n if(arr.size()==1)return 0;\\n        map<int,vector<int>>m;\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]].push_back(i);\\n        }\\n        queue<int>q;\\n        \\n        int step=0;\\n       q.push(0);\\n        \\n       \\n        while(!q.empty()){\\n        step++;\\n            int si=q.size();\\n            for(int i=0;i<si;i++){\\n               int t=q.front();\\n                q.pop();\\n                \\n                if(t-1>=0 && m[arr[t-1]].size()>0){\\n                    q.push(t-1);\\n                }\\n                if(t+1<arr.size() && m[arr[t+1]].size()>0){\\n                    if(t+1==arr.size()-1)return step;\\n                    else q.push(t+1);\\n                }\\n                if(m[arr[t]].size()>0){\\n                    for(auto k:m[arr[t]]){\\n                        if(k != t){\\n                            if(k==arr.size()-1)return step;\\n                             else q.push(k);\\n                        }\\n                       \\n                    }\\n                }\\n                  m.erase(arr[t]);\\n            }\\n          \\n            \\n        }\\n        return step;\\n\\t\\t}\\n\\t\\t\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2085575,
                "title": "python-beginner-friendly-without-visited-set-efficient-solution",
                "content": "\\n```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        jump_queue = deque([[0, 0]])\\n        same_block_jump = defaultdict(list)\\n        \\n        for index in range(len(arr)):\\n            same_block_jump[arr[index]].append(index)\\n        \\n        while jump_queue:\\n            \\n            jump_index, jump_count = jump_queue.popleft()\\n        \\n            if jump_index == len(arr) - 1:\\n                return jump_count\\n            \\n            possible_jumps = [jump_index + 1, jump_index - 1, *same_block_jump[arr[jump_index]]]\\n\\n            for jump in possible_jumps:\\n                if arr[jump] != \\'0\\' and 0 <= jump < len(arr):\\n                    jump_queue.append([jump, jump_count + 1])\\n                    \\n            same_block_jump[arr[jump_index]] = []\\n            arr[jump_index] = \\'0\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        \\n        jump_queue = deque([[0, 0]])\\n        same_block_jump = defaultdict(list)\\n        \\n        for index in range(len(arr)):\\n            same_block_jump[arr[index]].append(index)\\n        \\n        while jump_queue:\\n            \\n            jump_index, jump_count = jump_queue.popleft()\\n        \\n            if jump_index == len(arr) - 1:\\n                return jump_count\\n            \\n            possible_jumps = [jump_index + 1, jump_index - 1, *same_block_jump[arr[jump_index]]]\\n\\n            for jump in possible_jumps:\\n                if arr[jump] != \\'0\\' and 0 <= jump < len(arr):\\n                    jump_queue.append([jump, jump_count + 1])\\n                    \\n            same_block_jump[arr[jump_index]] = []\\n            arr[jump_index] = \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908576,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        int tar = n - 1;\\n        \\n        // 3 connections, i -> i - 1, i + 1, and \\n        unordered_map<int, vector<int>> sameValList; // {values : nodes}\\n        for (int i = 0; i < n; i++) {\\n            sameValList[arr[i]].push_back(i); // indicies that have the same value\\n        }\\n        \\n        queue<int> bfsQ;\\n        vector<bool> memo(n, false);\\n        bfsQ.push(0);\\n        memo[0] = true;\\n        \\n        int res = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                int curr = bfsQ.front(); bfsQ.pop();\\n                if (curr == tar) return res;\\n                if (curr > 0 && !memo[curr - 1]) {\\n                    memo[curr - 1] = true;\\n                    bfsQ.push(curr - 1);\\n                }\\n                if (curr + 1 < n && !memo[curr + 1]) {\\n                    memo[curr + 1] = true;\\n                    bfsQ.push(curr + 1);\\n                }\\n                // can be O(n)\\n                for (int &eachConnect : sameValList[arr[curr]]) {\\n                    if (memo[eachConnect]) continue;\\n                    memo[eachConnect] = true;\\n                    bfsQ.push(eachConnect);\\n                }\\n                sameValList[arr[curr]].clear(); // important optimization, so we dont have to recheck these connections\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        int n = arr.size();\\n        int tar = n - 1;\\n        \\n        // 3 connections, i -> i - 1, i + 1, and \\n        unordered_map<int, vector<int>> sameValList; // {values : nodes}\\n        for (int i = 0; i < n; i++) {\\n            sameValList[arr[i]].push_back(i); // indicies that have the same value\\n        }\\n        \\n        queue<int> bfsQ;\\n        vector<bool> memo(n, false);\\n        bfsQ.push(0);\\n        memo[0] = true;\\n        \\n        int res = 0;\\n        while (!bfsQ.empty()) {\\n            int currQSize = bfsQ.size();\\n            while (currQSize-- > 0) {\\n                int curr = bfsQ.front(); bfsQ.pop();\\n                if (curr == tar) return res;\\n                if (curr > 0 && !memo[curr - 1]) {\\n                    memo[curr - 1] = true;\\n                    bfsQ.push(curr - 1);\\n                }\\n                if (curr + 1 < n && !memo[curr + 1]) {\\n                    memo[curr + 1] = true;\\n                    bfsQ.push(curr + 1);\\n                }\\n                // can be O(n)\\n                for (int &eachConnect : sameValList[arr[curr]]) {\\n                    if (memo[eachConnect]) continue;\\n                    memo[eachConnect] = true;\\n                    bfsQ.push(eachConnect);\\n                }\\n                sameValList[arr[curr]].clear(); // important optimization, so we dont have to recheck these connections\\n            }\\n            res++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898877,
                "title": "java-bfs-and-why-dfs-memoization-doesn-t-work",
                "content": "In this question **DFS** will work if used **without** memoization but will give TLE and if we use memoization, then we will get wrong answer because here, unlike the conventional Rat in a Maze type problems (where we are allowed to move only forward or down) we can jump back also, instead of only moving forward. This can cause the memoized values to be stored incorrectly. \\n\\nAn excellent explanation of this phenomenon can be found here: [Why Memoization is not working?](https://leetcode.com/problems/jump-game-iv/discuss/1694469/Why-DP-%2B-Memoization-is-not-working) \\nSee the comment of **@dudeandcat**\\n\\nThe problem can be successfully solved using BFS algorithm :\\n\\n```\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> equalValPosns = new HashMap<>();\\n\\n        // make map of num vs list of indices where num is present\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> posns = equalValPosns.getOrDefault(arr[i], new ArrayList<Integer>());\\n\\n            posns.add(i);\\n\\n            equalValPosns.put(arr[i], posns);\\n        }\\n        \\n        return minJumps(arr, equalValPosns);\\n    }\\n    \\n    private int minJumps(int[] arr, Map<Integer, List<Integer>> equalValPosns) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int blocker = Integer.MAX_VALUE, jumps = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            jumps++;\\n            \\n            int size = queue.size();\\n            \\n            while (size-- > 0) {\\n                int removedIdx = queue.remove();                \\n                \\n                if (removedIdx == arr.length - 1) {\\n                    return jumps;\\n                }\\n                    \\n                int valAtRemovedIdx = arr[removedIdx];\\n                \\n                if (valAtRemovedIdx != blocker) {\\n                    // block current index from being visited again\\n                    arr[removedIdx] = blocker;\\n\\n                    if (removedIdx > 0 && arr[removedIdx - 1] != blocker) {\\n                        queue.add(removedIdx - 1);\\n                    }\\n\\n                    if (removedIdx < arr.length - 1 && arr[removedIdx + 1] != blocker) {\\n                        queue.add(removedIdx + 1);\\n                    }\\n\\n                    for (int index : equalValPosns.get(valAtRemovedIdx)) {\\n                        if (arr[index] != blocker) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    \\n                    // to avoid iterating all the elements of list again if value is repeated\\n                    equalValPosns.put(valAtRemovedIdx, new ArrayList<>());\\n                }\\n            }\\n        }\\n        return jumps;\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    public int minJumps(int[] arr) {\\n        Map<Integer, List<Integer>> equalValPosns = new HashMap<>();\\n\\n        // make map of num vs list of indices where num is present\\n        for (int i = 0; i < arr.length; i++) {\\n            List<Integer> posns = equalValPosns.getOrDefault(arr[i], new ArrayList<Integer>());\\n\\n            posns.add(i);\\n\\n            equalValPosns.put(arr[i], posns);\\n        }\\n        \\n        return minJumps(arr, equalValPosns);\\n    }\\n    \\n    private int minJumps(int[] arr, Map<Integer, List<Integer>> equalValPosns) {\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(0);\\n        \\n        int blocker = Integer.MAX_VALUE, jumps = -1;\\n        \\n        while (!queue.isEmpty()) {\\n            jumps++;\\n            \\n            int size = queue.size();\\n            \\n            while (size-- > 0) {\\n                int removedIdx = queue.remove();                \\n                \\n                if (removedIdx == arr.length - 1) {\\n                    return jumps;\\n                }\\n                    \\n                int valAtRemovedIdx = arr[removedIdx];\\n                \\n                if (valAtRemovedIdx != blocker) {\\n                    // block current index from being visited again\\n                    arr[removedIdx] = blocker;\\n\\n                    if (removedIdx > 0 && arr[removedIdx - 1] != blocker) {\\n                        queue.add(removedIdx - 1);\\n                    }\\n\\n                    if (removedIdx < arr.length - 1 && arr[removedIdx + 1] != blocker) {\\n                        queue.add(removedIdx + 1);\\n                    }\\n\\n                    for (int index : equalValPosns.get(valAtRemovedIdx)) {\\n                        if (arr[index] != blocker) {\\n                            queue.add(index);\\n                        }\\n                    }\\n                    \\n                    // to avoid iterating all the elements of list again if value is repeated\\n                    equalValPosns.put(valAtRemovedIdx, new ArrayList<>());\\n                }\\n            }\\n        }\\n        return jumps;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821279,
                "title": "jump-game-iv-using-map-and-queue-efficient-solution",
                "content": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }\\n        \\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int step = 0;\\n        \\n        // Fill the map\\n        \\n        for (int i = 0; i < n; i++) {\\n            map.computeIfAbsent(arr[i], v -> new ArrayList<>()).add(i);\\n        }\\n        \\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.offer(0);\\n        \\n        while (!queue.isEmpty()) {\\n            step++;\\n            int size = queue.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                \\n                // Jump to j - 1\\n                \\n                int j = queue.poll();\\n                \\n                if (j - 1 >= 0 && map.containsKey(arr[j - 1])) {\\n                    \\n                    queue.offer(j - 1);\\n                }\\n                \\n                // Jump to j + 1\\n                \\n                if (j + 1 < n && map.containsKey(arr[j + 1])) {\\n                    \\n                    if (j + 1 == n - 1) {\\n                        \\n                        return step;\\n                    }\\n                    \\n                    queue.offer(j + 1);\\n                }\\n                \\n                // Jump to k --> arr[j] == arr[k]\\n                \\n                if (map.containsKey(arr[j])) {\\n                    \\n                    for (int k : map.get(arr[j])) {\\n                        \\n                        if (k != j) {\\n                            \\n                            if (k == n -1) {\\n                                \\n                                return step;\\n                            }\\n                            \\n                            queue.offer(k);\\n                        }\\n                    }\\n                }\\n                \\n                map.remove(arr[j]);\\n            }\\n        }\\n        \\n        return step;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minJumps(int[] arr) {\\n        int n = arr.length;\\n        if (n == 1) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1800091,
                "title": "bfs-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        int i,x;\\n        vector<int> dp(n,-1);\\n        for(i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        dp[0]=0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(x+1!=n && dp[x+1]==-1){\\n                dp[x+1]=dp[x]+1;\\n                q.push(x+1);\\n            }\\n            if(x!=0 && dp[x-1]==-1){\\n                dp[x-1]=dp[x]+1;\\n                q.push(x-1);\\n            }\\n            for(auto y: mp[arr[x]]){\\n                if(dp[y]==-1){\\n                    dp[y]=dp[x]+1;\\n                    q.push(y);\\n                }\\n            }\\n            mp.erase(arr[x]); //The first time we visit 7, [7,7,7,7,7,...] all the remaining 7 will be visited by next step, hence this can be removed\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,vector<int>> mp;\\n        int n = arr.size();\\n        int i,x;\\n        vector<int> dp(n,-1);\\n        for(i=0;i<n;i++){\\n            mp[arr[i]].push_back(i);\\n        }\\n        dp[0]=0;\\n        queue<int> q;\\n        q.push(0);\\n        \\n        while(!q.empty()){\\n            x = q.front();\\n            q.pop();\\n            if(x+1!=n && dp[x+1]==-1){\\n                dp[x+1]=dp[x]+1;\\n                q.push(x+1);\\n            }\\n            if(x!=0 && dp[x-1]==-1){\\n                dp[x-1]=dp[x]+1;\\n                q.push(x-1);\\n            }\\n            for(auto y: mp[arr[x]]){\\n                if(dp[y]==-1){\\n                    dp[y]=dp[x]+1;\\n                    q.push(y);\\n                }\\n            }\\n            mp.erase(arr[x]); //The first time we visit 7, [7,7,7,7,7,...] all the remaining 7 will be visited by next step, hence this can be removed\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775035,
                "title": "python-easy-to-read-and-understand-bfs",
                "content": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            d[val].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        q = [0]\\n        visited[0] = True\\n        ans = 0\\n        while q:\\n            for i in range(len(q)):\\n                ind = q.pop(0)\\n                #print(ind)\\n                if ind == n-1:\\n                    return ans\\n                if ind + 1 < n and visited[ind+1] == False:\\n                    visited[ind+1] = True\\n                    q.append(ind+1)\\n                if ind - 1 > 0 and visited[ind-1] == False:\\n                    visited[ind-1] = True\\n                    q.append(ind-1)\\n                for nei in d[arr[ind]]:\\n                    if visited[nei] == False:\\n                        visited[nei] = True\\n                        q.append(nei)\\n                del d[arr[ind]]\\n            ans += 1",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minJumps(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = defaultdict(list)\\n        for i, val in enumerate(arr):\\n            d[val].append(i)\\n        \\n        visited = [False for _ in range(n)]\\n        q = [0]\\n        visited[0] = True\\n        ans = 0\\n        while q:\\n            for i in range(len(q)):\\n                ind = q.pop(0)\\n                #print(ind)\\n                if ind == n-1:\\n                    return ans\\n                if ind + 1 < n and visited[ind+1] == False:\\n                    visited[ind+1] = True\\n                    q.append(ind+1)\\n                if ind - 1 > 0 and visited[ind-1] == False:\\n                    visited[ind-1] = True\\n                    q.append(ind-1)\\n                for nei in d[arr[ind]]:\\n                    if visited[nei] == False:\\n                        visited[nei] = True\\n                        q.append(nei)\\n                del d[arr[ind]]\\n            ans += 1",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1822069,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822061,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822197,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1573419,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822206,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822183,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566205,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822523,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1575545,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1565262,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822069,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822061,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822197,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1573419,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822206,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822183,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566205,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1822523,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1575545,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1565262,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "I\\'ve been solving LeetCode medium and hard questions for more than 7 days straight. I think it\\'s time for an \\'Easy\\' day so I can feel like a genius again :)."
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "weekend = hard"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "Question tag affects us more than the question itself, this one is kindof easy-medium but tag made us think it's HARD"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "yes\\n"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@nehabindal](/nehabindal) Agree"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I dunno, I found it quite tough (though that might be my lack of experience with BFS). It required a lot of optimisation for me. Looking at the top answers (in JS) they are all quite long and complex. I feel the Hard tag is warranted here. It was doable for me though, which a lot of hard problems are just not."
                    },
                    {
                        "username": "nehabindal",
                        "content": "i agree. they should remove q tags in my opinion.. causes unnecccesary bias and fear"
                    },
                    {
                        "username": "KevinFederline",
                        "content": "The accepted solutions are all BFS, but smart BFS taking some of the problem structure into account. In general, BFS can require time as much as the number of edges in the graph. If you take your graph to have vertex set equal to the indices of the list, with an edge between to vertices if you can jump from one index to the other, this graph could potentially have O(N^2) many edges. For example, suppose the first N-1 entries in the list are 0, and the last entry is 1. A naive BFS will traverse every edge in the corresponding graph, which is O(N^2) edges, resulting in TLE if N is large.\\n\\nThe upvoted solutions all get around this by basically noting that, once you arrive at a number, you can jump to every other index with the same number immediately. You can remember you\\'ve done this to avoid looking at edges between two indices with the same number ever again."
                    },
                    {
                        "username": "beardedone",
                        "content": "**Breath First Search** - Take a breath, then write some code..."
                    },
                    {
                        "username": "Gydronium",
                        "content": "Breath First Search - Take a breath, then search for solution in Solutions tab"
                    },
                    {
                        "username": "dumb_me",
                        "content": "tle gang !!!! \\uD83E\\uDD79"
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Gucci gang"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/jump-game-iv/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Breadth-First Search\n\n  \n**Approach 2:** Bidirectional BFS\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "arghyadas",
                        "content": "TLE on 22/33 \\uD83D\\uDE2D"
                    },
                    {
                        "username": "arghyadas",
                        "content": "[@kaichamp101](/kaichamp101) \\uD83E\\uDD72"
                    },
                    {
                        "username": "kaichamp101",
                        "content": "For me, 31/33 :("
                    },
                    {
                        "username": "dheerajchugh303",
                        "content": "Those who tried to solve the DP , mostly they made the following DP expression\\n\\nDP [i] = Min( dp[i-1],d[j]) +1 where j<I and A[j] =[i] \\nAfter that they optimizing the DP[i-1] \\n\\nDP[i-1] = DP[i]+1 < DP[i-1] ? DP[i]+1 : DP[i-1]; // Only updating one step back \\n\\n\\nBut they are not taking care of the condition they can jump back on the same number that\\u2019s why there solution is failing. \\nFor most of them test case having input array of length \\u2013 3549 is failing. \\n\\nThe solution of that test case is \\n\\n1.\\tPos = 0 \\nValue =7872\\nStep =0\\n\\n2.\\tPos = 1 \\nValue =8708\\nStep =1\\n\\n3.\\tPos = 3321\\nValue =8708\\nStep =2\\n\\n// From  above to below 6 steps will be taken\\n\\n4.\\tPos = 3327\\nValue =3656\\nStep =8\\n\\n\\n5.\\tPos = 3337\\nValue =3656\\nStep =9\\n\\n\\n6.\\tPos = 3336\\nValue =5510\\nStep =10\\n\\n// This is a backward jump, not addressed in most of the DP solution \\n7.\\tPos = 2715\\nValue =5510\\nStep =11\\n\\n8.\\tPos = 2716\\nValue =2340\\nStep =12\\n\\n// one more backward jump\\n9.\\tPos = 1805\\nValue =2340\\nStep =13\\n\\n// 3 steps in sequence\\n10.\\tPos = 1808\\nValue =-7610\\nStep =16\\n\\n11.\\tPos = 3537\\nValue =-7610\\nStep =17\\n\\n// after this all 13 steps in sequence \\n12.\\tPos = 3549\\nValue =1174\\nStep =30\\nThanks to https://leetcode.com/problems/jump-game-iv/discuss/989119/c%2B%2B-using-dp-ish-passes-every-test-cases , with the help of this solution I am able to zero what is the most common mistakes in DP.\\n\\nDue to this backward jump , DP is not feasible and BFS is a good solution.\\n"
                    },
                    {
                        "username": "sheepmeow",
                        "content": "**TLDR**\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\n\\n@qiuqiushasha said the following\\n> To be very concise, the reason is that the jumper can jump back. For easier jump game question, the jumper never can jump back.\\n\\n\\n\\n**Detailed Explanation**\\nFirst of all, we want to model the problem in a way that we understand. Let `i` be the current index we examine, it can only go to the following indicies: `i + 1, i - 1, list of indicies where for each j in the list arr[j] == arr[i]`. We can think of it as a graph, and the problem becomes `starting at source (index 0), find the shortest path to target (index arr.length - 1)`. \\nThere, the solution becomes clear, since the most efficienct algorithm for shortest path in graph is always BFS, with a time complexity of `O(n)`\\nWhy doesn\\'t DFS + memo work? I believe it is because of the result we cache may not be the optimal result (shortest path) in DFS, since DFS traverses nodes in **random** order, and we only cache the **first** result it find.\\nOf course, you can do this with DFS alone by traverse *ALL* paths and return the shortest, but it has exponential time complexity of O(k^n) where k is the number of neighbours a node have. In this problem, this solution will cause TLE.\\nI am still trying to find a concrete, human-readable example that fails my DFS + memo algorithm. Let me know if you\\'ve already found one!"
                    },
                    {
                        "username": "H_Dabas02",
                        "content": "For any index you make a call where we go to the previous index where you again make a call to the next index (the first index we were initially on), So they\\'ll keep calling each other and won\\'t terminate"
                    }
                ]
            },
            {
                "id": 1566001,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822748,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822510,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822712,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822098,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822689,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822553,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1822100,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 2019695,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1971643,
                "content": [
                    {
                        "username": "clarklong",
                        "content": "I spent a lot of time in this question (I worked on backtracking first, and then use dfs+memo), but didn\\'t work out. But I don\\'t know why we could\\'t use DFS + memo? it seems that people who post articles give the BFS idea. \\n**Can anyone provide DFS solution????**"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "A DFS solution won\\'t work for this problem, because it asks for the minimum number of jumps, which automatically rings a BFS bell. DFS assures you that there is a possible path, while BFS assures that the path taken is the minimum possible. That\\'s why BFS solutions are so recurrent here and DFS easily runs to TLE."
                    },
                    {
                        "username": "blondi12",
                        "content": "I tried many options, always TLE with DFS"
                    },
                    {
                        "username": "sk03167",
                        "content": "I blame you guys for trolling leetcode when they were giving easy, medium problems in feb. This is why we can\\'t have nice things. xD"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "If you use basic `BFS` with hashmap (or array) and stuck with `TLE`, consider  `clear`  the `hashmap[arr[i]]` after the first traverse  or using a flag or memorize array or something to mark that you visited every index has the same value `arr[i]` in the hashmap so you don't need to do that anymore. \nOne more thing you need to do to improve perfomance : using a `unordered_map` to access with O(1) instead a `map` cost O(log).\nSee the code below for example:\n```\n   for (int idx : idxMap[arr[i]]) {\n         if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n           }\n  }\n idxMap[arr[i]].clear();  //important\n```\nor no need to spend more to clear with a flag\n```\n //unordered_map<int, pair<bool, vector<int>>>idxMap;\n\nif (!idxMap[arr[i]].first) {\n    for (int m : idxMap[arr[i]].second) {\n       if (m != i && !visited[m]) {\n              q.push(m);\n              visited[m] = true;\n        }\n    }\n    idxMap[arr[i]].first = true;  //important\n }\n```\n"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "feels like a medium"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Question is Medium level BFS based problem, Only you should focus on is optimised way of making the adjacency list."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "**Solve previous jump games first**\\n\\n[55. Jump Game](https://leetcode.com/problems/jump-game/)\\n[45. Jump Game II](https://leetcode.com/problems/jump-game-ii/)\\n[1306. Jump Game III](https://leetcode.com/problems/jump-game-iii/)"
                    },
                    {
                        "username": "aitachii",
                        "content": "That was difficult to understand but it was fun. Might have to review this problem later."
                    },
                    {
                        "username": "orbuluh",
                        "content": "[C++ performance tip], say you have a map of `{value -> vector of indicies}`. And for a value, when you've good to mark those indices as visited, don't do\n\n```cpp\nyourMap.erase(value);\n```\n\ndo\n\n```cpp\nyourMap[value].clear()\n```\n\nAs clear only invalidate the element in your vector, so it won't waste time destructing the vector like when you do erase."
                    },
                    {
                        "username": "user0581xU",
                        "content": "Time Limit Exceeded ... 22 / 33 testcases passed\\n\\nWhat is going on? bfs search will cause exceeding time limit? "
                    },
                    {
                        "username": "__anu__",
                        "content": "My notes after solving this question :\\n\\n1. Very important and interesting question with  a twist\\n2. You will think that you will start with recursion and then memoize it and then use dp. Although your recursive solution will be correct and it will give TLE but memoize will give you wrong answer.\\n3. Memoization and dfs wouldn\\'t work here as at any point when you calculate the computed value it differs for different path that crosses via this point. As it might me minimum later for some other path crossing via this point.\\n4. BFS is the right approach. \\n5. Point to be noted that without clear() inside the bfs, it will give TLE as we don\\'t wish to check for repeated numbers. It takes an extra overhead to check if it is visited or not when in reality we have already added once in the queue and it is visited. ex - [7,7,7,7]"
                    }
                ]
            },
            {
                "id": 1883441,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1824205,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1824007,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823421,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823224,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823125,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823117,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823114,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1823056,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1822994,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "similar to word ladder \\nthis is hardT_T"
                    },
                    {
                        "username": "anant0211",
                        "content": "can someone explain how to handle these type of cases?\\n[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,77,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,1,1,1,1,1,1,1,1,1,1,1,11]"
                    },
                    {
                        "username": "Abodh5921",
                        "content": "bad luck can be any time after solving tis question i tried jump Game VI and VII \\nboth question giving TLE"
                    },
                    {
                        "username": "rohanhaldiya",
                        "content": "Why is this out of memory for testcases with all 7s and one 11?\\n```\\npublic class Solution {\\n    public int MinJumps(int[] arr) {\\n        Dictionary<int,HashSet<int>> dict = new();\\n        for(int i=0;i<arr.Length;i++){\\n            if(!dict.ContainsKey(arr[i])){\\n                dict.Add(arr[i],new HashSet<int>());\\n            }\\n            dict[arr[i]].Add(i);\\n            \\n        }\\n\\n        Queue<int> queue = new();\\n        queue.Enqueue(0);\\n        HashSet<int> visited = new();\\n        int steps=0;\\n        while(queue.Count>0){\\n            int size = queue.Count;\\n            for(int i=0;i<size;i++){\\n                var e = queue.Dequeue();\\n                //Console.WriteLine(e);\\n                if(e == arr.Length-1){\\n                    return steps;\\n                }\\n                if(visited.Contains(e))\\n                    continue;\\n                visited.Add(e);\\n                foreach(int index in dict[arr[e]]){\\n                    if(e==index)\\n                        continue;\\n                    if(!visited.Contains(index)){\\n                        queue.Enqueue(index);\\n                    }\\n                }\\n                if(e-1>=0 && !visited.Contains(e-1)){\\n                    queue.Enqueue(e-1);\\n                }\\n                if(e+1<arr.Length && !visited.Contains(e+1)){\\n                    queue.Enqueue(e+1);\\n                }\\n            }\\n            steps++;\\n        }\\n        return 0;\\n    }\\n}\\n```"
                    },
                    {
                        "username": "purple_Lion",
                        "content": "u should clear the hashset for all the previous values its having "
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "explained with intuition, dry run and live coding using BFS, just try and you won\\'t regret, also do comment your feedback https://youtu.be/td9HFMIUrZU"
                    },
                    {
                        "username": "_vishalverma",
                        "content": "Finally after 2 hours of trying I finally had to open the Editorial tab.\\nJust had to add one line to get from TLE to AC. :)"
                    },
                    {
                        "username": "native_element",
                        "content": "why not dfs?? "
                    },
                    {
                        "username": "slashtab",
                        "content": "This is the first time I have solved this type of problem all by myself bethought any hint. "
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "Why is it wrong? Can someone explain?!\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& arr,int i,unordered_map<int,int>& m,vector<int>& dp){\\n        if(i==arr.size()-1)return 0;\\n        if(i<0 or i>=arr.size())return 1e9;\\n        if(dp[i]!=-1)return 1e9;\\n        dp[i]=1;\\n        return min({1+f(arr,i+1,m,dp),1+f(arr,i-1,m,dp),1+f(arr,m[arr[i]],m,dp)});\\n    }\\n    int minJumps(vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        vector<int> dp(arr.size()+1,-1);\\n        for(int i=0;i<arr.size();i++){\\n            m[arr[i]]=i;\\n        }\\n        return f(arr,0,m,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "SuryaTejaswi2504",
                        "content": "[@slashtab](/slashtab) I am, look at the third argument in the min function, I\\'m using a map to go through the indices which have the same values as the current one.\\n"
                    },
                    {
                        "username": "slashtab",
                        "content": "You are going one index back, one index forward but not all the other index which has same value as the current value -- you\\'re at. does this help?"
                    },
                    {
                        "username": "goku20001",
                        "content": "Because it is not correct."
                    },
                    {
                        "username": "SatyamSingh_12",
                        "content": "What about another question, \\nWhere the 3rd condition is not present?\\n\\nwhere this is not a restriction\\nj where: arr[i] == arr[j] and i != j."
                    },
                    {
                        "username": "blondi12",
                        "content": "this task will not make sense, since the only way from 0 to the last index is i + 1"
                    }
                ]
            },
            {
                "id": 1822906,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822691,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822609,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822580,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822574,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822124,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822121,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822097,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822092,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            },
            {
                "id": 1822082,
                "content": [
                    {
                        "username": "manmohan145",
                        "content": "Can Anyone tell me whats wrong with my logic It passes 23/33 test cases.\\n public int minJumps(int[] arr) {\\n        if(arr.length==1)\\n        {\\n            return 0;\\n        }\\n        if(arr.length==2)\\n        {\\n            return 1;\\n        }\\n        Map<Integer,List<Integer>> m=new HashMap<>();\\n        int [] dp=new int[arr.length];\\n        Arrays.fill(dp,109999);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            List<Integer> l=m.get(arr[i]);\\n            if(l==null)\\n            {\\n                l=new ArrayList<Integer>();\\n            }\\n            l.add(i);\\n            m.put(arr[i],l); \\n        }\\n        for(int i:m.get(arr[arr.length-1]))\\n        {\\n            dp[i]=1;\\n        }\\n        dp[arr.length-1]=0;\\n        // System.out.print(m);\\n        for(int i=arr.length-2;i>0;i--)\\n        {\\n            dp[i]=Math.min(dp[i],Math.min(dp[i+1]+1,dp[i-1]+1));\\n            for(int r:m.get(arr[i]))\\n            {\\n                dp[r]=Math.min(dp[i]+1,dp[r]);\\n            }\\n        }\\n        return Math.min(dp[1]+1,dp[0]);\\n        \\n    }"
                    },
                    {
                        "username": "shivam9935",
                        "content": "TLE and DFS peeps ?"
                    },
                    {
                        "username": "blondi12",
                        "content": "yeah, only 15/33 testcases were passed with DFS"
                    },
                    {
                        "username": "dankCoder007",
                        "content": "Goodbye Streak :/"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\\n\\nInitialize a queue with the starting index (0), and a visited set that keeps track of visited indices. Initialize a steps variable to 0, which will be used to keep track of the number of jumps required to reach the end of the array.\\n\\nUse a while loop to iterate over the queue until it is empty. At each iteration of the while loop, dequeue an index from the queue, and if this index is equal to the last index of the array, return the current value of the steps variable, since this means that the end of the array has been reached.\\n\\nIf the current index is not equal to the last index of the array, calculate the maximum number of steps that can be taken from this index by using the value at the current index. This will be the maximum range for the next jump.\\n\\nFor each possible next jump, add the index to the queue if it has not been visited before. Also add this index to the visited set.\\n\\nIncrement the steps variable by 1, since a new jump is being made.\\n\\nRepeat steps 2-5 until the end of the array is reached or the queue is empty.\\n\\nIf the end of the array is not reached by the time the queue is empty, return -1, indicating that it is not possible to reach the end of the array."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Code Link For Reference:-\\nhttps://leetcode.com/problems/jump-game-iv/solutions/3258867/detailed-solution-with-steps/"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "one of the easier and straightforward Hards for me at least, maybe because I like BFS , DFS \\uD83D\\uDE05!!"
                    },
                    {
                        "username": "SuyashSingh_1",
                        "content": "This problem is definitely pushing me out of my comfort zone."
                    },
                    {
                        "username": "sasukesharma",
                        "content": "let\\'s survive this weekend "
                    },
                    {
                        "username": "purple_Lion",
                        "content": "Hard problems makes strong coders \\uD83D\\uDE0E"
                    },
                    {
                        "username": "cheesebread",
                        "content": "I learned something from this problem, but god, the memory TLE was annoying. Not sure if anyone would look for that in an actual interview."
                    },
                    {
                        "username": "hoangnn451",
                        "content": "TLE is a way of indicating your algorithm can be further optimized, in the actual interview there will be no TLE but you have to mention BigO time instead."
                    },
                    {
                        "username": "alt909",
                        "content": "It\\'s just a medium with extra steps, I was worried for a second."
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If N and Its Double Exist",
        "question_content": "<p>Given an array <code>arr</code> of integers, check if there exist two indices <code>i</code> and <code>j</code> such that :</p>\n\n<ul>\n\t<li><code>i != j</code></li>\n\t<li><code>0 &lt;= i, j &lt; arr.length</code></li>\n\t<li><code>arr[i] == 2 * arr[j]</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [10,2,5,3]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> For i = 0 and j = 2, arr[i] == 10 == 2 * 5 == 2 * arr[j]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> arr = [3,1,7,11]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> There is no i and j that satisfy the conditions.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= arr.length &lt;= 500</code></li>\n\t<li><code>-10<sup>3</sup> &lt;= arr[i] &lt;= 10<sup>3</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 503441,
                "title": "java-python-3-hashset-w-analysis",
                "content": "**Q & A**:\\n*Q1*: Can you please explain this line ?\\n```\\nif (seen.contains(2 * i) || i % 2 == 0 && seen.contains(i / 2))\\n```\\n\\n*A1*: `i` is half or 2 times of a number in `seen`.\\n\\n*Q2*: Are time complexities for add, remove and look-up (contains method) operation of HashSet take O(n) time in worst case?\\n*A2*: Yes. It could be but in a very rare case. The rare case depends on certain specific factors like\\n\\nYou have a really bad hash function that makes all the elements have the same hash code and you have to look up the element in a linear fashion.\\nAnd/or the bucket size capacity responsible is of very small size.\\nBut considering Java\\'s HashSet implementation that has an initial capacity of 16 elements and a load factor of 0.75 indicates that the HashSet\\'s capacity gets incremented as soon as the total number of elements hits 75% of capacity, the above rare cases won\\'t happen considering the constraints provided in the problem where it mentions that the maximum array length is 500 (a.k.a 500 elements max!)\\n - credit to **@guywithimpostersyndrome**.\\n\\n**end of Q & A**\\n\\n----\\n\\n```java\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> seen = new HashSet<>();   \\n        for (int i : arr) {\\n            if (seen.contains(2 * i) || i % 2 == 0 && seen.contains(i / 2))\\n                return true;\\n            seen.add(i);\\n        }\\n        return false;\\n    }\\n```\\n```python\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen = set()\\n        for i in arr:\\n          # if 2 * i in seen or i % 2 == 0 and i // 2 in seen:\\n            if 2 * i in seen or i / 2 in seen: # credit to @PeterBohai\\n                return True\\n            seen.add(i)\\n        return False\\n```\\nOr (Inspired by **@leihao1313**) \\n```python\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        cnt = Counter(arr)\\n        return any(2 * x in cnt and x != 0 for x in arr) or cnt[0] > 1\\n```\\n\\n**Analysis:**\\n\\nTime & space: O(n), n = arr.length.",
                "solutionTags": [],
                "code": "```\\nif (seen.contains(2 * i) || i % 2 == 0 && seen.contains(i / 2))\\n```\n```java\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> seen = new HashSet<>();   \\n        for (int i : arr) {\\n            if (seen.contains(2 * i) || i % 2 == 0 && seen.contains(i / 2))\\n                return true;\\n            seen.add(i);\\n        }\\n        return false;\\n    }\\n```\n```python\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen = set()\\n        for i in arr:\\n          # if 2 * i in seen or i % 2 == 0 and i // 2 in seen:\\n            if 2 * i in seen or i / 2 in seen: # credit to @PeterBohai\\n                return True\\n            seen.add(i)\\n        return False\\n```\n```python\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        cnt = Counter(arr)\\n        return any(2 * x in cnt and x != 0 for x in arr) or cnt[0] > 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 504918,
                "title": "java-easy-5-line-solution-with-explanation",
                "content": "HashSet provides O(1) lookup, so it ideal for this question. For each number in the array we check, if we have already seen it\\'s half or it\\'s double.\\n**NOTE:** When checking half, we need to ensure that the current number is even, else we will get wrong anwer like in the case of 3 and 7 being in the input. Here for 7, 7/2 would give 3 (not 3.5) which is present in the HashSet but not what we need. \\n```\\npublic boolean checkIfExist(int[] arr) {\\n\\tHashSet<Integer> set = new HashSet<>();\\n\\tfor(int a : arr) {\\n\\t\\tif(set.contains(a*2) || (a%2 == 0 && set.contains(a/2))) return true;\\n\\t\\tset.add(a);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean checkIfExist(int[] arr) {\\n\\tHashSet<Integer> set = new HashSet<>();\\n\\tfor(int a : arr) {\\n\\t\\tif(set.contains(a*2) || (a%2 == 0 && set.contains(a/2))) return true;\\n\\t\\tset.add(a);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780188,
                "title": "faster-than-97-83-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            if(set.count(2*arr[i])>0 || ((arr[i]%2==0) && set.count(arr[i]/2)>0))\\n                return true;\\n            set.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\t\\t\\n**Feel free to ask any question in the comment section.\\nIf you like this solution, do UPVOTE.\\nHappy Coding :)**\\n\\t\\t",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            if(set.count(2*arr[i])>0 || ((arr[i]%2==0) && set.count(arr[i]/2)>0))\\n                return true;\\n            set.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723608,
                "title": "java-4-approaches-everything-you-d-need",
                "content": "### **Please Upvote** :D\\n### 1. Brute force approach:\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n\\t    int n = arr.length;\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < n; j++) \\n                if (i != j && arr[i] == 2 * arr[j]) \\n                    return true;\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n### 2. Binary Search:\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for (int i = 0; i < arr.length; i++) {\\n            int target = 2 * arr[i];\\n            int lo = 0, hi = arr.length - 1;\\n            while (lo <= hi) {\\n                int mid = lo + (hi - lo) / 2;\\n                if (arr[mid] == target && mid != i) \\n                    return true;\\n                if (arr[mid] < target) \\n                    lo = mid + 1;\\n                else \\n                    hi = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(1)\\n```\\n### 3. Using HashMap:\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (map.containsKey(2 * arr[i]) &&\\n                map.get(2 * arr[i]) != i) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) => O(n ^ 2)\\n// SC: O(n)\\n// HashMap.containsKey() costs O(n) at worst case\\n```\\n### 4. Using HashSet:\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : arr) {\\n            if (set.contains(i * 2) || (i % 2 == 0 && set.contains(i / 2))) {\\n                return true;\\n            }\\n            set.add(i);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(n)\\n// set.contains() costs O(logn) at worst case\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n\\t    int n = arr.length;\\n        for (int i = 0; i < n; i++) \\n            for (int j = 0; j < n; j++) \\n                if (i != j && arr[i] == 2 * arr[j]) \\n                    return true;\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for (int i = 0; i < arr.length; i++) {\\n            int target = 2 * arr[i];\\n            int lo = 0, hi = arr.length - 1;\\n            while (lo <= hi) {\\n                int mid = lo + (hi - lo) / 2;\\n                if (arr[mid] == target && mid != i) \\n                    return true;\\n                if (arr[mid] < target) \\n                    lo = mid + 1;\\n                else \\n                    hi = mid - 1;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = arr.length;\\n        for (int i = 0; i < n; i++){\\n            map.put(arr[i], i);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (map.containsKey(2 * arr[i]) &&\\n                map.get(2 * arr[i]) != i) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n) + O(n * n) => O(n ^ 2)\\n// SC: O(n)\\n// HashMap.containsKey() costs O(n) at worst case\\n```\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : arr) {\\n            if (set.contains(i * 2) || (i % 2 == 0 && set.contains(i / 2))) {\\n                return true;\\n            }\\n            set.add(i);\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logn), SC: O(n)\\n// set.contains() costs O(logn) at worst case\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584052,
                "title": "java-solution-binary-search",
                "content": "```java\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        int zeroCount = 0;\\n        for (int x : arr) {\\n            if (x != 0) {\\n                if (binarySearch(x*2, arr)) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                ++zeroCount;\\n            }\\n        }\\n        return zeroCount >= 2;\\n    }\\n    \\n    public boolean binarySearch(int x, int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = (int)((start + end)/2);\\n            if (nums[mid] < x) {\\n                start = 1 + mid;\\n            }\\n            else if (nums[mid] > x) {\\n                end = mid - 1;\\n            }\\n            else {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```java\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        int zeroCount = 0;\\n        for (int x : arr) {\\n            if (x != 0) {\\n                if (binarySearch(x*2, arr)) {\\n                    return true;\\n                }\\n            }\\n            else {\\n                ++zeroCount;\\n            }\\n        }\\n        return zeroCount >= 2;\\n    }\\n    \\n    public boolean binarySearch(int x, int[] nums) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while (start <= end) {\\n            int mid = (int)((start + end)/2);\\n            if (nums[mid] < x) {\\n                start = 1 + mid;\\n            }\\n            else if (nums[mid] > x) {\\n                end = mid - 1;\\n            }\\n            else {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791983,
                "title": "javascript-hash-table-or-set-space-time-complexity-analysis",
                "content": "# **Hash Table**\\nWe could use a for  loop nested in a for loop to check for each element if there is a corresponding number that is its double.\\n\\nBut even though we would have a constant space complexity of O(1), we would have a quadratic time complexity of O(n\\xB2) which is not good and should be avoided if possible.\\n\\nAnother possible solution is to use the Hash Table data structure that in JavaScript can be represented as an object. Its main advantage is that we can assume that it takes constant time of O(1) to retrieve each stored element, so it is fast.\\n\\nIt also allows us to solve this problem by traversing the array only once:\\n\\nIn each iteration of a for statement we check if the current value already exists as a key in our object.\\n* If so, a number and its double exist in the array, we must return true.\\n* If not, store key/value pairs where one pair has the current element divided by 2 as a key and the other pair has the current element multiplied by 2 as a key. Notice that the values we store with each key do not matter, since we only check the keys.\\n\\nIf the for loop ends without finding a match, it means that the array does not contain a number and its double, we must return false.\\n\\nSince we created a Hash Table with a size that scales linearly according to the size of our input array, it has a linear space complexity of O(n).\\n\\nThis time we only traverse the array once, so it has a linear time complexity of O(n).\\n\\n```\\nvar checkIfExist = function(arr) {\\n    const hashTable = {};\\n    \\n    for(let i = 0; i < arr.length; i ++) {\\n      const currValue = arr[i];\\n      \\n      if(hashTable[currValue] !== undefined) {\\n        return true\\n      }\\n      hashTable[currValue / 2] = currValue;\\n      hashTable[currValue * 2] = currValue;\\n    }\\n  \\n  return false;\\n};\\n```\\n# **Map**\\nThis Hash Table approach could also be implemented by using the JavaScript built in Map data collection.\\n\\nThe main difference in our use case would be that instead of storing each key in the Hash Table as a string, we would store each key in a Map as a number. An Object only supports string and symbol as a key, but a Map supports objects and any primitive type as keys.\\n# **Set**\\nThe problem with using a Hash Table (object) or Map is that when we insert a key/value pair, the key is required but its value is not.\\nWhen we need a Hash Table data structure\\'s properties to solve the problem, but we only need keys instead of key/value pairs it makes sense to use a Set data collection.\\n**NOTE**: Keep in mind that a JavaScript built in Set only stores unique values.\\n\\nSimilar to an object and a Map, we can assume that we can retrieve a value from a Set with a constant time complexity of O(1).\\n\\nWe created a Set with a size that scales linearly according to the size of our input array, it has a linear space complexity of O(n).\\n\\nJust like our previous solution we only traverse the array once, so it has a linear time complexity of O(n).\\n\\n```\\nvar checkIfExist = function(arr) {\\n    const set = new Set();\\n    \\n    for(let i = 0; i < arr.length; i ++) {\\n      const currValue = arr[i];\\n      \\n      if(set.has(currValue)) {\\n        return true\\n      }\\n      set.add(currValue / 2);\\n      set.add(currValue * 2);\\n    }\\n  \\n  return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nvar checkIfExist = function(arr) {\\n    const hashTable = {};\\n    \\n    for(let i = 0; i < arr.length; i ++) {\\n      const currValue = arr[i];\\n      \\n      if(hashTable[currValue] !== undefined) {\\n        return true\\n      }\\n      hashTable[currValue / 2] = currValue;\\n      hashTable[currValue * 2] = currValue;\\n    }\\n  \\n  return false;\\n};\\n```\n```\\nvar checkIfExist = function(arr) {\\n    const set = new Set();\\n    \\n    for(let i = 0; i < arr.length; i ++) {\\n      const currValue = arr[i];\\n      \\n      if(set.has(currValue)) {\\n        return true\\n      }\\n      set.add(currValue / 2);\\n      set.add(currValue * 2);\\n    }\\n  \\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503714,
                "title": "python3-counter-o-n-100",
                "content": "count all numbers and store in counter,\\n1. if there are multiple zero return True\\n2. check each number\\'s double in counter, if it is at least one, return True,\\n3. return False if above conditions fail\\n```\\nclass Solution:\\n  def checkIfExist(self, arr: List[int]) -> bool:\\n    \\n    s = collections.Counter(arr)\\n    \\n    #check if there are more than one zeros\\n    if(s[0]>1): return True;\\n    \\n    \\n    for num in arr:\\n      if s[2*num] and num!=0:\\n        return True\\n    return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def checkIfExist(self, arr: List[int]) -> bool:\\n    \\n    s = collections.Counter(arr)\\n    \\n    #check if there are more than one zeros\\n    if(s[0]>1): return True;\\n    \\n    \\n    for num in arr:\\n      if s[2*num] and num!=0:\\n        return True\\n    return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1299922,
                "title": "c-3-solutions-o-n-n-o-n-logn-o-n",
                "content": "```\\n// Brute Force Two Pointer Soln\\n// Time O(n.n)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            int n = arr[pointer_one];\\n            for (pointer_two = pointer_one + 1; pointer_two < arr.size(); pointer_two++) {\\n                int m = arr[pointer_two];\\n                if ( n == (2 * m) || m == (2 * n)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n```\\n// Binary Search Soln\\n// Time O(N.logN)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for (int pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            if ((arr[pointer_one] % 2 == 0) && arr[pointer_one] < 0) {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, arr[pointer_one] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, 2 * arr[pointer_one]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n// Hash Table Soln\\n// Time: O(N)\\n// Space: O(N)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> uset;\\n        for(int& i:arr){\\n            if(uset.count(2*i) || (!(i&1) && (uset.count(i/2))))\\n                return true;\\n            uset.insert(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Two Pointers",
                    "Sorting",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\n// Brute Force Two Pointer Soln\\n// Time O(n.n)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            int n = arr[pointer_one];\\n            for (pointer_two = pointer_one + 1; pointer_two < arr.size(); pointer_two++) {\\n                int m = arr[pointer_two];\\n                if ( n == (2 * m) || m == (2 * n)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\n// Binary Search Soln\\n// Time O(N.logN)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for (int pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            if ((arr[pointer_one] % 2 == 0) && arr[pointer_one] < 0) {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, arr[pointer_one] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, 2 * arr[pointer_one]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n// Hash Table Soln\\n// Time: O(N)\\n// Space: O(N)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> uset;\\n        for(int& i:arr){\\n            if(uset.count(2*i) || (!(i&1) && (uset.count(i/2))))\\n                return true;\\n            uset.insert(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503507,
                "title": "python-3-five-lines-beats-100",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, A: List[int]) -> bool:\\n        if A.count(0) > 1: return True\\n        S = set(A) - {0}\\n        for a in A:\\n            if 2*a in S: return True\\n        return False\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "class Solution:\\n    def checkIfExist(self, A: List[int]) -> bool:\\n        if A.count(0) > 1: return True\\n        S = set(A) - {0}",
                "codeTag": "Java"
            },
            {
                "id": 509400,
                "title": "java-set-1ms-explained",
                "content": "We can solve it with a hash set. For every number there are two options - either there is 2xn or there is n/2 but only if n is even. As we traverse the array we\\'re adding elements to the set but perform the check above first. \\nO(n) time comlexity - one pass of the array, O(n) space for the hash set.\\n\\n```\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet();\\n        for (int n : arr) {\\n            if (set.contains(2*n) \\n                || (n%2 == 0 && set.contains(n/2)))\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet();\\n        for (int n : arr) {\\n            if (set.contains(2*n) \\n                || (n%2 == 0 && set.contains(n/2)))\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 839197,
                "title": "1346-ten-solutions-different-caches-no-cache",
                "content": "---\\n\\nBackground:\\n\\n- Some JavaScript methods return `undefined`, some return `false`, and some `-1` on not found logic\\n- As you go down different solutions, you will have more javascript than problem solving itself :) (or may be not)\\n- Depending on if we have enough memory or not, we can choose one of the answers\\n  - I would choose 1st solution `Set`\\n  - Or, if someone says no more memory, then would choose the 4th solution, the simpler `for (i) for (j)` loop\\n\\nBy reading post this you might become good in JavaScript, if not problem solving, or both :)\\n\\n---\\n\\n**Algo:**\\n\\n- Finding if we have an element that is double or half is the question\\n- That element should be not be same (which means element cannot be `0` because `0/2 = 0* 2 = 0`)\\n- For each element `e`, as we move to right of array:\\n  - Check if its `double` or `half` exists in our cache (say `Set/Map/Obj/Array/etc`)\\n    - If so, we found an `different` element ( `i != j` condition of question) so return `true`\\n  - Now that we have seen this `e`, put in in the cache\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar checkIfExist = function(A) {\\n    let set = new Set();\\n\\n    for (let e of A) {\\n        if (set.has(e * 2) || set.has(e / 2))\\n            return true;\\n        set.add(e);\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let map = new Map();\\n\\n    for (let e of A) {\\n        if (map.has(e * 2) || map.has(e / 2))\\n            return true;\\n        map.set(e, true);\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let obj = {};\\n\\n    for (let e of A) {\\n        if (obj[e * 2] || obj[e / 2])\\n            return true;\\n        obj[e] = true;\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let n = A.length;\\n\\n    for (let i = 0; i < n; i++)\\n        for (let j = 0; j < i; j++)\\n            if ((A[i] === A[j] * 2) || (A[i] === A[j] / 2))\\n                return true;\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.indexOf(e * 2) !== -1 || B.indexOf(e / 2) !== -1)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let n = A.length;\\n\\n    for (let i = 0; i < n; i++)\\n        if (\\n            ((A.indexOf(A[i] * 2) !== -1 && A.indexOf(A[i] * 2) !== i)) ||\\n            ((A.indexOf(A[i] / 2) !== -1 && A.indexOf(A[i] / 2) !== i))\\n        )\\n            return true;\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.includes((2 * e)) || B.includes(e / 2))\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.some((b) => b === e * 2) || B.some((b) => b === e / 2))\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.find((b) => b === e * 2) !== undefined || B.find((b) => b === e / 2) !== undefined)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.filter((b) => b === e * 2)[0] !== undefined || B.filter((b) => b === e / 2)[0] !== undefined)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.findIndex((b) => b === e * 2) !== -1 || B.findIndex((b) => b === e / 2) !== -1)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    while (A.length) {\\n        if (B.includes((2 * A[0])) || B.includes(A[0] / 2))\\n            return true;\\n        B.push(A.shift())\\n    }\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let e;\\n\\n    while ((e = A.shift()) !== undefined)\\n        if (A.includes((2 * e)) || A.includes(e / 2))\\n            return true;\\n\\n    return false\\n};\\n```\\n\\n```\\nvar checkIfExist = function(A) {\\n    let e;\\n\\n    while ((e = A.pop()) !== undefined)\\n        if (A.includes((2 * e)) || A.includes(e / 2))\\n            return true;\\n\\n    return false\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfExist = function(A) {\\n    let set = new Set();\\n\\n    for (let e of A) {\\n        if (set.has(e * 2) || set.has(e / 2))\\n            return true;\\n        set.add(e);\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let map = new Map();\\n\\n    for (let e of A) {\\n        if (map.has(e * 2) || map.has(e / 2))\\n            return true;\\n        map.set(e, true);\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let obj = {};\\n\\n    for (let e of A) {\\n        if (obj[e * 2] || obj[e / 2])\\n            return true;\\n        obj[e] = true;\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let n = A.length;\\n\\n    for (let i = 0; i < n; i++)\\n        for (let j = 0; j < i; j++)\\n            if ((A[i] === A[j] * 2) || (A[i] === A[j] / 2))\\n                return true;\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.indexOf(e * 2) !== -1 || B.indexOf(e / 2) !== -1)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let n = A.length;\\n\\n    for (let i = 0; i < n; i++)\\n        if (\\n            ((A.indexOf(A[i] * 2) !== -1 && A.indexOf(A[i] * 2) !== i)) ||\\n            ((A.indexOf(A[i] / 2) !== -1 && A.indexOf(A[i] / 2) !== i))\\n        )\\n            return true;\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.includes((2 * e)) || B.includes(e / 2))\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.some((b) => b === e * 2) || B.some((b) => b === e / 2))\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.find((b) => b === e * 2) !== undefined || B.find((b) => b === e / 2) !== undefined)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.filter((b) => b === e * 2)[0] !== undefined || B.filter((b) => b === e / 2)[0] !== undefined)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    for (let e of A) {\\n        if (B.findIndex((b) => b === e * 2) !== -1 || B.findIndex((b) => b === e / 2) !== -1)\\n            return true;\\n        B.push(e)\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let B = new Array();\\n\\n    while (A.length) {\\n        if (B.includes((2 * A[0])) || B.includes(A[0] / 2))\\n            return true;\\n        B.push(A.shift())\\n    }\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let e;\\n\\n    while ((e = A.shift()) !== undefined)\\n        if (A.includes((2 * e)) || A.includes(e / 2))\\n            return true;\\n\\n    return false\\n};\\n```\n```\\nvar checkIfExist = function(A) {\\n    let e;\\n\\n    while ((e = A.pop()) !== undefined)\\n        if (A.includes((2 * e)) || A.includes(e / 2))\\n            return true;\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167113,
                "title": "c-using-map",
                "content": "\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n\\n            if(mp.find(arr[i] * 2) != mp.end())\\n                return true;\\n            if(arr[i] % 2 == 0 && mp.find(arr[i]/2) != mp.end())\\n                return true;\\n            mp[arr[i]]++;\\n        }\\n        \\n        return false;\\n    }\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n\\n            if(mp.find(arr[i] * 2) != mp.end())\\n                return true;\\n            if(arr[i] % 2 == 0 && mp.find(arr[i]/2) != mp.end())\\n                return true;\\n            mp[arr[i]]++;\\n        }\\n        \\n        return false;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3345913,
                "title": "python3-simple-binary-search-approach",
                "content": "![image.png](https://assets.leetcode.com/users/images/6128ee21-1f40-477e-9fba-01f9bb922a2a_1679885453.0123944.png)\\n# Code\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        for i in range(len(arr)):\\n            product = arr[i]*2\\n            lo,hi = 0,len(arr)-1\\n            while lo<=hi:\\n                mid = (lo+hi)//2\\n                if arr[mid]==product and mid!= i:\\n                    return True\\n                elif arr[mid]<product:\\n                    lo+=1\\n                else:\\n                    hi-=1\\n        return False\\n```\\n**Hope you find it helpful!**",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        for i in range(len(arr)):\\n            product = arr[i]*2\\n            lo,hi = 0,len(arr)-1\\n            while lo<=hi:\\n                mid = (lo+hi)//2\\n                if arr[mid]==product and mid!= i:\\n                    return True\\n                elif arr[mid]<product:\\n                    lo+=1\\n                else:\\n                    hi-=1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588466,
                "title": "java-clean-code-binary-search-intution-explained",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        // Intutively : we can run through the array (using a for loop) and for each element -> I will calculate 2*arr[i] ---> and then search it up in the array by calling a function --->search will be binary search to reduce time complexity\\n        \\n        //As, we are planning to use binary search we will first sort the array\\n        \\n        Arrays.sort(arr);\\n        \\n        int res;\\n        \\n        for(int i = 0; i<arr.length; i++)\\n        {\\n            res = check_binarySearch(arr, arr[i]*2);\\n            if(res != i && res != -1)\\n            {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public int check_binarySearch(int[] arr, int target)\\n    {\\n        int start = 0;\\n        int end = arr.length-1;\\n        \\n        while(start<=end)\\n        {\\n            int mid = start + (end - start)/2;\\n            \\n            if(arr[mid] > target)\\n            {\\n                end = mid - 1;\\n            }\\n            else if(arr[mid] < target)\\n            {\\n                start = mid + 1; \\n            }\\n            else\\n            {\\n                return mid;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        // Intutively : we can run through the array (using a for loop) and for each element -> I will calculate 2*arr[i] ---> and then search it up in the array by calling a function --->search will be binary search to reduce time complexity\\n        \\n        //As, we are planning to use binary search we will first sort the array\\n        \\n        Arrays.sort(arr);\\n        \\n        int res;\\n        \\n        for(int i = 0; i<arr.length; i++)\\n        {\\n            res = check_binarySearch(arr, arr[i]*2);\\n            if(res != i && res != -1)\\n            {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1011435,
                "title": "simple-javascript-soluion-99-faster-90-less-memory",
                "content": "```\\nvar checkIfExist = function(array) {\\n  while (array.length) { // While the array has items\\n    const n = array.pop() // Get an item and remove it from the array\\n\\t // If the double or the half is found stop looking\\n    if (array.includes(n*2) || array.includes(n/2)) return true\\n  }\\n  return false // If we get here we\\'ve gone through the whole array without finding a match\\n}\\n```\\nThis solution takes advantage of the fact that we shorten the array everytime we look for a double, so the next check goes faster the more items we\\'ve checked.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfExist = function(array) {\\n  while (array.length) { // While the array has items\\n    const n = array.pop() // Get an item and remove it from the array\\n\\t // If the double or the half is found stop looking\\n    if (array.includes(n*2) || array.includes(n/2)) return true\\n  }\\n  return false // If we get here we\\'ve gone through the whole array without finding a match\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1488669,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> s = new HashSet<>();\\n        for( int i:arr){\\n            if(s.contains(i*2) || (s.contains(i/2) && i%2==0)){\\n                return true;\\n            }\\n            s.add(i);\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nCheck for Double and Half in the elements present in HashSet to find relation [ N = 2 * M].\\n\\nFeel free to upvote if you like the Solution.\\nReach out to me in comments for suggestions and queries.\\nHappy Coding!!!!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> s = new HashSet<>();\\n        for( int i:arr){\\n            if(s.contains(i*2) || (s.contains(i/2) && i%2==0)){\\n                return true;\\n            }\\n            s.add(i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645679,
                "title": "python-3-answer",
                "content": "This seems a bit more straightforward to me.\\nI iterate the range of the lest, and check two things. First, I check if the double exists in the list, and I check that it is not the same index, to prevent the edge case of return True when you have [0] in the list.\\n\\n\\n``` Python\\nclass Solution:\\n\\n    def checkIfExist(self, arr:List[int]) -> True:\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in arr and arr.index(arr[i]*2 ) != i:\\n                return True\\n        \\n        return False\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python\\nclass Solution:\\n\\n    def checkIfExist(self, arr:List[int]) -> True:\\n        \\n        for i in range(len(arr)):\\n            if arr[i]*2 in arr and arr.index(arr[i]*2 ) != i:\\n                return True\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722298,
                "title": "c-using-binary-search",
                "content": "```\\nbool checkIfExist(vector<int>& a) {\\n\\tsort(a.begin(), a.end());\\n\\tint n = a.size();\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(a[i] >= 0) {\\n\\t\\t\\tif((i != n-1) && (binary_search(a.begin()+i+1, a.end(), 2*a[i]))) return true;\\n\\t\\t}else{ \\n\\t\\t\\tif( (i>0) && (binary_search(a.begin(), a.begin()+i, 2*a[i])) ) return true;\\n\\t\\t}    \\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nbool checkIfExist(vector<int>& a) {\\n\\tsort(a.begin(), a.end());\\n\\tint n = a.size();\\n\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tif(a[i] >= 0) {\\n\\t\\t\\tif((i != n-1) && (binary_search(a.begin()+i+1, a.end(), 2*a[i]))) return true;\\n\\t\\t}else{ \\n\\t\\t\\tif( (i>0) && (binary_search(a.begin(), a.begin()+i, 2*a[i])) ) return true;\\n\\t\\t}    \\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801315,
                "title": "python-one-pass-no-sorting-explanation-provided",
                "content": "To do this in one pass we need to keep track of possible `M` and `N` that could be derived from the current element `a`. As we iterate through the array, check if `a` is a possible `M` or `N` based on elements we\\'ve seen so far. If it is, return `True`. If we iterate through the entire list can\\'t find a match, we can safely return `False`.\\n\\nSome improvements:\\n* We can use a `set()` to store possible `M` and `N` because we don\\'t care about duplicates.\\n* We only need to add something to the possible `M` set if its even. This decreases the amount of elements when searching through the possible `M` set.\\n\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        possible_M = set()\\n        possible_N = set()\\n        for a in arr:\\n            if a in possible_M: return True\\n            if a in possible_N: return True\\n            if a % 2 == 0: possible_M.add(a//2)\\n            possible_N.add(a*2)\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        possible_M = set()\\n        possible_N = set()\\n        for a in arr:\\n            if a in possible_M: return True\\n            if a in possible_N: return True\\n            if a % 2 == 0: possible_M.add(a//2)\\n            possible_N.add(a*2)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678107,
                "title": "c-optimised-solution-linear-time-solution-unordered-set-soluton",
                "content": "**TC = O(n)\\nSC = O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int>us;\\n        \\n        for(int i = 0; i<arr.size(); i++){\\n\\t\\t//if the double of the element existed previously in the array\\n            if(us.find(arr[i]*2) != us.end()){\\n                return true;\\n            }\\n\\t\\t\\t\\n       //as the array is of integers so no need to check for the half of odd numbers\\n\\t   //here we have checked if the number is even if yess ...then check if there is half of the current number present previously in the array\\n            if(arr[i]%2 == 0){\\n                if(us.find(arr[i]/2) != us.end()){\\n                    return true;\\n                }\\n            }\\n          //if none of the above cases are true then we will insert the current element into the unordered set and will move further checking other elements\\n            us.insert(arr[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int>us;\\n        \\n        for(int i = 0; i<arr.size(); i++){\\n\\t\\t//if the double of the element existed previously in the array\\n            if(us.find(arr[i]*2) != us.end()){\\n                return true;\\n            }\\n\\t\\t\\t\\n       //as the array is of integers so no need to check for the half of odd numbers\\n\\t   //here we have checked if the number is even if yess ...then check if there is half of the current number present previously in the array\\n            if(arr[i]%2 == 0){\\n                if(us.find(arr[i]/2) != us.end()){\\n                    return true;\\n                }\\n            }\\n          //if none of the above cases are true then we will insert the current element into the unordered set and will move further checking other elements\\n            us.insert(arr[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105451,
                "title": "3-approaches-brute-force-o-n-n-to-optimized-o-n-c-binarysearch-hashset",
                "content": "**1. Brute Force: using 2 for loops**\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                if(arr[i] == 2*arr[j]  &&  i != j)\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\\nTime Complexity: O(n*n)\\nAuxilary Space: O(1)\\n\\n\\n**Better Approach: Using Binary Search**\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n; i++){\\n            int start = 0;\\n            int end = n-1;\\n            int target = 2*arr[i];\\n            while(start <= end){\\n                int mid = start+(end-start)/2;\\n                if((arr[mid] == target)  &&  (mid != i))\\n                    return true;\\n                else if(arr[mid] > target)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nTime Complexity: O(nlogn)\\nAuxilary Space: O(1)\\n\\n\\n**3. Optimized Approach: Using HashSet**\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s;\\n        for(auto x: arr){\\n            if(s.count(x*2))\\n                return true;\\n            else if(s.count(x/2)  &&  x%2 == 0) \\n                return true;\\n            s.insert(x);\\n        }\\n        return false;\\n    }\\n};\\n```\\nTime Complexity: O(N)\\nAuxilary Space: O(N)\\n\\n\\n**Please upvote if this helps!!!**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<n; j++)\\n                if(arr[i] == 2*arr[j]  &&  i != j)\\n                    return true;\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i=0; i<n; i++){\\n            int start = 0;\\n            int end = n-1;\\n            int target = 2*arr[i];\\n            while(start <= end){\\n                int mid = start+(end-start)/2;\\n                if((arr[mid] == target)  &&  (mid != i))\\n                    return true;\\n                else if(arr[mid] > target)\\n                    end = mid - 1;\\n                else\\n                    start = mid + 1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s;\\n        for(auto x: arr){\\n            if(s.count(x*2))\\n                return true;\\n            else if(s.count(x/2)  &&  x%2 == 0) \\n                return true;\\n            s.insert(x);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503657,
                "title": "1-line-python",
                "content": "The input size limit is so tiny that we can easily brute force this:\\n```\\ndef checkIfExist(self, arr):\\n    return any(a == 2 * b for a, b in itertools.permutations(arr, 2))\\n```\\nBut here\\'s an O(n) solution as well, testing zeros and non-zeros separately:\\n```\\ndef checkIfExist(self, arr):\\n    s = set(arr)\\n    return arr.count(0) > 1 or any(2 * x in s for x in s if x)\\n```",
                "solutionTags": [],
                "code": "```\\ndef checkIfExist(self, arr):\\n    return any(a == 2 * b for a, b in itertools.permutations(arr, 2))\\n```\n```\\ndef checkIfExist(self, arr):\\n    s = set(arr)\\n    return arr.count(0) > 1 or any(2 * x in s for x in s if x)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503467,
                "title": "c-py3-hashmap-solution",
                "content": "Check if there exists `i != j` so that `arr[i] = 2 * arr[j]`.\\n\\n# Explanation\\n\\nStore all the elements of `arr`  in a HashMap or HashSet and then check. \\n\\nNote the corner case of `[0]`.\\n\\nThe time complexity is O(n).\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> s;\\n        for (int x: arr)\\n            s[x]++;\\n        for (int x: arr)\\n            if (x != 0 && s.find(x * 2) != s.end())\\n                return true;\\n            else if (x == 0 && s[x] >= 2)\\n                return true;\\n        return false;\\n    }\\n};\\n```\\n\\n# PY3 Solution\\n\\n```python\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d = dict()\\n        for x in arr:\\n            d[x] = d.get(x, 0) + 1\\n        for x in arr:\\n            if x != 0 and 2 * x in d:\\n                return True\\n            elif x == 0 and d[0] >= 2:\\n                return True\\n        return False\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> s;\\n        for (int x: arr)\\n            s[x]++;\\n        for (int x: arr)\\n            if (x != 0 && s.find(x * 2) != s.end())\\n                return true;\\n            else if (x == 0 && s[x] >= 2)\\n                return true;\\n        return false;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d = dict()\\n        for x in arr:\\n            d[x] = d.get(x, 0) + 1\\n        for x in arr:\\n            if x != 0 and 2 * x in d:\\n                return True\\n            elif x == 0 and d[0] >= 2:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197827,
                "title": "python3-solution-using-hashmap",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        hashMap = {}\\n        for i in arr:\\n            if(hashMap.get(i+i)):\\n                return True\\n            if(i%2 == 0 and hashMap.get(i//2)):\\n                return True\\n            hashMap[i] = True\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        hashMap = {}\\n        for i in arr:\\n            if(hashMap.get(i+i)):\\n                return True\\n            if(i%2 == 0 and hashMap.get(i//2)):\\n                return True\\n            hashMap[i] = True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601979,
                "title": "easy-python-solution-beats-99-96",
                "content": "```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            if 2*arr[i] in arr and arr.index(2*arr[i])!=i:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            if 2*arr[i] in arr and arr.index(2*arr[i])!=i:\\n                return True\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 551560,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 4 ms, faster than 94.63% of Go online submissions for Check If N and Its Double Exist.\\nMemory Usage: 3.2 MB, less than 100.00% of Go online submissions for Check If N and Its Double Exist.\\n\\n```go\\nfunc checkIfExist(arr []int) bool {\\n    tmp := make(map[float64]bool)\\n    for _, v := range arr {\\n        V := float64(v)\\n        if tmp[V * 2.0] || tmp[V / 2.0] { return true }\\n        tmp[V] = true\\n    }\\n    return false\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc checkIfExist(arr []int) bool {\\n    tmp := make(map[float64]bool)\\n    for _, v := range arr {\\n        V := float64(v)\\n        if tmp[V * 2.0] || tmp[V / 2.0] { return true }\\n        tmp[V] = true\\n    }\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2753029,
                "title": "two-pointers-solution-98-99",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    let left = 0, right = 1;\\n    \\n    while(left < arr.length-1){\\n        if(arr[left] == (arr[right] * 2) || arr[right] == (arr[left] * 2)){\\n            return true\\n        }else if(right === arr.length-1){\\n            left++\\n            right = left+1\\n        }else{\\n            right++\\n        }\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    let left = 0, right = 1;\\n    \\n    while(left < arr.length-1){\\n        if(arr[left] == (arr[right] * 2) || arr[right] == (arr[left] * 2)){\\n            return true\\n        }else if(right === arr.length-1){\\n            left++\\n            right = left+1\\n        }else{\\n            right++\\n        }\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2340623,
                "title": "python-simple-python-solution-using-binary-search",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 72 ms, faster than 72.07% of Python3 online submissions for Check If N and Its Double Exist.\\n# Memory Usage: 13.9 MB, less than 53.83% of Python3 online submissions for Check If N and Its Double Exist.\\n\\tclass Solution:\\n\\t\\tdef checkIfExist(self, arr: List[int]) -> bool:\\n\\n\\t\\t\\tdef BinarySearch(array, target):\\n\\n\\t\\t\\t\\tlow = 0\\n\\t\\t\\t\\thigh = len(array) - 1\\n\\n\\t\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\t\\tmid = (low + high ) // 2\\n\\n\\t\\t\\t\\t\\tif array[mid] == target:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\t\\telif array[mid] < target:\\n\\t\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\t\\telif array[mid] > target:\\n\\t\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tarray = sorted(arr)\\n\\n\\t\\t\\tfor i in range(len(array)):\\n\\n\\t\\t\\t\\tindex = BinarySearch(array, array[i] * 2)\\n\\n\\t\\t\\t\\tif index != -1 and index != i:\\n\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n\\t\\n# Thank you \\uD83D\\uDD25\\u270C\\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 72 ms, faster than 72.07% of Python3 online submissions for Check If N and Its Double Exist.\\n# Memory Usage: 13.9 MB, less than 53.83% of Python3 online submissions for Check If N and Its Double Exist.\\n\\tclass Solution:\\n\\t\\tdef checkIfExist(self, arr: List[int]) -> bool:\\n\\n\\t\\t\\tdef BinarySearch(array, target):\\n\\n\\t\\t\\t\\tlow = 0\\n\\t\\t\\t\\thigh = len(array) - 1\\n\\n\\t\\t\\t\\twhile low <= high:\\n\\n\\t\\t\\t\\t\\tmid = (low + high ) // 2\\n\\n\\t\\t\\t\\t\\tif array[mid] == target:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\t\\telif array[mid] < target:\\n\\t\\t\\t\\t\\t\\tlow = mid + 1\\n\\n\\t\\t\\t\\t\\telif array[mid] > target:\\n\\t\\t\\t\\t\\t\\thigh = mid - 1\\n\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tarray = sorted(arr)\\n\\n\\t\\t\\tfor i in range(len(array)):\\n\\n\\t\\t\\t\\tindex = BinarySearch(array, array[i] * 2)\\n\\n\\t\\t\\t\\tif index != -1 and index != i:\\n\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\treturn False\\n\\t\\n# Thank you \\uD83D\\uDD25\\u270C\\uD83D\\uDC4D\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2074775,
                "title": "explanation-n-log-n-binary-search",
                "content": "Sort the array -> n logn\\n\\nIterate each element and search for its double usig binary search -> n * log n\\n\\nOVERALL COMPLEXITY = O ( n logn )\\n\\nFOR NEGATIVE ELEMENTS : Search in left array\\nFOR NON NEGATIVE ELEMENTS : Search in right array\\n\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        n=len(arr)\\n        for i in range(n):\\n            k=arr[i]\\n            \\n            # binary search for negatives\\n            if k<0:\\n                lo=0\\n                hi=i\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(2*k):\\n                        return True\\n                    elif arr[mid]<(2*k):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n            \\n            # binary seach for non negatives\\n            else:\\n                lo=i+1\\n                hi=n\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(k*2):\\n                        return True\\n                    elif arr[mid]<(k*2):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n                        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        n=len(arr)\\n        for i in range(n):\\n            k=arr[i]\\n            \\n            # binary search for negatives\\n            if k<0:\\n                lo=0\\n                hi=i\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(2*k):\\n                        return True\\n                    elif arr[mid]<(2*k):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n            \\n            # binary seach for non negatives\\n            else:\\n                lo=i+1\\n                hi=n\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(k*2):\\n                        return True\\n                    elif arr[mid]<(k*2):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n                        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326179,
                "title": "elegant-two-pointers-o-n-for-sorted-otherwise-o-nlogn",
                "content": "The algorithm runs in linear time if input is sorted as we have pointers i and j which traverses elements only once.\\nThe algorithm is as follows:\\n1. i and j are initialized to 0 (Note that j is not 1 as negative numbers can be in the array, see my earlier incorrect implementation to understand the difference).\\n2. Here i points to smaller of two elements in magnitude and j points to larger ( i.e `abs(arr[i]) < abs(arr[j])` ).\\n3. Now if i == j then either (i == 0 && j == 0), in that case if initial element is negative our smaller pointer i should be forwarded otherwise initial element is positive so j (larger pointer) should be forwarded. If i and j are not at 0 index then it means they both point to element \"0\" or transition point from negative to positive numbers in which case j should be ahead and thus incremented. (*Notice the difference between index 0 and element \"0\"*)\\n4. Now for the negative set of numbers j remains behind pointer i because of abs(i) < abs(j) invariant.\\n5. Finally i and j will merge on element \"0\" or transition point.\\n6. Now i and j will switch their relative order i.e i remains behind j because of our invariant abs(i) < abs(j).\\n7. For the rest casework is the usual two pointer comparison.\\n\\nThus we can independently check for negative set of values and positive set of values with same pointers within one loop. You can independently check for condition in negative values first and then positive using two different loops as well and that can make things clear for you.\\n\\nThe tricky part of this algorithm is to accomodate for negative values. If we see closely the pointers readjust themselves beautifully (that\\'s why *elegant two pointers*) while transitioning from negative values to positive values and we just need to take care of edge case as specified above which results in quite fast algorithm for sorted input.\\n\\n**Upvote** if you found it useful.\\n\\n```\\nbool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0, j = 0; i < n && j < n;) {\\n            if(i == j) {\\n                if(arr[i] >= 0)\\n                    j++;\\n                else\\n                    i++;\\n            }\\n            \\n            else if(2*arr[i] < arr[j])\\n                i++;\\n            else if(2*arr[i] > arr[j])\\n                j++;\\n            else\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```\\n\\nMy earlier incorrect submission. This algorithm doesn\\'t account for negative values and thus fails for following input -> `[-10,12,-20,-8,15]`\\n```\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0, j = 1; i < n && j < n;) {\\n            if(2*arr[i] < arr[j])\\n                i++;\\n            else if(2*arr[i] > arr[j])\\n                j++;\\n            else\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nbool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0, j = 0; i < n && j < n;) {\\n            if(i == j) {\\n                if(arr[i] >= 0)\\n                    j++;\\n                else\\n                    i++;\\n            }\\n            \\n            else if(2*arr[i] < arr[j])\\n                i++;\\n            else if(2*arr[i] > arr[j])\\n                j++;\\n            else\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```\n```\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0, j = 1; i < n && j < n;) {\\n            if(2*arr[i] < arr[j])\\n                i++;\\n            else if(2*arr[i] > arr[j])\\n                j++;\\n            else\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509834,
                "title": "javascript-easy-to-understand-set-or-array",
                "content": "We could easily do this via a set like this:\\n\\n```js\\nconst checkIfExist = arr => {\\n  const set = new Set();\\n  for (const val of arr) {\\n    if (set.has(val << 1) || set.has(val / 2)) return true; // val << 1 means val * 2, see comments below for detail\\n    set.add(val);\\n  }\\n  return false;\\n};\\n```\\n\\nOr use 2 Uint8Array like this:\\n\\n```js\\nconst checkIfExist = arr => {\\n  const neg = new Uint8Array(1000);\\n  const pos = new Uint8Array(1000);\\n  for (const val of arr) {\\n    const arr = val > 0 ? pos : neg;\\n    const v2 = Math.abs(val);\\n    if (arr[v2 << 1] === 1 || arr[v2 / 2]) return true;\\n    arr[v2] = 1;\\n  }\\n  return false;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst checkIfExist = arr => {\\n  const set = new Set();\\n  for (const val of arr) {\\n    if (set.has(val << 1) || set.has(val / 2)) return true; // val << 1 means val * 2, see comments below for detail\\n    set.add(val);\\n  }\\n  return false;\\n};\\n```\n```js\\nconst checkIfExist = arr => {\\n  const neg = new Uint8Array(1000);\\n  const pos = new Uint8Array(1000);\\n  for (const val of arr) {\\n    const arr = val > 0 ? pos : neg;\\n    const v2 = Math.abs(val);\\n    if (arr[v2 << 1] === 1 || arr[v2 / 2]) return true;\\n    arr[v2] = 1;\\n  }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503455,
                "title": "java-python3-using-hash-set",
                "content": "Algorithm: \\nScan through `arr` and check if `2*x` or `x/2` was seen. \\n\\nImplementation in Java\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int x : arr) {\\n            if (seen.contains(2*x) || (x%2==0 && seen.contains(x/2))) \\n                return true;\\n            seen.add(x); \\n        }\\n        return false; \\n    }\\n}\\n```\\n\\nImplementation in Python3\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen = set()\\n        for x in arr:\\n            if 2*x in seen or x/2 in seen: return True\\n            seen.add(x)\\n        return False \\n```\\nAnalysis: \\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> seen = new HashSet<>();\\n        for (int x : arr) {\\n            if (seen.contains(2*x) || (x%2==0 && seen.contains(x/2))) \\n                return true;\\n            seen.add(x); \\n        }\\n        return false; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen = set()\\n        for x in arr:\\n            if 2*x in seen or x/2 in seen: return True\\n            seen.add(x)\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920263,
                "title": "some-easy-c-solutions-binary-search-set-map",
                "content": "## Code : Using Binary Search\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++){\\n            int low=i+1; int high= arr.size()-1;\\n            if (arr[i]<0){\\n                while (low<= high){\\n                int mid= low+ (high-low)/2;\\n                if (arr[i] == arr[mid]*2)return true;\\n                else if (arr[i] < arr[mid]*2){\\n                    high= mid-1;\\n                }\\n                else low= mid+1;\\n                }\\n            }\\n            else{\\n                while (low<= high){\\n                    int mid= low+ (high-low)/2;\\n                    if (arr[i]*2 == arr[mid]) {return true;}\\n                    else if (arr[i]*2 < arr[mid]){\\n                        high= mid-1;\\n                    }\\n                    else low= mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n## Code : Using Sets\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> st;\\n        for (int i=0; i<arr.size(); i++){\\n            st.insert(arr[i]);\\n        }\\n        for (auto val : st){\\n            if (val!=0 && st.find(val*2)!= st.end())return true;\\n        }\\n        return count(arr.begin(),arr.end(),0)>1;\\n    }\\n};\\n```\\n---\\n\\n## Code : Using Hashing\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        for (auto val: mp){\\n            if ((val.first)!=0 && mp.find((val.first)*2)!= mp.end())return true;\\n            if (val.first==0 && mp[val.first]>=2)return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n### Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for (int i=0; i<arr.size(); i++){\\n            int low=i+1; int high= arr.size()-1;\\n            if (arr[i]<0){\\n                while (low<= high){\\n                int mid= low+ (high-low)/2;\\n                if (arr[i] == arr[mid]*2)return true;\\n                else if (arr[i] < arr[mid]*2){\\n                    high= mid-1;\\n                }\\n                else low= mid+1;\\n                }\\n            }\\n            else{\\n                while (low<= high){\\n                    int mid= low+ (high-low)/2;\\n                    if (arr[i]*2 == arr[mid]) {return true;}\\n                    else if (arr[i]*2 < arr[mid]){\\n                        high= mid-1;\\n                    }\\n                    else low= mid+1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> st;\\n        for (int i=0; i<arr.size(); i++){\\n            st.insert(arr[i]);\\n        }\\n        for (auto val : st){\\n            if (val!=0 && st.find(val*2)!= st.end())return true;\\n        }\\n        return count(arr.begin(),arr.end(),0)>1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        for (int i=0; i<arr.size(); i++){\\n            mp[arr[i]]++;\\n        }\\n        for (auto val: mp){\\n            if ((val.first)!=0 && mp.find((val.first)*2)!= mp.end())return true;\\n            if (val.first==0 && mp[val.first]>=2)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713087,
                "title": "c-solution-easy-solution-beginner-friendly",
                "content": "```\\n unordered_set<int>s;\\n        int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==0)\\n                c+=1;\\n        }\\n        if(c>1)\\n            return true;\\n        \\n        for(int i=0;i<a.size();i++)\\n            s.insert(a[i]);\\n    \\n        for(int i=0;i<a.size();i++)\\n        {\\n           if(a[i]!=0){\\n            int p=a[i]*2;\\n            if(s.find(p)!=s.end())\\n                return true;\\n           }\\n           \\n        }\\n      return false;\\n```\\n``` If you like my approach then please upvote me.```\\n``` Happy coding :) ```\\n``` If you have any doubt then feel free to ask in the comment section.```\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n unordered_set<int>s;\\n        int c=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==0)\\n                c+=1;\\n        }\\n        if(c>1)\\n            return true;\\n        \\n        for(int i=0;i<a.size();i++)\\n            s.insert(a[i]);\\n    \\n        for(int i=0;i<a.size();i++)\\n        {\\n           if(a[i]!=0){\\n            int p=a[i]*2;\\n            if(s.find(p)!=s.end())\\n                return true;\\n           }\\n           \\n        }\\n      return false;\\n```\n``` If you like my approach then please upvote me.```\n``` Happy coding :) ```\n``` If you have any doubt then feel free to ask in the comment section.```",
                "codeTag": "Unknown"
            },
            {
                "id": 2100515,
                "title": "3-solutions-o-n-o-nlogn-o-n-2",
                "content": "Brute force approach **O(N^2)**\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n               boolean b = false;\\n        int i = 0;\\n        while(i < arr.length){\\n            for(int j =  0 ; j< arr.length; j++) {\\n                if( i != j && arr[i] == 2 * arr[j]){\\n                    b = true;\\n                }\\n            }\\n            i++;\\n        }\\n        return b ; \\n    }\\n}\\n```\\n\\nBinary Search **O(NlogN)**\\n```\\nclass Solution {\\n    public  boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for (int i = 0; i < arr.length; i++) {\\n            if(binarySearch(arr,i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n//    Long to avoid stack overflow\\n    boolean binarySearch(int [] arr, int index){\\n        int start = 0;\\n        int end = arr.length -1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n//            If 0 exists once so it will return true, so we need to check that we are not at the same index.\\n            if(index!= mid && (long)(arr[index] * 2) == (long)arr[mid]){\\n                return true;\\n            } else if((long)(arr[index] * 2) > (long)arr[mid]) {\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\nHashmap **O(N)**\\n```\\nclass Solution {\\n  public boolean checkIfExist(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            map.put(arr[i],i);\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n//    As 3/2 = 1 so, if 3 is there and 1 is there , it will return true. To avoid, number should be even\\n//            To check if 0 is present and it returns the same index , we need to add != i as well.\\n            if(arr[i] %2 == 0 && map.get(arr[i]/2) != null && map.get(arr[i]/2)!= i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n               boolean b = false;\\n        int i = 0;\\n        while(i < arr.length){\\n            for(int j =  0 ; j< arr.length; j++) {\\n                if( i != j && arr[i] == 2 * arr[j]){\\n                    b = true;\\n                }\\n            }\\n            i++;\\n        }\\n        return b ; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public  boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for (int i = 0; i < arr.length; i++) {\\n            if(binarySearch(arr,i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n//    Long to avoid stack overflow\\n    boolean binarySearch(int [] arr, int index){\\n        int start = 0;\\n        int end = arr.length -1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n//            If 0 exists once so it will return true, so we need to check that we are not at the same index.\\n            if(index!= mid && (long)(arr[index] * 2) == (long)arr[mid]){\\n                return true;\\n            } else if((long)(arr[index] * 2) > (long)arr[mid]) {\\n                start = mid+1;\\n            }else{\\n                end = mid-1;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\n  public boolean checkIfExist(int[] arr) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            map.put(arr[i],i);\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n//    As 3/2 = 1 so, if 3 is there and 1 is there , it will return true. To avoid, number should be even\\n//            To check if 0 is present and it returns the same index , we need to add != i as well.\\n            if(arr[i] %2 == 0 && map.get(arr[i]/2) != null && map.get(arr[i]/2)!= i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2074764,
                "title": "python-o-n-logn-binary-search",
                "content": "Sort the array  -> **n logn**\\n\\nIterate each element and search for its double usig binary search -> **n * log n**\\n\\n**OVERALL COMPLEXITY = O ( n logn )**\\n\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        n=len(arr)\\n        for i in range(n):\\n            k=arr[i]\\n            \\n            # binary search for negatives\\n            if k<0:\\n                lo=0\\n                hi=i\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(2*k):\\n                        return True\\n                    elif arr[mid]<(2*k):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n            \\n            # binary seach for non negatives\\n            else:\\n                lo=i+1\\n                hi=n\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(k*2):\\n                        return True\\n                    elif arr[mid]<(k*2):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n                        \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        n=len(arr)\\n        for i in range(n):\\n            k=arr[i]\\n            \\n            # binary search for negatives\\n            if k<0:\\n                lo=0\\n                hi=i\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(2*k):\\n                        return True\\n                    elif arr[mid]<(2*k):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n            \\n            # binary seach for non negatives\\n            else:\\n                lo=i+1\\n                hi=n\\n                while lo<hi:\\n                    mid=(lo+hi)//2\\n                    \\n                    if arr[mid]==(k*2):\\n                        return True\\n                    elif arr[mid]<(k*2):\\n                        lo=mid+1\\n                    else:\\n                        hi=mid\\n                        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809116,
                "title": "simple-java-solution-using-loops-easy-to-understand",
                "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n         \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr.length;j++){\\n                if((arr[i]==arr[j]*2 )&& i!=j)\\n                    return true;\\n                }\\n        }\\n       \\n            \\n            \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n         \\n        for(int i=0;i<arr.length;i++){\\n            for(int j=0;j<arr.length;j++){\\n                if((arr[i]==arr[j]*2 )&& i!=j)\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1793631,
                "title": "javascript-o-n-hashset-one-pass-solution",
                "content": "```\\nvar checkIfExist = function(arr) {\\n\\tconst set = new Set();\\n\\tfor (let value of arr) {\\n\\t\\tif (set.has(2 * value) || set.has(value / 2)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(value);\\n\\t}\\n\\treturn false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfExist = function(arr) {\\n\\tconst set = new Set();\\n\\tfor (let value of arr) {\\n\\t\\tif (set.has(2 * value) || set.has(value / 2)) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tset.add(value);\\n\\t}\\n\\treturn false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697414,
                "title": "python-code-check-if-n-and-its-double-exist",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l=len(arr)\\n        for i in range(l):\\n            for j in range(l):\\n                if (i != j) and (arr[i]==2*arr[j]):\\n                    return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l=len(arr)\\n        for i in range(l):\\n            for j in range(l):\\n                if (i != j) and (arr[i]==2*arr[j]):\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342217,
                "title": "check-if-n-and-double-exists-discussed-all-3-approaches-optimized-soln-o-n",
                "content": "Discussed all three approach. If you have any doubt then pls comment down.\\n```\\n// Brute Force Two Pointer Soln\\n// Time O(n.n)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            int n = arr[pointer_one];\\n            for (pointer_two = pointer_one + 1; pointer_two < arr.size(); pointer_two++) {\\n                int m = arr[pointer_two];\\n                if ( n == (2 * m) || m == (2 * n)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n```\\n// Binary Search Soln\\n// Time O(N.logN)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for (int pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            if ((arr[pointer_one] % 2 == 0) && arr[pointer_one] < 0) {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, arr[pointer_one] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, 2 * arr[pointer_one]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n```\\n// Hash Table Soln\\n// Time: O(N)\\n// Space: O(N)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> uset;\\n        for(int& i:arr){\\n            if(uset.count(2*i) || (!(i&1) && (uset.count(i/2))))\\n                return true;\\n            uset.insert(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting",
                    "Ordered Set"
                ],
                "code": "```\\n// Brute Force Two Pointer Soln\\n// Time O(n.n)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        int pointer_one = -1;\\n        int pointer_two = -1;\\n        \\n        for (pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            int n = arr[pointer_one];\\n            for (pointer_two = pointer_one + 1; pointer_two < arr.size(); pointer_two++) {\\n                int m = arr[pointer_two];\\n                if ( n == (2 * m) || m == (2 * n)) {\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\n// Binary Search Soln\\n// Time O(N.logN)\\n// Space O(1)\\n\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for (int pointer_one = 0; pointer_one < arr.size(); pointer_one++) {\\n            if ((arr[pointer_one] % 2 == 0) && arr[pointer_one] < 0) {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, arr[pointer_one] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, pointer_one + 1, arr.size() - 1, 2 * arr[pointer_one]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n// Hash Table Soln\\n// Time: O(N)\\n// Space: O(N)\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> uset;\\n        for(int& i:arr){\\n            if(uset.count(2*i) || (!(i&1) && (uset.count(i/2))))\\n                return true;\\n            uset.insert(i);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848224,
                "title": "python-o-n-solution",
                "content": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef checkIfExist(self, arr):\\n\\t\\t\\t\\tcont=set()\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tif arr[i]*2 in cont or (arr[i]%2==0 and arr[i]//2 in cont):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tcont.add(arr[i])\\n\\t\\t\\t\\treturn False\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tclass Solution(object):\\n\\t\\t\\tdef checkIfExist(self, arr):\\n\\t\\t\\t\\tcont=set()\\n\\t\\t\\t\\tfor i in range(len(arr)):\\n\\t\\t\\t\\t\\tif arr[i]*2 in cont or (arr[i]%2==0 and arr[i]//2 in cont):\\n\\t\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t\\tcont.add(arr[i])\\n\\t\\t\\t\\treturn False\\n",
                "codeTag": "Java"
            },
            {
                "id": 631813,
                "title": "python-o-n-o-n-solution",
                "content": "Time complexity: O(n)\\nSpace complexity: O(n)\\nApproach:\\nIterate over each element (num) of the list. Check if that element is present in the set \"s\". If not, add half of num and double of num to the set, so that whenever we encounter either of these, we know that we have found a match.\\n```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        s = set()\\n        for num in arr:\\n            if num not in s:\\n                if num % 2 ==  0:\\n                    s.add(num//2)\\n                s.add(num*2)\\n            else:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        s = set()\\n        for num in arr:\\n            if num not in s:\\n                if num % 2 ==  0:\\n                    s.add(num//2)\\n                s.add(num*2)\\n            else:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539317,
                "title": "c-speed-mem-99-100-with-omega-n-o-n-2-and-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n        set<int> s;\\n        int zero_cnt = 0;\\n        int max_val = INT_MIN;\\n        \\n        //insert keys into Hash Table\\n        for(int i=0; i < arr.size(); i++){\\n            s.insert(arr[i]);\\n            if(arr[i]==0)\\n                zero_cnt++;\\n            max_val = max(max_val, arr[i]);\\n        }\\n        \\n        // check if there is more than one 0\\n        if(zero_cnt > 1)\\n            return true;\\n            \\n        // erase zero bec 2 0s case is already checked above\\n        s.erase(0);\\n        \\n        set<int>::iterator itr;\\n        int target;\\n        // target = value in the set times 2\\n        for(itr = s.begin(); itr!= s.end(); itr++){\\n            target = *itr * 2;\\n            \\n            // check N = 2 * M\\n            if(s.find(target) != s.end())\\n                return true;\\n            \\n            // if target is more than max_val in the set, no need to continue\\n            if(target>max_val)\\n                break;\\n        }\\n        \\n        return false;\\n     }\\n};       \\n        \\n/*  OBSOLETE\\n\\n    bool checkIfExist(vector<int>& arr) {        \\n        map <int,int> umap;\\n        \\n        //insert keys into Hash Table\\n        for(int i=0; i < arr.size(); i++)\\n            umap[arr[i]]++;\\n        \\n        //check if there is more than one 0\\n        if(umap.find(0) != umap.end()){\\n            if(umap[0] > 1)\\n                return true;\\n            else\\n                umap.erase(0);\\n        }\\n\\n        //check if there is N = 2 * M\\n        for(int i=0; i < arr.size(); i++){\\n            if(umap.find(2*arr[i]) != umap.end())\\n                return true;            \\n        }\\n\\n        //there is no N = 2 * M\\n        return false;\\n    }\\n*/        \\n        \\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n        set<int> s;\\n        int zero_cnt = 0;\\n        int max_val = INT_MIN;\\n        \\n        //insert keys into Hash Table\\n        for(int i=0; i < arr.size(); i++){\\n            s.insert(arr[i]);\\n            if(arr[i]==0)\\n                zero_cnt++;\\n            max_val = max(max_val, arr[i]);\\n        }\\n        \\n        // check if there is more than one 0\\n        if(zero_cnt > 1)\\n            return true;\\n            \\n        // erase zero bec 2 0s case is already checked above\\n        s.erase(0);\\n        \\n        set<int>::iterator itr;\\n        int target;\\n        // target = value in the set times 2\\n        for(itr = s.begin(); itr!= s.end(); itr++){\\n            target = *itr * 2;\\n            \\n            // check N = 2 * M\\n            if(s.find(target) != s.end())\\n                return true;\\n            \\n            // if target is more than max_val in the set, no need to continue\\n            if(target>max_val)\\n                break;\\n        }\\n        \\n        return false;\\n     }\\n};       \\n        \\n/*  OBSOLETE\\n\\n    bool checkIfExist(vector<int>& arr) {        \\n        map <int,int> umap;\\n        \\n        //insert keys into Hash Table\\n        for(int i=0; i < arr.size(); i++)\\n            umap[arr[i]]++;\\n        \\n        //check if there is more than one 0\\n        if(umap.find(0) != umap.end()){\\n            if(umap[0] > 1)\\n                return true;\\n            else\\n                umap.erase(0);\\n        }\\n\\n        //check if there is N = 2 * M\\n        for(int i=0; i < arr.size(); i++){\\n            if(umap.find(2*arr[i]) != umap.end())\\n                return true;            \\n        }\\n\\n        //there is no N = 2 * M\\n        return false;\\n    }\\n*/        \\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510869,
                "title": "c-o-1-space-and-o-nlogn-time",
                "content": "Saw quite a few linear time and space solutions, and tried to solve for constant space.\\nIdea is to:\\n1. sort array(nlogn)\\n2. binary search for 2*a[i] for each a[i]\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int i=0;\\n        for(i=0;i<a.size();i++)\\n        {\\n            int temp = bs(a,2*a[i]);\\n            if(temp!=-1&&temp!=i)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int bs(vector<int> a, int t)\\n    {\\n        int l=0,r=a.size()-1,mid=(l+r)/2;\\n        while(l<=r)\\n        {\\n            mid = (l+r)/2;\\n            if(a[mid]==t)\\n                return mid;\\n            \\n            if(a[mid]>t)\\n            r = mid -1;\\n            else\\n            l = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        int i=0;\\n        for(i=0;i<a.size();i++)\\n        {\\n            int temp = bs(a,2*a[i]);\\n            if(temp!=-1&&temp!=i)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n    int bs(vector<int> a, int t)\\n    {\\n        int l=0,r=a.size()-1,mid=(l+r)/2;\\n        while(l<=r)\\n        {\\n            mid = (l+r)/2;\\n            if(a[mid]==t)\\n                return mid;\\n            \\n            if(a[mid]>t)\\n            r = mid -1;\\n            else\\n            l = mid + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503540,
                "title": "c-concise-solution",
                "content": "**Please Up Vote**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkIfExist(vector<int>& arr) \\n\\t\\t{\\n\\t\\t\\tint c=0;\\n\\t\\t\\tset<int> s;\\n\\t\\t\\tfor(auto a:arr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a==0)c++;\\n\\t\\t\\t\\ts.insert(a);\\n\\t\\t\\t}\\n\\t\\t\\tif(c>1)return 1;\\n\\t\\t\\tfor(auto a:arr)if(a!=0&&s.find(2*a)!=s.end())return 1;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkIfExist(vector<int>& arr) \\n\\t\\t{\\n\\t\\t\\tint c=0;\\n\\t\\t\\tset<int> s;\\n\\t\\t\\tfor(auto a:arr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(a==0)c++;\\n\\t\\t\\t\\ts.insert(a);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 503435,
                "title": "java-simple-hashset-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        int n = arr.length;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(arr[i] % 2 == 0 && set.contains(arr[i] / 2) || set.contains(arr[i] * 2)) return true;\\n            set.add(arr[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        int n = arr.length;\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i = 0; i < n; i++) {\\n            if(arr[i] % 2 == 0 && set.contains(arr[i] / 2) || set.contains(arr[i] * 2)) return true;\\n            set.add(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429757,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-4lines-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q1346. Check If N and Its Double Exist***\\n\\niven an array arr of integers, check if there exists two integers N and M such that N is the double of `M` ( i.e. `N = 2 * M`).\\n\\nMore formally check if there exists two indices i and j such that :\\n\\n```\\n* i != j\\n* 0 <= i, j < arr.length\\n* arr[i] == 2 * arr[j]\\n ```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if i != j and arr[i] == 2*arr[j]: \\n                    return True\\n```\\n**Runtime:**  86 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n            for(int j=0;j<arr.length;j++)\\n                if(arr[i]==2*arr[j]&&j!=i)\\n                    return true;\\n        return false;\\n    }\\n}\\n```\\n**Runtime:**  3 ms\\n**Memory Usage:**  42.7 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n      for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr.size();j++)\\n                if(arr[i]==2*arr[j]&&j!=i)  \\n                    return true;\\n        return false;  \\n    }\\n};\\n```\\n**Runtime:**  14 ms\\t\\n**Memory Usage:**  10.1 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n* i != j\\n* 0 <= i, j < arr.length\\n* arr[i] == 2 * arr[j]\\n ```\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(len(arr)):\\n                if i != j and arr[i] == 2*arr[j]: \\n                    return True\\n```\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n            for(int j=0;j<arr.length;j++)\\n                if(arr[i]==2*arr[j]&&j!=i)\\n                    return true;\\n        return false;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n      for(int i=0;i<arr.size();i++)\\n            for(int j=0;j<arr.size();j++)\\n                if(arr[i]==2*arr[j]&&j!=i)  \\n                    return true;\\n        return false;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258764,
                "title": "easy-to-understand-c",
                "content": "i use 2 for loops to check for \\n\\n1. 1. i != j \\n2. 2. 0 <= i, j < arr.length \\n3. 3. arr[i] == 2 * arr[j]\\n\\nUpvote if you like this!\\n\\nRuntime: 12 ms, faster than 48.03% of C++ online submissions for Check If N and Its Double Exist.\\nMemory Usage: 10 MB, less than 82.19% of C++ online submissions for Check If N and Its Double Exist.\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i != j){\\n                    if(arr[i] == 2 * arr[j]){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i != j){\\n                    if(arr[i] == 2 * arr[j]){\\n                        return 1;\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2202938,
                "title": "o-n-c-solution",
                "content": "```\\nbool checkIfExist(int* arr, int arrSize){\\n    int* hash = (int*)calloc(2001, sizeof(int));/* -1000 - 0 - 1000 */\\n    int curr, process;\\n    for(int i = 0; i < arrSize; i++)\\n    {\\n        curr = arr[i];\\n        \\n        if(curr & 1) /* odd */\\n        {\\n            process = curr * 2;\\n            if((process <= 1000) && (process >= -1000) && hash[1000+process])\\n                return true;\\n        }\\n        else /* even */\\n        {\\n            process = curr * 2;\\n            if((process <= 1000) && (process >= -1000) && hash[1000+process])\\n                return true;\\n            process = curr / 2;\\n            if(hash[1000+process])\\n                return true;\\n        }\\n        hash[1000+curr]++;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkIfExist(int* arr, int arrSize){\\n    int* hash = (int*)calloc(2001, sizeof(int));/* -1000 - 0 - 1000 */\\n    int curr, process;\\n    for(int i = 0; i < arrSize; i++)\\n    {\\n        curr = arr[i];\\n        \\n        if(curr & 1) /* odd */\\n        {\\n            process = curr * 2;\\n            if((process <= 1000) && (process >= -1000) && hash[1000+process])\\n                return true;\\n        }\\n        else /* even */\\n        {\\n            process = curr * 2;\\n            if((process <= 1000) && (process >= -1000) && hash[1000+process])\\n                return true;\\n            process = curr / 2;\\n            if(hash[1000+process])\\n                return true;\\n        }\\n        hash[1000+curr]++;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539566,
                "title": "o-n-100-4-line-code-using-hash",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& v) {\\n        \\n        unordered_set<int> us;\\n        for(int i = 0; i < v.size(); i++)\\n            if( (us.find(2 * v[i]) != us.end()) || ( (v[i] % 2 == 0) && us.find(v[i] / 2) != us.end() ) )    //found double or half in set \\n                    return 1;\\n            else\\n                us.insert(v[i]);\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& v) {\\n        \\n        unordered_set<int> us;\\n        for(int i = 0; i < v.size(); i++)\\n            if( (us.find(2 * v[i]) != us.end()) || ( (v[i] % 2 == 0) && us.find(v[i] / 2) != us.end() ) )    //found double or half in set \\n                    return 1;\\n            else\\n                us.insert(v[i]);\\n        return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1476455,
                "title": "4ms-c-o-n-logn-binary-search-negative-test-case",
                "content": "Runtime: 4 ms, faster than 93.82% of C++ online submissions for Check If N and Its Double Exist.\\nMemory Usage: 9.8 MB, less than 99.52% of C++ online submissions for Check If N and Its Double Exist.\\n```\\n\\tbool checkIfExist(vector<int>& arr) {\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\tint start, end;\\n\\t\\tfor(int i = 0; i<= arr.size()-1; i++){\\n\\t\\t\\tint target = arr[i];\\n\\t\\t\\tif (target < 0){\\n\\t\\t\\t\\tstart = 0;\\n\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\tend = arr.size() - 1;\\n\\t\\t\\t}\\n\\t\\t\\twhile(start <= end){\\n\\t\\t\\t\\tint mid = start + (end - start)/2;\\n\\t\\t\\t\\tif(target*2 == arr[mid]) return true;\\n\\t\\t\\t\\telse if(target*2 < arr[mid]) end = mid - 1;\\n\\t\\t\\t\\telse start = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```\\nFor the negative number test case such as: [-10,12,-20,-8,15], we get a sorted array [-20,-10,-8,12,15].\\nIn this case -10 & -20 are a pair. Here if we use binary search in the forward direction then it will always return in false. That\\'s why I added the if-else condition before the while-loop which will make the start and end position for checking. We can also abs() funciton while comparing in the while-loop, but I used this method instead. Thanks!\\n\\nUpdate: I have uploaded another solution <a href=\"https://leetcode.com/problems/check-if-n-and-its-double-exist/discuss/1510247/C++-0ms-Beats-100-No-Fancy-or-Easy-Code\">here</a>. It beats 100% and is 0ms runtime.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n\\tbool checkIfExist(vector<int>& arr) {\\n\\t\\tsort(arr.begin(), arr.end());\\n\\t\\tint start, end;\\n\\t\\tfor(int i = 0; i<= arr.size()-1; i++){\\n\\t\\t\\tint target = arr[i];\\n\\t\\t\\tif (target < 0){\\n\\t\\t\\t\\tstart = 0;\\n\\t\\t\\t\\tend = i - 1;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tstart = i + 1;\\n\\t\\t\\t\\tend = arr.size() - 1;\\n\\t\\t\\t}\\n\\t\\t\\twhile(start <= end){\\n\\t\\t\\t\\tint mid = start + (end - start)/2;\\n\\t\\t\\t\\tif(target*2 == arr[mid]) return true;\\n\\t\\t\\t\\telse if(target*2 < arr[mid]) end = mid - 1;\\n\\t\\t\\t\\telse start = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1173341,
                "title": "java-array-hashset-beats-99-98-1ms-t-c-o-n-s-c-o-n",
                "content": "\\n    // O(arr.length) O(1)\\n\\tpublic boolean checkIfExist(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint num = arr[i];\\n\\t\\t\\tif (num % 2 == 0 && set.contains(num / 2))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (set.contains(2 * num))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tset.add(num);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(arr.length) O(1)\\n\\tpublic boolean checkIfExist(int[] arr) {\\n\\n\\t\\tint len = arr.length;\\n\\t\\tHashSet<Integer> set = new HashSet<>();\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint num = arr[i];\\n\\t\\t\\tif (num % 2 == 0 && set.contains(num / 2))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tif (set.contains(2 * num))\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\tset.add(num);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 809704,
                "title": "swift-set-solution-o-n-100",
                "content": "```\\nfunc checkIfExist(_ arr: [Int]) -> Bool {\\n\\tvar nums = Set<Int>()\\n\\n\\tfor num in arr {\\n\\t\\tif nums.contains(num * 2) { return true }\\n\\t\\tif num % 2 == 0 && nums.contains(num / 2) { \\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tnums.insert(num)\\n\\t}\\n\\n\\treturn false\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc checkIfExist(_ arr: [Int]) -> Bool {\\n\\tvar nums = Set<Int>()\\n\\n\\tfor num in arr {\\n\\t\\tif nums.contains(num * 2) { return true }\\n\\t\\tif num % 2 == 0 && nums.contains(num / 2) { \\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tnums.insert(num)\\n\\t}\\n\\n\\treturn false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719911,
                "title": "c-solution-with-unordered-set",
                "content": "```\\nbool checkIfExist(vector<int> &arr) {\\n    unordered_set<int> checks;\\n    for (const int &i : arr) {\\n        if (checks.find(i * 2) != checks.end() ||\\n            (i % 2 == 0) && checks.find(i / 2) != checks.end()) {\\n            return true;\\n        }\\n        checks.insert(i);\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkIfExist(vector<int> &arr) {\\n    unordered_set<int> checks;\\n    for (const int &i : arr) {\\n        if (checks.find(i * 2) != checks.end() ||\\n            (i % 2 == 0) && checks.find(i / 2) != checks.end()) {\\n            return true;\\n        }\\n        checks.insert(i);\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539531,
                "title": "two-dict-beats-99-speed-100-memory",
                "content": "\\tclass Solution:\\n\\tdef checkIfExist(self, arr: List[int]) -> bool:\\n\\t\\tdouble = {}\\n\\t\\tsingle = {}\\n\\t\\tfor num in arr:\\n\\t\\t\\tif num in double or num in single:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\telse:\\n\\t\\t\\t\\tdouble[num*2]=num\\n\\t\\t\\t\\tsingle[num/2]=num\\n\\n\\t\\treturn False",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\tdef checkIfExist(self, arr: List[int]) -> bool:\\n\\t\\tdouble = {}",
                "codeTag": "Java"
            },
            {
                "id": 523539,
                "title": "c-92-ms",
                "content": "\\tpublic class Solution\\n    {\\n        public bool CheckIfExist(int[] arr)\\n        {\\n            var set = arr.ToHashSet();\\n            foreach (int v in set)\\n            {\\n                if (v != 0 && set.Contains(2 * v))\\n                {\\n                    return true;\\n                }\\n            }\\n            return arr.Count(v => v == 0) > 1;\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public bool CheckIfExist(int[] arr)\\n        {\\n            var set = arr.ToHashSet();\\n            foreach (int v in set)\\n            {\\n                if (v != 0 && set.Contains(2 * v))\\n                {\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 519434,
                "title": "javascript-solution-2-for-loops",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] * 2 === arr[j] || arr[i] / 2 === arr[j]) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        for (let j = 0; j < i; j++) {\\n            if (arr[i] * 2 === arr[j] || arr[i] / 2 === arr[j]) return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503437,
                "title": "clean-python-3-set",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        s = set()\\n        for num in arr:\\n            if 2 * num in s: return True\\n            if not num % 2 and num // 2 in s: return True\\n            s.add(num)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        s = set()\\n        for num in arr:\\n            if 2 * num in s: return True\\n            if not num % 2 and num // 2 in s: return True\\n            s.add(num)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755216,
                "title": "very-simple-solution-c-same-logic-for-other-programming-languages-too-try-it",
                "content": "# Flow of Code\\nLooping through the vector and checking the condtions i!=j,(statisfied by for loops starting) and arr[i]==2*arr[j] or arr[i]*2==arr[j] if these conditions statisfied return true or return false as answer.\\n\\n# Use Same Logic in other languages such as C, Java, Python, Javascript etc... to achieve the result.\\n\\n# Code\\n# C++\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                if(arr[i]==2*arr[j] || 2*arr[i]==arr[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n# C\\n```\\nbool checkIfExist(int* arr, int arrSize){\\n    for(int i=0;i<arrSize;i++){\\n        for(int j=i+1;j<arrSize;j++){\\n            if(*(arr+i)*2==*(arr+j) || *(arr+i)==*(arr+j)*2)\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\n```\\n# Java\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                if(arr[i]*2==arr[j] || arr[i]==2*arr[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n# JavaScript\\n```\\nvar checkIfExist = function(arr) {\\n    for(var i=0;i<arr.length;i++){\\n        for(var j=i+1;j<arr.length;j++){\\n            if(arr[i]==arr[j]*2 || arr[i]*2==arr[j])\\n                return true;\\n        }\\n    }\\n    return false;\\n};\\n```\\n# Python\\n```\\nclass Solution(object):\\n    def checkIfExist(self, arr):\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```\\n# Python3\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```\\n\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            for(int j=i+1;j<arr.size();j++){\\n                if(arr[i]==2*arr[j] || 2*arr[i]==arr[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nbool checkIfExist(int* arr, int arrSize){\\n    for(int i=0;i<arrSize;i++){\\n        for(int j=i+1;j<arrSize;j++){\\n            if(*(arr+i)*2==*(arr+j) || *(arr+i)==*(arr+j)*2)\\n                return true;\\n        }\\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            for(int j=i+1;j<arr.length;j++){\\n                if(arr[i]*2==arr[j] || arr[i]==2*arr[j])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\nvar checkIfExist = function(arr) {\\n    for(var i=0;i<arr.length;i++){\\n        for(var j=i+1;j<arr.length;j++){\\n            if(arr[i]==arr[j]*2 || arr[i]*2==arr[j])\\n                return true;\\n        }\\n    }\\n    return false;\\n};\\n```\n```\\nclass Solution(object):\\n    def checkIfExist(self, arr):\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(0,len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[i]*2==arr[j] or arr[i]==arr[j]*2:\\n                    return True;\\n        return False;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573988,
                "title": "easy-solution-using-hashmap-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> temp;\\n        \\n        for (int i = 0; i < arr.size(); i++) {\\n            temp[arr[i]]++; \\n        }\\n        \\n        for (auto i : arr) {\\n            if (i != 0 && temp.find(i * 2) != temp.end()) {\\n                return true;\\n            } else if (i == 0 && temp[0] >= 2) {\\n                return true;\\n            } \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> temp;\\n        \\n        for (int i = 0; i < arr.size(); i++) {\\n            temp[arr[i]]++; \\n        }\\n        \\n        for (auto i : arr) {\\n            if (i != 0 && temp.find(i * 2) != temp.end()) {\\n                return true;\\n            } else if (i == 0 && temp[0] >= 2) {\\n                return true;\\n            } \\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3395056,
                "title": "hashset-solution-for-c-explanation-complexity",
                "content": "# Approach\\nHashSet provides O(1) lookup, so it ideal for this question. \\nFor each number in the array we check, if we have already seen  it\\'s half or it\\'s double.\\n\\nNOTE: When checking half, we need to ensure that the current number is  even, else we will get wrong answer like in the case of 3 and 7 being in the input.\\nHere for 7, 7/2 would give 3 (not 3.5) which is present in the HashSet but not what we need.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\npublic bool CheckIfExistHash(int[] arr)\\n{\\n    var hash = new HashSet<int>(arr.Length);\\n\\n    foreach (var item in arr)\\n    {\\n        if (hash.Contains(item * 2) || (item % 2 == 0 && hash.Contains(item / 2)))\\n        {\\n            return true;\\n        }\\n\\n        hash.Add(item);\\n    }\\n\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic bool CheckIfExistHash(int[] arr)\\n{\\n    var hash = new HashSet<int>(arr.Length);\\n\\n    foreach (var item in arr)\\n    {\\n        if (hash.Contains(item * 2) || (item % 2 == 0 && hash.Contains(item / 2)))\\n        {\\n            return true;\\n        }\\n\\n        hash.Add(item);\\n    }\\n\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3235490,
                "title": "python-easy-solution-beats-98-66-runtime-28ms",
                "content": "\\n# Approach\\n\\nHere we are first traversing the array and for each element we are checking if that value multiplied by 2 is present in array or not.\\nTo exclude that particular element we are using list concatenation\\ni.e. arr[ : i ]+arr[i+1 : ] by this we will be checking all elements of array except the one at which we are currently present because if number would be 0 then its multiplication by 2 will be 0 and it will return true and we don\\'t want that to happen.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def checkIfExist(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False\\n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def checkIfExist(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(len(arr)):\\n            if arr[i]*2 in (arr[:i]+arr[i+1:]):\\n                return True\\n        \\n        return False\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838923,
                "title": "4-lines-python-solution-using-sets-40-ms-easy",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        if arr.count(0) > 1: return 1\\n        S = set(arr) - {0}\\n        for i in arr:\\n            if 2*i in S: return 1\\n        return 0\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        if arr.count(0) > 1: return 1\\n        S = set(arr) - {0}",
                "codeTag": "Java"
            },
            {
                "id": 2745257,
                "title": "python-o-n-2-o-nlogn-o-n-explained",
                "content": "# **1. BRUTE FORCE - O(N^2)**\\nAccording to the constraints, the list length will be at most 500. So we can write a Brute Force solution and that will be accepted.\\n\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        # For Each Element in the Array\\n        for i in range(len(arr)):\\n            # Go through each element\\n            for j in range(len(arr)):\\n                # Check if condition is met\\n                # If yes, return True\\n                if i != j and arr[i] == 2 * arr[j]: return True\\n        \\n        # If we come out of the first loop, that means, there is no such pair\\n        # Hence, return False\\n        return False\\n\\n# **2. BINARY SEARCH - O(NLogN)**\\n\\nCan we do better than O(N^2)? \\n\\nFor every element, we are looking at every other element to see if it is a double. We have to do this because the list is not sorted so it is possible that for any element, its double is before it or after it in the list. \\n\\nBut if the list was sorted, then we can apply Binary Search because then, if the mid element is not double, then either it will be more than double or less than double. And based on that, we can either discard the left half or the right half. This will bring the complexity down to O(NLogN)\\n\\n```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        # To apply Binary Search, first sort the list\\n        arr.sort()\\n        \\n        n = len(arr)\\n        \\n        # For each element in the list\\n        for i,num in enumerate(arr):\\n            # Binary Search for its double\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # We also need to make sure i != j\\n                if arr[mid] == 2 * num and i != mid: return True\\n                \\n                # If the element at mid is less than the double of num\\n                # Then search for double at right of mid\\n                if arr[mid] < 2 * num: start = mid + 1\\n                    \\n                # Otherwise search for the double at the left side of mid\\n                else: end = mid - 1\\n                    \\n        \\n        return False\\n```\\n\\n# **3. USING A SET - O(N)**\\n\\nIs there a way to solve this problem in just one loop? Yes! See, we know that if the list is not sorted, then for any element, its double can either be on its left or its right. For a moment, lets forget that it is on the right. If the double of an element is on its left, then is there a way to check if the double exists on left in O(1) time? That\\'s where we can use a Set.\\n\\nAs we loop through every element, we also keep checking if we have already came across the double of that element before in the array. If yes, we got a pair. If not, we can put that element in set and move to the next iteration. \\n\\nBut there is one issue.\\n\\nLets take an example - \\n\\n\\t\\t\\t5 ,13, 10 ,6\\n\\t\\t\\t\\n\\t\\t\\tHere, when we start the loop, we put 5 and 13 in the set as their doubles are not in set yet\\n\\t\\t\\t\\n\\t\\t\\tSo, set = (5, 13)\\n\\t\\t\\t\\n\\t\\t\\tNow when we come to 10. We check if its double is in the set. We don\\'t find it so we move on.\\n\\t\\t\\t\\n\\t\\t\\tAnd at the end, we return False.\\n\\t\\t\\t\\n\\t\\t\\tBut if you see, the double of 5 is 10 so there is a valid pair which means we should return True.\\n\\t\\t\\t\\n\\t\\t\\tAnd now you can see that we not only need to check for the double in set but also for the half.\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\tSo, for every element, we check if its half exists in set or if its double exists in set.\\n\\t\\t\\t\\n\\t\\t\\tIn both cases, we have a valid pair.\\n\\t\\t\\t\\nAnd that\\'s the whole idea of this approach.\\n\\nDo note that this approach will use extra space, something the previous two solutions don\\'t.\\n\\n```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        # Set so that lookup is in constant time\\n        nums = set()\\n        \\n        for el in arr:\\n            # if the double of this element is present in set\\n            # Or its half is present in the set\\n            # Then we have a pair\\n            if el * 2 in nums or el / 2 in nums: return True\\n            \\n            # Otherwise, add this element to set and move to the next iteration\\n            nums.add(el)\\n            \\n    \\n        # If we come out of loop, that means, there is no valid pair at all\\n        return False\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        # To apply Binary Search, first sort the list\\n        arr.sort()\\n        \\n        n = len(arr)\\n        \\n        # For each element in the list\\n        for i,num in enumerate(arr):\\n            # Binary Search for its double\\n            start, end = 0, n - 1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                # We also need to make sure i != j\\n                if arr[mid] == 2 * num and i != mid: return True\\n                \\n                # If the element at mid is less than the double of num\\n                # Then search for double at right of mid\\n                if arr[mid] < 2 * num: start = mid + 1\\n                    \\n                # Otherwise search for the double at the left side of mid\\n                else: end = mid - 1\\n                    \\n        \\n        return False\\n```\n```\\ndef checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        # Set so that lookup is in constant time\\n        nums = set()\\n        \\n        for el in arr:\\n            # if the double of this element is present in set\\n            # Or its half is present in the set\\n            # Then we have a pair\\n            if el * 2 in nums or el / 2 in nums: return True\\n            \\n            # Otherwise, add this element to set and move to the next iteration\\n            nums.add(el)\\n            \\n    \\n        # If we come out of loop, that means, there is no valid pair at all\\n        return False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2556584,
                "title": "clean-and-easy-code",
                "content": "**please upvote if you like**\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++){\\n            int target=2*arr[i];\\n            int start=0;\\n            int end=arr.length-1;\\n            while(start<=end ){\\n                int mid=start+(end-start)/2;\\n                if(arr[mid]==target&& mid!=i){\\n                    return true;\\n                }\\n                else if(arr[mid]<target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++){\\n            int target=2*arr[i];\\n            int start=0;\\n            int end=arr.length-1;\\n            while(start<=end ){\\n                int mid=start+(end-start)/2;\\n                if(arr[mid]==target&& mid!=i){\\n                    return true;\\n                }\\n                else if(arr[mid]<target){\\n                    start=mid+1;\\n                }\\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556196,
                "title": "c-easy-3-methods-fast",
                "content": "## Method1 : \\n### Brute Force -> O(N^2)\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0;i< arr.size()-1;i++){\\n\\t\\t\\tfor(int j=i+1;j<arr.size();j++){\\n\\t\\t\\t\\tif(arr[i]*2==arr[j] || arr[j]*2==arr[i]) \\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};\\n```\\n\\\\\\n## Method2 : \\n### Using Map STL -> O(N+NlogN)\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        map<int, int> mp;\\n        \\n        for(auto i : arr)\\n            mp[i]++;\\n        \\n        for(auto i : arr){\\n            if(i == 0 && mp[i] > 1)\\n                return true;\\n            if(i!=0 && mp[2*i] > 0){\\n                cout<<i<<endl;\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\\\\\n## Method3 : \\n### Using Binary Search -> O(NlogN)\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            int idx = lower_bound(arr.begin(),arr.end(), 2*arr[i]) - arr.begin();\\n            \\n            if(idx < arr.size() && arr[idx] == 2*arr[i] && i != idx) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0;i< arr.size()-1;i++){\\n\\t\\t\\tfor(int j=i+1;j<arr.size();j++){\\n\\t\\t\\t\\tif(arr[i]*2==arr[j] || arr[j]*2==arr[i]) \\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        map<int, int> mp;\\n        \\n        for(auto i : arr)\\n            mp[i]++;\\n        \\n        for(auto i : arr){\\n            if(i == 0 && mp[i] > 1)\\n                return true;\\n            if(i!=0 && mp[2*i] > 0){\\n                cout<<i<<endl;\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            int idx = lower_bound(arr.begin(),arr.end(), 2*arr[i]) - arr.begin();\\n            \\n            if(idx < arr.size() && arr[idx] == 2*arr[i] && i != idx) \\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2508001,
                "title": "o-n-unordered-multiset-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_multiset<int> s;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if((arr[i]%2 == 0 && s.find(arr[i]/2) != s.end()) || s.find(arr[i]*2) != s.end())\\n                return true;\\n            s.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_multiset<int> s;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if((arr[i]%2 == 0 && s.find(arr[i]/2) != s.end()) || s.find(arr[i]*2) != s.end())\\n                return true;\\n            s.insert(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2429397,
                "title": "java-0ms-faster-than-100-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr)\\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(Integer i: arr)\\n        {\\n            if(set.contains(i*2) || (i%2 == 0 && set.contains(i/2)))\\n                return true;\\n            \\n            set.add(i);\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr)\\n    {\\n        HashSet<Integer> set = new HashSet<>();\\n        \\n        for(Integer i: arr)\\n        {\\n            if(set.contains(i*2) || (i%2 == 0 && set.contains(i/2)))\\n                return true;\\n            \\n            set.add(i);\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417691,
                "title": "javascipt-solution-using-a-set-object",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar checkIfExist = function (arr) {\\n    let intSet = new Set(arr)\\n    if (intSet.has(0) && arr.filter(e => e === 0).length >= 2) return true\\n   \\n    for (let element of intSet) {\\n        if (element !== 0) {\\n            if (intSet.has(element * 2) || intSet.has(element / 2)) return true\\n        }\\n    };\\n\\t\\n    return false\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar checkIfExist = function (arr) {\\n    let intSet = new Set(arr)\\n    if (intSet.has(0) && arr.filter(e => e === 0).length >= 2) return true\\n   \\n    for (let element of intSet) {\\n        if (element !== 0) {\\n            if (intSet.has(element * 2) || intSet.has(element / 2)) return true\\n        }\\n    };\\n\\t\\n    return false\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2242376,
                "title": "c-solution-6ms-better-than-90-easy-to-understand",
                "content": "```\\nbool checkIfExist(vector<int>& arr) {\\n        int num[2001]={-1};\\n        \\n        int n = arr.size(), count=0;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\tif(arr[i]==0)   count++;\\n\\t\\t\\tif(count==2)    return true;\\n\\t\\t}\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            if(arr[i]!=0)                num[arr[i]+1000]=10;\\n     \\n        for(int i=0; i<arr.size(); i++){\\n            if(-500<=arr[i] && arr[i]<=500)\\n                if(num[2*(arr[i])+1000]==10)    return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nbool checkIfExist(vector<int>& arr) {\\n        int num[2001]={-1};\\n        \\n        int n = arr.size(), count=0;\\n        for(int i=0; i<n; i++) {\\n\\t\\t\\tif(arr[i]==0)   count++;\\n\\t\\t\\tif(count==2)    return true;\\n\\t\\t}\\n        \\n        for(int i=0; i<arr.size(); i++)\\n            if(arr[i]!=0)                num[arr[i]+1000]=10;\\n     \\n        for(int i=0; i<arr.size(); i++){\\n            if(-500<=arr[i] && arr[i]<=500)\\n                if(num[2*(arr[i])+1000]==10)    return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2194660,
                "title": "java-easy-binary-search",
                "content": "**If it helps, do an Upvote \\u2B06\\uFE0F\\uD83C\\uDD99 So others can also find it helpful**\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i = 0 ; i < arr.length; i++){\\n           int indexDouble = binary(arr , arr[i] * 2);\\n            if(indexDouble != i && indexDouble != -1){     \\n                return true;\\n            } \\n        }\\n        return false;\\n    }\\n    int binary(int[] arr , int key){\\n        int s = 0;\\n        int e = arr.length - 1;\\n        \\n        while(s <= e){\\n            int m = s + (e-s)/2;\\n            if(key == arr[m]) \\n                return m;\\n            if(key > arr[m]) \\n                s = m + 1;\\n            else\\n                e = m - 1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i = 0 ; i < arr.length; i++){\\n           int indexDouble = binary(arr , arr[i] * 2);\\n            if(indexDouble != i && indexDouble != -1){     \\n                return true;\\n            } \\n        }\\n        return false;\\n    }\\n    int binary(int[] arr , int key){\\n        int s = 0;\\n        int e = arr.length - 1;\\n        \\n        while(s <= e){\\n            int m = s + (e-s)/2;\\n            if(key == arr[m]) \\n                return m;\\n            if(key > arr[m]) \\n                s = m + 1;\\n            else\\n                e = m - 1; \\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096365,
                "title": "c-very-basic-understanding-code-0ms-100-faster-code",
                "content": "It\\'s a very simple question and Approach is also much easy.\\n\\nApproach\\n\\n1. Take each element from array,\\n2. Compare it with each other elements of array (except from itself),\\n3. If any element found it\\'s double then return true\\n4. If not then after ending these loops, return false.\\n\\n\\n```\\n\\nfor(int i=0; i<arr.size(); i++)\\n{\\n    for(int j=0; j<arr.size(); j++)\\n    {\\n\\t\\tif(i == j)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif(arr[j] == 2 * arr[i])\\n\\t\\t\\treturn true;\\n\\t}\\n}\\nreturn false;\\n\\n```\\n\\nYeah, It\\'s a very easy approach and it\\'s giving 100% Perfect Solution, so if like my approach Please Upvote it.",
                "solutionTags": [],
                "code": "```\\n\\nfor(int i=0; i<arr.size(); i++)\\n{\\n    for(int j=0; j<arr.size(); j++)\\n    {\\n\\t\\tif(i == j)\\n\\t\\t\\tcontinue;\\n\\n\\t\\tif(arr[j] == 2 * arr[i])\\n\\t\\t\\treturn true;\\n\\t}\\n}\\nreturn false;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087892,
                "title": "binary-search-c-solution-100-faster",
                "content": "for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                k++;\\n        }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0)\\n                k++;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1768271,
                "title": "java-easy-binary-search",
                "content": "Please upvote if you find it helpful\\n\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        int c=0;\\n        if(arr.length == 1)\\n            return false;\\n        for(int i:arr){\\n            if(i != 0){\\n                if( bs(arr,i*2))\\n                return true;\\n            }\\n            \\n            else c++;\\n        }\\n        return c > 1;\\n    }\\n public boolean bs(int[]arr,int m){\\n     int l=0,h=arr.length-1;\\n     while(l<=h)\\n     {\\n         int mid = l +(h-l)/2;\\n         if(arr[mid] == m){\\n             return true;\\n         }\\n         else if(arr[mid]>m)\\n             h = mid-1;\\n         else l = mid+1;\\n     }\\n     return false;\\n }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        int c=0;\\n        if(arr.length == 1)\\n            return false;\\n        for(int i:arr){\\n            if(i != 0){\\n                if( bs(arr,i*2))\\n                return true;\\n            }\\n            \\n            else c++;\\n        }\\n        return c > 1;\\n    }\\n public boolean bs(int[]arr,int m){\\n     int l=0,h=arr.length-1;\\n     while(l<=h)\\n     {\\n         int mid = l +(h-l)/2;\\n         if(arr[mid] == m){\\n             return true;\\n         }\\n         else if(arr[mid]>m)\\n             h = mid-1;\\n         else l = mid+1;\\n     }\\n     return false;\\n }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733404,
                "title": "c-time-complexity-o-n-space-complexity-o-n",
                "content": "# If you think this code as best code with time complexity, then please upvote. Because if you upvote it, I will be getting motivation..\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> N, M;\\n        for(auto x: arr)\\n        {\\n            if(N.find(x) != N.end()) return true;\\n            if(M.find(x) != M.end()) return true;\\n            if(x%2 == 0) N.insert(x/2);\\n            M.insert(x*2);\\n        }\\n        return false;\\n    }// time complexity : O(N)\\n    //space complexity: O(N)\\n};",
                "solutionTags": [],
                "code": "# If you think this code as best code with time complexity, then please upvote. Because if you upvote it, I will be getting motivation..\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> N, M;\\n        for(auto x: arr)\\n        {\\n            if(N.find(x) != N.end()) return true;\\n            if(M.find(x) != M.end()) return true;\\n            if(x%2 == 0) N.insert(x/2);\\n            M.insert(x*2);\\n        }\\n        return false;\\n    }// time complexity : O(N)\\n    //space complexity: O(N)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1697423,
                "title": "python-code-check-if-n-and-its-double-exist-improved",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l=len(arr)\\n        for i in arr:\\n            if i*2 in arr or i/2 in arr:\\n                return True\\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l=len(arr)\\n        for i in arr:\\n            if i*2 in arr or i/2 in arr:\\n                return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183156,
                "title": "rust-o-n-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn check_if_exist(arr: Vec<i32>) -> bool {\\n        let mut set = std::collections::HashSet::new();\\n        arr.iter().any(|&x| {\\n            let found = set.contains(&(x * 2)) || x % 2 == 0 && set.contains(&(x / 2));\\n            set.insert(x);\\n            found\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn check_if_exist(arr: Vec<i32>) -> bool {\\n        let mut set = std::collections::HashSet::new();\\n        arr.iter().any(|&x| {\\n            let found = set.contains(&(x * 2)) || x % 2 == 0 && set.contains(&(x / 2));\\n            set.insert(x);\\n            found\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1086699,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int num,size = arr.size();\\n        for(int i=0;i<size;i++){\\n            num = 2*arr[i];\\n            for(int j=0;j<size;j++){\\n                    if(j!=i && num==arr[j] ){\\n                        return true;\\n            }\\n        }\\n            \\n    }\\n        return false;\\n    }\\n        \\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int num,size = arr.size();\\n        for(int i=0;i<size;i++){\\n            num = 2*arr[i];\\n            for(int j=0;j<size;j++){\\n                    if(j!=i && num==arr[j] ){\\n                        return true;\\n            }\\n        }\\n            \\n    }\\n        return false;\\n    }\\n        \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997926,
                "title": "java-1-iteration",
                "content": "```    \\npublic boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++) {\\n            if(set.contains(arr[i]*2) || (arr[i]%2==0 && set.contains(arr[i]/2)))\\n                return true;\\n            set.add(arr[i]);\\n        }\\n        return false;\\n}",
                "solutionTags": [],
                "code": "```    \\npublic boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<arr.length; i++) {\\n            if(set.contains(arr[i]*2) || (arr[i]%2==0 && set.contains(arr[i]/2)))\\n                return true;\\n            set.add(arr[i]);\\n        }\\n        return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 624111,
                "title": "one-line-javascript-solution",
                "content": "> Runtime: 56 ms, faster than 74.60% of JavaScript online submissions for Check If N and Its Double Exist.\\nMemory Usage: 35.2 MB, less than 100.00% of JavaScript online submissions for Check If N and Its Double Exist.\\n```js\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    return arr.filter(e=> arr.includes(e*2))\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    return arr.filter(e=> arr.includes(e*2))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503477,
                "title": "java-find-last-index",
                "content": "```\\n    public boolean checkIfExist(int[] arr) {\\n        ArrayList<Integer> arrayList = new ArrayList<Integer>();\\n        for(int i : arr) arrayList.add(i);\\n        for(int i =0 ; i< arrayList.size(); i++){\\n            if( arrayList.get(i) % 2 == 0 ) {\\n                int index = arrayList.lastIndexOf(arrayList.get(i) / 2);\\n                if ( index != -1 && index != i)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean checkIfExist(int[] arr) {\\n        ArrayList<Integer> arrayList = new ArrayList<Integer>();\\n        for(int i : arr) arrayList.add(i);\\n        for(int i =0 ; i< arrayList.size(); i++){\\n            if( arrayList.get(i) % 2 == 0 ) {\\n                int index = arrayList.lastIndexOf(arrayList.get(i) / 2);\\n                if ( index != -1 && index != i)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927333,
                "title": "check-if-n-and-its-double-exist-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                if(arr[i] == 2 * arr[j] && i != j){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                if(arr[i] == 2 * arr[j] && i != j){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790533,
                "title": "4-c-solutions-hash-set-hash-map-binary-search-and-two-pointer-approach",
                "content": "\\n# Code\\n```\\n// Solution 1 (Hash set)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            if(set.count(2*arr[i])>0 || ((arr[i]%2==0) && set.count(arr[i]/2)>0))\\n                return true;\\n            set.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 (Hash table)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<arr.size(); i++){\\n            if(mp.find(arr[i]*2) != mp.end())\\n                return true;\\n            else if(arr[i]%2==0 && mp.find(arr[i]/2) != mp.end())\\n                return true;\\n            mp[arr[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 3 (Two-pointers)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (int j = i + 1; j < arr.size(); j++) {\\n                if ( arr[i] == (2 * arr[j]) || arr[j] == (2 * arr[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 4 (Binary search)\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for(int i = 0; i < arr.size(); i++) {\\n            if((arr[i] % 2 == 0) && arr[i] < 0) {\\n                if(binarySearch(arr, i + 1, arr.size() - 1, arr[i] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, i + 1, arr.size() - 1, 2 * arr[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Solution 1 (Hash set)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> set;\\n        for(int i=0;i<arr.size();i++){\\n            if(set.count(2*arr[i])>0 || ((arr[i]%2==0) && set.count(arr[i]/2)>0))\\n                return true;\\n            set.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 2 (Hash table)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for(int i=0; i<arr.size(); i++){\\n            if(mp.find(arr[i]*2) != mp.end())\\n                return true;\\n            else if(arr[i]%2==0 && mp.find(arr[i]/2) != mp.end())\\n                return true;\\n            mp[arr[i]] = i;\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 3 (Two-pointers)\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        for (int i = 0; i < arr.size(); i++) {\\n            for (int j = i + 1; j < arr.size(); j++) {\\n                if ( arr[i] == (2 * arr[j]) || arr[j] == (2 * arr[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n// Solution 4 (Binary search)\\nclass Solution {\\npublic:\\n    bool binarySearch (vector<int> &arr, int l, int r, int target)\\n    {\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n            if (arr[m] == target)\\n                return true;\\n            else if (arr[m] > target)\\n                r = m - 1;\\n            else\\n                l = m + 1;\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        for(int i = 0; i < arr.size(); i++) {\\n            if((arr[i] % 2 == 0) && arr[i] < 0) {\\n                if(binarySearch(arr, i + 1, arr.size() - 1, arr[i] / 2))\\n                    return true; \\n            }\\n            else {\\n                if (binarySearch(arr, i + 1, arr.size() - 1, 2 * arr[i]))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789350,
                "title": "easy-approach-using-for-loop",
                "content": "Time complexity:\\nO(n^2)\\nSpace complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for (int i=0;i<arr.length;i++){\\n            for(int j =0;j<arr.length;j++){\\n                if(arr[i]==arr[j]*2 &&i!=j){\\n                    return true;\\n                }\\n            }\\n            }\\n         return false ;\\n          \\n        } \\n}\\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for (int i=0;i<arr.length;i++){\\n            for(int j =0;j<arr.length;j++){\\n                if(arr[i]==arr[j]*2 &&i!=j){\\n                    return true;\\n                }\\n            }\\n            }\\n         return false ;\\n          \\n        } \\n}\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738340,
                "title": "simple-c-solution-with-explanation-unordered-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhile reading this problem we are getting the intuition of Binary search or some similar technique.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Here we can use the binary search, but it is not mentioned that then input array is sorted, so we need to sort the input array before applying the binary search.\\n2. Another approach is to use set, which has a default property of sorting the input while it is getting inserted. Since we can have a duplicate items so we will use unordered_set, which will sort the input while inserting.\\n3. Apply the find function for unordered_map to satisfy the condition given s[i] == 2*s[j], where 0<i<j;\\n4. taking care of bourdary cases where we can have more than one \\'0\\' in the input array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s;\\n        for(auto a:arr)\\n        {\\n            s.insert(a);\\n        }\\n        for(auto s1:s)\\n        {\\n            if(s1 !=0 && s.find(s1*2)!=s.end()) return true;\\n        }\\n        return count(arr.begin(),arr.end(),0)>1;\\n\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s;\\n        for(auto a:arr)\\n        {\\n            s.insert(a);\\n        }\\n        for(auto s1:s)\\n        {\\n            if(s1 !=0 && s.find(s1*2)!=s.end()) return true;\\n        }\\n        return count(arr.begin(),arr.end(),0)>1;\\n\\n    }\\n};\\n# IF THIS CODE  IS HELPFUL,  THEN  PLEASE UPVOTE!!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688668,
                "title": "best-java-solution-easy-to-understand-beats-99-39",
                "content": "# Intuition\\nThe intuition behind the provided code is to check if there exists a pair of elements in the array arr where one element is exactly twice the other.\\n\\nThe code achieves this by iterating over each element in the array using the outer loop and comparing it with every other element in the array using the inner loop. For each pair of elements (i, j), it checks if arr[i] is equal to arr[j]*2 and also ensures that i is not equal to j. If such a pair is found, it immediately returns true, indicating that the condition is satisfied.\\n\\nThis approach leverages a brute-force technique to exhaustively search for a matching pair. By considering all possible combinations, the code determines whether there is a valid pair in the array. If no such pair is found after checking all possible combinations, the code returns false, indicating that there is no pair where one element is exactly twice the other.\\n\\nHowever, it\\'s worth noting that this brute-force approach has a time complexity of O(n^2), where n is the length of the input array. This means that for larger arrays, the code may not be efficient. Alternative approaches, such as using a HashSet or sorting the array, can provide more optimized solutions with lower time complexities.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach used in the provided code is a brute-force approach to check if there exists a pair of elements in the array arr where one element is exactly twice the other.\\n\\nThe code iterates over each element in the array using the outer loop, comparing it with every other element in the array using the inner loop. For each pair of elements (i, j), it checks if arr[i] is equal to arr[j]*2 and also ensures that i is not equal to j. If such a pair is found, the function returns true indicating that the condition is satisfied.\\n\\nIf no such pair is found after checking all possible combinations, the function returns false indicating that there is no pair where one element is exactly twice the other.\\n\\nThis approach has a time complexity of O(n^2) due to the nested loops, as mentioned earlier, and a space complexity of O(1) as it does not use any additional data structures.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i =0 ; i< arr.length ; i++){\\n            for(int j=0 ; j<arr.length ; j++){\\n            \\n                if(arr[i] == arr[j]*2 && i!=j){\\n                    return true;\\n                }\\n            }\\n                \\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i =0 ; i< arr.length ; i++){\\n            for(int j=0 ; j<arr.length ; j++){\\n            \\n                if(arr[i] == arr[j]*2 && i!=j){\\n                    return true;\\n                }\\n            }\\n                \\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3599004,
                "title": "javascript-easy-solution-without-using-array-methods-set-map-hashtable",
                "content": "\\n\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function (arr) {\\n    for (let j = 0; j < arr.length; j++) {\\n        for (i = 0; i < arr.length; i++) {\\n            if (arr[j] == 2 * arr[i] && i!=j) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function (arr) {\\n    for (let j = 0; j < arr.length; j++) {\\n        for (i = 0; i < arr.length; i++) {\\n            if (arr[j] == 2 * arr[i] && i!=j) {\\n                return true;\\n            }\\n        }\\n    }\\n\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3407563,
                "title": "simple-solution-using-hash-maps-beats-others",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp.insert({arr[i],i});\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i]*2)!=mp.end() && mp[arr[i]*2]!=i){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<arr.size();i++){\\n            mp.insert({arr[i],i});\\n        }\\n\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i]*2)!=mp.end() && mp[arr[i]*2]!=i){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404195,
                "title": "check-if-n-and-its-double-exist-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary Search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        sort(arr.begin(), arr.end());\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l = 0, r = arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(arr[i]==2*arr[mid] && i==mid)\\n                {\\n                    break;\\n                }\\n                else if(arr[i]==2*arr[mid])\\n                {\\n                    return true;\\n                }\\n                else if(arr[i]>2*arr[mid])\\n                {\\n                    l = mid+1;\\n                }\\n                else if(arr[i]<2*arr[mid])\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int i, j, l, r, mid;\\n        sort(arr.begin(), arr.end());\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            l = 0, r = arr.size()-1;\\n            while(l<=r)\\n            {\\n                mid = (l+r)/2;\\n                if(arr[i]==2*arr[mid] && i==mid)\\n                {\\n                    break;\\n                }\\n                else if(arr[i]==2*arr[mid])\\n                {\\n                    return true;\\n                }\\n                else if(arr[i]>2*arr[mid])\\n                {\\n                    l = mid+1;\\n                }\\n                else if(arr[i]<2*arr[mid])\\n                {\\n                    r = mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404152,
                "title": "check-if-n-and-its-double-exist-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int i, j;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=0 ; j<arr.size() ; j++)\\n            {\\n                if(arr[i]==2*arr[j] && i!=j)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int i, j;\\n        for(i=0 ; i<arr.size() ; i++)\\n        {\\n            for(j=0 ; j<arr.size() ; j++)\\n            {\\n                if(arr[i]==2*arr[j] && i!=j)\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302550,
                "title": "easy-solution-o-n-space-and-time-complexity-easy-understanding",
                "content": "\\n> # Approach\\nHash is the concept to check the existance of an element on O(1) time complexity so that i have use HashSet Data Structure.Add all elements into the HashSet on a traversal and do another traversal and check 2*arr[x] exists.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        int zero = 0;\\n        for(int itr : arr){\\n            if(itr==0) zero++;\\n            hash.add(itr);\\n        }\\n        if(zero>=2){\\n            return true;\\n        }\\n        hash.remove(0);\\n        for(int itr : arr){\\n            if(hash.contains(2*itr)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        int zero = 0;\\n        for(int itr : arr){\\n            if(itr==0) zero++;\\n            hash.add(itr);\\n        }\\n        if(zero>=2){\\n            return true;\\n        }\\n        hash.remove(0);\\n        for(int itr : arr){\\n            if(hash.contains(2*itr)) return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296419,
                "title": "c-solution-using-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n    unordered_set<int> s;\\n    for (int i = 0; i < arr.size(); i++)\\n    {\\n        if (s.find(2 * arr[i]) != s.end())\\n            return true;\\n        if (arr[i] % 2 == 0 && s.find(arr[i] / 2) != s.end())\\n            return true;   \\n        s.insert(arr[i]);\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n    unordered_set<int> s;\\n    for (int i = 0; i < arr.size(); i++)\\n    {\\n        if (s.find(2 * arr[i]) != s.end())\\n            return true;\\n        if (arr[i] % 2 == 0 && s.find(arr[i] / 2) != s.end())\\n            return true;   \\n        s.insert(arr[i]);\\n    }\\n    return false;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3250430,
                "title": "easily-understandable-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++){\\n            for(int j=0; j<arr.size(); j++){\\n                if(i!=j){\\n                    if(arr[i]==2*arr[j]){\\n                        return true;\\n                    }\\n                }\\n\\n            }\\n        }\\n                \\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i=0; i<arr.size(); i++){\\n            for(int j=0; j<arr.size(); j++){\\n                if(i!=j){\\n                    if(arr[i]==2*arr[j]){\\n                        return true;\\n                    }\\n                }\\n\\n            }\\n        }\\n                \\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175205,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n      bool check(vector<int>& arr,int index){\\n        int p = arr[index] * 2;\\n        int lo = 0, hi = arr.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(arr[mid] == p && mid != index)   return true;\\n            else if(arr[mid] < p){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(check(arr,i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      bool check(vector<int>& arr,int index){\\n        int p = arr[index] * 2;\\n        int lo = 0, hi = arr.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(arr[mid] == p && mid != index)   return true;\\n            else if(arr[mid] < p){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(check(arr,i)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3121334,
                "title": "best-python-solution",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        dic = {}\\n        for i in range(len(arr)):\\n            dic[arr[i]]  = arr[:i]\\n            \\n        for key,val in dic.items():\\n            if 2*key in val:\\n                return True\\n            elif key%2==0 and key//2 in val:\\n                return True\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        dic = {}\\n        for i in range(len(arr)):\\n            dic[arr[i]]  = arr[:i]\\n            \\n        for key,val in dic.items():\\n            if 2*key in val:\\n                return True\\n            elif key%2==0 and key//2 in val:\\n                return True\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098603,
                "title": "beats-86-30-simple-approach-check-if-n-and-its-double-exist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(1,len(arr)):\\n                if i!=j and ((arr[i]==arr[j]+arr[j]) or (arr[i]+arr[i]==arr[j])):\\n                    return True\\n                    break\\n        else:\\n            return False\\n```\\nIf you find it usefule, please upvote !!",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(1,len(arr)):\\n                if i!=j and ((arr[i]==arr[j]+arr[j]) or (arr[i]+arr[i]==arr[j])):\\n                    return True\\n                    break\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950025,
                "title": "java-hashmap-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x : arr) map.put(x,map.getOrDefault(x,0)+1);\\n        \\n        for(int i = 0;i<arr.length;i++) {\\n            map.put(arr[i],map.get(arr[i])-1);\\n            if(map.containsKey(2 * arr[i]) && map.get(2 * arr[i])>0) {\\n               return true; \\n            }\\n            map.put(arr[i],map.get(arr[i])+1);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int x : arr) map.put(x,map.getOrDefault(x,0)+1);\\n        \\n        for(int i = 0;i<arr.length;i++) {\\n            map.put(arr[i],map.get(arr[i])-1);\\n            if(map.containsKey(2 * arr[i]) && map.get(2 * arr[i])>0) {\\n               return true; \\n            }\\n            map.put(arr[i],map.get(arr[i])+1);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914610,
                "title": "simple-c-algorithm",
                "content": "\\n# Approach\\n Simple double looping technique (Brute Force) \\nC++ simple algorithm\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n  Auxillary space -> O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        bool ans=false;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                if(i!=j  && arr[i]==2*arr[j])\\n                {\\n                    ans=true;\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        bool ans=false;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                if(i!=j  && arr[i]==2*arr[j])\\n                {\\n                    ans=true;\\n                }\\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2898294,
                "title": "java-binary-search-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++) {\\n            int x=arr[i]*2;\\n            int l=0;\\n            int r=arr.length-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(mid!=i && arr[mid]==x){\\n                    return true;\\n                }\\n                else if(arr[mid]<x){\\n                    l=mid+1;\\n                }\\n                else {\\n                    r=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++) {\\n            int x=arr[i]*2;\\n            int l=0;\\n            int r=arr.length-1;\\n            while(l<=r){\\n                int mid=l+(r-l)/2;\\n                if(mid!=i && arr[mid]==x){\\n                    return true;\\n                }\\n                else if(arr[mid]<x){\\n                    l=mid+1;\\n                }\\n                else {\\n                    r=mid-1;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818128,
                "title": "python3-beat-85-5-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l = len(arr)\\n        for i in range(l-1):\\n            if  arr[i] * 2 in arr[0:i] + arr[i+1:]  or arr[i] / 2 in arr[0:i]+ arr[i+1:]:\\n                return True\\n        return False\\n\\n\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        l = len(arr)\\n        for i in range(l-1):\\n            if  arr[i] * 2 in arr[0:i] + arr[i+1:]  or arr[i] / 2 in arr[0:i]+ arr[i+1:]:\\n                return True\\n        return False\\n\\n\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743246,
                "title": "java-binary-search-o-nlogn",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++){\\n          int res = binarySearch(arr, arr[i]*2);\\n            if(res != -1 && res != i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n     int binarySearch(int[] arr, int target){\\n        int start = 0;\\n        int end = arr.length - 1;\\n        \\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            \\n            if(arr[mid] > target){\\n                end = mid - 1;\\n            }\\n            else if(arr[mid] < target){\\n                start = mid + 1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        Arrays.sort(arr);\\n        for(int i=0;i<arr.length;i++){\\n          int res = binarySearch(arr, arr[i]*2);\\n            if(res != -1 && res != i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n     int binarySearch(int[] arr, int target){\\n        int start = 0;\\n        int end = arr.length - 1;\\n        \\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            \\n            if(arr[mid] > target){\\n                end = mid - 1;\\n            }\\n            else if(arr[mid] < target){\\n                start = mid + 1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675543,
                "title": "java-using-hashset",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(Integer x:arr){\\n            if(set.contains(x*2) || x%2==0 && set.contains(x/2))\\n                return true;\\n            set.add(x);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(Integer x:arr){\\n            if(set.contains(x*2) || x%2==0 && set.contains(x/2))\\n                return true;\\n            set.add(x);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668321,
                "title": "memory-usage-9-9-mb-less-than-94-48-of-c-online-submissions",
                "content": "**C++ Solution using BRUTE FORCE Approach**\\n\\n```\\n\\n/*** 1346. Check if N and Its Double Exist ***/\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n\\t\\t\\n\\t\\t//decalred a boolean variable ans and initialised it to false\\n        bool ans = false;\\n\\t\\t\\n\\t\\t//iterate over the vector and find two elements where either ,\\n\\t\\t// (i) first = 2*second\\n\\t\\t// (ii) first/2 = second\\n\\t\\t\\n\\t\\t/*** Don\\'t forget to check that the one multiplied or divided with 2 , should be \\n\\t\\ta even number otherwise ( for 7,3  => 7/2 = 3 will return true)  ***/\\n\\t\\t\\n        for(int i=0;i<arr.size();++i){\\t\\t\\n            for(int j=0;j<arr.size();++j){\\n                if(i!=j && ((arr[i]%2==0 && arr[i]==2*arr[j]) || (arr[i]%2==0 && arr[i]/2==arr[j]))){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if found any such pair then assign true to the boolean variable ans and exit from the for loop\\n\\t\\t\\t\\t//as there is no need to check further\\n\\t\\t\\t\\t\\n                    ans = true;\\n                    break;\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n/*** 1346. Check if N and Its Double Exist ***/\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n\\t\\t\\n\\t\\t//decalred a boolean variable ans and initialised it to false\\n        bool ans = false;\\n\\t\\t\\n\\t\\t//iterate over the vector and find two elements where either ,\\n\\t\\t// (i) first = 2*second\\n\\t\\t// (ii) first/2 = second\\n\\t\\t\\n\\t\\t/*** Don\\'t forget to check that the one multiplied or divided with 2 , should be \\n\\t\\ta even number otherwise ( for 7,3  => 7/2 = 3 will return true)  ***/\\n\\t\\t\\n        for(int i=0;i<arr.size();++i){\\t\\t\\n            for(int j=0;j<arr.size();++j){\\n                if(i!=j && ((arr[i]%2==0 && arr[i]==2*arr[j]) || (arr[i]%2==0 && arr[i]/2==arr[j]))){\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t//if found any such pair then assign true to the boolean variable ans and exit from the for loop\\n\\t\\t\\t\\t//as there is no need to check further\\n\\t\\t\\t\\t\\n                    ans = true;\\n                    break;\\n                }\\n            }\\n        }\\n         return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2660146,
                "title": "1-line-of-logic-only-3ms-runtime-easy-java-with-easy-understanding-binary-search-also-added",
                "content": "```\\n/* Approach-1 */ \\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false; \\n    }    \\n}\\n\\n/* Approach - 2 : Binary Search */\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i = 0; i < arr.length; i++){\\n            int res = binarySearch(arr, arr[i]*2);\\n            if(res != -1 && res != i){\\n                return true;\\n            }\\n        }\\n        return false;\\n        \\n    }\\n    public int binarySearch(int[] arr, int target){\\n        int start = 0;\\n        int end = arr.length - 1;\\n        \\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            \\n            if(arr[mid] > target){\\n                end = mid - 1;\\n            }\\n            else if(arr[mid] < target){\\n                start = mid + 1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = i + 1; j < arr.length; j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i]){\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2643969,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = 0; j < arr.length; j++){\\n                if(i != j && arr[i] == 2 * arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            for(int j = 0; j < arr.length; j++){\\n                if(i != j && arr[i] == 2 * arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597037,
                "title": "python-simple-clean-approach-beat-95-easy-t-o-n",
                "content": "#### Approach: Maintain  HashTable\\n\\u2714\\uFE0F\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d = {}\\n        for val in arr:\\n            if d.get(val*2,0) or d.get(val/2,0): return True\\n            d[val] = 1\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d = {}\\n        for val in arr:\\n            if d.get(val*2,0) or d.get(val/2,0): return True\\n            d[val] = 1\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554277,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n      let j = arr.length - 1;\\n      while(j >= 0) {\\n        if(arr[i] === (2 * arr[j]) && j != i){\\n          return true;\\n        }\\n        j--;\\n      }\\n    }\\n  return false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n      let j = arr.length - 1;\\n      while(j >= 0) {\\n        if(arr[i] === (2 * arr[j]) && j != i){\\n          return true;\\n        }\\n        j--;\\n      }\\n    }\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2544375,
                "title": "c-solution-easy",
                "content": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i])\\n                    return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        \\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i])\\n                    return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2469411,
                "title": "java-solution-using-double-concept-and-hashset",
                "content": "```\\nHashSet< Double > list = new HashSet<>();\\n        for ( int a : arr ) {\\n            if ( list.contains(a / 2.0) || list.contains(a * 2.0) ) return true;\\n            list.add(a * 1.0);\\n        }\\n        return false;\\n```\\n please appreciate if works for you !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nHashSet< Double > list = new HashSet<>();\\n        for ( int a : arr ) {\\n            if ( list.contains(a / 2.0) || list.contains(a * 2.0) ) return true;\\n            list.add(a * 1.0);\\n        }\\n        return false;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2424683,
                "title": "python3-solution-faster-than-90",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        def binarySearch(nums,target)->bool:\\n            low = 0 \\n            high = len(nums) -1\\n            \\n            while low <= high:\\n                mid = low + (high - low)//2\\n                if nums[mid] == target:\\n                    return True\\n                elif nums[mid] > target:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            return False\\n        \\n        \\n        arr.sort()\\n        \\n        for i in range(len(arr) - 1):\\n            if arr[i] >= 0:\\n                \\n                if binarySearch(arr[i+1:], arr[i]*2):\\n                    return True\\n            else:\\n                if binarySearch(arr[:i], arr[i]*2):\\n                    return True\\n            \\n        return False\\n                \\n            \\n                \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        def binarySearch(nums,target)->bool:\\n            low = 0 \\n            high = len(nums) -1\\n            \\n            while low <= high:\\n                mid = low + (high - low)//2\\n                if nums[mid] == target:\\n                    return True\\n                elif nums[mid] > target:\\n                    high = mid - 1\\n                else:\\n                    low = mid + 1\\n            return False\\n        \\n        \\n        arr.sort()\\n        \\n        for i in range(len(arr) - 1):\\n            if arr[i] >= 0:\\n                \\n                if binarySearch(arr[i+1:], arr[i]*2):\\n                    return True\\n            else:\\n                if binarySearch(arr[:i], arr[i]*2):\\n                    return True\\n            \\n        return False\\n                \\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2374643,
                "title": "c-brute-force-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        for(int i = 0; i < arr.size(); i++){\\n            for(int j = i+1; j < arr.size(); j++){\\n                if(arr[i] == 2 * arr[j] || arr[j] == 2 * arr[i])\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336543,
                "title": "faster-than-100-online-c-solution-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for(auto i:arr){\\n            if(mp.find(i) != mp.end()) return true;   \\n            if(i%2==0){\\n                mp[i/2]++;\\n            }\\n            mp[i*2]++;\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int, int> mp;\\n        for(auto i:arr){\\n            if(mp.find(i) != mp.end()) return true;   \\n            if(i%2==0){\\n                mp[i/2]++;\\n            }\\n            mp[i*2]++;\\n        }\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286801,
                "title": "python3-check-if-n-and-its-double-exist-brute-force-way-iteration-easy-and-clean-code",
                "content": "```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[j]==2*arr[i] or arr[i]==2*arr[j]:\\n                    return True\\n        return  False\\n    \\n        \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        for i in range(len(arr)):\\n            for j in range(i+1,len(arr)):\\n                if arr[j]==2*arr[i] or arr[i]==2*arr[j]:\\n                    return True\\n        return  False\\n    \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2239462,
                "title": "simple-binary-search",
                "content": "//first sort the elements and then apply simple binry search\\n//consider the case of zero ...1)when single 0 is present \\n// 2) when more than one 0 is present \\n\\nclass Solution {\\npublic:\\n    bool bs(vector<int>& nums,int low,int high,int target){\\n         while(low<=high){\\n              int mid=low+(high-low)/2;\\n             if(nums[mid]==target){\\n                 return true;\\n             }else if(nums[mid]>target){\\n                 high=mid-1;\\n             }else{\\n                 low=mid+1;\\n             }\\n         }    \\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& nums) {\\n         sort(nums.begin(),nums.end());\\n         int n=nums.size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n           if(nums[i]==0){\\n               cnt++;\\n               if(cnt>1){\\n                   return true;\\n               }\\n           }  \\n        }\\n        for(int i=0;i<n;i++){\\n            if(nums[i]==0){\\n                continue;\\n            }\\n            int target=2*nums[i];\\n            if(bs(nums,0,n-1,target)){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool bs(vector<int>& nums,int low,int high,int target){\\n         while(low<=high){\\n              int mid=low+(high-low)/2;\\n             if(nums[mid]==target){\\n                 return true;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2042551,
                "title": "simple-python-solutions",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen_values = {}\\n        \\n        # map the value to the index seen\\n        count = 0 \\n        for num in arr:\\n            seen_values[num] = count\\n            count = count + 1\\n        \\n        # use count_1 as a value to track index and look at all\\n        # of the values in arr\\n        count_1 = 0 \\n        for num in arr:\\n            double = num * 2\\n            \\n            # see if the value is in the dictionary\\n            # ensure that the values are not the same so like [-2,0,10,-19,4,6,-8]\\n            # 0 * 2 would be 0. We cannot use the same 0 \\n            if double in seen_values and seen_values[double] != count_1:\\n                return True\\n            \\n            count_1 = count_1 + 1 \\n        \\n        # we have looped through them all and \\n        # have not gotten true\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        seen_values = {}",
                "codeTag": "Java"
            },
            {
                "id": 1990676,
                "title": "o-n-fastest-js-solution",
                "content": "\\tvar checkIfExist = function(arr) {\\n\\t\\tlet obj = {};\\n\\t\\tfor(let val of arr){\\n\\t\\t\\tif(obj[val*2] || obj[val/2]){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(val === 0 && obj[0] === 0){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tobj[val] =  val;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar checkIfExist = function(arr) {\\n\\t\\tlet obj = {};\\n\\t\\tfor(let val of arr){\\n\\t\\t\\tif(obj[val*2] || obj[val/2]){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(val === 0 && obj[0] === 0){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tobj[val] =  val;\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 1989563,
                "title": "python-solution-faster-than-90",
                "content": "In this case, innitially array is not sorted, to perform a binary search we need to sort it first, which alone will take O(nlogn) time complexity, so I have used a hashsset here which takes O(N) memory but time complexity will be O(n), which is better than O(nlogn).\\n\\n```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d=set()\\n        for i in arr:\\n            if i*2 in d or i/2 in d:\\n                return True\\n            d.add(i)\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        d=set()\\n        for i in arr:\\n            if i*2 in d or i/2 in d:\\n                return True\\n            d.add(i)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1955228,
                "title": "o-n-3-lines-java",
                "content": "Set set=new HashSet();\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(set.contains(arr[i]*2) || (arr[i]%2==0 && set.contains(arr[i]/2))) return true;\\n\\t\\t\\tset.add(arr[i]);\\n\\t\\t}",
                "solutionTags": [],
                "code": "Set set=new HashSet();\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tif(set.contains(arr[i]*2) || (arr[i]%2==0 && set.contains(arr[i]/2))) return true;\\n\\t\\t\\tset.add(arr[i]);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1945703,
                "title": "javascript-solution-simple-70ms",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    \\n    for(let i = 0; i < arr.length; i++){\\n        for(let j = 0; j < arr.length; j++ ){\\n            if(i != j){\\n                if(arr[i] === 2 * arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    \\n    for(let i = 0; i < arr.length; i++){\\n        for(let j = 0; j < arr.length; j++ ){\\n            if(i != j){\\n                if(arr[i] === 2 * arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1936701,
                "title": "c-linq",
                "content": "```\\n    public bool CheckIfExist(int[] arr) {\\n        \\n        if (arr.Where(i => i == 0).Count() > 1)\\n        {\\n            return true;\\n        }\\n\\n        return arr.Where(i => i != 0).Count(x => arr.Contains(x * 2)) > 0;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public bool CheckIfExist(int[] arr) {\\n        \\n        if (arr.Where(i => i == 0).Count() > 1)\\n        {\\n            return true;\\n        }\\n\\n        return arr.Where(i => i != 0).Count(x => arr.Contains(x * 2)) > 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1927943,
                "title": "c-simple-binary-search-on-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int idx){\\n        int p = arr[idx] * 2;\\n        int lo = 0, hi = arr.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(arr[mid] == p && mid != idx)   return true;\\n            else if(arr[mid] < p){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(check(arr,i))    return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nTime Complexity : O(2*nlogn)\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int idx){\\n        int p = arr[idx] * 2;\\n        int lo = 0, hi = arr.size() - 1;\\n        while(lo <= hi){\\n            int mid = lo + (hi - lo)/2;\\n            if(arr[mid] == p && mid != idx)   return true;\\n            else if(arr[mid] < p){\\n                lo = mid + 1;\\n            }else{\\n                hi = mid - 1;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(check(arr,i))    return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1922791,
                "title": "simple-c-both-sorting-binary-search-and-unordered-set-solution",
                "content": "1. Simple Brute Force \\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        bool ok = false;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                if (i != j && arr[i] == 2 * arr[j])\\n                {\\n                    ok = true;\\n                    break;\\n                }\\n        return ok;\\n    }\\n};\\n```\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n2. Using sorting and lower_bound(binary search)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        bool ok = false;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < n; i++)\\n        {\\n            int ind = lower_bound(arr.begin(), arr.end(), 2 * arr[i]) - arr.begin();\\n            if (ind == n)\\n                ind--;\\n            if (arr[ind] == 2 * arr[i] && ind != i)\\n            {\\n                ok = true;\\n                break;\\n            }\\n        }\\n        return ok;\\n    }\\n};\\n```\\n\\nTime Complexity: O(NLogN)\\nSpace Complexity: O(1)\\n\\n3. Using C++ STL unordered_set\\nAn unordered_set is implemented using a hash table where keys are hashed into indices of a hash table so that the insertion is always randomized. All operations on the unordered_set takes constant time O(1) on an average.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int cnt = 0;\\n        unordered_set<int> hash;\\n        for (int i = 0; i < n; i++)\\n        {\\n            hash.insert(arr[i]);\\n            if (arr[i] == 0)\\n                cnt++;\\n        }\\n        if (cnt > 1)\\n            return true;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] != 0 && hash.find(2 * arr[i]) != hash.end())\\n                return true;\\n        return false;\\n    }\\n};\\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\nI hope this helps. \\uD83D\\uDE42\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        bool ok = false;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < n; j++)\\n                if (i != j && arr[i] == 2 * arr[j])\\n                {\\n                    ok = true;\\n                    break;\\n                }\\n        return ok;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        bool ok = false;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < n; i++)\\n        {\\n            int ind = lower_bound(arr.begin(), arr.end(), 2 * arr[i]) - arr.begin();\\n            if (ind == n)\\n                ind--;\\n            if (arr[ind] == 2 * arr[i] && ind != i)\\n            {\\n                ok = true;\\n                break;\\n            }\\n        }\\n        return ok;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkIfExist(vector<int> &arr)\\n    {\\n        int n = arr.size();\\n        int cnt = 0;\\n        unordered_set<int> hash;\\n        for (int i = 0; i < n; i++)\\n        {\\n            hash.insert(arr[i]);\\n            if (arr[i] == 0)\\n                cnt++;\\n        }\\n        if (cnt > 1)\\n            return true;\\n        for (int i = 0; i < n; i++)\\n            if (arr[i] != 0 && hash.find(2 * arr[i]) != hash.end())\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908645,
                "title": "c-with-set-and-two-pointers",
                "content": "# Two Solutions\\n## ---- Using a Set/HashSet ----\\n**Results**\\n*Runtime:* 4 ms\\n*Memory:* 10.3 MB\\n\\n**Complexity**\\n*Time:* O(n)\\n*Space:* O(n)\\n```C++\\nclass Solution {\\npublic:\\n    // O(n) time | O(n) space.\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> doubles_set;\\n        for(int num : arr)\\n        {\\n            if(doubles_set.find(num*2) != doubles_set.end() || \\n               (num%2 == 0 && doubles_set.find(num/2) != doubles_set.end()))\\n                return true;\\n            doubles_set.insert(num);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\nThis approach is probably the easiest to understand.\\n- We check if double the number OR half of the number we are looking at exists within the set (meaning we saw it in the array).\\n  - If it does, that means our condition of `n = m*2` has been satisfied and we can return true.\\n  - Please note: The second condition, `num/2`, can only be checked if the current number is even, where `num%2 == 0` would be true if the current number is even.\\n- If it doesn\\'t exist, then we add the current number to the set.\\n\\n## ---- Using Two Pointers ----\\n**Results**\\n*Runtime:* 3 ms\\n*Memory:* 9.9 MB\\n\\n**Complexity**\\n*Time:* O(nlog(n))\\n*Space:* O(1)\\n```C++\\nclass Solution {\\npublic:\\n    // O(nlog(n)) time | O(1) space.\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0, right = 1;\\n        while(right < arr.size())\\n        {\\n\\t\\t\\t// Account for when right and left values are both negative.\\n\\t\\t\\t// Makes sure that 2*right_val is at LEAST equal to left_val.\\n            if(arr[right]*2 < arr[left])\\n            {\\n                right++;\\n                continue;\\n            }\\n            \\n            if(arr[left]*2 == arr[right] || arr[left] == arr[right]*2)\\n                return true;\\n            \\n            if(arr[left]*2 < arr[right])\\n                left++;\\n            else\\n                right++;\\n            \\n\\t\\t\\t// Right pointer must always be at least 1 ahead of left pointer.\\n            if(left == right)\\n                right++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nFor a default approach, without using extra space for data structures like hashsets, I think it is a lot better to sort the array for the two pointer approach than using an unsorted array with nested loops.\\n\\n- Sorting takes about `O(nlog(n))` time and then looping through the whole array onces is `O(n)`.\\n- This is a whole lot better than not sorting the array, but having nested loops to check for all possible solutions, which would take about `0(n^2)` time.",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Ordered Set"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    // O(n) time | O(n) space.\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> doubles_set;\\n        for(int num : arr)\\n        {\\n            if(doubles_set.find(num*2) != doubles_set.end() || \\n               (num%2 == 0 && doubles_set.find(num/2) != doubles_set.end()))\\n                return true;\\n            doubles_set.insert(num);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\n```C++\\nclass Solution {\\npublic:\\n    // O(nlog(n)) time | O(1) space.\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0, right = 1;\\n        while(right < arr.size())\\n        {\\n\\t\\t\\t// Account for when right and left values are both negative.\\n\\t\\t\\t// Makes sure that 2*right_val is at LEAST equal to left_val.\\n            if(arr[right]*2 < arr[left])\\n            {\\n                right++;\\n                continue;\\n            }\\n            \\n            if(arr[left]*2 == arr[right] || arr[left] == arr[right]*2)\\n                return true;\\n            \\n            if(arr[left]*2 < arr[right])\\n                left++;\\n            else\\n                right++;\\n            \\n\\t\\t\\t// Right pointer must always be at least 1 ahead of left pointer.\\n            if(left == right)\\n                right++;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830544,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        //brute force  worst way\\n      int n=arr.size();  \\n        for(int i=0;i<n;i++){\\n            int value= 2*arr[i];\\n            for(int j=0;j<n;j++){\\n                if((value==arr[j]) && (i !=j )){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        //brute force  worst way\\n      int n=arr.size();  \\n        for(int i=0;i<n;i++){\\n            int value= 2*arr[i];\\n            for(int j=0;j<n;j++){\\n                if((value==arr[j]) && (i !=j )){\\n                    return true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1819705,
                "title": "0ms-easy-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n       map<double,int> mp;\\n       for(int i=0;i<arr.size();i++){\\n           if(mp.count(arr[i]*2) or mp.count((double)arr[i]/2))\\n               return true;\\n           mp[arr[i]]++;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n       map<double,int> mp;\\n       for(int i=0;i<arr.size();i++){\\n           if(mp.count(arr[i]*2) or mp.count((double)arr[i]/2))\\n               return true;\\n           mp[arr[i]]++;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1792268,
                "title": "java-solution-brute-force-and-binary-search-both",
                "content": "Brute force - o(n^2) (easy)\\n\\n```\\n  public boolean checkIfExist(int[] arr) {    \\n   int n = arr.length;\\n       for(int i=0; i<n; ++i){\\n        for(int j=0; j<n; ++j){\\n            if(j!=i){\\n                if(2*arr[i]==arr[j]){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n   return false;\\n }\\n```\\nNote - Here index is also checked  for cases like [-2,0,10,-19,4,6,-8] , [0,0]\\nDo dry run to understand better!\\n\\nUsing Binary Search\\n```\\npublic boolean binarySearch(int[]a,int key,int index){\\n        int s =0;\\n        int e = a.length-1;\\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            if(a[mid] == key && mid!=index){\\n                return true;\\n            }\\n            if(a[mid]<key){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return false;\\n    }\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i = 0;i<arr.length;i++){\\n            if(binarySearch(arr,2*arr[i],i)){\\n                return true;\\n            }\\n        }\\n       return false;\\n    }\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\n  public boolean checkIfExist(int[] arr) {    \\n   int n = arr.length;\\n       for(int i=0; i<n; ++i){\\n        for(int j=0; j<n; ++j){\\n            if(j!=i){\\n                if(2*arr[i]==arr[j]){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n    }\\n   return false;\\n }\\n```\n```\\npublic boolean binarySearch(int[]a,int key,int index){\\n        int s =0;\\n        int e = a.length-1;\\n        int mid = s+(e-s)/2;\\n        while(s<=e){\\n            if(a[mid] == key && mid!=index){\\n                return true;\\n            }\\n            if(a[mid]<key){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid-1;\\n            }\\n            mid = s+(e-s)/2;\\n        }\\n        return false;\\n    }\\n    public boolean checkIfExist(int[] arr) {\\n        Arrays.sort(arr);\\n        for(int i = 0;i<arr.length;i++){\\n            if(binarySearch(arr,2*arr[i],i)){\\n                return true;\\n            }\\n        }\\n       return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790457,
                "title": "python-solution-binary-search-hashmap-set",
                "content": "```\\n\\n#By using dictionary\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        exist_map = {}\\n        for num in arr:\\n            if num * 2 in exist_map or num / 2 in exist_map:\\n                return True\\n            exist_map[num] = 1\\n        \\n        return False\\n\\n\\n\\n#By using set TC: O(N) and SC: O(N)\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        exist_set = set()\\n        for num in arr:\\n            if num * 2 in exist_set or num / 2 in exist_set:\\n                return True\\n            exist_set.add(num)\\n        \\n        return False\\n\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        dict_map = collections.Counter(arr)\\n        \\n        # Check if there are more than one zeros.\\n        if dict_map[0] > 1:\\n            return True\\n        \\n        # check if any double number exist\\n        for num in arr:\\n            if num*2 in dict_map and num != 0:\\n                return True\\n        return False\\n\\n# Time complexity NlogN and space complexity O(N)\\nclass Solution:\\n    def binary_search(self, arr: List[int], num):\\n        left = 0\\n        right = len(arr)-1\\n        while(left <= right):\\n            mid = left + (right - left) // 2\\n            if arr[mid] == num:\\n                return True\\n            elif arr[mid] < num:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return False\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        arr.sort()\\n        zero_count = 0\\n        for num in arr:\\n            if (self.binary_search(arr, num) and self.binary_search(arr, 2* num) and num != 0):\\n                return True\\n            elif num == 0:\\n                zero_count += 1\\n        if zero_count == 2:\\n            return True\\n        return False\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        exist_map = {}",
                "codeTag": "Java"
            },
            {
                "id": 1785147,
                "title": "java-o-n-with-hashset",
                "content": "Add  2*elemnet or element/2  if even to set.\\nThen just check if each element in the array iteration exists in the set.\\nReturn false otherwise.\\n\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        Set<Integer> check = new HashSet<Integer>();\\n        for(int elem:arr){\\n            if(check.contains(elem)) {\\n                return true;\\n            }\\n            if(elem%2 ==0) {\\n                check.add(elem/2);\\n            }\\n            check.add(elem*2);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        Set<Integer> check = new HashSet<Integer>();\\n        for(int elem:arr){\\n            if(check.contains(elem)) {\\n                return true;\\n            }\\n            if(elem%2 ==0) {\\n                check.add(elem/2);\\n            }\\n            check.add(elem*2);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778662,
                "title": "java-brute-force-o-n2",
                "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n      for(int i=0;i<arr.length;i++){\\n          for(int j=0;j<arr.length;j++){\\n              if(i==j){\\n                  continue;\\n              }\\n              if(arr[j]==2*arr[i]){\\n                  return true;\\n              }\\n          }\\n      }  \\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n      for(int i=0;i<arr.length;i++){\\n          for(int j=0;j<arr.length;j++){\\n              if(i==j){\\n                  continue;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1756586,
                "title": "c-binary-search-easy",
                "content": "````\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int val){\\n        int l=0,r=arr.size()-1, m;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(arr[m]==(val*2))return m;\\n            if(arr[m]>(val*2))r=m-1;\\n            else l=m+1;\\n        }\\n        return -1;\\n    }\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            int srch=bs(arr,arr[i]);\\n            if(srch!=-1 && srch!=i)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n````",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int bs(vector<int>& arr, int val){\\n        int l=0,r=arr.size()-1, m;\\n        while(l<=r){\\n            m=l+(r-l)/2;\\n            if(arr[m]==(val*2))return m;\\n            if(arr[m]>(val*2))r=m-1;\\n            else l=m+1;\\n        }\\n        return -1;\\n    }\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            int srch=bs(arr,arr[i]);\\n            if(srch!=-1 && srch!=i)\\n                return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666890,
                "title": "c-clean-codes-brute-force-method-and-using-set",
                "content": "\\n\\nO(N) time and O(N) space complexity\\nbool checkIfExist(vector<int>& arr) {\\n\\t\\t\\n\\t\\t\\n\\t\\tunordered_set<int> st;\\n        \\n \\n        for(int item : arr)\\n        {\\n            \\n\\t\\t\\t// here we need to take care of numbers like 7/2 == 3 and 6/2 ==3 so one extra condition\\n\\t\\t\\t// need to be checked in order to avoid misktake\\n            if(st.find(item*2) != st.end() || \\n               (item%2 ==0 && st.find(item/2) != st.end()))\\n                return true;\\n            \\n            st.insert(item);\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n\\t\\n\\t// Brute force way is having the O(N^2) complexity \\n\\t\\n\\t bool checkIfExist(vector<int>& arr) {\\n\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            int key = arr[i];\\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(key == 2*arr[j] || arr[j] == 2*key)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n\\t\\n**feel free to give suggestions in the comments section below and if you like the solution do upvote it !!\\n\\tHappy coding :)**",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "\\n\\nO(N) time and O(N) space complexity\\nbool checkIfExist(vector<int>& arr) {\\n\\t\\t\\n\\t\\t\\n\\t\\tunordered_set<int> st;\\n        \\n \\n        for(int item : arr)\\n        {\\n            \\n\\t\\t\\t// here we need to take care of numbers like 7/2 == 3 and 6/2 ==3 so one extra condition\\n\\t\\t\\t// need to be checked in order to avoid misktake\\n            if(st.find(item*2) != st.end() || \\n               (item%2 ==0 && st.find(item/2) != st.end()))\\n                return true;\\n            \\n            st.insert(item);\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n\\t\\n\\t// Brute force way is having the O(N^2) complexity \\n\\t\\n\\t bool checkIfExist(vector<int>& arr) {\\n\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            int key = arr[i];\\n            for(int j=i+1; j<arr.size(); j++)\\n            {\\n                if(key == 2*arr[j] || arr[j] == 2*key)\\n                    return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\t\\n\\t\\n**feel free to give suggestions in the comments section below and if you like the solution do upvote it !!\\n\\tHappy coding :)**",
                "codeTag": "Unknown"
            },
            {
                "id": 1621672,
                "title": "easy-c-solution-with-explanation-using-set",
                "content": "We maintain a **hash set** and loop through the array. \\nIn each iteration we check whether a number twice that of the current number is present in the set or not. \\nSimilarly we also need to check if the current value is even then a number half of the current number is present or not. \\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i=0;i<arr.size();i++){\\n            if(st.count(2*arr[i]) || (arr[i]%2==0 && st.count(arr[i]/2)))\\n                return true;            \\n            st.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int>st;\\n        for(int i=0;i<arr.size();i++){\\n            if(st.count(2*arr[i]) || (arr[i]%2==0 && st.count(arr[i]/2)))\\n                return true;            \\n            st.insert(arr[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1583717,
                "title": "6-line-java-solution-1ms-using-sets",
                "content": "**upvote if you LIKE** \\uD83D\\uDE42\\n\\nclass Solution {\\n\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hs.contains(2*arr[i]) || (arr[i]%2==0 && hs.contains(arr[i]/2)) )\\n                return true;\\n            hs.add(arr[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean checkIfExist(int[] arr) {\\n        \\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i=0;i<arr.length;i++){\\n            if(hs.contains(2*arr[i]) || (arr[i]%2==0 && hs.contains(arr[i]/2)) )\\n                return true;\\n            hs.add(arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1560214,
                "title": "simple-hashmap-python-solution",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        mydict = {}\\n        for ele in arr:\\n            if mydict.get((ele/2)) == 1 or mydict.get((2*ele))==1:\\n                return True\\n            else:\\n                mydict[ele] = 1\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        mydict = {}",
                "codeTag": "Java"
            },
            {
                "id": 1503137,
                "title": "binary-search-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i =0; i<n; i++){\\n            int find = arr[i] * 2;\\n            int left = 0,right=n-1;\\n            \\n            while(left <= right){\\n                int mid = left + (right-left)/2;\\n                if(arr[mid] == find && mid != i){\\n                    return true;\\n                }\\n                else if(arr[mid] > find){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        for(int i =0; i<n; i++){\\n            int find = arr[i] * 2;\\n            int left = 0,right=n-1;\\n            \\n            while(left <= right){\\n                int mid = left + (right-left)/2;\\n                if(arr[mid] == find && mid != i){\\n                    return true;\\n                }\\n                else if(arr[mid] > find){\\n                    right = mid-1;\\n                }\\n                else{\\n                    left = mid + 1;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460991,
                "title": "python-o-n-solution-and-o-n-space",
                "content": "\\n        hmap={}\\n        for i in range(len(arr)):\\n            hmap[arr[i]]=i\\n\\n        for i in range(len(arr)):\\n            if arr[i]*2 in hmap:\\n         \\n                if i!=hmap[arr[i]*2] :\\n                    return True\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        hmap={}\\n        for i in range(len(arr)):\\n            hmap[arr[i]]=i\\n\\n        for i in range(len(arr)):\\n            if arr[i]*2 in hmap:\\n         \\n                if i!=hmap[arr[i]*2] :\\n                    return True\\n        return False",
                "codeTag": "Unknown"
            },
            {
                "id": 1457028,
                "title": "java-best-solution-using-hashset",
                "content": "\\n\\n```\\nclass Solution {\\n    public boolean checkIfExist(int[] a) {\\n        HashSet<Integer> h = new HashSet<Integer>();\\n        for(int i=0; i<a.length;i++){\\n            if(h.contains(a[i]*2) || (a[i]%2==0 && h.contains(a[i]/2)))\\n                return true;\\n            else {\\n                h.add(a[i]);\\n            }\\n\\n        }\\n        return false;\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] a) {\\n        HashSet<Integer> h = new HashSet<Integer>();\\n        for(int i=0; i<a.length;i++){\\n            if(h.contains(a[i]*2) || (a[i]%2==0 && h.contains(a[i]/2)))\\n                return true;\\n            else {\\n                h.add(a[i]);\\n            }\\n\\n        }\\n        return false;\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414000,
                "title": "java-simple-solution-runtime-1-ms-faster-than-99-take-a-look",
                "content": "Using HashSet:\\n\\npublic boolean checkIfExist(int[] arr) {\\n\\t\\n\\tHashSet<Integer> set = new HashSet<>();\\n\\tfor(int ele : arr) {\\n\\t\\tif(set.contains(ele*2) || (ele%2 == 0 && set.contains(ele/2)))\\n\\t\\t\\treturn true;\\n\\t\\tset.add(ele);\\n\\t}\\n\\t\\n\\treturn false;\\n}\\n\\nUsing Hashmap:\\nclass Solution {\\n    \\n\\tpublic boolean checkIfExist(int[] arr) { \\n\\tHashMap<Integer,Integer> map = new HashMap();\\n       for(int i=0;i<arr.length;i++){   //Traversing from start\\n           if(map.containsKey(2*arr[i]))\\n               return true;  \\n           else\\n               map.put(arr[i],i);\\n       }\\n       map.clear();\\n       for(int i=arr.length-1;i>=0;i--){ //traversing from end\\n           if(map.containsKey(2*arr[i]))\\n               return true;\\n           else\\n               map.put(arr[i],i);\\n       }\\n        return false;\\n    }\\n}\\n//Do upvote if you like the solution",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n\\tpublic boolean checkIfExist(int[] arr) { \\n\\tHashMap<Integer,Integer> map = new HashMap();\\n       for(int i=0;i<arr.length;i++){   //Traversing from start\\n           if(map.containsKey(2*arr[i]))\\n               return true;  \\n           else\\n               map.put(arr[i],i);\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1351396,
                "title": "java-simple-hashset-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i:arr){\\n            if(set.contains(i*2) || (i%2==0 && set.contains(i/2))){\\n                return true;\\n            }\\n            set.add(i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i:arr){\\n            if(set.contains(i*2) || (i%2==0 && set.contains(i/2))){\\n                return true;\\n            }\\n            set.add(i);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348904,
                "title": "python3-solution-faster-than-97-and-less-space-than-76-solutions",
                "content": "```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i]*2 in arr[0:i]+arr[i+1:]:\\n                return True",
                "solutionTags": [],
                "code": "```class Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i]*2 in arr[0:i]+arr[i+1:]:\\n                return True",
                "codeTag": "Java"
            },
            {
                "id": 1345498,
                "title": "c-easy-solution-using-unordered-map",
                "content": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n       \\n         unordered_map<int ,int>hash; \\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            \\n             hash[arr[i]]++;\\n        } \\n        \\n        for(int i  = 0 ; i < arr.size() ; i++){\\n            \\n            //handling the edge case if arr[i] = 0\\n            if(arr[i] == 0 && hash[arr[i]] == 1){\\n                 continue;\\n             }\\n            \\n     //cheking either arr[i]\\'s double exists or is it double of any number present in vector\\n             if(hash.count(arr[i] * 2) > 0 || (arr[i] % 2 == 0 && hash.count(arr[i]/2) > 0)){\\n                 return true;\\n             }\\n        }\\n        \\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n       \\n         unordered_map<int ,int>hash; \\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            \\n             hash[arr[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1335965,
                "title": "javascript-simple-and-fast",
                "content": "Runtime: 68 ms, faster than 97.69% of JavaScript online submissions for Check If N and Its Double Exist.\\nMemory Usage: 40.5 MB, less than 32.47% of JavaScript online submissions for Check If N and Its Double Exist.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    const record = new Set()\\n    for (const num of arr) {\\n        const half = num / 2 \\n        const double = num * 2\\n        if (record.has(half) || record.has(double))\\n            return true\\n        record.add(num)\\n    }\\n    return false\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {boolean}\\n */\\nvar checkIfExist = function(arr) {\\n    const record = new Set()\\n    for (const num of arr) {\\n        const half = num / 2 \\n        const double = num * 2\\n        if (record.has(half) || record.has(double))\\n            return true\\n        record.add(num)\\n    }\\n    return false\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1335527,
                "title": "c-unorderd-map-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        int n=arr.size();\\n        \\n        //store all the values in map\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            //if we encounter zero, the count should be even to have double as 0*2=0\\n            if(arr[i]==0 && mp[arr[i]]%2==0)\\n                return true;\\n            //if we dont find the pair and also if the number is not zero since we check for zero\\n            if(mp.find(arr[i]*2)!=mp.end() && arr[i]!=0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int>mp;\\n        int n=arr.size();\\n        \\n        //store all the values in map\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            //if we encounter zero, the count should be even to have double as 0*2=0\\n            if(arr[i]==0 && mp[arr[i]]%2==0)\\n                return true;\\n            //if we dont find the pair and also if the number is not zero since we check for zero\\n            if(mp.find(arr[i]*2)!=mp.end() && arr[i]!=0)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332930,
                "title": "c-simple-c-using-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]=i;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i]*2)!=mp.end() && mp[arr[i]*2] != i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_map<int,int> mp;\\n        \\n        for(int i=0;i<arr.size();i++){\\n            mp[arr[i]]=i;\\n        }\\n        for(int i=0;i<arr.size();i++){\\n            if(mp.find(arr[i]*2)!=mp.end() && mp[arr[i]*2] != i){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308897,
                "title": "go-simple-solution-o-n",
                "content": "```\\nfunc checkIfExist(arr []int) bool {\\n    dict := map[int]bool{}\\n    for _, v := range arr {\\n        if dict[2*v] || (dict[v/2] && v%2 == 0) {\\n            return true\\n        }\\n        dict[v] = true\\n    }\\n\\n    return false\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc checkIfExist(arr []int) bool {\\n    dict := map[int]bool{}\\n    for _, v := range arr {\\n        if dict[2*v] || (dict[v/2] && v%2 == 0) {\\n            return true\\n        }\\n        dict[v] = true\\n    }\\n\\n    return false\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1262374,
                "title": "1-minute-read-java-o-n-solution",
                "content": "Use Hash Set to store all the elements of the array into it. Then re-iterate over the array to see if it\\'s double is present in the set. The only exception to this method is that if our array contains only one ```0``` then it is itself\\'s double, and our algorithm would count is as present, but we don\\'t want to count it if it\\'s the only ```0``` present (because question demands for their indices ```i``` and ```j``` to be different). So we also keep a track of count of zero and and upon re-iteration, we check on finding ```0```, if it\\'s count is greater than 1.\\n\\nBelow is the code of above algorithm in Java.\\n\\n```java\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        int zero = 0;\\n        for(int i : arr) {\\n            set.add(i);\\n            if(i == 0) \\n                zero++;\\n        }\\n        for(int i : arr) {\\n            if(i == 0 && zero > 1)  \\n                return true;\\n            else if(i != 0 && set.contains(2 * i)) \\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```0```\n```0```\n```i```\n```j```\n```0```\n```java\\nclass Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        Set<Integer> set = new HashSet<>();\\n        int zero = 0;\\n        for(int i : arr) {\\n            set.add(i);\\n            if(i == 0) \\n                zero++;\\n        }\\n        for(int i : arr) {\\n            if(i == 0 && zero > 1)  \\n                return true;\\n            else if(i != 0 && set.contains(2 * i)) \\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213186,
                "title": "python-beats-97",
                "content": "```\\nclass Solution:\\n    def checkIfExist(self, nums: List[int]) -> bool:\\n        s=set()\\n        for i in nums:\\n            if i/2 in s or i*2 in s:\\n                return True\\n            else:\\n                s.add(i)\\n        return False\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkIfExist(self, nums: List[int]) -> bool:\\n        s=set()\\n        for i in nums:\\n            if i/2 in s or i*2 in s:\\n                return True\\n            else:\\n                s.add(i)\\n        return False\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1166376,
                "title": "js-easy-to-understand-for-beginners-as-well",
                "content": "```\\nvar checkIfExist = function(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(arr.indexOf(arr[i]/2) !== -1 && arr.indexOf(arr[i]/2) !== i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkIfExist = function(arr) {\\n    for(let i=0;i<arr.length;i++){\\n        if(arr.indexOf(arr[i]/2) !== -1 && arr.indexOf(arr[i]/2) !== i){\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1152025,
                "title": "simpler-and-faster-c-solution-using-hashset-o-n",
                "content": "```\\n    bool checkIfExist(vector<int>& arr) {\\n        if(arr.size() < 2)\\n            return false;\\n        unordered_set<int> lookup;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(lookup.find(arr[i]) == lookup.end()) //not found\\n            {\\n                lookup.insert(2*arr[i]);\\n                if(arr[i]%2 == 0)\\n                    lookup.insert(arr[i]/2);\\n            }\\n            else\\n                return true;\\n        }\\n        return false;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\n    bool checkIfExist(vector<int>& arr) {\\n        if(arr.size() < 2)\\n            return false;\\n        unordered_set<int> lookup;\\n        for(int i = 0; i < arr.size(); i++)\\n        {\\n            if(lookup.find(arr[i]) == lookup.end()) //not found\\n            {\\n                lookup.insert(2*arr[i]);\\n                if(arr[i]%2 == 0)\\n                    lookup.insert(arr[i]/2);\\n            }\\n            else\\n                return true;\\n        }\\n        return false;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1115612,
                "title": "unordered-set-solution-c-faster-than-97",
                "content": "We create a set, and with every iteration on the elements of the array - if we find that a double of the element, or that element divided by 2 is in the set - return true, otherwise, put that element in the set and continue. When we finish - if we finished iterating on the array and haven\\'t returned true, return false as it necessarily means there are no elements satysfying the condition of the problem.\\n```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s = unordered_set<int>();\\n        for (int i = 0; i < arr.size(); ++i){\\n            if (s.find(arr[i]*2) != s.end()){\\n                return true;\\n            }\\n            else if ((arr[i])%2 == 0 and s.find(arr[i]/2) != s.end()){\\n                return true;\\n            }\\n            else{\\n                s.insert(arr[i]);\\n                continue;\\n            }\\n        }\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        unordered_set<int> s = unordered_set<int>();\\n        for (int i = 0; i < arr.size(); ++i){\\n            if (s.find(arr[i]*2) != s.end()){\\n                return true;\\n            }\\n            else if ((arr[i])%2 == 0 and s.find(arr[i]/2) != s.end()){\\n                return true;\\n            }\\n            else{\\n                s.insert(arr[i]);\\n                continue;\\n            }\\n        }\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575975,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1762263,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1820536,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1782223,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1763505,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1942949,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1574258,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 2065677,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 2033547,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1953542,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1575975,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1762263,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1820536,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1782223,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1763505,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1942949,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1574258,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 2065677,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 2033547,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1953542,
                "content": [
                    {
                        "username": "ytsirolnik",
                        "content": "The question clearly states `i != j` and yet, returning a false for `[0, 0]` is false and the test case expect the return value to be`true`.\\n\\nThis contradicts the `i != j` as `0 = 0`"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "take the question this way:\\nif you have any other value than `arr[i]` that equals `2 * arr[i]`, you have a valid answer; so here you have `arr[i+1] = 2 * arr[i]` , hence this is valid."
                    },
                    {
                        "username": "ankitmishra1021",
                        "content": "Bro, better u take 0 as base case, if count of 0 > 1  return True,  and here  i != j (i and j are  indices) , you are thinking it value"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "It says that the index can not be equal the value can be equal ."
                    },
                    {
                        "username": "pritz99",
                        "content": "[-2,0,10,-19,4,6,-8] this case only gives me error 107/108?\\nanyone"
                    },
                    {
                        "username": "gpzzz",
                        "content": "Reason is the zero, when your loop reaches 0, it tries if 0*2 == 0, which is true, return true.\\nSolution? Add a check for individual zeros and skip them"
                    },
                    {
                        "username": "user1678hd",
                        "content": "add this                     if arr[j]==arr[i]*2 and i!=j:\\ni had the same test case\\n"
                    },
                    {
                        "username": "Nitai_Gauranga",
                        "content": "@pritz99 can you tell what approach u re following?"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "same"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) can you post you solution and error if you want to continue with this approach ?"
                    },
                    {
                        "username": "pritz99",
                        "content": "[@darkmatter404](/darkmatter404)  converting both the array into list and retaining one to another if there is common element and it not on same index return true"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@pritz99](/pritz99) what is the approach that you are following?"
                    },
                    {
                        "username": "matthewwdaly",
                        "content": "Once again, a challenge in the Binary Search study plan and I have no clue why you would think to use a binary search to solve it."
                    },
                    {
                        "username": "human004",
                        "content": "Yeah, idk either. If you wanted to solve with constant space, sorting and using two pointers would be more efficient than sorting and binary search. Though I think they would technically both be O(n log n). Seems like something you\\'d only mention in an interview if you were asked to brainstorm other solutions."
                    },
                    {
                        "username": "Shaneyyy",
                        "content": "I was confused as well. I used an object and basic math to solve this."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "[@sandagolcea](/sandagolcea) But the array is not sorted. How can I take advantage of Binary Search searching for a target that I don\\'t know in which half it could be?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "maybe not the most intuitive, but you can use for binary search practice, if you think of the problem as `\"search for a target number in an array\"`, where `target = 2 * arr[i]`.\\nTbh, after phrasing it like that it absolutely sounds like smth to solve with binary search.. :D\\nActually think (after implementing 2x solutions), that for me the binary search in the end looks more elegant than the other solution I came up with."
                    },
                    {
                        "username": "wireless_music",
                        "content": "Just an altered version of two sum problem lol"
                    },
                    {
                        "username": "anitya_sharma",
                        "content": "class Solution {\\n    public boolean checkIfExist(int[] arr) {\\n        return search(arr);\\n    }\\n    static boolean search(int[] arr){\\n        int end = arr.length-1;\\n        for(int i = 0; i<=end ; i++){\\n            for(int j = 0; j<=end ; j++){\\n                if(arr[i]==2*arr[j]){\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n107/108 testcases passed\\nhow to eliminate the negatives\\n[-2,0,10,-19,4,6,-8]\\nthis is the only testcase left"
                    },
                    {
                        "username": "PrinceTp",
                        "content": "Add a condition \\n\\nif(i!=j) \\n{ \\n      return true;\\n}"
                    },
                    {
                        "username": "pyush98",
                        "content": "0 is a special case"
                    },
                    {
                        "username": "akshatanand",
                        "content": "https://youtu.be/r8oMVi4ayZI\\n\\n"
                    },
                    {
                        "username": "piyanshu74",
                        "content": "Please do not use arr.length-1 only use arr.length in both the loop"
                    },
                    {
                        "username": "Abhishek-Pandey",
                        "content": "the test case 76 input is j [2,3,3,0,0] which does not follow the condition so return false , but the ans is true;\\n\\nthis is wrong textcase"
                    },
                    {
                        "username": "Natepot",
                        "content": "This testcase is correct. Here you can choose i=3 and j=4, so arr[i] == 0 and arr[j] == 0.\n\n1. (i != j) --> (3 != 4) --> true\n2. (0 <= i, j < arr.length) --> (0 <= 3, 4 < 5) --> true\n3. (arr[i] == 2\\*arr[j]) --> (0 == 2\\*0) --> (0 == 0) --> true\n\nNote that you must choose elements at different indices, but the elements may be equal."
                    },
                    {
                        "username": "ShaiBrin",
                        "content": "Why can\\'t 2 pointers be used. I tried it and the time limit is exceeded.\\n `while right < len(arr) and left < right:\\n\\n            if arr[left] == 2 * arr[right]:\\n                out = True\\n                break\\n            \\n            elif right == len(arr) - 1:\\n                left+=1\\n                right = left + 1\\n\\n            elif arr[left] * 2 != arr[right]:\\n                right+=1`"
                    },
                    {
                        "username": "xtrezzes",
                        "content": "look at the hints. it says to use a hash table. it allows you to find out in O(1) time whether there is a certain element in it. apparently they counted on this when they made the case tests"
                    }
                ]
            },
            {
                "id": 1909004,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1858801,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1850151,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1813212,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1785867,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1747666,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1700579,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1689530,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1627863,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            },
            {
                "id": 1737580,
                "content": [
                    {
                        "username": "karthikeya48",
                        "content": "class Solution {\npublic:\n    bool checkIfExist(vector<int>& arr) {\n        unordered_set<int>s(arr.begin(),arr.end());\n\n        for(int i:s){\n            if(s.count(i*2)){\n                return true;\n                break;\n            }\n        }\n        return false;\n        \n    }\n};\n[-2,0,10,-19,4,6,-8]#fails for this test case\n\nCan anyone say what went wrong in the above code ??\n\n"
                    },
                    {
                        "username": "Natepot",
                        "content": "The only values in this array where N and its double exist are 0 and 0*2=0, but you can\\'t use this since index i would equal index j. You\\'d need to assert that, for this special 0 case, you aren\\'t double-counting that index/element. (Note that if there are multiple instances of 0 in the array then returning true is valid, since i and j can be different values)"
                    },
                    {
                        "username": "jerryy147",
                        "content": "Testcase : [0,0], expected : true, yet i should not equal j"
                    },
                    {
                        "username": "Natepot",
                        "content": "i and j are array indices, not values. Here i can be 0 and j can be 1 (not equal), while arr[i] == 0 and arr[j] == 0 (arr[0] == 0 and arr[1] == 0)."
                    },
                    {
                        "username": "WallaWonka",
                        "content": "I can\\'t figure it out a solution not $O(n^2)$. Can anyone please help me?"
                    },
                    {
                        "username": "pyush98",
                        "content": "use a hashmap \n\n\n\n0 is the only number where 2 * n = n when n = 0\n\nso after u implement the hasmap solution, simply go back in ur code and count the zeros. if count >1 return True, if not, go to the rest of ur code where u iterate thru the hasmap and check for stuff\n\n"
                    },
                    {
                        "username": "piyushhhh_code",
                        "content": "We can do the above problem in O(n) in average case by using unordered set.\\nYou can visit my solution for elaborate explanation: https://leetcode.com/problems/check-if-n-and-its-double-exist/solutions/3641123/easy-unordered-set-on-c-code/\\n"
                    },
                    {
                        "username": "rituraj421",
                        "content": "`Below is my solution `\n\n`class Solution {`\n    `public boolean checkIfExist(int[] arr) {`\n       ` int slow = 0;`\n       ` int fast = 1;`\n\n        while (fast < arr.length) {\n            if (arr[slow] == 2 * arr[fast] || arr[fast] == 2 * arr[slow]) {\n                return true;\n            }\n            if (arr[fast] > 2 * arr[slow]) {\n                slow++;\n            } else {\n                fast++;\n            }\n            if (slow == fast) {\n                fast++;\n            }\n        }\n        return false;\n    }\n`}`\n\nIt passed around 51 testcases and `failed at this one \"arr =[2,3,3,0,0]\" `\nbut the condition says ` \" arr[i] == 2 * arr[j]\" ` which is voileted , my ans is \"false\" But it says it must be true,\nsomeone please `Explain`\n"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "I hope you have figured out the problem by yourself. But still here are my 2 cents.\\nI can see why you chose this 2 pointer approach, but its tricker than simple addition in a standard finding sum problem.\\nTry having an approach with DS like Map & list.\\nAnyway, to answer your question in this particular test case your code 2 flaws.\\n1. the array is almost sorted like 2,3,3 Here your code  if(arr[fast] > 2 * arr[slow]) fails and keeps incrementing  fast pointer till arr.length and exits while loop\\n2. In the whole solution you have not consider the case an array with 2 or more zeros. keep in mind 0/2 = 0. Thus if more that one 0\\'s are present in array immediately return true. you don\\'t have to wait till 2 pointers catch on to it."
                    },
                    {
                        "username": "hwanyb",
                        "content": " ```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        if(arr.includes(item * 2) || arr.includes(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n```\\nvar checkIfExist = function(arr) {\\n    for(let i = 0; i < arr.length; i++) {\\n        const item = arr[i];\\n        const setedArr = new Set(arr);\\n        if(setedArr.has(item * 2) || setedArr.has(item / 2)){\\n            return true;\\n        }\\n    } \\n    return false;\\n};\\n```\\n\\n\\nCan anyone explain the difference between the two?"
                    },
                    {
                        "username": "kmilesz",
                        "content": "in javascripts, array.includes() has a time complexity o(n), and set.has() has a time complexity o(1)\\n"
                    },
                    {
                        "username": "user4154k",
                        "content": "Two Pointer Simple Approach\\n\\nclass Solution:\\n    def checkIfExist(self, arr: List[int]) -> bool:\\n        \\n        \\n        i = 0\\n        j = 1\\n        \\n        while i < len(arr)-1:\\n            \\n            if arr[i] == arr[j] *2 or arr[i] == arr[j] / 2:\\n                return True\\n            else:\\n                j += 1\\n                \\n            if j == len(arr):\\n                i += 1\\n                j = i+1\\n                \\n        else:\\n            return False"
                    },
                    {
                        "username": "IsaKons",
                        "content": "[@ghosh_babu](/ghosh_babu) seems that yes, its the same as to have two FOR. Like for I in length, and for j in length. So O(N^2)"
                    },
                    {
                        "username": "ghosh_babu",
                        "content": "Although you are using a single while loop, I believe the complexity ends up being O(N^2). isn\\'t it? I mean for these 3 statement \\n       if j == len(arr):\\n            i += 1\\n            j = i+1 \\n\\nyou are iterating for each element once the whole array actually? "
                    },
                    {
                        "username": "shashwatwankhedekar",
                        "content": "Can anyone help to optimize this code as it is running for some cases like \\n10 2 5 3\\n 3 1 7 11\\n10 1 5 3\\n11 3 5 10\\n1 10 5 3\\nbut not for \\n5 1 10 6\\n\\nclass Solution {\\npublic:\\n    bool checkIfExist(vector<int>& arr) {\\n        sort(arr.begin(), arr.end(), greater<int>());\\n        int l = 0;\\n        int h = arr.size() - 1;\\n        // int mid = l + (h - l)/2;\\n        int i = 0;\\n\\n        while (l<=h)\\n        {\\n            int mid = l + (h - l)/2;\\n            if(arr[i] == 2*arr[mid])\\n            {\\n                return true;\\n            }\\n\\n            else if(2*arr[mid] < arr[i])\\n            {\\n                h = mid - 1;\\n            }\\n            else\\n            {\\n                l = mid + 1;\\n            }\\n            i++;\\n        } \\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "therishuraj",
                        "content": "        int i = 0;\n        while(i<arr.size()) {\n            int l = 0;\n            int h = arr.size()-1;\n            while (l <= h) {\n                int mid = l + (h - l)/2;\n                if(arr[i] < 2*arr[mid]) {\n                    l = mid + 1;\n                }\n                else if(arr[i] > 2*arr[mid]) {\n                    h = mid - 1;\n                }\n                else {\n                    return true;\n                }\n            }\n            i++;\n        }\n        return false;\n\nmissing a loop for i . \nCheck this out."
                    },
                    {
                        "username": "nagar-ananya",
                        "content": "How do I check extra long cases in order to filter out errors in my code (testcase 106/108)?"
                    },
                    {
                        "username": "hars_raj",
                        "content": "The failed test cases are shown after submission. Examine those.."
                    },
                    {
                        "username": "schnarbies",
                        "content": "I don\\'t understand, the code tester is telling me that for an array [2,3,3,0,0] the answer should be true, so ?????"
                    },
                    {
                        "username": "jelb",
                        "content": "0,0 are considered as well as far they are in different index!\\n"
                    },
                    {
                        "username": "sateesh_kovvuri",
                        "content": "for i=3 , j=4 arr[i]=2*arr[j] so its true"
                    },
                    {
                        "username": "Kashif_Rahman",
                        "content": "for [0,0] it will return true ."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: use Set data structure to get O(n) solution"
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "[@darkmatter404](/darkmatter404) Why do we need to store key and value when we only required key.So when ever need to have a use of hashmap ,think set or dic"
                    },
                    {
                        "username": "darkmatter404",
                        "content": "[@Yusen Peng](/YusenPeng) - why do you prefer Set over Dict ? "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Number of Steps to Make Two Strings Anagram",
        "question_content": "<p>You are given two strings of the same length <code>s</code> and <code>t</code>. In one step you can choose <strong>any character</strong> of <code>t</code> and replace it with <strong>another character</strong>.</p>\n\n<p>Return <em>the minimum number of steps</em> to make <code>t</code> an anagram of <code>s</code>.</p>\n\n<p>An <strong>Anagram</strong> of a string is a string that contains the same characters with a different (or the same) ordering.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;bab&quot;, t = &quot;aba&quot;\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Replace the first &#39;a&#39; in t with b, t = &quot;bba&quot; which is anagram of s.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;leetcode&quot;, t = &quot;practice&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> Replace &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; and &#39;c&#39; from t with proper characters to make t anagram of s.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;anagram&quot;, t = &quot;mangaar&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> &quot;anagram&quot; and &quot;mangaar&quot; are anagrams. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>s.length == t.length</code></li>\n\t<li><code>s</code> and <code>t</code> consist of lowercase English letters only.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 503450,
                "title": "java-python-3-count-occurrences-and-sum-the-difference-w-analysis",
                "content": "```java\\n    public int minSteps(String s, String t) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\']; // count the occurrences of chars in s.\\n            --count[t.charAt(i) - \\'a\\']; // compute the difference between s and t.\\n        }\\n     // return Arrays.stream(count).map(Math::abs).sum() / 2; // sum the absolute of difference and divide it by 2.\\n     // return Arrays.stream(count).filter(i -> i > 0).sum(); // sum the positive values.\\n        int steps = 0;\\n        for (int step : count) {\\n            if (step > 0) {\\n                steps += step;\\n            }\\n        }\\n\\t    return steps;\\n    }\\n```\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt, steps = Counter(s), 0\\n        for c in t:\\n            if cnt[c] > 0:\\n                cnt[c] -= 1\\n            else:\\n                steps += 1\\n        return steps\\n```\\nmake the above Python 3 code shorter\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = map(collections.Counter, (s, t))\\n        return sum(abs(cnt1[c] - cnt2[c]) for c in string.ascii_lowercase) // 2\\n```\\nor further simpler:\\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = map(collections.Counter, (s, t))\\n        return sum((cnt1 - cnt2).values())\\n```\\n**Analysis:**\\nTime: O(n), space: O(1), where n = s.length() + t.length().",
                "solutionTags": [],
                "code": "```java\\n    public int minSteps(String s, String t) {\\n        int[] count = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            ++count[s.charAt(i) - \\'a\\']; // count the occurrences of chars in s.\\n            --count[t.charAt(i) - \\'a\\']; // compute the difference between s and t.\\n        }\\n     // return Arrays.stream(count).map(Math::abs).sum() / 2; // sum the absolute of difference and divide it by 2.\\n     // return Arrays.stream(count).filter(i -> i > 0).sum(); // sum the positive values.\\n        int steps = 0;\\n        for (int step : count) {\\n            if (step > 0) {\\n                steps += step;\\n            }\\n        }\\n\\t    return steps;\\n    }\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt, steps = Counter(s), 0\\n        for c in t:\\n            if cnt[c] > 0:\\n                cnt[c] -= 1\\n            else:\\n                steps += 1\\n        return steps\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = map(collections.Counter, (s, t))\\n        return sum(abs(cnt1[c] - cnt2[c]) for c in string.ascii_lowercase) // 2\\n```\n```python\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = map(collections.Counter, (s, t))\\n        return sum((cnt1 - cnt2).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503460,
                "title": "java-maintain-an-array-to-record-the-occurrence-of-characters",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i = 0; i < 26; i++) if(arr[i] > 0) ans += arr[i];\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 601103,
                "title": "only-solution-that-beats-100-time-and-100-space",
                "content": "OK lets do this!!!\\ni see a lot of people posting solutions which beat 100% of codes ,i have observed most of them do not!\\n**here i will post a complete optimisation workflow so that u get an understanding of how to reduce the runtime**\\n\\nMY ATTEMPT-1:\\n\\n```\\n      class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0;\\n        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i : arr) if(i > 0) ans += i;\\n        return ans;\\n    }\\n}  \\n```\\nRUNTIME-13MS BEATS 73%\\nUMMMM......GOOD BUT NOT ENOUGH!!\\n\\nATTEMPT-2!\\n\\n   ```\\n   class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0; //removed this as it is already given length of two strings are same! silly mistake        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n\\t\\tchar[] sc=s.toCharArray();   //converted string to char array\\n\\t\\tchar[] tc=t.toCharArray();   //converted string to char array\\n        for(int i = 0; i < n; i++) {\\n            arr[sc[i] - \\'a\\']++;\\n            arr[tc[i] - \\'a\\']--;\\n        }\\n        for(int i : arr) if(i > 0) ans += i;\\n        return ans;\\n    }\\n}  \\n```\\nIMPROVS-CONVERTING STRING TO CHAR ARRAY AS ARRAY IS FASTER !\\nRUNTIME -9 MS!\\nNICE!GOOD JOB!\\nBEATS 90%!\\n\\nBUT STILL TO GO!\\n\\nFINALLY I TRIED TO REPLACE SOME CONSTANTS WITTH FINAL STATIC VARIABLES!\\nINSTEAD OF EVERYTIME CALCULATING THE ASCII OF a WE ARE REPLACING IT WITH A CONSTANT!\\nTHIS REDUCES RUNTIME IMMENSELY!\\n\\nATTEMPT -3\\n\\n```\\nclass Solution {\\n        final static int a = 97; //ASCII OF \\'a\\'\\n        final static int size = 26; //size of array\\n\\t\\n        public int minSteps(String s, String t) {\\n            int[] arr = new int[size];\\n            int l = s.length();\\n            char[] sa = s.toCharArray();\\n            char[] ta = t.toCharArray();\\n            for (int i = 0; i < l; i++) {\\n                int sci = sa[i] - a;\\n                int tci = ta[i] - a;\\n                arr[sci] += 1;\\n                arr[tci] -= 1;\\n            }\\n            int ans = 0;\\n            for (int n : arr) {\\n                if (n > 0) {\\n                    ans += n;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n\\t```\\n\\t\\n\\t\\n**RUNTIME-7 MS!\\nBEATS 100%\\nFINALLY FULLY OPTIMISED!!**\\n\\nSO I HOPE  U GET MY THOUGHT PROCESS !\\nHOPE IT HELPS!\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n      class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0;\\n        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n        for(int i = 0; i < n; i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }\\n        for(int i : arr) if(i > 0) ans += i;\\n        return ans;\\n    }\\n}  \\n```\n```\\n   class Solution {\\n    public int minSteps(String s, String t) {\\n        if(s.equals(t))return 0; //removed this as it is already given length of two strings are same! silly mistake        \\n        \\n        int n = s.length(), ans = 0;\\n        int[] arr = new int[26];\\n\\t\\tchar[] sc=s.toCharArray();   //converted string to char array\\n\\t\\tchar[] tc=t.toCharArray();   //converted string to char array\\n        for(int i = 0; i < n; i++) {\\n            arr[sc[i] - \\'a\\']++;\\n            arr[tc[i] - \\'a\\']--;\\n        }\\n        for(int i : arr) if(i > 0) ans += i;\\n        return ans;\\n    }\\n}  \\n```\n```\\nclass Solution {\\n        final static int a = 97; //ASCII OF \\'a\\'\\n        final static int size = 26; //size of array\\n\\t\\n        public int minSteps(String s, String t) {\\n            int[] arr = new int[size];\\n            int l = s.length();\\n            char[] sa = s.toCharArray();\\n            char[] ta = t.toCharArray();\\n            for (int i = 0; i < l; i++) {\\n                int sci = sa[i] - a;\\n                int tci = ta[i] - a;\\n                arr[sci] += 1;\\n                arr[tci] -= 1;\\n            }\\n            int ans = 0;\\n            for (int n : arr) {\\n                if (n > 0) {\\n                    ans += n;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 503708,
                "title": "precise-c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        int sum=0;\\n        for(auto i:s)\\n            m[i]++;\\n        for(auto i:t)\\n            m[i]--;\\n        for(auto i:m){\\n            if(i.second<0)\\n                sum += i.second;\\n        }\\n        return abs(sum);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        int sum=0;\\n        for(auto i:s)\\n            m[i]++;\\n        for(auto i:t)\\n            m[i]--;\\n        for(auto i:m){\\n            if(i.second<0)\\n                sum += i.second;\\n        }\\n        return abs(sum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902179,
                "title": "python-easy-solution-with-explanation-o-n-time-and-space-faster-97",
                "content": "#####   Idea: the strings are equal in length \\n* #####              Replacing is the only operation \\n* #####              Find how many characters t and s shares \\n* #####              And the remining would be the needed replacment                 \\n\\t1. * #####            count the letter occurance in the s \\n\\t1. * #####            iterate over t and when you get same letter as in s, substract it from s\\n#####             \\n#####             return the remaining number of letters in s\\n\\n```\\n        import collections \\n        memo = collections.defaultdict(int)\\n        # saving the number of occurance of characters in s\\n        for char in s:\\n            memo[char] += 1\\n\\t\\t\\t\\n        count = 0\\n        for char in t:\\n            if memo[char]:\\n                memo[char] -=1   # if char in t is also in memo, substract that from the counted number\\n            else:\\n                count += 1\\n        # return count #or\\n        return sum(memo.values())\\n```\\n\\n##### IF this helps, please don\\'t forget to upvote",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        import collections \\n        memo = collections.defaultdict(int)\\n        # saving the number of occurance of characters in s\\n        for char in s:\\n            memo[char] += 1\\n\\t\\t\\t\\n        count = 0\\n        for char in t:\\n            if memo[char]:\\n                memo[char] -=1   # if char in t is also in memo, substract that from the counted number\\n            else:\\n                count += 1\\n        # return count #or\\n        return sum(memo.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 618456,
                "title": "python-solution",
                "content": "Delete the common characters in s and t; Number of remaining characters in t is the answer. \\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        for ch in s:\\n\\t\\t    # Find and replace only one occurence of this character in t\\n            t = t.replace(ch, \\'\\', 1)\\n            \\n        return len(t)\\n```\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        for ch in s:\\n\\t\\t    # Find and replace only one occurence of this character in t\\n            t = t.replace(ch, \\'\\', 1)\\n            \\n        return len(t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 734251,
                "title": "c-very-easy-to-understand-without-hashmap",
                "content": "In this we just have to return the number of characters(with respect to their frequency) **which are in s but not in t**\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) { \\n        int Freq[26]={0};\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            Freq[s[i]-\\'a\\']++;\\n            Freq[t[i]-\\'a\\']--;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(Freq[i]>0)\\n                count+=Freq[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) { \\n        int Freq[26]={0};\\n        int count=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            Freq[s[i]-\\'a\\']++;\\n            Freq[t[i]-\\'a\\']--;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(Freq[i]>0)\\n                count+=Freq[i];\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073267,
                "title": "js-easy-solution-hashmap",
                "content": "```\\nvar minSteps = function(s, t) {\\n    /*  create a hashMap for s iterate throgh t \\n        and check how many letters are missing\\n\\t\\tO(N) - time\\n\\t\\tO(1) - space, since there are only 26 letters in the alphabet\\n    */\\n    let hashMap = {};\\n    for (let letter of s) {\\n        if (hashMap[letter]) hashMap[letter] ++;\\n        else hashMap[letter] = 1;\\n    }\\n    let changes = 0;\\n    for (let letter of t) {\\n        if (hashMap[letter]) hashMap[letter] --;\\n        else changes ++;\\n    }\\n    return changes;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSteps = function(s, t) {\\n    /*  create a hashMap for s iterate throgh t \\n        and check how many letters are missing\\n\\t\\tO(N) - time\\n\\t\\tO(1) - space, since there are only 26 letters in the alphabet\\n    */\\n    let hashMap = {};\\n    for (let letter of s) {\\n        if (hashMap[letter]) hashMap[letter] ++;\\n        else hashMap[letter] = 1;\\n    }\\n    let changes = 0;\\n    for (let letter of t) {\\n        if (hashMap[letter]) hashMap[letter] --;\\n        else changes ++;\\n    }\\n    return changes;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 536256,
                "title": "simple-solution-using-hashmap-with-explanations",
                "content": "class Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int step=0;\\n        \\n        //store everything of s into a hashmap, along with each frequencies\\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }\\n        \\n        \\n        for(int i=0; i<t.length(); i++){\\n            char c = t.charAt(i);\\n\\n            //if the map contains one of the character with at least 1 frequency,\\n            //we subtract the frequency\\n            if(map.containsKey(c) && map.get(c)>0){\\n                map.put(c, map.get(c)-1);\\n            }\\n            //otherwise increment the steps needed to make t anagram\\n            else step++;\\n        }\\n        \\n        return step;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        HashMap<Character, Integer> map = new HashMap<>();\\n        int step=0;\\n        \\n        //store everything of s into a hashmap, along with each frequencies\\n        for(char c : s.toCharArray()){\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 509847,
                "title": "javascript-easy-to-understand-counting-o-n",
                "content": "We do counting first and then calculate the sum of positive count.\\n\\n```js\\nconst minSteps = (s, t) => {\\n  const BASE = 97;\\n  const count = new Int32Array(26);\\n  for (let i = 0; i < s.length; ++i) {\\n    ++count[s.charCodeAt(i) - BASE];\\n    --count[t.charCodeAt(i) - BASE];\\n  }\\n  let step = 0;\\n  for (let i = 0; i < 26; ++i) {\\n    count[i] > 0 && (step += count[i]);\\n  }\\n  return step;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst minSteps = (s, t) => {\\n  const BASE = 97;\\n  const count = new Int32Array(26);\\n  for (let i = 0; i < s.length; ++i) {\\n    ++count[s.charCodeAt(i) - BASE];\\n    --count[t.charCodeAt(i) - BASE];\\n  }\\n  let step = 0;\\n  for (let i = 0; i < 26; ++i) {\\n    count[i] > 0 && (step += count[i]);\\n  }\\n  return step;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503535,
                "title": "python-3-two-lines-beats-100",
                "content": "```\\nclass Solution:\\n    def minSteps(self, S: str, T: str) -> int:\\n        D = collections.Counter(S) - collections.Counter(T)\\n        return sum(max(0, D[s]) for s in set(S))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, S: str, T: str) -> int:\\n        D = collections.Counter(S) - collections.Counter(T)\\n        return sum(max(0, D[s]) for s in set(S))\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 503444,
                "title": "c-o-n-o-26",
                "content": "```\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (auto ch : s) ++cnt[ch - \\'a\\'];\\n    for (auto ch : t) --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int n) {return s + abs(n); }) / 2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t) {\\n    int cnt[26] = {};\\n    for (auto ch : s) ++cnt[ch - \\'a\\'];\\n    for (auto ch : t) --cnt[ch - \\'a\\'];\\n    return accumulate(begin(cnt), end(cnt), 0, [](int s, int n) {return s + abs(n); }) / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2421540,
                "title": "python-elegant-short-no-built-ins-constant-memory",
                "content": "\\n\\n    def minSteps(self, s: str, t: str) -> int:\\n        count = [0] * 26\\n\\n        for char in s:\\n            count[ord(char) - ord(\\'a\\')] += 1\\n\\n        for char in t:\\n            count[ord(char) - ord(\\'a\\')] -= 1\\n\\n        return sum(val for val in count if val > 0)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n\\n    def minSteps(self, s: str, t: str) -> int:\\n        count = [0] * 26\\n\\n        for char in s:\\n            count[ord(char) - ord(\\'a\\')] += 1\\n\\n        for char in t:\\n            count[ord(char) - ord(\\'a\\')] -= 1\\n\\n        return sum(val for val in count if val > 0)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 930487,
                "title": "java-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int ans = 0;\\n        HashMap<Character, Integer> sFreq = new HashMap();\\n        HashMap<Character, Integer> tFreq = new HashMap();\\n        \\n        for(char ch : s.toCharArray()){\\n            sFreq.put(ch, sFreq.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(char ch : t.toCharArray()){\\n\\n            tFreq.put(ch, tFreq.getOrDefault(ch, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : sFreq.entrySet()){\\n            if(tFreq.containsKey(entry.getKey())){\\n                int diff = entry.getValue() - tFreq.get(entry.getKey());\\n                if(diff > 0)\\n                    ans += diff;\\n            } else {\\n                ans += entry.getValue();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n* The main idea is: we make hashmap of char frequency of each string, then we iterate through map of String s that we have built. As we iterate, we get the difference between the current char of map S and that of map T. If T doesn\\'t have current char of map S, then we add the value of s to our ans counter",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int ans = 0;\\n        HashMap<Character, Integer> sFreq = new HashMap();\\n        HashMap<Character, Integer> tFreq = new HashMap();\\n        \\n        for(char ch : s.toCharArray()){\\n            sFreq.put(ch, sFreq.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(char ch : t.toCharArray()){\\n\\n            tFreq.put(ch, tFreq.getOrDefault(ch, 0) + 1);\\n        }\\n\\n        for (Map.Entry<Character, Integer> entry : sFreq.entrySet()){\\n            if(tFreq.containsKey(entry.getKey())){\\n                int diff = entry.getValue() - tFreq.get(entry.getKey());\\n                if(diff > 0)\\n                    ans += diff;\\n            } else {\\n                ans += entry.getValue();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523328,
                "title": "python-3-detailed-and-minimal-solutions",
                "content": "**Intuition** \\u2014 We want to have the same letters/counts in `s` and `t` so we first count letter frequencies for both and the number of steps would be the sum of the differences between frequencies. \\n\\nWe do not sum negative differences since they have their positive counter-parts. \\n**Example** \\u2013 frequency differences of `{-1,1}` in the `s = \"bab\", t = \"aba\"` test case imply that we have to change one letter with the other and the number of steps is `sum([1])=1`. \\n\\n```Python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minSteps(self, s, t):\\n        s_freq, t_freq, steps = defaultdict(int), defaultdict(int), 0\\n        for c in s:\\n            s_freq[c] += 1\\n        for c in t:\\n            t_freq[c] += 1\\n        for l in s_freq:\\n            s_i = s_freq[l] - t_freq[l]\\n            if s_i > 0:\\n                steps += s_i\\n        return steps\\n```\\n\\nA simpler version that uses `collections.Counter`:\\n\\n```Python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s, t):\\n        s_freq, t_freq = map(Counter, (s, t))\\n        return sum((s_freq-t_freq).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minSteps(self, s, t):\\n        s_freq, t_freq, steps = defaultdict(int), defaultdict(int), 0\\n        for c in s:\\n            s_freq[c] += 1\\n        for c in t:\\n            t_freq[c] += 1\\n        for l in s_freq:\\n            s_i = s_freq[l] - t_freq[l]\\n            if s_i > 0:\\n                steps += s_i\\n        return steps\\n```\n```Python\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s, t):\\n        s_freq, t_freq = map(Counter, (s, t))\\n        return sum((s_freq-t_freq).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503719,
                "title": "python-pythonic-solution-and-explanation",
                "content": "```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((collections.Counter(s)-collections.Counter(t)).values())\\n```\\n\\nlonger version:\\n```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        S = collections.Counter(s)\\n        T = collections.Counter(t)\\n        return sum((S-T).values())\\n```\\nExplanation:\\nR = S - T will return the following:\\n1. if a letter `e` is in both S and T and Counter of `e` is higher in S: `R[\\'e\\'] = S[\\'e\\'] - T[\\'e\\']`\\n2. if a letter `e` is in both S and T and Counter of `e` is lower in S: `R[\\'e\\'] = 0`. Note that this is **not negative**. Very important\\n3. if a letter `e` is only in S: `R[\\'e\\'] = S[\\'e\\']`\\n\\nTherefore, after running `S-T`, we have :\\n1. Letters those only appear in S \\n2. Letters those appear in S more than T with the difference as `value`\\n\\nThe sum of these will be the total of \"extra\" charaters in T\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((collections.Counter(s)-collections.Counter(t)).values())\\n```\n```python\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        S = collections.Counter(s)\\n        T = collections.Counter(t)\\n        return sum((S-T).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363535,
                "title": "minimum-number-of-steps-c-easy-fast-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        unordered_map<char,int>m;\\n        int count = 0;\\n\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i = 0; i<t.size(); i++)\\n        {\\n            m[t[i]]--;\\n        }\\n        for(auto x : m)\\n        {\\n            count += abs(x.second);\\n        }\\n        return count/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        unordered_map<char,int>m;\\n        int count = 0;\\n\\n        for(int i = 0; i<s.size(); i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i = 0; i<t.size(); i++)\\n        {\\n            m[t[i]]--;\\n        }\\n        for(auto x : m)\\n        {\\n            count += abs(x.second);\\n        }\\n        return count/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841286,
                "title": "python-easy-solution-beat-99-using-counter",
                "content": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn len(s) - count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# if you like the solution, Please upvote!!\\n\\tclass Solution:\\n\\t\\tdef minSteps(self, s: str, t: str) -> int:\\n\\n\\t\\t\\tcommon = Counter(s) & Counter(t)\\n\\t\\t\\tcount = sum(common.values())\\n\\n\\t\\t\\treturn len(s) - count",
                "codeTag": "Java"
            },
            {
                "id": 1562931,
                "title": "c-o-n-solution-short-solution",
                "content": "We will keep record of the characters of both strings in a single map i.e., add the characters of one string and subtract the characters of other string. This way the common elements will have frequency 0 in the map.\\nNow we will calculate the total +ve frequency, this indicates the total number of characters of 1st string which are not present in 2nd string.\\nSimilarly, the -ve frequency will tell us about the number of characters of 2nd string which are not present in 1st string.\\n\\nLet us assume they came out to be ```x``` and ```y``` respectively and``` x = y```, then the answer will be  ```x``` becuase we can make those  ```y``` characters of 2nd string same as ```x``` characters of string 1.\\n\\nIf any of them is greater then, the answer will be the greater value i.e. if ```x > y```, then ```y``` characters can be changed to the chracters in 1st string leaving ```x - y``` characters, which must be added to string 2 to make it an anagram of string 1.\\nThus answer is ```y + (x - y) = x``` i.e., the greater value.\\n\\n```\\nint minSteps(string s, string t) {\\n        vector<int> mp(26, 0);\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i] - \\'a\\']++;\\n            mp[t[i] - \\'a\\']--;\\n        }\\n        int pos = 0, neg = 0;\\n        for(auto it : mp) {\\n            if(it > 0) pos += it;\\n            if(it < 0) neg -= it;\\n        }\\n        return max(pos, neg); \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```x```\n```y```\n``` x = y```\n```x```\n```y```\n```x```\n```x > y```\n```y```\n```x - y```\n```y + (x - y) = x```\n```\\nint minSteps(string s, string t) {\\n        vector<int> mp(26, 0);\\n        for(int i = 0; i < s.size(); i++) {\\n            mp[s[i] - \\'a\\']++;\\n            mp[t[i] - \\'a\\']--;\\n        }\\n        int pos = 0, neg = 0;\\n        for(auto it : mp) {\\n            if(it > 0) pos += it;\\n            if(it < 0) neg -= it;\\n        }\\n        return max(pos, neg); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503438,
                "title": "java-simple-count-mismatching-character",
                "content": "```\\n    public int minSteps(String s, String t) {\\n        int[] charMap = new int[26];\\n        for(char c: s.toCharArray()) charMap[c -\\'a\\']++;\\n        for(char c: t.toCharArray()) charMap[c -\\'a\\']--;\\n        \\n        int count = 0;        \\n        for(int i=0; i< 26;i++) \\n            if(charMap[i] > 0)\\n                count += charMap[i];\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minSteps(String s, String t) {\\n        int[] charMap = new int[26];\\n        for(char c: s.toCharArray()) charMap[c -\\'a\\']++;\\n        for(char c: t.toCharArray()) charMap[c -\\'a\\']--;\\n        \\n        int count = 0;        \\n        for(int i=0; i< 26;i++) \\n            if(charMap[i] > 0)\\n                count += charMap[i];\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999008,
                "title": "java-94-beats-2-solution-hashmap-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst create two array of length 26 then convert string s (character of s into one array) and same in second array. then check both array index value is same or not . if not then count++ and last return count/2;\\n\\nPlease upvote me \\uD83D\\uDE4B\\u200D\\u2642\\uFE0F\\uD83D\\uDE4B\\uD83D\\uDE47\\uD83D\\uDE47\\u200D\\u2642\\uFE0F\\uD83D\\uDE47\\u200D\\u2640\\uFE0F\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        int temp[] = new int[26];\\n        int val[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n           temp[s.charAt(i)-\\'a\\']++; val[t.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0; i<temp.length; i++){\\n            if(temp[i]!=val[i]) count+=Math.abs(temp[i]-val[i]);  \\n        }\\n        return count/2;\\n\\n\\n\\n\\n//         Another Solution (Using HashMap)  \\n\\n        // Map<Character,Integer> map = new HashMap<>();\\n        // if(s.length()!=t.length()) return 0;\\n        // int count=0;\\n        // for(int i=0;i<s.length();i++){\\n        //     map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        // }\\n        // for(int i=0;i<t.length();i++){\\n        //     char ch = t.charAt(i);\\n        //     if(map.containsKey(ch) && map.get(ch)>0){\\n        //        map.put(ch,map.get(ch)-1);\\n        //     }\\n        //     else{\\n        //         count++;\\n        //     }\\n        // }\\n        // return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        int temp[] = new int[26];\\n        int val[] = new int[26];\\n        for(int i=0; i<s.length(); i++){\\n           temp[s.charAt(i)-\\'a\\']++; val[t.charAt(i)-\\'a\\']++;\\n        }\\n        for(int i=0; i<temp.length; i++){\\n            if(temp[i]!=val[i]) count+=Math.abs(temp[i]-val[i]);  \\n        }\\n        return count/2;\\n\\n\\n\\n\\n//         Another Solution (Using HashMap)  \\n\\n        // Map<Character,Integer> map = new HashMap<>();\\n        // if(s.length()!=t.length()) return 0;\\n        // int count=0;\\n        // for(int i=0;i<s.length();i++){\\n        //     map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        // }\\n        // for(int i=0;i<t.length();i++){\\n        //     char ch = t.charAt(i);\\n        //     if(map.containsKey(ch) && map.get(ch)>0){\\n        //        map.put(ch,map.get(ch)-1);\\n        //     }\\n        //     else{\\n        //         count++;\\n        //     }\\n        // }\\n        // return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826427,
                "title": "python-3-1-line-with-counter-beats-99-104ms",
                "content": "```python3 []\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return (Counter(s) - Counter(t)).total()\\n```\\n![Screenshot 2023-07-28 at 05.28.54.png](https://assets.leetcode.com/users/images/34a9cbb7-d2ea-4436-976b-690eaa4b7a61_1690511451.477379.png)\\n\\n[2186. Minimum Number of Steps to Make Two Strings Anagram II](https://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/description/)\\n```python3 []\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = Counter(s), Counter(t)\\n        return (cnt1-cnt2).total() + (cnt2-cnt1).total()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return (Counter(s) - Counter(t)).total()\\n```\n```python3 []\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1, cnt2 = Counter(s), Counter(t)\\n        return (cnt1-cnt2).total() + (cnt2-cnt1).total()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3711953,
                "title": "easy-frequency-counting-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is very simple, calculate the frequency of the characters and return **half the sum of the frequency difference between s and t.**\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        int n = s.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           v1[s[i]-\\'a\\']++;\\n           v2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++)\\n        ans+=abs(v1[i]-v2[i]);\\n        \\n        return ans/2;  \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/f6c9b79c-cad3-42c5-a203-afec7aadb9a7_1688374475.1562643.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        int n = s.size(),ans = 0;\\n        vector<int> v1(26,0),v2(26,0);\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n           v1[s[i]-\\'a\\']++;\\n           v2[t[i]-\\'a\\']++;\\n        }\\n\\n        for(int i = 0;i<26;i++)\\n        ans+=abs(v1[i]-v2[i]);\\n        \\n        return ans/2;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876345,
                "title": "python-solution-hashmap-explained",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d1={}\\n        d2={}\\n        c=0\\n        #frequency of s\\n        for i in s:\\n            if i in d1:\\n                d1[i]+=1\\n            else:\\n                d1[i]=1\\n        #frequency of t        \\n        for i in t:\\n            if i in d2:\\n                d2[i]+=1\\n            else:\\n                d2[i]=1\\n        #count the characters if s\\'s characters not present in t\\n        #and if present and frequency of s\\'s characters are greater than that of t\\'s then store their\\n        #frequency diff(coz only those need to replace from t)\\n        for i in d1.keys():\\n            if i in d2:\\n                if d1[i]>d2[i]:\\n                    c+=d1[i]-d2[i]\\n            else:\\n                c+=d1[i]\\n        return c\\n        \\n```\\n**PLEASE UPVOTE IF YOU FOUND THE SOLUTION HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d1={}\\n        d2={}\\n        c=0\\n        #frequency of s\\n        for i in s:\\n            if i in d1:\\n                d1[i]+=1\\n            else:\\n                d1[i]=1\\n        #frequency of t        \\n        for i in t:\\n            if i in d2:\\n                d2[i]+=1\\n            else:\\n                d2[i]=1\\n        #count the characters if s\\'s characters not present in t\\n        #and if present and frequency of s\\'s characters are greater than that of t\\'s then store their\\n        #frequency diff(coz only those need to replace from t)\\n        for i in d1.keys():\\n            if i in d2:\\n                if d1[i]>d2[i]:\\n                    c+=d1[i]-d2[i]\\n            else:\\n                c+=d1[i]\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581777,
                "title": "basic-and-easy-python-solution-without-using-counter",
                "content": "I saw how everyone was using counter to solve this but I was not that familiar with it. so, i wanted it to solve with basic implementation. This is a basic solution in my opinion but if you find it difficult to understand just comment down below!!\\n\\'\\'\\'\\n\\n\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\tcount = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i in t:\\n\\t\\t\\t\\tt=t.replace(i,\\'\\',1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "I saw how everyone was using counter to solve this but I was not that familiar with it. so, i wanted it to solve with basic implementation. This is a basic solution in my opinion but if you find it difficult to understand just comment down below!!\\n\\'\\'\\'\\n\\n\\tdef minSteps(self, s: str, t: str) -> int:\\n\\t\\tcount = 0\\n\\t\\tfor i in s:\\n\\t\\t\\tif i in t:\\n\\t\\t\\t\\tt=t.replace(i,\\'\\',1)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tcount += 1\\n\\t\\treturn count\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 503721,
                "title": "python3-counter-o-n-100",
                "content": "1. count all characters of `s` and `t`\\n2. for each character in `a` -> `z`\\n3. check if a character\\'s count in `s` is more than `t`  then add to result\\n\\n```\\nclass Solution:\\n  def minSteps(self, s: str, t: str) -> int:\\n    res = 0\\n    s = collections.Counter(s)\\n    t = collections.Counter(t)\\n    for c in string.ascii_lowercase:\\n        res += s[c] - t[c] if s[c] > t[c] else 0\\n    return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def minSteps(self, s: str, t: str) -> int:\\n    res = 0\\n    s = collections.Counter(s)\\n    t = collections.Counter(t)\\n    for c in string.ascii_lowercase:\\n        res += s[c] - t[c] if s[c] > t[c] else 0\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710856,
                "title": "c-easy-solution-using-vectors",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe answer is the sum of difference of frequencies of characters divides by 2\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are traversing string and storing frequency of each character of both strings. The difference between frequencies of characters is the total number of removal and insertions we have to do. Since in one swapping we can remove an element and insert another, so final answer will be the difference of frequencies / 2.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> cnt1(26,0),cnt2(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt1[s[i]-\\'a\\']++;\\n            cnt2[t[i]-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0;i<26;i++)\\n        sum+=abs(cnt1[i]-cnt2[i]);\\n\\n        return sum/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> cnt1(26,0),cnt2(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            cnt1[s[i]-\\'a\\']++;\\n            cnt2[t[i]-\\'a\\']++;\\n        }\\n        int sum=0;\\n        for(int i=0;i<26;i++)\\n        sum+=abs(cnt1[i]-cnt2[i]);\\n\\n        return sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112234,
                "title": "easy-solution-in-python-using-counter",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        for i,j in cnt2.items():\\n            if i in cnt1 and j>cnt1[i]:\\n                sm+=abs(j-cnt1[i])\\n            elif i not in cnt1:\\n                sm+=j\\n        return sm\\n```",
                "solutionTags": [
                    "Python3",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        cnt1=Counter(s)\\n        cnt2=Counter(t)\\n        sm=0\\n        for i,j in cnt2.items():\\n            if i in cnt1 and j>cnt1[i]:\\n                sm+=abs(j-cnt1[i])\\n            elif i not in cnt1:\\n                sm+=j\\n        return sm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012641,
                "title": "java-solution-beats-100",
                "content": "# Intuition\\nThis Problem can be solved using the Valid Anagram Question Idea\\n\\n# Approach\\nCount the frequencies of each character and store in seprate arrays for both the strings  & later find the difference between frequencies and add it in a variable because that much will be required to make t a anagram with s !\\n\\n# Complexity\\n- Time complexity:\\nO(N) \\n\\n- Space complexity:\\nO(1) since the 26 array size is considered to be constant\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        int[] res = validAnagram(s);\\n        int[] res1 = validAnagram(t);\\n\\n        int ans = 0;\\n\\n        for(int i = 0 ; i < 26 ; i++){\\n\\n            if(res1[i]  < res[i]){\\n\\n                ans+= res[i] - res1[i];\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n     }\\n\\n     static int[] validAnagram(String s){\\n\\n        int[] ans = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n\\n            ans[c - \\'a\\']++;\\n        }\\n        \\n        \\n        return ans;\\n\\n \\n     }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        int[] res = validAnagram(s);\\n        int[] res1 = validAnagram(t);\\n\\n        int ans = 0;\\n\\n        for(int i = 0 ; i < 26 ; i++){\\n\\n            if(res1[i]  < res[i]){\\n\\n                ans+= res[i] - res1[i];\\n            }\\n        }\\n\\n        return ans;\\n\\n\\n     }\\n\\n     static int[] validAnagram(String s){\\n\\n        int[] ans = new int[26];\\n\\n        for(char c : s.toCharArray()){\\n\\n            ans[c - \\'a\\']++;\\n        }\\n        \\n        \\n        return ans;\\n\\n \\n     }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2711634,
                "title": "java-solution-easy-understanding-simple",
                "content": "```\\n\\t\\tpublic int minSteps(String s, String t) {\\n        \\n\\t\\t\\tint[] alpha = new int[26];\\n\\t\\t\\tint steps = 0;\\n        \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++){\\n            \\n\\t\\t\\t\\talpha[s.charAt(i) - \\'a\\']++;\\n\\t\\t\\t\\talpha[t.charAt(i) - \\'a\\']--;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tfor(int n: alpha)\\n\\t\\t\\t\\tif(n > 0) steps += n;\\n        \\n\\t\\t\\treturn steps;\\n        \\n\\t\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tpublic int minSteps(String s, String t) {\\n        \\n\\t\\t\\tint[] alpha = new int[26];\\n\\t\\t\\tint steps = 0;\\n        \\n\\t\\t\\tfor(int i = 0; i < s.length(); i++){\\n            \\n\\t\\t\\t\\talpha[s.charAt(i) - \\'a\\']++;\\n\\t\\t\\t\\talpha[t.charAt(i) - \\'a\\']--;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tfor(int n: alpha)\\n\\t\\t\\t\\tif(n > 0) steps += n;\\n        \\n\\t\\t\\treturn steps;\\n        \\n\\t\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2631529,
                "title": "sliding-window-pattern-explained-with-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        //fixed sliding window pattern\\n        \\n        int i=0,j=0;\\n        int n = s.size() , diff=0;\\n        unordered_map<char,int>mp;\\n        \\n        //store frequency of all character present in s in map mp \\n        for(auto&it:s) mp[it]++;\\n \\n        while(j<n){\\n            // a-> 1 , b-> 2 in mp   --> s=\"bab\" , t=\"aba\"\\n            \\n            if(mp[t[j]]!=0){\\n                mp[t[j]]--; //decrement the frequency when that character of string t is present in mp// a->0 , b->1 --> a->0 , b->0\\n                if(mp[t[j]]==0) mp.erase(t[j]); //optional \\n                j++;\\n            }\\n            \\n            else   {\\n                diff++; // when a found in t but not in map, diff++\\n                 j++;\\n            }\\n            \\n        }\\n        \\n         return diff ; \\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        //fixed sliding window pattern\\n        \\n        int i=0,j=0;\\n        int n = s.size() , diff=0;\\n        unordered_map<char,int>mp;\\n        \\n        //store frequency of all character present in s in map mp \\n        for(auto&it:s) mp[it]++;\\n \\n        while(j<n){\\n            // a-> 1 , b-> 2 in mp   --> s=\"bab\" , t=\"aba\"\\n            \\n            if(mp[t[j]]!=0){\\n                mp[t[j]]--; //decrement the frequency when that character of string t is present in mp// a->0 , b->1 --> a->0 , b->0\\n                if(mp[t[j]]==0) mp.erase(t[j]); //optional \\n                j++;\\n            }\\n            \\n            else   {\\n                diff++; // when a found in t but not in map, diff++\\n                 j++;\\n            }\\n            \\n        }\\n        \\n         return diff ; \\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505503,
                "title": "hashmap-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> map=new HashMap<>();\\n        for(char c : s.toCharArray())map.put(c,map.getOrDefault(c,0)+1);\\n        \\n        for(char c: t.toCharArray())map.put(c,map.getOrDefault(c,0)-1);\\n        \\n        int ans=0;\\n        \\n        for(char c:map.keySet()){\\n            if(map.get(c)>0)ans+=map.get(c);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character , Integer> map=new HashMap<>();\\n        for(char c : s.toCharArray())map.put(c,map.getOrDefault(c,0)+1);\\n        \\n        for(char c: t.toCharArray())map.put(c,map.getOrDefault(c,0)-1);\\n        \\n        int ans=0;\\n        \\n        for(char c:map.keySet()){\\n            if(map.get(c)>0)ans+=map.get(c);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1802975,
                "title": "simple-java-solution",
                "content": "public int minSteps(String s, String t) {\\n\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:t.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        int p=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>b[i])\\n                p+=(a[i]-b[i]);\\n        }\\n        return p;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int minSteps(String s, String t) {\\n\\n        int a[]=new int[26];\\n        int b[]=new int[26];\\n        for(char c:s.toCharArray())\\n        {\\n            a[c-\\'a\\']++;\\n        }\\n        for(char c:t.toCharArray())\\n        {\\n            b[c-\\'a\\']++;\\n        }\\n        int p=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]>b[i])\\n                p+=(a[i]-b[i]);\\n        }\\n        return p;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1464720,
                "title": "c-map-very-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        map<char,int> mp;\\n        int res=0;\\n        \\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }\\n        \\n        for(char ch : t)\\n        {\\n            if(mp.find(ch)==mp.end())\\n            {\\n                res++;\\n            }\\n            else\\n            {\\n                mp[ch]--;\\n                if(!mp[ch])\\n                {\\n                    mp.erase(ch);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        map<char,int> mp;\\n        int res=0;\\n        \\n        for(char ch : s)\\n        {\\n            mp[ch]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1329561,
                "title": "java-easy-and-clean-solution",
                "content": "\\n    public int minSteps(String s, String t) {\\n        int ans = 0;\\n        int[] count = new int[26];\\n\\n        for (char c: s.toCharArray())\\n            count[c - \\'a\\']++;\\n\\n        for (char c: t.toCharArray())\\n            count[c - \\'a\\']--;\\n\\n        for (int i: count) {\\n            if (i >= 0)\\n                ans += i;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int minSteps(String s, String t) {\\n        int ans = 0;\\n        int[] count = new int[26];\\n\\n        for (char c: s.toCharArray())\\n            count[c - \\'a\\']++;\\n\\n        for (char c: t.toCharArray())\\n            count[c - \\'a\\']--;\\n\\n        for (int i: count) {\\n            if (i >= 0)\\n                ans += i;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1289044,
                "title": "c-speed-mem-o-m-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int mem[26] = {0};\\n        \\n        for(int i=0; i< s.size(); i++)\\n            mem[s[i]-\\'a\\']++;\\n        \\n        for(int i=0; i < t.size(); i++)\\n            mem[t[i]-\\'a\\']--;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i < 26; i++)\\n            if(mem[i]>0)\\n                cnt += mem[i];\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int mem[26] = {0};\\n        \\n        for(int i=0; i< s.size(); i++)\\n            mem[s[i]-\\'a\\']++;\\n        \\n        for(int i=0; i < t.size(); i++)\\n            mem[t[i]-\\'a\\']--;\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i < 26; i++)\\n            if(mem[i]>0)\\n                cnt += mem[i];\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263254,
                "title": "python-one-liner-faster-than-98-99",
                "content": "\"\"\"\\nclass Solution:\\n\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum(abs(s.count(i)-t.count(i))for i in \"abcdefghijklmnopqrstuvwxyz\")//2\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\t#Please upvote if you like :))\\n",
                "solutionTags": [],
                "code": "\"\"\"\\nclass Solution:\\n\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum(abs(s.count(i)-t.count(i))for i in \"abcdefghijklmnopqrstuvwxyz\")//2\\n\\t\\t\\n\\t\\t\"\"\"\\n\\t\\t#Please upvote if you like :))\\n",
                "codeTag": "Java"
            },
            {
                "id": 1136176,
                "title": "python-beast-mode-solution-3-lines-easy",
                "content": "- In my opinon, this problem is more of a set theory problem\\n- First we use a counter on s and t\\n- The `|` operator performs a union between `s` and `t`\\n- The `&` operator performs the intersection between `s` and `t`\\n- When we subtract these two, we get the counts of characters that are different between `s` and `t`\\n- We can divide their counts by two, because when we replace one character it makes it equal to another character\\n\\n```python\\ndef minSteps(s, t):\\n    s, t = Counter(s), Counter(t)\\n    complement = (s | t) - (s & t)\\n    return sum(complement.values()) // 2\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef minSteps(s, t):\\n    s, t = Counter(s), Counter(t)\\n    complement = (s | t) - (s & t)\\n    return sum(complement.values()) // 2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1124573,
                "title": "c-linear-time-int-26-space-with-explanations",
                "content": "**Key points:**\\n* The title should have gave away the solution already.\\n* What can I say, it is a bit evil since it only covers 26 lower case English letters. But don\\'t blame me, it is in the constraints.\\n* Just keep counting 26 letters. Increase by one side decrease by the other side. Like two letter histograms overlaping and canceling each other.\\n* At the end, add up either all positive or all negative counts, it will give the difference.\\n```\\n  int minSteps(const string & s, const string & t) {\\n    int ct[26] {};\\n    for (int i=0; i<s.size(); ++i) {\\n      ++ct[s[i]-\\'a\\'];\\n      --ct[t[i]-\\'a\\'];\\n    }\\n    int ret = 0;\\n    for (int i=0; i<26; ++i)\\n      ret += (ct[i] > 0)?ct[i]:0;\\n    return ret;\\n  }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  int minSteps(const string & s, const string & t) {\\n    int ct[26] {};\\n    for (int i=0; i<s.size(); ++i) {\\n      ++ct[s[i]-\\'a\\'];\\n      --ct[t[i]-\\'a\\'];\\n    }\\n    int ret = 0;\\n    for (int i=0; i<26; ++i)\\n      ret += (ct[i] > 0)?ct[i]:0;\\n    return ret;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 966393,
                "title": "o-nlog-n-time-o-1-space-solution-with-sorting",
                "content": "While I agree that it\\'s pretty efficient to use the O (n) time and space solution, this provides another way to think about the problem using sorting. Alot of solutions claim O(1) space, while it is true under ascii, what if we have an infinite alphabet? This algorithm is more elegant and is  a true constant space solution, if you consider sorting in place.\\n\\nLet\\'s pretend that sorting is in place (heap sort is one such inplace method). The key to understanding this solution is that when strings are lexicographically sorted, and since we maintain ptrs starting at the beginning and incrementing the lexicographically lagging value pointed to by one of the pointers, we realize that when two values pointed to by pointers arent equal, there couldn\\'t have been values before that matches this value due to sorting. This allows us to count the number of pairs of swaps doubled. We return // 2 at the end.\\n\\n* note that the code is greatly expanded out for clarity\\n\\n```\\n    def minSteps(self, s: str, t: str) -> int:\\n        val = 0\\n        sl = sorted(s)\\n        tl = sorted(t)\\n        ptrs, ptrl = 0, 0\\n\\t\\t\\n        while(ptrs < len(s) or ptrl < len(t)):\\n            if (ptrs >= len(s) or ptrl >= len(t)):\\n                if (ptrs < len(s)):\\n                    ptrs += 1\\n                else:\\n                    ptrl += 1\\n                val += 1\\n            else:\\n                if (sl[ptrs] == tl[ptrl]):\\n                    ptrs += 1\\n                    ptrl += 1\\n                elif(sl[ptrs] < tl[ptrl]):\\n                    ptrs += 1\\n                    val += 1\\n                else:\\n                    ptrl += 1\\n                    val += 1\\n        return val // 2\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    def minSteps(self, s: str, t: str) -> int:\\n        val = 0\\n        sl = sorted(s)\\n        tl = sorted(t)\\n        ptrs, ptrl = 0, 0\\n\\t\\t\\n        while(ptrs < len(s) or ptrl < len(t)):\\n            if (ptrs >= len(s) or ptrl >= len(t)):\\n                if (ptrs < len(s)):\\n                    ptrs += 1\\n                else:\\n                    ptrl += 1\\n                val += 1\\n            else:\\n                if (sl[ptrs] == tl[ptrl]):\\n                    ptrs += 1\\n                    ptrl += 1\\n                elif(sl[ptrs] < tl[ptrl]):\\n                    ptrs += 1\\n                    val += 1\\n                else:\\n                    ptrl += 1\\n                    val += 1\\n        return val // 2\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 503485,
                "title": "python-easy-accepted-solution",
                "content": "Easy Solution or You can say Old school way:\\n```\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        if not s or not t:\\n            return 0\\n        count = 0\\n        dicT,dicS = {},{}\\n        for i in range(len(t)):\\n            if t[i] in dicT:\\n                dicT[t[i]] += 1\\n            else:\\n                dicT[t[i]] = 1\\n        for i in range(len(s)):\\n            if s[i] in dicS:\\n                dicS[s[i]] += 1\\n            else:\\n                dicS[s[i]] = 1\\n        print(dicS,dicT)\\n        for k,v in dicT.items():\\n            if k in dicS:\\n                if dicT[k] > dicS[k]:\\n                    count += abs(dicT[k]-dicS[k]\\n            else:\\n                count += dicT[k]\\n        return(count)\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n```\\n\\nHigh time to leverage libraries (Lol !), Thank you @JummyEgg\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        S = collections.Counter(s)\\n        T = collections.Counter(t)\\n        return sum((S-T).values())\\n```\\n\\nTo understand more on how for and Counter works, Please see in the comment section .\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minSteps(self, s, t):\\n        if not s or not t:\\n            return 0\\n        count = 0\\n        dicT,dicS = {},{}\\n        for i in range(len(t)):\\n            if t[i] in dicT:\\n                dicT[t[i]] += 1\\n            else:\\n                dicT[t[i]] = 1\\n        for i in range(len(s)):\\n            if s[i] in dicS:\\n                dicS[s[i]] += 1\\n            else:\\n                dicS[s[i]] = 1\\n        print(dicS,dicT)\\n        for k,v in dicT.items():\\n            if k in dicS:\\n                if dicT[k] > dicS[k]:\\n                    count += abs(dicT[k]-dicS[k]\\n            else:\\n                count += dicT[k]\\n        return(count)\\n        \"\"\"\\n        :type s: str\\n        :type t: str\\n        :rtype: int\\n        \"\"\"\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        S = collections.Counter(s)\\n        T = collections.Counter(t)\\n        return sum((S-T).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503448,
                "title": "java-python-char-count-array-o-n-m-time-o-1-space",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        int char_count[] = new int[26]; \\n\\n        for (int i = 0; i < s.length(); i++)  \\n            // Count all letters present in 1st string\\n            char_count[s.charAt(i) - \\'a\\']++;\\n\\n        for (int i = 0; i < t.length(); i++)  \\n            // Subtract all letters from the 1st string\\n            // If count becomes -ve, we need to modify this letter\\n            if (char_count[t.charAt(i) - \\'a\\']-- <= 0) \\n                count++; \\n\\n        return count;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count = 0\\n        char_count = [0] * 26\\n\\n        for i in range(len( s)):\\n            # Count all letters present in 1st string\\n            char_count[ord(s[i]) - ord(\\'a\\')] += 1\\n\\n        for i in range(len(t)):\\n            # Subtract all letters from the 1st string\\n            char_count[ord(t[i]) - ord(\\'a\\')] -= 1\\n            \\n            # If count becomes -ve, we need to modify this letter\\n            if (char_count[ord(t[i]) - ord(\\'a\\')] < 0) : \\n                count += 1\\n\\n        return count \\n```\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int count = 0;\\n        int char_count[] = new int[26]; \\n\\n        for (int i = 0; i < s.length(); i++)  \\n            // Count all letters present in 1st string\\n            char_count[s.charAt(i) - \\'a\\']++;\\n\\n        for (int i = 0; i < t.length(); i++)  \\n            // Subtract all letters from the 1st string\\n            // If count becomes -ve, we need to modify this letter\\n            if (char_count[t.charAt(i) - \\'a\\']-- <= 0) \\n                count++; \\n\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        count = 0\\n        char_count = [0] * 26\\n\\n        for i in range(len( s)):\\n            # Count all letters present in 1st string\\n            char_count[ord(s[i]) - ord(\\'a\\')] += 1\\n\\n        for i in range(len(t)):\\n            # Subtract all letters from the 1st string\\n            char_count[ord(t[i]) - ord(\\'a\\')] -= 1\\n            \\n            # If count becomes -ve, we need to modify this letter\\n            if (char_count[ord(t[i]) - ord(\\'a\\')] < 0) : \\n                count += 1\\n\\n        return count \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952857,
                "title": "easy-c-solution-using-hash-map-and-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n       unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n       }\\n       int count=0;\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minSteps(string s, string t) {\\n       unordered_map<char,int> mp;\\n       for(auto i:s)\\n       {\\n           mp[i]++;\\n       } \\n       for(auto i:t)\\n       {\\n           if(mp[i]>0)\\n           {\\n               mp[i]--;\\n           }\\n       }\\n       int count=0;\\n       for(auto i:mp)\\n       {\\n           count+=i.second;\\n       }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949830,
                "title": "unique-solution-well-explained-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Algorithm:\\n\\n1)Character Frequencies:\\n\\nInitialize two arrays or dictionaries to store the character frequencies for strings s and t.\\nTraverse through both strings and update the respective character frequencies.\\n2)Calculate Steps:\\n\\nInitialize a variable steps to keep track of the minimum number of steps.\\n\\nTraverse through the lowercase English alphabet characters (a-z).\\nFor each character, calculate the absolute difference in frequencies between s and t and add it to steps.\\nReturn Steps:\\n\\n3)Return the value of steps.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        map<char,int>mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\n        mp[t[i]]--;\\n        \\n        }\\n        int sum=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<0)\\n\\n\\n            //ABSOLUTE IS TAKEN KYUKI S MEIN SE T KO REMOVE KARTE TIME HO SAKTA HAI KI KUCH ELEMENTS KI FREQUENCY NEGATIVE HO JAYE \\n              sum+=abs(it.second);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        map<char,int>mp;\\n\\n        for(int i=0;i<s.size();i++)\\n        {\\n            mp[s[i]]++;\\n\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n\\n        mp[t[i]]--;\\n        \\n        }\\n        int sum=0;\\n        for(auto it:mp)\\n        {\\n            if(it.second<0)\\n\\n\\n            //ABSOLUTE IS TAKEN KYUKI S MEIN SE T KO REMOVE KARTE TIME HO SAKTA HAI KI KUCH ELEMENTS KI FREQUENCY NEGATIVE HO JAYE \\n              sum+=abs(it.second);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375813,
                "title": "return-sum-freq-difference-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int > a(26,0), b(26,0);\\n        \\n        \\n        for(auto i: s)\\n        {\\n            a[i-\\'a\\']++;\\n        }\\n        \\n        for(auto i: t)\\n        {\\n            b[i-\\'a\\']++;\\n        }\\n        \\n        int diff = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            diff+=abs(a[i]-b[i]);\\n        }\\n        \\n        return diff/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int > a(26,0), b(26,0);\\n        \\n        \\n        for(auto i: s)\\n        {\\n            a[i-\\'a\\']++;\\n        }\\n        \\n        for(auto i: t)\\n        {\\n            b[i-\\'a\\']++;\\n        }\\n        \\n        int diff = 0;\\n        for(int i=0;i<26;i++)\\n        {\\n            diff+=abs(a[i]-b[i]);\\n        }\\n        \\n        return diff/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309173,
                "title": "java-frequency-array",
                "content": "## Clean solution:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            sFreq[s.charAt(i) - \\'a\\']++;\\n            tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n\\n        int steps = 0;\\n        for (int i = 0; i < 26; i++) {\\n            int step = sFreq[i] - tFreq[i];\\n            if (step > 0) {\\n                steps += step;\\n            }\\n        }\\n\\n        return steps;\\n    }\\n}\\n```\\n\\n##### Time complexity: $$O(n + 26) => O(n)$$\\n##### Space complexity: $$O(26) => O(1)$$",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] sFreq = new int[26];\\n        int[] tFreq = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            sFreq[s.charAt(i) - \\'a\\']++;\\n            tFreq[t.charAt(i) - \\'a\\']++;\\n        }\\n\\n        int steps = 0;\\n        for (int i = 0; i < 26; i++) {\\n            int step = sFreq[i] - tFreq[i];\\n            if (step > 0) {\\n                steps += step;\\n            }\\n        }\\n\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235428,
                "title": "java-hashmaps-and-counting",
                "content": "\\n#### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n#### Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return 0;\\n        }\\n        \\n        Map<Character, Integer> freqs = new HashMap<>();\\n\\n        for (char c : s.toCharArray()) {\\n            freqs.put(c, freqs.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        int steps = 0;\\n        \\n        for (char c : t.toCharArray()) {\\n            if (freqs.containsKey(c) && freqs.get(c) > 0) {\\n                freqs.put(c, freqs.get(c) - 1);\\n            } else {\\n                steps++;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        if (s.length() != t.length()) {\\n            return 0;\\n        }\\n        \\n        Map<Character, Integer> freqs = new HashMap<>();\\n\\n        for (char c : s.toCharArray()) {\\n            freqs.put(c, freqs.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        int steps = 0;\\n        \\n        for (char c : t.toCharArray()) {\\n            if (freqs.containsKey(c) && freqs.get(c) > 0) {\\n                freqs.put(c, freqs.get(c) - 1);\\n            } else {\\n                steps++;\\n            }\\n        }\\n        \\n        return steps;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235360,
                "title": "simple-solution-using-c-beats-90-61",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++){\\n            str1[s[i]-\\'a\\']++;\\n            str2[t[i]-\\'a\\']++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int str1[26]={},str2[26]={};\\n        for(int i=0;i<s.size();i++){\\n            str1[s[i]-\\'a\\']++;\\n            str2[t[i]-\\'a\\']++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++) ans+=abs(str1[i]-str2[i]);\\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192014,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int ans = 0, n = s.size(), m = t.size();\\n        vector<int>v(26,0);\\n        for(int i = 0;i < n;i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i = 0;i < 26;i++)\\n            ans += abs(v[i]);\\n        return ans/2; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n       int ans = 0, n = s.size(), m = t.size();\\n        vector<int>v(26,0);\\n        for(int i = 0;i < n;i++)\\n        {\\n            v[s[i]-\\'a\\']++;\\n            v[t[i]-\\'a\\']--;\\n        }\\n        for(int i = 0;i < 26;i++)\\n            ans += abs(v[i]);\\n        return ans/2; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082404,
                "title": "c-solution-beats-99-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to find the minimum number of steps required to convert string s to string t. One possible approach is to count the number of occurrences of each character in both strings and then compare the counts. By counting the number of extra characters in one string and the number of missing characters in the other, we can determine how many steps are needed to make them equal.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the code is to create an array of counts for each character in the alphabet, initialized to 0. Then, for each character in string s, the count for that character is incremented. Next, for each character in string t, the count for that character is decremented. Finally, the absolute value of each count is taken and added together to get the total number of steps needed to convert s to t. The result is then divided by 2 because each step involves both adding and removing a character.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count[26] = {0};\\n        for (char c : s) {\\n            count[c - \\'a\\']++;\\n        }\\n        for (char c : t) {\\n            count[c - \\'a\\']--;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            res += abs(count[i]);\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count[26] = {0};\\n        for (char c : s) {\\n            count[c - \\'a\\']++;\\n        }\\n        for (char c : t) {\\n            count[c - \\'a\\']--;\\n        }\\n        int res = 0;\\n        for (int i = 0; i < 26; i++) {\\n            res += abs(count[i]);\\n        }\\n        return res / 2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972701,
                "title": "q1347-accepetd-c-used-hashmap-easy-simple-explained",
                "content": "CRUX\\n1) Frequency of both s & t \\n\\tleetcode- l 1,e 3,t 1,c 1,d 1,o 1\\n\\tpractice- p 1,r 1,a 1,c 2,t 1,i 1,e 1\\n2) Substact the frequency of  t with s and take the sum of positive values only\\nCorresponding Code is below :\\nPlease Upvote \\uD83E\\uDEF6\\uD83C\\uDFFB \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map <char,int> mp1;\\n        unordered_map <char,int> mp2;\\n        for(char i:s)\\n            mp1[i]++;\\n        for(char i:t)\\n            mp2[i]++;\\n        int change=0;\\n        for(auto i:mp2){\\n            if(i.second-mp1[i.first]>0)\\n                change+=i.second-mp1[i.first];\\n        }\\n        return change;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map <char,int> mp1;\\n        unordered_map <char,int> mp2;\\n        for(char i:s)\\n            mp1[i]++;\\n        for(char i:t)\\n            mp2[i]++;\\n        int change=0;\\n        for(auto i:mp2){\\n            if(i.second-mp1[i.first]>0)\\n                change+=i.second-mp1[i.first];\\n        }\\n        return change;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945228,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - length of string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ - constant 26 char array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] charArray = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            charArray[s.charAt(i) -\\'a\\']++;\\n            charArray[t.charAt(i) -\\'a\\']--;\\n        }\\n\\n        int steps = 0;\\n        for (int c : charArray) {\\n            if (c > 0) { // we only count +, since we only need the diff between s and t, not a count of absolutely every char\\n                steps += c;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] charArray = new int[26];\\n        for (int i = 0; i < s.length(); i++) {\\n            charArray[s.charAt(i) -\\'a\\']++;\\n            charArray[t.charAt(i) -\\'a\\']--;\\n        }\\n\\n        int steps = 0;\\n        for (int c : charArray) {\\n            if (c > 0) { // we only count +, since we only need the diff between s and t, not a count of absolutely every char\\n                steps += c;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814820,
                "title": "very-easy-one-liner-python-solution",
                "content": "\\n\\n# Approach\\nAdd the differences in the frequencies of characters in t and s.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((Counter(t)-Counter(s)).values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((Counter(t)-Counter(s)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719627,
                "title": "fundamental-approach-c-trick-hash-table",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int> umap;\\n        for(auto ch:s) umap[ch]++;\\n        for(auto ch:t) umap[ch]--;\\n        int sum = 0;\\n        for(auto it:umap) {\\n            sum +=abs(it.second);\\n        }\\n        return sum/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int> umap;\\n        for(auto ch:s) umap[ch]++;\\n        for(auto ch:t) umap[ch]--;\\n        int sum = 0;\\n        for(auto it:umap) {\\n            sum +=abs(it.second);\\n        }\\n        return sum/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709372,
                "title": "easy-short-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u found my Solution useful**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int minSteps=0;\\n        for(auto it:s)\\n            mp[it]++;\\n        for(auto it:t)\\n            mp[it]--;\\n        for(auto it:mp)\\n            minSteps+=abs(it.second);\\n        return minSteps/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        int minSteps=0;\\n        for(auto it:s)\\n            mp[it]++;\\n        for(auto it:t)\\n            mp[it]--;\\n        for(auto it:mp)\\n            minSteps+=abs(it.second);\\n        return minSteps/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664206,
                "title": "c-4-lines-only-hashmap-easiest-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        unordered_map<char,int>mpp;\\n        int cnt = 0;\\n\\n        for(auto &it:s) mpp[it]++;\\n\\n        for(auto &it:t) mpp[it]--;\\n            \\n        for(auto it: mpp) cnt += abs(it.second);\\n\\n        return cnt/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n\\n        unordered_map<char,int>mpp;\\n        int cnt = 0;\\n\\n        for(auto &it:s) mpp[it]++;\\n\\n        for(auto &it:t) mpp[it]--;\\n            \\n        for(auto it: mpp) cnt += abs(it.second);\\n\\n        return cnt/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657880,
                "title": "c-easy-solution-with-explanation",
                "content": "# Intuition\\nAs it is an anagram, we just need to know if there are any characters that string s has but t does not.\\n\\n# Approach\\nKeep a frequency tracker vector for the alphabets in string s and t. If the 3 a\\'s are present in string s, increment the counter as many times. But if two a\\'s are already present in string t, decrement the counter as we already have those. Now iterate through our frequency vector and see if there are alphabets that are present in s but not t, and add that value to final answer. \\nIt can happen that string t has 2 b\\'s but string s doesnt, meaning freq1[1]=-2. What do we do in that case? We dont care about it, as the operation is substitution and new characters will be added to there place. Hence the method max(freq1[i], 0).\\n\\n# Complexity\\n- Time complexity:\\nO(max(N, M)) where N and M are the length of strings s and t\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freq1(26, 0);\\n        for(char c:s)\\n            freq1[c-\\'a\\']++;\\n        for(char c:t)\\n            freq1[c-\\'a\\']--;\\n        int ans = 0;\\n        for(int i=0; i<26; i++)\\n        {\\n            ans+=max(freq1[i], 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> freq1(26, 0);\\n        for(char c:s)\\n            freq1[c-\\'a\\']++;\\n        for(char c:t)\\n            freq1[c-\\'a\\']--;\\n        int ans = 0;\\n        for(int i=0; i<26; i++)\\n        {\\n            ans+=max(freq1[i], 0);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463562,
                "title": "c-time-88-beats-space-99-99-beats-time-o-max-m-n-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string &s, string &t) {\\n        vector<int> v(26,0);\\n        for(auto &i: t){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: s){\\n            if(v[i-\\'a\\'] > 0){\\n                v[i-\\'a\\']--;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string &s, string &t) {\\n        vector<int> v(26,0);\\n        for(auto &i: t){\\n            v[i-\\'a\\']++;\\n        }\\n        for(auto &i: s){\\n            if(v[i-\\'a\\'] > 0){\\n                v[i-\\'a\\']--;\\n            }\\n        }\\n        int ans = 0;\\n        for(auto &i: v){\\n            ans += i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347354,
                "title": "java-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[26];\\n        \\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        int c = 0;\\n        for(char ch : t.toCharArray()){\\n            if(arr[ch-\\'a\\'] == 0) c++;\\n            else arr[ch-\\'a\\']--;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[26];\\n        \\n        for(char ch : s.toCharArray()){\\n            arr[ch-\\'a\\']++;\\n        }\\n        int c = 0;\\n        for(char ch : t.toCharArray()){\\n            if(arr[ch-\\'a\\'] == 0) c++;\\n            else arr[ch-\\'a\\']--;\\n        }\\n        \\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290057,
                "title": "78-tc-and-79-sc-easy-python-solution",
                "content": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n\\ts = Counter(s)\\n\\tt = Counter(t)\\n\\tans = 0\\n\\tfor i in t:\\n\\t\\tif(i not in s):\\n\\t\\t\\tans += t[i]\\n\\t\\telif(t[i] > s[i]):\\n\\t\\t\\tans += t[i]-s[i]\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n\\ts = Counter(s)\\n\\tt = Counter(t)\\n\\tans = 0\\n\\tfor i in t:\\n\\t\\tif(i not in s):\\n\\t\\t\\tans += t[i]\\n\\t\\telif(t[i] > s[i]):\\n\\t\\t\\tans += t[i]-s[i]\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2276760,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> sa(26,0);\\n        int n=s.size();\\n        for(auto i:s){\\n            sa[i-\\'a\\']++;\\n        }\\n        \\n        for(auto i:t){\\n            sa[i-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            if(sa[i]<0) ans=ans+sa[i];\\n        }\\n        return abs(ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> sa(26,0);\\n        int n=s.size();\\n        for(auto i:s){\\n            sa[i-\\'a\\']++;\\n        }\\n        \\n        for(auto i:t){\\n            sa[i-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++){\\n            if(sa[i]<0) ans=ans+sa[i];\\n        }\\n        return abs(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200413,
                "title": "simple-java-faster-than-92-o-n-time-o-1-space",
                "content": "```\\n    public int minSteps(String s, String t) {\\n\\t    // Use a 26-sized array to store the character frequency difference between s and t \\n        int[] alphabet = new int[26];\\n        for (int i=0; i<s.length(); i++) {\\n            alphabet[s.charAt(i) - \\'a\\']++;\\n            alphabet[t.charAt(i) - \\'a\\']--;\\n        }\\n\\t\\t// The sum of alphabet must be 0, \\n\\t\\t// we only need to count the absolute sum of either postives or negatives\\n        int res = 0;\\n        for (int i : alphabet) {\\n            if (i > 0) res += i;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int minSteps(String s, String t) {\\n\\t    // Use a 26-sized array to store the character frequency difference between s and t \\n        int[] alphabet = new int[26];\\n        for (int i=0; i<s.length(); i++) {\\n            alphabet[s.charAt(i) - \\'a\\']++;\\n            alphabet[t.charAt(i) - \\'a\\']--;\\n        }\\n\\t\\t// The sum of alphabet must be 0, \\n\\t\\t// we only need to count the absolute sum of either postives or negatives\\n        int res = 0;\\n        for (int i : alphabet) {\\n            if (i > 0) res += i;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127036,
                "title": "java-solution-faster-than-99-94-solution-without-hashmap-easy-solution",
                "content": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] > 0) ans += count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minSteps(String s, String t) {\\n        int count[] = new int[26];\\n\\n        for (char ch : s.toCharArray()) count[ch - \\'a\\']++;\\n        for (char ch : t.toCharArray()) count[ch - \\'a\\']--;\\n\\n        int ans = 0;\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] > 0) ans += count[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083167,
                "title": "python-one-liner-fastest",
                "content": "## Very simple \\nMight be in Easy **Categories**.\\n\\n```\\ndef minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        return sum((Counter(s) - Counter(t)).values())\\n```\\n\\nMuch appriciated **UpVote^**, if you find this helpful.\\n#### Comment below, if any suggestions or doubts.",
                "solutionTags": [],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        return sum((Counter(s) - Counter(t)).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2024761,
                "title": "python-simple-2-line-solution-faster-than-85",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        common_vals = sum((Counter(s) & Counter(t)).values())\\n        return len(s) - common_vals",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        common_vals = sum((Counter(s) & Counter(t)).values())\\n        return len(s) - common_vals",
                "codeTag": "Java"
            },
            {
                "id": 2016924,
                "title": "easy-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) \\n    {\\n        HashMap<Character,Integer> hmap1 = new HashMap<>();\\n        HashMap<Character,Integer> hmap2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hmap1.put(s.charAt(i),hmap1.getOrDefault(s.charAt(i),0)+1);\\n            hmap2.put(t.charAt(i),hmap2.getOrDefault(t.charAt(i),0)+1);\\n        }\\n        int count=0;\\n        for(char ch:hmap2.keySet())\\n        {\\n            if(!hmap1.containsKey(ch))\\n                count+=hmap2.get(ch);\\n            else\\n            {\\n                int a = hmap1.get(ch);\\n                int b = hmap2.get(ch);\\n                if(a<b)\\n                    count+=(b-a);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) \\n    {\\n        HashMap<Character,Integer> hmap1 = new HashMap<>();\\n        HashMap<Character,Integer> hmap2 = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            hmap1.put(s.charAt(i),hmap1.getOrDefault(s.charAt(i),0)+1);\\n            hmap2.put(t.charAt(i),hmap2.getOrDefault(t.charAt(i),0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1917806,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        map = {}\\n        for c in s:\\n            if c not in map:\\n                map[c] = 1\\n            else:\\n                map[c]+=1\\n        \\n        result = 0\\n        \\n        for c in t:\\n            if c not in map or map[c] == 0 :\\n                result+=1\\n            else:\\n                map[c]-=1\\n        \\n        return result\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        map = {}\\n        for c in s:\\n            if c not in map:\\n                map[c] = 1\\n            else:\\n                map[c]+=1\\n        \\n        result = 0\\n        \\n        for c in t:\\n            if c not in map or map[c] == 0 :\\n                result+=1\\n            else:\\n                map[c]-=1\\n        \\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1781964,
                "title": "simple-cpp-beginner-friendly-with-one-freq-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        //diamond notes\\n        //just make a hashmap and store all elements of s\\n        //and then traverse t and check if h[t[i]]==0 add 1 to answer else h[t[i]]--\\n        unordered_map<char,int>h,m;\\n        int ans=0;\\n        for(auto it:s)\\n        {\\n            h[it]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(h[t[i]]==0)\\n            {\\n                ans++;\\n            }else\\n            {\\n                h[t[i]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        //diamond notes\\n        //just make a hashmap and store all elements of s\\n        //and then traverse t and check if h[t[i]]==0 add 1 to answer else h[t[i]]--\\n        unordered_map<char,int>h,m;\\n        int ans=0;\\n        for(auto it:s)\\n        {\\n            h[it]++;\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(h[t[i]]==0)\\n            {\\n                ans++;\\n            }else\\n            {\\n                h[t[i]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712611,
                "title": "python3-dictionary-hash-table-easy-understanding",
                "content": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s, t = Counter(s), Counter(t)\\n        res = 0\\n        for i in t:\\n            if t[i] >= s[i]:\\n                res += t[i] - s[i]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        s, t = Counter(s), Counter(t)\\n        res = 0\\n        for i in t:\\n            if t[i] >= s[i]:\\n                res += t[i] - s[i]\\n        \\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1673516,
                "title": "c-easy-hashmap",
                "content": "**Upvote if you found solution useful**\\n```C++\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            m[t[i]]--;\\n        }\\n        int ans=0;\\n        for(auto x:m){\\n            if(x.second>0){\\n                ans+=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<int,int> m;\\n        for(int i=0;i<s.length();i++){\\n            m[s[i]]++;\\n            m[t[i]]--;\\n        }\\n        int ans=0;\\n        for(auto x:m){\\n            if(x.second>0){\\n                ans+=x.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672674,
                "title": "python-easy-to-understand-solution-with-comments-using-hashmap",
                "content": "\\tif s == t:\\n            return 0\\n        # If the two strings are equal then directly return 0\\n        # Forming 2 hashmaps here to get the frequency count of each element\\n        hashmap_s = {}\\n        hashmap_t = {}\\n        \\n        \\n        # Here I am entering the elements in the hashmap for the string s\\n        for i in range(len(s)):\\n            if s[i] in hashmap_s:\\n                hashmap_s[s[i]] += 1\\n            else:\\n                hashmap_s[s[i]] = 1\\n                \\n         # Here I am entering the elements in the hashmap for the string s\\n        for i in range(len(t)):\\n            if t[i] in hashmap_t:\\n                hashmap_t[t[i]] += 1\\n            else:\\n                hashmap_t[t[i]] = 1\\n        \\n        # This loop will compare the elements of string s with the hashmap_t and will add if any element is not in hashmap_t which is to be found in string s. It will give a frequency count of 0\\n        for i in range(len(s)):\\n            if s[i] not in hashmap_t:\\n                hashmap_t[s[i]] = 0\\n        \\n        # Same for the hashmap_s\\n        for i in range(len(t)):\\n            if t[i] not in hashmap_s:\\n                hashmap_s[t[i]] = 0\\n\\n        \\n\\n        count = 0 # Initializing the count to 0\\n        for key,value in hashmap_s.items(): # Looping through the key and value pair of hashmap_S\\n            count += abs(hashmap_s[key] - hashmap_t[key]) # We will increment the count to the difference between the values of the respective keys of both the hashmaps.\\n        \\n        # We just need to make one string as an anagram and our number of moves will be double that of the actual moves because there are two hashmaps. hencet we return count // 2(half of the moves)\\n        return count //2",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tif s == t:\\n            return 0\\n        # If the two strings are equal then directly return 0\\n        # Forming 2 hashmaps here to get the frequency count of each element\\n        hashmap_s = {}\\n        hashmap_t = {}\\n        \\n        \\n        # Here I am entering the elements in the hashmap for the string s\\n        for i in range(len(s)):\\n            if s[i] in hashmap_s:\\n                hashmap_s[s[i]] += 1\\n            else:\\n                hashmap_s[s[i]] = 1\\n                \\n         # Here I am entering the elements in the hashmap for the string s\\n        for i in range(len(t)):\\n            if t[i] in hashmap_t:\\n                hashmap_t[t[i]] += 1\\n            else:\\n                hashmap_t[t[i]] = 1\\n        \\n        # This loop will compare the elements of string s with the hashmap_t and will add if any element is not in hashmap_t which is to be found in string s. It will give a frequency count of 0\\n        for i in range(len(s)):\\n            if s[i] not in hashmap_t:\\n                hashmap_t[s[i]] = 0\\n        \\n        # Same for the hashmap_s\\n        for i in range(len(t)):\\n            if t[i] not in hashmap_s:\\n                hashmap_s[t[i]] = 0\\n\\n        \\n\\n        count = 0 # Initializing the count to 0\\n        for key,value in hashmap_s.items(): # Looping through the key and value pair of hashmap_S\\n            count += abs(hashmap_s[key] - hashmap_t[key]) # We will increment the count to the difference between the values of the respective keys of both the hashmaps.\\n        \\n        # We just need to make one string as an anagram and our number of moves will be double that of the actual moves because there are two hashmaps. hencet we return count // 2(half of the moves)\\n        return count //2",
                "codeTag": "Unknown"
            },
            {
                "id": 1562961,
                "title": "java-o-n-maps",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch =s.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n                freq++;\\n                hm.put(ch,freq);\\n            }\\n            else{\\n                hm.put(ch,1);\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        for(int i =0;i<t.length();i++){\\n            char ch =t.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n                freq--;\\n                hm.put(ch,freq);\\n            }\\n            \\n        }\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch =s.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n               \\n               if(freq>0){\\n                   count+=freq; \\n                    freq=0;\\n                }\\n                hm.put(ch,freq);\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> hm=new HashMap<>();\\n        for(int i =0;i<s.length();i++){\\n            char ch =s.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n                freq++;\\n                hm.put(ch,freq);\\n            }\\n            else{\\n                hm.put(ch,1);\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        for(int i =0;i<t.length();i++){\\n            char ch =t.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n                freq--;\\n                hm.put(ch,freq);\\n            }\\n            \\n        }\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch =s.charAt(i);\\n            if(hm.containsKey(ch)){\\n                int freq=hm.get(ch);\\n               \\n               if(freq>0){\\n                   count+=freq; \\n                    freq=0;\\n                }\\n                hm.put(ch,freq);\\n            }\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499658,
                "title": "c-easy-solution",
                "content": "class Solution\\n{\\npublic:\\n\\n    int minSteps(string s, string t)\\n    {\\n        map<char, int> map;\\n        vector<int> v;\\n\\n        for (auto i : s)\\n        {\\n            map[i]++;\\n        }\\n\\n        for (auto i : t)\\n        {\\n            map[i]--;\\n        }\\n\\n        for (auto j : map)\\n        {\\n            if (j.second > 0)\\n            {\\n                v.push_back(j.second);\\n            }\\n        }\\n        return accumulate(v.begin(), v.end(), 0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n\\n    int minSteps(string s, string t)\\n    {\\n        map<char, int> map;\\n        vector<int> v;\\n\\n        for (auto i : s)\\n        {\\n            map[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1382483,
                "title": "java-o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] h = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            h[s.charAt(i)-\\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int i=0;i<t.length();i++){\\n            if(h[t.charAt(i)-\\'a\\']>0){\\n                h[t.charAt(i)-\\'a\\']--;   \\n            }\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(h[i]>0){\\n                count+=h[i];\\n            }    \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] h = new int[26];\\n        for(int i=0;i<s.length();i++){\\n            h[s.charAt(i)-\\'a\\']++;\\n        }\\n        int count = 0;\\n        for(int i=0;i<t.length();i++){\\n            if(h[t.charAt(i)-\\'a\\']>0){\\n                h[t.charAt(i)-\\'a\\']--;   \\n            }\\n        }\\n        \\n        for(int i=0;i<26;i++){\\n            if(h[i]>0){\\n                count+=h[i];\\n            }    \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373111,
                "title": "python-for-beginners",
                "content": "\\tclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        c1=Counter(s)\\n        c2=Counter(t)\\n        ans=0\\n        for letter,freq in c1.items():\\n            if letter in c2.keys():\\n                ans=ans+abs(c2[letter]-freq)\\n            else:\\n                ans=ans+freq\\n        for letter,freq in c2.items():\\n            if letter not in c1.keys():\\n                ans=ans+freq\\n        return ans//2",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        c1=Counter(s)\\n        c2=Counter(t)\\n        ans=0\\n        for letter,freq in c1.items():\\n            if letter in c2.keys():\\n                ans=ans+abs(c2[letter]-freq)\\n            else:\\n                ans=ans+freq\\n        for letter,freq in c2.items():\\n            if letter not in c1.keys():\\n                ans=ans+freq\\n        return ans//2",
                "codeTag": "Java"
            },
            {
                "id": 1284650,
                "title": "java-hashmap-comments-clear-explanation",
                "content": "```\\n\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character, Integer> map_s = new HashMap<>();\\n        HashMap<Character, Integer> map_t = new HashMap<>();\\n        \\n        for(char ch : s.toCharArray()) \\n            map_s.put(ch, map_s.getOrDefault(ch, 0)+1);\\n        \\n        for(char ch : t.toCharArray()) \\n            map_t.put(ch, map_t.getOrDefault(ch, 0)+1);\\n        \\n        int result = 0;\\n        for(char ch : map_t.keySet()) {\\n            if(map_s.get(ch) == null) result+=map_t.get(ch); // if character in string t is not in string s, we need to replace those all characters\\n            else if(map_s.get(ch) < map_t.get(ch)) result+=(map_t.get(ch) - map_s.get(ch)); // if # of characters in string t are more, we need to replace those extra characters.\\n           // else => freq is same, no replacement is required.\\n        }\\n        return result;\\n    }\\n}\\n\\n```\\n\\nTC: O(N)\\nSC: O(N)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character, Integer> map_s = new HashMap<>();\\n        HashMap<Character, Integer> map_t = new HashMap<>();\\n        \\n        for(char ch : s.toCharArray()) \\n            map_s.put(ch, map_s.getOrDefault(ch, 0)+1);\\n        \\n        for(char ch : t.toCharArray()) \\n            map_t.put(ch, map_t.getOrDefault(ch, 0)+1);\\n        \\n        int result = 0;\\n        for(char ch : map_t.keySet()) {\\n            if(map_s.get(ch) == null) result+=map_t.get(ch); // if character in string t is not in string s, we need to replace those all characters\\n            else if(map_s.get(ch) < map_t.get(ch)) result+=(map_t.get(ch) - map_s.get(ch)); // if # of characters in string t are more, we need to replace those extra characters.\\n           // else => freq is same, no replacement is required.\\n        }\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169804,
                "title": "python-one-liner",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\n        return sum((Counter(s) - Counter(t)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\n        return sum((Counter(s) - Counter(t)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007660,
                "title": "easy-clear-solution-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n    }\\n    int minSteps(string s, string t) {\\n        vector<int>ms(26,0);\\n        int res=0;\\n        for(char x:s)ms[x-\\'a\\']++;\\n        for(char x:t)ms[x-\\'a\\']--;\\n        for(auto x:ms){\\n            if(x>0){\\n                res+=x;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(){\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n    }\\n    int minSteps(string s, string t) {\\n        vector<int>ms(26,0);\\n        int res=0;\\n        for(char x:s)ms[x-\\'a\\']++;\\n        for(char x:t)ms[x-\\'a\\']--;\\n        for(auto x:ms){\\n            if(x>0){\\n                res+=x;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 994276,
                "title": "easy-python-simple-one-liner-damn-easy-99-faster",
                "content": "```\\nsum((Counter(s)-Counter(t)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nsum((Counter(s)-Counter(t)).values())\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 981846,
                "title": "easy-to-understand-java-solution-with-explanation",
                "content": "The main idea for this solution is,\\n\\nThere are two arrays that hold the number of occurrences of a letter, then there is a sum which is the returned value.\\n\\nThe first loop is for putting all of the letters occurrences into the arrays. The `s.charAt(i) - 97` is for getting the position of the character. Since the ascii of `\\'a\\'` is `97` we can find the letter\\'s position. An example could be the letter `b`. `b` is `98` in the ascii table, so when we subtract `97` from `98` we get `1`, which is the position in the array where we put the occurence.\\n\\nThe second loop is for adding the number of occurrences that aren\\'t equal. The `Math.abs(first[i] - second[i]);` is for getting the difference of the number of occurrences, which intern tells us the number of extra characters that are not same, so we add that to the result of numbers that need to be changed.\\n\\n```\\npublic int minSteps(String s, String t) {\\n\\tint[] first = new int[26];\\n\\tint[] second = new int[26];\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tfirst[s.charAt(i) - 97] += 1;\\n\\t\\tsecond[t.charAt(i) - 97] += 1;\\n\\t}\\n\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tsum += Math.abs(first[i] - second[i]);\\n\\t}\\n\\treturn sum / 2;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minSteps(String s, String t) {\\n\\tint[] first = new int[26];\\n\\tint[] second = new int[26];\\n\\tint sum = 0;\\n\\tfor (int i = 0; i < s.length(); i++) {\\n\\t\\tfirst[s.charAt(i) - 97] += 1;\\n\\t\\tsecond[t.charAt(i) - 97] += 1;\\n\\t}\\n\\n\\tfor (int i = 0; i < 26; i++) {\\n\\t\\tsum += Math.abs(first[i] - second[i]);\\n\\t}\\n\\treturn sum / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 883174,
                "title": "javascript-easy-solution",
                "content": "```\\nvar minSteps = function(s, t) {\\n    let map = {}\\n    let count = 0;\\n    for (let char of s) {\\n        map[char] = ++map[char] || 1\\n    }\\n    for (let word of t) {\\n        if (map[word]) {\\n            map[word]--;\\n            continue;\\n        }\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minSteps = function(s, t) {\\n    let map = {}\\n    let count = 0;\\n    for (let char of s) {\\n        map[char] = ++map[char] || 1\\n    }\\n    for (let word of t) {\\n        if (map[word]) {\\n            map[word]--;\\n            continue;\\n        }\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867570,
                "title": "java-java8-clean-code",
                "content": "```Java\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, 0);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }\\n        return Arrays.stream(arr).filter(e -> e > 0).sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arr = new int[26];\\n        Arrays.fill(arr, 0);\\n        \\n        for (int i = 0; i < s.length(); i++) {\\n            arr[s.charAt(i) - \\'a\\']++;\\n            arr[t.charAt(i) - \\'a\\']--;\\n        }\\n        return Arrays.stream(arr).filter(e -> e > 0).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856241,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] letter1 = new int[26];\\n        int[] letter2 = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            letter1[c1 - \\'a\\']++;\\n            letter2[c2 - \\'a\\']++;\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            cnt += Math.abs(letter1[i] - letter2[i]);\\n        }\\n        return cnt / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] letter1 = new int[26];\\n        int[] letter2 = new int[26];\\n        for (int i = 0; i < s.length(); ++i) {\\n            char c1 = s.charAt(i);\\n            char c2 = t.charAt(i);\\n            letter1[c1 - \\'a\\']++;\\n            letter2[c2 - \\'a\\']++;\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < 26; ++i) {\\n            cnt += Math.abs(letter1[i] - letter2[i]);\\n        }\\n        return cnt / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812576,
                "title": "easy-c-solution-using-just-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0};\\n        int count=0;\\n       for(auto i:s)\\n       {\\n           a[i-\\'a\\']++;\\n       }\\n        for(auto i:t)\\n        {\\n            if(a[i-\\'a\\']<=0)\\n            {\\n                count++;\\n            }\\n            else{\\n                a[i-\\'a\\']--;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int a[26]={0}",
                "codeTag": "Java"
            },
            {
                "id": 784440,
                "title": "java-solution-o-n-with-map",
                "content": "class Solution {\\n    public int minSteps(String s, String t) {\\n\\t\\n        Map<Character, Integer> map = new HashMap();\\n        for(char c: s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }\\n        int steps = 0;\\n        for(char c: t.toCharArray()) {\\n            if(map.containsKey(c) && map.get(c) > 0) {\\n                 map.put(c, map.getOrDefault(c, 0) - 1);\\n                continue;\\n            }\\n            else {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n\\t\\n        Map<Character, Integer> map = new HashMap();\\n        for(char c: s.toCharArray()) {\\n            map.put(c, map.getOrDefault(c, 0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 746202,
                "title": "swift-simple-hashmap",
                "content": "```\\n final class Solution {\\n    func minSteps(_ s: String, _ t: String) -> Int {\\n        var has = [Character: Int]()\\n        for char in s {\\n            has[char, default: 0] += 1\\n        }\\n        for char in t {\\n            has[char, default: 0] -= 1\\n        }\\n        let val =  has.values.filter { $0 <= 0 }.reduce(0, { (resu, val) in\\n            return resu + val\\n        })\\n        return abs(val)\\n    }\\n }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n final class Solution {\\n    func minSteps(_ s: String, _ t: String) -> Int {\\n        var has = [Character: Int]()\\n        for char in s {\\n            has[char, default: 0] += 1\\n        }\\n        for char in t {\\n            has[char, default: 0] -= 1\\n        }\\n        let val =  has.values.filter { $0 <= 0 }.reduce(0, { (resu, val) in\\n            return resu + val\\n        })\\n        return abs(val)\\n    }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669207,
                "title": "c-using-count-array-of-size-26",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t)\\n    {\\n        int a[26]{0};\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s[i] - \\'a\\']++;\\n            a[t[i] - \\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i] < 0)\\n                ans+=abs(a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t)\\n    {\\n        int a[26]{0};\\n        for(int i=0;i<s.length();i++)\\n        {\\n            a[s[i] - \\'a\\']++;\\n            a[t[i] - \\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i] < 0)\\n                ans+=abs(a[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661144,
                "title": "java-solution-based-on-buckets",
                "content": "```\\npublic int minSteps(String s, String t) {\\n        int[] bucket = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            bucket[ch - \\'a\\']++;\\n        }\\n        for (char ch : t.toCharArray()) {\\n            if (bucket[ch - \\'a\\'] > 0) {\\n                bucket[ch - \\'a\\']--;\\n            }\\n        }\\n        int count = 0;\\n        for (int i : bucket) {\\n            count += i;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSteps(String s, String t) {\\n        int[] bucket = new int[26];\\n        for (char ch : s.toCharArray()) {\\n            bucket[ch - \\'a\\']++;\\n        }\\n        for (char ch : t.toCharArray()) {\\n            if (bucket[ch - \\'a\\'] > 0) {\\n                bucket[ch - \\'a\\']--;\\n            }\\n        }\\n        int count = 0;\\n        for (int i : bucket) {\\n            count += i;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630524,
                "title": "really-easy-just-count-occurences-in-map-c-easy-implementation",
                "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        if(s.length()!=t.length())\\n            return 0;\\n        map<char,int> m1;\\n        for(int i=0;i<t.length();i++)\\n        m1[t[i]]+=1;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1[s[i]]==0)\\n                count++;\\n            else\\n                m1[s[i]]--;\\n        }\\n        return count;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        if(s.length()!=t.length())\\n            return 0;\\n        map<char,int> m1;\\n        for(int i=0;i<t.length();i++)\\n        m1[t[i]]+=1;\\n        int count=0;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(m1[s[i]]==0)\\n                count++;\\n            else\\n                m1[s[i]]--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 572912,
                "title": "swift-o-n-with-explanation",
                "content": "```\\nclass Solution {\\n    func minSteps(_ s: String, _ t: String) -> Int {\\n        var sCountMap = [Character:Int]() \\n        var tCountMap = [Character:Int]()\\n        \\n\\t\\t// Count a number of each character appearance in s\\n        for c in s{\\n            sCountMap[c, default:0] += 1\\n        }\\n\\t\\t// Count a number of each character appearance in t\\n        for c in t{\\n            tCountMap[c, default:0] += 1\\n        }\\n        \\n\\t\\t// Subtract each s\\' character apperance from tCountMap.\\n        for key in sCountMap.keys{\\n            tCountMap[key, default:0] -= sCountMap[key]! \\n        }\\n        \\n\\t\\t// At this point, positive count in tCountMap means t has some characters appeared more than s.\\n\\t\\t// Image we have given s=\"aba\" t= \"bab\", to become anaglams, t needs to change one of \"b\"s to \"a\".\\n\\t\\t// In our tCountMap after the subtraction, we have tCountMap as {a: -1, b: 1}.\\n\\t\\t// The key observation here is that if t is lacking some characters by N, \\n\\t\\t// then there must be some other character or characters appeared more than s by N. \\n\\t\\t// Therefore, to count a number of character that needs to be changed in order for t to become anaglam of s, \\n\\t\\t// we needs to sum all the positive counts in tCountMap.\\n        var result = 0\\n        for key in tCountMap.keys{\\n            result += tCountMap[key]! >= 0 ? tCountMap[key]! : 0\\n        }\\n\\t\\t\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minSteps(_ s: String, _ t: String) -> Int {\\n        var sCountMap = [Character:Int]() \\n        var tCountMap = [Character:Int]()\\n        \\n\\t\\t// Count a number of each character appearance in s\\n        for c in s{\\n            sCountMap[c, default:0] += 1\\n        }\\n\\t\\t// Count a number of each character appearance in t\\n        for c in t{\\n            tCountMap[c, default:0] += 1\\n        }\\n        \\n\\t\\t// Subtract each s\\' character apperance from tCountMap.\\n        for key in sCountMap.keys{\\n            tCountMap[key, default:0] -= sCountMap[key]! \\n        }\\n        \\n\\t\\t// At this point, positive count in tCountMap means t has some characters appeared more than s.\\n\\t\\t// Image we have given s=\"aba\" t= \"bab\", to become anaglams, t needs to change one of \"b\"s to \"a\".\\n\\t\\t// In our tCountMap after the subtraction, we have tCountMap as {a: -1, b: 1}.\\n\\t\\t// The key observation here is that if t is lacking some characters by N, \\n\\t\\t// then there must be some other character or characters appeared more than s by N. \\n\\t\\t// Therefore, to count a number of character that needs to be changed in order for t to become anaglam of s, \\n\\t\\t// we needs to sum all the positive counts in tCountMap.\\n        var result = 0\\n        for key in tCountMap.keys{\\n            result += tCountMap[key]! >= 0 ? tCountMap[key]! : 0\\n        }\\n\\t\\t\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520703,
                "title": "c-24-ms-99-solution-w-explanation",
                "content": "The idea is to first calculate the \"discrepancy\" between the two strings, in terms of *letter count*. The goal is not to make the strings equal, but to make their anagrams equal, so as long as they have the same number of each letter then their anagrams are equal.\\n\\nOnce we calculate the discrepency, notice that swapping a letter will fix **2** instances of discrepancy.\\n\\nBecause the two strings are the same size, if one string has `n` extra letters, then it must also be missing `n` other letters from the other string. This means that if we take an extra letter in first string and make it into a missing letter in second string, then the *both* strings will have 1 less discrepancy, and thus the total discrepancy decreases by 2. Thus, every swap decreases discrepancy by 2.\\n\\nNotice that the number of total discrepancy is always even, because extra in 1 string implies missing in the other, so the discrepancies always come in pairs. \\n\\nBased on analysis all we need to do now is to calculate total discrepancy, then divide that by 2 to get the number of swaps needed.\\n\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        size_t size = s.size();\\n        vector<int> f(26, 0);\\n        for(int i = 0; i < size; ++i) {\\n            ++f[s[i]-\\'a\\'];\\n            --f[t[i]-\\'a\\'];\\n        }\\n        return accumulate(f.begin(), f.end(), 0, [](const int& a, const int &b) {return a + abs(b);})/2;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        size_t size = s.size();\\n        vector<int> f(26, 0);\\n        for(int i = 0; i < size; ++i) {\\n            ++f[s[i]-\\'a\\'];\\n            --f[t[i]-\\'a\\'];\\n        }\\n        return accumulate(f.begin(), f.end(), 0, [](const int& a, const int &b) {return a + abs(b);})/2;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 518068,
                "title": "concise-and-easy-understanding-java-solution-100-100",
                "content": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] jaja = new int[128];\\n        int ans = 0;\\n        \\n        for (char c: s.toCharArray()) {\\n            jaja[c]++;\\n        }\\n\\n        for (char c: t.toCharArray()) {\\n            jaja[c]--;\\n        }\\n        \\n        for (int i = 0; i < jaja.length; ++i) {\\n            if (jaja[i] != 0) {\\n                ans += Math.abs(jaja[i]);\\n            }\\n        }\\n        \\n        return ans / 2;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int[] jaja = new int[128];\\n        int ans = 0;\\n        \\n        for (char c: s.toCharArray()) {\\n            jaja[c]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 510470,
                "title": "java-count-chars-linear-explained",
                "content": "\\nWe need to count chars that are different between strings, those needs to be changed. We count every char in s first, then scan t and decrement counts of the same chars. Every time count goes below 0 it means that some other char is missing, so we add one to result.\\n\\nO(n) - scan s and t which are of the same length. O(1) space - need constant size array to count different chars.\\n\\n```\\n    public int minSteps(String s, String t) {\\n        int[] count = new int[128];\\n        for (char ch : s.toCharArray()) ++count[ch];\\n        int res = 0;\\n        for (char ch : t.toCharArray()) {\\n            if (count[ch] <= 0)\\n                ++res;\\n            else --count[ch];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int minSteps(String s, String t) {\\n        int[] count = new int[128];\\n        for (char ch : s.toCharArray()) ++count[ch];\\n        int res = 0;\\n        for (char ch : t.toCharArray()) {\\n            if (count[ch] <= 0)\\n                ++res;\\n            else --count[ch];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506902,
                "title": "python3-1-liner",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((collections.Counter(s) - collections.Counter(t)).values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        return sum((collections.Counter(s) - collections.Counter(t)).values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505989,
                "title": "python-o-n-sol-by-letter-counting-with-explanation",
                "content": "Python O( n ) sol. by letter counting\\n\\n---\\n\\nAlgorithm:\\n\\nStep_#1:\\nBuild two **dictionaries** for s and t, with **letter as key**, **occurrence as value**\\n\\nStep_#2:\\nScan from \\'a\\' to \\'z\\', count the **occurrence of letters**,\\nin order to compute **minimal distance to anagram**.\\n\\n---\\n\\nNote:\\n1. Each character **modification** will contribute one **+1 for dest letter**, **-1** to **src letter**.\\nTherefore, the total occurrence difference divides 2 is the minimal distance to anagram.\\n\\n2. the \\'//\\' is the integer division operator in python.\\n\\n---\\n\\nExample:\\ns = bab => { \\'a\\':1 , \\'b\\':2 }\\nt = aba => { \\'a\\':2 , \\'b\\':1 }\\n\\ntotal occurrence difference = |-1| + |1| = 1 + 1 = 2\\nminimal distance to anagram = 2 // 2 = 1 \\n\\nt is anagram of s by changing t = **a**ba to t\\' = **b**ba\\n\\n\\n---\\n\\n\\n```\\nfrom collections import defaultdict\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        # dictionary\\n        # key   : alphabet letter\\n        # value : occurrence\\n        s_occ_dict = defaultdict( int )\\n        t_occ_dict = defaultdict( int )\\n        \\n        # build the dictionary for input string s\\n        for ch in s:\\n            s_occ_dict[ch] += 1\\n        \\n        # build the dictionary for input string t\\n        for ch in t:\\n            t_occ_dict[ch] += 1\\n        \\n        \\n        # counting the minimum distance to anagram \\n        diff = 0\\n        \\n        for ch in ascii_lowercase:\\n            \\n            diff += abs(s_occ_dict[ch] - t_occ_dict[ch])\\n            \\n        return diff//2\\n            \\n```\\n\\n---\\n\\nReference:\\n[1] [Python official docs about integer division: // operator](https://docs.python.org/3/library/stdtypes.html?highlight=integer%20division#numeric-types-int-float-complex)\\n\\n[2] [Python official docs about string.ascii_lowercase](https://docs.python.org/3/library/string.html?highlight=ascii_lowercase#string.ascii_lowercase)\\n\\n[3] [Python official docs about defaultdict()](https://docs.python.org/3/library/collections.html?highlight=defaultdict#collections.defaultdict)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom string import ascii_lowercase\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        # dictionary\\n        # key   : alphabet letter\\n        # value : occurrence\\n        s_occ_dict = defaultdict( int )\\n        t_occ_dict = defaultdict( int )\\n        \\n        # build the dictionary for input string s\\n        for ch in s:\\n            s_occ_dict[ch] += 1\\n        \\n        # build the dictionary for input string t\\n        for ch in t:\\n            t_occ_dict[ch] += 1\\n        \\n        \\n        # counting the minimum distance to anagram \\n        diff = 0\\n        \\n        for ch in ascii_lowercase:\\n            \\n            diff += abs(s_occ_dict[ch] - t_occ_dict[ch])\\n            \\n        return diff//2\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 505561,
                "title": "javascript-solution",
                "content": "```\\nlet minSteps = function(s, t) {\\n    let balanceMap = {},\\n        result = 0\\n    for (let i = 0; i < s.length; i++) {\\n        let currentS = s[i],\\n            currentT = t[i]\\n        balanceMap[currentS] ? balanceMap[currentS] ++ : balanceMap[currentS] = 1\\n        balanceMap[currentT] ? balanceMap[currentT] -- : balanceMap[currentT] = -1\\n    }\\n    for (let k of Object.values(balanceMap)) {\\n        result += Math.abs(k)\\n    }\\n    return result / 2\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet minSteps = function(s, t) {\\n    let balanceMap = {},\\n        result = 0\\n    for (let i = 0; i < s.length; i++) {\\n        let currentS = s[i],\\n            currentT = t[i]\\n        balanceMap[currentS] ? balanceMap[currentS] ++ : balanceMap[currentS] = 1\\n        balanceMap[currentT] ? balanceMap[currentT] -- : balanceMap[currentT] = -1\\n    }\\n    for (let k of Object.values(balanceMap)) {\\n        result += Math.abs(k)\\n    }\\n    return result / 2\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 504044,
                "title": "javascript-count-just-one-string",
                "content": "1. Count letters from string s only and store them in a map.\\n2. Loop through string t and check each letter: if letter not found in the map or letter count is 0 increment counter otherwise decrease the counter.\\n\\n\\n```\\nvar minSteps = function(s, t) {\\n    const smap = {};\\n    for (let i = 0; i < s.length; i++) {\\n        smap[s[i]] = 1 + (smap[s[i]] || 0);\\n    }\\n\\n    let count = 0;\\n    for (let i = 0; i < t.length; i++) {\\n        if (!smap[t[i]])count++;\\n        else smap[t[i]] = smap[t[i]] - 1;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minSteps = function(s, t) {\\n    const smap = {};\\n    for (let i = 0; i < s.length; i++) {\\n        smap[s[i]] = 1 + (smap[s[i]] || 0);\\n    }\\n\\n    let count = 0;\\n    for (let i = 0; i < t.length; i++) {\\n        if (!smap[t[i]])count++;\\n        else smap[t[i]] = smap[t[i]] - 1;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503699,
                "title": "1-line-fast-python",
                "content": "In Python, counting characters in strings is incredibly fast (compared to other Python code). This got accepted in 80 ms.\\n```\\ndef minSteps(self, s, t):\\n    return sum(max(s.count(c) - t.count(c), 0) for c in set(s))\\n```\\nThis one takes about 108 ms:\\n```\\ndef minSteps(self, s, t):\\n    s, t = map(collections.Counter, (s, t))\\n    return sum((s - t).values())\\n```",
                "solutionTags": [],
                "code": "```\\ndef minSteps(self, s, t):\\n    return sum(max(s.count(c) - t.count(c), 0) for c in set(s))\\n```\n```\\ndef minSteps(self, s, t):\\n    s, t = map(collections.Counter, (s, t))\\n    return sum((s - t).values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4007675,
                "title": "best-solution-using-map-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        long count = 0;\\n        if(s == t) {\\n            return 0;\\n        }\\n        map<char, int> mp1;\\n        for(auto i : s) {\\n            mp1[i]++;\\n        }\\n        map<char, int> mp2;\\n        for(auto i : t) {\\n            mp2[i]++;\\n        }\\n        int a;\\n        for (auto i : mp1) {\\n            if(mp2.find(i.first) != mp2.end()) {\\n                if(i.second > mp2[i.first]) {\\n                    a = i.second - mp2[i.first];\\n                }\\n                else {\\n                    continue;\\n                }\\n            }\\n            else {\\n                a = i.second;\\n            }\\n            count += a;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        long count = 0;\\n        if(s == t) {\\n            return 0;\\n        }\\n        map<char, int> mp1;\\n        for(auto i : s) {\\n            mp1[i]++;\\n        }\\n        map<char, int> mp2;\\n        for(auto i : t) {\\n            mp2[i]++;\\n        }\\n        int a;\\n        for (auto i : mp1) {\\n            if(mp2.find(i.first) != mp2.end()) {\\n                if(i.second > mp2[i.first]) {\\n                    a = i.second - mp2[i.first];\\n                }\\n                else {\\n                    continue;\\n                }\\n            }\\n            else {\\n                a = i.second;\\n            }\\n            count += a;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3951490,
                "title": "java-easy-solution-6ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere i have use hash map concept\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        if(s.length()!=t.length()) return 0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char ch=t.charAt(i);\\n           if(map.containsKey(ch) && map.get(ch)>0){\\n               map.put(ch,map.get(ch)-1);\\n            \\n            }\\n            else{\\n                count++;\\n            }\\n           }\\n           return count;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character,Integer> map=new HashMap<>();\\n        if(s.length()!=t.length()) return 0;\\n        int count=0;\\n        for(int i=0;i<s.length();i++){\\n            map.put(s.charAt(i),map.getOrDefault(s.charAt(i),0)+1);\\n        }\\n        for(int i=0;i<t.length();i++){\\n            char ch=t.charAt(i);\\n           if(map.containsKey(ch) && map.get(ch)>0){\\n               map.put(ch,map.get(ch)-1);\\n            \\n            }\\n            else{\\n                count++;\\n            }\\n           }\\n           return count;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3824288,
                "title": "java-simple-solution-100-faster-with-explanation",
                "content": "# Approach\\nThe approach used in the given solution is quite clear and straightforward. Let\\'s break it down step-by-step:\\n\\n1. Initialize two arrays `arrS` and `arrT`, both of size 26, to keep track of the counts of each character in strings `s` and `t`. We are using a fixed-size array of 26 to represent lowercase English letters.\\n\\n2. Iterate through the characters of string `s`, and for each character, increment the count in the corresponding index of `arrS`. This step is performed to record the frequency of each character in `s`.\\n\\n3. Repeat the same process for string `t` to populate the `arrT` array with the counts of characters in `t`.\\n\\n4. Initialize a variable `count` to keep track of the number of steps required to make `t` an anagram of `s`. The initial value of `count` is set to 0.\\n\\n5. Iterate through the arrays `arrS` and `arrT` simultaneously. For each index, compare the counts of characters from `s` and `t`. If the count of a character in `t` is less than the count in `s`, it means that we need to make additional steps to increase the count of that character in `t`.\\n\\n6. In the inner loop, increment the count of that character in `t` and also increment the `count` variable to keep track of the total steps taken.\\n\\n7. After completing the loop, `count` will represent the minimum number of steps required to make `t` an anagram of `s`.\\n\\nThe logic behind this approach is that an anagram of a string is another string with the same characters but potentially in a different order. To make `t` an anagram of `s`, we need to ensure that both strings have the same count of each character. By calculating the difference in counts of each character between `s` and `t`, we determine the number of steps needed to modify `t` accordingly. The goal is to balance the counts of all characters in `t` with the counts in `s`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = new int[26];\\n        int[] arrT = new int[26];\\n\\n        for(char c : s.toCharArray()) {\\n            arrS[c - \\'a\\']++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arrT[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < 26; i++){\\n            while(arrS[i] > arrT[i]) {\\n                arrT[i]++;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] arrS = new int[26];\\n        int[] arrT = new int[26];\\n\\n        for(char c : s.toCharArray()) {\\n            arrS[c - \\'a\\']++;\\n        }\\n\\n        for(char c : t.toCharArray()){\\n            arrT[c - \\'a\\']++;\\n        }\\n\\n        int count = 0;\\n\\n        for(int i = 0; i < 26; i++){\\n            while(arrS[i] > arrT[i]) {\\n                arrT[i]++;\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695428,
                "title": "simple-c-hash-map-and-set-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to change the elements in string t only when \\n1. There are no occurances of that element in string s  \\n2. There are more occurances of element in string t than of string s\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Store occurances of each term in string s,t in map mp1,mp2.\\n2. A set st to get unique elemnts of string t so that in next itertion we can get compare occurances.\\n3. We iterate through that set made of string t \\n   -> If there are no occerances of that element in string s remove\\n      all those occurances of that element ie, add it to answer\\n   -> If string t has more occurances than string s for particular\\n      element add those extra occurances to the answer. \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp1,mp2;\\n        int ans = 0;\\n        for(char i:s)\\n        {\\n            mp1[i]++;\\n        }\\n        for(char i:t)\\n        {\\n            mp2[i]++;\\n        }\\n        set<char> st;\\n        for(char i:t)\\n        {\\n            st.insert(i);\\n        }\\n        for(char i:st)\\n        {\\n            if(mp1[i] == 0)\\n            {\\n                ans += mp2[i];\\n            }\\n            else if(mp1[i] < mp2[i])\\n            {\\n                ans += mp2[i] - mp1[i];\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp1,mp2;\\n        int ans = 0;\\n        for(char i:s)\\n        {\\n            mp1[i]++;\\n        }\\n        for(char i:t)\\n        {\\n            mp2[i]++;\\n        }\\n        set<char> st;\\n        for(char i:t)\\n        {\\n            st.insert(i);\\n        }\\n        for(char i:st)\\n        {\\n            if(mp1[i] == 0)\\n            {\\n                ans += mp2[i];\\n            }\\n            else if(mp1[i] < mp2[i])\\n            {\\n                ans += mp2[i] - mp1[i];\\n            }\\n        }\\n        return ans;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454894,
                "title": "easiest-c-solution-intuition-explained-w-comments",
                "content": "# Intuition\\nAnagram means a string that contains the same characters with a different (or the same) ordering, i.e. the characters will be same.\\n\\nSo we can simply count the common characters in both the strings and the remaining characters (in any one of the string) will be the required answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHere I\\'m using an unordered map to count the common characters.\\nStep 1: Map the characters of string 1.\\n\\nStep 2: Traverse through string 2 and if the character is already present in the map, increase the counter (c).\\n\\nStep 3: Return size of string 1(or String 2 as both  have same length) minus the counter.\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\nHere we are using unordered_map to store frequecy of every letter in string so at we can have all english letter in the string, therfore it is O(26) or O(1).\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# **Do Upvote Please!!**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;                 // Step 1\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;                    // Step 2\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n       \\n        // return (n1+n2-2*c)/2; \\n        return n1-c;                    // Step 3\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) \\n    {\\n        int c=0;\\n        int n1=s.size();\\n        int n2=t.size();\\n        unordered_map<char,int> m;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            m[s[i]]++;                 // Step 1\\n        }\\n        for(int i=0;i<t.size();i++)\\n        {\\n            if(m.find(t[i])!=m.end() and m[t[i]]>0)\\n            {\\n                c++;                    // Step 2\\n                m[t[i]]--;\\n                cout<<t[i]<<endl;\\n            }\\n        }\\n       \\n        // return (n1+n2-2*c)/2; \\n        return n1-c;                    // Step 3\\n       \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3360625,
                "title": "simple-python-solution-using-dictionary",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        dic = collections.defaultdict(int)\\n        for char in s:\\n            dic[char] += 1\\n        count = 0\\n        for char in t:\\n            if dic[char]:\\n                dic[char] -=1   \\n            else:\\n                count += 1\\n        return sum(dic.values())\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        dic = collections.defaultdict(int)\\n        for char in s:\\n            dic[char] += 1\\n        count = 0\\n        for char in t:\\n            if dic[char]:\\n                dic[char] -=1   \\n            else:\\n                count += 1\\n        return sum(dic.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296552,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> mapping(string s)\\n    {\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            v[s[i] - \\'a\\']++;\\n        return v;\\n    }\\n\\n    int minSteps(string s, string t) {\\n\\n    vector<int> mapping1 = mapping(s);\\n    vector<int> mapping2 = mapping(t);\\n    int count = 0;\\n    for (int i = 0; i < 26; i++)\\n    {\\n        int diff = 0;\\n        if (mapping1[i] != 0)\\n            if (mapping1[i] > mapping2[i])\\n                diff = mapping1[i] - mapping2[i];\\n        count += diff;\\n    }\\n    return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> mapping(string s)\\n    {\\n        vector<int> v(26, 0);\\n        for (int i = 0; i < s.size(); i++)\\n            v[s[i] - \\'a\\']++;\\n        return v;\\n    }\\n\\n    int minSteps(string s, string t) {\\n\\n    vector<int> mapping1 = mapping(s);\\n    vector<int> mapping2 = mapping(t);\\n    int count = 0;\\n    for (int i = 0; i < 26; i++)\\n    {\\n        int diff = 0;\\n        if (mapping1[i] != 0)\\n            if (mapping1[i] > mapping2[i])\\n                diff = mapping1[i] - mapping2[i];\\n        count += diff;\\n    }\\n    return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281674,
                "title": "golang-100-fastest-solution",
                "content": "\\n```\\nfunc minSteps(s string, t string) (res int) {\\n    dict := [26]int{}\\n    for k , v := range s {\\n        dict[v - \\'a\\']++\\n        dict[t[k] - \\'a\\']--\\n    }\\n\\n    for _ , v := range dict {\\n        if v > 0 { \\n            res += v\\n        }\\n    }\\n    return res\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minSteps(s string, t string) (res int) {\\n    dict := [26]int{}\\n    for k , v := range s {\\n        dict[v - \\'a\\']++\\n        dict[t[k] - \\'a\\']--\\n    }\\n\\n    for _ , v := range dict {\\n        if v > 0 { \\n            res += v\\n        }\\n    }\\n    return res\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2996697,
                "title": "cpp-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t)\\n    {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        if(m.size()==0)return 0;\\n        int ans=0;\\n        for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t)\\n    {\\n        unordered_map<char,int>m;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        for(int i=0;i<t.length();i++)\\n        {\\n            if(m.find(t[i])!=m.end())\\n            {\\n                m[t[i]]--;\\n                if(m[t[i]]==0)\\n                {\\n                    m.erase(t[i]);\\n                }\\n            }\\n        }\\n        if(m.size()==0)return 0;\\n        int ans=0;\\n        for(auto it:m)\\n        {\\n            ans+=it.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2984451,
                "title": "beats-94-java-solution-o-1-space",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int []mp=new int[26];\\n    int []mp2=new int[26];\\n\\n    int count=0;\\n    int ans=0;\\n\\n    for(int i=0;i<s.length();i++){\\n\\n    \\n    mp[s.charAt(i)-\\'a\\']++;\\n\\n    mp2[t.charAt(i)-\\'a\\']++;\\n\\n\\n    }\\n\\n    for(char i=\\'a\\';i<=\\'z\\';i++){\\n\\n    if(mp[i-\\'a\\']==0){\\n        count+=mp2[i-\\'a\\'];\\n    }\\n    else if(mp[i-\\'a\\']<mp2[i-\\'a\\']){\\n        count+=mp2[i-\\'a\\']-mp[i-\\'a\\'];\\n    }\\n    else if(mp[i-\\'a\\']>mp2[i-\\'a\\']&&count>mp[i-\\'a\\']-mp2[i-\\'a\\']){\\n\\n        count=count-(mp[i-\\'a\\']-mp2[i-\\'a\\']);\\n\\n        ans=ans+(mp[i-\\'a\\']-mp2[i-\\'a\\']);\\n    }\\n\\n    }\\n\\n    return ans+count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n    int []mp=new int[26];\\n    int []mp2=new int[26];\\n\\n    int count=0;\\n    int ans=0;\\n\\n    for(int i=0;i<s.length();i++){\\n\\n    \\n    mp[s.charAt(i)-\\'a\\']++;\\n\\n    mp2[t.charAt(i)-\\'a\\']++;\\n\\n\\n    }\\n\\n    for(char i=\\'a\\';i<=\\'z\\';i++){\\n\\n    if(mp[i-\\'a\\']==0){\\n        count+=mp2[i-\\'a\\'];\\n    }\\n    else if(mp[i-\\'a\\']<mp2[i-\\'a\\']){\\n        count+=mp2[i-\\'a\\']-mp[i-\\'a\\'];\\n    }\\n    else if(mp[i-\\'a\\']>mp2[i-\\'a\\']&&count>mp[i-\\'a\\']-mp2[i-\\'a\\']){\\n\\n        count=count-(mp[i-\\'a\\']-mp2[i-\\'a\\']);\\n\\n        ans=ans+(mp[i-\\'a\\']-mp2[i-\\'a\\']);\\n    }\\n\\n    }\\n\\n    return ans+count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806744,
                "title": "easy-java-solution-using-frequency-array",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n          int res = 0;\\n        int[] f1= new int[26] , f2 = new int[26];\\n \\n        for(char ch : s.toCharArray())   f1[ch-\\'a\\']++;\\n        for(char ch : t.toCharArray())   f2[ch-\\'a\\']++;\\n        \\n        for(int i=0;i<26;++i)\\n            if(f2[i]<f1[i])   res += (f1[i]-f2[i]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n          int res = 0;\\n        int[] f1= new int[26] , f2 = new int[26];\\n \\n        for(char ch : s.toCharArray())   f1[ch-\\'a\\']++;\\n        for(char ch : t.toCharArray())   f2[ch-\\'a\\']++;\\n        \\n        for(int i=0;i<26;++i)\\n            if(f2[i]<f1[i])   res += (f1[i]-f2[i]);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755872,
                "title": "java-solution-simple-and-easy-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s1, String s2) {\\n        int arr[]=new int[26];\\n        int brr[]=new int[26];\\n       \\n        for(int i=0;i<s1.length();i++) arr[s1.charAt(i)-\\'a\\']++;\\n       \\n        for(int i=0;i<s2.length();i++) brr[s2.charAt(i)-\\'a\\']++;\\n         \\n        int count=0;\\n        \\n        //for(int i=0;i<26;i++)System.out.print(arr[i]+\" \");\\n        \\n        for(int i=0;i<26;i++)count+=Math.abs(arr[i]-brr[i]);\\n       \\n        return count/2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s1, String s2) {\\n        int arr[]=new int[26];\\n        int brr[]=new int[26];\\n       \\n        for(int i=0;i<s1.length();i++) arr[s1.charAt(i)-\\'a\\']++;\\n       \\n        for(int i=0;i<s2.length();i++) brr[s2.charAt(i)-\\'a\\']++;\\n         \\n        int count=0;\\n        \\n        //for(int i=0;i<26;i++)System.out.print(arr[i]+\" \");\\n        \\n        for(int i=0;i<26;i++)count+=Math.abs(arr[i]-brr[i]);\\n       \\n        return count/2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2624272,
                "title": "python-sol-n-using-dictionary-easy-understand",
                "content": "class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        ds = defaultdict(int)\\n        dt = defaultdict(int)\\n        for i in s:\\n            ds[i] +=1\\n        for j in t:\\n            dt[j] +=1\\n        for i in s:\\n            if i not in dt:\\n                dt[i] = 0\\n        for i in t:\\n            if i not in ds:\\n                ds[i] = 0\\n        out = 0\\n        for key,value in dt.items():\\n            x = value - ds[key]\\n            out += abs(x)\\n        return int(out/2)",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        ds = defaultdict(int)\\n        dt = defaultdict(int)\\n        for i in s:\\n            ds[i] +=1\\n        for j in t:\\n            dt[j] +=1\\n        for i in s:\\n            if i not in dt:\\n                dt[i] = 0\\n        for i in t:\\n            if i not in ds:\\n                ds[i] = 0\\n        out = 0\\n        for key,value in dt.items():\\n            x = value - ds[key]\\n            out += abs(x)\\n        return int(out/2)",
                "codeTag": "Java"
            },
            {
                "id": 2588738,
                "title": "using-hashmap-python-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        def pairs(s):\\n            dct = defaultdict(int)\\n            for i in s:\\n                dct[i] += 1\\n            return dct\\n        \\n        S = pairs(s)\\n        T = pairs(t)\\n        res = 0\\n        \\n        for key in S.keys():    \\n            if S[key] > T[key]:\\n                res += S[key]-T[key]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        \\n        def pairs(s):\\n            dct = defaultdict(int)\\n            for i in s:\\n                dct[i] += 1\\n            return dct\\n        \\n        S = pairs(s)\\n        T = pairs(t)\\n        res = 0\\n        \\n        for key in S.keys():    \\n            if S[key] > T[key]:\\n                res += S[key]-T[key]\\n\\t\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563800,
                "title": "python-using-dictionary",
                "content": "```class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d = {k:s.count(k) for k in set(s)}\\n        for letter in t:\\n            if letter in d and d[letter]>0:\\n                d[letter] -= 1\\n        return sum(d.values())\\n   ```\\n\\t\\t\\t\\t\\nAt first we are creating a dictionary with keys = all values from set and values = count of that letter.\\nSecond step is, to remove the letter from the dictionary which are already present only to make the count = 0 and not below that.\\nThird step, add all the values from the dictionary and this should be the answer.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d = {k:s.count(k) for k in set(s)}\\n        for letter in t:\\n            if letter in d and d[letter]>0:\\n                d[letter] -= 1\\n        return sum(d.values())\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2515577,
                "title": "c-o-1-space-solution-linear-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        vector<int> count1(26, 0) , count2(26 , 0);\\n        \\n        for(int i = 0 ; i<s.length() ; i++)\\n        {\\n            count1[s[i] - \\'a\\']++;\\n            count2[t[i] - \\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i<26 ; i++)\\n            ans+= abs(count1[i] - count2[i]);\\n        \\n        return ans/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        vector<int> count1(26, 0) , count2(26 , 0);\\n        \\n        for(int i = 0 ; i<s.length() ; i++)\\n        {\\n            count1[s[i] - \\'a\\']++;\\n            count2[t[i] - \\'a\\']++;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0 ; i<26 ; i++)\\n            ans+= abs(count1[i] - count2[i]);\\n        \\n        return ans/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513869,
                "title": "11-ms-java-solution",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        int[] sArr = new int[26];\\n        int[] tArr = new int[26];\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            sArr[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < t.length(); i++){\\n            tArr[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < sArr.length; i++){\\n            sArr[i] -= tArr[i];\\n            \\n            if(sArr[i] > 0){\\n                count += sArr[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        \\n        int[] sArr = new int[26];\\n        int[] tArr = new int[26];\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            sArr[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for(int i = 0; i < t.length(); i++){\\n            tArr[t.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        int count = 0;\\n        for(int i = 0; i < sArr.length; i++){\\n            sArr[i] -= tArr[i];\\n            \\n            if(sArr[i] > 0){\\n                count += sArr[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467546,
                "title": "easy-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> vec(26,0);\\n        for(int i=0;i<t.length();i++){\\n            vec[t[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(vec[s[i]-\\'a\\'] > 0)\\n            vec[s[i]-\\'a\\']--;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<vec.size();i++){\\n            cnt+=vec[i];\\n        }\\n       return cnt; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> vec(26,0);\\n        for(int i=0;i<t.length();i++){\\n            vec[t[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<s.length();i++){\\n            if(vec[s[i]-\\'a\\'] > 0)\\n            vec[s[i]-\\'a\\']--;\\n        }\\n        int cnt=0;\\n        for(int i=0;i<vec.size();i++){\\n            cnt+=vec[i];\\n        }\\n       return cnt; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2442121,
                "title": "python-o-n",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        dict1={}\\n        for c in s:\\n            if dict1.get(c,None) is None:\\n                dict1[c]=1  \\n            else:\\n                dict1[c]+=1\\n        s=0\\n        for c in t:\\n            if dict1.get(c,None) is None:\\n                s+=1\\n            else:\\n                if dict1[c]==0:\\n                    s+=1\\n                else:\\n                    dict1[c]-=1\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        dict1={}\\n        for c in s:\\n            if dict1.get(c,None) is None:\\n                dict1[c]=1  \\n            else:\\n                dict1[c]+=1\\n        s=0\\n        for c in t:\\n            if dict1.get(c,None) is None:\\n                s+=1\\n            else:\\n                if dict1[c]==0:\\n                    s+=1\\n                else:\\n                    dict1[c]-=1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406283,
                "title": "c-easy-solution-without-hashmap",
                "content": "```\\n int n=s.length();\\n        vector<int>vt(26,0);\\n        vector<int>vt1(26,0);\\n        for(auto it:s){\\n            vt[it-\\'a\\']++;\\n        }\\n        // for(auto it:vt){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(auto it:t){\\n         vt1[it-\\'a\\']++;\\n        }\\n         \\n        int ans=0;\\n       for(int i=0;i<26;i++){\\n           ans+=abs(vt[i]-vt1[i]);\\n       }\\n        return ans/2;",
                "solutionTags": [],
                "code": "```\\n int n=s.length();\\n        vector<int>vt(26,0);\\n        vector<int>vt1(26,0);\\n        for(auto it:s){\\n            vt[it-\\'a\\']++;\\n        }\\n        // for(auto it:vt){\\n        //     cout<<it<<\" \";\\n        // }\\n        for(auto it:t){\\n         vt1[it-\\'a\\']++;\\n        }\\n         \\n        int ans=0;\\n       for(int i=0;i<26;i++){\\n           ans+=abs(vt[i]-vt1[i]);\\n       }\\n        return ans/2;",
                "codeTag": "C++"
            },
            {
                "id": 2385621,
                "title": "java-solution-easy-to-understand",
                "content": "```\\n//find the frequency of every letter and check diffrence between the frequency of each letter then divide it by 2 to calculate the minimum number of letter to be changed.\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int sf[]=new int[26];\\n        int tf[]=new int[26];\\n        int diff=0;\\n        for(char c:s.toCharArray()){\\n            sf[c-\\'a\\']++;\\n        }\\n        for(char c:t.toCharArray()){\\n            tf[c-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++){\\n            diff+=(int)Math.abs(sf[i]-tf[i]);\\n        }\\n        return diff/2;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minSteps(String s, String t) {\\n        int sf[]=new int[26];\\n        int tf[]=new int[26];\\n        int diff=0;\\n        for(char c:s.toCharArray()){\\n            sf[c-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2302963,
                "title": "one-liner-faster-than-99-95-space-less-than-98-basics",
                "content": "```\\n        c=0\\n        for i in set(s):\\n          a=s.count(i)\\n          b=t.count(i)\\n          if a>b:\\n            c+=a-b\\n\\n        return (c)\\n```\\nTHIS ALL CAN BE PACKED IN A SINGEL LINE ALSO\\n\\n```\\n         l=set(s)\\n         return (sum([s.count(i)-t.count(i) for i in l if s.count(i)>t.count(i)]))\\n```\\nIF THIS HELP U KINDLY UPVOTE THIS TO HELP OTHERS TO GET THIS SOLUTION\\nIF U DONT GET IT KINDLY COMMENT AND FEEL FREE TO ASK\\nAND CORRECT MEIF I AM WRONG",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        c=0\\n        for i in set(s):\\n          a=s.count(i)\\n          b=t.count(i)\\n          if a>b:\\n            c+=a-b\\n\\n        return (c)\\n```\n```\\n         l=set(s)\\n         return (sum([s.count(i)-t.count(i) for i in l if s.count(i)>t.count(i)]))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2295370,
                "title": "c-solution-hashmap-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int> str_map;\\n        int count = 0;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(str_map.find(s[i]) != str_map.end()) str_map[s[i]] += 1;\\n            else str_map[s[i]] = 1;\\n        }\\n        \\n        for(int i=0; i<t.size(); i++)\\n        {\\n            if(str_map.find(t[i]) == str_map.end()) count++;\\n            else if(str_map[t[i]] == 0) count++;\\n            else str_map[t[i]] -= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char, int> str_map;\\n        int count = 0;\\n        \\n        for(int i=0; i<s.size(); i++)\\n        {\\n            if(str_map.find(s[i]) != str_map.end()) str_map[s[i]] += 1;\\n            else str_map[s[i]] = 1;\\n        }\\n        \\n        for(int i=0; i<t.size(); i++)\\n        {\\n            if(str_map.find(t[i]) == str_map.end()) count++;\\n            else if(str_map[t[i]] == 0) count++;\\n            else str_map[t[i]] -= 1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2291020,
                "title": "easy-python-solution-using-dictionary",
                "content": "Explanation:\\nCount the occurences of each element of string s and record it in a dictionary.\\nIterate through the string t and decrement the count of the alphabets of t present in dict.\\nAs the len(s) = len(t) given in question, the total sum of the left out elements in dict are the one\\'s that need to be replaced into.\\nHence return sum of the values of dict.\\n```\\ndef minSteps(self, s: str, t: str) -> int:\\n        sdict = dict()\\n        for ch in s:\\n            sdict[ch] = sdict.get(ch, 0) + 1\\n        for ch in t:\\n            if sdict.get(ch, 0) > 0:\\n                sdict[ch] -= 1\\n        return sum(sdict.values())\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minSteps(self, s: str, t: str) -> int:\\n        sdict = dict()\\n        for ch in s:\\n            sdict[ch] = sdict.get(ch, 0) + 1\\n        for ch in t:\\n            if sdict.get(ch, 0) > 0:\\n                sdict[ch] -= 1\\n        return sum(sdict.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2275886,
                "title": "python-solution-using-counter",
                "content": "We can use Python\\'s counter to get the difference in the characters between the two strings, and sum up the number of differences to get our answer.\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        diff = c1 - c2\\n        return sum(diff.values())\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        c1 = Counter(s)\\n        c2 = Counter(t)\\n        diff = c1 - c2\\n        return sum(diff.values())\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2253945,
                "title": "very-easy-c-solution",
                "content": "1. Count the no. of common characters from both the strings.\\n2. If the common characters == length of string then return 0\\n3. else return string length - common characters (the difference will be needed to replace)\\n\\n```\\nclass Solution {\\npublic:\\n    int countPairs(string s1, int n1, string s2, int n2)\\n    {\\n        int freq1[26] = { 0 };\\n        int freq2[26] = { 0 };\\n        int i, count = 0;\\n        for (i = 0; i < n1; i++)\\n            freq1[s1[i] - \\'a\\']++;\\n        for (i = 0; i < n2; i++)\\n            freq2[s2[i] - \\'a\\']++;\\n        for (i = 0; i < 26; i++)\\n            count += (min(freq1[i], freq2[i]));\\n        return count;\\n    }\\n    int minSteps(string s, string t) {\\n        int size = s.length();\\n        int temp = countPairs(s, size, t, size);\\n        if(t.length()==temp)\\n            return 0;\\n        else\\n            return (t.length()-temp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countPairs(string s1, int n1, string s2, int n2)\\n    {\\n        int freq1[26] = { 0 };\\n        int freq2[26] = { 0 };\\n        int i, count = 0;\\n        for (i = 0; i < n1; i++)\\n            freq1[s1[i] - \\'a\\']++;\\n        for (i = 0; i < n2; i++)\\n            freq2[s2[i] - \\'a\\']++;\\n        for (i = 0; i < 26; i++)\\n            count += (min(freq1[i], freq2[i]));\\n        return count;\\n    }\\n    int minSteps(string s, string t) {\\n        int size = s.length();\\n        int temp = countPairs(s, size, t, size);\\n        if(t.length()==temp)\\n            return 0;\\n        else\\n            return (t.length()-temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247860,
                "title": "python-solution",
                "content": "\\'\\'\\'class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        s_count = Counter(s)\\n        c_count = Counter(t)\\n        s_c = list(s_count)\\n        c_c = list(c_count)\\n        c = 0\\n        for i in s_c :\\n            if i in c_c :\\n                e = s_count[i] - c_count[i]\\n                if e > 0 :\\n                    c += e\\n            elif i not in c_c :\\n                c += s_count[i]\\n        return (c)\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        from collections import Counter\\n        s_count = Counter(s)\\n        c_count = Counter(t)\\n        s_c = list(s_count)\\n        c_c = list(c_count)\\n        c = 0\\n        for i in s_c :\\n            if i in c_c :\\n                e = s_count[i] - c_count[i]\\n                if e > 0 :\\n                    c += e\\n            elif i not in c_c :\\n                c += s_count[i]\\n        return (c)\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2244639,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>m1,m2;\\n        for(int i=0;i<s.size();i++)\\n            m1[s[i]]++;\\n        for(int i=0;i<t.size();i++)\\n            m2[t[i]]++;\\n        int ans=0;\\n        for(auto i:m1)\\n        {\\n            int k=m2[i.first];\\n            ans+=abs(k-i.second);\\n        }\\n        for(auto i:m2)\\n        {\\n            if(!m1[i.first])\\n            {\\n                 int k=m1[i.first];\\n                 ans+=abs(k-i.second);\\n            }\\n        }\\n        return ans/2;     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        map<char,int>m1,m2;\\n        for(int i=0;i<s.size();i++)\\n            m1[s[i]]++;\\n        for(int i=0;i<t.size();i++)\\n            m2[t[i]]++;\\n        int ans=0;\\n        for(auto i:m1)\\n        {\\n            int k=m2[i.first];\\n            ans+=abs(k-i.second);\\n        }\\n        for(auto i:m2)\\n        {\\n            if(!m1[i.first])\\n            {\\n                 int k=m1[i.first];\\n                 ans+=abs(k-i.second);\\n            }\\n        }\\n        return ans/2;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2237514,
                "title": "js-solution",
                "content": "```\\nvar minSteps = function(s, t) {\\n        \\n    let hash1 = hash(s);\\n    let hash2 = hash(t);\\n    let steps = 0;\\n    \\n    for(let key of Object.keys(hash1)) {\\n        if( hash2[key]) {\\n            hash1[key] = hash1[key] - hash2[key];\\n        }\\n        if( hash1[key] > 0 ) {\\n            steps += hash1[key];\\n        }\\n    }\\n    \\n    return steps;\\n};\\n\\nfunction hash(str) {\\n    let hash = {};\\n    for(let i=0; i<str.length; i++) {\\n        let letter = str[i];\\n        if( hash[letter] ) {\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }\\n    \\n    return hash;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar minSteps = function(s, t) {\\n        \\n    let hash1 = hash(s);\\n    let hash2 = hash(t);\\n    let steps = 0;\\n    \\n    for(let key of Object.keys(hash1)) {\\n        if( hash2[key]) {\\n            hash1[key] = hash1[key] - hash2[key];\\n        }\\n        if( hash1[key] > 0 ) {\\n            steps += hash1[key];\\n        }\\n    }\\n    \\n    return steps;\\n};\\n\\nfunction hash(str) {\\n    let hash = {};\\n    for(let i=0; i<str.length; i++) {\\n        let letter = str[i];\\n        if( hash[letter] ) {\\n            hash[letter]++;\\n        } else {\\n            hash[letter] = 1;\\n        }\\n    }\\n    \\n    return hash;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2211510,
                "title": "java-hashmap",
                "content": "Approach-1:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        Map<Character, Integer> mapS = new HashMap<>();\\n        for (var ch : s.toCharArray())\\n            mapS.put(ch, mapS.getOrDefault(ch, 0) + 1);\\n        \\n        Map<Character, Integer> mapT = new HashMap<>();\\n        for (var ch : t.toCharArray())\\n            if (mapS.containsKey(ch))  {\\n                mapS.put(ch, mapS.get(ch) - 1);\\n                if (mapS.get(ch) == 0)\\n                    mapS.remove(ch);\\n            }\\n            else \\n                mapT.put(ch, mapT.getOrDefault(ch, 0) + 1);\\n        \\n        int steps = 0;\\n        for (var value : mapT.values()) \\n            steps += value;\\n        \\n        return steps;\\n    }\\n}\\n```\\n\\nApproach-2:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        Map<Character, Integer> mapS = new HashMap<>();\\n        for (var ch : s.toCharArray())\\n            mapS.put(ch, mapS.getOrDefault(ch, 0) + 1);\\n        \\n        int steps = 0;\\n        Map<Character, Integer> mapT = new HashMap<>();\\n        for (var ch : t.toCharArray())\\n            if (mapS.containsKey(ch))  {\\n                mapS.put(ch, mapS.get(ch) - 1);\\n                if (mapS.get(ch) == 0)\\n                    mapS.remove(ch);\\n            }\\n            else \\n                steps++;\\n        \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        Map<Character, Integer> mapS = new HashMap<>();\\n        for (var ch : s.toCharArray())\\n            mapS.put(ch, mapS.getOrDefault(ch, 0) + 1);\\n        \\n        Map<Character, Integer> mapT = new HashMap<>();\\n        for (var ch : t.toCharArray())\\n            if (mapS.containsKey(ch))  {\\n                mapS.put(ch, mapS.get(ch) - 1);\\n                if (mapS.get(ch) == 0)\\n                    mapS.remove(ch);\\n            }\\n            else \\n                mapT.put(ch, mapT.getOrDefault(ch, 0) + 1);\\n        \\n        int steps = 0;\\n        for (var value : mapT.values()) \\n            steps += value;\\n        \\n        return steps;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        Map<Character, Integer> mapS = new HashMap<>();\\n        for (var ch : s.toCharArray())\\n            mapS.put(ch, mapS.getOrDefault(ch, 0) + 1);\\n        \\n        int steps = 0;\\n        Map<Character, Integer> mapT = new HashMap<>();\\n        for (var ch : t.toCharArray())\\n            if (mapS.containsKey(ch))  {\\n                mapS.put(ch, mapS.get(ch) - 1);\\n                if (mapS.get(ch) == 0)\\n                    mapS.remove(ch);\\n            }\\n            else \\n                steps++;\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2159446,
                "title": "java-very-simple-solution-with-comment",
                "content": "Please refer to the code and comment below\\n\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        //Two arrays that store the number of appearance for each letter for s and t\\n        var myS = new int[26];\\n        var myT = new int[26];\\n\\n        //The final answer\\n        var ans = 0;\\n\\n        //Count the number of occurrence of each letter in each string\\n        for(int i = 0; i < s.length(); i++) {\\n            myS[s.charAt(i) - \\'a\\'] += 1;\\n            myT[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n\\n        //Add the difference of each letter up to get the total amount of differences\\n        for (int i = 0; i < 26; i++) {\\n            ans += Math.abs(myS[i] - myT[i]);\\n        }\\n\\n        //Since for every two mismatches we only have to operate once (change the char in t into the desired in s), the answer is the differences divided by 2\\n        return ans / 2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        //Two arrays that store the number of appearance for each letter for s and t\\n        var myS = new int[26];\\n        var myT = new int[26];\\n\\n        //The final answer\\n        var ans = 0;\\n\\n        //Count the number of occurrence of each letter in each string\\n        for(int i = 0; i < s.length(); i++) {\\n            myS[s.charAt(i) - \\'a\\'] += 1;\\n            myT[t.charAt(i) - \\'a\\'] += 1;\\n        }\\n\\n        //Add the difference of each letter up to get the total amount of differences\\n        for (int i = 0; i < 26; i++) {\\n            ans += Math.abs(myS[i] - myT[i]);\\n        }\\n\\n        //Since for every two mismatches we only have to operate once (change the char in t into the desired in s), the answer is the differences divided by 2\\n        return ans / 2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2123122,
                "title": "o-n-easy-cpp-6-lines-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]]++;\\n        for(int i=0;i<t.length();i++) if(mp[t[i]]>0) mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp) if(i.second) cnt+=i.second;\\n        return cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> mp;\\n        for(int i=0;i<s.length();i++) mp[s[i]]++;\\n        for(int i=0;i<t.length();i++) if(mp[t[i]]>0) mp[t[i]]--;\\n        int cnt=0;\\n        for(auto i:mp) if(i.second) cnt+=i.second;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095419,
                "title": "c-simple",
                "content": "```\\npublic class Solution\\n{\\n    public int MinSteps(string s, string t)\\n    {\\n        int[] differences = new int[26];\\n        foreach (char character in s) differences[character - \\'a\\']++;\\n        foreach (char character in t) differences[character - \\'a\\']--;\\n        return differences.Sum(x => x > 0 ? x : 0);\\n    } \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinSteps(string s, string t)\\n    {\\n        int[] differences = new int[26];\\n        foreach (char character in s) differences[character - \\'a\\']++;\\n        foreach (char character in t) differences[character - \\'a\\']--;\\n        return differences.Sum(x => x > 0 ? x : 0);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093082,
                "title": "c-easy-solution-using-hashmaps",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        unordered_map<char,int> mp;\\n        for(auto i:s){\\n            mp[i]++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]!=0){\\n                mp[t[i]]--;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int count=0;\\n        unordered_map<char,int> mp;\\n        for(auto i:s){\\n            mp[i]++;\\n        }\\n        \\n        for(int i=0;i<t.size();i++){\\n            if(mp.find(t[i])!=mp.end() && mp[t[i]]!=0){\\n                mp[t[i]]--;\\n            }\\n            else{\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087763,
                "title": "c-easy-solution-o-n",
                "content": "```\\nint minSteps(string s, string t) {\\n        int svec[26] = {0};\\n        int tvec[26] = {0};\\n        \\n        for(int i = 0; i < s.size(); ++i) {\\n            svec[s[i] - \\'a\\'] += 1;\\n            tvec[t[i] - \\'a\\'] += 1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            if(svec[i] > 0 && svec[i] > tvec[i]) {\\n                ans += svec[i] - tvec[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minSteps(string s, string t) {\\n        int svec[26] = {0};\\n        int tvec[26] = {0};\\n        \\n        for(int i = 0; i < s.size(); ++i) {\\n            svec[s[i] - \\'a\\'] += 1;\\n            tvec[t[i] - \\'a\\'] += 1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < 26; ++i) {\\n            if(svec[i] > 0 && svec[i] > tvec[i]) {\\n                ans += svec[i] - tvec[i];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047437,
                "title": "98-faster-simple-java-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      int f[]=new int[26];\\n        for(char c : s.toCharArray())f[c-\\'a\\']++;\\n        for(char c : t.toCharArray())f[c-\\'a\\']--;\\n        int count=0;\\n        for(int a : f)count+=Math.abs(a);\\n        return count/2;\\n    }\\n}\\n# ```\\n# Time : O(n) linear\\n# Space : O(1) constant\\n# \\n# Please upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n      int f[]=new int[26];\\n        for(char c : s.toCharArray())f[c-\\'a\\']++;\\n        for(char c : t.toCharArray())f[c-\\'a\\']--;\\n        int count=0;\\n        for(int a : f)count+=Math.abs(a);\\n        return count/2;\\n    }\\n}\\n# ```",
                "codeTag": "Java"
            },
            {
                "id": 2016664,
                "title": "easy-hashmap-solution-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        unordered_map<char,int> um;\\n        //store frequency of all characters of s in unordered_map\\n        for(auto x:s)\\n        {\\n          um[x]++;  \\n        }\\n        //decrement the frequency of overlapping elements in the same unordered map \\n        for(auto x:t)\\n        {\\n          um[x]--;  \\n        }\\n       int ans=0;\\n        //elements whose frequency is still positive must be replaced that number of times\\n        for(auto x:s)\\n        {\\n          if(um[x]>0)\\n          {\\n              ans+=um[x];\\n              um[x]=0;\\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        \\n        unordered_map<char,int> um;\\n        //store frequency of all characters of s in unordered_map\\n        for(auto x:s)\\n        {\\n          um[x]++;  \\n        }\\n        //decrement the frequency of overlapping elements in the same unordered map \\n        for(auto x:t)\\n        {\\n          um[x]--;  \\n        }\\n       int ans=0;\\n        //elements whose frequency is still positive must be replaced that number of times\\n        for(auto x:s)\\n        {\\n          if(um[x]>0)\\n          {\\n              ans+=um[x];\\n              um[x]=0;\\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979730,
                "title": "py3-short-and-simple-o-1-space-o-n-time-with-comments",
                "content": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        freq = [0]*26\\n\\t\\t# Cancel out common chars\\n        for i,j in zip(s,t):\\n            freq[ord(i)-ord(\\'a\\')]+=1\\n            freq[ord(j)-ord(\\'a\\')]-=1\\n\\t\\t# a pair of chars can be resolved by replacing in one string eg: aba,bab here we only replace b with a in 2nd or a with b in first not both\\n        return abs(sum(map(abs,freq))//2)\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        freq = [0]*26\\n\\t\\t# Cancel out common chars\\n        for i,j in zip(s,t):\\n            freq[ord(i)-ord(\\'a\\')]+=1\\n            freq[ord(j)-ord(\\'a\\')]-=1\\n\\t\\t# a pair of chars can be resolved by replacing in one string eg: aba,bab here we only replace b with a in 2nd or a with b in first not both\\n        return abs(sum(map(abs,freq))//2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936056,
                "title": "simple-java-solution-using-array",
                "content": "\\n    public int minSteps(String s, String t) {\\n        int[] word = new int[26];\\n        int result = 0;\\n        \\n        for(char c : t.toCharArray()){\\n            word[c - \\'a\\']++;\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(word[c - \\'a\\'] > 0){\\n                word[c - \\'a\\']--;\\n            }else{\\n                result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int minSteps(String s, String t) {\\n        int[] word = new int[26];\\n        int result = 0;\\n        \\n        for(char c : t.toCharArray()){\\n            word[c - \\'a\\']++;\\n        }\\n        \\n        for(char c : s.toCharArray()){\\n            if(word[c - \\'a\\'] > 0){\\n                word[c - \\'a\\']--;\\n            }else{\\n                result++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1924359,
                "title": "python-very-easy-soln-hashmap",
                "content": "```\\nimport string\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d1 = dict.fromkeys(string.ascii_lowercase, 0)\\n        d2 = dict.fromkeys(string.ascii_lowercase, 0)\\n        for i in range(len(s)):\\n            if s[i] in d1:\\n                d1[s[i]]+=1\\n            else:\\n                d1[s[i]]=1\\n        for i in range(len(t)):\\n            if t[i] in d2:\\n                d2[t[i]]+=1\\n            else:\\n                d2[t[i]]=1\\n        s = 0\\n        for i in range(26):\\n            s+=abs(d1[chr(97+i)]-d2[chr(97+i)])\\n        return s//2\\n```\\n\\nplease upvote if you like !!!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport string\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        d1 = dict.fromkeys(string.ascii_lowercase, 0)\\n        d2 = dict.fromkeys(string.ascii_lowercase, 0)\\n        for i in range(len(s)):\\n            if s[i] in d1:\\n                d1[s[i]]+=1\\n            else:\\n                d1[s[i]]=1\\n        for i in range(len(t)):\\n            if t[i] in d2:\\n                d2[t[i]]+=1\\n            else:\\n                d2[t[i]]=1\\n        s = 0\\n        for i in range(26):\\n            s+=abs(d1[chr(97+i)]-d2[chr(97+i)])\\n        return s//2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915189,
                "title": "java-solution-one-pass",
                "content": "```\\npublic int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        for(int i = 0; i<s.length(); i++){\\n            freqCount[s.charAt(i)-\\'a\\']++;\\n            freqCount[t.charAt(i)-\\'a\\']--;\\n        }\\n        int count = 0;\\n        for(int fre : freqCount){\\n            count+=Math.abs(fre);\\n        }\\n        return count/2;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minSteps(String s, String t) {\\n        int[] freqCount = new int[26];\\n        for(int i = 0; i<s.length(); i++){\\n            freqCount[s.charAt(i)-\\'a\\']++;\\n            freqCount[t.charAt(i)-\\'a\\']--;\\n        }\\n        int count = 0;\\n        for(int fre : freqCount){\\n            count+=Math.abs(fre);\\n        }\\n        return count/2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880675,
                "title": "c-solution-beats-78",
                "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int c=0;\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            v1[s[i]-\\'a\\']++;\\n            v2[t[i]-\\'a\\']++;\\n        }\\n        for(int i=0;i<26;i++)\\n        {\\n            if(v1[i]>v2[i])\\n                c=c+(v1[i]-v2[i]);\\n        }\\n        return c;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        int c=0;\\n        vector<int> v1(26,0);\\n        vector<int> v2(26,0);\\n        for(int i=0;i<s.length();i++)\\n        {\\n            v1[s[i]-\\'a\\']++;\\n            v2[t[i]-\\'a\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1838063,
                "title": "1347-python-2-dict-hashmap-explaination",
                "content": "I used the same technique in other questions here:\\n\\nhttps://leetcode.com/problems/minimum-number-of-steps-to-make-two-strings-anagram-ii/discuss/1838064/2186.-PYTHON-2-DictHashmap-Explaination\\n\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\n        seen1 = collections.Counter(s) #Make a dictionary {char:occurance}\\n        seen2 = collections.Counter(t) #Make a dictionary {char:occurance}\\n        \\n        total = 0\\n        \\n        #Iterate through seen1\\n        for key in seen1:\\n            \\n            if key in seen2: #Overlaps\\n                total = total + abs(seen1[key] - seen2[key])\\n                \\n            elif key not in seen2: #No overlaps\\n                total = total + seen1[key]\\n                \\n        #Iterate through seen2        \\n        for key in seen2:\\n            \\n            if key not in seen1: #No overlaps\\n                \\n                total = total + seen2[key]\\n                \\n                \\n        return total//2\\n    \\n    \\n    \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n\\n        seen1 = collections.Counter(s) #Make a dictionary {char:occurance}",
                "codeTag": "Java"
            },
            {
                "id": 1820678,
                "title": "java-easy-map",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     \\n        Map<Character, Integer> counts = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            counts.put(c, counts.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (char c : t.toCharArray()) {\\n            \\n            if (counts.containsKey(c)) {\\n                \\n                int v = counts.get(c);\\n                v--;\\n                if (v == 0) {\\n                    counts.remove(c);\\n                } else {\\n                    counts.put(c, v);\\n                }\\n            }\\n        }\\n        \\n        return Arrays.stream(counts.values().stream().mapToInt(i->i).toArray()).sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n     \\n        Map<Character, Integer> counts = new HashMap<>();\\n        for (char c : s.toCharArray()) {\\n            counts.put(c, counts.getOrDefault(c, 0) + 1);\\n        }\\n        \\n        for (char c : t.toCharArray()) {\\n            \\n            if (counts.containsKey(c)) {\\n                \\n                int v = counts.get(c);\\n                v--;\\n                if (v == 0) {\\n                    counts.remove(c);\\n                } else {\\n                    counts.put(c, v);\\n                }\\n            }\\n        }\\n        \\n        return Arrays.stream(counts.values().stream().mapToInt(i->i).toArray()).sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1804795,
                "title": "java-easy-to-understand-hashing",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n        int count = 0;\\n        int [] sArr = new int [26];\\n        \\n        for (int i = 0 ; i <s.length(); i++ ){\\n            \\n            sArr[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0 ; i <t.length(); i++ ){\\n            \\n            sArr[t.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0 ; i < 26; i++){\\n            if (sArr[i] != 0)\\n                count += Math.abs(sArr[i]);\\n        }\\n        \\n        return count/2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n\\n        int count = 0;\\n        int [] sArr = new int [26];\\n        \\n        for (int i = 0 ; i <s.length(); i++ ){\\n            \\n            sArr[s.charAt(i) - \\'a\\']++;\\n        }\\n        \\n        for (int i = 0 ; i <t.length(); i++ ){\\n            \\n            sArr[t.charAt(i) - \\'a\\']--;\\n        }\\n        \\n        for (int i = 0 ; i < 26; i++){\\n            if (sArr[i] != 0)\\n                count += Math.abs(sArr[i]);\\n        }\\n        \\n        return count/2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1803070,
                "title": "java-hashmap-o-s-t-time-o-s-o-26-space",
                "content": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        char ch;\\n        int num_of_ch = 0;\\n        \\n        for(int i = 0; i< s.length(); i++){\\n            ch = s.charAt(i);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(int i = 0; i< t.length(); i++){\\n            ch = t.charAt(i);\\n            if(!map.containsKey(ch)){\\n                num_of_ch++;\\n            }\\n            else{\\n                map.put(ch, map.get(ch) - 1);\\n                if(map.get(ch) == 0)\\n                    map.remove(ch);\\n            }\\n        }\\n        return num_of_ch;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\\n        char ch;\\n        int num_of_ch = 0;\\n        \\n        for(int i = 0; i< s.length(); i++){\\n            ch = s.charAt(i);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n        }\\n        \\n        for(int i = 0; i< t.length(); i++){\\n            ch = t.charAt(i);\\n            if(!map.containsKey(ch)){\\n                num_of_ch++;\\n            }\\n            else{\\n                map.put(ch, map.get(ch) - 1);\\n                if(map.get(ch) == 0)\\n                    map.remove(ch);\\n            }\\n        }\\n        return num_of_ch;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801389,
                "title": "javascript-es6-solution",
                "content": "```\\nconst minSteps = (s, t) => {\\n  let map = new Map();\\n  s.split(\"\").forEach(w => map.set(w, map.get(w) + 1 || 1));\\n  let count = 0;\\n  t.split(\"\").forEach(w => map.get(w) ? map.set(w, map.get(w) - 1) : count++);\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst minSteps = (s, t) => {\\n  let map = new Map();\\n  s.split(\"\").forEach(w => map.set(w, map.get(w) + 1 || 1));\\n  let count = 0;\\n  t.split(\"\").forEach(w => map.get(w) ? map.set(w, map.get(w) - 1) : count++);\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792995,
                "title": "java-simple-o-n-solution-100",
                "content": "```java\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] letters = new int[26];\\n        int result = 0;\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            letters[s.charAt(i) - \\'a\\']++;\\n            letters[t.charAt(i) - \\'a\\']--;   \\n        }\\n        \\n        for(int i = 0; i < 26; ++i)\\n            if(letters[i] > 0)\\n                result += letters[i];\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n        int[] letters = new int[26];\\n        int result = 0;\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            letters[s.charAt(i) - \\'a\\']++;\\n            letters[t.charAt(i) - \\'a\\']--;   \\n        }\\n        \\n        for(int i = 0; i < 26; ++i)\\n            if(letters[i] > 0)\\n                result += letters[i];\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777097,
                "title": "python-faster-than-80",
                "content": "Simple solution by using the counter and subtracting the occurrences of elements s in tCounter\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCounter = collections.Counter(s)\\n        tCounter = collections.Counter(t)\\n        \\n        for k in tCounter.keys():\\n            if k in sCounter:\\n                tCounter[k] -= sCounter[k]\\n                sCounter[k] = 0\\n        count = 0\\n        for k,v in tCounter.items():\\n            if v > 0:\\n                count+=v\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "Simple solution by using the counter and subtracting the occurrences of elements s in tCounter\\n\\n```\\nclass Solution:\\n    def minSteps(self, s: str, t: str) -> int:\\n        sCounter = collections.Counter(s)\\n        tCounter = collections.Counter(t)\\n        \\n        for k in tCounter.keys():\\n            if k in sCounter:\\n                tCounter[k] -= sCounter[k]\\n                sCounter[k] = 0\\n        count = 0\\n        for k,v in tCounter.items():\\n            if v > 0:\\n                count+=v\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1775988,
                "title": "java-simple-solution-with-explanation",
                "content": "With first for loap count the frequency of character\\'s in \"S\" string.\\nWith second loap if frequency if character present in S then decrement it, otherwise increment the required character.\\nThe code is self explict. \\n```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n       int sCount[]=new int[26];\\n       int sRequired=0;\\n       for(int i=0;i<s.length();i++)sCount[s.charAt(i)-\\'a\\']++;\\n       \\n        for(int i=0;i<t.length();i++){\\n            int no=t.charAt(i)-\\'a\\';\\n            if(sCount[no]>0)sCount[no]--;\\n            else sRequired++;\\n            }\\n        return sRequired;  \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minSteps(String s, String t) {\\n       int sCount[]=new int[26];\\n       int sRequired=0;\\n       for(int i=0;i<s.length();i++)sCount[s.charAt(i)-\\'a\\']++;\\n       \\n        for(int i=0;i<t.length();i++){\\n            int no=t.charAt(i)-\\'a\\';\\n            if(sCount[no]>0)sCount[no]--;\\n            else sRequired++;\\n            }\\n        return sRequired;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741980,
                "title": "consice-c-solution-o-n-2-approaches",
                "content": "***Method - 1 :***\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> freq;\\n        int count = 0;\\n        for(auto it : s) freq[it]++;\\n        for(auto it : t) freq[it]--;\\n        for(auto it : freq) if(it.second < 0) count += it.second;\\n        return abs(count);\\n    }\\n};\\n```\\n***Method - 2 :***\\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> freqs, freqt;\\n        for(int i = 0; i < s.size(); i++) \\n            freqs[s[i]]++, freqt[t[i]]++;\\n        \\n        int count = 0;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            if(freqt == freqs) return count;\\n            if(freqt[ch] < freqs[ch]) \\n                count += freqs[ch] - freqt[ch];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> freq;\\n        int count = 0;\\n        for(auto it : s) freq[it]++;\\n        for(auto it : t) freq[it]--;\\n        for(auto it : freq) if(it.second < 0) count += it.second;\\n        return abs(count);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int> freqs, freqt;\\n        for(int i = 0; i < s.size(); i++) \\n            freqs[s[i]]++, freqt[t[i]]++;\\n        \\n        int count = 0;\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch++){\\n            if(freqt == freqs) return count;\\n            if(freqt[ch] < freqs[ch]) \\n                count += freqs[ch] - freqt[ch];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1681607,
                "title": "c-simple-and-fast",
                "content": "Count the number of mismatches in both the strings and then divide the value by two to get the answer. Using a vector of size makes space complexity constant. \\n```\\nclass Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> mp (26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n          mp[s[i]-\\'a\\']++;\\n          mp[t[i]-\\'a\\']--;\\n        }\\n        int ans=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            ans+=abs(mp[i]);\\n        }\\n        return ans/2;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        vector<int> mp (26,0);\\n        for(int i=0;i<s.size();i++)\\n        {\\n          mp[s[i]-\\'a\\']++;\\n          mp[t[i]-\\'a\\']--;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1574868,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1574511,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1567014,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1763539,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1963108,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1855941,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            },
            {
                "id": 1745850,
                "content": [
                    {
                        "username": "james9277",
                        "content": "Should it be a easy instead of medium?"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "This must be an easy question"
                    },
                    {
                        "username": "balajisb147",
                        "content": "Why is this problem tagged under medium?\\nCan anyone explain why?\\nIs there anything special about this problem for being tagged under medium?\\n"
                    },
                    {
                        "username": "always_try",
                        "content": "**Simple Explanation:**\\n**1.** Length has given equal to each other ,so we don\\'t need to take care of that.\\n**2**. For our second string there are three case possible--\\n\\n**a.** Unknown element   (have an element which are not in first  string)\\n**b.** known element but in excess amount (means count of that char in second is more)\\n**c.** known element but in less amount (means count of that char in second is less)\\n\\nSo to make string second same to first , we need to convert case **\\'a\\'** and **\\'b\\'** to **\\'c\\'**.\\nor other way we can say that there are two way to find ans\\n***1.*** know element which are in less number (add the difference to get final ans)\\n***2.*** know element which are in excess number(add diff) + which are unknow element\\n\\nIf u have any doubt then comment \\nUPVOTE if it helps\\n"
                    },
                    {
                        "username": "sumeetrayat",
                        "content": "By this approach 1 the example 2 given ans should be 6"
                    },
                    {
                        "username": "Ankur_0152",
                        "content": "make a hash table for both and return s.length()-no_of_terms_matched;"
                    },
                    {
                        "username": "imarpitsingh",
                        "content": "class Solution {\\npublic:\\n    int minSteps(string s, string t) {\\n        unordered_map<char,int>m;\\n        unordered_map<char,int>p;\\n        for(auto i:s){\\n           m[i]++;\\n        }\\n        for(auto i :t){\\n            p[i]++;\\n        }\\n        if(m==p){\\n            return 0;\\n        }\\n        int count=0;\\n        for(auto i:m){\\n            if(p[i.first]>0){\\n                count=count+min(m[i.first],p[i.first]);\\n            }\\n        }\\n        return s.length()-count;\\n    }\\n};"
                    },
                    {
                        "username": "kieuwanlee4120",
                        "content": "If only use Hashmaps that would be O(n^2) for best time right ? (no dfs or backtracking)"
                    },
                    {
                        "username": "vincentverapen2012",
                        "content": "O(3n) = O(n)"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Easy peasy"
                    }
                ]
            }
        ]
    },
    {
        "title": "Tweet Counts Per Frequency",
        "question_content": "<p>A social media company is trying to monitor activity on their site by analyzing the number of tweets that occur in select periods of time. These periods can be partitioned into smaller <strong>time chunks</strong> based on a certain frequency (every <strong>minute</strong>, <strong>hour</strong>, or <strong>day</strong>).</p>\n\n<p>For example, the period <code>[10, 10000]</code> (in <strong>seconds</strong>) would be partitioned into the following <strong>time chunks</strong> with these frequencies:</p>\n\n<ul>\n\t<li>Every <strong>minute</strong> (60-second chunks): <code>[10,69]</code>, <code>[70,129]</code>, <code>[130,189]</code>, <code>...</code>, <code>[9970,10000]</code></li>\n\t<li>Every <strong>hour</strong> (3600-second chunks): <code>[10,3609]</code>, <code>[3610,7209]</code>, <code>[7210,10000]</code></li>\n\t<li>Every <strong>day</strong> (86400-second chunks): <code>[10,10000]</code></li>\n</ul>\n\n<p>Notice that the last chunk may be shorter than the specified frequency&#39;s chunk size and will always end with the end time of the period (<code>10000</code> in the above example).</p>\n\n<p>Design and implement an API to help the company with their analysis.</p>\n\n<p>Implement the <code>TweetCounts</code> class:</p>\n\n<ul>\n\t<li><code>TweetCounts()</code> Initializes the <code>TweetCounts</code> object.</li>\n\t<li><code>void recordTweet(String tweetName, int time)</code> Stores the <code>tweetName</code> at the recorded <code>time</code> (in <strong>seconds</strong>).</li>\n\t<li><code>List&lt;Integer&gt; getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)</code> Returns a list of integers representing the number of tweets with <code>tweetName</code> in each <strong>time chunk</strong> for the given period of time <code>[startTime, endTime]</code> (in <strong>seconds</strong>) and frequency <code>freq</code>.\n\t<ul>\n\t\t<li><code>freq</code> is one of <code>&quot;minute&quot;</code>, <code>&quot;hour&quot;</code>, or <code>&quot;day&quot;</code> representing a frequency of every <strong>minute</strong>, <strong>hour</strong>, or <strong>day</strong> respectively.</li>\n\t</ul>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;TweetCounts&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;getTweetCountsPerFrequency&quot;,&quot;recordTweet&quot;,&quot;getTweetCountsPerFrequency&quot;]\n[[],[&quot;tweet3&quot;,0],[&quot;tweet3&quot;,60],[&quot;tweet3&quot;,10],[&quot;minute&quot;,&quot;tweet3&quot;,0,59],[&quot;minute&quot;,&quot;tweet3&quot;,0,60],[&quot;tweet3&quot;,120],[&quot;hour&quot;,&quot;tweet3&quot;,0,210]]\n\n<strong>Output</strong>\n[null,null,null,null,[2],[2,1],null,[4]]\n\n<strong>Explanation</strong>\nTweetCounts tweetCounts = new TweetCounts();\ntweetCounts.recordTweet(&quot;tweet3&quot;, 0);                              // New tweet &quot;tweet3&quot; at time 0\ntweetCounts.recordTweet(&quot;tweet3&quot;, 60);                             // New tweet &quot;tweet3&quot; at time 60\ntweetCounts.recordTweet(&quot;tweet3&quot;, 10);                             // New tweet &quot;tweet3&quot; at time 10\ntweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 59); // return [2]; chunk [0,59] had 2 tweets\ntweetCounts.getTweetCountsPerFrequency(&quot;minute&quot;, &quot;tweet3&quot;, 0, 60); // return [2,1]; chunk [0,59] had 2 tweets, chunk [60,60] had 1 tweet\ntweetCounts.recordTweet(&quot;tweet3&quot;, 120);                            // New tweet &quot;tweet3&quot; at time 120\ntweetCounts.getTweetCountsPerFrequency(&quot;hour&quot;, &quot;tweet3&quot;, 0, 210);  // return [4]; chunk [0,210] had 4 tweets\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= time, startTime, endTime &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= endTime - startTime &lt;= 10<sup>4</sup></code></li>\n\t<li>There will be at most <code>10<sup>4</sup></code> calls <strong>in total</strong> to <code>recordTweet</code> and <code>getTweetCountsPerFrequency</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 503453,
                "title": "java-treemap-accepted-solution-easy-understand",
                "content": "\\n```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913366,
                "title": "i-hate-this-problem-use-map-o-n",
                "content": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(time);\\n            map.put(tweetName, temp);\\n        }else{\\n            map.get(tweetName).add(time);\\n        }\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        int interval = 60;\\n        if(freq.equals(\"hour\"))\\n            interval = interval * 60;\\n        if(freq.equals(\"day\"))\\n            interval = interval * 60 * 24;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // get the number of possible intervals, \\n        // if startTime = 30 and endTime = 150 with minute as freq\\n        // (150 - 30) / 60 = 2, this means there will be 3 intervals\\n        // [30, 90); [90, 150); [150, 150)\\n        for(int i = 0; i <= (endTime - startTime) / interval; i++)\\n            res.add(0);\\n        \\n        List<Integer> times = map.get(tweetName);\\n        for(int time : times){\\n            if(startTime <= time && time <= endTime){\\n                // get the index of which interval at current time\\n                int idx = (time - startTime) / interval;\\n                res.set(idx, res.get(idx)+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)){\\n            List<Integer> temp = new ArrayList<>();\\n            temp.add(time);\\n            map.put(tweetName, temp);\\n        }else{\\n            map.get(tweetName).add(time);\\n        }\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        int interval = 60;\\n        if(freq.equals(\"hour\"))\\n            interval = interval * 60;\\n        if(freq.equals(\"day\"))\\n            interval = interval * 60 * 24;\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // get the number of possible intervals, \\n        // if startTime = 30 and endTime = 150 with minute as freq\\n        // (150 - 30) / 60 = 2, this means there will be 3 intervals\\n        // [30, 90); [90, 150); [150, 150)\\n        for(int i = 0; i <= (endTime - startTime) / interval; i++)\\n            res.add(0);\\n        \\n        List<Integer> times = map.get(tweetName);\\n        for(int time : times){\\n            if(startTime <= time && time <= endTime){\\n                // get the index of which interval at current time\\n                int idx = (time - startTime) / interval;\\n                res.set(idx, res.get(idx)+1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503515,
                "title": "python3-linear-scan",
                "content": "Algorithm:\\nScan through the time for a given `tweetName` and add the count in the corresponding interval. \\n\\nImplementation: \\n```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = dict()\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets.setdefault(tweetName, []).append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\": seconds = 60 \\n        elif freq == \"hour\": seconds = 3600\\n        else: seconds = 86400\\n        \\n        ans = [0] * ((endTime - startTime)//seconds + 1)\\n        for t in self.tweets[tweetName]:\\n            if startTime <= t <= endTime: ans[(t-startTime)//seconds] += 1\\n        return ans \\n```\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = dict()\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets.setdefault(tweetName, []).append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\": seconds = 60 \\n        elif freq == \"hour\": seconds = 3600\\n        else: seconds = 86400\\n        \\n        ans = [0] * ((endTime - startTime)//seconds + 1)\\n        for t in self.tweets[tweetName]:\\n            if startTime <= t <= endTime: ans[(t-startTime)//seconds] += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 503447,
                "title": "python-binary-search",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.a = defaultdict(list)\\n\\n    def recordTweet(self, tn: str, time: int) -> None:\\n        bisect.insort(self.a[tn], time)\\n       \\n    def getTweetCountsPerFrequency(self, freq: str, tn: str, startTime: int, endTime: int) -> List[int]:\\n        delta = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n        i = startTime\\n        res = []\\n        while i <= endTime:\\n            j = min(i + delta, endTime+1)\\n            res.append(bisect_left(self.a[tn], j) - bisect_left(self.a[tn], i))\\n            i += delta\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.a = defaultdict(list)\\n\\n    def recordTweet(self, tn: str, time: int) -> None:\\n        bisect.insort(self.a[tn], time)\\n       \\n    def getTweetCountsPerFrequency(self, freq: str, tn: str, startTime: int, endTime: int) -> List[int]:\\n        delta = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n        i = startTime\\n        res = []\\n        while i <= endTime:\\n            j = min(i + delta, endTime+1)\\n            res.append(bisect_left(self.a[tn], j) - bisect_left(self.a[tn], i))\\n            i += delta\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504456,
                "title": "c-accepted-solution-with-map",
                "content": "\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, vector<int>>m;\\n    unordered_map<string, int>f = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400}};\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector <int>res;\\n        for (int i=0; i <= (endTime - startTime) / f[freq]; i++)\\n            res.push_back(0);\\n\\n        for (auto& time : m[tweetName]) {\\n            if (time >= startTime && time <= endTime) {\\n                int index = (time - startTime) / f[freq];\\n                res[index]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, vector<int>>m;\\n    unordered_map<string, int>f = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400}};\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector <int>res;\\n        for (int i=0; i <= (endTime - startTime) / f[freq]; i++)\\n            res.push_back(0);\\n\\n        for (auto& time : m[tweetName]) {\\n            if (time >= startTime && time <= endTime) {\\n                int index = (time - startTime) / f[freq];\\n                res[index]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503752,
                "title": "easy-to-read-python-solution",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dict = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if(tweetName not in self.dict):\\n            self.dict[tweetName] = [time]\\n        else:\\n            self.dict[tweetName].append(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        times = self.dict[tweetName]\\n        \\n        size = 0 \\n        secs = 0\\n        \\n        if(freq == \\'minute\\'):\\n            secs = 60\\n            size = (endTime - startTime) / 60 + 1\\n        if(freq == \\'hour\\'):\\n            secs = 3600\\n            size = (endTime - startTime) / 3600 + 1\\n        if(freq == \\'day\\'):\\n            secs = 86400\\n            size = (endTime - startTime) / 86400 + 1\\n                \\n        r = [0] * int(size)\\n        \\n        for i in times:\\n            if(startTime <= i and i <= endTime):\\n                index = int((i-startTime)/secs)\\n                r[index] += 1\\n\\n        return r\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dict = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if(tweetName not in self.dict):\\n            self.dict[tweetName] = [time]\\n        else:\\n            self.dict[tweetName].append(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        times = self.dict[tweetName]\\n        \\n        size = 0 \\n        secs = 0\\n        \\n        if(freq == \\'minute\\'):\\n            secs = 60\\n            size = (endTime - startTime) / 60 + 1\\n        if(freq == \\'hour\\'):\\n            secs = 3600\\n            size = (endTime - startTime) / 3600 + 1\\n        if(freq == \\'day\\'):\\n            secs = 86400\\n            size = (endTime - startTime) / 86400 + 1\\n                \\n        r = [0] * int(size)\\n        \\n        for i in times:\\n            if(startTime <= i and i <= endTime):\\n                index = int((i-startTime)/secs)\\n                r[index] += 1\\n\\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503920,
                "title": "short-c-lower-bound-solution",
                "content": "```\\nclass TweetCounts {\\n    unordered_map<string, multiset<int>> all;\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        all[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int d = 86400;\\n        if (freq[0] == \\'m\\') {\\n            d = 60;\\n        } else if (freq[0] == \\'h\\') {\\n            d = 3600;\\n        }\\n        vector<int> r((endTime - startTime) / d + 1);\\n        const auto s = all.find(tweetName);\\n        if (s != all.end()) {\\n            for (auto t = s->second.lower_bound(startTime); t != s->second.end() && *t <= endTime; ++t) {\\n               ++r[(*t - startTime) / d];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    unordered_map<string, multiset<int>> all;\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        all[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int d = 86400;\\n        if (freq[0] == \\'m\\') {\\n            d = 60;\\n        } else if (freq[0] == \\'h\\') {\\n            d = 3600;\\n        }\\n        vector<int> r((endTime - startTime) / d + 1);\\n        const auto s = all.find(tweetName);\\n        if (s != all.end()) {\\n            for (auto t = s->second.lower_bound(startTime); t != s->second.end() && *t <= endTime; ++t) {\\n               ++r[(*t - startTime) / d];\\n            }\\n        }\\n        return r;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503483,
                "title": "java-simple-tree-map-easy-to-understand",
                "content": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public TweetCounts() { \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tm = map.get(tweetName);\\n        tm.put(time, tm.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        if (!map.containsKey(tweetName)) return res;\\n        TreeMap<Integer, Integer> tm = map.get(tweetName);\\n        int gap = 60;\\n        if (freq.equals(\"hour\")) gap = 3600;\\n        else if (freq.equals(\"day\")) gap = 3600 * 24;\\n        for (int start = startTime; start < endTime + 1; start += gap) {\\n            int sum = 0;\\n            int end = Math.min(start + gap, endTime + 1);\\n            Map<Integer, Integer> sm = tm.subMap(start, end);\\n            for (int value : sm.values()) sum += value;\\n            res.add(sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map = new HashMap<>();\\n    public TweetCounts() { \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tm = map.get(tweetName);\\n        tm.put(time, tm.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        if (!map.containsKey(tweetName)) return res;\\n        TreeMap<Integer, Integer> tm = map.get(tweetName);\\n        int gap = 60;\\n        if (freq.equals(\"hour\")) gap = 3600;\\n        else if (freq.equals(\"day\")) gap = 3600 * 24;\\n        for (int start = startTime; start < endTime + 1; start += gap) {\\n            int sum = 0;\\n            int end = Math.min(start + gap, endTime + 1);\\n            Map<Integer, Integer> sm = tm.subMap(start, end);\\n            for (int value : sm.values()) sum += value;\\n            res.add(sum);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630979,
                "title": "python3-straightforward-in-o-n",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        frequency = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400 \\n        # total chunks \\n        chunks = (endTime - startTime) // frequency + 1\\n        res = [0] * chunks\\n        for time in self.tweets[tweetName]:\\n            # figure out in which time chunk does the time belong and then update the result array\\n            if time >= startTime and time <= endTime:\\n                chunk = (time - startTime) // frequency\\n                res[chunk] += 1\\n        return res\\n```\\nAm I missing something or this is trivial? Really no algo needed just a hashmap\\n\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        frequency = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400 \\n        # total chunks \\n        chunks = (endTime - startTime) // frequency + 1\\n        res = [0] * chunks\\n        for time in self.tweets[tweetName]:\\n            # figure out in which time chunk does the time belong and then update the result array\\n            if time >= startTime and time <= endTime:\\n                chunk = (time - startTime) // frequency\\n                res[chunk] += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511282,
                "title": "simple-java-solution-with-hashmap-of-treeset-cheating-using-double",
                "content": "We can maintain the `TreeSet` for each tweet which records the timestamp at which the tweet occurs. Afterwards, it\\'s as simple as using TreeSet\\'s built-in range queries.\\n\\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Integer>> map = new HashMap();\\n    Map<String, Integer> meta = new HashMap();\\n    public TweetCounts() {\\n        \\n        meta.put(\"minute\", 60);\\n        meta.put(\"hour\", 3600);\\n        meta.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        map.computeIfAbsent(tweetName, t -> new TreeSet<Integer>()).add(time);\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Integer> subset = (TreeSet) map.getOrDefault(tweetName, new TreeSet<Integer>()).subSet(startTime, true, endTime, true);\\n        \\n        List<Integer> out = new ArrayList();\\n        \\n        int chunk = meta.get(freq);\\n            \\n        for(int i = startTime; i <= endTime; i = i + chunk ) {\\n\\n            out.add(subset.subSet(i, true, Math.min(i + chunk-1, endTime), true).size());\\n        }\\n        return out;\\n    }\\n}\\n```\\n\\nHowever, the above solution fails for the following test-case because `[tweet3, 10]` has to be recorded twice. In my view, either this might NOT be a valid real-world use-case or the problem is worded poorly. How can a same tweet be recorded twice with the same timestamp? <aybe instead of `recordTweet`, they can say `recordTweetActivity` which represents an activity associated with the tweet which can happen simultaneously (e.g. two users might like `tweet3` at timestamp 10). `TreeSet` solution fails as it can not store duplicate records.\\n\\n```\\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\\n```\\n\\nIn order, get around these testcases, we can use the following solutions.\\n\\nInstead of `TreeSet`, we can use `TreeMap` and its subsequent `subMap` range queries. This allows us to store duplicate records. Example - https://leetcode.com/problems/tweet-counts-per-frequency/discuss/503453/Java-TreeMap-Accepted-Solution-Easy-Understand\\n\\nOR\\n\\nWe can have some fun and hack our way into using `TreeSet<Double>` as well to store duplicate records. This is not an ideal solution (but like problem, like solution). The trick is - for duplicate timestamps, we will insert a random double value between `timestamp` and `timestamp + 1` and `TreeSet` range queries will work. Why?  \\n\\n1. There are infinitely many real numbers present between `timestamp` and `timestamp+1`, so we will never hit a collision case. \\n2. `minute`, `hour`, and `day` have integer precision. Thus, range queries will work because we are squeezing the repeated number between its next integer value.\\n\\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Double>> map = new HashMap();\\n    Map<String, Integer> meta = new HashMap();\\n    public TweetCounts() {\\n        \\n        meta.put(\"minute\", 60);\\n        meta.put(\"hour\", 3600);\\n        meta.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        Double thack = new Double(time);\\n        while(!map.computeIfAbsent(tweetName, t -> new TreeSet<Double>()).add(thack)) {\\n            thack = thack + new Random().nextDouble();\\n        }\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Double> subset = (TreeSet) map.getOrDefault(tweetName, new TreeSet<Double>()).subSet(new Double(startTime), true, new Double(endTime), true);\\n        \\n        List<Integer> out = new ArrayList();\\n        \\n        int chunk = meta.get(freq);\\n            \\n        for(int i = startTime; i <= endTime; i = i + chunk ) {\\n\\n            out.add(subset.subSet(new Double(i), true, new Double(Math.min(i + chunk-1, endTime)), true).size());\\n        }\\n        return out;\\n    }\\n}\\n```\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Integer>> map = new HashMap();\\n    Map<String, Integer> meta = new HashMap();\\n    public TweetCounts() {\\n        \\n        meta.put(\"minute\", 60);\\n        meta.put(\"hour\", 3600);\\n        meta.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        map.computeIfAbsent(tweetName, t -> new TreeSet<Integer>()).add(time);\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Integer> subset = (TreeSet) map.getOrDefault(tweetName, new TreeSet<Integer>()).subSet(startTime, true, endTime, true);\\n        \\n        List<Integer> out = new ArrayList();\\n        \\n        int chunk = meta.get(freq);\\n            \\n        for(int i = startTime; i <= endTime; i = i + chunk ) {\\n\\n            out.add(subset.subSet(i, true, Math.min(i + chunk-1, endTime), true).size());\\n        }\\n        return out;\\n    }\\n}\\n```\n```\\n[\"TweetCounts\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"recordTweet\",\"getTweetCountsPerFrequency\",\"getTweetCountsPerFrequency\",\"recordTweet\",\"getTweetCountsPerFrequency\"]\\n[[],[\"tweet3\",0],[\"tweet3\",60],[\"tweet3\",10],[\"tweet3\",10],[\"minute\",\"tweet3\",0,59],[\"minute\",\"tweet3\",0,60],[\"tweet3\",120],[\"hour\",\"tweet3\",0,210]]\\n```\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Double>> map = new HashMap();\\n    Map<String, Integer> meta = new HashMap();\\n    public TweetCounts() {\\n        \\n        meta.put(\"minute\", 60);\\n        meta.put(\"hour\", 3600);\\n        meta.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        Double thack = new Double(time);\\n        while(!map.computeIfAbsent(tweetName, t -> new TreeSet<Double>()).add(thack)) {\\n            thack = thack + new Random().nextDouble();\\n        }\\n        \\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Double> subset = (TreeSet) map.getOrDefault(tweetName, new TreeSet<Double>()).subSet(new Double(startTime), true, new Double(endTime), true);\\n        \\n        List<Integer> out = new ArrayList();\\n        \\n        int chunk = meta.get(freq);\\n            \\n        for(int i = startTime; i <= endTime; i = i + chunk ) {\\n\\n            out.add(subset.subSet(new Double(i), true, new Double(Math.min(i + chunk-1, endTime)), true).size());\\n        }\\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236601,
                "title": "c-concise-lower-bound-starttime-upper-bound-end-time",
                "content": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweets_[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = freq[0] == \\'m\\' ? 60 : (freq[0] == \\'h\\' ? 3600 : 86400);\\n        const auto& times = tweets_[tweetName];\\n        vector<int> result(((endTime - startTime) / interval) + 1);\\n        const auto& end = times.upper_bound(endTime);\\n        for (auto it = times.lower_bound(startTime); it != end; it++) {\\n           result[(it->first - startTime) / interval] += it->second;\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, int>> tweets_;\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweets_[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = freq[0] == \\'m\\' ? 60 : (freq[0] == \\'h\\' ? 3600 : 86400);\\n        const auto& times = tweets_[tweetName];\\n        vector<int> result(((endTime - startTime) / interval) + 1);\\n        const auto& end = times.upper_bound(endTime);\\n        for (auto it = times.lower_bound(startTime); it != end; it++) {\\n           result[(it->first - startTime) / interval] += it->second;\\n        }\\n        return result;\\n    }\\n    \\nprivate:\\n    unordered_map<string, map<int, int>> tweets_;\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103544,
                "title": "easy-binary-search-tree-in-java",
                "content": "Hence this question requires a binary search to find number of tweets in a given interval, one could easily implement an array and have binary search approach to insert new tweets in the array. Implementing binary tree would cut the search and insert from O(n) to O(logn).\\n\\nTake a look at the code in java below.\\n\\n```\\nclass TweetCounts {\\n    \\n    private class TreeNode {\\n        \\n        private int val;\\n        private TreeNode left;\\n        private TreeNode right;\\n        \\n        private TreeNode(int data) {\\n            val = data;\\n            left = null;\\n            right = null;\\n        }\\n        \\n    }\\n    \\n    private Map<String, TreeNode> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) {\\n            root = new TreeNode(val);\\n        }\\n        else if (root.val <= val) {\\n            root.right = insert(root.right, val);\\n        }\\n        else {\\n            root.left = insert(root.left, val);\\n        }\\n        return root;\\n    }\\n    \\n    public void recordTweet(String name, int time) {\\n        TreeNode root = map.get(name);\\n        root = insert(root, time);\\n        map.put(name, root);\\n    }\\n    \\n    private int treverse(TreeNode root, int l, int r) {\\n        if (root == null || l >= r) {\\n            return 0;\\n        }\\n        if (root.val <= l) {\\n            int add = root.val == l ? 1 : 0;\\n            return add + treverse(root.right, l, r);\\n        }\\n        if (root.val >= r) {\\n            return treverse(root.left, l, r);\\n        }\\n        return 1 + treverse(root.left, l, r) + treverse(root.right, l, r);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String name, int start, int end) {\\n        int d = 0;\\n        TreeNode root = map.get(name);\\n        List<Integer> res = new ArrayList<>();\\n        if (freq.equals(\"minute\")) {\\n            d = 60;\\n        }\\n        else if (freq.equals(\"hour\")) {\\n            d = 3600;\\n        }\\n        else {\\n            d = 86400;\\n        }\\n        while (start + d <= end) {\\n            int count = treverse(root, start, start + d);\\n            start = start + d;\\n            res.add(count);\\n        }\\n        if (start <= end) {\\n            int count = treverse(root, start, end + 1);\\n            res.add(count);\\n            start = end + 1;\\n        }\\n        return res;\\n    }\\n    \\n}\\n ```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass TweetCounts {\\n    \\n    private class TreeNode {\\n        \\n        private int val;\\n        private TreeNode left;\\n        private TreeNode right;\\n        \\n        private TreeNode(int data) {\\n            val = data;\\n            left = null;\\n            right = null;\\n        }\\n        \\n    }\\n    \\n    private Map<String, TreeNode> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    private TreeNode insert(TreeNode root, int val) {\\n        if (root == null) {\\n            root = new TreeNode(val);\\n        }\\n        else if (root.val <= val) {\\n            root.right = insert(root.right, val);\\n        }\\n        else {\\n            root.left = insert(root.left, val);\\n        }\\n        return root;\\n    }\\n    \\n    public void recordTweet(String name, int time) {\\n        TreeNode root = map.get(name);\\n        root = insert(root, time);\\n        map.put(name, root);\\n    }\\n    \\n    private int treverse(TreeNode root, int l, int r) {\\n        if (root == null || l >= r) {\\n            return 0;\\n        }\\n        if (root.val <= l) {\\n            int add = root.val == l ? 1 : 0;\\n            return add + treverse(root.right, l, r);\\n        }\\n        if (root.val >= r) {\\n            return treverse(root.left, l, r);\\n        }\\n        return 1 + treverse(root.left, l, r) + treverse(root.right, l, r);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String name, int start, int end) {\\n        int d = 0;\\n        TreeNode root = map.get(name);\\n        List<Integer> res = new ArrayList<>();\\n        if (freq.equals(\"minute\")) {\\n            d = 60;\\n        }\\n        else if (freq.equals(\"hour\")) {\\n            d = 3600;\\n        }\\n        else {\\n            d = 86400;\\n        }\\n        while (start + d <= end) {\\n            int count = treverse(root, start, start + d);\\n            start = start + d;\\n            res.add(count);\\n        }\\n        if (start <= end) {\\n            int count = treverse(root, start, end + 1);\\n            res.add(count);\\n            start = end + 1;\\n        }\\n        return res;\\n    }\\n    \\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 688197,
                "title": "simple-java-solution-with-map-and-treeset",
                "content": "```\\nclass TweetCounts {\\n\\n    HashMap<String,TreeSet<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeSet<Integer> set = map.getOrDefault(tweetName, new TreeSet<>());\\n        set.add(time);\\n        map.put(tweetName,set);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Integer> set = map.getOrDefault(tweetName, new TreeSet<>());\\n        int delta = deltaG(freq);\\n        List<Integer> frequencies = new ArrayList<>();\\n        for (int start = startTime; start <= endTime; start += delta) {\\n            int end = Math.min(start + delta, endTime + 1);\\n            SortedSet<Integer> sub = set.subSet(start, end);\\n            frequencies.add(sub.size());\\n        }\\n        return frequencies;\\n    }\\n    \\n    private int deltaG(String freq){\\n        if(freq.equals(\"minute\")) return 60;\\n        else if(freq.equals(\"hour\")) return 3600;\\n        return 86400;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    HashMap<String,TreeSet<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeSet<Integer> set = map.getOrDefault(tweetName, new TreeSet<>());\\n        set.add(time);\\n        map.put(tweetName,set);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        TreeSet<Integer> set = map.getOrDefault(tweetName, new TreeSet<>());\\n        int delta = deltaG(freq);\\n        List<Integer> frequencies = new ArrayList<>();\\n        for (int start = startTime; start <= endTime; start += delta) {\\n            int end = Math.min(start + delta, endTime + 1);\\n            SortedSet<Integer> sub = set.subSet(start, end);\\n            frequencies.add(sub.size());\\n        }\\n        return frequencies;\\n    }\\n    \\n    private int deltaG(String freq){\\n        if(freq.equals(\"minute\")) return 60;\\n        else if(freq.equals(\"hour\")) return 3600;\\n        return 86400;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503904,
                "title": "segmenttree-solution",
                "content": "```\\nclass SegmentTree{\\n    SegmentTree left, right;\\n    long from, to;\\n    long sum;\\n    public SegmentTree(long f, long t){\\n        from = f;\\n        to = t;\\n    }\\n    public void insert(long p, long v){\\n        long mid = from + (to - from) / 2;\\n        if (left == null){\\n            left = new SegmentTree(from, mid);\\n        }\\n        if (right == null){\\n            right = new SegmentTree(mid, to);\\n        }\\n        if (p == from && p + 1 == to){\\n            sum += v;\\n            return;\\n        }\\n        if (p < mid){\\n            left.insert(p, v);\\n        }else{\\n            right.insert(p, v);\\n        }\\n        sum = left.sum + right.sum;\\n    }\\n    public int getSum(long f, long t){\\n        long mid = from + (to - from) / 2;\\n        if (f == from && t == to){\\n            return (int)sum;\\n        }\\n        if (t <= mid){\\n            return left == null ? 0 : left.getSum(f, t);\\n        }else if (f >= mid){\\n            return right == null ? 0: right.getSum(f, t);\\n        }\\n        return  (left == null ? 0 : left.getSum(f, mid)) + (right == null ? 0 : right.getSum(mid, t));\\n    }\\n}\\nclass TweetCounts {\\n    Map<String, SegmentTree> mp;\\n    Map<String, Integer> freqMap;\\n    public TweetCounts() {\\n        mp = new HashMap<>();\\n        freqMap = new HashMap<>();\\n        freqMap.put(\"minute\", 60);\\n        freqMap.put(\"hour\", 60 * 60);\\n        freqMap.put(\"day\", 24 * 60 * 60);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        mp.compute(tweetName, (k, v) -> v == null ? new SegmentTree(0, 1000000005) : v).insert(time, 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int step = freqMap.getOrDefault(freq, 24 * 60 * 60);\\n        List<Integer> ans = new ArrayList<>();\\n        if (!mp.containsKey(tweetName)){\\n            return ans;\\n        }\\n        for (int i = startTime; i <= endTime; i += step){\\n            SegmentTree root = mp.get(tweetName);\\n            ans.add(root.getSum(i, Math.min(i + step, endTime + 1)));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree{\\n    SegmentTree left, right;\\n    long from, to;\\n    long sum;\\n    public SegmentTree(long f, long t){\\n        from = f;\\n        to = t;\\n    }\\n    public void insert(long p, long v){\\n        long mid = from + (to - from) / 2;\\n        if (left == null){\\n            left = new SegmentTree(from, mid);\\n        }\\n        if (right == null){\\n            right = new SegmentTree(mid, to);\\n        }\\n        if (p == from && p + 1 == to){\\n            sum += v;\\n            return;\\n        }\\n        if (p < mid){\\n            left.insert(p, v);\\n        }else{\\n            right.insert(p, v);\\n        }\\n        sum = left.sum + right.sum;\\n    }\\n    public int getSum(long f, long t){\\n        long mid = from + (to - from) / 2;\\n        if (f == from && t == to){\\n            return (int)sum;\\n        }\\n        if (t <= mid){\\n            return left == null ? 0 : left.getSum(f, t);\\n        }else if (f >= mid){\\n            return right == null ? 0: right.getSum(f, t);\\n        }\\n        return  (left == null ? 0 : left.getSum(f, mid)) + (right == null ? 0 : right.getSum(mid, t));\\n    }\\n}\\nclass TweetCounts {\\n    Map<String, SegmentTree> mp;\\n    Map<String, Integer> freqMap;\\n    public TweetCounts() {\\n        mp = new HashMap<>();\\n        freqMap = new HashMap<>();\\n        freqMap.put(\"minute\", 60);\\n        freqMap.put(\"hour\", 60 * 60);\\n        freqMap.put(\"day\", 24 * 60 * 60);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        mp.compute(tweetName, (k, v) -> v == null ? new SegmentTree(0, 1000000005) : v).insert(time, 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int step = freqMap.getOrDefault(freq, 24 * 60 * 60);\\n        List<Integer> ans = new ArrayList<>();\\n        if (!mp.containsKey(tweetName)){\\n            return ans;\\n        }\\n        for (int i = startTime; i <= endTime; i += step){\\n            SegmentTree root = mp.get(tweetName);\\n            ans.add(root.getSum(i, Math.min(i + step, endTime + 1)));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 979544,
                "title": "clean-python-bisect-solution",
                "content": "```\\nimport bisect\\nclass TweetCounts:\\n    FREQS = {\\n        \\'minute\\': 60,\\n        \\'hour\\': 60 * 60,\\n        \\'day\\': 60 * 60 * 24\\n    }\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        bisect.insort(self.tweets[tweetName], time)\\n    \\n    def bucket(self, timeDelta, intervalTime):\\n        return (timeDelta // intervalTime)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        tweets = self.tweets[tweetName]\\n        if not tweets:\\n            return []\\n\\n        interval = self.FREQS[freq]\\n        output = [0] * (self.bucket((endTime-startTime), interval) + 1)\\n        start = bisect.bisect_left(tweets, startTime)\\n        end = bisect.bisect_right(tweets, endTime)\\n\\n        for i in range(start, end):\\n            output[self.bucket(tweets[i]-startTime,interval)] += 1\\n        return output\\n```\\n\\nThe tripping points of this problem are mainly:\\n* keeping the times sorted, or deciding to sort on each query\\n* figuring out how many buckets should be in the output\\n* which bucket each time interval falls into\\n\\nLet\\'s approach each individually.\\n\\n**Maintaining Sorted Tweet Times**\\nMaintaining sorted lists means O(logN) insertion time for each new element (overall, O(NlogN) when N elements are added total). This is versus sorting for each query, which is O(NlogN) for each query - so for M queries, this costs M * NlogN.\\n\\nMaintaining a sorted input also means there is no need to iterate through every single item in `tweets`, as we can use binary search to find the start and end indices.\\n\\n**How many buckets for the output?**\\nThere is at least one bucket, even if the total amount of time is less than our time interval. For example, if we want a per-minute frequency but only look at 30 seconds, that\\'s still one (parital) bucket. If we wanted 90 seconds and a per-minute frequency, that\\'s one full bucket (0-59 seconds) and one partial bucket (60-90). If we end the time interval exactly on the end of a bucket, like 119 seconds, we get 2 full buckets and no partial buckets (0-59, 60-119).\\n\\nThe answer of \"how many buckets\" boils down to \"how many times can I fit all or part of the interval in seconds, into the total timespan in seconds? One way to calculate this is to divide the total timespan by the intervals, and take the ceiling. Since `math.ceil()` will always round up to the next natural integer, it accounts for the case where there is a parital interval as well as only whole intervals.\\n\\n**Which bucket should I increment for a given time?**\\n\\nIn some similar \"bucketing\" problems, it\\'s possible to iterate over the elements themselves, and when a condition is reached that means the nexk bucket should be started, to append the current (now completed) bucket to the output, and reset it to 0/[]. However, in our case, we might have a jump between one time and the next that skips over an interval entirely. Consider this more trivial example:\\n\\n```\\nnums = [1,2,3,9,10,11]\\ninterval = 5\\n# the goal is to group numbers into intervals of 5 (1-indexed), like this:\\n# expected = [[1,2,3], [9,10], [11]]\\n\\n# we might be tempted to write:\\n# note: THIS CODE IS WRONG for this problem!\\nnext_interval = (1 + interval)  # 6\\ncurr_bucket = []\\noutput = []\\nfor item in nums:\\n    if item >= next_interval:\\n\\t    output.append(curr_bucket)\\n\\t\\tcurr_bucket = [item]\\n\\t\\tnext_interval += interval\\n\\telse:\\n\\t    curr_bucket.append(item)\\noutput.append(curr_bucket)\\nreturn output\\n```\\n\\nThis works, because there is at least one element in each bucket. But what about this input:\\n\\n```\\nnums = [1,2,3,4,5,34, 70]\\nexpected = [[1,2,3,4,5], [34]]\\n```\\nThe code would get to 34, notice that it\\'s greater than `6`, and reset `next_interval` to `11`. Now, the state is:\\n```\\nnext_interval = 11\\nitem = 34\\ncurr_bucket = [34]\\noutput = [[1,2,3,4,5]]\\n```\\n\\nOn the next iteration, we would have:\\n```\\nnext_interval = 11\\nitem = 70\\ncurr_bucket = [34, 70]\\noutput = [[1,2,3,4,5]]\\n```\\n\\nIn other words, `next_interval` has not kept up with how far we are into the possible values in `nums`. We\\'ll never reach 11 because we\\'ve already passed it. Instead of assuming we have at least one item for each bucket we want to populate, we should instead calculate which bucket it belongs to.\\n\\nIn the solution, there is a method used to do this calculation. For the case where we need to figure out how many buckets we need, we realize that for our `output` array, the \"first\" bucket will actually be at `index=0` - so if we calculate the last possible value in our input set\\'s bucket *index*, that gives us a way to find the total length of the output array by adding 1.\\n\\n*Note: this does not work exactly like this in Python2, as Py2 handles division differently. To make it work in Python2, convert the numerator to a float, e.g. `float(totaltimespan) / interval`. Alternately, use `from __future__ import division` See [1]*\\n\\n\\n\\n\\n[1] https://python-history.blogspot.com/2009/03/problem-with-integer-division.html\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nclass TweetCounts:\\n    FREQS = {\\n        \\'minute\\': 60,\\n        \\'hour\\': 60 * 60,\\n        \\'day\\': 60 * 60 * 24\\n    }\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        bisect.insort(self.tweets[tweetName], time)\\n    \\n    def bucket(self, timeDelta, intervalTime):\\n        return (timeDelta // intervalTime)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        tweets = self.tweets[tweetName]\\n        if not tweets:\\n            return []\\n\\n        interval = self.FREQS[freq]\\n        output = [0] * (self.bucket((endTime-startTime), interval) + 1)\\n        start = bisect.bisect_left(tweets, startTime)\\n        end = bisect.bisect_right(tweets, endTime)\\n\\n        for i in range(start, end):\\n            output[self.bucket(tweets[i]-startTime,interval)] += 1\\n        return output\\n```\n```\\nnums = [1,2,3,9,10,11]\\ninterval = 5\\n# the goal is to group numbers into intervals of 5 (1-indexed), like this:\\n# expected = [[1,2,3], [9,10], [11]]\\n\\n# we might be tempted to write:\\n# note: THIS CODE IS WRONG for this problem!\\nnext_interval = (1 + interval)  # 6\\ncurr_bucket = []\\noutput = []\\nfor item in nums:\\n    if item >= next_interval:\\n\\t    output.append(curr_bucket)\\n\\t\\tcurr_bucket = [item]\\n\\t\\tnext_interval += interval\\n\\telse:\\n\\t    curr_bucket.append(item)\\noutput.append(curr_bucket)\\nreturn output\\n```\n```\\nnums = [1,2,3,4,5,34, 70]\\nexpected = [[1,2,3,4,5], [34]]\\n```\n```\\nnext_interval = 11\\nitem = 34\\ncurr_bucket = [34]\\noutput = [[1,2,3,4,5]]\\n```\n```\\nnext_interval = 11\\nitem = 70\\ncurr_bucket = [34, 70]\\noutput = [[1,2,3,4,5]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653180,
                "title": "simple-c-solution",
                "content": "```\\nclass TweetCounts {\\nprivate:\\n    unordered_map<string,vector<int>> TweetTimes;\\n    \\npublic:\\n    TweetCounts() { }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        TweetTimes[tweetName].push_back(time);      //store the time under the tweetname\\n        return;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if (!TweetTimes.count(tweetName)) return {0};\\n        int f = (freq[0] == \\'m\\')? 60 : (freq[0] == \\'h\\')? 3600 : 86400; \\n        vector<int> ans((endTime-startTime)/f + 1, 0); \\n        for (auto& t : TweetTimes[tweetName]){\\n            if (t < startTime || t > endTime) continue;\\n            ans[(t-startTime)/f]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\nprivate:\\n    unordered_map<string,vector<int>> TweetTimes;\\n    \\npublic:\\n    TweetCounts() { }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        TweetTimes[tweetName].push_back(time);      //store the time under the tweetname\\n        return;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if (!TweetTimes.count(tweetName)) return {0};\\n        int f = (freq[0] == \\'m\\')? 60 : (freq[0] == \\'h\\')? 3600 : 86400; \\n        vector<int> ans((endTime-startTime)/f + 1, 0); \\n        for (auto& t : TweetTimes[tweetName]){\\n            if (t < startTime || t > endTime) continue;\\n            ans[(t-startTime)/f]++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144053,
                "title": "python-binary-search-time-100-mem-100",
                "content": "```\\nclass TweetCounts(object):\\n    \\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        \\n        \\n    def recordTweet(self, name, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        if name not in self.tweets:\\n            self.tweets[name].append(time)\\n        else:\\n            idx = bisect.bisect(self.tweets[name], time)\\n            self.tweets[name].insert(idx, time)\\n            \\n        \\n    def getTweetCountsPerFrequency(self, freq, name, start, end):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if name not in self.tweets:\\n            return []\\n        \\n        def get_interval(freq):\\n            if freq == \"minute\":\\n                return 60\\n            elif freq == \"hour\":\\n                return 3600\\n            elif freq == \"day\":\\n                return 86400\\n        \\n        interval = get_interval(freq)\\n        size = ((end - start)/interval) + 1\\n        buckets = [0]*size\\n        \\n        i = bisect.bisect_left(self.tweets[name], start)\\n        j = bisect.bisect_right(self.tweets[name], end)\\n        times = self.tweets[name][i:j]\\n        for t in times:\\n            k = (t-start)//interval\\n            buckets[k] += 1\\n        \\n        return buckets\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts(object):\\n    \\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        \\n        \\n    def recordTweet(self, name, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        if name not in self.tweets:\\n            self.tweets[name].append(time)\\n        else:\\n            idx = bisect.bisect(self.tweets[name], time)\\n            self.tweets[name].insert(idx, time)\\n            \\n        \\n    def getTweetCountsPerFrequency(self, freq, name, start, end):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if name not in self.tweets:\\n            return []\\n        \\n        def get_interval(freq):\\n            if freq == \"minute\":\\n                return 60\\n            elif freq == \"hour\":\\n                return 3600\\n            elif freq == \"day\":\\n                return 86400\\n        \\n        interval = get_interval(freq)\\n        size = ((end - start)/interval) + 1\\n        buckets = [0]*size\\n        \\n        i = bisect.bisect_left(self.tweets[name], start)\\n        j = bisect.bisect_right(self.tweets[name], end)\\n        times = self.tweets[name][i:j]\\n        for t in times:\\n            k = (t-start)//interval\\n            buckets[k] += 1\\n        \\n        return buckets\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922832,
                "title": "100-00-runtime-fast-short-binary-search-solution",
                "content": "Binary search with [bisect](https://docs.python.org/3/library/bisect.html) is a great fit for this problem. For reference:\\n**bisect_left**: \"...the insertion point will be before (to the left of) any existing entries...\"\\nbisect/**bisect_right** (both does same): \"...returns an insertion point which comes after (to the right of) any existing entries...\"\\n\\nSo when we search *startTime* with **bisect_left** and *endTime* with **bisect_right**, we will get the enclosing range of all the tweets we need to count. The rest is an easy accounting with slicing it to the periods based on the frequency.\\n\\n```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right, insort\\nclass TweetCounts(object):\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        insort(self.tweets[tweetName],time)\\n        \\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        period = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\'else 86400\\n        result = [0] * ((endTime-startTime)//period + 1)\\n        startIndex = bisect_left(self.tweets[tweetName], startTime)\\n        endIndex = bisect_right(self.tweets[tweetName], endTime)\\n        for i in range(startIndex, endIndex):\\n            timeblock = (self.tweets[tweetName][i] - startTime) //period\\n            result[timeblock] += 1\\n        return result\\n```\\n\\n### Why does this beat other bisect based solutions? \\nWe run binary search once while other posted solutions I noted keep updating it at every frequency start in the for loop. For example if the query is for minute frequency and the reported period is k minutes:\\nThis solution: ***O(logN + K)***\\nOther bisect solutions: ***O(K logN)***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import bisect_left, bisect_right, insort\\nclass TweetCounts(object):\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        insort(self.tweets[tweetName],time)\\n        \\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        period = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\'else 86400\\n        result = [0] * ((endTime-startTime)//period + 1)\\n        startIndex = bisect_left(self.tweets[tweetName], startTime)\\n        endIndex = bisect_right(self.tweets[tweetName], endTime)\\n        for i in range(startIndex, endIndex):\\n            timeblock = (self.tweets[tweetName][i] - startTime) //period\\n            result[timeblock] += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518845,
                "title": "javascript-easy-to-understand-map-bst",
                "content": "## Map\\n\\nActually, I don\\'t get the point of this problem.\\nI just follow the description and to implement it.\\n\\n- recordTweet\\n\\t- Using a map to store the tweet name and its time list.\\n- getTweetCountsPerFrequency\\n\\t- Calculate the interval count.\\n\\t- Traversal the time list to fill the result array.\\n\\n```js\\nclass TweetCounts {\\n  constructor() {\\n    this.freqInterval = {\\n      minute: 60,\\n      hour: 3600,\\n      day: 86400,\\n    };\\n    this.data = new Map();\\n  }\\n\\n  recordTweet(name, time) {\\n    if (this.data.has(name) === false) {\\n      this.data.set(name, []);\\n    }\\n    this.data.get(name).push(time);\\n  }\\n\\n  getTweetCountsPerFrequency(freq, name, start, end) {\\n    const interval = this.freqInterval[freq];\\n    const ret = new Uint16Array(Math.ceil((end - start + 1) / interval));\\n    if (this.data.has(name)) {\\n      for (const time of this.data.get(name)) {\\n        if (time > end || time < start) continue;\\n        ++ret[Math.floor((time - start + 1) / interval)];\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n\\n## BST\\n\\nWe could use a binary search tree to optimize it.\\nActually, a self-balanced binary search tree is better. But JS has no such native data structure. And I don\\'t wanna write too much code. So I just use a simple binary search tree here.\\n\\n```js\\nconst createNode = val => ({ val, left: null, right: null });\\nclass BinarySearchTree {\\n  constructor() {\\n    this.root = null;\\n  }\\n  insert(val, cur = this.root) {\\n    const node = createNode(val);\\n    if (!this.root) { this.root = node; return; }\\n    if (val >= cur.val) {\\n      !cur.right ? (cur.right = node) : this.insert(val, cur.right);\\n    } else {\\n      !cur.left ? (cur.left = node) : this.insert(val, cur.left);\\n    }\\n  }\\n  traversal(low, high, interval, intervals, cur = this.root) {\\n    if (!cur) return;\\n    if (cur.val <= high && cur.val >= low) {\\n      ++intervals[Math.floor((cur.val - low + 1) / interval)];\\n    }\\n    cur.val > low && this.traversal(low, high, interval, intervals, cur.left);\\n    cur.val < high && this.traversal(low, high, interval, intervals, cur.right);\\n  }\\n};\\nclass TweetCounts {\\n  constructor() {\\n    this.freqInterval = {\\n      minute: 60,\\n      hour: 3600,\\n      day: 86400,\\n    };\\n    this.data = new Map();\\n  }\\n\\n  recordTweet(name, time) {\\n    if (this.data.has(name) === false) {\\n      this.data.set(name, new BinarySearchTree());\\n    }\\n    this.data.get(name).insert(time);\\n  }\\n\\n  getTweetCountsPerFrequency(freq, name, start, end) {\\n    const interval = this.freqInterval[freq];\\n    const ret = new Uint16Array(Math.ceil((end - start + 1) / interval));\\n    this.data.has(name) && this.data.get(name).traversal(start, end, interval, ret);\\n    return ret;\\n  }\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nclass TweetCounts {\\n  constructor() {\\n    this.freqInterval = {\\n      minute: 60,\\n      hour: 3600,\\n      day: 86400,\\n    };\\n    this.data = new Map();\\n  }\\n\\n  recordTweet(name, time) {\\n    if (this.data.has(name) === false) {\\n      this.data.set(name, []);\\n    }\\n    this.data.get(name).push(time);\\n  }\\n\\n  getTweetCountsPerFrequency(freq, name, start, end) {\\n    const interval = this.freqInterval[freq];\\n    const ret = new Uint16Array(Math.ceil((end - start + 1) / interval));\\n    if (this.data.has(name)) {\\n      for (const time of this.data.get(name)) {\\n        if (time > end || time < start) continue;\\n        ++ret[Math.floor((time - start + 1) / interval)];\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```js\\nconst createNode = val => ({ val, left: null, right: null });\\nclass BinarySearchTree {\\n  constructor() {\\n    this.root = null;\\n  }\\n  insert(val, cur = this.root) {\\n    const node = createNode(val);\\n    if (!this.root) { this.root = node; return; }\\n    if (val >= cur.val) {\\n      !cur.right ? (cur.right = node) : this.insert(val, cur.right);\\n    } else {\\n      !cur.left ? (cur.left = node) : this.insert(val, cur.left);\\n    }\\n  }\\n  traversal(low, high, interval, intervals, cur = this.root) {\\n    if (!cur) return;\\n    if (cur.val <= high && cur.val >= low) {\\n      ++intervals[Math.floor((cur.val - low + 1) / interval)];\\n    }\\n    cur.val > low && this.traversal(low, high, interval, intervals, cur.left);\\n    cur.val < high && this.traversal(low, high, interval, intervals, cur.right);\\n  }\\n};\\nclass TweetCounts {\\n  constructor() {\\n    this.freqInterval = {\\n      minute: 60,\\n      hour: 3600,\\n      day: 86400,\\n    };\\n    this.data = new Map();\\n  }\\n\\n  recordTweet(name, time) {\\n    if (this.data.has(name) === false) {\\n      this.data.set(name, new BinarySearchTree());\\n    }\\n    this.data.get(name).insert(time);\\n  }\\n\\n  getTweetCountsPerFrequency(freq, name, start, end) {\\n    const interval = this.freqInterval[freq];\\n    const ret = new Uint16Array(Math.ceil((end - start + 1) / interval));\\n    this.data.has(name) && this.data.get(name).traversal(start, end, interval, ret);\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1636922,
                "title": "python3-using-insort-and-bisect-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/50fd3612-261a-46ae-b27d-ed4b49765868_1639969307.1475787.png)\\n\\n\\n```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.words = defaultdict(lambda: [])\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        insort(self.words[tweetName], time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        idxStart = bisect_left(self.words[tweetName], startTime)\\n        idxEnd = bisect_right(self.words[tweetName], endTime)\\n        tmp = self.words[tweetName][idxStart: idxEnd]\\n        \\n        if freq == \"minute\":        \\n            div = 60\\n        elif freq == \"hour\":\\n            div = 3600\\n        else: \\n            div = 84600\\n        \\n        maxElem = (endTime - startTime)//div  \\n        \\n        ans = [0 for _ in range(maxElem + 1)]\\n        \\n        for num in tmp: \\n            idx = (num - startTime)//div\\n            ans[idx] += 1\\n            \\n        return ans\\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.words = defaultdict(lambda: [])\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        insort(self.words[tweetName], time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        idxStart = bisect_left(self.words[tweetName], startTime)\\n        idxEnd = bisect_right(self.words[tweetName], endTime)\\n        tmp = self.words[tweetName][idxStart: idxEnd]\\n        \\n        if freq == \"minute\":        \\n            div = 60\\n        elif freq == \"hour\":\\n            div = 3600\\n        else: \\n            div = 84600\\n        \\n        maxElem = (endTime - startTime)//div  \\n        \\n        ans = [0 for _ in range(maxElem + 1)]\\n        \\n        for num in tmp: \\n            idx = (num - startTime)//div\\n            ans[idx] += 1\\n            \\n        return ans\\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286376,
                "title": "java-simple-built-in-treemap-solution-with-comments",
                "content": "```\\nclass TweetCounts {\\n    \\n    // String for tweetName, TreeMap for timeline & count\\n    Map<String, TreeMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    // O(1) for existed time\\n    // O(1) for a new tweetName\\n    // O(log(N)) for a new time, where N is the number of unique time of a tweetName\\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        map.get(tweetName).put(time, map.get(tweetName).getOrDefault(time, 0) + 1);\\n    }\\n    \\n    // O(k * log(N)), where N is the number of unique time of a tweetName, k is (endTime - startTime) / freq \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int time = helper(freq);\\n        List<Integer> ans = new ArrayList<>();\\n        if(!map.containsKey(tweetName)) return ans;\\n        for(int i = startTime; i <= endTime; i += time + 1) {\\n            int start = i;\\n            int end = Math.min(i + time, endTime);\\n            int count = 0;\\n            for(int val: map.get(tweetName).subMap(start, true, end, true).values()) count += val;\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n    \\n    private int helper(String freq) {\\n        if(freq.equals(\"minute\")) return 59;\\n        else if(freq.equals(\"hour\")) return 3599;\\n        return 86399;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n    \\n    // String for tweetName, TreeMap for timeline & count\\n    Map<String, TreeMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    // O(1) for existed time\\n    // O(1) for a new tweetName\\n    // O(log(N)) for a new time, where N is the number of unique time of a tweetName\\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        map.get(tweetName).put(time, map.get(tweetName).getOrDefault(time, 0) + 1);\\n    }\\n    \\n    // O(k * log(N)), where N is the number of unique time of a tweetName, k is (endTime - startTime) / freq \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int time = helper(freq);\\n        List<Integer> ans = new ArrayList<>();\\n        if(!map.containsKey(tweetName)) return ans;\\n        for(int i = startTime; i <= endTime; i += time + 1) {\\n            int start = i;\\n            int end = Math.min(i + time, endTime);\\n            int count = 0;\\n            for(int val: map.get(tweetName).subMap(start, true, end, true).values()) count += val;\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n    \\n    private int helper(String freq) {\\n        if(freq.equals(\"minute\")) return 59;\\n        else if(freq.equals(\"hour\")) return 3599;\\n        return 86399;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012720,
                "title": "easy-c-solution",
                "content": "```\\npublic class TweetCounts {    \\n    private Dictionary<string, List<int>> tweets;\\n    private Dictionary<string, int> deltas;\\n    public TweetCounts() {        \\n        this.tweets = new Dictionary<string, List<int>>();\\n        this.deltas = new Dictionary<string, int>();\\n        this.deltas.Add(\"minute\", 60);\\n        this.deltas.Add(\"hour\", 60 * 60);\\n        this.deltas.Add(\"day\", 60 * 60 * 24);\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        if (!tweets.ContainsKey(tweetName))\\n            tweets.Add(tweetName, new List<int>());\\n        tweets[tweetName].Add(time);\\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int delta = deltas[freq];\\n        var ans = new List<int>(new int[1 + (endTime - startTime) / delta]);\\n        foreach (int time in tweets[tweetName])\\n            if (time >= startTime && time <= endTime)\\n                ans[(time - startTime) / delta]++;\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.RecordTweet(tweetName,time);\\n * IList<int> param_2 = obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TweetCounts {    \\n    private Dictionary<string, List<int>> tweets;\\n    private Dictionary<string, int> deltas;\\n    public TweetCounts() {        \\n        this.tweets = new Dictionary<string, List<int>>();\\n        this.deltas = new Dictionary<string, int>();\\n        this.deltas.Add(\"minute\", 60);\\n        this.deltas.Add(\"hour\", 60 * 60);\\n        this.deltas.Add(\"day\", 60 * 60 * 24);\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        if (!tweets.ContainsKey(tweetName))\\n            tweets.Add(tweetName, new List<int>());\\n        tweets[tweetName].Add(time);\\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int delta = deltas[freq];\\n        var ans = new List<int>(new int[1 + (endTime - startTime) / delta]);\\n        foreach (int time in tweets[tweetName])\\n            if (time >= startTime && time <= endTime)\\n                ans[(time - startTime) / delta]++;\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.RecordTweet(tweetName,time);\\n * IList<int> param_2 = obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511029,
                "title": "java-map-of-bst-accepted-solution-explained",
                "content": "We can searh number of elements quickly if we interpret every tweet time as a node in BST and query will be number of nodes between two values. We can build such tree for every tween separetely and keep these trees in the map.\\nImportant assumption is that there will be no same tweets happened at the same time - this gives us flexibilty to use TreeSet and not more complex objects like TreeMap where count for each time is the value. In this case we can do TreeSet.subSet(intervalStart, intervalEnd).size().\\n\\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Integer>> m;\\n\\n    public TweetCounts() {\\n        m = new HashMap();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        if (!m.containsKey(tweetName))\\n            m.put(tweetName, new TreeSet());\\n        m.get(tweetName).add(time);\\n    }\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        switch(freq) {\\n            case \"hour\"     : interval = 3600; break;\\n            case \"day\"      : interval = 86400; break;\\n        }\\n        return helper(interval, tweetName, startTime, endTime);\\n    }\\n\\n    List<Integer> helper(int interval, String tweet, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList();\\n        if (!m.containsKey(tweet) || m.get(tweet).isEmpty()) {\\n            for (int t = startTime; t <= endTime; t+=interval) res.add(0);\\n            return res;\\n        }\\n        TreeSet<Integer> tweetCounts = m.get(tweet);\\n        for (int t = startTime; t <= endTime; t+=interval)\\n            res.add(tweetCounts.subSet(t, Math.min(t + interval, endTime + 1)).size());\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass TweetCounts {\\n\\n    Map<String, TreeSet<Integer>> m;\\n\\n    public TweetCounts() {\\n        m = new HashMap();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        if (!m.containsKey(tweetName))\\n            m.put(tweetName, new TreeSet());\\n        m.get(tweetName).add(time);\\n    }\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        switch(freq) {\\n            case \"hour\"     : interval = 3600; break;\\n            case \"day\"      : interval = 86400; break;\\n        }\\n        return helper(interval, tweetName, startTime, endTime);\\n    }\\n\\n    List<Integer> helper(int interval, String tweet, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList();\\n        if (!m.containsKey(tweet) || m.get(tweet).isEmpty()) {\\n            for (int t = startTime; t <= endTime; t+=interval) res.add(0);\\n            return res;\\n        }\\n        TreeSet<Integer> tweetCounts = m.get(tweet);\\n        for (int t = startTime; t <= endTime; t+=interval)\\n            res.add(tweetCounts.subSet(t, Math.min(t + interval, endTime + 1)).size());\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505477,
                "title": "c-true-o-q-out-logq-solution-using-c-policy-based-data-structures",
                "content": "Q == total number of queries.\\nOUT == total length of all outputs\\nReference link: https://codeforces.com/blog/entry/11080?locale=en\\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n \\nusing namespace __gnu_pbds;\\n \\ntypedef\\ntree<\\n  pair<int,int>,\\n  null_type,\\n  less<pair<int,int>>,\\n  rb_tree_tag,\\n  tree_order_statistics_node_update>\\nordered_set;\\n\\nclass TweetCounts {\\n    int ctr=0;\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    map<string, ordered_set> M;\\n    void recordTweet(string tweetName, int time) {\\n        // use ctr to add a \"dummy\" unique 2nd coordinate\\n        // to allow multiple tweets with same name and time\\n        M[tweetName].insert({time, ctr++});\\n        return;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        bool hour  =(freq==\"hour\");\\n        bool minute=(freq==\"minute\");\\n        //bool day =(freq==\"day\");\\n        \\n        int delta;\\n        if(minute)    delta=60;\\n        else if(hour) delta=60*60;\\n        else          delta=60*60*24;\\n        \\n        vector<int> result;\\n        ordered_set& MM=M[tweetName];\\n        \\n        const int INF=1e9;\\n        for(int L=startTime; L<=endTime; L+=delta)\\n        {\\n            int R=min(endTime, L+delta-1);\\n\\n            int sL=MM.order_of_key({L, -INF}), // idx of smallest element which has first coordinate >= L\\n                sR=MM.order_of_key({R,  INF}); // idx of smallest element which has first coordinate >  R\\n            \\n            result.push_back(sR-sL);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nComplaint in 3...2...1...: I\\'m a bit surprised that most of first page AC solutions are different variations with O(Q * Q) time complexity. Weak tests?",
                "solutionTags": [],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n \\nusing namespace __gnu_pbds;\\n \\ntypedef\\ntree<\\n  pair<int,int>,\\n  null_type,\\n  less<pair<int,int>>,\\n  rb_tree_tag,\\n  tree_order_statistics_node_update>\\nordered_set;\\n\\nclass TweetCounts {\\n    int ctr=0;\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    map<string, ordered_set> M;\\n    void recordTweet(string tweetName, int time) {\\n        // use ctr to add a \"dummy\" unique 2nd coordinate\\n        // to allow multiple tweets with same name and time\\n        M[tweetName].insert({time, ctr++});\\n        return;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        bool hour  =(freq==\"hour\");\\n        bool minute=(freq==\"minute\");\\n        //bool day =(freq==\"day\");\\n        \\n        int delta;\\n        if(minute)    delta=60;\\n        else if(hour) delta=60*60;\\n        else          delta=60*60*24;\\n        \\n        vector<int> result;\\n        ordered_set& MM=M[tweetName];\\n        \\n        const int INF=1e9;\\n        for(int L=startTime; L<=endTime; L+=delta)\\n        {\\n            int R=min(endTime, L+delta-1);\\n\\n            int sL=MM.order_of_key({L, -INF}), // idx of smallest element which has first coordinate >= L\\n                sR=MM.order_of_key({R,  INF}); // idx of smallest element which has first coordinate >  R\\n            \\n            result.push_back(sR-sL);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 503691,
                "title": "python3-using-dict-and-array",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.record = {}\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.record:\\n            self.record[tweetName] = [time]\\n        else:\\n            self.record[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\":\\n            delta = 60\\n        elif freq == \"hour\":\\n            delta = 3600\\n        else:\\n            delta = 216000\\n        \\n        ans = [0 for i in range((endTime - startTime) // delta + 1)]\\n        if tweetName not in self.record:\\n            return ans\\n        else:\\n            data = sorted(self.record[tweetName])\\n            for num in data:\\n                if num >= startTime and num <= endTime:\\n                    ans[(num - startTime) // delta] += 1\\n                    \\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.record = {}\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.record:\\n            self.record[tweetName] = [time]\\n        else:\\n            self.record[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\":\\n            delta = 60\\n        elif freq == \"hour\":\\n            delta = 3600\\n        else:\\n            delta = 216000\\n        \\n        ans = [0 for i in range((endTime - startTime) // delta + 1)]\\n        if tweetName not in self.record:\\n            return ans\\n        else:\\n            data = sorted(self.record[tweetName])\\n            for num in data:\\n                if num >= startTime and num <= endTime:\\n                    ans[(num - startTime) // delta] += 1\\n                    \\n        return ans\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051431,
                "title": "python-log-n-sortedlist-solution-100-time",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(SortedList)\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        self.d[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if freq == \"minute\": delta = 60 \\n        elif freq == \"hour\": delta = 3600\\n        else: delta = 86400\\n        out = [0 for _ in range(startTime, endTime+1, delta)]\\n        for time in self.d[tweetName].irange(startTime, endTime):\\n            out[(time-startTime+1)//delta] +=1\\n        return out\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.d = collections.defaultdict(SortedList)\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        self.d[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if freq == \"minute\": delta = 60 \\n        elif freq == \"hour\": delta = 3600\\n        else: delta = 86400\\n        out = [0 for _ in range(startTime, endTime+1, delta)]\\n        for time in self.d[tweetName].irange(startTime, endTime):\\n            out[(time-startTime+1)//delta] +=1\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777422,
                "title": "hashmap-sortedmap-easy-understand",
                "content": "```\\npublic class TweetCounts {\\n    private final Map<String, SortedMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        int count = map.get(tweetName).getOrDefault(time, 0);\\n        map.get(tweetName).put(time, count + 1);\\n\\n    }\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int slot = \"minute\".equals(freq) ? 60 :\\n                (\"hour\".equals(freq) ? 3600 : (24 * 3600));\\n        SortedMap<Integer, Integer> mapPerTweet = map.getOrDefault(tweetName, Collections.emptySortedMap());\\n\\n        List<Integer> res = new ArrayList<>();\\n        int start = startTime;\\n        while (start <= endTime) {\\n            int end = Math.min(endTime + 1, start + slot);\\n            SortedMap<Integer, Integer> submap = mapPerTweet.subMap(start, end);\\n            res.add(submap.values().stream().reduce(0, Integer::sum));\\n\\n            start = end;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TweetCounts {\\n    private final Map<String, SortedMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        int count = map.get(tweetName).getOrDefault(time, 0);\\n        map.get(tweetName).put(time, count + 1);\\n\\n    }\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int slot = \"minute\".equals(freq) ? 60 :\\n                (\"hour\".equals(freq) ? 3600 : (24 * 3600));\\n        SortedMap<Integer, Integer> mapPerTweet = map.getOrDefault(tweetName, Collections.emptySortedMap());\\n\\n        List<Integer> res = new ArrayList<>();\\n        int start = startTime;\\n        while (start <= endTime) {\\n            int end = Math.min(endTime + 1, start + slot);\\n            SortedMap<Integer, Integer> submap = mapPerTweet.subMap(start, end);\\n            res.add(submap.values().stream().reduce(0, Integer::sum));\\n\\n            start = end;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1528475,
                "title": "python3-solution",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetNames = defaultdict(list)\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweetNames[tweetName].append(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        if freq==\"minute\":\\n            chunk_size = 60\\n        elif freq==\"hour\":\\n            chunk_size = 60 * 60\\n        else:\\n            chunk_size = 60 * 60 * 24\\n            \\n        chunk_count = int((endTime - startTime)/chunk_size) + 1\\n        \\n        bins = [0] * (chunk_count)\\n        \\n        for tweettime in self.tweetNames[tweetName]:\\n            if(startTime <= tweettime and tweettime <= endTime):\\n                chunk_number = int((tweettime-startTime)/chunk_size)\\n                bins[chunk_number] +=1\\n\\n        return bins\\n            \\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetNames = defaultdict(list)\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweetNames[tweetName].append(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        if freq==\"minute\":\\n            chunk_size = 60\\n        elif freq==\"hour\":\\n            chunk_size = 60 * 60\\n        else:\\n            chunk_size = 60 * 60 * 24\\n            \\n        chunk_count = int((endTime - startTime)/chunk_size) + 1\\n        \\n        bins = [0] * (chunk_count)\\n        \\n        for tweettime in self.tweetNames[tweetName]:\\n            if(startTime <= tweettime and tweettime <= endTime):\\n                chunk_number = int((tweettime-startTime)/chunk_size)\\n                bins[chunk_number] +=1\\n\\n        return bins\\n            \\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469713,
                "title": "java-sol-95ms",
                "content": "```\\nclass TweetCounts {\\n    private Map<String, TreeMap<Integer, Integer>> tweetMap;\\n    \\n    public TweetCounts() {\\n        tweetMap = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetMap.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> timeFreqMap = tweetMap.get(tweetName);\\n        timeFreqMap.put(time, timeFreqMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400; \\n        int size = (endTime - startTime)/interval;\\n        int[] count = new int[size + 1];\\n        TreeMap<Integer, Integer> timeFreqMap = tweetMap.get(tweetName);\\n        for (Map.Entry<Integer, Integer> entry: timeFreqMap.subMap(startTime, endTime + 1).entrySet()){\\n            int index = (entry.getKey() - startTime)/interval;\\n            count[index] += entry.getValue();\\n        }\\n        /*caused runtime to go up to 157ms\\n        since primitive int type in count[] hence use boxed.\\n        refer: https://examples.javacodegeeks.com/core-java/java8-convert-array-list-example/\\n        */\\n        //return Arrays.stream(count).boxed().collect(Collectors.toList());\\n        \\n        /* old school method but runtime drops to 95ms*/\\n        List<Integer> res = new ArrayList<>();\\n        for (int num : count)\\n             res.add(num);\\n        return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass TweetCounts {\\n    private Map<String, TreeMap<Integer, Integer>> tweetMap;\\n    \\n    public TweetCounts() {\\n        tweetMap = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetMap.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> timeFreqMap = tweetMap.get(tweetName);\\n        timeFreqMap.put(time, timeFreqMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400; \\n        int size = (endTime - startTime)/interval;\\n        int[] count = new int[size + 1];\\n        TreeMap<Integer, Integer> timeFreqMap = tweetMap.get(tweetName);\\n        for (Map.Entry<Integer, Integer> entry: timeFreqMap.subMap(startTime, endTime + 1).entrySet()){\\n            int index = (entry.getKey() - startTime)/interval;\\n            count[index] += entry.getValue();\\n        }\\n        /*caused runtime to go up to 157ms\\n        since primitive int type in count[] hence use boxed.\\n        refer: https://examples.javacodegeeks.com/core-java/java8-convert-array-list-example/\\n        */\\n        //return Arrays.stream(count).boxed().collect(Collectors.toList());\\n        \\n        /* old school method but runtime drops to 95ms*/\\n        List<Integer> res = new ArrayList<>();\\n        for (int num : count)\\n             res.add(num);\\n        return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378574,
                "title": "scala-using-ranges-and-treemap",
                "content": "```scala\\n  class TweetCollection {\\n    private val tweetMap = collection.mutable.HashMap[String, scala.collection.mutable.TreeMap[Int, Int]]()\\n\\n    def addTweet(name: String, time: Int): Unit = {\\n      tweetMap.get(name) match {\\n        case Some(treeMap) =>\\n          val count = treeMap.get(time).fold(1)(c => c + 1)\\n          treeMap.put(time, count)\\n        case _ =>\\n          tweetMap.put(name, scala.collection.mutable.TreeMap[Int, Int](time -> 1))\\n      }\\n    }\\n\\n    def getCount(name: String, r: Range): Int = {\\n      tweetMap\\n        .get(name)\\n        .map(_.range(r.head, r.last).values.sum)\\n        .getOrElse(0)\\n    }\\n  }\\n\\n  class TweetCounts() {\\n    private val tweets = new TweetCollection()\\n\\n    def recordTweet(tweetName: String, time: Int) {\\n      tweets.addTweet(tweetName, time)\\n    }\\n\\n    def getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List[Int] = {\\n      val step: Int = TweetVals.timeMap(freq)\\n      Range.inclusive(startTime, endTime).grouped(step).map { r =>\\n        val newRange = Range.inclusive(r.head, r.last + 1)\\n        tweets.getCount(tweetName, newRange)\\n      }.toList\\n    }\\n  }\\n\\n  object TweetVals {\\n    val timeMap = Map(\\n      \"minute\" -> 60,\\n      \"hour\" -> 3600,\\n      \"day\" -> 86400\\n      )\\n  }\\n  ```\\n",
                "solutionTags": [],
                "code": "```scala\\n  class TweetCollection {\\n    private val tweetMap = collection.mutable.HashMap[String, scala.collection.mutable.TreeMap[Int, Int]]()\\n\\n    def addTweet(name: String, time: Int): Unit = {\\n      tweetMap.get(name) match {\\n        case Some(treeMap) =>\\n          val count = treeMap.get(time).fold(1)(c => c + 1)\\n          treeMap.put(time, count)\\n        case _ =>\\n          tweetMap.put(name, scala.collection.mutable.TreeMap[Int, Int](time -> 1))\\n      }\\n    }\\n\\n    def getCount(name: String, r: Range): Int = {\\n      tweetMap\\n        .get(name)\\n        .map(_.range(r.head, r.last).values.sum)\\n        .getOrElse(0)\\n    }\\n  }\\n\\n  class TweetCounts() {\\n    private val tweets = new TweetCollection()\\n\\n    def recordTweet(tweetName: String, time: Int) {\\n      tweets.addTweet(tweetName, time)\\n    }\\n\\n    def getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List[Int] = {\\n      val step: Int = TweetVals.timeMap(freq)\\n      Range.inclusive(startTime, endTime).grouped(step).map { r =>\\n        val newRange = Range.inclusive(r.head, r.last + 1)\\n        tweets.getCount(tweetName, newRange)\\n      }.toList\\n    }\\n  }\\n\\n  object TweetVals {\\n    val timeMap = Map(\\n      \"minute\" -> 60,\\n      \"hour\" -> 3600,\\n      \"day\" -> 86400\\n      )\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1311850,
                "title": "java-time-bucket-faster-than-99-9",
                "content": "We bucket each tweet into `tweetName: {day: {hour: {minute: [time]}}}`.\\n```\\nprivate static final int MINUTE = 60;\\nprivate static final int HOUR = 3600;\\nprivate static final int DAY = 86400;\\n\\nprivate final Map<String, Map<Integer, Map<Integer, Map<Integer, List<Integer>>>>> store;\\n\\npublic TweetCounts() {\\n\\tthis.store = new HashMap();\\n}\\n\\npublic void recordTweet(String tweetName, int time) {\\n\\tint d = time / DAY;\\n\\tint h = (time - d * DAY) / HOUR;\\n\\tint m = (time - d * DAY - h * HOUR) / MINUTE;\\n\\tMap<Integer, Map<Integer, Map<Integer, List<Integer>>>> dstore\\n\\t\\t= store.computeIfAbsent(tweetName, k -> new HashMap());\\n\\tMap<Integer, Map<Integer, List<Integer>>> hstore\\n\\t\\t= dstore.computeIfAbsent(d, k -> new HashMap());\\n\\tMap<Integer, List<Integer>> mstore\\n\\t\\t= hstore.computeIfAbsent(h, k -> new HashMap());\\n\\tmstore.computeIfAbsent(m, k -> new ArrayList()).add(time);\\n}\\n\\npublic List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\tint sfreq = convFreqToSecond(freq);\\n\\tMap<Integer, Map<Integer, Map<Integer, List<Integer>>>> dstore = store.get(tweetName);\\n\\tint[] chunks = new int[(endTime - startTime) / sfreq + 1];\\n\\tint sd = startTime / DAY, ed = endTime / DAY;\\n\\tfor (int d = sd; d <= ed; d++) {\\n\\t\\tif (!dstore.containsKey(d)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// optimization: calculate the range so we can skip buckets we know we can\\'t find any suitable tweets\\n\\t\\tint sh = startTime <= (d * DAY) ? 0 : ((startTime - d * DAY) / HOUR);\\n\\t\\tint eh = endTime > ((d + 1) * DAY) ? (DAY / HOUR) : ((endTime - d * DAY) / HOUR + 1);\\n\\t\\tMap<Integer, Map<Integer, List<Integer>>> hstore = dstore.get(d);\\n\\t\\tfor (int h = sh; h < eh; h++) {\\n\\t\\t\\tif (!hstore.containsKey(h)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t// similar optimization as above\\n\\t\\t\\tint sm = startTime <= (d * DAY + h * HOUR) ? 0 : ((startTime - d * DAY - h * HOUR) / MINUTE);\\n\\t\\t\\tint em = endTime > (d * DAY + (h + 1) * HOUR) ?\\n\\t\\t\\t\\t(HOUR / MINUTE) : ((endTime - d * DAY - h * HOUR) / MINUTE + 1);\\n\\t\\t\\tMap<Integer, List<Integer>> mstore = hstore.get(h);\\n\\t\\t\\tfor (int m = sm; m <= em; m++) {\\n\\t\\t\\t\\tif (!mstore.containsKey(m)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (Integer record : mstore.get(m)) {\\n\\t\\t\\t\\t\\tif (startTime <= record && record <= endTime) {\\n\\t\\t\\t\\t\\t\\tchunks[(record - startTime) / sfreq]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tList<Integer> ans = new ArrayList();\\n\\tfor (int chunk : chunks) {\\n\\t\\tans.add(chunk);\\n\\t}\\n\\treturn ans;\\n}\\n\\nprivate int convFreqToSecond(String freq) {\\n\\tswitch (freq) {\\n\\t\\tcase \"minute\":\\n\\t\\t\\treturn MINUTE;\\n\\t\\tcase \"hour\":\\n\\t\\t\\treturn HOUR;\\n\\t\\tcase \"day\":\\n\\t\\t\\treturn DAY;\\n\\t}\\n\\treturn 0;\\n}\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nprivate static final int MINUTE = 60;\\nprivate static final int HOUR = 3600;\\nprivate static final int DAY = 86400;\\n\\nprivate final Map<String, Map<Integer, Map<Integer, Map<Integer, List<Integer>>>>> store;\\n\\npublic TweetCounts() {\\n\\tthis.store = new HashMap();\\n}\\n\\npublic void recordTweet(String tweetName, int time) {\\n\\tint d = time / DAY;\\n\\tint h = (time - d * DAY) / HOUR;\\n\\tint m = (time - d * DAY - h * HOUR) / MINUTE;\\n\\tMap<Integer, Map<Integer, Map<Integer, List<Integer>>>> dstore\\n\\t\\t= store.computeIfAbsent(tweetName, k -> new HashMap());\\n\\tMap<Integer, Map<Integer, List<Integer>>> hstore\\n\\t\\t= dstore.computeIfAbsent(d, k -> new HashMap());\\n\\tMap<Integer, List<Integer>> mstore\\n\\t\\t= hstore.computeIfAbsent(h, k -> new HashMap());\\n\\tmstore.computeIfAbsent(m, k -> new ArrayList()).add(time);\\n}\\n\\npublic List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\tint sfreq = convFreqToSecond(freq);\\n\\tMap<Integer, Map<Integer, Map<Integer, List<Integer>>>> dstore = store.get(tweetName);\\n\\tint[] chunks = new int[(endTime - startTime) / sfreq + 1];\\n\\tint sd = startTime / DAY, ed = endTime / DAY;\\n\\tfor (int d = sd; d <= ed; d++) {\\n\\t\\tif (!dstore.containsKey(d)) {\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\t\\t// optimization: calculate the range so we can skip buckets we know we can\\'t find any suitable tweets\\n\\t\\tint sh = startTime <= (d * DAY) ? 0 : ((startTime - d * DAY) / HOUR);\\n\\t\\tint eh = endTime > ((d + 1) * DAY) ? (DAY / HOUR) : ((endTime - d * DAY) / HOUR + 1);\\n\\t\\tMap<Integer, Map<Integer, List<Integer>>> hstore = dstore.get(d);\\n\\t\\tfor (int h = sh; h < eh; h++) {\\n\\t\\t\\tif (!hstore.containsKey(h)) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t// similar optimization as above\\n\\t\\t\\tint sm = startTime <= (d * DAY + h * HOUR) ? 0 : ((startTime - d * DAY - h * HOUR) / MINUTE);\\n\\t\\t\\tint em = endTime > (d * DAY + (h + 1) * HOUR) ?\\n\\t\\t\\t\\t(HOUR / MINUTE) : ((endTime - d * DAY - h * HOUR) / MINUTE + 1);\\n\\t\\t\\tMap<Integer, List<Integer>> mstore = hstore.get(h);\\n\\t\\t\\tfor (int m = sm; m <= em; m++) {\\n\\t\\t\\t\\tif (!mstore.containsKey(m)) {\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (Integer record : mstore.get(m)) {\\n\\t\\t\\t\\t\\tif (startTime <= record && record <= endTime) {\\n\\t\\t\\t\\t\\t\\tchunks[(record - startTime) / sfreq]++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tList<Integer> ans = new ArrayList();\\n\\tfor (int chunk : chunks) {\\n\\t\\tans.add(chunk);\\n\\t}\\n\\treturn ans;\\n}\\n\\nprivate int convFreqToSecond(String freq) {\\n\\tswitch (freq) {\\n\\t\\tcase \"minute\":\\n\\t\\t\\treturn MINUTE;\\n\\t\\tcase \"hour\":\\n\\t\\t\\treturn HOUR;\\n\\t\\tcase \"day\":\\n\\t\\t\\treturn DAY;\\n\\t}\\n\\treturn 0;\\n}\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206624,
                "title": "python3-clean-bisect",
                "content": "```python\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        bisect.insort(self.tweets[tweetName], time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \\'minute\\':\\n            chunk = 60\\n        elif freq == \\'hour\\':\\n            chunk = 3600\\n        else:\\n            chunk = 86400\\n        ans = []\\n        s = startTime\\n\\n        while s <= endTime:\\n            e = min(s + chunk - 1, endTime)\\n            i = bisect.bisect_left(self.tweets[tweetName], s)\\n            j = bisect.bisect_right(self.tweets[tweetName], e)\\n            ans += j - i,\\n            s = e + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        bisect.insort(self.tweets[tweetName], time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \\'minute\\':\\n            chunk = 60\\n        elif freq == \\'hour\\':\\n            chunk = 3600\\n        else:\\n            chunk = 86400\\n        ans = []\\n        s = startTime\\n\\n        while s <= endTime:\\n            e = min(s + chunk - 1, endTime)\\n            i = bisect.bisect_left(self.tweets[tweetName], s)\\n            j = bisect.bisect_right(self.tweets[tweetName], e)\\n            ans += j - i,\\n            s = e + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135627,
                "title": "c-o-log-n-operations-with-order-statistic-tree",
                "content": "An order statistic tree is a datastructure like ```multiset<int>```, but allows an ```O(log(n))``` query to know the index of an element `x` when the set is ordered. You don\\'t need to implement it, and can just use the EXT library which had it implemented. \\n\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<pair<int, int>,null_type,less<pair<int, int>>,rb_tree_tag,tree_order_statistics_node_update> set_t; //ordered statistics tree. Allows all set operations + .order_of_key(x) function for finding order of x\\n\\nclass TweetCounts {\\npublic:\\n    int T = 0;\\n    unordered_map<string, set_t> H;\\n    void recordTweet(string tweetName, int time) {\\n        H[tweetName].insert({time, T++});\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int increment=86400;\\n        if (freq==\"minute\")increment=60;\\n        else if (freq==\"hour\")increment=3600;\\n        \\n        vector<int> ret;\\n        while(startTime<=endTime){\\n            int l = startTime;\\n            int r = min(startTime+increment-1, endTime);\\n            startTime=r+1;\\n            auto it_l = H[tweetName].lower_bound({l,-1});\\n            auto it_r = H[tweetName].upper_bound({r,T+1});\\n            if (it_l==H[tweetName].end() or it_r==H[tweetName].begin())ret.push_back(0);\\n            else ret.push_back(H[tweetName].order_of_key(*prev(it_r))- H[tweetName].order_of_key(*it_l)+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```multiset<int>```\n```O(log(n))```\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\ntypedef tree<pair<int, int>,null_type,less<pair<int, int>>,rb_tree_tag,tree_order_statistics_node_update> set_t; //ordered statistics tree. Allows all set operations + .order_of_key(x) function for finding order of x\\n\\nclass TweetCounts {\\npublic:\\n    int T = 0;\\n    unordered_map<string, set_t> H;\\n    void recordTweet(string tweetName, int time) {\\n        H[tweetName].insert({time, T++});\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int increment=86400;\\n        if (freq==\"minute\")increment=60;\\n        else if (freq==\"hour\")increment=3600;\\n        \\n        vector<int> ret;\\n        while(startTime<=endTime){\\n            int l = startTime;\\n            int r = min(startTime+increment-1, endTime);\\n            startTime=r+1;\\n            auto it_l = H[tweetName].lower_bound({l,-1});\\n            auto it_r = H[tweetName].upper_bound({r,T+1});\\n            if (it_l==H[tweetName].end() or it_r==H[tweetName].begin())ret.push_back(0);\\n            else ret.push_back(H[tweetName].order_of_key(*prev(it_r))- H[tweetName].order_of_key(*it_l)+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1117648,
                "title": "c-hash-map-to-map-solution-with-some-analysis",
                "content": "**Key points:**\\n* The problem is simple, it is just about using which contain is more efficient.\\n* I choosed hash map from name string to a map of timestamp to hit counter.\\n* I suppose you could also choose multiset to save multiple entries of same time stamp. But if collision does happen a lot, multiset always grow per each recordTweet yet map can just bump the counter without using more space.\\n* On the other hand, if collision rarely happens, map may actually use more space since there are lot of value = 1 in it. So choose wisely depend on the use case.\\n* It is nice that I can use map::lower_bound to do a blurry search for the right spot in sequence. Otherwise iterate through all is not fun. In theory it should be log(n) performance.\\n```\\n  TweetCounts() {\\n    freq_.insert({\"minute\", 60});\\n    freq_.insert({\"hour\", 3600});\\n    freq_.insert({\"day\", 86400});\\n  }\\n    \\n  void recordTweet(const string & tweetName, int time) {\\n    ++lut_[tweetName][time];\\n  }\\n    \\n  vector<int> getTweetCountsPerFrequency(const string & freq, const string & tweetName, int startTime, int endTime) {\\n    int interval = freq_[freq];\\n    vector<int> ret(1+(endTime-startTime)/interval, 0);\\n    auto itor = lut_.find(tweetName);\\n    if (itor == lut_.end())\\n      return ret;\\n    auto itor2 = itor->second.lower_bound(startTime);\\n    while (itor2 != itor->second.end() && itor2->first <= endTime) {\\n      ret[(itor2->first-startTime)/interval] += itor2->second;\\n      ++itor2;\\n    }\\n    return ret;\\n  }\\n\\nprivate:\\n  unordered_map<string, map<int, int>> lut_;\\n  map<string, int> freq_;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  TweetCounts() {\\n    freq_.insert({\"minute\", 60});\\n    freq_.insert({\"hour\", 3600});\\n    freq_.insert({\"day\", 86400});\\n  }\\n    \\n  void recordTweet(const string & tweetName, int time) {\\n    ++lut_[tweetName][time];\\n  }\\n    \\n  vector<int> getTweetCountsPerFrequency(const string & freq, const string & tweetName, int startTime, int endTime) {\\n    int interval = freq_[freq];\\n    vector<int> ret(1+(endTime-startTime)/interval, 0);\\n    auto itor = lut_.find(tweetName);\\n    if (itor == lut_.end())\\n      return ret;\\n    auto itor2 = itor->second.lower_bound(startTime);\\n    while (itor2 != itor->second.end() && itor2->first <= endTime) {\\n      ret[(itor2->first-startTime)/interval] += itor2->second;\\n      ++itor2;\\n    }\\n    return ret;\\n  }\\n\\nprivate:\\n  unordered_map<string, map<int, int>> lut_;\\n  map<string, int> freq_;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 815024,
                "title": "python-binary-search-solution",
                "content": "\"\"\"\\n\\n\\timport collections\\n\\n\\n\\tclass TweetCounts(object):\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.tweets = collections.defaultdict(list)\\n\\n\\t\\tdef recordTweet(self, tweetName, time):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type tweetName: str\\n\\t\\t\\t:type time: int\\n\\t\\t\\t:rtype: None\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tindex = self.binary_search(tweetName, time)\\n\\t\\t\\tself.tweets[tweetName].insert(index,  time)\\n\\n\\n\\t\\tdef getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type freq: str\\n\\t\\t\\t:type tweetName: str\\n\\t\\t\\t:type startTime: int\\n\\t\\t\\t:type endTime: int\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdelta = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n\\t\\t\\ti = startTime\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i <= endTime:\\n\\t\\t\\t\\tj = min(i + delta, endTime + 1)\\n\\t\\t\\t\\tres.append(self.binary_search(tweetName, j) - self.binary_search(tweetName, i))\\n\\t\\t\\t\\ti += delta\\n\\n\\t\\t\\treturn res\\n\\n\\n\\t\\tdef binary_search(self, tweetName, time):\\n\\t\\t\\tcur_list = self.tweets[tweetName]\\n\\t\\t\\tl = 0\\n\\t\\t\\tr = len(cur_list) \\n\\t\\t\\twhile l < r:\\n\\t\\t\\t\\tmid = (l+r) // 2\\n\\t\\t\\t\\tif cur_list[mid] < time:\\n\\t\\t\\t\\t\\tl = mid + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid\\n\\n\\t\\t\\treturn l\\n\\n\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\n\\timport collections\\n\\n\\n\\tclass TweetCounts(object):\\n\\n\\t\\tdef __init__(self):\\n\\t\\t\\tself.tweets = collections.defaultdict(list)\\n\\n\\t\\tdef recordTweet(self, tweetName, time):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type tweetName: str\\n\\t\\t\\t:type time: int\\n\\t\\t\\t:rtype: None\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tindex = self.binary_search(tweetName, time)\\n\\t\\t\\tself.tweets[tweetName].insert(index,  time)\\n\\n\\n\\t\\tdef getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type freq: str\\n\\t\\t\\t:type tweetName: str\\n\\t\\t\\t:type startTime: int\\n\\t\\t\\t:type endTime: int\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tdelta = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n\\t\\t\\ti = startTime\\n\\t\\t\\tres = []\\n\\t\\t\\twhile i <= endTime:\\n\\t\\t\\t\\tj = min(i + delta, endTime + 1)\\n\\t\\t\\t\\tres.append(self.binary_search(tweetName, j) - self.binary_search(tweetName, i))\\n\\t\\t\\t\\ti += delta\\n\\n\\t\\t\\treturn res\\n\\n\\n\\t\\tdef binary_search(self, tweetName, time):\\n\\t\\t\\tcur_list = self.tweets[tweetName]\\n\\t\\t\\tl = 0\\n\\t\\t\\tr = len(cur_list) \\n\\t\\t\\twhile l < r:\\n\\t\\t\\t\\tmid = (l+r) // 2\\n\\t\\t\\t\\tif cur_list[mid] < time:\\n\\t\\t\\t\\t\\tl = mid + 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tr = mid\\n\\n\\t\\t\\treturn l\\n\\n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 540412,
                "title": "c-lower-bound-and-upper-bound-in-set",
                "content": "```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, set<int>> tweets;\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) { // in seconds\\n        tweets[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int n(freq[0] == \\'m\\' ? 60 : freq[0] == \\'h\\' ? 3600 : 86400);\\n        for (int i = startTime; i <= endTime; i += n)\\n            ans.push_back(distance(tweets[tweetName].lower_bound(i), tweets[tweetName].upper_bound(min(i + n - 1, endTime))));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, set<int>> tweets;\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) { // in seconds\\n        tweets[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int n(freq[0] == \\'m\\' ? 60 : freq[0] == \\'h\\' ? 3600 : 86400);\\n        for (int i = startTime; i <= endTime; i += n)\\n            ans.push_back(distance(tweets[tweetName].lower_bound(i), tweets[tweetName].upper_bound(min(i + n - 1, endTime))));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505752,
                "title": "java-straight-forward-solution-with-hashmap-and-priorityqueue",
                "content": "My idea is to associate eahc tweet\\'s name with its timestamp, and by using PriorityQueue for each tweet, we can ensure the timestamps we store is sorted. The, what is left is to count the occurence of tweet in each interval.\\n```\\nclass TweetCounts {\\n    Map<String, PriorityQueue<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<String, PriorityQueue<Integer>>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (!map.containsKey(tweetName)) {\\n            map.put(tweetName, new PriorityQueue<Integer>());\\n        }\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        PriorityQueue<Integer> pq = map.containsKey(tweetName) ? map.get(tweetName) : null;\\n        int delta = getDelta(freq);\\n        int start = startTime, end = Math.min(startTime + delta, endTime + 1);\\n        List<Integer> list = new ArrayList<>();\\n        while (start < end) {\\n            int f = 0;\\n            while (pq.size() > 0 && pq.peek() >= start && pq.peek() < end) {\\n                f++;\\n                list.add(pq.poll());\\n            }\\n            // if the current timestamp is smaller than the current interval, move\\n            // on to the next timestamp, otherwise, move to the next interval\\n            if (pq.size() > 0 && pq.peek() < start) {\\n                list.add(pq.poll());\\n            } else {\\n                result.add(f);\\n                start += delta;\\n                end += delta;\\n                end = Math.min(end, endTime + 1);\\n            }\\n        }\\n        for (int num : list) pq.add(num);\\n        return result;\\n    }\\n    /**\\n     * The helper function to get the delta based on freq\\n     */\\n    private int getDelta(String freq) {\\n        if (freq.equals(\"minute\")) return 60;\\n        if (freq.equals(\"hour\")) return 60 * 60;\\n        if (freq.equals(\"day\")) return 24 * 60 * 60;\\n        return 60;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String, PriorityQueue<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<String, PriorityQueue<Integer>>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (!map.containsKey(tweetName)) {\\n            map.put(tweetName, new PriorityQueue<Integer>());\\n        }\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        PriorityQueue<Integer> pq = map.containsKey(tweetName) ? map.get(tweetName) : null;\\n        int delta = getDelta(freq);\\n        int start = startTime, end = Math.min(startTime + delta, endTime + 1);\\n        List<Integer> list = new ArrayList<>();\\n        while (start < end) {\\n            int f = 0;\\n            while (pq.size() > 0 && pq.peek() >= start && pq.peek() < end) {\\n                f++;\\n                list.add(pq.poll());\\n            }\\n            // if the current timestamp is smaller than the current interval, move\\n            // on to the next timestamp, otherwise, move to the next interval\\n            if (pq.size() > 0 && pq.peek() < start) {\\n                list.add(pq.poll());\\n            } else {\\n                result.add(f);\\n                start += delta;\\n                end += delta;\\n                end = Math.min(end, endTime + 1);\\n            }\\n        }\\n        for (int num : list) pq.add(num);\\n        return result;\\n    }\\n    /**\\n     * The helper function to get the delta based on freq\\n     */\\n    private int getDelta(String freq) {\\n        if (freq.equals(\"minute\")) return 60;\\n        if (freq.equals(\"hour\")) return 60 * 60;\\n        if (freq.equals(\"day\")) return 24 * 60 * 60;\\n        return 60;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503884,
                "title": "why-my-segment-tree-solution-can-t-work",
                "content": "This segmentree code can pass https://leetcode.com/problems/range-sum-query-mutable/ and https://leetcode.com/problems/count-of-smaller-numbers-after-self/\\n\\n```\\nclass SegmentTree{\\n    SegmentTree left, right;\\n    int from, to;\\n    int sum;\\n    public SegmentTree(int f, int t){\\n        from = f;\\n        to = t;\\n    }\\n    public void insert(int p, int v){\\n        int mid = from + (to - from) / 2;\\n        if (left == null){\\n            left = new SegmentTree(from, mid);\\n        }\\n        if (right == null){\\n            right = new SegmentTree(mid, to);\\n        }\\n        if (p == from && p + 1 == to){\\n            sum = v;\\n            return;\\n        }\\n        if (p < mid){\\n            left.insert(p, v);\\n        }else{\\n            right.insert(p, v);\\n        }\\n        sum = left.sum + right.sum;\\n    }\\n    public int getSum(int f, int t){\\n        int mid = from + (to - from) / 2;\\n        if (f == from && t == to){\\n            return sum;\\n        }\\n        if (t <= mid){\\n            return left == null ? 0 : left.getSum(f, t);\\n        }else if (f >= mid){\\n            return right == null ? 0: right.getSum(f, t);\\n        }\\n        return  (left == null ? 0 : left.getSum(f, mid)) + (right == null ? 0 : right.getSum(mid, t));\\n    }\\n}\\nclass TweetCounts {\\n    Map<String, SegmentTree> mp;\\n    Map<String, Integer> freqMap;\\n    public TweetCounts() {\\n        mp = new HashMap<>();\\n        freqMap = new HashMap<>();\\n        freqMap.put(\"minute\", 60);\\n        freqMap.put(\"hour\", 60 * 60);\\n        freqMap.put(\"day\", 24 * 60 * 60);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        mp.compute(tweetName, (k, v) -> v == null ? new SegmentTree(0, 2000000000) : v).insert(time, 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int step = freqMap.getOrDefault(freq, 24 * 60 * 60);\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = startTime; i <= endTime; i += step){\\n            if (!mp.containsKey(tweetName)){\\n                ans.add(0);\\n                continue;\\n            }\\n            SegmentTree root = mp.get(tweetName);\\n            ans.add(root.getSum(i, i + step));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree{\\n    SegmentTree left, right;\\n    int from, to;\\n    int sum;\\n    public SegmentTree(int f, int t){\\n        from = f;\\n        to = t;\\n    }\\n    public void insert(int p, int v){\\n        int mid = from + (to - from) / 2;\\n        if (left == null){\\n            left = new SegmentTree(from, mid);\\n        }\\n        if (right == null){\\n            right = new SegmentTree(mid, to);\\n        }\\n        if (p == from && p + 1 == to){\\n            sum = v;\\n            return;\\n        }\\n        if (p < mid){\\n            left.insert(p, v);\\n        }else{\\n            right.insert(p, v);\\n        }\\n        sum = left.sum + right.sum;\\n    }\\n    public int getSum(int f, int t){\\n        int mid = from + (to - from) / 2;\\n        if (f == from && t == to){\\n            return sum;\\n        }\\n        if (t <= mid){\\n            return left == null ? 0 : left.getSum(f, t);\\n        }else if (f >= mid){\\n            return right == null ? 0: right.getSum(f, t);\\n        }\\n        return  (left == null ? 0 : left.getSum(f, mid)) + (right == null ? 0 : right.getSum(mid, t));\\n    }\\n}\\nclass TweetCounts {\\n    Map<String, SegmentTree> mp;\\n    Map<String, Integer> freqMap;\\n    public TweetCounts() {\\n        mp = new HashMap<>();\\n        freqMap = new HashMap<>();\\n        freqMap.put(\"minute\", 60);\\n        freqMap.put(\"hour\", 60 * 60);\\n        freqMap.put(\"day\", 24 * 60 * 60);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        mp.compute(tweetName, (k, v) -> v == null ? new SegmentTree(0, 2000000000) : v).insert(time, 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int step = freqMap.getOrDefault(freq, 24 * 60 * 60);\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = startTime; i <= endTime; i += step){\\n            if (!mp.containsKey(tweetName)){\\n                ans.add(0);\\n                continue;\\n            }\\n            SegmentTree root = mp.get(tweetName);\\n            ans.add(root.getSum(i, i + step));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503641,
                "title": "c-solution",
                "content": "```\\nclass TweetCounts {\\npublic:\\n    map<string,multiset<int>> m ;\\n    TweetCounts() {\\n        ;\\n    }\\n    \\n    void recordTweet(string t, int time) {\\n        m[t].insert(time) ;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int s, int e) {\\n        vector<int> ans ;\\n        int invl ;\\n        if( freq == \"minute\" ) invl = 60 ;\\n        else if( freq == \"hour\" ) invl = 3600 ;\\n        else invl = 86400 ;\\n        auto it = m[t].begin() ;\\n        int val,c,a, b = s ;\\n        bool done = true ;\\n        while(done){\\n            a = b ;\\n            c = 0 ;\\n            b = b + invl ;\\n            if( b >= e+1){\\n                b = e+1 ;\\n                done = false ;\\n            }\\n            while( it!=m[t].end()){\\n                val = *it ;\\n                if( val >= a and val < b ) c++ ;\\n                else if( val >= b ) break ;\\n                it++ ;                \\n            }\\n            ans.push_back(c) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    map<string,multiset<int>> m ;\\n    TweetCounts() {\\n        ;\\n    }\\n    \\n    void recordTweet(string t, int time) {\\n        m[t].insert(time) ;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int s, int e) {\\n        vector<int> ans ;\\n        int invl ;\\n        if( freq == \"minute\" ) invl = 60 ;\\n        else if( freq == \"hour\" ) invl = 3600 ;\\n        else invl = 86400 ;\\n        auto it = m[t].begin() ;\\n        int val,c,a, b = s ;\\n        bool done = true ;\\n        while(done){\\n            a = b ;\\n            c = 0 ;\\n            b = b + invl ;\\n            if( b >= e+1){\\n                b = e+1 ;\\n                done = false ;\\n            }\\n            while( it!=m[t].end()){\\n                val = *it ;\\n                if( val >= a and val < b ) c++ ;\\n                else if( val >= b ) break ;\\n                it++ ;                \\n            }\\n            ans.push_back(c) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503579,
                "title": "python-better-than-100-hashmap-buckets-solution-in-o-n",
                "content": "This is a shitty problem. After checking other\\'s solution, I find this clean way to solve.\\n```\\nfrom collections import defaultdict\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.tweet_map = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        self.tweet_map[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if freq == \\'minute\\':\\n            delta = 60\\n        elif freq == \\'hour\\':\\n            delta = 60 * 60\\n        else:\\n            delta = 24 * 60 * 60\\n\\n        rst = [0] * ((endTime - startTime) / delta + 1)\\n        for time in self.tweet_map[tweetName]:\\n            if time < startTime or time > endTime:\\n                continue\\n            rst[(time - startTime) / delta] += 1\\n        return rst\\n\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.tweet_map = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        self.tweet_map[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if freq == \\'minute\\':\\n            delta = 60\\n        elif freq == \\'hour\\':\\n            delta = 60 * 60\\n        else:\\n            delta = 24 * 60 * 60\\n\\n        rst = [0] * ((endTime - startTime) / delta + 1)\\n        for time in self.tweet_map[tweetName]:\\n            if time < startTime or time > endTime:\\n                continue\\n            rst[(time - startTime) / delta] += 1\\n        return rst\\n\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163185,
                "title": "simple-explained-solution",
                "content": "\\n```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ruby",
                    "Bash",
                    "Swift",
                    "Scala"
                ],
                "code": "```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118943,
                "title": "binary-solution-c-hashmap",
                "content": "\\n\\n# Code : 1 (Optimal)\\n```\\nclass TweetCounts {\\n    unordered_map<string,map<int,int>>mp;\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = freq[0] == \\'m\\' ? 60 : (freq[0] == \\'h\\' ? 60*60 : 60*60*24);\\n\\n        vector<int>ans((endTime-startTime)/interval + 1,0);\\n        const auto &end = mp[tweetName].upper_bound(endTime);\\n        for(auto it = mp[tweetName].lower_bound(startTime);it != end;it++){\\n            ans[(it->first-startTime)/interval] += it->second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n# Code : 2\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        if(freq == \"hour\") interval *= 60;\\n        if(freq == \"day\") interval *= 60*24;\\n        vector<int>ans((endTime-startTime)/interval + 1,0);\\n        for(auto ti : mp[tweetName]){\\n            if(ti>= startTime and ti<=endTime)\\n                ans[(ti-startTime)/interval]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass TweetCounts {\\n    unordered_map<string,map<int,int>>mp;\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = freq[0] == \\'m\\' ? 60 : (freq[0] == \\'h\\' ? 60*60 : 60*60*24);\\n\\n        vector<int>ans((endTime-startTime)/interval + 1,0);\\n        const auto &end = mp[tweetName].upper_bound(endTime);\\n        for(auto it = mp[tweetName].lower_bound(startTime);it != end;it++){\\n            ans[(it->first-startTime)/interval] += it->second;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        if(freq == \"hour\") interval *= 60;\\n        if(freq == \"day\") interval *= 60*24;\\n        vector<int>ans((endTime-startTime)/interval + 1,0);\\n        for(auto ti : mp[tweetName]){\\n            if(ti>= startTime and ti<=endTime)\\n                ans[(ti-startTime)/interval]++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2124055,
                "title": "multiset",
                "content": "```\\nunordered_map<string,multiset<int>>m;\\npublic:\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    \\n    void recordTweet(string ttN, int t) {\\n        m[ttN].insert(t);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tN, int sT, int eT) {\\n        int intV=60;\\n        if(freq==\"hour\") intV=3600;\\n        else if(freq==\"day\") intV=86400;\\n        vector<int>ans((eT-sT)/intV+1);\\n        auto i = m[tN].lower_bound(sT);\\n        auto j = m[tN].upper_bound(eT);\\n        for(;i!=j;i++){\\n            ans[(*i-sT)/intV]++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nunordered_map<string,multiset<int>>m;\\npublic:\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    \\n    void recordTweet(string ttN, int t) {\\n        m[ttN].insert(t);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tN, int sT, int eT) {\\n        int intV=60;\\n        if(freq==\"hour\") intV=3600;\\n        else if(freq==\"day\") intV=86400;\\n        vector<int>ans((eT-sT)/intV+1);\\n        auto i = m[tN].lower_bound(sT);\\n        auto j = m[tN].upper_bound(eT);\\n        for(;i!=j;i++){\\n            ans[(*i-sT)/intV]++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2096410,
                "title": "java-treemap",
                "content": "```java\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass TweetCounts {\\n\\n  Map<String, TreeMap<Integer, Integer>> map;\\n\\n  public TweetCounts() {\\n    map = new HashMap<>();\\n  }\\n\\n  public void recordTweet(String tweetName, int time) {\\n    TreeMap<Integer, Integer> treeMap = map.computeIfAbsent(tweetName, (x) -> new TreeMap<>());\\n    treeMap.put(time, 1 + treeMap.getOrDefault(time, 0));\\n  }\\n\\n  public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n    int interval;\\n    switch (freq) {\\n      case \"minute\":\\n        interval = 60;\\n        break;\\n      case \"hour\":\\n        interval = 60 * 60;\\n        break;\\n      case \"day\":\\n        // pass through\\n      default:\\n        interval = 60 * 60 * 24;\\n    }\\n    int[] arr = new int[(endTime - startTime) / interval + 1];\\n    TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n    treeMap.subMap(startTime, true, endTime, true)\\n        .forEach((k, v) -> {\\n          arr[(k - startTime) / interval] += v;\\n        });\\n    return Arrays.stream(arr).boxed().collect(Collectors.toList());\\n  }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 =\\n * obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```java\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\nclass TweetCounts {\\n\\n  Map<String, TreeMap<Integer, Integer>> map;\\n\\n  public TweetCounts() {\\n    map = new HashMap<>();\\n  }\\n\\n  public void recordTweet(String tweetName, int time) {\\n    TreeMap<Integer, Integer> treeMap = map.computeIfAbsent(tweetName, (x) -> new TreeMap<>());\\n    treeMap.put(time, 1 + treeMap.getOrDefault(time, 0));\\n  }\\n\\n  public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n    int interval;\\n    switch (freq) {\\n      case \"minute\":\\n        interval = 60;\\n        break;\\n      case \"hour\":\\n        interval = 60 * 60;\\n        break;\\n      case \"day\":\\n        // pass through\\n      default:\\n        interval = 60 * 60 * 24;\\n    }\\n    int[] arr = new int[(endTime - startTime) / interval + 1];\\n    TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n    treeMap.subMap(startTime, true, endTime, true)\\n        .forEach((k, v) -> {\\n          arr[(k - startTime) / interval] += v;\\n        });\\n    return Arrays.stream(arr).boxed().collect(Collectors.toList());\\n  }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 =\\n * obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082267,
                "title": "very-concise-c-solution-using-map-o-n",
                "content": "\\n1. use map to store the time of every tweet differently using map<string , vector<int>> \\n2. while we get the required time start to end make start 0 and make end time = end - start \\n3. so that everytime slabs are like (0,k-1) (k ,2k-1) .....\\n4. we can get the number of range in which it falls  using simple ceil funtion like for k its 2nd and for 2k its 3 .\\n5. simply increase the count of that range by 1 if the current tweeted time falls in that range .\\n```\\nclass TweetCounts {\\npublic:\\n    map<string ,vector<int>> m;\\n    \\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string t, int time) {\\n        m[t].push_back(time);\\n        \\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int startTime, int endTime) {\\n        \\n        int k;\\n        if(freq==\"minute\")\\n        {\\n            k=60;\\n        }\\n        else if(freq==\"hour\")\\n            k=3600;\\n        else\\n            k=86400;\\n        \\n        int end=endTime-startTime;\\n        \\n        vector<int> ans(ceil((end+1)/(k*1.0)),0);\\n        for(int i=0;i<m[t].size();i++)\\n        {\\n            if((m[t][i]-startTime)<=end && (m[t][i]-startTime)>=0)\\n            {\\n                ans[ceil((m[t][i]-startTime+1)/(k*1.0))-1]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```\\n \\n Upvote is not a must but good if u do XD\\n \\n \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    map<string ,vector<int>> m;\\n    \\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string t, int time) {\\n        m[t].push_back(time);\\n        \\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int startTime, int endTime) {\\n        \\n        int k;\\n        if(freq==\"minute\")\\n        {\\n            k=60;\\n        }\\n        else if(freq==\"hour\")\\n            k=3600;\\n        else\\n            k=86400;\\n        \\n        int end=endTime-startTime;\\n        \\n        vector<int> ans(ceil((end+1)/(k*1.0)),0);\\n        for(int i=0;i<m[t].size();i++)\\n        {\\n            if((m[t][i]-startTime)<=end && (m[t][i]-startTime)>=0)\\n            {\\n                ans[ceil((m[t][i]-startTime+1)/(k*1.0))-1]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2017563,
                "title": "using-hashmap",
                "content": "```\\nclass TweetCounts {\\n    private Map<String, List<Integer>> map;\\n    private static Map<String, Integer> intervalMap;\\n    static {\\n        intervalMap = new HashMap<>();\\n        intervalMap.put(\"minute\", 60);\\n        intervalMap.put(\"hour\", 60*60);\\n        intervalMap.put(\"day\", 24*60*60);\\n    }\\n    public TweetCounts() {\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        Integer interval = intervalMap.get(freq);\\n        for(int i=0; i<=(endTime-startTime)/interval; ++i) {\\n            res.add(0);\\n        }\\n        List<Integer> times = map.get(tweetName);\\n        for(int time : times) {\\n            if(time >= startTime && time <= endTime) {\\n                int idx = (time-startTime)/interval;\\n                res.set(idx, res.get(idx)+1);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    private Map<String, List<Integer>> map;\\n    private static Map<String, Integer> intervalMap;\\n    static {\\n        intervalMap = new HashMap<>();\\n        intervalMap.put(\"minute\", 60);\\n        intervalMap.put(\"hour\", 60*60);\\n        intervalMap.put(\"day\", 24*60*60);\\n    }\\n    public TweetCounts() {\\n        map = new HashMap<>(); \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        Integer interval = intervalMap.get(freq);\\n        for(int i=0; i<=(endTime-startTime)/interval; ++i) {\\n            res.add(0);\\n        }\\n        List<Integer> times = map.get(tweetName);\\n        for(int time : times) {\\n            if(time >= startTime && time <= endTime) {\\n                int idx = (time-startTime)/interval;\\n                res.set(idx, res.get(idx)+1);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1581183,
                "title": "clean-python-3-o-n-solution-with-comments",
                "content": "Very space efficient but open to ideas on how I could improve speed.\\n\\n```\\nclass TweetCounts:\\n    \\n    frequencies = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n\\n    def __init__(self):\\n        self.tweets = {}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        try:\\n            self.tweets[tweetName].append(time)\\n        except KeyError:\\n            self.tweets[tweetName] = []\\n            self.tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        #Find total amount of chunks by dividing the time range by the desired frequency\\n        tweetCounts = [0] * (((endTime - startTime) // self.frequencies[freq]) + 1)\\n        \\n        for tweetTime in self.tweets[tweetName]:\\n            #Offset tweetTime so a non-zero start time doesn\\'t push us into a bin ahead of the correct one\\n            targetChunk = (tweetTime - startTime) // self.frequencies[freq]\\n            \\n            if startTime <= tweetTime <= endTime:\\n                tweetCounts[targetChunk] += 1\\n                \\n        return tweetCounts",
                "solutionTags": [],
                "code": "Very space efficient but open to ideas on how I could improve speed.\\n\\n```\\nclass TweetCounts:\\n    \\n    frequencies = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n\\n    def __init__(self):\\n        self.tweets = {}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        try:\\n            self.tweets[tweetName].append(time)\\n        except KeyError:\\n            self.tweets[tweetName] = []\\n            self.tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        #Find total amount of chunks by dividing the time range by the desired frequency\\n        tweetCounts = [0] * (((endTime - startTime) // self.frequencies[freq]) + 1)\\n        \\n        for tweetTime in self.tweets[tweetName]:\\n            #Offset tweetTime so a non-zero start time doesn\\'t push us into a bin ahead of the correct one\\n            targetChunk = (tweetTime - startTime) // self.frequencies[freq]\\n            \\n            if startTime <= tweetTime <= endTime:\\n                tweetCounts[targetChunk] += 1\\n                \\n        return tweetCounts",
                "codeTag": "Java"
            },
            {
                "id": 1484734,
                "title": "c-108ms-49-simple-small-easy",
                "content": "Runtime: 108 ms, faster than 49.12% of C++ online submissions for Tweet Counts Per Frequency.\\nMemory Usage: 40.5 MB, less than 51.64% of C++ online submissions for Tweet Counts Per Frequency.\\n```\\nclass TweetCounts {\\npublic:\\n  unordered_map<string, vector<int>> t;\\n      \\n  void recordTweet(string tN, int time) { \\n    t[tN].insert(upper_bound(t[tN].begin(), t[tN].end(), time), time);\\n  }\\n    \\n  vector<int> getTweetCountsPerFrequency(string freq, string tN, int startTime, int endTime) {\\n    vector<int>res;\\n    int sh = freq[0] == \\'m\\' ? sh = 60 : freq[0] == \\'h\\' ? sh = 3600 : sh = 86400;\\n    \\n    auto id = upper_bound(t[tN].begin(), t[tN].end(), --startTime);\\n    \\n    while(startTime != endTime){\\n      startTime = min(endTime, startTime + sh);\\n      auto id_next = upper_bound(id, t[tN].end(), startTime);\\n      res.push_back(id_next - id);\\n      id = id_next;\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n  unordered_map<string, vector<int>> t;\\n      \\n  void recordTweet(string tN, int time) { \\n    t[tN].insert(upper_bound(t[tN].begin(), t[tN].end(), time), time);\\n  }\\n    \\n  vector<int> getTweetCountsPerFrequency(string freq, string tN, int startTime, int endTime) {\\n    vector<int>res;\\n    int sh = freq[0] == \\'m\\' ? sh = 60 : freq[0] == \\'h\\' ? sh = 3600 : sh = 86400;\\n    \\n    auto id = upper_bound(t[tN].begin(), t[tN].end(), --startTime);\\n    \\n    while(startTime != endTime){\\n      startTime = min(endTime, startTime + sh);\\n      auto id_next = upper_bound(id, t[tN].end(), startTime);\\n      res.push_back(id_next - id);\\n      id = id_next;\\n    }\\n    \\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354114,
                "title": "sorteddict-python-o-log-n-for-both-operations",
                "content": "```\\nfrom sortedcontainers import SortedDict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(SortedDict)       \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if time not in self.tweets[tweetName]:\\n            self.tweets[tweetName][time] = 0\\n        self.tweets[tweetName][time] += 1\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        skip = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n        res = [0]*((endTime - startTime) // skip + 1)\\n        for key in self.tweets[tweetName].irange(startTime, endTime):\\n            res[(key - startTime) // skip] += self.tweets[tweetName][key]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(SortedDict)       \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if time not in self.tweets[tweetName]:\\n            self.tweets[tweetName][time] = 0\\n        self.tweets[tweetName][time] += 1\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        skip = 60 if freq == \\'minute\\' else 3600 if freq == \\'hour\\' else 86400\\n        res = [0]*((endTime - startTime) // skip + 1)\\n        for key in self.tweets[tweetName].irange(startTime, endTime):\\n            res[(key - startTime) // skip] += self.tweets[tweetName][key]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346937,
                "title": "golang-solution-binarysearch",
                "content": "there is standard library for binary search we can use.\\n`Sort.SearchInts` uses binary search to find element.\\n\\n```\\nvar freqMp = map[string]int{\"minute\":60,\"hour\":3600,\"day\":86400}\\ntype TweetCounts struct {\\n    tweets map[string][]int\\n}\\n\\n\\nfunc Constructor() TweetCounts {\\n    return TweetCounts{make(map[string][]int),}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    if _,ok:=this.tweets[tweetName];!ok{\\n        this.tweets[tweetName]=make([]int,0)\\n    }\\n    i:=0\\n    for ;i<len(this.tweets[tweetName]);i++{\\n        if time<this.tweets[tweetName][i]{\\n            break\\n        }\\n    }\\n    this.insert(tweetName,i,time)\\n}\\n\\nfunc (this *TweetCounts)insert(tweetName string,at,time int){\\n    temp:=make([]int,0)\\n    temp=append(temp,this.tweets[tweetName][:at]...)\\n    temp=append(temp,time)\\n    temp=append(temp,this.tweets[tweetName][at:]...)\\n    this.tweets[tweetName]=temp\\n}\\n\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n    counts:=make([]int,(endTime-startTime)/freqMp[freq]+1)\\n    start:=sort.SearchInts(this.tweets[tweetName],startTime)\\n    end:=sort.SearchInts(this.tweets[tweetName],endTime+1)\\n    for i:=start;i<end;i++{\\n        idx:=(this.tweets[tweetName][i]-startTime)/freqMp[freq]\\n        counts[idx]++\\n    }\\n    return counts\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar freqMp = map[string]int{\"minute\":60,\"hour\":3600,\"day\":86400}\\ntype TweetCounts struct {\\n    tweets map[string][]int\\n}\\n\\n\\nfunc Constructor() TweetCounts {\\n    return TweetCounts{make(map[string][]int),}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    if _,ok:=this.tweets[tweetName];!ok{\\n        this.tweets[tweetName]=make([]int,0)\\n    }\\n    i:=0\\n    for ;i<len(this.tweets[tweetName]);i++{\\n        if time<this.tweets[tweetName][i]{\\n            break\\n        }\\n    }\\n    this.insert(tweetName,i,time)\\n}\\n\\nfunc (this *TweetCounts)insert(tweetName string,at,time int){\\n    temp:=make([]int,0)\\n    temp=append(temp,this.tweets[tweetName][:at]...)\\n    temp=append(temp,time)\\n    temp=append(temp,this.tweets[tweetName][at:]...)\\n    this.tweets[tweetName]=temp\\n}\\n\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n    counts:=make([]int,(endTime-startTime)/freqMp[freq]+1)\\n    start:=sort.SearchInts(this.tweets[tweetName],startTime)\\n    end:=sort.SearchInts(this.tweets[tweetName],endTime+1)\\n    for i:=start;i<end;i++{\\n        idx:=(this.tweets[tweetName][i]-startTime)/freqMp[freq]\\n        counts[idx]++\\n    }\\n    return counts\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1326322,
                "title": "java-treemap-solution-with-time-complexity-analysis",
                "content": "My solution uses TreeMap to record the tweet count at a timestamp. Here is an analysis of the subMap method which is a key point when analysising the time complexity of the solution. While others have differnt perspectives on this, below is mine thought.\\n\\nTime complexity of the subMap(): O(lgn + n) --> O(n)\\n\\nThe O(lgn) is the cost of finding the `i`, lower boundary of the subMap. To find a target(or the least element larger or equal to the target) in a balanced binary search tree, lgn should be the worese case.\\n\\nThen it takes O(n) to iterate from the `i` to the rest elements one by one till `end`. Thanks to TreeMap as a SortedMap, when iterating using inorder traversal of a binary search tree, it will keep a sorted order so iteration can stop just at the `end`. The iterator.next() will cost O(1). Then from ` i ` to `end`, the worest case is n* O(1) = O(n) because the range can include all elements in the tree.\\n\\nPlease feel free to leave any comments.\\n\\n```\\nclass TweetCounts {\\n    // TreeMap records timestamp : count of tweet\\n    // Must use TreeMap not TreeSet becasue the recordTweet could be call mutiple times with the same tweet+timestamp\\n\\t// Maybe addTweet is a better name :)\\n    private Map<String, TreeMap<Integer, Integer>> tweetToTimestampMap = new HashMap<>();\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeMap<Integer, Integer> map = tweetToTimestampMap.get(tweetName);\\n        if (map == null) {\\n            map = new TreeMap<>();\\n            tweetToTimestampMap.put(tweetName, map);\\n            map.put(time, 1);\\n        } else {\\n            Integer count = map.get(time);\\n            if (count == null) {\\n                count = 0;\\n            }\\n\\n            count++;\\n            map.put(time, count);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = tweetToTimestampMap.get(tweetName);\\n        if (map == null) {\\n            return result;\\n        }\\n\\n        int interval = toInterval(freq);\\n        for (int i = startTime; i <= endTime; i = i + interval) {\\n            // [i, end]\\n            int end = Math.min(i + interval - 1, endTime);\\n            int sum = 0;\\n            for (int count : map.subMap(i, true, end, true).values()) {\\n                sum = sum + count;\\n            }\\n\\n            result.add(sum);\\n        }\\n\\n        return result;\\n    }\\n\\n    private int toInterval(String freq) {\\n        if (\"minute\".equals(freq)) {\\n            return 60;\\n        } else if (\"hour\".equals(freq)) {\\n            return 3600;\\n        } else if (\"day\".equals(freq)) {\\n            return 86400;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    // TreeMap records timestamp : count of tweet\\n    // Must use TreeMap not TreeSet becasue the recordTweet could be call mutiple times with the same tweet+timestamp\\n\\t// Maybe addTweet is a better name :)\\n    private Map<String, TreeMap<Integer, Integer>> tweetToTimestampMap = new HashMap<>();\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeMap<Integer, Integer> map = tweetToTimestampMap.get(tweetName);\\n        if (map == null) {\\n            map = new TreeMap<>();\\n            tweetToTimestampMap.put(tweetName, map);\\n            map.put(time, 1);\\n        } else {\\n            Integer count = map.get(time);\\n            if (count == null) {\\n                count = 0;\\n            }\\n\\n            count++;\\n            map.put(time, count);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        TreeMap<Integer, Integer> map = tweetToTimestampMap.get(tweetName);\\n        if (map == null) {\\n            return result;\\n        }\\n\\n        int interval = toInterval(freq);\\n        for (int i = startTime; i <= endTime; i = i + interval) {\\n            // [i, end]\\n            int end = Math.min(i + interval - 1, endTime);\\n            int sum = 0;\\n            for (int count : map.subMap(i, true, end, true).values()) {\\n                sum = sum + count;\\n            }\\n\\n            result.add(sum);\\n        }\\n\\n        return result;\\n    }\\n\\n    private int toInterval(String freq) {\\n        if (\"minute\".equals(freq)) {\\n            return 60;\\n        } else if (\"hour\".equals(freq)) {\\n            return 3600;\\n        } else if (\"day\".equals(freq)) {\\n            return 86400;\\n        } else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234845,
                "title": "python3-solution-with-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        # in secs\\n        self.tweets = collections.defaultdict(SortedList)\\n        self.window = {\"minute\": 60, \"hour\": 3600, \"day\":86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets[tweetName].add(time)\\n            \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        freq_n = self.window[freq]\\n        block = self.tweets[tweetName]\\n        res = [0] * ((endTime - startTime) // freq_n + 1)\\n        start_ind = block.bisect_left(startTime)\\n        end_ind =block.bisect_right(endTime)\\n        \\n        for i in range(start_ind, end_ind):\\n            which_time_block = (block[i] - startTime) // freq_n\\n            res[which_time_block] += 1\\n            \\n        return res\\n            \\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        # in secs\\n        self.tweets = collections.defaultdict(SortedList)\\n        self.window = {\"minute\": 60, \"hour\": 3600, \"day\":86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweets[tweetName].add(time)\\n            \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        freq_n = self.window[freq]\\n        block = self.tweets[tweetName]\\n        res = [0] * ((endTime - startTime) // freq_n + 1)\\n        start_ind = block.bisect_left(startTime)\\n        end_ind =block.bisect_right(endTime)\\n        \\n        for i in range(start_ind, end_ind):\\n            which_time_block = (block[i] - startTime) // freq_n\\n            res[which_time_block] += 1\\n            \\n        return res\\n            \\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1191739,
                "title": "intuitive-solution",
                "content": "```\\n// Space: O(N)\\nclass TweetCounts {\\n    Map<String, ArrayList<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n\\t// This should be very fast because we expect massive calls for \"recordTweet\" compared to \"getTweetCountsPerFrequency\"\\n\\t// Time: O(1)\\n    public void recordTweet(String tweetName, int time) {\\n        if ( map.containsKey(tweetName) ) {\\n            map.get(tweetName).add(time);\\n        }\\n        else {\\n            ArrayList<Integer> list = new ArrayList<>();\\n            list.add(time);\\n            map.put(tweetName, list);\\n        }\\n    }\\n    \\n\\t// Time: O(n). where n is highest tweeted #tag\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        ArrayList<Integer> time = map.get(tweetName);\\n        ArrayList<Integer> resultlist = new ArrayList<Integer>();\\n        int[] result;\\n        if ( freq.equals(\"minute\") ) {\\n            result = new int[ ((endTime-startTime)/60) + 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[ (t-startTime) / 60] += 1;\\n                }\\n            }\\n        }\\n        else if ( freq.equals(\"hour\") ) {\\n            result = new int[ ((endTime-startTime)/3600) + 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[ (t-startTime) / 3600] += 1;\\n                }\\n            }\\n        }\\n        else { // freq == day\\n            result = new int[ ((endTime-startTime) / 86400 )+ 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[(t-startTime) / 86400] += 1;\\n                }\\n            }\\n        }\\n        for ( int i = 0 ; i < result.length; i++ ) {\\n            resultlist.add(result[i]);\\n        }\\n        return resultlist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Space: O(N)\\nclass TweetCounts {\\n    Map<String, ArrayList<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n\\t// This should be very fast because we expect massive calls for \"recordTweet\" compared to \"getTweetCountsPerFrequency\"\\n\\t// Time: O(1)\\n    public void recordTweet(String tweetName, int time) {\\n        if ( map.containsKey(tweetName) ) {\\n            map.get(tweetName).add(time);\\n        }\\n        else {\\n            ArrayList<Integer> list = new ArrayList<>();\\n            list.add(time);\\n            map.put(tweetName, list);\\n        }\\n    }\\n    \\n\\t// Time: O(n). where n is highest tweeted #tag\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        ArrayList<Integer> time = map.get(tweetName);\\n        ArrayList<Integer> resultlist = new ArrayList<Integer>();\\n        int[] result;\\n        if ( freq.equals(\"minute\") ) {\\n            result = new int[ ((endTime-startTime)/60) + 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[ (t-startTime) / 60] += 1;\\n                }\\n            }\\n        }\\n        else if ( freq.equals(\"hour\") ) {\\n            result = new int[ ((endTime-startTime)/3600) + 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[ (t-startTime) / 3600] += 1;\\n                }\\n            }\\n        }\\n        else { // freq == day\\n            result = new int[ ((endTime-startTime) / 86400 )+ 1];\\n            for ( Integer t : time ) {\\n                if ( t >= startTime && t <= endTime ){\\n                    result[(t-startTime) / 86400] += 1;\\n                }\\n            }\\n        }\\n        for ( int i = 0 ; i < result.length; i++ ) {\\n            resultlist.add(result[i]);\\n        }\\n        return resultlist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1167306,
                "title": "passing-20-22-test-too-long-to-debug-javascript-maps",
                "content": "I\\'m passing 20/22 tests - I\\'m struggling to find the bug in my code\\n```\\nvar times\\nvar chunk\\n\\nvar TweetCounts = function() {\\n    day = new Map()\\n    minute = new Map()\\n    hour = new Map()\\n    times = { day, minute, hour}\\n    \\n    chunk = {\\n        day: 86400,\\n        hour: 3600,\\n        minute: 60\\n    }\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    addTweet(tweetName, time, times.minute)\\n    addTweet(tweetName, time, times.hour)\\n    addTweet(tweetName, time, times.day)\\n};\\n\\nvar addTweet = function(tweetName, time, map){\\n    var tweetAtTime = map.get(time)\\n    if(tweetAtTime !== undefined){\\n        tweetAtTime.push({tweetName, time})\\n    } else {\\n        map.set(time, [{tweetName, time}])\\n    }\\n}\\n\\n/** \\n * @param {string} freq \\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    var frequency = []\\n    while(startTime <= endTime){\\n        var count = 0\\n        var endInterval = startTime + chunk[freq] - 1\\n        var tweetTimes = times[freq]\\n        for (var key of tweetTimes.keys()){\\n            if(key < startTime || key > endInterval){\\n                continue\\n            }\\n            var tweets = tweetTimes.get(key)\\n            tweets.forEach(tweet => {\\n                if(tweet.tweetName === tweetName){\\n                    count++\\n                }\\n            })\\n        }\\n        frequency.push(count)\\n        startTime = endInterval >= endTime ? endTime + 1 : startTime + chunk[freq]\\n\\t\\t// I\\'ve also tried startTime = endInterval >= endTime ? endTime + 1 : endInterval + 1\\n    }\\n    return frequency\\n};\\n\\n/** \\n * Your TweetCounts object will be instantiated and called as such:\\n * var obj = new TweetCounts()\\n * obj.recordTweet(tweetName,time)\\n * var param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n */\\n ```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar times\\nvar chunk\\n\\nvar TweetCounts = function() {\\n    day = new Map()\\n    minute = new Map()\\n    hour = new Map()\\n    times = { day, minute, hour}\\n    \\n    chunk = {\\n        day: 86400,\\n        hour: 3600,\\n        minute: 60\\n    }\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    addTweet(tweetName, time, times.minute)\\n    addTweet(tweetName, time, times.hour)\\n    addTweet(tweetName, time, times.day)\\n};\\n\\nvar addTweet = function(tweetName, time, map){\\n    var tweetAtTime = map.get(time)\\n    if(tweetAtTime !== undefined){\\n        tweetAtTime.push({tweetName, time})\\n    } else {\\n        map.set(time, [{tweetName, time}])\\n    }\\n}\\n\\n/** \\n * @param {string} freq \\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    var frequency = []\\n    while(startTime <= endTime){\\n        var count = 0\\n        var endInterval = startTime + chunk[freq] - 1\\n        var tweetTimes = times[freq]\\n        for (var key of tweetTimes.keys()){\\n            if(key < startTime || key > endInterval){\\n                continue\\n            }\\n            var tweets = tweetTimes.get(key)\\n            tweets.forEach(tweet => {\\n                if(tweet.tweetName === tweetName){\\n                    count++\\n                }\\n            })\\n        }\\n        frequency.push(count)\\n        startTime = endInterval >= endTime ? endTime + 1 : startTime + chunk[freq]\\n\\t\\t// I\\'ve also tried startTime = endInterval >= endTime ? endTime + 1 : endInterval + 1\\n    }\\n    return frequency\\n};\\n\\n/** \\n * Your TweetCounts object will be instantiated and called as such:\\n * var obj = new TweetCounts()\\n * obj.recordTweet(tweetName,time)\\n * var param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1133537,
                "title": "python-manual-binary-search",
                "content": "```\\nfrom collections import defaultdict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetMap = defaultdict(list)\\n        \\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        times = self.tweetMap[tweetName]\\n        pos = self.binarySearch(times, time) + 1\\n        times.insert(pos, time)\\n        \\n        \\n        \\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        times = self.tweetMap[tweetName]\\n        result = []\\n        step = 60\\n\\n        if (freq == \"hour\"):\\n            step = 3600\\n        if (freq == \"day\"):\\n            step = 86400\\n        s = startTime\\n        while (s <= endTime):\\n            e = min(s + step, endTime + 1)\\n            if (s > times[len(times) - 1] or e < times[0] ):\\n                result.append(0)\\n            else:\\n                m = self.binarySearch(times, s)\\n                n = self.binarySearch(times, e)\\n                result.append(n - m)\\n\\n            s = s + step\\n            \\n\\n        return result\\n        \\n        \\n    def binarySearch(self, arr, item):\\n        start = 0\\n        end = len(arr) - 1\\n        ans = -1\\n        while (start <= end):\\n            mid = (start + end) //2\\n            if (item <= arr[mid]):\\n                end = mid - 1\\n            else:\\n                ans = mid\\n                start = mid + 1 \\n        return ans\\n ```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetMap = defaultdict(list)\\n        \\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        times = self.tweetMap[tweetName]\\n        pos = self.binarySearch(times, time) + 1\\n        times.insert(pos, time)\\n        \\n        \\n        \\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        times = self.tweetMap[tweetName]\\n        result = []\\n        step = 60\\n\\n        if (freq == \"hour\"):\\n            step = 3600\\n        if (freq == \"day\"):\\n            step = 86400\\n        s = startTime\\n        while (s <= endTime):\\n            e = min(s + step, endTime + 1)\\n            if (s > times[len(times) - 1] or e < times[0] ):\\n                result.append(0)\\n            else:\\n                m = self.binarySearch(times, s)\\n                n = self.binarySearch(times, e)\\n                result.append(n - m)\\n\\n            s = s + step\\n            \\n\\n        return result\\n        \\n        \\n    def binarySearch(self, arr, item):\\n        start = 0\\n        end = len(arr) - 1\\n        ans = -1\\n        while (start <= end):\\n            mid = (start + end) //2\\n            if (item <= arr[mid]):\\n                end = mid - 1\\n            else:\\n                ans = mid\\n                start = mid + 1 \\n        return ans\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1094496,
                "title": "binary-search-tree-approach",
                "content": "Runtime 85%.\\n\\nIn reality, tweets tend to arrive in (almost) sequential order. However, the tweets in this problem arrive out of order; hence, BST fits well, to keep the tree not so unbalanced.\\n```\\nclass BSTNode(object):\\n  def __init__(self, time):\\n    self.time = time\\n    self.left = None\\n    self.right = None\\n  \\n  def insert(self, time):\\n    if time <= self.time:\\n      if self.left:\\n        self.left.insert(time)\\n      else:\\n        self.left = BSTNode(time)\\n    else:\\n      if self.right:\\n        self.right.insert(time)\\n      else:\\n        self.right = BSTNode(time)\\n  \\n  def inorder(self, from_time):\\n    if from_time <= self.time:\\n      if self.left:\\n        yield from self.left.inorder(from_time)\\n      yield self.time\\n    if self.right:\\n      yield from self.right.inorder(from_time)      \\n\\nclass TweetCounts:\\n  def __init__(self):\\n    # space O(t*n)\\n\\t# where t is # of tweet names, n is average tweet count per tweet name\\n    self.tweet_to_bst = {}\\n    self.interval_sizes = {\\'day\\':86400, \\'hour\\':3600, \\'minute\\':60}\\n\\n  def recordTweet(self, tweetName, time):\\n    # average time O(log(n)) where n is average tweet count per tweet name\\n    if tweetName not in self.tweet_to_bst:\\n      self.tweet_to_bst[tweetName] = BSTNode(time)\\n    else:\\n      self.tweet_to_bst[tweetName].insert(time)\\n\\n  def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n    # average time O(log(n)+k)\\n    # where n is average tweet count per tweet name\\n    #   k is # of tweets within the given interval for the given tweet name\\n    intervals, size = [], self.interval_sizes[freq]\\n    for t in range(startTime, endTime+1, size):\\n      intervals.append(0)\\n    if tweetName not in self.tweet_to_bst:\\n      return intervals\\n    bst = self.tweet_to_bst[tweetName]\\n    for t in bst.inorder(startTime):\\n      if t > endTime: break\\n      intervals[int((t - startTime) / size)] += 1\\n    return intervals\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTNode(object):\\n  def __init__(self, time):\\n    self.time = time\\n    self.left = None\\n    self.right = None\\n  \\n  def insert(self, time):\\n    if time <= self.time:\\n      if self.left:\\n        self.left.insert(time)\\n      else:\\n        self.left = BSTNode(time)\\n    else:\\n      if self.right:\\n        self.right.insert(time)\\n      else:\\n        self.right = BSTNode(time)\\n  \\n  def inorder(self, from_time):\\n    if from_time <= self.time:\\n      if self.left:\\n        yield from self.left.inorder(from_time)\\n      yield self.time\\n    if self.right:\\n      yield from self.right.inorder(from_time)      \\n\\nclass TweetCounts:\\n  def __init__(self):\\n    # space O(t*n)\\n\\t# where t is # of tweet names, n is average tweet count per tweet name\\n    self.tweet_to_bst = {}\\n    self.interval_sizes = {\\'day\\':86400, \\'hour\\':3600, \\'minute\\':60}\\n\\n  def recordTweet(self, tweetName, time):\\n    # average time O(log(n)) where n is average tweet count per tweet name\\n    if tweetName not in self.tweet_to_bst:\\n      self.tweet_to_bst[tweetName] = BSTNode(time)\\n    else:\\n      self.tweet_to_bst[tweetName].insert(time)\\n\\n  def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n    # average time O(log(n)+k)\\n    # where n is average tweet count per tweet name\\n    #   k is # of tweets within the given interval for the given tweet name\\n    intervals, size = [], self.interval_sizes[freq]\\n    for t in range(startTime, endTime+1, size):\\n      intervals.append(0)\\n    if tweetName not in self.tweet_to_bst:\\n      return intervals\\n    bst = self.tweet_to_bst[tweetName]\\n    for t in bst.inorder(startTime):\\n      if t > endTime: break\\n      intervals[int((t - startTime) / size)] += 1\\n    return intervals\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1064176,
                "title": "python3-using-sortedcollections-and-bisect-yet-disappointing-performances-any-idea-why",
                "content": "I was expecting better performance for this code using `SortedList` (provided by the `sortedcontainers` module) along the associated binary search with `bisect_left`, `bisect_right`).\\n\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.sortedLists = defaultdict(SortedList)\\n        self.freqs = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.sortedLists[tweetName].add(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        sl = self.sortedLists[tweetName]\\n        delta = self.freqs[freq]\\n        out = []\\n        beg = startTime\\n        while beg <= endTime:\\n            end = min(beg + delta-1, endTime)\\n            left = sl.bisect_left(beg)    \\n            right = sl.bisect_right(end)\\n            out.append(right-left)\\n            beg += delta\\n        return out\\n```\\n\\nOnly beats 20% of the submissions, despite most of them looking like `O(n^2)` with `bisect.insort`.\\n\\nAFAIK `SortedList` implements a <b> Segment Tree Data Structure </b>, so I was expecting better.\\n\\nI must be missing something. Anyone knows what might explain such poor performances compared to the rest?\\n",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.sortedLists = defaultdict(SortedList)\\n        self.freqs = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.sortedLists[tweetName].add(time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        sl = self.sortedLists[tweetName]\\n        delta = self.freqs[freq]\\n        out = []\\n        beg = startTime\\n        while beg <= endTime:\\n            end = min(beg + delta-1, endTime)\\n            left = sl.bisect_left(beg)    \\n            right = sl.bisect_right(end)\\n            out.append(right-left)\\n            beg += delta\\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953878,
                "title": "swift-elegant-solution",
                "content": "class TweetCounts {\\n\\n    var dict: [String: [Int]] = [:]\\n    init() {\\n        \\n    }\\n    \\n    func recordTweet(_ tweetName: String, _ time: Int) {\\n        dict[tweetName, default: []].append(time)\\n    }\\n    \\n    func getTweetCountsPerFrequency(_ freq: String, _ tweetName: String, _ startTime: Int, _ endTime: Int) -> [Int] {\\n        \\n        var interval = 60\\n        \\n        if freq == \"day\" {\\n            interval *= 24 * 60\\n        }\\n        else if freq == \"hour\"{\\n            interval *= 60\\n        }           \\n         \\n        var r = (endTime - startTime)/interval\\n        print(r)\\n       \\n        //add one to r\\n        var result = Array(repeating:0, count: r+1)\\n        \\n        for time in dict[tweetName]! {\\n            if(startTime <= time && time <= endTime){\\n                var index = (time - startTime) / interval\\n                result[index] += 1 \\n            }\\n            else {}\\n        }\\n        \\n        return result\\n    }\\n    }\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * let obj = TweetCounts()\\n * obj.recordTweet(tweetName, time)\\n * let ret_2: [Int] = obj.getTweetCountsPerFrequency(freq, tweetName, startTime, endTime)\\n */",
                "solutionTags": [],
                "code": "class TweetCounts {\\n\\n    var dict: [String: [Int]] = [:]\\n    init() {\\n        \\n    }\\n    \\n    func recordTweet(_ tweetName: String, _ time: Int) {\\n        dict[tweetName, default: []].append(time)\\n    }\\n    \\n    func getTweetCountsPerFrequency(_ freq: String, _ tweetName: String, _ startTime: Int, _ endTime: Int) -> [Int] {\\n        \\n        var interval = 60\\n        \\n        if freq == \"day\" {\\n            interval *= 24 * 60\\n        }\\n        else if freq == \"hour\"{\\n            interval *= 60\\n        }           \\n         \\n        var r = (endTime - startTime)/interval\\n        print(r)\\n       \\n        //add one to r\\n        var result = Array(repeating:0, count: r+1)\\n        \\n        for time in dict[tweetName]! {\\n            if(startTime <= time && time <= endTime){\\n                var index = (time - startTime) / interval\\n                result[index] += 1 \\n            }\\n            else {}\\n        }\\n        \\n        return result\\n    }\\n    }\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * let obj = TweetCounts()\\n * obj.recordTweet(tweetName, time)\\n * let ret_2: [Int] = obj.getTweetCountsPerFrequency(freq, tweetName, startTime, endTime)\\n */",
                "codeTag": "Java"
            },
            {
                "id": 909150,
                "title": "unsure-why-larger-test-case-is-failing-javascript",
                "content": "I\\'m a bit stumped right now. I was hoping someone could tell me why this is failing the larger test case(linked at bottom). Thanks!\\n\\n```js\\nvar TweetCounts = function() {\\n    this.tweets = {}; // { name: [times]}\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time (seconds)\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n  this.tweets[tweetName] = this.tweets[tweetName] ? this.tweets[tweetName].concat(time) : [time];\\n};\\n\\nconst freqMapToSeconds = {\\n  minute: 60,\\n  hour: 3600,\\n  day: 86400\\n};\\n/** \\n * @param {string} freq - min, hour or day\\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n  // Get list of intervals\\n  const freqVal = freqMapToSeconds[freq];\\n  const tweetsArr = this.tweets[tweetName];\\n  const intervalCount = Math.ceil((endTime - startTime) / freqVal);\\n  const initArray = Array(intervalCount).fill(0);\\n  return tweetsArr.reduce((acc, time) => {\\n    if (time < startTime || time > endTime) {\\n      return acc;\\n    }\\n    // Get which index of the arr we want to up the count at\\n    const index = Math.floor((time - startTime) / freqVal);\\n    acc[index] = acc[index] ? ++acc[index] : 1;\\n    return acc;\\n  }, initArray);\\n};\\n```\\n[Failing input pastebin](https://pastebin.com/kef7qHzT)",
                "solutionTags": [],
                "code": "```js\\nvar TweetCounts = function() {\\n    this.tweets = {}; // { name: [times]}\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time (seconds)\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n  this.tweets[tweetName] = this.tweets[tweetName] ? this.tweets[tweetName].concat(time) : [time];\\n};\\n\\nconst freqMapToSeconds = {\\n  minute: 60,\\n  hour: 3600,\\n  day: 86400\\n};\\n/** \\n * @param {string} freq - min, hour or day\\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n  // Get list of intervals\\n  const freqVal = freqMapToSeconds[freq];\\n  const tweetsArr = this.tweets[tweetName];\\n  const intervalCount = Math.ceil((endTime - startTime) / freqVal);\\n  const initArray = Array(intervalCount).fill(0);\\n  return tweetsArr.reduce((acc, time) => {\\n    if (time < startTime || time > endTime) {\\n      return acc;\\n    }\\n    // Get which index of the arr we want to up the count at\\n    const index = Math.floor((time - startTime) / freqVal);\\n    acc[index] = acc[index] ? ++acc[index] : 1;\\n    return acc;\\n  }, initArray);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900899,
                "title": "c-8-line",
                "content": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        const int d = deltas.at(freq), n = 1 + (endTime - startTime) / d;\\n        vector<int> res(n);\\n        for(int t : m[tweetName])\\n            if(t >= startTime && t <= endTime) res[(t-startTime)/d]++;\\n        return res;\\n    }\\n    \\n    unordered_map<string, set<int>> m;\\n    const map<string, int> deltas = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 3600*24}};\\n};",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        const int d = deltas.at(freq), n = 1 + (endTime - startTime) / d;\\n        vector<int> res(n);\\n        for(int t : m[tweetName])\\n            if(t >= startTime && t <= endTime) res[(t-startTime)/d]++;\\n        return res;\\n    }\\n    \\n    unordered_map<string, set<int>> m;\\n    const map<string, int> deltas = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 3600*24}};\\n};",
                "codeTag": "Java"
            },
            {
                "id": 891379,
                "title": "simple-hash-bst-solution",
                "content": "```\\nfunction bst(val) {\\n    this.val = val\\n    this.left = null\\n    this.right = null\\n}\\n\\nfunction insert(root, val) {\\n    if (root.val >= val) {\\n        if (root.left) {\\n            insert(root.left, val)\\n        } else {\\n            root.left = new bst(val)\\n        }\\n    } else if (root.val < val) {\\n        if (root.right) {\\n            insert(root.right, val)\\n        } else {\\n            root.right = new bst(val)\\n        }\\n    }\\n}\\n\\nfunction traverse(root, startTime, endTime, cb) {\\n    if (root.val >= startTime && root.val <= endTime) {\\n        cb(root.val)    \\n    }\\n    if (root.left && root.val > startTime) {\\n        traverse(root.left, startTime, endTime, cb)\\n    }\\n    if (root.right && root.val < endTime) {\\n        traverse(root.right, startTime, endTime, cb)\\n    }\\n}\\n\\nvar TweetCounts = function() {\\n    this.tweets = {}\\n    this.freqs = {\\n        minute: 60,\\n        hour: 3600,\\n        day: 60 * 60 * 24\\n    }\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (this.tweets[tweetName]) {\\n        const times = this.tweets[tweetName]\\n        insert(times, time)    \\n    } else {\\n        this.tweets[tweetName] = new bst(time)\\n    }\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    let intervals = []\\n    const intervalDuration = this.freqs[freq]\\n    \\n    for (let interval = 0; interval < (endTime - startTime + 1) / intervalDuration; interval++) {\\n        intervals[interval] = 0\\n    }\\n    \\n    if (!this.tweets[tweetName]) {\\n        return intervals\\n    }\\n    \\n    const times = this.tweets[tweetName]\\n    traverse(times, startTime, endTime, val => {\\n        const interval = Math.floor((val - startTime) / intervalDuration)\\n        intervals[interval]++\\n    })\\n    return intervals\\n};\\n\\n ```",
                "solutionTags": [],
                "code": "```\\nfunction bst(val) {\\n    this.val = val\\n    this.left = null\\n    this.right = null\\n}\\n\\nfunction insert(root, val) {\\n    if (root.val >= val) {\\n        if (root.left) {\\n            insert(root.left, val)\\n        } else {\\n            root.left = new bst(val)\\n        }\\n    } else if (root.val < val) {\\n        if (root.right) {\\n            insert(root.right, val)\\n        } else {\\n            root.right = new bst(val)\\n        }\\n    }\\n}\\n\\nfunction traverse(root, startTime, endTime, cb) {\\n    if (root.val >= startTime && root.val <= endTime) {\\n        cb(root.val)    \\n    }\\n    if (root.left && root.val > startTime) {\\n        traverse(root.left, startTime, endTime, cb)\\n    }\\n    if (root.right && root.val < endTime) {\\n        traverse(root.right, startTime, endTime, cb)\\n    }\\n}\\n\\nvar TweetCounts = function() {\\n    this.tweets = {}\\n    this.freqs = {\\n        minute: 60,\\n        hour: 3600,\\n        day: 60 * 60 * 24\\n    }\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (this.tweets[tweetName]) {\\n        const times = this.tweets[tweetName]\\n        insert(times, time)    \\n    } else {\\n        this.tweets[tweetName] = new bst(time)\\n    }\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    let intervals = []\\n    const intervalDuration = this.freqs[freq]\\n    \\n    for (let interval = 0; interval < (endTime - startTime + 1) / intervalDuration; interval++) {\\n        intervals[interval] = 0\\n    }\\n    \\n    if (!this.tweets[tweetName]) {\\n        return intervals\\n    }\\n    \\n    const times = this.tweets[tweetName]\\n    traverse(times, startTime, endTime, val => {\\n        const interval = Math.floor((val - startTime) / intervalDuration)\\n        intervals[interval]++\\n    })\\n    return intervals\\n};\\n\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 755020,
                "title": "python3-solution-with-binary-insert",
                "content": "Using a diction to store the tweets, the key is the tweet name, the value is the sorted list of the time.  \\nThe triky part is the binary insertion, I am choosing left bound binary search, so it can be inserted with sorted order.  \\n\\n```\\nclass TweetCounts:\\n    \\n    FREQUENCE = {\\n        \\'minute\\' : 60,\\n        \\'hour\\' : 3600,\\n        \\'day\\' : 24*3600,\\n    }\\n\\n    def __init__(self):\\n        self.tweets_dict = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        if tweetName not in self.tweets_dict:\\n            self.tweets_dict[tweetName] = []\\n        \\n        left, right = 0, len(self.tweets_dict[tweetName])\\n        # left bound\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.tweets_dict[tweetName][mid] == time:\\n                right = mid\\n            elif self.tweets_dict[tweetName][mid] > time:\\n                right = mid\\n            elif self.tweets_dict[tweetName][mid] < time:\\n                left = mid + 1\\n        self.tweets_dict[tweetName].insert(left, time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        if tweetName not in self.tweets_dict:\\n            return []\\n        \\n        delta = TweetCounts.FREQUENCE[freq]\\n        \\n        num_intervals = (endTime - startTime) // delta + 1\\n        \\n        result = [0] * num_intervals\\n        \\n        for t in self.tweets_dict[tweetName]:\\n            if t < startTime:\\n                continue\\n            if t > endTime:\\n                break\\n            \\n            index = (t - startTime) // delta\\n            result[index] += 1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass TweetCounts:\\n    \\n    FREQUENCE = {\\n        \\'minute\\' : 60,\\n        \\'hour\\' : 3600,\\n        \\'day\\' : 24*3600,\\n    }\\n\\n    def __init__(self):\\n        self.tweets_dict = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        if tweetName not in self.tweets_dict:\\n            self.tweets_dict[tweetName] = []\\n        \\n        left, right = 0, len(self.tweets_dict[tweetName])\\n        # left bound\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if self.tweets_dict[tweetName][mid] == time:\\n                right = mid\\n            elif self.tweets_dict[tweetName][mid] > time:\\n                right = mid\\n            elif self.tweets_dict[tweetName][mid] < time:\\n                left = mid + 1\\n        self.tweets_dict[tweetName].insert(left, time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        if tweetName not in self.tweets_dict:\\n            return []\\n        \\n        delta = TweetCounts.FREQUENCE[freq]\\n        \\n        num_intervals = (endTime - startTime) // delta + 1\\n        \\n        result = [0] * num_intervals\\n        \\n        for t in self.tweets_dict[tweetName]:\\n            if t < startTime:\\n                continue\\n            if t > endTime:\\n                break\\n            \\n            index = (t - startTime) // delta\\n            result[index] += 1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746082,
                "title": "c-solution-beats-100-in-memory-and-speed-so-far",
                "content": "The idea is to keep the tweets in hierarchical dictionary so that given start and end time , we only fetchs the relvant tweets stat (by using additional  hierarchy that relates to time frames of 10000 second).\\n\\n```\\npublic class TweetCounts {\\n\\n    Dictionary<string, Dictionary<int, Dictionary<int,int>>> tweetsRepo ;\\n    \\n    public TweetCounts() { \\n        tweetsRepo = new Dictionary<string, Dictionary<int, Dictionary<int,int>>>();\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) \\n    {\\n        Dictionary<int, Dictionary<int,int>> tweetInfo ;\\n        if (!tweetsRepo.TryGetValue(tweetName, out tweetInfo)) {\\n            tweetInfo = new  Dictionary<int, Dictionary<int,int>>();\\n            tweetsRepo.Add(tweetName,tweetInfo) ;\\n        }\\n        \\n        int segment = time / 10000 ;  \\n        Dictionary<int,int> tweetSegmentInfo ;\\n        if (!tweetInfo.TryGetValue(segment, out tweetSegmentInfo)) {\\n            tweetSegmentInfo = new  Dictionary<int,int>();\\n            tweetInfo.Add(segment,tweetSegmentInfo) ;\\n        }\\n            \\n        int freq = 0 ;\\n        if (!tweetSegmentInfo.TryGetValue(time, out freq)) {   \\n            tweetSegmentInfo.Add(time,1) ;\\n        } else {\\n            tweetSegmentInfo[time] = freq+1;\\n        }  \\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency\\n    (\\n        string freq, \\n        string tweetName, \\n        int startTime, \\n        int endTime\\n    ) \\n    {\\n        int firstSegment = startTime / 10000 ;\\n        int secondSegment = endTime / 10000 ;\\n        \\n        var relevantSegments = new  List<Dictionary<int,int>>(); \\n        Dictionary<int, Dictionary<int,int>> tweetInfo = null ;\\n        if (tweetsRepo.TryGetValue(tweetName, out tweetInfo)) {\\n            Dictionary<int,int> ftweetSegmentInfo = null ;\\n            if (tweetInfo.TryGetValue(firstSegment, out ftweetSegmentInfo)) {\\n                relevantSegments.Add(ftweetSegmentInfo);\\n            }\\n            if (secondSegment > firstSegment) {\\n                Dictionary<int,int> stweetSegmentInfo = null ;\\n                if (tweetInfo.TryGetValue(secondSegment, out stweetSegmentInfo)) {\\n                    relevantSegments.Add(stweetSegmentInfo);\\n                }  \\n            }\\n        }\\n        \\n        int periodLength = 0 ;\\n        switch (freq) \\n        {\\n            case \"minute\" : \\n                periodLength = 60 ;\\n                break ;\\n            case \"hour\":\\n                periodLength = 3600 ;\\n                break;\\n            case \"day\":\\n                periodLength = 86400 ;\\n                break ;\\n        }\\n            \\n        int numberOfPeriods = 1 + (endTime - startTime) / periodLength ;\\n        int[] periodsInfo = new int[numberOfPeriods];\\n            \\n        foreach (Dictionary<int,int> segmentInfo in relevantSegments) {\\n            foreach (int second in segmentInfo.Keys.ToList<int>()) {\\n                if (second >= startTime && second <= endTime) {\\n                    int period = (second - startTime) / periodLength ;\\n                    periodsInfo[period] += segmentInfo[second];\\n                }    \\n            }\\n        }\\n        return periodsInfo.ToList<int>();    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TweetCounts {\\n\\n    Dictionary<string, Dictionary<int, Dictionary<int,int>>> tweetsRepo ;\\n    \\n    public TweetCounts() { \\n        tweetsRepo = new Dictionary<string, Dictionary<int, Dictionary<int,int>>>();\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) \\n    {\\n        Dictionary<int, Dictionary<int,int>> tweetInfo ;\\n        if (!tweetsRepo.TryGetValue(tweetName, out tweetInfo)) {\\n            tweetInfo = new  Dictionary<int, Dictionary<int,int>>();\\n            tweetsRepo.Add(tweetName,tweetInfo) ;\\n        }\\n        \\n        int segment = time / 10000 ;  \\n        Dictionary<int,int> tweetSegmentInfo ;\\n        if (!tweetInfo.TryGetValue(segment, out tweetSegmentInfo)) {\\n            tweetSegmentInfo = new  Dictionary<int,int>();\\n            tweetInfo.Add(segment,tweetSegmentInfo) ;\\n        }\\n            \\n        int freq = 0 ;\\n        if (!tweetSegmentInfo.TryGetValue(time, out freq)) {   \\n            tweetSegmentInfo.Add(time,1) ;\\n        } else {\\n            tweetSegmentInfo[time] = freq+1;\\n        }  \\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency\\n    (\\n        string freq, \\n        string tweetName, \\n        int startTime, \\n        int endTime\\n    ) \\n    {\\n        int firstSegment = startTime / 10000 ;\\n        int secondSegment = endTime / 10000 ;\\n        \\n        var relevantSegments = new  List<Dictionary<int,int>>(); \\n        Dictionary<int, Dictionary<int,int>> tweetInfo = null ;\\n        if (tweetsRepo.TryGetValue(tweetName, out tweetInfo)) {\\n            Dictionary<int,int> ftweetSegmentInfo = null ;\\n            if (tweetInfo.TryGetValue(firstSegment, out ftweetSegmentInfo)) {\\n                relevantSegments.Add(ftweetSegmentInfo);\\n            }\\n            if (secondSegment > firstSegment) {\\n                Dictionary<int,int> stweetSegmentInfo = null ;\\n                if (tweetInfo.TryGetValue(secondSegment, out stweetSegmentInfo)) {\\n                    relevantSegments.Add(stweetSegmentInfo);\\n                }  \\n            }\\n        }\\n        \\n        int periodLength = 0 ;\\n        switch (freq) \\n        {\\n            case \"minute\" : \\n                periodLength = 60 ;\\n                break ;\\n            case \"hour\":\\n                periodLength = 3600 ;\\n                break;\\n            case \"day\":\\n                periodLength = 86400 ;\\n                break ;\\n        }\\n            \\n        int numberOfPeriods = 1 + (endTime - startTime) / periodLength ;\\n        int[] periodsInfo = new int[numberOfPeriods];\\n            \\n        foreach (Dictionary<int,int> segmentInfo in relevantSegments) {\\n            foreach (int second in segmentInfo.Keys.ToList<int>()) {\\n                if (second >= startTime && second <= endTime) {\\n                    int period = (second - startTime) / periodLength ;\\n                    periodsInfo[period] += segmentInfo[second];\\n                }    \\n            }\\n        }\\n        return periodsInfo.ToList<int>();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606793,
                "title": "java",
                "content": "```\\nclass TweetCounts {\\n\\n    HashMap<String, TreeSet<Integer>> hm;\\n    \\n    public TweetCounts() {\\n        hm = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        hm.putIfAbsent(tweetName, new TreeSet<>());\\n        hm.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        if(freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else if(freq.equals(\"day\")) {\\n            interval = 86400;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        if(hm.containsKey(tweetName)) {\\n            TreeSet<Integer> set = hm.get(tweetName);\\n            for(int i=startTime; i<=endTime; i+= interval) {\\n                res.add(set.subSet(i, Math.min(i+interval, endTime + 1)).size());\\n            }\\n        } else {\\n            for(int i=startTime; i<=endTime; i+= interval) {\\n                res.add(0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    HashMap<String, TreeSet<Integer>> hm;\\n    \\n    public TweetCounts() {\\n        hm = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        hm.putIfAbsent(tweetName, new TreeSet<>());\\n        hm.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = 60;\\n        if(freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else if(freq.equals(\"day\")) {\\n            interval = 86400;\\n        }\\n        \\n        List<Integer> res = new ArrayList<>();\\n        if(hm.containsKey(tweetName)) {\\n            TreeSet<Integer> set = hm.get(tweetName);\\n            for(int i=startTime; i<=endTime; i+= interval) {\\n                res.add(set.subSet(i, Math.min(i+interval, endTime + 1)).size());\\n            }\\n        } else {\\n            for(int i=startTime; i<=endTime; i+= interval) {\\n                res.add(0);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 562107,
                "title": "python-straightforward-solution",
                "content": "```\\nclass TweetCounts:\\n    \\n    deltaDic = {\\n        \\'minute\\': 60, \\n        \\'hour\\': 3600,\\n        \\'day\\': 24 * 3600,\\n    }\\n\\n    def __init__(self):\\n        self.tweetDic = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if not tweetName in self.tweetDic:\\n            self.tweetDic[tweetName] = []\\n        self.tweetDic[tweetName].append(time)\\n        self.tweetDic[tweetName].sort()\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if not tweetName in self.tweetDic:\\n            return []\\n        \\n        delta = self.deltaDic[freq]\\n        output = [0] * ((endTime - startTime) // delta + 1)\\n        for t in self.tweetDic[tweetName]:\\n            if t < startTime:\\n                continue\\n            elif t > endTime:\\n                continue\\n            else:\\n                idx = (t - startTime) // delta\\n                output[idx] += 1\\n        \\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n    \\n    deltaDic = {\\n        \\'minute\\': 60, \\n        \\'hour\\': 3600,\\n        \\'day\\': 24 * 3600,\\n    }\\n\\n    def __init__(self):\\n        self.tweetDic = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if not tweetName in self.tweetDic:\\n            self.tweetDic[tweetName] = []\\n        self.tweetDic[tweetName].append(time)\\n        self.tweetDic[tweetName].sort()\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if not tweetName in self.tweetDic:\\n            return []\\n        \\n        delta = self.deltaDic[freq]\\n        output = [0] * ((endTime - startTime) // delta + 1)\\n        for t in self.tweetDic[tweetName]:\\n            if t < startTime:\\n                continue\\n            elif t > endTime:\\n                continue\\n            else:\\n                idx = (t - startTime) // delta\\n                output[idx] += 1\\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530977,
                "title": "java-map-string-treeset-integer-solution",
                "content": "```\\nclass TweetCounts {\\n    \\n    private Map<String, TreeSet<Integer>> map;\\n\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (map.get(tweetName) == null)\\n            map.put(tweetName, new TreeSet<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if (!map.containsKey(tweetName))\\n            return Collections.emptyList();\\n        \\n        int step = getStep(freq);\\n        List<Integer> res = new ArrayList<>();\\n        TreeSet<Integer> set = map.get(tweetName);\\n        \\n        for (int i=startTime; i<=endTime; i+=step) {\\n            res.add(set.subSet(i, Math.min(i + step, endTime + 1)).size());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getStep(String freq) {\\n        switch (freq) {\\n            case \"minute\": return 60;\\n            case \"hour\": return 3600;\\n            case \"day\": return 86400;\\n            default: throw new RuntimeException(\"Invalid frequency \" + freq);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    \\n    private Map<String, TreeSet<Integer>> map;\\n\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (map.get(tweetName) == null)\\n            map.put(tweetName, new TreeSet<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if (!map.containsKey(tweetName))\\n            return Collections.emptyList();\\n        \\n        int step = getStep(freq);\\n        List<Integer> res = new ArrayList<>();\\n        TreeSet<Integer> set = map.get(tweetName);\\n        \\n        for (int i=startTime; i<=endTime; i+=step) {\\n            res.add(set.subSet(i, Math.min(i + step, endTime + 1)).size());\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private int getStep(String freq) {\\n        switch (freq) {\\n            case \"minute\": return 60;\\n            case \"hour\": return 3600;\\n            case \"day\": return 86400;\\n            default: throw new RuntimeException(\"Invalid frequency \" + freq);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511092,
                "title": "accepted-java-treemap-based-solution",
                "content": "import java.util.*;\\n\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> tweetMap = new HashMap<String, TreeMap<Integer, Integer>>();\\n    private static Map<String, Integer> FREQUENCY_TO_SECONDS = new HashMap<String, Integer>();\\n    static {\\n        FREQUENCY_TO_SECONDS.put(\"minute\", 60);\\n        FREQUENCY_TO_SECONDS.put(\"hour\", 60*60);\\n        FREQUENCY_TO_SECONDS.put(\"day\", 24*60*60);\\n    };\\n    \\n    public TweetCounts() {\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (tweetMap.get(tweetName) != null) {\\n            TreeMap<Integer, Integer> tweetTimeMap = tweetMap.get(tweetName);\\n            tweetTimeMap.put(time, tweetTimeMap.getOrDefault(time, 1));\\n        } else {\\n            TreeMap<Integer, Integer> tweetTimeMap = new TreeMap<Integer, Integer>();\\n            tweetTimeMap.put(time, 1);\\n            tweetMap.put(tweetName, tweetTimeMap);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        TreeMap<Integer, Integer> tweetTimeMap = tweetMap.get(tweetName);\\n        List<Integer> results = new ArrayList<Integer>();\\n\\n        int startTimeMap = startTime;\\n\\n        while(startTimeMap <= endTime) {\\n          int endTimeMap = startTimeMap + FREQUENCY_TO_SECONDS.get(freq);\\n\\t\\t  \\n\\t\\t  //Careful here as the submap is fromInclusive : true to toInclusive false by default\\n          \\n\\t\\t  SortedMap<Integer, Integer> subMap = tweetTimeMap.subMap(startTimeMap,Math.min(endTimeMap, endTime+1));\\n          int sum = subMap.values().stream().reduce(0, Integer::sum);\\n          results.add(sum);\\n          startTimeMap = endTimeMap;\\n        }\\n\\n        return results;\\n        \\n    }\\n    \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */",
                "solutionTags": [],
                "code": "import java.util.*;\\n\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> tweetMap = new HashMap<String, TreeMap<Integer, Integer>>();\\n    private static Map<String, Integer> FREQUENCY_TO_SECONDS = new HashMap<String, Integer>();\\n    static {\\n        FREQUENCY_TO_SECONDS.put(\"minute\", 60);\\n        FREQUENCY_TO_SECONDS.put(\"hour\", 60*60);\\n        FREQUENCY_TO_SECONDS.put(\"day\", 24*60*60);\\n    };\\n    \\n    public TweetCounts() {\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if (tweetMap.get(tweetName) != null) {\\n            TreeMap<Integer, Integer> tweetTimeMap = tweetMap.get(tweetName);\\n            tweetTimeMap.put(time, tweetTimeMap.getOrDefault(time, 1));\\n        } else {\\n            TreeMap<Integer, Integer> tweetTimeMap = new TreeMap<Integer, Integer>();\\n            tweetTimeMap.put(time, 1);\\n            tweetMap.put(tweetName, tweetTimeMap);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        TreeMap<Integer, Integer> tweetTimeMap = tweetMap.get(tweetName);\\n        List<Integer> results = new ArrayList<Integer>();\\n\\n        int startTimeMap = startTime;\\n\\n        while(startTimeMap <= endTime) {\\n          int endTimeMap = startTimeMap + FREQUENCY_TO_SECONDS.get(freq);\\n\\t\\t  \\n\\t\\t  //Careful here as the submap is fromInclusive : true to toInclusive false by default\\n          \\n\\t\\t  SortedMap<Integer, Integer> subMap = tweetTimeMap.subMap(startTimeMap,Math.min(endTimeMap, endTime+1));\\n          int sum = subMap.values().stream().reduce(0, Integer::sum);\\n          results.add(sum);\\n          startTimeMap = endTimeMap;\\n        }\\n\\n        return results;\\n        \\n    }\\n    \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 508627,
                "title": "python-o-n-2-sol-by-dict-and-bisection-85-with-comment",
                "content": "Python O(n^2) sol. by dict and bisection.\\n\\n---\\n\\n```\\nfrom collections import defaultdict\\nfrom bisect import insort_left, bisect_left\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n\\n        # dictionary:\\n        # key   : tweetname\\n        # value : list of timestamps\\n        self.tweet_timestamp = defaultdict( list )            \\n\\n        \\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        # insert new timestamp for tweetName, and kepp in order\\n        insort_left( self.tweet_timestamp[tweetName], time )\\n\\n        \\n        \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        arr_timestamp = self.tweet_timestamp[tweetName]\\n        \\n        unit_size = None\\n        \\n        # compute unit size from given frequency\\n        if freq == \\'minute\\':\\n            unit_size = 60\\n        elif freq == \\'hour\\':\\n            unit_size = 60 * 60\\n        elif freq == \\'day\\':\\n            unit_size = 60 * 60 * 24\\n        \\n        # compute total number of intervals\\n        num_of_interval = (endTime - startTime)//unit_size + 1\\n        \\n        # list for output\\n        result = [ 0 for i in range(num_of_interval) ]\\n        \\n        # find the index of first timestamp in query range\\n        index = bisect_left(arr_timestamp, startTime)\\n        \\n        # update statistics of tweet occurrences based on specified interval\\n        while index < len(arr_timestamp) and arr_timestamp[index] <= endTime:\\n            result[ (arr_timestamp[index]-startTime) // unit_size ] += 1\\n            index += 1\\n            \\n        return result\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom bisect import insort_left, bisect_left\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n\\n        # dictionary:\\n        # key   : tweetname\\n        # value : list of timestamps\\n        self.tweet_timestamp = defaultdict( list )            \\n\\n        \\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        # insert new timestamp for tweetName, and kepp in order\\n        insort_left( self.tweet_timestamp[tweetName], time )\\n\\n        \\n        \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        arr_timestamp = self.tweet_timestamp[tweetName]\\n        \\n        unit_size = None\\n        \\n        # compute unit size from given frequency\\n        if freq == \\'minute\\':\\n            unit_size = 60\\n        elif freq == \\'hour\\':\\n            unit_size = 60 * 60\\n        elif freq == \\'day\\':\\n            unit_size = 60 * 60 * 24\\n        \\n        # compute total number of intervals\\n        num_of_interval = (endTime - startTime)//unit_size + 1\\n        \\n        # list for output\\n        result = [ 0 for i in range(num_of_interval) ]\\n        \\n        # find the index of first timestamp in query range\\n        index = bisect_left(arr_timestamp, startTime)\\n        \\n        # update statistics of tweet occurrences based on specified interval\\n        while index < len(arr_timestamp) and arr_timestamp[index] <= endTime:\\n            result[ (arr_timestamp[index]-startTime) // unit_size ] += 1\\n            index += 1\\n            \\n        return result\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508138,
                "title": "c-simple-vector-or-map-lower-bound-complexity-analysis",
                "content": "The tricky part is that we need to return the number of tweets in time slots statring at the specified ```startTime```, e.g.\\n```\\nstartTime=10, endTime=150, freq=minute results in 3 time slots:\\n10...69\\n70...129\\n130...150\\n```\\nSo we cannot pre-calculate anything and have to keep all times of tweets.\\n\\n**Solution with vector**\\n\\nThe easiest way is to keep them in a vector:\\n```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>> m; // tweet -> {time}\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int f=60;\\n        if(freq==\"hour\") f=60*60;\\n        if(freq==\"day\") f=60*60*24;\\n        int len=(endTime-startTime)/f+1;\\n        vector<int> res(len);\\n        for(int time:m[tweetName]) { // just loop all times and count matching\\n            if(time<startTime||time>endTime) continue;\\n            int slot = (time - startTime)/f;\\n            res[slot]++;\\n        }\\n        return res;\\n    }\\n};\\n ```\\n **Complexity:**\\nMemory: O(N)\\nSpeed adding one tweet:  O(1); for all tweets O(N)\\nSpeed getting statistics: O(N)\\nNote, that adding to an unordered_map and accessing and element in it is contstant time in average, so we can safely ignore this. \\n\\n**Solution with map**\\n\\nIn order to speed this up, we can pre-order the time of tweets and then we can loop them starting with the right one. \\nLower_bound will find the starting position in O(LogN) which is faster than just going through all tweets.\\nAdding an element to the map is O(logN) which is slower than O(1) for adding to the vector so the actual speed depends on the balance between adding tweets and getting the statistics.\\n\\n```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,map<int,int>> m; // tweet -> {time->count}\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName][time]++;\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int f=60;\\n        if(freq==\"hour\") f=60*60;\\n        if(freq==\"day\") f=60*60*24;\\n        int len=(endTime-startTime)/f+1;\\n        vector<int> res(len);\\n        for(auto it=m[tweetName].lower_bound(startTime); // from startTime: binary search\\n            it!=m[tweetName].end() && it->first<=endTime; // till endTime\\n            it++) {\\n            int time = it->first;\\n            int slot = (time - startTime)/f;\\n            res[slot] += it->second;\\n        }\\n        return res;\\n    }\\n};\\n ```\\n  **Complexity:**\\nMemory: O(N)\\nSpeed of adding one tweet:  O(LogN), all tweets: O(NLogN)\\nSpeed of getting statistics: O(LogN)\\n",
                "solutionTags": [],
                "code": "```startTime```\n```\\nstartTime=10, endTime=150, freq=minute results in 3 time slots:\\n10...69\\n70...129\\n130...150\\n```\n```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>> m; // tweet -> {time}\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int f=60;\\n        if(freq==\"hour\") f=60*60;\\n        if(freq==\"day\") f=60*60*24;\\n        int len=(endTime-startTime)/f+1;\\n        vector<int> res(len);\\n        for(int time:m[tweetName]) { // just loop all times and count matching\\n            if(time<startTime||time>endTime) continue;\\n            int slot = (time - startTime)/f;\\n            res[slot]++;\\n        }\\n        return res;\\n    }\\n};\\n ```\n```cpp\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,map<int,int>> m; // tweet -> {time->count}\\n    TweetCounts() {\\n        m.clear();\\n    }\\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName][time]++;\\n    }\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int f=60;\\n        if(freq==\"hour\") f=60*60;\\n        if(freq==\"day\") f=60*60*24;\\n        int len=(endTime-startTime)/f+1;\\n        vector<int> res(len);\\n        for(auto it=m[tweetName].lower_bound(startTime); // from startTime: binary search\\n            it!=m[tweetName].end() && it->first<=endTime; // till endTime\\n            it++) {\\n            int time = it->first;\\n            int slot = (time - startTime)/f;\\n            res[slot] += it->second;\\n        }\\n        return res;\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 507074,
                "title": "c-simple-solution",
                "content": "Just got a chance to work on it. Was busy during the contest.\\n```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        hash[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(hash.count(tweetName) == 0)\\n            return {};\\n        \\n        int f = 60;\\n        if(freq == \"minute\")    f = 60;\\n        else if(freq == \"hour\") f = 3600;\\n        else                    f = 3600 * 24;\\n        \\n        vector<int> ret((endTime-startTime)/f + 1 , 0);\\n        \\n        for(auto it = hash[tweetName].begin(); it != hash[tweetName].end(); ++it){\\n            int time = *it;\\n            if(time >= startTime && time <= endTime){\\n                int slot = (time-startTime)/f;\\n                ret[slot]++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n    map<string, set<int>> hash;\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        hash[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(hash.count(tweetName) == 0)\\n            return {};\\n        \\n        int f = 60;\\n        if(freq == \"minute\")    f = 60;\\n        else if(freq == \"hour\") f = 3600;\\n        else                    f = 3600 * 24;\\n        \\n        vector<int> ret((endTime-startTime)/f + 1 , 0);\\n        \\n        for(auto it = hash[tweetName].begin(); it != hash[tweetName].end(); ++it){\\n            int time = *it;\\n            if(time >= startTime && time <= endTime){\\n                int slot = (time-startTime)/f;\\n                ret[slot]++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n    map<string, set<int>> hash;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506660,
                "title": "python-straight-forward-solution",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.a = collections.defaultdict(list)\\n        self.dic = { \\'minute\\': 60, \\'hour\\':60*60, \\'day\\':60*60*24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.a[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, start: int, end: int) -> List[int]:\\n        cur = 0\\n        N = ((end -start)//self.dic[freq])+1\\n        lst = [0]*N\\n        for i in self.a[tweetName]:\\n            if i < start or i > end: continue\\n            lst[(i-start)//self.dic[freq]]+=1\\n        return lst\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.a = collections.defaultdict(list)\\n        self.dic = { \\'minute\\': 60, \\'hour\\':60*60, \\'day\\':60*60*24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.a[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, start: int, end: int) -> List[int]:\\n        cur = 0\\n        N = ((end -start)//self.dic[freq])+1\\n        lst = [0]*N\\n        for i in self.a[tweetName]:\\n            if i < start or i > end: continue\\n            lst[(i-start)//self.dic[freq]]+=1\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506337,
                "title": "easy-to-understand-python3-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dict_of_tweets = defaultdict(list)\\n        self.interval_division = {\"hour\" : 3600, \"minute\" : 60, \"day\": 3600 * 24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict_of_tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        list_of_tweet_timestamps = list(filter(lambda x: x >= startTime and x <= endTime, self.dict_of_tweets[tweetName]))\\n        \\n        number_to_divide = self.interval_division[freq]\\n        \\n        min_interval = startTime // number_to_divide\\n        max_interval = (endTime - startTime) // number_to_divide\\n        \\n        intervals = list(map(lambda x: (x - startTime) //number_to_divide, list_of_tweet_timestamps))\\n        \\n        return_list = [intervals.count(i) for i in range(max_interval + 1)]\\n        return return_list",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dict_of_tweets = defaultdict(list)\\n        self.interval_division = {\"hour\" : 3600, \"minute\" : 60, \"day\": 3600 * 24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict_of_tweets[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        list_of_tweet_timestamps = list(filter(lambda x: x >= startTime and x <= endTime, self.dict_of_tweets[tweetName]))\\n        \\n        number_to_divide = self.interval_division[freq]\\n        \\n        min_interval = startTime // number_to_divide\\n        max_interval = (endTime - startTime) // number_to_divide\\n        \\n        intervals = list(map(lambda x: (x - startTime) //number_to_divide, list_of_tweet_timestamps))\\n        \\n        return_list = [intervals.count(i) for i in range(max_interval + 1)]\\n        return return_list",
                "codeTag": "Java"
            },
            {
                "id": 504252,
                "title": "dumb-brute-force-accepted-python-c",
                "content": "Disappointed/motivated by LeetCode\\'s generally lousy testing, I tried a totally dumb brute force solution. To my further disappointment, it got accepted.\\n\\n**Python**\\n```\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.times = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        self.times[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        delta = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 24*60*60}[freq]\\n        result = []\\n        while startTime <= endTime:\\n            end = min(startTime + delta, endTime + 1)\\n            result.append(sum(startTime <= t < end\\n                              for t in self.times[tweetName]))\\n            startTime += delta\\n        return result\\n```\\n\\n**C++**\\n```\\nclass TweetCounts {\\npublic:\\n    map<string, vector<int>> times;\\n\\n    void recordTweet(string tweetName, int time) {\\n        times[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int delta = freq == \"minute\" ? 60 : freq == \"hour\" ? 60*60 : 24*60*60;\\n        vector<int> result;\\n        while (startTime <= endTime) {\\n            int end = min(startTime + delta, endTime + 1);\\n            int count = 0;\\n            for (int t : times[tweetName])\\n                count += startTime <= t && t < end;\\n            result.push_back(count);\\n            startTime += delta;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.times = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        self.times[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        delta = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 24*60*60}[freq]\\n        result = []\\n        while startTime <= endTime:\\n            end = min(startTime + delta, endTime + 1)\\n            result.append(sum(startTime <= t < end\\n                              for t in self.times[tweetName]))\\n            startTime += delta\\n        return result\\n```\n```\\nclass TweetCounts {\\npublic:\\n    map<string, vector<int>> times;\\n\\n    void recordTweet(string tweetName, int time) {\\n        times[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int delta = freq == \"minute\" ? 60 : freq == \"hour\" ? 60*60 : 24*60*60;\\n        vector<int> result;\\n        while (startTime <= endTime) {\\n            int end = min(startTime + delta, endTime + 1);\\n            int count = 0;\\n            for (int t : times[tweetName])\\n                count += startTime <= t && t < end;\\n            result.push_back(count);\\n            startTime += delta;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504057,
                "title": "java-simple-treemap-solution",
                "content": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)) {\\n            map.put(tweetName, new TreeMap<>());\\n        }\\n        TreeMap<Integer, Integer> count = map.get(tweetName);\\n        count.put(time, count.getOrDefault(time, 0) + 1);\\n    }\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        if(!map.containsKey(tweetName)) return result;\\n        TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n        int step = \"minute\".equals(freq) ? 60 : (\"hour\".equals(freq) ? 3600 : 3600 * 24);\\n        int cursor = startTime;\\n        while(cursor <= endTime) {\\n            int next = cursor + step > endTime ? endTime + 1: cursor + step;\\n            int count = 0;\\n            for(int i : treeMap.subMap(cursor, next).values()) count += i;\\n            result.add(count);\\n            cursor = next;\\n        }\\n        return result;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map;\\n\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)) {\\n            map.put(tweetName, new TreeMap<>());\\n        }\\n        TreeMap<Integer, Integer> count = map.get(tweetName);\\n        count.put(time, count.getOrDefault(time, 0) + 1);\\n    }\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        if(!map.containsKey(tweetName)) return result;\\n        TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n        int step = \"minute\".equals(freq) ? 60 : (\"hour\".equals(freq) ? 3600 : 3600 * 24);\\n        int cursor = startTime;\\n        while(cursor <= endTime) {\\n            int next = cursor + step > endTime ? endTime + 1: cursor + step;\\n            int count = 0;\\n            for(int i : treeMap.subMap(cursor, next).values()) count += i;\\n            result.add(count);\\n            cursor = next;\\n        }\\n        return result;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503864,
                "title": "java-messy-sol-clean-structure-finally-pass",
                "content": "Idea: sort each list, then binary search for the start and end index, then we can find out the size.\\n```\\nclass TweetCounts {\\n    Map<String,List<Integer>>map;\\n    public TweetCounts() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(map.containsKey(tweetName)){\\n            map.get(tweetName).add(time);\\n        }else{\\n            List<Integer>list=new ArrayList<>();\\n            list.add(time);\\n            map.put(tweetName,list);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer>ans=new ArrayList<>();\\n        if(!map.containsKey(tweetName))  return ans;\\n        int delta=0;\\n        if(freq.equals(\"minute\")){\\n            delta=60;\\n        }else if(freq.equals(\"hour\")){\\n            delta=3600;\\n        }else{\\n            delta=86400;\\n        }\\n        List<Integer>list=map.get(tweetName);\\n        Collections.sort(list);\\n        \\n        int start=startTime;\\n        int end=start;\\n        if(startTime==endTime){\\n            int s=binaryS(list,startTime);\\n            int e=binaryE(list,endTime);\\n            ans.add(e-s+1);\\n            return ans;\\n        }\\n        while(true){\\n            start=end;\\n            end+=delta;\\n            if(start>endTime){\\n                break;\\n            }//great\\n            if(end-1<=list.get(0)||start>list.get(list.size()-1)){\\n                ans.add(0); //not in range\\n                continue;\\n            }\\n            int indexS=0;int indexE=0;\\n            if(end>=endTime){\\n                if(start==endTime){\\n                    indexS=binaryS(list,start);\\n                    indexE=binaryE(list,endTime);\\n                }else{\\n                   indexS=binaryS(list,start);\\n                    indexE=binaryE(list,endTime-1); \\n                }\\n\\n            }else{\\n                indexS=binaryS(list,start);\\n                indexE=binaryE(list,end-1);\\n            }\\n            ans.add(indexE-indexS+1);\\n        }\\n        return ans;\\n    }\\n    public int binaryS(List<Integer>nums,int start){//find the first ele greater or eaual start\\n        int left=0;int right=nums.size()-1;\\n        int res=0;int target=start;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums.get(mid)>=target){\\n                res=mid;\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    public int binaryE(List<Integer>nums,int end){//find ele equal or less than end\\n        int left=0;int res=0;\\n        int right=nums.size()-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums.get(mid)>end){\\n                right=mid-1;\\n            }else{//<=\\n                res=mid;\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String,List<Integer>>map;\\n    public TweetCounts() {\\n        map=new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(map.containsKey(tweetName)){\\n            map.get(tweetName).add(time);\\n        }else{\\n            List<Integer>list=new ArrayList<>();\\n            list.add(time);\\n            map.put(tweetName,list);\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer>ans=new ArrayList<>();\\n        if(!map.containsKey(tweetName))  return ans;\\n        int delta=0;\\n        if(freq.equals(\"minute\")){\\n            delta=60;\\n        }else if(freq.equals(\"hour\")){\\n            delta=3600;\\n        }else{\\n            delta=86400;\\n        }\\n        List<Integer>list=map.get(tweetName);\\n        Collections.sort(list);\\n        \\n        int start=startTime;\\n        int end=start;\\n        if(startTime==endTime){\\n            int s=binaryS(list,startTime);\\n            int e=binaryE(list,endTime);\\n            ans.add(e-s+1);\\n            return ans;\\n        }\\n        while(true){\\n            start=end;\\n            end+=delta;\\n            if(start>endTime){\\n                break;\\n            }//great\\n            if(end-1<=list.get(0)||start>list.get(list.size()-1)){\\n                ans.add(0); //not in range\\n                continue;\\n            }\\n            int indexS=0;int indexE=0;\\n            if(end>=endTime){\\n                if(start==endTime){\\n                    indexS=binaryS(list,start);\\n                    indexE=binaryE(list,endTime);\\n                }else{\\n                   indexS=binaryS(list,start);\\n                    indexE=binaryE(list,endTime-1); \\n                }\\n\\n            }else{\\n                indexS=binaryS(list,start);\\n                indexE=binaryE(list,end-1);\\n            }\\n            ans.add(indexE-indexS+1);\\n        }\\n        return ans;\\n    }\\n    public int binaryS(List<Integer>nums,int start){//find the first ele greater or eaual start\\n        int left=0;int right=nums.size()-1;\\n        int res=0;int target=start;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums.get(mid)>=target){\\n                res=mid;\\n                right=mid-1;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n    public int binaryE(List<Integer>nums,int end){//find ele equal or less than end\\n        int left=0;int res=0;\\n        int right=nums.size()-1;\\n        while(left<=right){\\n            int mid=left+(right-left)/2;\\n            if(nums.get(mid)>end){\\n                right=mid-1;\\n            }else{//<=\\n                res=mid;\\n                left=mid+1;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503853,
                "title": "javascript-solution",
                "content": "```\\nvar TweetCounts = function() {\\n    this.tweetMap = new Map();\\n    this.secMap = { minute: 60, hour: 3600, day: 24 * 60 * 60 };\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (this.tweetMap.has(tweetName)) {\\n        const ts = this.tweetMap.get(tweetName);\\n        ts.push(time);\\n        ts.sort((a, b) => a - b);\\n    } else {\\n        this.tweetMap.set(tweetName, [time]);\\n    }\\n};\\n\\n/** \\n * @param {string} freq \\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    const res = [];\\n    const ts = this.tweetMap.has(tweetName) ? this.tweetMap.get(tweetName) : [];\\n    if (!ts.length) return res;\\n    const interval = this.secMap[freq];\\n\\n    while (startTime <= endTime) {\\n        let cnt = 0;\\n        for (let i = 0; i < ts.length; i++) {\\n            if (ts[i] >= startTime && ts[i] < Math.min(endTime + 1, startTime + interval)) {\\n                cnt++;\\n            }\\n        }\\n        res.push(cnt);\\n        startTime += interval;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar TweetCounts = function() {\\n    this.tweetMap = new Map();\\n    this.secMap = { minute: 60, hour: 3600, day: 24 * 60 * 60 };\\n};\\n\\n/** \\n * @param {string} tweetName \\n * @param {number} time\\n * @return {void}\\n */\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (this.tweetMap.has(tweetName)) {\\n        const ts = this.tweetMap.get(tweetName);\\n        ts.push(time);\\n        ts.sort((a, b) => a - b);\\n    } else {\\n        this.tweetMap.set(tweetName, [time]);\\n    }\\n};\\n\\n/** \\n * @param {string} freq \\n * @param {string} tweetName \\n * @param {number} startTime \\n * @param {number} endTime\\n * @return {number[]}\\n */\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    const res = [];\\n    const ts = this.tweetMap.has(tweetName) ? this.tweetMap.get(tweetName) : [];\\n    if (!ts.length) return res;\\n    const interval = this.secMap[freq];\\n\\n    while (startTime <= endTime) {\\n        let cnt = 0;\\n        for (let i = 0; i < ts.length; i++) {\\n            if (ts[i] >= startTime && ts[i] < Math.min(endTime + 1, startTime + interval)) {\\n                cnt++;\\n            }\\n        }\\n        res.push(cnt);\\n        startTime += interval;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503846,
                "title": "hashmap-and-sorting",
                "content": "class TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>> data;\\n    TweetCounts() {   \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        data[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> temp(data[tweetName].begin(),data[tweetName].end());\\n        sort(temp.begin(),temp.end());\\n        vector<int> res;\\n        if(freq==\"minute\"){\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+60-1;\\n            \\n            while(stTime<=endTime){\\n                //cout<<stTime<<\" \";\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+60;\\n            }\\n            if(stTime-60<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n        }\\n        else if(freq==\"hour\"){\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+3600-1;\\n            while(stTime<=endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+3600;\\n            }\\n            if(stTime-3600<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n            \\n        }\\n        else{\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+86400-1;\\n            while(stTime<=endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+86400;\\n            }\\n            if(stTime-86400<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>> data;\\n    TweetCounts() {   \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        data[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> temp(data[tweetName].begin(),data[tweetName].end());\\n        sort(temp.begin(),temp.end());\\n        vector<int> res;\\n        if(freq==\"minute\"){\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+60-1;\\n            \\n            while(stTime<=endTime){\\n                //cout<<stTime<<\" \";\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+60;\\n            }\\n            if(stTime-60<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n        }\\n        else if(freq==\"hour\"){\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+3600-1;\\n            while(stTime<=endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+3600;\\n            }\\n            if(stTime-3600<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n            \\n        }\\n        else{\\n            int i;\\n            for(i=0;i<temp.size() && temp[i]<startTime;i++);\\n            int stTime = startTime+86400-1;\\n            while(stTime<=endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=stTime;i++){\\n                    count++;\\n                }\\n                res.push_back(count);\\n                stTime = stTime+86400;\\n            }\\n            if(stTime-86400<endTime){\\n                int count =0;\\n                for(;i<temp.size() && temp[i]<=endTime;i++){\\n                        count++;\\n                }\\n                res.push_back(count);\\n            }\\n            \\n        }\\n        return res;\\n        \\n    }\\n};",
                "codeTag": "C++"
            },
            {
                "id": 503833,
                "title": "py3-ac-solution",
                "content": "It seems not so difficult as I had thought? This problem seems like one in the final exam of my C++ class...\\nJust solve it by the straightforward method.Sorting can make it easier.\\n```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetStore = {}\\n\\n    def recordTweet(self, tweetName, time) :\\n        if tweetName not in self.tweetStore :\\n            self.tweetStore[tweetName] = []\\n        self.tweetStore[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime) :\\n        inteval = 0\\n        if freq == \"minute\" : inteval = 60\\n        elif freq == \"hour\" : inteval = 3600\\n        elif freq == \"day\" : inteval = 86400\\n        \\n        self.tweetStore[tweetName].sort()  //After sorting,everything goes easy.\\n        \\n        ans_lst = [0]\\n        pt = 0  //define a point to indicate where we are in the ans_lst\\n        upper = startTime + inteval  //establish and maintain an upper bound while traversing\\n        for i in self.tweetStore[tweetName] :\\n            if startTime <= i and i <= endTime :\\n                while i >= upper : \\n                    upper += inteval\\n                    pt += 1\\n                    ans_lst.append(0)\\n                ans_lst[pt] += 1\\n                \\n        while upper <= endTime :  //After traversing all valid tweet,we should fill the next intervals with 0\\n            upper += inteval\\n            ans_lst.append(0)\\n        return ans_lst\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetStore = {}\\n\\n    def recordTweet(self, tweetName, time) :\\n        if tweetName not in self.tweetStore :\\n            self.tweetStore[tweetName] = []\\n        self.tweetStore[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime) :\\n        inteval = 0\\n        if freq == \"minute\" : inteval = 60\\n        elif freq == \"hour\" : inteval = 3600\\n        elif freq == \"day\" : inteval = 86400\\n        \\n        self.tweetStore[tweetName].sort()  //After sorting,everything goes easy.\\n        \\n        ans_lst = [0]\\n        pt = 0  //define a point to indicate where we are in the ans_lst\\n        upper = startTime + inteval  //establish and maintain an upper bound while traversing\\n        for i in self.tweetStore[tweetName] :\\n            if startTime <= i and i <= endTime :\\n                while i >= upper : \\n                    upper += inteval\\n                    pt += 1\\n                    ans_lst.append(0)\\n                ans_lst[pt] += 1\\n                \\n        while upper <= endTime :  //After traversing all valid tweet,we should fill the next intervals with 0\\n            upper += inteval\\n            ans_lst.append(0)\\n        return ans_lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503757,
                "title": "go-solution-beats-100",
                "content": "Noticed of line 31 and line 37:\\n\\n1. The length of result should be: result := make([]int, (endTime - startTime + interval) / interval)\\n2. The correct counting in the loop should be result[(time-startTime)/interval]++\\n\\nThat\\'s said, the start time is not 0, result[0] should be calculated from wherever the starttime begins, instead of 0.\\n\\nTime Complexity:\\n1. For RecordTweet, it is a hashmap insertion, which is `O(1)`;\\n2. For GetTweetCountsPerFrequency, it takes the array of time out from hashmap with the key tweetName, then iterate it from the beginning to the end. Therefore the time complexity is `O(n)`; \\n\\n```\\ntype TweetCounts struct {\\n    Tweet map[string][]int // key: name val: []int times\\n}\\n\\nfunc Constructor() TweetCounts {\\n    return TweetCounts{\\n        Tweet: map[string][]int{},\\n    }\\n}\\n\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    if _, ok := this.Tweet[tweetName]; !ok {\\n        this.Tweet[tweetName] = []int{time}\\n    } else {\\n        this.Tweet[tweetName] = append(this.Tweet[tweetName], time)\\n    }\\n}\\n\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n    interval := GetInterval(freq)\\n\\t\\n    if _, ok := this.Tweet[tweetName]; !ok {\\n        return []int{}\\n    }\\n    \\n    result := make([]int, (endTime - startTime + interval) / interval)\\n    for _, time := range this.Tweet[tweetName] {\\n        if time > endTime || time < startTime {\\n            continue\\n        }\\n        \\n        thisInterval := (time-startTime)/interval\\n        result[thisInterval]++\\n    }\\n    \\n    return result\\n}\\n\\n\\nfunc GetInterval(freq string) int {\\n    if freq == \"minute\" {\\n        return 60\\n    }\\n    \\n    if freq == \"hour\" {\\n        return 3600\\n    }\\n    \\n    if freq == \"day\" {\\n        return 86400\\n    }\\n    \\n    return 0 // never reach here\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TweetCounts struct {\\n    Tweet map[string][]int // key: name val: []int times\\n}\\n\\nfunc Constructor() TweetCounts {\\n    return TweetCounts{\\n        Tweet: map[string][]int{},\\n    }\\n}\\n\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    if _, ok := this.Tweet[tweetName]; !ok {\\n        this.Tweet[tweetName] = []int{time}\\n    } else {\\n        this.Tweet[tweetName] = append(this.Tweet[tweetName], time)\\n    }\\n}\\n\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n    interval := GetInterval(freq)\\n\\t\\n    if _, ok := this.Tweet[tweetName]; !ok {\\n        return []int{}\\n    }\\n    \\n    result := make([]int, (endTime - startTime + interval) / interval)\\n    for _, time := range this.Tweet[tweetName] {\\n        if time > endTime || time < startTime {\\n            continue\\n        }\\n        \\n        thisInterval := (time-startTime)/interval\\n        result[thisInterval]++\\n    }\\n    \\n    return result\\n}\\n\\n\\nfunc GetInterval(freq string) int {\\n    if freq == \"minute\" {\\n        return 60\\n    }\\n    \\n    if freq == \"hour\" {\\n        return 3600\\n    }\\n    \\n    if freq == \"day\" {\\n        return 86400\\n    }\\n    \\n    return 0 // never reach here\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 503674,
                "title": "java-using-map-and-binarysearch",
                "content": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>>map = new HashMap();\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.getOrDefault(tweetName, new ArrayList());\\n        list.add(time);\\n        map.put(tweetName, list);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList();\\n        if(!map.containsKey(tweetName))  return res;\\n        List<int[]> intervals = new ArrayList();\\n        int inCount = getIntervalCount(freq);\\n        \\n        int leftEnd =endTime;\\n        int start = startTime;\\n        int end = 0;\\n        while(end >= 0 && end < endTime) {\\n        \\n            end = Math.min(endTime, start+inCount);\\n            intervals.add(new int[]{start, end});\\n            start = end+1;\\n        }\\n        \\n        List<Integer> list = map.get(tweetName);\\n        Collections.sort(list);\\n        \\n        for(int[] interval : intervals) {\\n            int low = ceiling(list, interval[0]);\\n            int high = floor(list, interval[1]);\\n            int count = high - low + 1;\\n                \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(List<Integer> list, int low, int high) {\\n        int count = 0;\\n        for(Integer val : list) {\\n            if(val >=low && val<=high) {\\n                count++;\\n            }\\n            if(val > high) return count;\\n        }\\n        return count;\\n    }\\n    \\n    int floor(List<Integer> list, int val) {\\n        int low =0;\\n        int high = list.size()-1;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            if(list.get(mid)==val) return mid;\\n            if(list.get(mid) < val) {\\n                low = mid+1; \\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    int ceiling(List<Integer> list, int val) {\\n        int low =0;\\n        int high = list.size()-1;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            if(list.get(mid)==val) return mid;\\n            if(list.get(mid) < val) {\\n                low = mid+1; \\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int getIntervalCount(String freq) {\\n        if(freq.equals(\"minute\")) {\\n            return 60-1;\\n        } else if(freq.equals(\"hour\")) {\\n            return 3600-1;\\n            \\n        } else if(freq.equals(\"day\")) {\\n            return 86400-1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>>map = new HashMap();\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.getOrDefault(tweetName, new ArrayList());\\n        list.add(time);\\n        map.put(tweetName, list);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList();\\n        if(!map.containsKey(tweetName))  return res;\\n        List<int[]> intervals = new ArrayList();\\n        int inCount = getIntervalCount(freq);\\n        \\n        int leftEnd =endTime;\\n        int start = startTime;\\n        int end = 0;\\n        while(end >= 0 && end < endTime) {\\n        \\n            end = Math.min(endTime, start+inCount);\\n            intervals.add(new int[]{start, end});\\n            start = end+1;\\n        }\\n        \\n        List<Integer> list = map.get(tweetName);\\n        Collections.sort(list);\\n        \\n        for(int[] interval : intervals) {\\n            int low = ceiling(list, interval[0]);\\n            int high = floor(list, interval[1]);\\n            int count = high - low + 1;\\n                \\n            res.add(count);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int find(List<Integer> list, int low, int high) {\\n        int count = 0;\\n        for(Integer val : list) {\\n            if(val >=low && val<=high) {\\n                count++;\\n            }\\n            if(val > high) return count;\\n        }\\n        return count;\\n    }\\n    \\n    int floor(List<Integer> list, int val) {\\n        int low =0;\\n        int high = list.size()-1;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            if(list.get(mid)==val) return mid;\\n            if(list.get(mid) < val) {\\n                low = mid+1; \\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        return high;\\n    }\\n    \\n    int ceiling(List<Integer> list, int val) {\\n        int low =0;\\n        int high = list.size()-1;\\n        while(low<=high) {\\n            int mid = low + (high-low)/2;\\n            if(list.get(mid)==val) return mid;\\n            if(list.get(mid) < val) {\\n                low = mid+1; \\n            } else {\\n                high = mid-1;\\n            }\\n        }\\n        return low;\\n    }\\n    \\n    private int getIntervalCount(String freq) {\\n        if(freq.equals(\"minute\")) {\\n            return 60-1;\\n        } else if(freq.equals(\"hour\")) {\\n            return 3600-1;\\n            \\n        } else if(freq.equals(\"day\")) {\\n            return 86400-1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 503644,
                "title": "simple-map-solution-with-sort-finally-they-fixed-the-submission-bug",
                "content": "Time O(nlogn) cuz the sort\\nThe question screwed my contest and hurt my feelings. finally the submission bug is now fixed\\n```\\nclass TweetCounts {\\n    private Map<String,Integer> feqs = new HashMap<String,Integer>(){{\\n        put(\"day\",86400);\\n        put(\"hour\",3600);\\n        put(\"minute\",60);\\n    }};\\n    \\n    private Map<String,List<Integer>> map;\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.getOrDefault(tweetName,new ArrayList<>());\\n        list.add(time);\\n        map.putIfAbsent(tweetName,list);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> times = map.get(tweetName);\\n        if(times == null) return new ArrayList<>();\\n        Collections.sort(times);\\n        Integer val = feqs.get(freq);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        int start = startTime;\\n        int end = Math.min(startTime+val,endTime+1);\\n        int count = 0;\\n        int i = 0;\\n        \\n        while(end <=endTime+1){\\n            while(i<times.size() && times.get(i)<start)i++;\\n            while(i<times.size() && times.get(i)>= start && times.get(i)<end){\\n                i++;\\n                count++;\\n            }\\n            \\n            res.add(count);\\n            count = 0;\\n            \\n            if(end == endTime+1) break;\\n            start = end;\\n            end = Math.min(start+val,endTime+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    private Map<String,Integer> feqs = new HashMap<String,Integer>(){{\\n        put(\"day\",86400);\\n        put(\"hour\",3600);\\n        put(\"minute\",60);\\n    }};\\n    \\n    private Map<String,List<Integer>> map;\\n    public TweetCounts() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.getOrDefault(tweetName,new ArrayList<>());\\n        list.add(time);\\n        map.putIfAbsent(tweetName,list);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> times = map.get(tweetName);\\n        if(times == null) return new ArrayList<>();\\n        Collections.sort(times);\\n        Integer val = feqs.get(freq);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        \\n        int start = startTime;\\n        int end = Math.min(startTime+val,endTime+1);\\n        int count = 0;\\n        int i = 0;\\n        \\n        while(end <=endTime+1){\\n            while(i<times.size() && times.get(i)<start)i++;\\n            while(i<times.size() && times.get(i)>= start && times.get(i)<end){\\n                i++;\\n                count++;\\n            }\\n            \\n            res.add(count);\\n            count = 0;\\n            \\n            if(end == endTime+1) break;\\n            start = end;\\n            end = Math.min(start+val,endTime+1);\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503633,
                "title": "c-recoding-data-in-a-sorted-list",
                "content": "The basic idea is to use a map-like data structure for storing the tweets by their name and for every name, sort its timestamps in accending order for efficient search. With binary-search, every insertion takes O(2 * log n) time (first locale tweet name, and then insert the timestamp into the corresponding sorted list).\\n\\nWhen a query is encountered, we shall first compute all time intervals we need to look at and then count the frequency by simply traversing the recording list, which takes linear time (linear to the number of records). The first element we start with can be located via a binary-search for the `startTime`.\\n\\nEven if the above tactic did pass all tests, there exists a more efficient way of counting frequencies once you realize that the timestamps are already sorted. Suppose we are asked to count the frequencies of time intervals [t1, t2), [t2, t3) and [t3, t4), we can also obtain the first element that is greater or equal to t2, t3 and t4, respectively, via a binary-search (like we do for `startTime`) again! If there is a way to know the indexes of all these elements, then the answers are simply the diffrences between the endpoints of each interval. In this way,  no traversing is ever needed. The time complexity would be linear to the number of time intervals, which is smaller than the number of records. Since C++ iterators do not support arithmetic manipulation, I simply use the slower tactic, as illustrated by the following code:\\n\\n```c++\\nclass TweetCounts\\n{\\npublic:\\n    TweetCounts()\\n    {\\n    }\\n\\n    void recordTweet(string tweetName, int time)\\n    {\\n        if (tweets.find(tweetName) == tweets.end()) {\\n            list<int> records;\\n            records.push_back(time);\\n            tweets[tweetName] = records;\\n        } else {\\n            auto it = lower_bound(tweets[tweetName].begin(), tweets[tweetName].end(), time);\\n            tweets[tweetName].insert(it, time);\\n        }\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)\\n    {\\n\\t\\t// compute time interval: vector [t1, t2, t3, ...] stands for time intervals [t1, t2), [t2, t3), ...\\n        vector<int> interval;\\n        interval.push_back(startTime);\\n        int step = (freq[0] == \\'m\\') ? 60 : (freq[0] == \\'h\\') ? 60 * 60 : 60 * 60 * 24;\\n        while (true) {\\n            startTime += step;\\n            if (startTime < endTime + 1) {\\n                interval.push_back(startTime);\\n            } else {\\n                interval.push_back(endTime + 1);\\n                break;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        auto xs = (tweets.find(tweetName) == tweets.end()) ? list<int>() : tweets[tweetName];\\n        auto it = lower_bound(xs.begin(), xs.end(), interval.front()); // binary search for the starting iterator\\n        for (int i = 1; i < interval.size(); i++) {\\n            int cnt = 0;\\n            while (it != xs.end() && *it < interval[i]) {\\n                cnt++;\\n                it++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    map<string, list<int> > tweets;\\n};\\n```\\n\\nNote that the above implementation also fits the following two corner cases (unsure if test cases really have them):\\n\\n- query a tweet whose name does not exist\\n- duplicate timestamps (e.g. `recordTweet(\"tweet3\", 30)` repeated several times)",
                "solutionTags": [],
                "code": "```c++\\nclass TweetCounts\\n{\\npublic:\\n    TweetCounts()\\n    {\\n    }\\n\\n    void recordTweet(string tweetName, int time)\\n    {\\n        if (tweets.find(tweetName) == tweets.end()) {\\n            list<int> records;\\n            records.push_back(time);\\n            tweets[tweetName] = records;\\n        } else {\\n            auto it = lower_bound(tweets[tweetName].begin(), tweets[tweetName].end(), time);\\n            tweets[tweetName].insert(it, time);\\n        }\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime)\\n    {\\n\\t\\t// compute time interval: vector [t1, t2, t3, ...] stands for time intervals [t1, t2), [t2, t3), ...\\n        vector<int> interval;\\n        interval.push_back(startTime);\\n        int step = (freq[0] == \\'m\\') ? 60 : (freq[0] == \\'h\\') ? 60 * 60 : 60 * 60 * 24;\\n        while (true) {\\n            startTime += step;\\n            if (startTime < endTime + 1) {\\n                interval.push_back(startTime);\\n            } else {\\n                interval.push_back(endTime + 1);\\n                break;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        auto xs = (tweets.find(tweetName) == tweets.end()) ? list<int>() : tweets[tweetName];\\n        auto it = lower_bound(xs.begin(), xs.end(), interval.front()); // binary search for the starting iterator\\n        for (int i = 1; i < interval.size(); i++) {\\n            int cnt = 0;\\n            while (it != xs.end() && *it < interval[i]) {\\n                cnt++;\\n                it++;\\n            }\\n            ans.push_back(cnt);\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    map<string, list<int> > tweets;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503559,
                "title": "golang-o-n-logn-straight-forward-solution-with-explanation",
                "content": "I think the key to solve this problem is **try not to understand the problem, instead, just follow the instructions.**\\n\\nI use a map to store the `<tweetname, time array>. ` The `RecordTweet` is just to store the time under tweet name. \\n\\nFor the `GetTweetCountsPerFrequency` method, I first sort the time array. The purpose is that I can search and find all the count in one trial later, which takes `O(N)`.   \\n\\nThe key part is to judge the end time first according to the instruction: ` min(startTime + delta*(i+1), endTime + 1)`. Then we can iterate over the sorted array. If the end time is `startTime + delta*(i+1)`, we need to break in time once current time is larger or equal to  `startTime + delta*(i+1)`, since we need to start from current time in the next iteration. For the rest functional logic, we just need to follow the instructions. \\n\\n```\\n\\ntype TweetCounts struct {\\n\\tm map[string][]int\\n}\\ntype Ints []int\\n\\nfunc (arr Ints) Len() int {\\n\\treturn len(arr)\\n}\\nfunc (arr Ints) Less(i, j int) bool {\\n\\treturn arr[i] < arr[j]\\n}\\n\\nfunc (arr Ints) Swap(i, j int) {\\n\\tarr[i], arr[j] = arr[j], arr[i]\\n}\\n\\nfunc Constructor() TweetCounts {\\n\\treturn TweetCounts{\\n\\t\\tm: make(map[string][]int),\\n\\t}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int) {\\n\\tthis.m[tweetName] = append(this.m[tweetName], time)\\n}\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\tvar arr, res []int = this.m[tweetName], []int{}\\n\\tsort.Sort(Ints(arr))\\n\\tbeg, outbeg, delta, i := 0, 0, 0, 0\\n\\tswitch freq {\\n\\tcase \"minute\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60\\n\\t\\t}\\n\\tcase \"hour\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60 * 60\\n\\t\\t}\\n\\tcase \"day\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60 * 60 * 24\\n\\t\\t}\\n\\t}\\n\\tfor {\\n\\t\\ttmpCnt := 0\\n\\t\\tif startTime+delta*(i+1) < endTime+1 {\\n\\n\\t\\t\\tfor beg = outbeg; beg < len(arr); beg++ {\\n\\t\\t\\t\\tif arr[beg] >= startTime+delta*i &&\\n\\t\\t\\t\\t\\tarr[beg] < startTime+delta*(i+1) {\\n\\t\\t\\t\\t\\ttmpCnt++\\n                    } else if arr[beg] >=  startTime+delta*(i+1) {\\n                        break\\n                    }\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\tfor beg = outbeg; beg < len(arr); beg++ {\\n\\t\\t\\t\\tif arr[beg] >= startTime+delta*i &&\\n\\t\\t\\t\\t\\tarr[beg] < endTime+1 {\\n\\t\\t\\t\\t\\ttmpCnt++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            res = append(res, tmpCnt)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\ti++\\n\\t\\toutbeg = beg\\n\\t\\tres = append(res, tmpCnt)\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\ntype TweetCounts struct {\\n\\tm map[string][]int\\n}\\ntype Ints []int\\n\\nfunc (arr Ints) Len() int {\\n\\treturn len(arr)\\n}\\nfunc (arr Ints) Less(i, j int) bool {\\n\\treturn arr[i] < arr[j]\\n}\\n\\nfunc (arr Ints) Swap(i, j int) {\\n\\tarr[i], arr[j] = arr[j], arr[i]\\n}\\n\\nfunc Constructor() TweetCounts {\\n\\treturn TweetCounts{\\n\\t\\tm: make(map[string][]int),\\n\\t}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int) {\\n\\tthis.m[tweetName] = append(this.m[tweetName], time)\\n}\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\tvar arr, res []int = this.m[tweetName], []int{}\\n\\tsort.Sort(Ints(arr))\\n\\tbeg, outbeg, delta, i := 0, 0, 0, 0\\n\\tswitch freq {\\n\\tcase \"minute\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60\\n\\t\\t}\\n\\tcase \"hour\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60 * 60\\n\\t\\t}\\n\\tcase \"day\":\\n\\t\\t{\\n\\t\\t\\tdelta = 60 * 60 * 24\\n\\t\\t}\\n\\t}\\n\\tfor {\\n\\t\\ttmpCnt := 0\\n\\t\\tif startTime+delta*(i+1) < endTime+1 {\\n\\n\\t\\t\\tfor beg = outbeg; beg < len(arr); beg++ {\\n\\t\\t\\t\\tif arr[beg] >= startTime+delta*i &&\\n\\t\\t\\t\\t\\tarr[beg] < startTime+delta*(i+1) {\\n\\t\\t\\t\\t\\ttmpCnt++\\n                    } else if arr[beg] >=  startTime+delta*(i+1) {\\n                        break\\n                    }\\n\\t\\t\\t}\\n\\n\\t\\t} else {\\n\\t\\t\\tfor beg = outbeg; beg < len(arr); beg++ {\\n\\t\\t\\t\\tif arr[beg] >= startTime+delta*i &&\\n\\t\\t\\t\\t\\tarr[beg] < endTime+1 {\\n\\t\\t\\t\\t\\ttmpCnt++\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            res = append(res, tmpCnt)\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\ti++\\n\\t\\toutbeg = beg\\n\\t\\tres = append(res, tmpCnt)\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 503530,
                "title": "python3-solution-for-this-time-consuming-problem",
                "content": "```python\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dic[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \\'minute\\':\\n            delta = 60\\n        elif freq == \\'hour\\':\\n            delta = 60 * 60\\n        elif freq == \\'day\\':\\n            delta = 60*60*24\\n\\n        cur = self.dic[tweetName]\\n        cur.sort()\\n        size = math.ceil((endTime - startTime + 1) / delta)\\n        res = [0] * (size  )\\n        for time in cur:\\n            if startTime <= time <= endTime:\\n                res[((time - startTime) // delta)] += 1\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```python\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.dic = collections.defaultdict(list)\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dic[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \\'minute\\':\\n            delta = 60\\n        elif freq == \\'hour\\':\\n            delta = 60 * 60\\n        elif freq == \\'day\\':\\n            delta = 60*60*24\\n\\n        cur = self.dic[tweetName]\\n        cur.sort()\\n        size = math.ceil((endTime - startTime + 1) / delta)\\n        res = [0] * (size  )\\n        for time in cur:\\n            if startTime <= time <= endTime:\\n                res[((time - startTime) // delta)] += 1\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 503489,
                "title": "java-treeset-solution",
                "content": "Using a unique nonce along with the timestamp in case the same tweet is registered multiple times at the same timestamp:\\n\\n```\\nclass Node {\\n    int time;\\n    \\n    int nonce;\\n    \\n    Node(int time, int nonce) {\\n        this.time = time;\\n        this.nonce = nonce;\\n    }\\n}\\n\\nclass Comp implements Comparator<Node> {\\n    public int compare(Node n1, Node n2) {\\n        if (n1.time != n2.time) {\\n            return n1.time - n2.time;\\n        } else {\\n            return n1.nonce - n2.nonce;\\n        }\\n    }\\n}\\n\\nclass TweetCounts {\\n    \\n    private Map<String, TreeSet<Node>> m = new HashMap();\\n    \\n    private int nonce = 0;\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeSet<Node> ts;\\n        if (!m.containsKey(tweetName)) {\\n            ts = new TreeSet(new Comp());\\n            m.put(tweetName, ts);\\n        } else {\\n            ts = m.get(tweetName);\\n        }\\n        Node n = new Node(time, nonce);\\n        nonce++;\\n        ts.add(n);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int delta;\\n        if (freq.equals(\"minute\")) {\\n            delta = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            delta = 3600;\\n        } else {\\n            delta = 86400;\\n        }\\n        List<Integer> res = new ArrayList();\\n        int curr = startTime;\\n        while(curr < endTime + 1) {\\n            int et = Math.min(curr + delta - 1, endTime);\\n            if (m.containsKey(tweetName)) {\\n                TreeSet ts = m.get(tweetName);\\n                Set cands = ts.subSet(new Node(curr, 0), true, new Node(et, nonce), false);\\n                res.add(cands.size());\\n            } else {\\n                res.add(0);\\n            }\\n            curr += delta;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    int time;\\n    \\n    int nonce;\\n    \\n    Node(int time, int nonce) {\\n        this.time = time;\\n        this.nonce = nonce;\\n    }\\n}\\n\\nclass Comp implements Comparator<Node> {\\n    public int compare(Node n1, Node n2) {\\n        if (n1.time != n2.time) {\\n            return n1.time - n2.time;\\n        } else {\\n            return n1.nonce - n2.nonce;\\n        }\\n    }\\n}\\n\\nclass TweetCounts {\\n    \\n    private Map<String, TreeSet<Node>> m = new HashMap();\\n    \\n    private int nonce = 0;\\n\\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeSet<Node> ts;\\n        if (!m.containsKey(tweetName)) {\\n            ts = new TreeSet(new Comp());\\n            m.put(tweetName, ts);\\n        } else {\\n            ts = m.get(tweetName);\\n        }\\n        Node n = new Node(time, nonce);\\n        nonce++;\\n        ts.add(n);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int delta;\\n        if (freq.equals(\"minute\")) {\\n            delta = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            delta = 3600;\\n        } else {\\n            delta = 86400;\\n        }\\n        List<Integer> res = new ArrayList();\\n        int curr = startTime;\\n        while(curr < endTime + 1) {\\n            int et = Math.min(curr + delta - 1, endTime);\\n            if (m.containsKey(tweetName)) {\\n                TreeSet ts = m.get(tweetName);\\n                Set cands = ts.subSet(new Node(curr, 0), true, new Node(et, nonce), false);\\n                res.add(cands.size());\\n            } else {\\n                res.add(0);\\n            }\\n            curr += delta;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503451,
                "title": "java-solution",
                "content": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> times = map.get(tweetName);\\n        Collections.sort(times);\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> m = new HashMap<>();\\n        if (freq.equals(\"hour\")) {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / 3600;\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += 3600) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        } else if (freq.equals(\"minute\")) {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / 60;\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n                \\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += 60) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        } else {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / (3600 * 24);\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += (3600 * 24)) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> times = map.get(tweetName);\\n        Collections.sort(times);\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> m = new HashMap<>();\\n        if (freq.equals(\"hour\")) {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / 3600;\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += 3600) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        } else if (freq.equals(\"minute\")) {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / 60;\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n                \\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += 60) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        } else {\\n            for (int i = 0; i < times.size(); i++) {\\n                if (times.get(i) >= startTime && times.get(i) <= endTime) {\\n                    int index = (times.get(i) - startTime) / (3600 * 24);\\n                    m.put(index, m.getOrDefault(index, 0) + 1);\\n                }\\n            }\\n            int count = 0;\\n            for (int i = startTime; i <= endTime; i += (3600 * 24)) {\\n                res.add(m.getOrDefault(count++, 0));\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060021,
                "title": "real-world-optimized-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want a map of a tweetName to a dictionary of time frequencies\\nWe want to be able to do chunk sizes of seconds based on different larger intervals \\nWe want to be able to determine an interval based on an ending and start time per chunk size \\n\\nIf we set all of these up in the initialization process, we can then do a linear scan over the appropriate tweets and allow for easy upgrading in the future \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSet up tweets to record as a map of tweetNames to dictionary of time frequencies. This way, as a tweet comes in, we can mark for that tweetName at that tweetTime the incidence of that tweet. This allows for realworld parallel scaling, where many of the same tweets may be arriving at the same or different timings. This could in turn be optimized by having time serve as a time pointer to a universal time object, which would in turn lower this from a necessary string to float mapping to int to a necessary string to pointer mapping to int pointer. Similarly, we can optimize by taking the string and doing encoding to shorten the bits related to it in lossless compression. This would eventually lead to a significant memory and thus time optimization. \\n\\nSet up seconds as a map of second intervals that are not seconds to the chunk size. This means we have second -> 1, minute -> 60, hour -> 60 * 60, day -> 60 * 60 * 24, week -> 60 * 60 * 24 * 7. Again this could be optimized, but for little gain as it is only done on init. Combinations of these could allow for more customized features as well. \\n\\nSet up a get interval inline function that is given an ending, starting, and chunk size and then returns the interval per chunk size result (ending - starting) per chunk_size in integer division format. \\n\\nBy keeping this as an inline function, the owners control over it is increased and thus maintained well. \\n\\nWe then record tweets by having the following checking process \\n- If tweetName in self.tweets \\n    - if time in self.tweets[tweetName] \\n        - self.tweets[tweetName][time] += 1 \\n    - else self.tweets[tweetName][time] = 1 \\n- else self.tweets[tweetName][time] = 1 \\n\\nTo getTweetCountsPerFrequency then \\n- get chunksize from self.seconds with default set to a day (could be changed, but day works for the test cases used here) \\n- answer is a list of 0s of size of the get interval function using endTime, startTime and now calculated chunksize \\n- the time keys are the set of self.tweets at tweetName keys \\n- the viable keys are those keys in tweet time keys that are in interval \\n- for key in viable keys then, \\n    - get interval of key, startTime, chunksize \\n    - answer at this interval is updated by self.tweets at tweetName at key (avoids multiple loopings therein) \\n- when loop concludes, return answer \\n\\n# Time Complexity \\n- For init, O(1). \\n- For recordTweet, O(2 bools, one set or one addition) \\n- For getTweetCountsPerFrequency \\n    - get chunksize is O(1) \\n    - get interval is a subtraction, addition and division cost \\n    - get tweet_time_keys as a set is O(T) where T is the number of timekeys at the tweetName \\n    - viable keys then takes O(T) as well \\n    - answer updates then takes O(t) where t is subset of T as these are viable times \\n        - during which we need to do a subtraction, division, and access step \\n    - total then is O(1) + O(-, /, +) + O(T) + O(T) + O(t) * (-, /, @)\\n    - total then is O(2T + tc), where c == (-, /, @)\\n\\n# Space Complexity \\n- For each tweetName \\n    - We store a dictionary of times \\n        - which point to integers \\n    - In total then O(D * I), where D is the dictionary of tweetNames and I is the set of time intervals is stored \\n    - All other storage is less than this by necessity and so is subsumed     \\n\\n# Code\\n```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = collections.defaultdict(dict)\\n        self.seconds = {\\'minute\\':60, \\'hour\\':(60*60), \\'day\\':(60*60*24)}\\n        self.get_interval = lambda ending, starting, chunk_size : (ending-starting)//chunk_size\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName in self.tweets : \\n            if time in self.tweets[tweetName] : \\n                self.tweets[tweetName][time] += 1 \\n            else : \\n                self.tweets[tweetName][time] = 1 \\n        else : \\n            self.tweets[tweetName][time] = 1\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        chunk_size = self.seconds.get(freq, 86400)\\n        answer = [0] * (self.get_interval(endTime, startTime, chunk_size) + 1)\\n        tweet_time_keys = set(self.tweets[tweetName].keys())\\n        viable_keys = [key for key in tweet_time_keys if startTime <= key <= endTime]\\n        for key in viable_keys : \\n            answer[self.get_interval(key, startTime, chunk_size)] += self.tweets[tweetName][key]\\n        return answer\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = collections.defaultdict(dict)\\n        self.seconds = {\\'minute\\':60, \\'hour\\':(60*60), \\'day\\':(60*60*24)}\\n        self.get_interval = lambda ending, starting, chunk_size : (ending-starting)//chunk_size\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName in self.tweets : \\n            if time in self.tweets[tweetName] : \\n                self.tweets[tweetName][time] += 1 \\n            else : \\n                self.tweets[tweetName][time] = 1 \\n        else : \\n            self.tweets[tweetName][time] = 1\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        chunk_size = self.seconds.get(freq, 86400)\\n        answer = [0] * (self.get_interval(endTime, startTime, chunk_size) + 1)\\n        tweet_time_keys = set(self.tweets[tweetName].keys())\\n        viable_keys = [key for key in tweet_time_keys if startTime <= key <= endTime]\\n        for key in viable_keys : \\n            answer[self.get_interval(key, startTime, chunk_size)] += self.tweets[tweetName][key]\\n        return answer\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708855,
                "title": "well-commented-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Dependent on the number of tweets recorded.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Dependent on number of tweets recorded with unique name.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>tweetRecords; // Here we are storing at what times a tweetname tweeted\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweetRecords[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        //now we are given intervals\\n        int interval=0;\\n        if(freq==\"minute\"){\\n            interval=60;\\n        }\\n        else if(freq==\"hour\"){\\n            interval=3600;\\n        }\\n        else if(freq==\"day\"){\\n            interval=3600*24;\\n        }\\n\\n        //now comes the main part\\n        int totalChunks=(endTime-startTime)/interval + 1;\\n\\n        //now we want the tweets of a perticular tweetName\\n        vector<int>&tweetTimes=tweetRecords[tweetName];\\n        \\n        vector<int>tweetCounts(totalChunks);\\n\\n        for(int time:tweetTimes){\\n            //check if tweet is made within the limit we need\\n            if(time>=startTime && time<=endTime){\\n                //finding in which chunk tweet was made\\n                int chunkIndex = (time - startTime) / interval;\\n                tweetCounts[chunkIndex]++;\\n            }\\n        }\\n        return tweetCounts;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>tweetRecords; // Here we are storing at what times a tweetname tweeted\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweetRecords[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        //now we are given intervals\\n        int interval=0;\\n        if(freq==\"minute\"){\\n            interval=60;\\n        }\\n        else if(freq==\"hour\"){\\n            interval=3600;\\n        }\\n        else if(freq==\"day\"){\\n            interval=3600*24;\\n        }\\n\\n        //now comes the main part\\n        int totalChunks=(endTime-startTime)/interval + 1;\\n\\n        //now we want the tweets of a perticular tweetName\\n        vector<int>&tweetTimes=tweetRecords[tweetName];\\n        \\n        vector<int>tweetCounts(totalChunks);\\n\\n        for(int time:tweetTimes){\\n            //check if tweet is made within the limit we need\\n            if(time>=startTime && time<=endTime){\\n                //finding in which chunk tweet was made\\n                int chunkIndex = (time - startTime) / interval;\\n                tweetCounts[chunkIndex]++;\\n            }\\n        }\\n        return tweetCounts;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3647818,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar TweetCounts = function() {\\n    this.timeMap = {\\n        minute: 60,\\n        hour: 60 * 60,\\n        day: 60 * 60 * 24,\\n    };\\n    this.recordsMap = new Map();\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    const records = this.recordsMap.get(tweetName) ?? [];\\n\\n    records.push(time);\\n    this.recordsMap.set(tweetName, records);\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    const records =  this.recordsMap.get(tweetName);\\n\\n    if (!records) return [];\\n    const BASE_TIME = this.timeMap[freq];\\n    const frequency = Math.floor((endTime - startTime) / BASE_TIME) + 1;\\n    const tweetCounts = Array(frequency).fill(0);\\n\\n    for (let index = 0; index < records.length; index++) {\\n        const time = records[index];\\n        if (startTime > time || endTime < time) continue;\\n        const chunk = Math.floor((time - startTime) / BASE_TIME);\\n\\n        tweetCounts[chunk] += 1;\\n    }\\n    return tweetCounts;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar TweetCounts = function() {\\n    this.timeMap = {\\n        minute: 60,\\n        hour: 60 * 60,\\n        day: 60 * 60 * 24,\\n    };\\n    this.recordsMap = new Map();\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    const records = this.recordsMap.get(tweetName) ?? [];\\n\\n    records.push(time);\\n    this.recordsMap.set(tweetName, records);\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    const records =  this.recordsMap.get(tweetName);\\n\\n    if (!records) return [];\\n    const BASE_TIME = this.timeMap[freq];\\n    const frequency = Math.floor((endTime - startTime) / BASE_TIME) + 1;\\n    const tweetCounts = Array(frequency).fill(0);\\n\\n    for (let index = 0; index < records.length; index++) {\\n        const time = records[index];\\n        if (startTime > time || endTime < time) continue;\\n        const chunk = Math.floor((time - startTime) / BASE_TIME);\\n\\n        tweetCounts[chunk] += 1;\\n    }\\n    return tweetCounts;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638658,
                "title": "time-segmented-tweet-analysis-using-python-and-sortedlist",
                "content": "**Solution**\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.freq = defaultdict(SortedList)\\n        self.intervals = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 60*60*24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.freq[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        ans = [0] * ((endTime - startTime) // self.intervals[freq] + 1)\\n        idx = self.freq[tweetName].bisect_left(startTime)\\n        while idx < len(self.freq[tweetName]) and self.freq[tweetName][idx] <= endTime:\\n            ans[(self.freq[tweetName][idx] - startTime) // self.intervals[freq]] += 1\\n            idx += 1\\n        return ans\\n```\\n\\n### Introduction\\n\\nA ubiquitous aspect of big data analysis, particularly for social media platforms, is handling and processing time-series data. Here, we\\'ll delve into a scenario where a social media company needs to dissect the number of tweets happening in specified time slots, segmented by different frequencies (every minute, hour, or day). To assist with this analysis, we will create an Application Programming Interface (API) that includes several methods bundled into a Python class, `TweetCounts`.\\n\\n### Building the `TweetCounts` Class\\n\\nThe `TweetCounts` class encapsulates the necessary functions for recording and evaluating tweets.\\n\\n```python\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\nclass TweetCounts:\\n    def __init__(self):\\n        self.freq = defaultdict(SortedList)\\n        self.intervals = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 60*60*24}\\n```\\n\\nIn the constructor, we initialize `self.freq`, a dictionary where each key represents a tweet\\'s name and the value is a SortedList of the times at which the tweet was posted. The SortedList ensures that insertion and deletion operations maintain the sorted property, providing an efficient way of storing and querying tweet times. \\n\\nAdditionally, we define `self.intervals` as a dictionary mapping each frequency to its corresponding duration in seconds.\\n\\n### `recordTweet` Method\\n\\nThe `recordTweet` function logs a tweet at a given time.\\n\\n```python\\ndef recordTweet(self, tweetName: str, time: int) -> None:\\n    self.freq[tweetName].add(time)\\n```\\n\\nHere, we add the provided `time` to the SortedList corresponding to `tweetName` in `self.freq`. The `add()` operation in SortedList ensures the list remains sorted after the addition.\\n\\n### `getTweetCountsPerFrequency` Method\\n\\nThe `getTweetCountsPerFrequency` function returns the number of tweets within each time segment for a specified period, frequency, and tweet name.\\n\\n```python\\ndef getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n    ans = [0] * ((endTime - startTime) // self.intervals[freq] + 1)\\n    idx = self.freq[tweetName].bisect_left(startTime)\\n    while idx < len(self.freq[tweetName]) and self.freq[tweetName][idx] <= endTime:\\n        ans[(self.freq[tweetName][idx] - startTime) // self.intervals[freq]] += 1\\n        idx += 1\\n    return ans\\n```\\n\\nThis function starts by initializing an array `ans` with a size sufficient to hold counts for all time chunks within the provided time range. We then find the index of the first tweet that was posted after `startTime` using the `bisect_left()` function of SortedList, which returns the insertion point for `startTime` in the sorted list.\\n\\nWe then iterate over each tweet for the given `tweetName` within the specified time range, incrementing the corresponding count in `ans` for each tweet. The index of each count is calculated based on the time elapsed since the `startTime` divided by the interval duration.\\n\\n### Time Complexity Analysis\\n\\nThe `recordTweet` function exhibits a time complexity of O(log N) due to the `add` operation on the SortedList, where N represents the current size of the SortedList.\\n\\nThe `getTweetCountsPerFrequency` function\\'s time complexity is O(M), where M is the number of tweets for the specified name that fall within the specified time range. The `bisect_left()` function and the array index operations are performed in constant time, and we are performing these operations once for each relevant tweet.\\n\\n### Conclusion\\n\\nThe provided design offers an elegant solution to time-segmented tweet analysis. With the help of SortedList, we are able to maintain the chronological order of tweets and efficiently query the tweets that fall within specified time ranges. Furthermore, this solution allows flexibility in defining the frequency intervals, making it adaptable to changing requirements.\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.freq = defaultdict(SortedList)\\n        self.intervals = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 60*60*24}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.freq[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        ans = [0] * ((endTime - startTime) // self.intervals[freq] + 1)\\n        idx = self.freq[tweetName].bisect_left(startTime)\\n        while idx < len(self.freq[tweetName]) and self.freq[tweetName][idx] <= endTime:\\n            ans[(self.freq[tweetName][idx] - startTime) // self.intervals[freq]] += 1\\n            idx += 1\\n        return ans\\n```\n```python\\nfrom sortedcontainers import SortedList\\nfrom collections import defaultdict\\n\\nclass TweetCounts:\\n    def __init__(self):\\n        self.freq = defaultdict(SortedList)\\n        self.intervals = {\\'minute\\': 60, \\'hour\\': 60*60, \\'day\\': 60*60*24}\\n```\n```python\\ndef recordTweet(self, tweetName: str, time: int) -> None:\\n    self.freq[tweetName].add(time)\\n```\n```python\\ndef getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n    ans = [0] * ((endTime - startTime) // self.intervals[freq] + 1)\\n    idx = self.freq[tweetName].bisect_left(startTime)\\n    while idx < len(self.freq[tweetName]) and self.freq[tweetName][idx] <= endTime:\\n        ans[(self.freq[tweetName][idx] - startTime) // self.intervals[freq]] += 1\\n        idx += 1\\n    return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592117,
                "title": "python-binary-search",
                "content": "```\\nclass TweetCounts:\\n    def __init__(self):self.es=defaultdict(list)\\n    def recordTweet(self, tn: str, t: int) -> None:self.es[tn].append(t)\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, et: int) -> List[int]:\\n        ts=self.es[tweetName]\\n        ts.sort()\\n        if freq==\"minute\":\\n            re=[]\\n            for l in range(startTime,et+1,60):re.append(abs(br(ts, min(l+59,et))-bl(ts, l)))\\n            return re\\n        elif freq==\"hour\":\\n            re=[]\\n            for l in range(startTime,et+1,3600):re.append(abs(br(ts, min(l+3599,et))-bl(ts, l)))\\n            return re\\n        re=[]\\n        for l in range(startTime,et+1,86400):re.append(abs(br(ts, min(l+86399,et))-bl(ts, l)))\\n        return re\\n\\ndef bl(arr, v):\\n    l=0\\n    r=len(arr)\\n    while l<r:\\n        m=(l+r)//2\\n        if arr[m]>v:r=m\\n        if arr[m]<v:l=m+1\\n        if arr[m]==v:r=m\\n    return max(min(l,r),0)\\ndef br(arr, v):\\n    l=0\\n    r=len(arr)\\n    while l<r:\\n        m=(l+r)//2\\n        if arr[m]>v:r=m\\n        if arr[m]<v:l=m+1\\n        if arr[m]==v:l=m+1\\n    return min(max(l,r),len(arr))\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n    def __init__(self):self.es=defaultdict(list)\\n    def recordTweet(self, tn: str, t: int) -> None:self.es[tn].append(t)\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, et: int) -> List[int]:\\n        ts=self.es[tweetName]\\n        ts.sort()\\n        if freq==\"minute\":\\n            re=[]\\n            for l in range(startTime,et+1,60):re.append(abs(br(ts, min(l+59,et))-bl(ts, l)))\\n            return re\\n        elif freq==\"hour\":\\n            re=[]\\n            for l in range(startTime,et+1,3600):re.append(abs(br(ts, min(l+3599,et))-bl(ts, l)))\\n            return re\\n        re=[]\\n        for l in range(startTime,et+1,86400):re.append(abs(br(ts, min(l+86399,et))-bl(ts, l)))\\n        return re\\n\\ndef bl(arr, v):\\n    l=0\\n    r=len(arr)\\n    while l<r:\\n        m=(l+r)//2\\n        if arr[m]>v:r=m\\n        if arr[m]<v:l=m+1\\n        if arr[m]==v:r=m\\n    return max(min(l,r),0)\\ndef br(arr, v):\\n    l=0\\n    r=len(arr)\\n    while l<r:\\n        m=(l+r)//2\\n        if arr[m]>v:r=m\\n        if arr[m]<v:l=m+1\\n        if arr[m]==v:l=m+1\\n    return min(max(l,r),len(arr))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458769,
                "title": "python-3-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        # Frequency to time\\n        self.freq = {\\n            \\'minute\\': 59,\\n            \\'hour\\': 3599,\\n            \\'day\\': 86399\\n        }\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        # Using binary search to insert new occurrence for each tweet\\n        m = bisect.bisect(self.tweets[tweetName], time)\\n        self.tweets[tweetName].insert(m, time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        # Store the result\\n        result = []\\n        interval = self.freq[freq]\\n        cur_time = startTime\\n\\n        # For each interval, find the number of occurrences for the tweet\\n        while cur_time <= endTime:\\n            end_cur_interval = min(cur_time + interval, endTime)\\n\\n\\n            i = bisect.bisect_left(self.tweets[tweetName], cur_time)\\n            j = bisect.bisect(self.tweets[tweetName], end_cur_interval)\\n            \\n            result.append(j-i)\\n            cur_time = end_cur_interval + 1\\n        return result\\n\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = defaultdict(list)\\n        # Frequency to time\\n        self.freq = {\\n            \\'minute\\': 59,\\n            \\'hour\\': 3599,\\n            \\'day\\': 86399\\n        }\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        # Using binary search to insert new occurrence for each tweet\\n        m = bisect.bisect(self.tweets[tweetName], time)\\n        self.tweets[tweetName].insert(m, time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        # Store the result\\n        result = []\\n        interval = self.freq[freq]\\n        cur_time = startTime\\n\\n        # For each interval, find the number of occurrences for the tweet\\n        while cur_time <= endTime:\\n            end_cur_interval = min(cur_time + interval, endTime)\\n\\n\\n            i = bisect.bisect_left(self.tweets[tweetName], cur_time)\\n            j = bisect.bisect(self.tweets[tweetName], end_cur_interval)\\n            \\n            result.append(j-i)\\n            cur_time = end_cur_interval + 1\\n        return result\\n\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427691,
                "title": "go-my-solution-hashmap-binary-insert",
                "content": "# Code\\n```\\ntype TweetCounts struct {\\n\\ttimes map[string][]int\\n\\tfreq  map[string]int\\n}\\n\\nfunc (tw *TweetCounts) init() {\\n\\ttw.times = make(map[string][]int)\\n\\ttw.freq = map[string]int{\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n}\\n\\nfunc (tw *TweetCounts) bns(time int, store []int) int {\\n\\tlow, high := 0, len(store)-1\\n\\tfor low <= high {\\n\\t\\tmedian := (low + high) / 2\\n\\t\\tif store[median] < time {\\n\\t\\t\\tlow = median + 1\\n\\t\\t} else {\\n\\t\\t\\thigh = median - 1\\n\\t\\t}\\n\\t}\\n\\treturn low\\n}\\n\\nfunc Constructor() TweetCounts {\\n\\ttweetCounts := TweetCounts{}\\n\\ttweetCounts.init()\\n\\treturn tweetCounts\\n}\\n\\nfunc (tw *TweetCounts) RecordTweet(tweetName string, time int) {\\n\\tif tw.times[tweetName] == nil {\\n\\t\\ttw.times[tweetName] = []int{}\\n\\t}\\n\\n\\tmid := tw.bns(time, tw.times[tweetName])\\n\\ttw.times[tweetName] = insert(tw.times[tweetName], mid, time)\\n}\\n\\nfunc (tw *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\ttimes := tw.times[tweetName]\\n\\ttimeChunk := tw.freq[freq]\\n\\tcounts := make([]int, int(math.Ceil(float64(endTime-startTime+1)/float64(timeChunk))))\\n\\tfor i := 0; i < len(times); i++ {\\n\\t\\tif times[i] < startTime {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif times[i] > endTime {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tcounts[(times[i]-startTime+1)/timeChunk]++\\n\\t}\\n\\treturn counts\\n}\\n\\nfunc insert(a []int, index int, value int) []int {\\n\\tif index >= len(a) {\\n\\t\\ta = append(a, value)\\n\\t} else {\\n\\t\\ta = append(a[:index+1], a[index:]...)\\n\\t\\ta[index] = value\\n\\t}\\n\\treturn a\\n}\\n\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TweetCounts struct {\\n\\ttimes map[string][]int\\n\\tfreq  map[string]int\\n}\\n\\nfunc (tw *TweetCounts) init() {\\n\\ttw.times = make(map[string][]int)\\n\\ttw.freq = map[string]int{\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n}\\n\\nfunc (tw *TweetCounts) bns(time int, store []int) int {\\n\\tlow, high := 0, len(store)-1\\n\\tfor low <= high {\\n\\t\\tmedian := (low + high) / 2\\n\\t\\tif store[median] < time {\\n\\t\\t\\tlow = median + 1\\n\\t\\t} else {\\n\\t\\t\\thigh = median - 1\\n\\t\\t}\\n\\t}\\n\\treturn low\\n}\\n\\nfunc Constructor() TweetCounts {\\n\\ttweetCounts := TweetCounts{}\\n\\ttweetCounts.init()\\n\\treturn tweetCounts\\n}\\n\\nfunc (tw *TweetCounts) RecordTweet(tweetName string, time int) {\\n\\tif tw.times[tweetName] == nil {\\n\\t\\ttw.times[tweetName] = []int{}\\n\\t}\\n\\n\\tmid := tw.bns(time, tw.times[tweetName])\\n\\ttw.times[tweetName] = insert(tw.times[tweetName], mid, time)\\n}\\n\\nfunc (tw *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\ttimes := tw.times[tweetName]\\n\\ttimeChunk := tw.freq[freq]\\n\\tcounts := make([]int, int(math.Ceil(float64(endTime-startTime+1)/float64(timeChunk))))\\n\\tfor i := 0; i < len(times); i++ {\\n\\t\\tif times[i] < startTime {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tif times[i] > endTime {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\tcounts[(times[i]-startTime+1)/timeChunk]++\\n\\t}\\n\\treturn counts\\n}\\n\\nfunc insert(a []int, index int, value int) []int {\\n\\tif index >= len(a) {\\n\\t\\ta = append(a, value)\\n\\t} else {\\n\\t\\ta = append(a[:index+1], a[index:]...)\\n\\t\\ta[index] = value\\n\\t}\\n\\treturn a\\n}\\n\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3372386,
                "title": "c-sorted-set",
                "content": "```\\npublic class TweetCounts {\\n    Comparer<(int k,int f)> cmp= Comparer<(int k,int f)>.Create((x,y)=>x.k.CompareTo(y.k));\\n    \\n    Dictionary<string,SortedSet<(int k,int f)>> dict=new Dictionary<string,SortedSet<(int k,int f)>>();\\n    \\n    \\n    public TweetCounts() {\\n            \\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        if(!dict.ContainsKey(tweetName))\\n            dict.Add(tweetName,new SortedSet<(int k,int f)>(cmp));\\n        \\n        SortedSet<(int k,int f)> ss=dict[tweetName]; \\n        \\n        (int k,int f) v;\\n                (int k,int f) v2=(time,1);\\n\\n        if(ss.TryGetValue((time,0) , out v))\\n        {\\n            ss.Remove(v);\\n            v2=(time,v.f+1);\\n        }\\n        \\n        dict[tweetName].Add(v2);\\n        \\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(!dict.ContainsKey(tweetName))\\n            return null;\\n        SortedSet<(int k,int f)> ss=dict[tweetName];\\n        int f=0;\\n        if(freq==\"minute\")\\n            f=60;\\n        else if(freq==\"hour\")\\n            f=3600;\\n        else if(freq==\"day\")\\n            f=86400;\\n        \\n        List<int> res=new List<int>();\\n        while(startTime<=endTime){\\n\\n            int e=Math.Min(endTime,startTime+f-1);\\n            var sv=ss.GetViewBetween((startTime,0),(e,0));\\n            int cnt=0;\\n            foreach((int k,int f) item11 in sv)\\n                cnt+=item11.f;\\n            res.Add(cnt);\\n            startTime+=f;\\n        }\\n        \\n        return res;\\n        \\n               \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.RecordTweet(tweetName,time);\\n * IList<int> param_2 = obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class TweetCounts {\\n    Comparer<(int k,int f)> cmp= Comparer<(int k,int f)>.Create((x,y)=>x.k.CompareTo(y.k));\\n    \\n    Dictionary<string,SortedSet<(int k,int f)>> dict=new Dictionary<string,SortedSet<(int k,int f)>>();\\n    \\n    \\n    public TweetCounts() {\\n            \\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        if(!dict.ContainsKey(tweetName))\\n            dict.Add(tweetName,new SortedSet<(int k,int f)>(cmp));\\n        \\n        SortedSet<(int k,int f)> ss=dict[tweetName]; \\n        \\n        (int k,int f) v;\\n                (int k,int f) v2=(time,1);\\n\\n        if(ss.TryGetValue((time,0) , out v))\\n        {\\n            ss.Remove(v);\\n            v2=(time,v.f+1);\\n        }\\n        \\n        dict[tweetName].Add(v2);\\n        \\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(!dict.ContainsKey(tweetName))\\n            return null;\\n        SortedSet<(int k,int f)> ss=dict[tweetName];\\n        int f=0;\\n        if(freq==\"minute\")\\n            f=60;\\n        else if(freq==\"hour\")\\n            f=3600;\\n        else if(freq==\"day\")\\n            f=86400;\\n        \\n        List<int> res=new List<int>();\\n        while(startTime<=endTime){\\n\\n            int e=Math.Min(endTime,startTime+f-1);\\n            var sv=ss.GetViewBetween((startTime,0),(e,0));\\n            int cnt=0;\\n            foreach((int k,int f) item11 in sv)\\n                cnt+=item11.f;\\n            res.Add(cnt);\\n            startTime+=f;\\n        }\\n        \\n        return res;\\n        \\n               \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.RecordTweet(tweetName,time);\\n * IList<int> param_2 = obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367982,
                "title": "c",
                "content": "```\\nclass TweetCounts {\\nprivate:\\n    unordered_map<string, map<int, int>>NameToTimeCount ;  //{ID, time to count}\\n    unordered_map<string, int>freqMap{{\"minute\", 60},{\"hour\", 60*60},{\"day\",24*60*60}};    \\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        NameToTimeCount[tweetName][time]++ ;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(startTime > endTime)\\n            return {} ;\\n        int interval = freqMap[freq] ;\\n        int n = (endTime - startTime)/interval + 1 ;\\n        vector<int>ret(n) ;\\n        auto left = NameToTimeCount[tweetName].lower_bound(startTime) ;\\n        auto right = NameToTimeCount[tweetName].upper_bound(endTime) ;\\n        while(left != right){\\n            ret[(left->first - startTime)/interval] += left->second ;\\n            left++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\nprivate:\\n    unordered_map<string, map<int, int>>NameToTimeCount ;  //{ID, time to count}\\n    unordered_map<string, int>freqMap{{\"minute\", 60},{\"hour\", 60*60},{\"day\",24*60*60}};    \\npublic:\\n    TweetCounts() {\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        NameToTimeCount[tweetName][time]++ ;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(startTime > endTime)\\n            return {} ;\\n        int interval = freqMap[freq] ;\\n        int n = (endTime - startTime)/interval + 1 ;\\n        vector<int>ret(n) ;\\n        auto left = NameToTimeCount[tweetName].lower_bound(startTime) ;\\n        auto right = NameToTimeCount[tweetName].upper_bound(endTime) ;\\n        while(left != right){\\n            ret[(left->first - startTime)/interval] += left->second ;\\n            left++ ;\\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3361695,
                "title": "map-with-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe description is a little bit confusing about the end timing.\\nstart taking multiset as one user may tweets more than one tweets at an instant and take a map of strings.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\nunordered_map<string,multiset<int>>m;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string s, int t) {\\n        m[s].insert(t);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string s, int st, int et) {\\n        int c=60;\\n        if(freq==\"hour\"){c=3600;}\\n        else if(freq==\"day\"){c=86400;}\\n        int t=st;\\n        vector<int>ans;\\n        while(t<=et)\\n        {\\n            int h=min({t+c-1,et});\\n            int dis=distance(m[s].lower_bound(t),m[s].lower_bound(h));\\n            \\n            if(t==h)\\n            {\\n                \\n                if(m[s].find(t)!=m[s].end()){dis=1;}\\n            }\\n            ans.push_back(dis);\\n            t+=c;\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\nunordered_map<string,multiset<int>>m;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string s, int t) {\\n        m[s].insert(t);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string s, int st, int et) {\\n        int c=60;\\n        if(freq==\"hour\"){c=3600;}\\n        else if(freq==\"day\"){c=86400;}\\n        int t=st;\\n        vector<int>ans;\\n        while(t<=et)\\n        {\\n            int h=min({t+c-1,et});\\n            int dis=distance(m[s].lower_bound(t),m[s].lower_bound(h));\\n            \\n            if(t==h)\\n            {\\n                \\n                if(m[s].find(t)!=m[s].end()){dis=1;}\\n            }\\n            ans.push_back(dis);\\n            t+=c;\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224485,
                "title": "binary-search-python3-solution",
                "content": "```\\n\\nclass TweetCounts:\\n    \\n    # O(1) time,\\n    # O(1) space,\\n    # Approach: hashtable, \\n    def __init__(self):\\n        self.records = defaultdict(list)\\n        self.time_mapping = {\"minute\": 59, \"hour\": 3599, \"day\": 86399}\\n\\n    \\n    # O(1) time,\\n    # O(1) space,\\n    # Approach: hashtable, \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.records[tweetName].append(time)\\n        \\n    def binarySearch(self, target, intervals):\\n        lo, hi = 0, len(intervals)-1\\n        \\n        if target < intervals[lo][0] or target > intervals[hi][1]:\\n            return hi+1\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            \\n            if target >= intervals[mid][0] and target <= intervals[mid][1]:\\n                return mid\\n            elif target > intervals[mid][1]:\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n        \\n    \\n    # O(len(records[tweetName]) * log(len(intervals))) time,\\n    # O(len(intervals)) space,\\n    # Approach: binary search, \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        ans = []\\n        intervals = []\\n        curr_interval = self.time_mapping[freq]\\n        curr_start = startTime\\n        curr_end = min(startTime+curr_interval, endTime)\\n        \\n        while curr_start <= endTime:\\n            ans.append(0)\\n            intervals.append((curr_start, curr_end))\\n            curr_start = curr_end + 1\\n            curr_end = min(curr_start+curr_interval, endTime)\\n            \\n        for record_time in self.records[tweetName]:\\n            interval_index = self.binarySearch(record_time, intervals)\\n            if interval_index < len(intervals):\\n                ans[interval_index] += 1\\n        \\n        return ans\\n        \\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass TweetCounts:\\n    \\n    # O(1) time,\\n    # O(1) space,\\n    # Approach: hashtable, \\n    def __init__(self):\\n        self.records = defaultdict(list)\\n        self.time_mapping = {\"minute\": 59, \"hour\": 3599, \"day\": 86399}\\n\\n    \\n    # O(1) time,\\n    # O(1) space,\\n    # Approach: hashtable, \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.records[tweetName].append(time)\\n        \\n    def binarySearch(self, target, intervals):\\n        lo, hi = 0, len(intervals)-1\\n        \\n        if target < intervals[lo][0] or target > intervals[hi][1]:\\n            return hi+1\\n        \\n        while lo <= hi:\\n            mid = (lo+hi)//2\\n            \\n            if target >= intervals[mid][0] and target <= intervals[mid][1]:\\n                return mid\\n            elif target > intervals[mid][1]:\\n                lo = mid+1\\n            else:\\n                hi = mid-1\\n        \\n    \\n    # O(len(records[tweetName]) * log(len(intervals))) time,\\n    # O(len(intervals)) space,\\n    # Approach: binary search, \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        ans = []\\n        intervals = []\\n        curr_interval = self.time_mapping[freq]\\n        curr_start = startTime\\n        curr_end = min(startTime+curr_interval, endTime)\\n        \\n        while curr_start <= endTime:\\n            ans.append(0)\\n            intervals.append((curr_start, curr_end))\\n            curr_start = curr_end + 1\\n            curr_end = min(curr_start+curr_interval, endTime)\\n            \\n        for record_time in self.records[tweetName]:\\n            interval_index = self.binarySearch(record_time, intervals)\\n            if interval_index < len(intervals):\\n                ans[interval_index] += 1\\n        \\n        return ans\\n        \\n        \\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166718,
                "title": "easy-cpp-solution-using-hashmap-o-n-time-complexity",
                "content": "# Approach\\nUsing hashmap to store the Tweets and time of their Occurence in seconds.\\nAs per the question now we have to count the frequency in intervals [\\'minute\\',\\'hour\\',\\'day\\']\\n\\nHere as we know , 1 min = 60 secs , 1 hour = 60x60 = 3600 secs and 1 day = 3600x24 = 86400 secs, storing this intervals in map for ease of access.\\n\\nSuppose you are given Start time and End time, now depends on the type of interval we can count no. of intervals\\nex : start time = 5 end time 80 , type \"mintue\"\\nso total time = 80-5= 75\\n\\n**Total time = endtime-startime,**\\n**No of intervals = (total time)/(interval period) + 1**\\n\\n**creating vector with given size of interval.\\nTo find Frequency count : iterate over the time vector of given tweet using map, if given time is in range , increase its interval value.**\\n\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    //to map freq to seconds for interval;\\n    unordered_map<string, int>f = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400}};\\n    TweetCounts() {\\n    }\\n\\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n\\n        // vectoc ans to store the frequency count in each interval\\n        // No of Interval = (endTime - startime)/freq + 1;\\n\\n        vector<int>ans( (endTime - startTime) / f[freq] + 1,0);\\n        for (auto time : mp[tweetName]) {\\n            if (time >= startTime && time <= endTime) {\\n                int index = (time - startTime) / f[freq]; // finding this time belongs to which interval;\\n                ans[index]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    //to map freq to seconds for interval;\\n    unordered_map<string, int>f = {{\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400}};\\n    TweetCounts() {\\n    }\\n\\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n\\n        // vectoc ans to store the frequency count in each interval\\n        // No of Interval = (endTime - startime)/freq + 1;\\n\\n        vector<int>ans( (endTime - startTime) / f[freq] + 1,0);\\n        for (auto time : mp[tweetName]) {\\n            if (time >= startTime && time <= endTime) {\\n                int index = (time - startTime) / f[freq]; // finding this time belongs to which interval;\\n                ans[index]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164649,
                "title": "java-simple-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass TweetCounts {\\n\\n    private Map<String, List<Integer>> tweets;\\n\\n    public TweetCounts() {\\n        tweets = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> tweetTimeList = tweets.getOrDefault(tweetName, new ArrayList<>());\\n        tweetTimeList.add(time);\\n\\n        tweets.put(tweetName, tweetTimeList);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> tweetCountPerChunk = new ArrayList<>();\\n        int chunk = Freq.valueOf(freq).chunk;\\n\\n        while((endTime-startTime)>=chunk) {\\n            tweetCountPerChunk.add(getTweetCount(tweetName, startTime, startTime+chunk));\\n            startTime+=chunk+1;\\n        }\\n\\n        if(startTime <= endTime) {\\n            tweetCountPerChunk.add(getTweetCount(tweetName, startTime, endTime));\\n        }\\n        \\n        return tweetCountPerChunk;\\n    }\\n\\n    public int getTweetCount(String tweetName, int startTime, int endTime) {\\n        int tweetCount=0;\\n        for (Iterator<Integer> it = tweets.get(tweetName).iterator(); it.hasNext(); ) {\\n            Integer time = it.next();\\n\\n            if(time <= endTime && time >= startTime) {\\n                tweetCount++;\\n            }\\n        }\\n        return tweetCount;\\n    }\\n}\\n\\nenum Freq {\\n    minute(59),\\n    hour(3599),\\n    day(86399);\\n\\n    public final int chunk;\\n\\n    Freq(int chunk) {\\n        this.chunk=chunk;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n\\n    private Map<String, List<Integer>> tweets;\\n\\n    public TweetCounts() {\\n        tweets = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> tweetTimeList = tweets.getOrDefault(tweetName, new ArrayList<>());\\n        tweetTimeList.add(time);\\n\\n        tweets.put(tweetName, tweetTimeList);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> tweetCountPerChunk = new ArrayList<>();\\n        int chunk = Freq.valueOf(freq).chunk;\\n\\n        while((endTime-startTime)>=chunk) {\\n            tweetCountPerChunk.add(getTweetCount(tweetName, startTime, startTime+chunk));\\n            startTime+=chunk+1;\\n        }\\n\\n        if(startTime <= endTime) {\\n            tweetCountPerChunk.add(getTweetCount(tweetName, startTime, endTime));\\n        }\\n        \\n        return tweetCountPerChunk;\\n    }\\n\\n    public int getTweetCount(String tweetName, int startTime, int endTime) {\\n        int tweetCount=0;\\n        for (Iterator<Integer> it = tweets.get(tweetName).iterator(); it.hasNext(); ) {\\n            Integer time = it.next();\\n\\n            if(time <= endTime && time >= startTime) {\\n                tweetCount++;\\n            }\\n        }\\n        return tweetCount;\\n    }\\n}\\n\\nenum Freq {\\n    minute(59),\\n    hour(3599),\\n    day(86399);\\n\\n    public final int chunk;\\n\\n    Freq(int chunk) {\\n        this.chunk=chunk;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137696,
                "title": "binary-search-approach",
                "content": "\\n\\n# Code\\n```\\nclass TweetCounts {\\n    Map<String, List<Integer>> tweetTimeMap;\\n\\n    public TweetCounts() {\\n        this.tweetTimeMap = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n\\n        if (!tweetTimeMap.containsKey(tweetName)) {\\n            tweetTimeMap.put(tweetName, new ArrayList<>());\\n        }\\n        tweetTimeMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        if (!tweetTimeMap.containsKey(tweetName)) {\\n            return ans;\\n        }\\n        int timeInSeconds = 0;\\n\\n        if (freq.equals(\"minute\")) {\\n            timeInSeconds = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            timeInSeconds = 60 * 60;\\n        } else {\\n            timeInSeconds = 60 * 60 * 24;\\n        }\\n        List<Integer> times = tweetTimeMap.get(tweetName);\\n        Collections.sort(times);\\n        int start = startTime;\\n\\n        while (start <= endTime) {\\n            int end = Math.min(start + timeInSeconds - 1, endTime);\\n            int indexJustGreaterThanEqualTo = bsJustGreaterThanEqualTo(times, start);\\n            int indexJustLessThanEqualTo = bsJustLessThanEqualTo(times, end);\\n\\n            if (indexJustGreaterThanEqualTo != -1 && indexJustLessThanEqualTo != -1) {\\n                ans.add(indexJustLessThanEqualTo - indexJustGreaterThanEqualTo + 1);\\n            } else {\\n                ans.add(0);\\n            }\\n            start = end + 1;\\n        }\\n        return ans;\\n    }\\n\\n    private int bsJustLessThanEqualTo(List<Integer> times, int target) {\\n        int ans = -1;\\n        int lo = 0;\\n        int hi = times.size() - 1;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if (times.get(pivot) <= target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int bsJustGreaterThanEqualTo(List<Integer> times, int target) {\\n        int ans = -1;\\n        int lo = 0;\\n        int hi = times.size() - 1;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if (times.get(pivot) < target) {\\n                lo = pivot + 1;\\n            } else {\\n                ans = pivot;\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Binary Search"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> tweetTimeMap;\\n\\n    public TweetCounts() {\\n        this.tweetTimeMap = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n\\n        if (!tweetTimeMap.containsKey(tweetName)) {\\n            tweetTimeMap.put(tweetName, new ArrayList<>());\\n        }\\n        tweetTimeMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> ans = new ArrayList<>();\\n\\n        if (!tweetTimeMap.containsKey(tweetName)) {\\n            return ans;\\n        }\\n        int timeInSeconds = 0;\\n\\n        if (freq.equals(\"minute\")) {\\n            timeInSeconds = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            timeInSeconds = 60 * 60;\\n        } else {\\n            timeInSeconds = 60 * 60 * 24;\\n        }\\n        List<Integer> times = tweetTimeMap.get(tweetName);\\n        Collections.sort(times);\\n        int start = startTime;\\n\\n        while (start <= endTime) {\\n            int end = Math.min(start + timeInSeconds - 1, endTime);\\n            int indexJustGreaterThanEqualTo = bsJustGreaterThanEqualTo(times, start);\\n            int indexJustLessThanEqualTo = bsJustLessThanEqualTo(times, end);\\n\\n            if (indexJustGreaterThanEqualTo != -1 && indexJustLessThanEqualTo != -1) {\\n                ans.add(indexJustLessThanEqualTo - indexJustGreaterThanEqualTo + 1);\\n            } else {\\n                ans.add(0);\\n            }\\n            start = end + 1;\\n        }\\n        return ans;\\n    }\\n\\n    private int bsJustLessThanEqualTo(List<Integer> times, int target) {\\n        int ans = -1;\\n        int lo = 0;\\n        int hi = times.size() - 1;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if (times.get(pivot) <= target) {\\n                ans = pivot;\\n                lo = pivot + 1;\\n            } else {\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private int bsJustGreaterThanEqualTo(List<Integer> times, int target) {\\n        int ans = -1;\\n        int lo = 0;\\n        int hi = times.size() - 1;\\n\\n        while (lo <= hi) {\\n            int pivot = lo + (hi - lo) / 2;\\n\\n            if (times.get(pivot) < target) {\\n                lo = pivot + 1;\\n            } else {\\n                ans = pivot;\\n                hi = pivot - 1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128504,
                "title": "java-short-easy-treemap-solution",
                "content": "\\n\\n# Code\\n```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map = null;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName , new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(!map.containsKey(tweetName))return ans;\\n        int gap = 60;\\n        switch (freq) {\\n            case \"hour\":\\n                gap = 3600;\\n                break;\\n            case \"day\":\\n                gap = 3600 * 24;\\n                break;\\n        }\\n        for(int t = startTime; t <= endTime; t += gap){\\n            int count = 0;\\n            int end = Math.min(t + gap , endTime + 1);\\n            for(int subCount : map.get(tweetName).subMap(t, true, end, false).values()) \\n                count += subCount;\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map = null;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName , new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> ans = new ArrayList<>();\\n        if(!map.containsKey(tweetName))return ans;\\n        int gap = 60;\\n        switch (freq) {\\n            case \"hour\":\\n                gap = 3600;\\n                break;\\n            case \"day\":\\n                gap = 3600 * 24;\\n                break;\\n        }\\n        for(int t = startTime; t <= endTime; t += gap){\\n            int count = 0;\\n            int end = Math.min(t + gap , endTime + 1);\\n            for(int subCount : map.get(tweetName).subMap(t, true, end, false).values()) \\n                count += subCount;\\n            ans.add(count);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115170,
                "title": "c-2-approach-multiset-vector-o-n-amazon-asked",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore times on a map with tweet name as key as times as value (vector/multiset).\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Approach 1 :\\n<!-- Describe your approach to solving the problem. -->\\nUsing multiset to stome time of a tweet\\n\\n# Code\\n```\\nclass TweetCounts {\\n    map<string, multiset<int>> mpp;\\n    map<string, int> inS = { {\"minute\", 60 - 1}, {\"hour\", 3600 - 1}, {\"day\", 86400 - 1} };;\\npublic:\\n    TweetCounts() {}\\n\\n    void recordTweet(string tweetName, int time) {\\n        mpp[tweetName].insert(time);\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string freq, string tName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int s = startTime, e = min(s + inS[freq], endTime);\\n        auto it = mpp[tName].lower_bound(s);\\n        while (s <= endTime) {\\n            int cnt = 0;\\n            // cout<<s<<\" \"<<e<<\" \";\\n            while (it != mpp[tName].end() && *it <= e) it++, cnt++;\\n            ans.push_back(cnt);\\n            s = e + 1;\\n            e = min(s + inS[freq], endTime);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n---\\n\\n\\n# Approach 2 :\\nUsing vector to stome time of a tweet\\n\\n# Code\\n```\\nclass TweetCounts {\\n    map<string, vector<int>> mpp;\\n    map<string, int> inS = { {\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400} };;\\npublic:\\n    TweetCounts() {}\\n\\n    void recordTweet(string tweetName, int time) {\\n        mpp[tweetName].push_back(time);\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string fr, string tN, int sT, int eT) {\\n        vector<int> ans;\\n        for (int i = 0; i <= (eT - sT) / inS[fr]; i++) ans.push_back(0);\\n\\n        for (auto t : mpp[tN]) {\\n            if (t >= sT && t <= eT) {\\n                int ind = (t - sT) / inS[fr];\\n                ans[ind]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Design",
                    "Sorting"
                ],
                "code": "```\\nclass TweetCounts {\\n    map<string, multiset<int>> mpp;\\n    map<string, int> inS = { {\"minute\", 60 - 1}, {\"hour\", 3600 - 1}, {\"day\", 86400 - 1} };;\\npublic:\\n    TweetCounts() {}\\n\\n    void recordTweet(string tweetName, int time) {\\n        mpp[tweetName].insert(time);\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string freq, string tName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int s = startTime, e = min(s + inS[freq], endTime);\\n        auto it = mpp[tName].lower_bound(s);\\n        while (s <= endTime) {\\n            int cnt = 0;\\n            // cout<<s<<\" \"<<e<<\" \";\\n            while (it != mpp[tName].end() && *it <= e) it++, cnt++;\\n            ans.push_back(cnt);\\n            s = e + 1;\\n            e = min(s + inS[freq], endTime);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass TweetCounts {\\n    map<string, vector<int>> mpp;\\n    map<string, int> inS = { {\"minute\", 60}, {\"hour\", 3600}, {\"day\", 86400} };;\\npublic:\\n    TweetCounts() {}\\n\\n    void recordTweet(string tweetName, int time) {\\n        mpp[tweetName].push_back(time);\\n    }\\n\\n    vector<int> getTweetCountsPerFrequency(string fr, string tN, int sT, int eT) {\\n        vector<int> ans;\\n        for (int i = 0; i <= (eT - sT) / inS[fr]; i++) ans.push_back(0);\\n\\n        for (auto t : mpp[tN]) {\\n            if (t >= sT && t <= eT) {\\n                int ind = (t - sT) / inS[fr];\\n                ans[ind]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3108387,
                "title": "easy-simple-c-short-code-tc-0-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1.We will use a map containing string and vector of int to store the tweetname and its timestamp.\\n2.In vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) - \\nwe will take a vector or list of timechunks in the following:\\na.For min - (endtime -starttime)/60 + 1\\na.For hour - (endtime -starttime)/3600 + 1\\na.For day - (endtime -starttime)/(24*3600) + 1 \\nand initiaize them to 0 at first.\\n3.Then we will iterate the map.If our timestamp for a given tweetname is withing the start time and endtime we will increment the chunk value where the timestamp will position itself in the vector.\\n4.Finally we will return the resultant vector.\\n\\n# Complexity\\n- Time complexity:\\nO(n) - iterating the map\\n\\n- Space complexity:\\nO(n) - map\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    TweetCounts() {\\n        mp.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(freq==\"minute\"){\\n            vector<int>ans((endTime-startTime)/60+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/60]++;\\n            return ans;\\n        }else if(freq==\"hour\"){\\n            vector<int>ans((endTime-startTime)/3600+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/3600]++;\\n            return ans;\\n        }\\n        else {\\n            vector<int>ans((endTime-startTime)/(24*3600)+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/(24*3600)]++;\\n            return ans;\\n        }\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,vector<int>>mp;\\n    TweetCounts() {\\n        mp.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if(freq==\"minute\"){\\n            vector<int>ans((endTime-startTime)/60+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/60]++;\\n            return ans;\\n        }else if(freq==\"hour\"){\\n            vector<int>ans((endTime-startTime)/3600+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/3600]++;\\n            return ans;\\n        }\\n        else {\\n            vector<int>ans((endTime-startTime)/(24*3600)+1,0);\\n            for(auto it:mp[tweetName])if(it>=startTime && it<=endTime)ans[(it-startTime)/(24*3600)]++;\\n            return ans;\\n        }\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106274,
                "title": "c-hash-map-easy-solution",
                "content": "# Please UpVote if it helps you\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    map<string,vector<int>>m;\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int temp = (endTime-startTime+1);\\n        auto x = m[tweetName];\\n        int time;\\n        if(freq==\"minute\"){\\n            time = 60;\\n        }\\n        else if(freq==\"hour\"){\\n            time = 3600; \\n        }\\n        else{\\n            time = 86400;\\n        }\\n        int n = temp/time + (temp%time ?1:0);\\n        vector<int> ans(n);\\n        for(auto it:x){\\n            if(it>=startTime && it<=endTime){\\n                ans[(it-startTime)/time]+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    map<string,vector<int>>m;\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int temp = (endTime-startTime+1);\\n        auto x = m[tweetName];\\n        int time;\\n        if(freq==\"minute\"){\\n            time = 60;\\n        }\\n        else if(freq==\"hour\"){\\n            time = 3600; \\n        }\\n        else{\\n            time = 86400;\\n        }\\n        int n = temp/time + (temp%time ?1:0);\\n        vector<int> ans(n);\\n        for(auto it:x){\\n            if(it>=startTime && it<=endTime){\\n                ans[(it-startTime)/time]+=1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105913,
                "title": "python-binary-search",
                "content": "# Code\\n```\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.tweets = {}\\n        \\n    def bs(self,nums,target,left = None,right = None):\\n        if left is None or right is None:\\n            left,right = 0,len(nums)\\n        while left<right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid\\n        return left\\n\\n    def get_intervals(self,freq,start,end):\\n        freq_dict = {\\'minute\\': 60, \\'hour\\': 3600, \\'day\\': 86400}\\n        res, interval = [],freq_dict[freq]\\n        while start <= end:\\n            res.append([start,min(start+interval-1,end)])\\n            start = start+interval\\n        return res\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        if tweetName in self.tweets:\\n            index= self.bs(self.tweets[tweetName],time)\\n            if index ==0: \\n                self.tweets[tweetName] = [time] + self.tweets[tweetName]\\n            elif index == len(self.tweets[tweetName]):\\n                self.tweets[tweetName] = self.tweets[tweetName] + [time]\\n            else: \\n                self.tweets[tweetName] = self.tweets[tweetName][:index] + [time] + self.tweets[tweetName][index:]\\n        else: self.tweets[tweetName] = [time]\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals = self.get_intervals(freq,startTime,endTime)\\n        # print(startTime,endTime,intervals)\\n        res = []\\n        for start,end in intervals:\\n            left = self.bs(self.tweets[tweetName], start)\\n            right = self.bs(self.tweets[tweetName], end+1)\\n            res.append(right-left)\\n        return res\\n\\n        \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass TweetCounts(object):\\n\\n    def __init__(self):\\n        self.tweets = {}\\n        \\n    def bs(self,nums,target,left = None,right = None):\\n        if left is None or right is None:\\n            left,right = 0,len(nums)\\n        while left<right:\\n            mid = (left+right)//2\\n            if nums[mid] < target: left = mid+1\\n            else: right = mid\\n        return left\\n\\n    def get_intervals(self,freq,start,end):\\n        freq_dict = {\\'minute\\': 60, \\'hour\\': 3600, \\'day\\': 86400}\\n        res, interval = [],freq_dict[freq]\\n        while start <= end:\\n            res.append([start,min(start+interval-1,end)])\\n            start = start+interval\\n        return res\\n\\n    def recordTweet(self, tweetName, time):\\n        \"\"\"\\n        :type tweetName: str\\n        :type time: int\\n        :rtype: None\\n        \"\"\"\\n        if tweetName in self.tweets:\\n            index= self.bs(self.tweets[tweetName],time)\\n            if index ==0: \\n                self.tweets[tweetName] = [time] + self.tweets[tweetName]\\n            elif index == len(self.tweets[tweetName]):\\n                self.tweets[tweetName] = self.tweets[tweetName] + [time]\\n            else: \\n                self.tweets[tweetName] = self.tweets[tweetName][:index] + [time] + self.tweets[tweetName][index:]\\n        else: self.tweets[tweetName] = [time]\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        \"\"\"\\n        :type freq: str\\n        :type tweetName: str\\n        :type startTime: int\\n        :type endTime: int\\n        :rtype: List[int]\\n        \"\"\"\\n        intervals = self.get_intervals(freq,startTime,endTime)\\n        # print(startTime,endTime,intervals)\\n        res = []\\n        for start,end in intervals:\\n            left = self.bs(self.tweets[tweetName], start)\\n            right = self.bs(self.tweets[tweetName], end+1)\\n            res.append(right-left)\\n        return res\\n\\n        \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100484,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\n\\nstruct TweetCounts {\\n    tweets: HashMap<String, Vec<i32>>,\\n}\\n\\nimpl TweetCounts {\\n    fn new() -> Self {\\n        Self { tweets: HashMap::new() }\\n    }\\n\\n    fn record_tweet(&mut self, tweet_name: String, time: i32) {\\n        self.tweets.entry(tweet_name).or_insert_with(Vec::new).push(time);\\n    }\\n\\n    fn get_tweet_counts_per_frequency(\\n        &self,\\n        freq: String,\\n        tweet_name: String,\\n        start_time: i32,\\n        end_time: i32,\\n    ) -> Vec<i32> {\\n        let mut result = Vec::new();\\n        let mut chunk_size = 0;\\n        match freq.as_str() {\\n            \"minute\" => chunk_size = 60,\\n            \"hour\" => chunk_size = 3600,\\n            \"day\" => chunk_size = 86400,\\n            _ => {}\\n        }\\n        let mut chunk_start = start_time;\\n        let mut chunk_end = chunk_start + chunk_size - 1;\\n        while chunk_start <= end_time {\\n            if chunk_end > end_time {\\n                chunk_end = end_time;\\n            }\\n            let mut count = 0;\\n            if let Some(tweets) = self.tweets.get(&tweet_name) {\\n                for tweet in tweets {\\n                    if *tweet >= chunk_start && *tweet <= chunk_end {\\n                        count += 1;\\n                    }\\n                }\\n            }\\n            result.push(count);\\n            chunk_start += chunk_size;\\n            chunk_end += chunk_size;\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\n\\nstruct TweetCounts {\\n    tweets: HashMap<String, Vec<i32>>,\\n}\\n\\nimpl TweetCounts {\\n    fn new() -> Self {\\n        Self { tweets: HashMap::new() }\\n    }\\n\\n    fn record_tweet(&mut self, tweet_name: String, time: i32) {\\n        self.tweets.entry(tweet_name).or_insert_with(Vec::new).push(time);\\n    }\\n\\n    fn get_tweet_counts_per_frequency(\\n        &self,\\n        freq: String,\\n        tweet_name: String,\\n        start_time: i32,\\n        end_time: i32,\\n    ) -> Vec<i32> {\\n        let mut result = Vec::new();\\n        let mut chunk_size = 0;\\n        match freq.as_str() {\\n            \"minute\" => chunk_size = 60,\\n            \"hour\" => chunk_size = 3600,\\n            \"day\" => chunk_size = 86400,\\n            _ => {}\\n        }\\n        let mut chunk_start = start_time;\\n        let mut chunk_end = chunk_start + chunk_size - 1;\\n        while chunk_start <= end_time {\\n            if chunk_end > end_time {\\n                chunk_end = end_time;\\n            }\\n            let mut count = 0;\\n            if let Some(tweets) = self.tweets.get(&tweet_name) {\\n                for tweet in tweets {\\n                    if *tweet >= chunk_start && *tweet <= chunk_end {\\n                        count += 1;\\n                    }\\n                }\\n            }\\n            result.push(count);\\n            chunk_start += chunk_size;\\n            chunk_end += chunk_size;\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084935,
                "title": "on-time-on-space-0ms-my-fastest-solution-explained",
                "content": "\\n```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n\\n    private Map<String, TreeMap<Integer, Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        \\n        if (!map.containsKey(tweetName)) map.put(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        tweetMap.put(time, tweetMap.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n\\t\\n\\t    if (!map.containsKey(tweetName)) return null;\\n        List<Integer> res = new LinkedList<>();\\n        \\n        int interval = 0, size = 0;\\n        if (freq.equals(\"minute\")) {\\n            interval = 60;\\n        } else if (freq.equals(\"hour\")) {\\n            interval = 3600;\\n        } else {\\n            interval = 86400;\\n        }\\n        size = ((endTime - startTime) / interval) + 1;\\n        \\n        int[] buckets = new int[size];\\n        \\n        TreeMap<Integer, Integer> tweetMap = map.get(tweetName);\\n        \\n        for (Map.Entry<Integer, Integer> entry : tweetMap.subMap(startTime, endTime + 1).entrySet()) {\\n            \\n            int index = (entry.getKey() - startTime) / interval;\\n            buckets[index] += entry.getValue();\\n        }\\n        \\n        for (int num : buckets) res.add(num);\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3080063,
                "title": "easy-fast-short-c-solution-design-problem-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n//An API, or application programming interface, is a set of defined rules that enable different applications to communicate with each other.\\n    //For minutes->59, For Hours->3599, For Day->24*3600-1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, vector<int>> m;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int st, int et) {\\n        if(freq==\"minute\"){\\n            vector<int> ans((et-st)/60+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/60]++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(freq==\"hour\"){\\n            vector<int> ans((et-st)/3600+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/3600]++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else{\\n            vector<int> ans((et-st)/(24*3600)+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/(24*3600)]++;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Binary Search",
                    "Design",
                    "Sorting"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, vector<int>> m;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string t, int st, int et) {\\n        if(freq==\"minute\"){\\n            vector<int> ans((et-st)/60+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/60]++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else if(freq==\"hour\"){\\n            vector<int> ans((et-st)/3600+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/3600]++;\\n                }\\n            }\\n            return ans;\\n        }\\n        else{\\n            vector<int> ans((et-st)/(24*3600)+1, 0);\\n            for(auto a:m[t]){\\n                if(a>=st && a<=et){\\n                    ans[(a-st)/(24*3600)]++;\\n                }\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045358,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass TweetCounts {\\npublic:\\n    map<string,vector<int>>mp;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if (freq==\"minute\")\\n        {\\n           vector<int>ans((endTime-startTime)/60+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[(it-startTime)/60]++;\\n             }\\n           }\\n           return ans;\\n        }\\n        else if (freq==\"hour\")\\n        {\\n          vector<int>ans((endTime-startTime)/3600+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[(it-startTime)/3600]++;\\n             }\\n           }\\n           return ans;\\n        }\\n        else \\n        {\\n           vector<int>ans(((endTime-startTime)/(3600*24))+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[((it-startTime)/(3600*24))]++;\\n             }\\n           }\\n           return ans;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    map<string,vector<int>>mp;\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        mp[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        if (freq==\"minute\")\\n        {\\n           vector<int>ans((endTime-startTime)/60+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[(it-startTime)/60]++;\\n             }\\n           }\\n           return ans;\\n        }\\n        else if (freq==\"hour\")\\n        {\\n          vector<int>ans((endTime-startTime)/3600+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[(it-startTime)/3600]++;\\n             }\\n           }\\n           return ans;\\n        }\\n        else \\n        {\\n           vector<int>ans(((endTime-startTime)/(3600*24))+1,0);\\n           for (auto it:mp[tweetName])\\n           {\\n             if (it>=startTime && it<=endTime)\\n             {\\n                 ans[((it-startTime)/(3600*24))]++;\\n             }\\n           }\\n           return ans;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969808,
                "title": "python-simple-solution-use-sortedlist-faster-than-78",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe had to use some form of sorted container to store timestamps in increasing order\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used a hash map of ```SortedList``` to store all the timestamps in increasing order. Then, I divide total time range in chunks of given length, binary search the start and end of the chunks and append to the result array.\\n\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetMap = defaultdict(SortedList)\\n        self.steps = {\\'minute\\': 60, \\'hour\\': 3600, \\'day\\': 86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweetMap[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        chunkSize, chunks, timeList = self.steps[freq], [], self.tweetMap[tweetName]\\n        chunkCount, res = ceil((endTime - startTime + 1) / chunkSize), []\\n        chunks.append([startTime, startTime + chunkSize - 1 if startTime + chunkSize - 1 <= endTime else endTime])\\n        for i in range(1, chunkCount):\\n            start = chunks[i - 1][1] + 1\\n            end = start + chunkSize - 1\\n            if end > endTime: end = endTime\\n            chunks.append([start, end])\\n        for start, end in chunks:\\n            res.append(timeList.bisect_right(end) - timeList.bisect_left(start))\\n        return res\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Binary Search",
                    "Design",
                    "Sorting"
                ],
                "code": "```SortedList```\n```\\nfrom sortedcontainers import SortedList\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweetMap = defaultdict(SortedList)\\n        self.steps = {\\'minute\\': 60, \\'hour\\': 3600, \\'day\\': 86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.tweetMap[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        chunkSize, chunks, timeList = self.steps[freq], [], self.tweetMap[tweetName]\\n        chunkCount, res = ceil((endTime - startTime + 1) / chunkSize), []\\n        chunks.append([startTime, startTime + chunkSize - 1 if startTime + chunkSize - 1 <= endTime else endTime])\\n        for i in range(1, chunkCount):\\n            start = chunks[i - 1][1] + 1\\n            end = start + chunkSize - 1\\n            if end > endTime: end = endTime\\n            chunks.append([start, end])\\n        for start, end in chunks:\\n            res.append(timeList.bisect_right(end) - timeList.bisect_left(start))\\n        return res\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2945784,
                "title": "kotlin-hashmap-list",
                "content": "```\\nclass TweetCounts() {\\n \\n    // tweet name | tweets\\n    private val storage = hashMapOf<String, MutableList<Int>>()\\n\\n    fun recordTweet(tweetName: String, time: Int) {\\n        val timeline = storage.getOrDefault(tweetName, mutableListOf())\\n        timeline.add(time)\\n        storage[tweetName] = timeline\\n    }\\n\\n    fun getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List<Int> {\\n        if (storage.isEmpty()) return emptyList()\\n\\n        val tweets = storage[tweetName]\\n        if (tweets.isNullOrEmpty()) return emptyList()\\n\\n        val chunkType = getChunkType(freq)\\n\\n        val intervalSize = chunkType.intervalSize\\n\\n        val result = mutableListOf<Int>()\\n\\n        for (chunkIntervalStart in startTime .. endTime step intervalSize) {\\n            val chunkIntervalEnd = Math.min(chunkIntervalStart + intervalSize - 1, endTime)\\n            val tweetsInInterval = tweets.filter { time -> time in chunkIntervalStart..chunkIntervalEnd }\\n                .size\\n            result.add(tweetsInInterval)\\n        }\\n\\n        return result\\n    }\\n\\n    enum class ChunkType(val chunkName: String, val intervalSize: Int) {\\n        MIN(\"minute\", 60),\\n        HOUR(\"hour\", 3600),\\n        DAY(\"day\", 86400)\\n    }\\n\\n    private fun getChunkType(freq: String): ChunkType {\\n        return when (freq) {\\n            ChunkType.MIN.chunkName -> ChunkType.MIN\\n            ChunkType.HOUR.chunkName -> ChunkType.HOUR\\n            else -> ChunkType.DAY\\n        }\\n    }\\n\\n}",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```\\nclass TweetCounts() {\\n \\n    // tweet name | tweets\\n    private val storage = hashMapOf<String, MutableList<Int>>()\\n\\n    fun recordTweet(tweetName: String, time: Int) {\\n        val timeline = storage.getOrDefault(tweetName, mutableListOf())\\n        timeline.add(time)\\n        storage[tweetName] = timeline\\n    }\\n\\n    fun getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List<Int> {\\n        if (storage.isEmpty()) return emptyList()\\n\\n        val tweets = storage[tweetName]\\n        if (tweets.isNullOrEmpty()) return emptyList()\\n\\n        val chunkType = getChunkType(freq)\\n\\n        val intervalSize = chunkType.intervalSize\\n\\n        val result = mutableListOf<Int>()\\n\\n        for (chunkIntervalStart in startTime .. endTime step intervalSize) {\\n            val chunkIntervalEnd = Math.min(chunkIntervalStart + intervalSize - 1, endTime)\\n            val tweetsInInterval = tweets.filter { time -> time in chunkIntervalStart..chunkIntervalEnd }\\n                .size\\n            result.add(tweetsInInterval)\\n        }\\n\\n        return result\\n    }\\n\\n    enum class ChunkType(val chunkName: String, val intervalSize: Int) {\\n        MIN(\"minute\", 60),\\n        HOUR(\"hour\", 3600),\\n        DAY(\"day\", 86400)\\n    }\\n\\n    private fun getChunkType(freq: String): ChunkType {\\n        return when (freq) {\\n            ChunkType.MIN.chunkName -> ChunkType.MIN\\n            ChunkType.HOUR.chunkName -> ChunkType.HOUR\\n            else -> ChunkType.DAY\\n        }\\n    }\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2771776,
                "title": "c-hashmap-of-maps",
                "content": "Use binary search (with map) to find the two endpoints and then iterate through them, bucketing them according to the specified frequency.\\n\\n```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,map<int,int>> m;\\n    \\n    unordered_map<string,int> steps = { \\n        { \"minute\", 60 },\\n        { \"hour\", 60*60 },\\n        { \"day\", 60*60*24 }\\n    };\\n    \\n    void recordTweet(const string& tweetName, int time) {\\n        m[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(const string& freq, const string& tweetName, int startTime, int endTime) {\\n        int step = steps[freq];\\n        \\n        vector<int> result(1+(endTime - startTime)/step);\\n        \\n        for (auto it = m[tweetName].lower_bound(startTime); it != m[tweetName].upper_bound(endTime); ++it) {\\n            result[(it->first-startTime)/step] += it->second;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    unordered_map<string,map<int,int>> m;\\n    \\n    unordered_map<string,int> steps = { \\n        { \"minute\", 60 },\\n        { \"hour\", 60*60 },\\n        { \"day\", 60*60*24 }\\n    };\\n    \\n    void recordTweet(const string& tweetName, int time) {\\n        m[tweetName][time]++;\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(const string& freq, const string& tweetName, int startTime, int endTime) {\\n        int step = steps[freq];\\n        \\n        vector<int> result(1+(endTime - startTime)/step);\\n        \\n        for (auto it = m[tweetName].lower_bound(startTime); it != m[tweetName].upper_bound(endTime); ++it) {\\n            result[(it->first-startTime)/step] += it->second;\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769658,
                "title": "python-sortedlist-binary-search",
                "content": "This one seemed like a very confusing problem at first but when you look closely at the examples, you will understand what is going on.\\n\\n\\nFirst, we want a way to keep track of the time values at which each tweet happened. The best way is for each tweet, we can keep a list of time values. So, we will use a map where each key is the \"tweet name\" and each value is a \"list of time values\" for that tweet.\\n\\nTo use Binary Search, these time values need to be in a sorted order so to make sure as we insert the time values in the list they are automatically placed at their right position, we can use the \"SortedList\" container in Python. The complexity of an insertion operation is almost O(LogN) and it will place the item at its correct place to maintain the sorted order.\\n\\nNext, we have to find a way to get the count of the particular tweet in a certain timeframe. And the twist is that this timeframe is further divided into chunks, based on the frequency string. The timeframe has startTime and endTime values which are in \"seconds\" but the \"freq\" can be \"minute\" or \"hour\" or even \"day\". So we have to divide this timeframe in chunks based on this \"freq\" value.\\n\\n\\te.g., If \"freq\" = \"minute\", then if we have a timeframe as [10, 100]\\n\\tThen it will be divided into chunks of 60 seconds that is - \\n\\t\\t[0, 59], [60, 100]\\n\\t\\t\\n\\tThe last chunk may or may not have exactly 60 seconds as it depends on timeframe.\\n\\t\\n\\tAnd now, for each chunk we need to find how many times a particular tweet happened.\\n\\t\\n\\tSince for each tweet, its time value list is sorted, we can use Binary Search here.\\n\\t\\n\\tWe find the leftmost index of the time value that is >= start value of a chunk\\n\\tAnd then we find the rightmost index of the time value that is  <= end value of a chunk\\n\\t\\n\\tAnd the number of tweets is => rightmostIndex - leftmostIndex + 1\\n\\t\\n# **SOLUTION 1 -**\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    \\n    # Using a SortedList instead of a normal list\\n    # We can ensure that time values for the tweet is in a sorted order as we insert them\\n    def __init__(self):\\n        self.dict = defaultdict(SortedList)\\n        \\n    # In a SortedList, addition is an almost O(LogN) operation\\n    # As we insert any value, it is automatically put at its correct place to maintain the sorted order\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        output = []\\n        \\n        # How many chunks will be there\\n        # For ex. if freq is \"minutes\" there will be chunks of 60 seconds.\\n        # So lets find how many chunks will be there based on \"freq\" that we get\\n        \\n        # We also keep a variable that stores the value which is the size of each chunk\\n        count = 0\\n        size = 0\\n        \\n        if freq == \"minute\": \\n            count = ceil((endTime - startTime + 1) / 60)\\n            size = 60\\n        elif freq == \"hour\": \\n            count = ceil((endTime - startTime + 1) / 3600)\\n            size = 3600\\n        else: \\n            count = ceil((endTime - startTime + 1) / 86400)\\n            size = 86400\\n            \\n        chunks = []\\n        chunks.append([startTime, startTime + size - 1 if startTime + size - 1 <= endTime else endTime])\\n        \\n        for i in range(1, count):\\n            start = chunks[i-1][1] + 1\\n            end = start + size - 1\\n            \\n            if end > endTime: end = endTime\\n            \\n            chunks.append([start, end])\\n            \\n        # Now for each chunk, we need to find how many tweets are there\\n        freqList = self.dict[tweetName]\\n        for chunk in chunks:\\n            \\n            # Since list is sorted, we can use Binary Search\\n            # We first find the index of leftmost time value which is >= chunk[0]\\n            start = 0\\n            end = len(freqList) - 1\\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if freqList[mid] >= chunk[0]:\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n            \\n            # If we couldn\\'t find any index then stop. We are done with this chunk\\n            if leftmostIndex == -1: \\n                output.append(0)\\n                continue\\n            \\n            # We then find the index of rightmost time value which is <= chunk[1]\\n            start = 0\\n            end = len(freqList) - 1\\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if freqList[mid] <= chunk[1]:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            output.append(rightmostIndex - leftmostIndex + 1)\\n            \\n        \\n        return output\\n```\\n\\n# **SOLUTION 2 - SLIGHT OPTIMIZATION**\\n\\nInstead of creating a new list of chunks and then looping over that list, we can skip this process by simply running a loop same number of times as number of chunks and in each iteration, we first set the start and end values of a chunk and then we apply Binary Search to find the count.\\n\\nIn this way, there is no need to create a separate list of chunks and that will result in a better Space Complexity than the previous approach.\\n\\n```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    \\n    # Using a SortedList instead of a normal list\\n    # We can ensure that time values for the tweet is in a sorted order as we insert them\\n    def __init__(self):\\n        self.dict = defaultdict(SortedList)\\n        \\n    # In a SortedList, addition is an almost O(LogN) operation\\n    # As we insert any value, it is automatically put at its correct place to maintain the sorted order\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        output = []\\n        \\n        # How many chunks will be there\\n        # For ex. if freq is \"minutes\" there will be chunks of 60 seconds.\\n        # So lets find how many chunks will be there based on \"freq\" that we get\\n        \\n        # We also keep a variable that stores the value which is the size of each chunk\\n        count = 0\\n        size = 0\\n        \\n        if freq == \"minute\": \\n            count = ceil((endTime - startTime + 1) / 60)\\n            size = 60\\n        elif freq == \"hour\": \\n            count = ceil((endTime - startTime + 1) / 3600)\\n            size = 3600\\n        else: \\n            count = ceil((endTime - startTime + 1) / 86400)\\n            size = 86400\\n\\n            \\n        # Now for each chunk, we need to find how many tweets are there\\n        freqList = self.dict[tweetName]\\n        \\n        prevEndTime = 0\\n        \\n        for i in range(count):\\n            \\n            # First, get the start and end time of this chunk\\n            chunkStartTime = startTime if prevEndTime == 0 else prevEndTime + 1\\n            chunkEndTime = chunkStartTime + size - 1\\n            \\n            if chunkEndTime > endTime: chunkEndTime = endTime\\n            \\n            # Since list is sorted, we can use Binary Search\\n            # We first find the index of leftmost time value which is >= chunkStartTime\\n            start = 0\\n            end = len(freqList) - 1\\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if freqList[mid] >= chunkStartTime:\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n            \\n            # If we couldn\\'t find any index then stop. We are done with this chunk\\n            if leftmostIndex == -1: \\n                output.append(0)\\n                continue\\n            \\n            # We then find the index of rightmost time value which is <= chunkEndTime\\n            start = 0\\n            end = len(freqList) - 1\\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if freqList[mid] <= chunkEndTime:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            output.append(rightmostIndex - leftmostIndex + 1)\\n            \\n            # Set the previous end time as the current chunk\\'s end time\\n            # So that in next iteration, we can use this previous end time to start a new chunk\\n            prevEndTime = chunkEndTime\\n            \\n        \\n        return output\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    \\n    # Using a SortedList instead of a normal list\\n    # We can ensure that time values for the tweet is in a sorted order as we insert them\\n    def __init__(self):\\n        self.dict = defaultdict(SortedList)\\n        \\n    # In a SortedList, addition is an almost O(LogN) operation\\n    # As we insert any value, it is automatically put at its correct place to maintain the sorted order\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        output = []\\n        \\n        # How many chunks will be there\\n        # For ex. if freq is \"minutes\" there will be chunks of 60 seconds.\\n        # So lets find how many chunks will be there based on \"freq\" that we get\\n        \\n        # We also keep a variable that stores the value which is the size of each chunk\\n        count = 0\\n        size = 0\\n        \\n        if freq == \"minute\": \\n            count = ceil((endTime - startTime + 1) / 60)\\n            size = 60\\n        elif freq == \"hour\": \\n            count = ceil((endTime - startTime + 1) / 3600)\\n            size = 3600\\n        else: \\n            count = ceil((endTime - startTime + 1) / 86400)\\n            size = 86400\\n            \\n        chunks = []\\n        chunks.append([startTime, startTime + size - 1 if startTime + size - 1 <= endTime else endTime])\\n        \\n        for i in range(1, count):\\n            start = chunks[i-1][1] + 1\\n            end = start + size - 1\\n            \\n            if end > endTime: end = endTime\\n            \\n            chunks.append([start, end])\\n            \\n        # Now for each chunk, we need to find how many tweets are there\\n        freqList = self.dict[tweetName]\\n        for chunk in chunks:\\n            \\n            # Since list is sorted, we can use Binary Search\\n            # We first find the index of leftmost time value which is >= chunk[0]\\n            start = 0\\n            end = len(freqList) - 1\\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if freqList[mid] >= chunk[0]:\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n            \\n            # If we couldn\\'t find any index then stop. We are done with this chunk\\n            if leftmostIndex == -1: \\n                output.append(0)\\n                continue\\n            \\n            # We then find the index of rightmost time value which is <= chunk[1]\\n            start = 0\\n            end = len(freqList) - 1\\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if freqList[mid] <= chunk[1]:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            output.append(rightmostIndex - leftmostIndex + 1)\\n            \\n        \\n        return output\\n```\n```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    \\n    # Using a SortedList instead of a normal list\\n    # We can ensure that time values for the tweet is in a sorted order as we insert them\\n    def __init__(self):\\n        self.dict = defaultdict(SortedList)\\n        \\n    # In a SortedList, addition is an almost O(LogN) operation\\n    # As we insert any value, it is automatically put at its correct place to maintain the sorted order\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.dict[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        output = []\\n        \\n        # How many chunks will be there\\n        # For ex. if freq is \"minutes\" there will be chunks of 60 seconds.\\n        # So lets find how many chunks will be there based on \"freq\" that we get\\n        \\n        # We also keep a variable that stores the value which is the size of each chunk\\n        count = 0\\n        size = 0\\n        \\n        if freq == \"minute\": \\n            count = ceil((endTime - startTime + 1) / 60)\\n            size = 60\\n        elif freq == \"hour\": \\n            count = ceil((endTime - startTime + 1) / 3600)\\n            size = 3600\\n        else: \\n            count = ceil((endTime - startTime + 1) / 86400)\\n            size = 86400\\n\\n            \\n        # Now for each chunk, we need to find how many tweets are there\\n        freqList = self.dict[tweetName]\\n        \\n        prevEndTime = 0\\n        \\n        for i in range(count):\\n            \\n            # First, get the start and end time of this chunk\\n            chunkStartTime = startTime if prevEndTime == 0 else prevEndTime + 1\\n            chunkEndTime = chunkStartTime + size - 1\\n            \\n            if chunkEndTime > endTime: chunkEndTime = endTime\\n            \\n            # Since list is sorted, we can use Binary Search\\n            # We first find the index of leftmost time value which is >= chunkStartTime\\n            start = 0\\n            end = len(freqList) - 1\\n            leftmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                if freqList[mid] >= chunkStartTime:\\n                    leftmostIndex = mid\\n                    end = mid - 1\\n                else: start = mid + 1\\n            \\n            # If we couldn\\'t find any index then stop. We are done with this chunk\\n            if leftmostIndex == -1: \\n                output.append(0)\\n                continue\\n            \\n            # We then find the index of rightmost time value which is <= chunkEndTime\\n            start = 0\\n            end = len(freqList) - 1\\n            rightmostIndex = -1\\n            \\n            while start <= end:\\n                mid = start + (end - start) // 2\\n                \\n                if freqList[mid] <= chunkEndTime:\\n                    rightmostIndex = mid\\n                    start = mid + 1\\n                else: end = mid - 1\\n            \\n            output.append(rightmostIndex - leftmostIndex + 1)\\n            \\n            # Set the previous end time as the current chunk\\'s end time\\n            # So that in next iteration, we can use this previous end time to start a new chunk\\n            prevEndTime = chunkEndTime\\n            \\n        \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2730116,
                "title": "faster-than-20-12-of-python3-online-submissions",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.d = defaultdict(list)\\n        self.freq = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.d[tweetName] += [time]\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        s = sorted(self.d[tweetName])\\n        result = []\\n        for time in range(startTime, endTime+1, self.freq[freq]):\\n            l = bisect.bisect_left(s, time)\\n            r = bisect.bisect_right(s, min(time+self.freq[freq]-1, endTime))\\n            result.append(r-l)\\n        return result",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.d = defaultdict(list)\\n        self.freq = {\"minute\": 60, \"hour\": 3600, \"day\": 86400}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.d[tweetName] += [time]\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        s = sorted(self.d[tweetName])\\n        result = []\\n        for time in range(startTime, endTime+1, self.freq[freq]):\\n            l = bisect.bisect_left(s, time)\\n            r = bisect.bisect_right(s, min(time+self.freq[freq]-1, endTime))\\n            result.append(r-l)\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 2726937,
                "title": "python-solution",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tw_freq = defaultdict(list)\\n        self.intv = {\"minute\": 60, \"hour\":3600, \"day\":86400}\\n\\n    def recordTweet(self, tw: str, time: int) -> None:\\n        self.tw_freq[tw].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tw: str, s: int, e: int) -> List[int]:\\n        dt = self.intv[freq]\\n        ans = [0]*((e-s)//dt+1)\\n        for t in self.tw_freq[tw]:\\n            if s<=t<=e:\\n                ans[(t-s)//dt]+=1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tw_freq = defaultdict(list)\\n        self.intv = {\"minute\": 60, \"hour\":3600, \"day\":86400}\\n\\n    def recordTweet(self, tw: str, time: int) -> None:\\n        self.tw_freq[tw].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tw: str, s: int, e: int) -> List[int]:\\n        dt = self.intv[freq]\\n        ans = [0]*((e-s)//dt+1)\\n        for t in self.tw_freq[tw]:\\n            if s<=t<=e:\\n                ans[(t-s)//dt]+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719121,
                "title": "python-simple-maths",
                "content": "\\n    def __init__(self):\\n        self.dict1 = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        self.dict1[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        if freq == \"minute\":\\n            chunk_size = 60\\n        elif freq == \"hour\":\\n            chunk_size = 60*60\\n        elif freq == \"day\":\\n            chunk_size = 60*60*24\\n            \\n        chunk_count = int((endTime - startTime)/chunk_size) + 1\\n        \\n        bins = [0]*chunk_count\\n        \\n        for i in self.dict1[tweetName]:\\n            if startTime <= i and i <= endTime:\\n                chunk_number = int((i-startTime)/chunk_size)\\n                bins[chunk_number] += 1\\n\\n        return bins\\n",
                "solutionTags": [],
                "code": "\\n    def __init__(self):\\n        self.dict1 = defaultdict(list)\\n\\n    def recordTweet(self, tweetName, time):\\n        self.dict1[tweetName].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq, tweetName, startTime, endTime):\\n        if freq == \"minute\":\\n            chunk_size = 60\\n        elif freq == \"hour\":\\n            chunk_size = 60*60\\n        elif freq == \"day\":\\n            chunk_size = 60*60*24\\n            \\n        chunk_count = int((endTime - startTime)/chunk_size) + 1\\n        \\n        bins = [0]*chunk_count\\n        \\n        for i in self.dict1[tweetName]:\\n            if startTime <= i and i <= endTime:\\n                chunk_number = int((i-startTime)/chunk_size)\\n                bins[chunk_number] += 1\\n\\n        return bins\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2649802,
                "title": "python-sortedlist-solution-surely-the-testcases-are-not-challenging-enough",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    # To differentiate between different tweetnames, we use a hash table\\n    # Each hash table key map to a sortedlist structure to allow for rapid binary search\\n    \\n    def __init__(self):\\n        self.hash_table = {}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.hash_table:\\n            self.hash_table[tweetName] = SortedList()\\n        self.hash_table[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\":\\n            interval = 60\\n        elif freq == \"hour\":\\n            interval = 3600\\n        else:\\n            interval = 86400\\n        result = []\\n        for time in range(startTime, endTime+1, interval):\\n            li = self.hash_table[tweetName].bisect_left(time)\\n            ri = self.hash_table[tweetName].bisect_right(min(time + interval-1, endTime))\\n            result.append(ri-li)\\n        return result\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n    # To differentiate between different tweetnames, we use a hash table\\n    # Each hash table key map to a sortedlist structure to allow for rapid binary search\\n    \\n    def __init__(self):\\n        self.hash_table = {}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.hash_table:\\n            self.hash_table[tweetName] = SortedList()\\n        self.hash_table[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        if freq == \"minute\":\\n            interval = 60\\n        elif freq == \"hour\":\\n            interval = 3600\\n        else:\\n            interval = 86400\\n        result = []\\n        for time in range(startTime, endTime+1, interval):\\n            li = self.hash_table[tweetName].bisect_left(time)\\n            ri = self.hash_table[tweetName].bisect_right(min(time + interval-1, endTime))\\n            result.append(ri-li)\\n        return result\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626246,
                "title": "java-solution",
                "content": "```\\n// Tweet Counts Per Frequency\\n// https://leetcode.com//problems/tweet-counts-per-frequency\\n\\nclass TweetCounts\\n{\\n    Map<String, List<Integer>> map;\\n    public TweetCounts()\\n    {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time)\\n    {\\n        if (!map.containsKey(tweetName))\\n            map.put(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)\\n    {\\n        List<Integer> res = new ArrayList<>();\\n        if (!map.containsKey(tweetName))\\n            return res;\\n        int interval = 0;\\n        if (freq.equals(\"minute\"))\\n            interval = 60;\\n        else if (freq.equals(\"hour\"))\\n            interval = 3600;\\n        else if (freq.equals(\"day\"))\\n            interval = 86400;\\n        int[] count = new int[(endTime - startTime) / interval + 1];\\n        for (int time : map.get(tweetName))\\n        {\\n            if (time >= startTime && time <= endTime)\\n                count[(time - startTime) / interval]++;\\n        }\\n        for (int i : count)\\n            res.add(i);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Tweet Counts Per Frequency\\n// https://leetcode.com//problems/tweet-counts-per-frequency\\n\\nclass TweetCounts\\n{\\n    Map<String, List<Integer>> map;\\n    public TweetCounts()\\n    {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time)\\n    {\\n        if (!map.containsKey(tweetName))\\n            map.put(tweetName, new ArrayList<>());\\n        map.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime)\\n    {\\n        List<Integer> res = new ArrayList<>();\\n        if (!map.containsKey(tweetName))\\n            return res;\\n        int interval = 0;\\n        if (freq.equals(\"minute\"))\\n            interval = 60;\\n        else if (freq.equals(\"hour\"))\\n            interval = 3600;\\n        else if (freq.equals(\"day\"))\\n            interval = 86400;\\n        int[] count = new int[(endTime - startTime) / interval + 1];\\n        for (int time : map.get(tweetName))\\n        {\\n            if (time >= startTime && time <= endTime)\\n                count[(time - startTime) / interval]++;\\n        }\\n        for (int i : count)\\n            res.add(i);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599072,
                "title": "java-treemap-based-solution-time-beats-95-space-beats-95",
                "content": "```java\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\npublic class TweetCounts {\\n\\n    class Chunk {\\n        int start, end, count;\\n\\n        public Chunk(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o instanceof Chunk) {\\n                var oc = (Chunk) o;\\n                return oc.start == this.start && oc.end == this.end;\\n            }\\n            return false;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return super.hashCode();\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return this.start + \"-\" + this.end;\\n        }\\n    }\\n\\n    private final Map<String, TreeMap<Integer, Integer>> tweetCounts = new HashMap<>();\\n    private final Map<String, Integer> frequencyOffsets = new HashMap<>();\\n\\n    public TweetCounts() {\\n        frequencyOffsets.put(\"minute\", 59);\\n        frequencyOffsets.put(\"hour\", 3599);\\n        frequencyOffsets.put(\"day\", 86399);\\n    }\\n\\n\\n    /**\\n     * Insert the tweet in time complexity: O(log t) where t is the no. of timestamps seen so far\\n     *\\n     * @param tweetName\\n     * @param time\\n     */\\n    public void recordTweet(String tweetName, int time) {\\n        tweetCounts.putIfAbsent(tweetName, new TreeMap<>());\\n        var timeCountMap = tweetCounts.get(tweetName);\\n        timeCountMap.put(time, timeCountMap.getOrDefault(time, 0) + 1);\\n    }\\n\\n    protected List<Chunk> getChunks(String freq, int start, int end) {\\n        var chunks = new ArrayList<Chunk>();\\n        int offset = frequencyOffsets.getOrDefault(freq, frequencyOffsets.get(\"minute\"));\\n        int currentStart = start;\\n\\n        while (currentStart <= end) {\\n            chunks.add(new Chunk(currentStart, Math.min(currentStart + offset, end)));\\n            currentStart += (offset + 1);\\n        }\\n\\n        return chunks;\\n    }\\n\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        var chunks = getChunks(freq, startTime, endTime);\\n\\n        TreeMap<Integer, Integer> tweetTimeCountMap = tweetCounts.get(tweetName);\\n        if (tweetTimeCountMap == null || tweetTimeCountMap.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        var tweetTimeCountsIt = tweetTimeCountMap.tailMap(startTime).entrySet().iterator();\\n\\n        if (tweetTimeCountsIt.hasNext()) {\\n            var currentTweetTimeCountEntry = tweetTimeCountsIt.next();\\n\\n            for (var chunk : chunks) {\\n                while (currentTweetTimeCountEntry.getKey() <= chunk.end && currentTweetTimeCountEntry.getKey() >= chunk.start) {\\n                    chunk.count += currentTweetTimeCountEntry.getValue();\\n\\n                    if (!tweetTimeCountsIt.hasNext()) {\\n                        break;\\n                    }\\n\\n                    currentTweetTimeCountEntry = tweetTimeCountsIt.next();\\n                }\\n            }\\n        }\\n\\n        return chunks.stream().map(c -> c.count).collect(Collectors.toList());\\n    }\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Tree",
                    "Design"
                ],
                "code": "```java\\nimport java.util.*;\\nimport java.util.stream.Collectors;\\n\\npublic class TweetCounts {\\n\\n    class Chunk {\\n        int start, end, count;\\n\\n        public Chunk(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (o instanceof Chunk) {\\n                var oc = (Chunk) o;\\n                return oc.start == this.start && oc.end == this.end;\\n            }\\n            return false;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return super.hashCode();\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return this.start + \"-\" + this.end;\\n        }\\n    }\\n\\n    private final Map<String, TreeMap<Integer, Integer>> tweetCounts = new HashMap<>();\\n    private final Map<String, Integer> frequencyOffsets = new HashMap<>();\\n\\n    public TweetCounts() {\\n        frequencyOffsets.put(\"minute\", 59);\\n        frequencyOffsets.put(\"hour\", 3599);\\n        frequencyOffsets.put(\"day\", 86399);\\n    }\\n\\n\\n    /**\\n     * Insert the tweet in time complexity: O(log t) where t is the no. of timestamps seen so far\\n     *\\n     * @param tweetName\\n     * @param time\\n     */\\n    public void recordTweet(String tweetName, int time) {\\n        tweetCounts.putIfAbsent(tweetName, new TreeMap<>());\\n        var timeCountMap = tweetCounts.get(tweetName);\\n        timeCountMap.put(time, timeCountMap.getOrDefault(time, 0) + 1);\\n    }\\n\\n    protected List<Chunk> getChunks(String freq, int start, int end) {\\n        var chunks = new ArrayList<Chunk>();\\n        int offset = frequencyOffsets.getOrDefault(freq, frequencyOffsets.get(\"minute\"));\\n        int currentStart = start;\\n\\n        while (currentStart <= end) {\\n            chunks.add(new Chunk(currentStart, Math.min(currentStart + offset, end)));\\n            currentStart += (offset + 1);\\n        }\\n\\n        return chunks;\\n    }\\n\\n\\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        var chunks = getChunks(freq, startTime, endTime);\\n\\n        TreeMap<Integer, Integer> tweetTimeCountMap = tweetCounts.get(tweetName);\\n        if (tweetTimeCountMap == null || tweetTimeCountMap.isEmpty()) {\\n            return Collections.emptyList();\\n        }\\n\\n        var tweetTimeCountsIt = tweetTimeCountMap.tailMap(startTime).entrySet().iterator();\\n\\n        if (tweetTimeCountsIt.hasNext()) {\\n            var currentTweetTimeCountEntry = tweetTimeCountsIt.next();\\n\\n            for (var chunk : chunks) {\\n                while (currentTweetTimeCountEntry.getKey() <= chunk.end && currentTweetTimeCountEntry.getKey() >= chunk.start) {\\n                    chunk.count += currentTweetTimeCountEntry.getValue();\\n\\n                    if (!tweetTimeCountsIt.hasNext()) {\\n                        break;\\n                    }\\n\\n                    currentTweetTimeCountEntry = tweetTimeCountsIt.next();\\n                }\\n            }\\n        }\\n\\n        return chunks.stream().map(c -> c.count).collect(Collectors.toList());\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2595063,
                "title": "java-2-sols-explained-how-treemap-improves-search-time-v-s-list-tc-sc",
                "content": "// Solution 1: Using Map for tweetName to list of timestamps\\n// Problem in this solution is that everytime, I am reading ALL the timestamp related to the tweetName and hence time taking\\n\\n// TC : O(N); N = avg num of tweets per tweetName (for getTweetCountsPerFrequency())\\n// SC : O(M); M = num of tweetNames\\n```\\nclass TweetCounts {\\n\\n    Map<String, List<Integer>> tweetToTimeMap;\\n    public TweetCounts() {\\n        tweetToTimeMap = new HashMap<>(); // key -> tweetName, value -> list of time stamps associated with tweetName\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetToTimeMap.putIfAbsent(tweetName, new ArrayList<>());\\n        tweetToTimeMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // find the size of interval\\n        // If minute = 60 (60sec in 1 minutes)\\n        // if hour = 60 * 60\\n        // if day = 24 * 60 * 60\\n        int intervalSize = 0;\\n        if(freq.equals(\"minute\")) {\\n            intervalSize = 60;\\n        } else if(freq.equals(\"hour\")) {\\n            intervalSize = 60 * 60;\\n        } else {\\n            intervalSize = 60 * 60 * 24;\\n        }\\n        \\n        // we have the intervalSize, now find how many intervals will fit in between endTime and startTime with intervalSize\\n        // intervalSize = 60, startTime = 30, endTime = 149 => (149 - 30)/60 = 119/60 = 1 (with 59 remiander, so will require 1 additional interval, that is why the below for loop goes unitl less than equal to numOfIntervals)\\n        int numOfIntervals = (endTime - startTime)/intervalSize;\\n        for(int i = 0; i <= numOfIntervals; i++) {\\n            res.add(0); // make all the intervals currently have 0 tweets\\n        }\\n        \\n        // now get all the time stamps of tweetName and see if the time stamp lies between endTime and startTime\\n        // if it does then find which interval it goes to and add the count to that interval\\n        for(int time : tweetToTimeMap.get(tweetName)) {\\n            if(startTime <= time && time <= endTime) {\\n                int intervalIdx = (time - startTime)/intervalSize;\\n                res.set(intervalIdx, res.get(intervalIdx) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n// Solution 2: Using Map for tweetName to TreeMap<timeStamp, count of tweet to that timestamp>\\n// Here, I am storing tweetName with a TreeMap which will have key as the timeStamp and value as the count for that timestamp\\n// The TreeMap has a function called subMap(start, end) which returns the SUBMAP (keys, value pairs which lies between start and end (inclusive)) in O(1) time, so now search time will decrease\\n\\n// TC : O(N); N = avg num of tweets per tweetName between startTime and endTime(for getTweetCountsPerFrequency())\\n// SC : O(M); M = num of tweetNames\\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeMap<Integer, Integer>> tweetToTimeMap;\\n    public TweetCounts() {\\n        tweetToTimeMap = new HashMap<>(); // key -> tweetName, value -> list of time stamps associated with tweetName\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetToTimeMap.putIfAbsent(tweetName, new TreeMap<>());\\n        \\n        TreeMap<Integer, Integer> timeMap = tweetToTimeMap.get(tweetName);\\n        timeMap.put(time, timeMap.getOrDefault(time, 0) + 1);\\n        \\n        tweetToTimeMap.put(tweetName, timeMap);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // find the size of interval\\n        // If minute = 60 (60sec in 1 minutes)\\n        // if hour = 60 * 60\\n        // if day = 24 * 60 * 60\\n        int intervalSize = 0;\\n        if(freq.equals(\"minute\")) {\\n            intervalSize = 60;\\n        } else if(freq.equals(\"hour\")) {\\n            intervalSize = 60 * 60;\\n        } else {\\n            intervalSize = 60 * 60 * 24;\\n        }\\n        \\n        // we have the intervalSize, now find how many intervals will fit in between endTime and startTime with intervalSize\\n        // intervalSize = 60, startTime = 30, endTime = 149 => (149 - 30)/60 = 119/60 = 1 (with 59 remiander, so will require 1 additional interval, that is why the below for loop goes unitl less than equal to numOfIntervals)\\n        int numOfIntervals = (endTime - startTime)/intervalSize;\\n        for(int i = 0; i <= numOfIntervals; i++) {\\n            res.add(0); // make all the intervals currently have 0 tweets\\n        }\\n        \\n        // now get all the time stamps of tweetName and see if the time stamp lies between endTime and startTime\\n        // if it does then find which interval it goes to and add the count to that interval\\n        for(Map.Entry<Integer, Integer> entry : tweetToTimeMap.get(tweetName).subMap(startTime, endTime + 1).entrySet()) {\\n            int intervalIdx = (entry.getKey() - startTime)/intervalSize;\\n            res.set(intervalIdx, res.get(intervalIdx) + entry.getValue()); // need to add new value to the previous value for this idx\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    Map<String, List<Integer>> tweetToTimeMap;\\n    public TweetCounts() {\\n        tweetToTimeMap = new HashMap<>(); // key -> tweetName, value -> list of time stamps associated with tweetName\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetToTimeMap.putIfAbsent(tweetName, new ArrayList<>());\\n        tweetToTimeMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // find the size of interval\\n        // If minute = 60 (60sec in 1 minutes)\\n        // if hour = 60 * 60\\n        // if day = 24 * 60 * 60\\n        int intervalSize = 0;\\n        if(freq.equals(\"minute\")) {\\n            intervalSize = 60;\\n        } else if(freq.equals(\"hour\")) {\\n            intervalSize = 60 * 60;\\n        } else {\\n            intervalSize = 60 * 60 * 24;\\n        }\\n        \\n        // we have the intervalSize, now find how many intervals will fit in between endTime and startTime with intervalSize\\n        // intervalSize = 60, startTime = 30, endTime = 149 => (149 - 30)/60 = 119/60 = 1 (with 59 remiander, so will require 1 additional interval, that is why the below for loop goes unitl less than equal to numOfIntervals)\\n        int numOfIntervals = (endTime - startTime)/intervalSize;\\n        for(int i = 0; i <= numOfIntervals; i++) {\\n            res.add(0); // make all the intervals currently have 0 tweets\\n        }\\n        \\n        // now get all the time stamps of tweetName and see if the time stamp lies between endTime and startTime\\n        // if it does then find which interval it goes to and add the count to that interval\\n        for(int time : tweetToTimeMap.get(tweetName)) {\\n            if(startTime <= time && time <= endTime) {\\n                int intervalIdx = (time - startTime)/intervalSize;\\n                res.set(intervalIdx, res.get(intervalIdx) + 1);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass TweetCounts {\\n\\n    Map<String, TreeMap<Integer, Integer>> tweetToTimeMap;\\n    public TweetCounts() {\\n        tweetToTimeMap = new HashMap<>(); // key -> tweetName, value -> list of time stamps associated with tweetName\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweetToTimeMap.putIfAbsent(tweetName, new TreeMap<>());\\n        \\n        TreeMap<Integer, Integer> timeMap = tweetToTimeMap.get(tweetName);\\n        timeMap.put(time, timeMap.getOrDefault(time, 0) + 1);\\n        \\n        tweetToTimeMap.put(tweetName, timeMap);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        \\n        // find the size of interval\\n        // If minute = 60 (60sec in 1 minutes)\\n        // if hour = 60 * 60\\n        // if day = 24 * 60 * 60\\n        int intervalSize = 0;\\n        if(freq.equals(\"minute\")) {\\n            intervalSize = 60;\\n        } else if(freq.equals(\"hour\")) {\\n            intervalSize = 60 * 60;\\n        } else {\\n            intervalSize = 60 * 60 * 24;\\n        }\\n        \\n        // we have the intervalSize, now find how many intervals will fit in between endTime and startTime with intervalSize\\n        // intervalSize = 60, startTime = 30, endTime = 149 => (149 - 30)/60 = 119/60 = 1 (with 59 remiander, so will require 1 additional interval, that is why the below for loop goes unitl less than equal to numOfIntervals)\\n        int numOfIntervals = (endTime - startTime)/intervalSize;\\n        for(int i = 0; i <= numOfIntervals; i++) {\\n            res.add(0); // make all the intervals currently have 0 tweets\\n        }\\n        \\n        // now get all the time stamps of tweetName and see if the time stamp lies between endTime and startTime\\n        // if it does then find which interval it goes to and add the count to that interval\\n        for(Map.Entry<Integer, Integer> entry : tweetToTimeMap.get(tweetName).subMap(startTime, endTime + 1).entrySet()) {\\n            int intervalIdx = (entry.getKey() - startTime)/intervalSize;\\n            res.set(intervalIdx, res.get(intervalIdx) + entry.getValue()); // need to add new value to the previous value for this idx\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570464,
                "title": "tweet-counts-per-frequency-python",
                "content": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.adict={}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName in self.adict:\\n            self.adict[tweetName].append(time)\\n        else:\\n            self.adict[tweetName]=[time]\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        segment=None\\n        if freq==\\'minute\\':\\n            segment=60\\n        elif freq==\\'hour\\':\\n            segment=3600\\n        else:\\n            segment=86400\\n        \\n        \\n        size=((endTime-startTime)//segment)+1\\n        \\n        store=[0]*size\\n        \\n        for time in self.adict[tweetName]:\\n            if time>=startTime and time<=endTime:\\n                \\n                key=(time-startTime)//segment\\n\\n                store[key]+=1\\n        return store\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.adict={}\\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName in self.adict:\\n            self.adict[tweetName].append(time)\\n        else:\\n            self.adict[tweetName]=[time]\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        segment=None\\n        if freq==\\'minute\\':\\n            segment=60\\n        elif freq==\\'hour\\':\\n            segment=3600\\n        else:\\n            segment=86400\\n        \\n        \\n        size=((endTime-startTime)//segment)+1\\n        \\n        store=[0]*size\\n        \\n        for time in self.adict[tweetName]:\\n            if time>=startTime and time<=endTime:\\n                \\n                key=(time-startTime)//segment\\n\\n                store[key]+=1\\n        return store\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2564869,
                "title": "java-hashmap-solution-with-explaination-comments",
                "content": "```\\nclass TweetCounts {\\n      Map<String,List<Integer>>map;\\n    \\n    public TweetCounts() {\\n        map=new HashMap<>();       //initialize the object\\n    }\\n    \\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)){\\n          map.put(tweetName,new ArrayList<>());\\n              map.get(tweetName).add(time);      // add all the time when particular tweet occur in list\\n        }\\n        else\\n            map.get(tweetName).add(time);\\n         \\n    }\\n    \\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        List<Integer>list=map.get(tweetName);   // get the list which contain time of tweet\\n        int frequency = getFreq(freq);     // get the freq as min=60 ,hour=60*60 for chunks\\n        \\n        int size=(endTime-startTime)/frequency; // to know total chunks for that period(start-end)\\n        int[] chunks=new int[size+1];\\n        \\n        for(int l:list)\\n        {\\n            if(l>=startTime && l<=endTime)        // in a range \\n                chunks[(l-startTime)/frequency]++;   // than increments that chunks index value\\n        }\\n        List<Integer>res=new ArrayList<>();\\n        for(int n:chunks)\\n            res.add(n);               // add ans to res\\n        \\n        \\n        return res;\\n    }\\n    \\n    // to convert freq to time(integer)\\n    public int getFreq(String freq)\\n    {\\n        \\n        if(freq.equals(\"minute\"))\\n            return 60;\\n        else if(freq.equals(\"hour\"))\\n            return 3600;\\n        else\\n            return 60*60*24;\\n       \\n        \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n      Map<String,List<Integer>>map;\\n    \\n    public TweetCounts() {\\n        map=new HashMap<>();       //initialize the object\\n    }\\n    \\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!map.containsKey(tweetName)){\\n          map.put(tweetName,new ArrayList<>());\\n              map.get(tweetName).add(time);      // add all the time when particular tweet occur in list\\n        }\\n        else\\n            map.get(tweetName).add(time);\\n         \\n    }\\n    \\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        \\n        List<Integer>list=map.get(tweetName);   // get the list which contain time of tweet\\n        int frequency = getFreq(freq);     // get the freq as min=60 ,hour=60*60 for chunks\\n        \\n        int size=(endTime-startTime)/frequency; // to know total chunks for that period(start-end)\\n        int[] chunks=new int[size+1];\\n        \\n        for(int l:list)\\n        {\\n            if(l>=startTime && l<=endTime)        // in a range \\n                chunks[(l-startTime)/frequency]++;   // than increments that chunks index value\\n        }\\n        List<Integer>res=new ArrayList<>();\\n        for(int n:chunks)\\n            res.add(n);               // add ans to res\\n        \\n        \\n        return res;\\n    }\\n    \\n    // to convert freq to time(integer)\\n    public int getFreq(String freq)\\n    {\\n        \\n        if(freq.equals(\"minute\"))\\n            return 60;\\n        else if(freq.equals(\"hour\"))\\n            return 3600;\\n        else\\n            return 60*60*24;\\n       \\n        \\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2558438,
                "title": "c-solution",
                "content": "```\\nclass TweetCounts {\\n    unordered_map<string, vector<int>> m;\\npublic:\\n    TweetCounts() \\n    {\\n        m.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) \\n    {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) \\\\\\n    {\\n        if(freq==\"minute\")\\n        {\\n            vector<int> count((endTime-startTime)/60 + 1, 0);\\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/60]++;\\n            }\\n            return count;\\n        }\\n        else if(freq==\"hour\")\\n        {\\n            vector<int> count((endTime-startTime)/3600 + 1, 0);   \\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/3600]++;\\n            }\\n            return count;\\n        }\\n        else\\n        {\\n            vector<int> count((endTime-startTime)/86400 + 1, 0);\\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/86400]++;\\n            }\\n            return count;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass TweetCounts {\\n    unordered_map<string, vector<int>> m;\\npublic:\\n    TweetCounts() \\n    {\\n        m.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) \\n    {\\n        m[tweetName].push_back(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) \\\\\\n    {\\n        if(freq==\"minute\")\\n        {\\n            vector<int> count((endTime-startTime)/60 + 1, 0);\\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/60]++;\\n            }\\n            return count;\\n        }\\n        else if(freq==\"hour\")\\n        {\\n            vector<int> count((endTime-startTime)/3600 + 1, 0);   \\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/3600]++;\\n            }\\n            return count;\\n        }\\n        else\\n        {\\n            vector<int> count((endTime-startTime)/86400 + 1, 0);\\n            for(auto a:m[tweetName])\\n            {\\n                if(startTime<=a && a<=endTime) count[(a-startTime)/86400]++;\\n            }\\n            return count;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2544075,
                "title": "noob-dpm07",
                "content": "```\\nclass TweetCounts:\\n    \"\"\"solved using a dict\"\"\"\\n\\n    def __init__(self):\\n        self.dic = defaultdict(lambda: [])  # defaultdict(list)\\n\\n    def recordTweet(self, hash_tag: str, time: int) -> None:\\n        self.dic[hash_tag].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, hash_tag: str, startTime: int, endTime: int) -> List[int]:\\n        \"\"\"\\n        freq: like choice field in db (\\'minute\\', \\'hour\\', \\'day\\')\\n        \"\"\"\\n        print(\"....\")\\n        print(freq, startTime, endTime)\\n        chunk = 60\\n        if freq == \"hour\":\\n            chunk = 3600\\n        elif freq == \"day\":\\n            chunk = 86400\\n    \\n        num_of_chunk = math.ceil((endTime - startTime) / chunk)\\n\\n        # as we are ceil our num_of_chunk is round-off so, for exact num_of_chunk\\n        if (endTime - startTime) % chunk == 0:\\n            num_of_chunk += 1\\n        \\n        res = [0] * num_of_chunk\\n        timeLst = self.dic[hash_tag]\\n        \\n        for time in timeLst:\\n            if time >= startTime and time <= endTime:\\n                time -= startTime\\n                res[time // chunk] += 1\\n        \\n        return res\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts:\\n    \"\"\"solved using a dict\"\"\"\\n\\n    def __init__(self):\\n        self.dic = defaultdict(lambda: [])  # defaultdict(list)\\n\\n    def recordTweet(self, hash_tag: str, time: int) -> None:\\n        self.dic[hash_tag].append(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, hash_tag: str, startTime: int, endTime: int) -> List[int]:\\n        \"\"\"\\n        freq: like choice field in db (\\'minute\\', \\'hour\\', \\'day\\')\\n        \"\"\"\\n        print(\"....\")\\n        print(freq, startTime, endTime)\\n        chunk = 60\\n        if freq == \"hour\":\\n            chunk = 3600\\n        elif freq == \"day\":\\n            chunk = 86400\\n    \\n        num_of_chunk = math.ceil((endTime - startTime) / chunk)\\n\\n        # as we are ceil our num_of_chunk is round-off so, for exact num_of_chunk\\n        if (endTime - startTime) % chunk == 0:\\n            num_of_chunk += 1\\n        \\n        res = [0] * num_of_chunk\\n        timeLst = self.dic[hash_tag]\\n        \\n        for time in timeLst:\\n            if time >= startTime and time <= endTime:\\n                time -= startTime\\n                res[time // chunk] += 1\\n        \\n        return res\\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498204,
                "title": "c-easy-solution",
                "content": "```\\nclass TweetCounts {\\n    unordered_map<string,multiset<int>>m;\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int start, int end) {\\n        int count =freq==\"minute\"?60:freq==\"hour\"?3600:86400;\\n        int prev=0;\\n        vector<int>ans;\\n        while(true){\\n            int val=0;\\n            for(auto it=m[tweetName].lower_bound(min(end,start));it!=m[tweetName].upper_bound(min(end,start+count-1));it++){\\n                val++;\\n            }\\n            ans.push_back(val);\\n            prev=val;\\n            start+=count;\\n            if(start>end){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass TweetCounts {\\n    unordered_map<string,multiset<int>>m;\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        m[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int start, int end) {\\n        int count =freq==\"minute\"?60:freq==\"hour\"?3600:86400;\\n        int prev=0;\\n        vector<int>ans;\\n        while(true){\\n            int val=0;\\n            for(auto it=m[tweetName].lower_bound(min(end,start));it!=m[tweetName].upper_bound(min(end,start+count-1));it++){\\n                val++;\\n            }\\n            ans.push_back(val);\\n            prev=val;\\n            start+=count;\\n            if(start>end){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469249,
                "title": "1348-tweet-counts-per-frequency",
                "content": "void recordTweet(string tweetName, int time) {\\n        tweetdb[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int add_factor = 0;\\n        vector<int> ans;\\n        if(freq.compare(\"minute\") == 0)\\n        {\\n            add_factor = 60 -1 ;\\n        }\\n        if(freq.compare(\"hour\") == 0)\\n        {\\n            add_factor = (60*60) - 1;\\n        }\\n        if(freq.compare(\"day\")==0)\\n        {\\n            add_factor = (24*60*60) - 1;\\n        }\\n        \\n        if(tweetdb.find(tweetName) == tweetdb.end())\\n        {\\n            cout<<\" did not find the tweet \"<<endl;\\n            return ans;\\n        }\\n        \\n       auto tweets = tweetdb[tweetName];\\n        vector<int> tweet_frq;\\n        for(auto it : tweets)\\n        {\\n            tweet_frq.push_back(it);\\n        }\\n        int temp_end = 0;\\n        int temp_start = startTime;\\n   \\n        while(temp_end < endTime )\\n        {\\n            auto it =  lower_bound(tweet_frq.begin(),tweet_frq.end(),temp_start);\\n      \\n            int low = it - tweet_frq.begin();\\n            temp_end = temp_start + add_factor;\\n            int temp_dat =  temp_end < endTime ? temp_end: endTime;//min(temp_end,endTime);\\n            auto it2 = lower_bound(tweet_frq.begin(),tweet_frq.end(),temp_dat) ;\\n            int high ;\\n            if(it2!= tweet_frq.end() && *it2 == temp_dat)\\n            {\\n                high = it2 - tweet_frq.begin();\\n            }\\n            else\\n            {\\n                high = it2 - tweet_frq.begin();\\n                high = high-1;\\n            }\\n            ans.push_back(((high - low) + 1));\\n            temp_start = temp_end + 1;\\n        }\\n\\n        return ans;\\n    }",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "void recordTweet(string tweetName, int time) {\\n        tweetdb[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int add_factor = 0;\\n        vector<int> ans;\\n        if(freq.compare(\"minute\") == 0)\\n        {\\n            add_factor = 60 -1 ;\\n        }\\n        if(freq.compare(\"hour\") == 0)\\n        {\\n            add_factor = (60*60) - 1;\\n        }\\n        if(freq.compare(\"day\")==0)\\n        {\\n            add_factor = (24*60*60) - 1;\\n        }\\n        \\n        if(tweetdb.find(tweetName) == tweetdb.end())\\n        {\\n            cout<<\" did not find the tweet \"<<endl;\\n            return ans;\\n        }\\n        \\n       auto tweets = tweetdb[tweetName];\\n        vector<int> tweet_frq;\\n        for(auto it : tweets)\\n        {\\n            tweet_frq.push_back(it);\\n        }\\n        int temp_end = 0;\\n        int temp_start = startTime;\\n   \\n        while(temp_end < endTime )\\n        {\\n            auto it =  lower_bound(tweet_frq.begin(),tweet_frq.end(),temp_start);\\n      \\n            int low = it - tweet_frq.begin();\\n            temp_end = temp_start + add_factor;\\n            int temp_dat =  temp_end < endTime ? temp_end: endTime;//min(temp_end,endTime);\\n            auto it2 = lower_bound(tweet_frq.begin(),tweet_frq.end(),temp_dat) ;\\n            int high ;\\n            if(it2!= tweet_frq.end() && *it2 == temp_dat)\\n            {\\n                high = it2 - tweet_frq.begin();\\n            }\\n            else\\n            {\\n                high = it2 - tweet_frq.begin();\\n                high = high-1;\\n            }\\n            ans.push_back(((high - low) + 1));\\n            temp_start = temp_end + 1;\\n        }\\n\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2433275,
                "title": "simple-code-with-explanation-comments",
                "content": "```\\nclass TweetCounts {\\n\\n    //Map of tweetName and list of timing when that tweet recorded over time series.\\n    Map<String, List<Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    // Simply add time to the value of the tweetName.\\n    public void recordTweet(String tweetName, int time) {\\n        map.computeIfAbsent(tweetName, list -> new ArrayList<>()).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //Get list of times when particular tweet recorded.\\n        List<Integer> tweetsTimes = map.get(tweetName);\\n        \\n        int windownSize = getWindownSize(freq);\\n        int size = (endTime-startTime)/windownSize;\\n        \\n        int[] timeIntervals = new int[size+1];\\n        \\n        for(int tweetsTime: tweetsTimes){\\n            //If and only if tweetTiem is valid for the given request context\\n            if(tweetsTime>=startTime && tweetsTime<=endTime){\\n                timeIntervals[(tweetsTime-startTime)/windownSize]++; \\n            }\\n        }\\n        for(int timeInterval: timeIntervals){\\n            result.add(timeInterval);\\n        }\\n        return result;\\n    }\\n    \\n    //Get the conversion to number.\\n    private int getWindownSize(String freq){\\n        if(\"minute\".equals(freq)){\\n            return 60;\\n        }else if(\"hour\".equals(freq)){\\n            return 60*60;\\n        }else{\\n            return 60*60*24;\\n        }\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n\\n    //Map of tweetName and list of timing when that tweet recorded over time series.\\n    Map<String, List<Integer>> map;\\n    \\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    // Simply add time to the value of the tweetName.\\n    public void recordTweet(String tweetName, int time) {\\n        map.computeIfAbsent(tweetName, list -> new ArrayList<>()).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> result = new ArrayList<>();\\n        \\n        //Get list of times when particular tweet recorded.\\n        List<Integer> tweetsTimes = map.get(tweetName);\\n        \\n        int windownSize = getWindownSize(freq);\\n        int size = (endTime-startTime)/windownSize;\\n        \\n        int[] timeIntervals = new int[size+1];\\n        \\n        for(int tweetsTime: tweetsTimes){\\n            //If and only if tweetTiem is valid for the given request context\\n            if(tweetsTime>=startTime && tweetsTime<=endTime){\\n                timeIntervals[(tweetsTime-startTime)/windownSize]++; \\n            }\\n        }\\n        for(int timeInterval: timeIntervals){\\n            result.add(timeInterval);\\n        }\\n        return result;\\n    }\\n    \\n    //Get the conversion to number.\\n    private int getWindownSize(String freq){\\n        if(\"minute\".equals(freq)){\\n            return 60;\\n        }else if(\"hour\".equals(freq)){\\n            return 60*60;\\n        }else{\\n            return 60*60*24;\\n        }\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266734,
                "title": "binarysearch-o-n-log-n-where-n-search-tweet-timestamps-required-to-sort",
                "content": "The optimal solution is O(n) which is based on carefully dividing the subset based on intervals.\\nThis is just an alternate, less optimal but cleaner approach.\\n\\nthe n*log(n) comes from sorting the list of timestamps of the given tweet. Required to perform the binary search.\\n\\nUse map to store the timestamps list of a tweet.\\nSort the occurences of the tweet to be searched.\\n\\nUse binary search based on the interval (interval is defined by Freq enum)\\n```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.computeIfAbsent(tweetName, v->new ArrayList<>()).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        if(map.containsKey(tweetName)) {\\n            Collections.sort(map.get(tweetName));\\n            while(startTime<=endTime) {\\n                int interval = Freq.valueOf(freq).getVal();\\n                int end = Math.min(startTime+interval-1, endTime); // need this to handle the last interval\\n                res.add(getFreq(map.get(tweetName), startTime, end));\\n                startTime=end+1; // ex: for minute, the interval is 60 so our end is 59. The next startTime is end+1\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n    public int getFreq(List<Integer> list, int start, int end) {\\n        int st = Collections.binarySearch(list, start);\\n        if(st<0) {\\n            st = (st+1)*-1; // our exact start time might not be in the list, to get the 1st timestamp greater than start\\n        }\\n        int en = Collections.binarySearch(list, end);\\n        if(en<0) {\\n            en = (en+2)*-1;  // our exact end time might not be in the list, to get the last timestamp just smaller than end\\n        }\\n        \\n        return en-st+1; // the freq count\\n    }\\n}\\n\\n enum Freq {\\n    minute(60), hour(3600), day(86400);\\n    Map<Freq, Integer> map = new HashMap<>();\\n    Freq(int val) {\\n        map.put(this, val);\\n    }\\n     \\n    public  int getVal() {\\n         return map.get(this);\\n     }\\n     \\n     \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.computeIfAbsent(tweetName, v->new ArrayList<>()).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        List<Integer> res = new ArrayList<>();\\n        if(map.containsKey(tweetName)) {\\n            Collections.sort(map.get(tweetName));\\n            while(startTime<=endTime) {\\n                int interval = Freq.valueOf(freq).getVal();\\n                int end = Math.min(startTime+interval-1, endTime); // need this to handle the last interval\\n                res.add(getFreq(map.get(tweetName), startTime, end));\\n                startTime=end+1; // ex: for minute, the interval is 60 so our end is 59. The next startTime is end+1\\n            }   \\n        }\\n        return res;\\n    }\\n    \\n    public int getFreq(List<Integer> list, int start, int end) {\\n        int st = Collections.binarySearch(list, start);\\n        if(st<0) {\\n            st = (st+1)*-1; // our exact start time might not be in the list, to get the 1st timestamp greater than start\\n        }\\n        int en = Collections.binarySearch(list, end);\\n        if(en<0) {\\n            en = (en+2)*-1;  // our exact end time might not be in the list, to get the last timestamp just smaller than end\\n        }\\n        \\n        return en-st+1; // the freq count\\n    }\\n}\\n\\n enum Freq {\\n    minute(60), hour(3600), day(86400);\\n    Map<Freq, Integer> map = new HashMap<>();\\n    Freq(int val) {\\n        map.put(this, val);\\n    }\\n     \\n    public  int getVal() {\\n         return map.get(this);\\n     }\\n     \\n     \\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262442,
                "title": "simple-python-solution-using-bisect-clean-code",
                "content": "```\\nimport bisect\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if not tweetName in self.tweets:\\n            self.tweets[tweetName] = []\\n        index = bisect.bisect_left(self.tweets[tweetName], time)\\n        self.tweets[tweetName].insert(index, time)\\n        \\n    \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        def find(step):\\n            nonlocal tweet\\n            result = []\\n            for i in range(startTime, endTime+1, step):\\n                result.append(bisect.bisect_right(tweet, min(endTime, i + step - 1)) - bisect.bisect_left(tweet, i))\\n            return result\\n                \\n                \\n        tweet = self.tweets[tweetName]\\n        if freq == \"minute\":\\n            return find(60)\\n        elif freq == \"hour\":\\n            return find(3600)\\n        else:\\n            return find(86400)",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nimport bisect\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets = {}\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if not tweetName in self.tweets:\\n            self.tweets[tweetName] = []\\n        index = bisect.bisect_left(self.tweets[tweetName], time)\\n        self.tweets[tweetName].insert(index, time)\\n        \\n    \\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        def find(step):\\n            nonlocal tweet\\n            result = []\\n            for i in range(startTime, endTime+1, step):\\n                result.append(bisect.bisect_right(tweet, min(endTime, i + step - 1)) - bisect.bisect_left(tweet, i))\\n            return result\\n                \\n                \\n        tweet = self.tweets[tweetName]\\n        if freq == \"minute\":\\n            return find(60)\\n        elif freq == \"hour\":\\n            return find(3600)\\n        else:\\n            return find(86400)",
                "codeTag": "Java"
            },
            {
                "id": 2224469,
                "title": "faster-than-95-java-binary-search-tree-based-search-timecomplexity-o-logn-ressize",
                "content": "```\\nclass TweetCounts {\\n\\n    private static Map<String,Integer> freqMap=new HashMap<>();\\n    static{\\n        freqMap.put(\"minute\",60);\\n        freqMap.put(\"hour\",3600);\\n        freqMap.put(\"day\",86400);\\n    }\\n    Map<String, BinaryTree> tweetMap;\\n    \\n    public TweetCounts() {\\n        tweetMap=new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!tweetMap.containsKey(tweetName)){\\n            tweetMap.put(tweetName, new BinaryTree());\\n        }\\n        tweetMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if(!tweetMap.containsKey(tweetName)){\\n            return Collections.EMPTY_LIST;\\n        }\\n        \\n        BinaryTree tree=tweetMap.get(tweetName);\\n        int intervSize=freqMap.get(freq);\\n        int maxCount=((endTime-startTime)/intervSize)+1;\\n        List<Integer> res=new ArrayList<>(maxCount);\\n        \\n        int currEndTime=Math.min(endTime,startTime+intervSize-1);\\n        \\n        //similar to prefix sum, get count until startTime and until endTime, totalCount=endTimeCount-startTimeCount\\n        //binary search in tree for the count\\n        while(maxCount>0){\\n            int pre = tree.search(startTime-1); //startTime-1 for 1-60 (get count until 0, since 1 needs to be included)\\n            int total = tree.search(currEndTime); //till endTime\\n            res.add(total-pre);\\n            startTime=currEndTime+1;\\n            currEndTime=Math.min(endTime,currEndTime+intervSize);\\n            maxCount--;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //maintain leftOrEqualCount (left and selfcount) for each node\\n    private static class BinaryTree{\\n        Node orig;\\n        \\n        public void add(int time){\\n            orig=add(orig,time);\\n        }\\n        \\n        private int search(int val){\\n            return search(orig,val);\\n        }\\n        \\n        private int search(Node root, int val){\\n            if(root==null){\\n                return 0;\\n            }else if(root.val==val){\\n                return root.leftOrEqualCount;\\n            }else if(root.val<val){\\n                return root.leftOrEqualCount+search(root.right,val);\\n            }else{\\n                return search(root.left,val);\\n            }\\n                \\n        }\\n\\t\\t\\n        private Node add(Node root, int time){\\n            if(root==null){\\n                return new Node(time);\\n            }\\n            if(root.val==time){\\n                root.leftOrEqualCount++;\\n            }else if(root.val>time){\\n                root.leftOrEqualCount++;\\n                root.left=add(root.left,time);\\n            }else{\\n                root.right=add(root.right,time);\\n            }\\n            return root;\\n        }\\n    }\\n\\t\\n    private static class Node{\\n        Node left;\\n        Node right;\\n        int val;\\n        int leftOrEqualCount;\\n        \\n        Node(int val){\\n            this.val=val;\\n            this.leftOrEqualCount=1;\\n        }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n\\n    private static Map<String,Integer> freqMap=new HashMap<>();\\n    static{\\n        freqMap.put(\"minute\",60);\\n        freqMap.put(\"hour\",3600);\\n        freqMap.put(\"day\",86400);\\n    }\\n    Map<String, BinaryTree> tweetMap;\\n    \\n    public TweetCounts() {\\n        tweetMap=new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        if(!tweetMap.containsKey(tweetName)){\\n            tweetMap.put(tweetName, new BinaryTree());\\n        }\\n        tweetMap.get(tweetName).add(time);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if(!tweetMap.containsKey(tweetName)){\\n            return Collections.EMPTY_LIST;\\n        }\\n        \\n        BinaryTree tree=tweetMap.get(tweetName);\\n        int intervSize=freqMap.get(freq);\\n        int maxCount=((endTime-startTime)/intervSize)+1;\\n        List<Integer> res=new ArrayList<>(maxCount);\\n        \\n        int currEndTime=Math.min(endTime,startTime+intervSize-1);\\n        \\n        //similar to prefix sum, get count until startTime and until endTime, totalCount=endTimeCount-startTimeCount\\n        //binary search in tree for the count\\n        while(maxCount>0){\\n            int pre = tree.search(startTime-1); //startTime-1 for 1-60 (get count until 0, since 1 needs to be included)\\n            int total = tree.search(currEndTime); //till endTime\\n            res.add(total-pre);\\n            startTime=currEndTime+1;\\n            currEndTime=Math.min(endTime,currEndTime+intervSize);\\n            maxCount--;\\n        }\\n        return res;\\n    }\\n    \\n    \\n    //maintain leftOrEqualCount (left and selfcount) for each node\\n    private static class BinaryTree{\\n        Node orig;\\n        \\n        public void add(int time){\\n            orig=add(orig,time);\\n        }\\n        \\n        private int search(int val){\\n            return search(orig,val);\\n        }\\n        \\n        private int search(Node root, int val){\\n            if(root==null){\\n                return 0;\\n            }else if(root.val==val){\\n                return root.leftOrEqualCount;\\n            }else if(root.val<val){\\n                return root.leftOrEqualCount+search(root.right,val);\\n            }else{\\n                return search(root.left,val);\\n            }\\n                \\n        }\\n\\t\\t\\n        private Node add(Node root, int time){\\n            if(root==null){\\n                return new Node(time);\\n            }\\n            if(root.val==time){\\n                root.leftOrEqualCount++;\\n            }else if(root.val>time){\\n                root.leftOrEqualCount++;\\n                root.left=add(root.left,time);\\n            }else{\\n                root.right=add(root.right,time);\\n            }\\n            return root;\\n        }\\n    }\\n\\t\\n    private static class Node{\\n        Node left;\\n        Node right;\\n        int val;\\n        int leftOrEqualCount;\\n        \\n        Node(int val){\\n            this.val=val;\\n            this.leftOrEqualCount=1;\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 2223876,
                "title": "c-segment-tree-slow-but-easy",
                "content": "```C++\\nstruct SegTree{\\n  \\n  void Update(int x) {\\n    x = x + size_;\\n    ++t_[x];\\n    while(x > 0) {\\n      t_[x / 2] = t_[x] + t_[x ^ 1]; \\n      x /= 2;\\n    }\\n  }\\n  \\n  int Query(int first, int last) {\\n    first = first + size_;\\n    last = last + size_;\\n    auto res = 0;\\n    while(first < last) {\\n      if(first & 1) {\\n        res += t_[first];\\n        ++first;\\n      }\\n      \\n      if(last & 1) {\\n        --last;\\n        res += t_[last];\\n      }\\n      \\n      first /= 2;\\n      last /= 2;\\n    }\\n    return res;\\n  }\\n  \\n  const int size_ = 1e9 + 1;\\n  std::unordered_map<int, int> t_;\\n};\\n\\ntemplate<typename Func>\\nvoid ForEachSpan(int start, int end, int stride, Func func) {\\n  for(int first = start, last = first + stride; first < end; first += stride, last += stride) {\\n    func(first, std::min(last, end));\\n  }\\n}\\n\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n      freqs_[tweetName].Update(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n      auto& segTree = freqs_[tweetName];\\n      auto res = std::vector<int>{};\\n      auto Count = [&res, &segTree](int first, int last){\\n        res.push_back(segTree.Query(first, last));\\n      };\\n      if(freq == \"minute\") {\\n        ForEachSpan(startTime, endTime + 1, 60, Count);\\n      } else if(freq == \"hour\") {\\n        ForEachSpan(startTime, endTime + 1, 3600, Count);\\n      } else if(freq == \"day\") {\\n        ForEachSpan(startTime, endTime + 1, 86400, Count);\\n      } else {\\n        assert(false);\\n      }\\n      return res;\\n    }\\nprivate:\\n  std::unordered_map<std::string, SegTree> freqs_{};\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nstruct SegTree{\\n  \\n  void Update(int x) {\\n    x = x + size_;\\n    ++t_[x];\\n    while(x > 0) {\\n      t_[x / 2] = t_[x] + t_[x ^ 1]; \\n      x /= 2;\\n    }\\n  }\\n  \\n  int Query(int first, int last) {\\n    first = first + size_;\\n    last = last + size_;\\n    auto res = 0;\\n    while(first < last) {\\n      if(first & 1) {\\n        res += t_[first];\\n        ++first;\\n      }\\n      \\n      if(last & 1) {\\n        --last;\\n        res += t_[last];\\n      }\\n      \\n      first /= 2;\\n      last /= 2;\\n    }\\n    return res;\\n  }\\n  \\n  const int size_ = 1e9 + 1;\\n  std::unordered_map<int, int> t_;\\n};\\n\\ntemplate<typename Func>\\nvoid ForEachSpan(int start, int end, int stride, Func func) {\\n  for(int first = start, last = first + stride; first < end; first += stride, last += stride) {\\n    func(first, std::min(last, end));\\n  }\\n}\\n\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n      freqs_[tweetName].Update(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n      auto& segTree = freqs_[tweetName];\\n      auto res = std::vector<int>{};\\n      auto Count = [&res, &segTree](int first, int last){\\n        res.push_back(segTree.Query(first, last));\\n      };\\n      if(freq == \"minute\") {\\n        ForEachSpan(startTime, endTime + 1, 60, Count);\\n      } else if(freq == \"hour\") {\\n        ForEachSpan(startTime, endTime + 1, 3600, Count);\\n      } else if(freq == \"day\") {\\n        ForEachSpan(startTime, endTime + 1, 86400, Count);\\n      } else {\\n        assert(false);\\n      }\\n      return res;\\n    }\\nprivate:\\n  std::unordered_map<std::string, SegTree> freqs_{};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212108,
                "title": "java-treemap-solution",
                "content": "Store a Map<String, TreeMap<Integer, Integer>> that represents the frequency map for each tweetName, i.e. for each tweetName stores a map of (timestamp -> frequency)\\n\\n```\\nMap<String, TreeMap<Integer, Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> freq = map.get(tweetName);\\n        freq.put(time, freq.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if (!map.containsKey(tweetName)) return null;\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400;\\n        int size = ((endTime - startTime) / interval) + 1;\\n        int[] result = new int[size];\\n        \\n        TreeMap<Integer, Integer> freqMap = map.get(tweetName);\\n        for(int time : freqMap.keySet()) {\\n            if(startTime <= time && time <= endTime){\\n                int idx = (time - startTime) / interval;\\n                result[idx] = result[idx] + freqMap.get(time);\\n                \\n            }\\n        }\\n        return Arrays.stream(result).boxed().collect(Collectors.toList());\\n    }\\n\\t",
                "solutionTags": [],
                "code": "Store a Map<String, TreeMap<Integer, Integer>> that represents the frequency map for each tweetName, i.e. for each tweetName stores a map of (timestamp -> frequency)\\n\\n```\\nMap<String, TreeMap<Integer, Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        map.putIfAbsent(tweetName, new TreeMap<>());\\n        TreeMap<Integer, Integer> freq = map.get(tweetName);\\n        freq.put(time, freq.getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        if (!map.containsKey(tweetName)) return null;\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400;\\n        int size = ((endTime - startTime) / interval) + 1;\\n        int[] result = new int[size];\\n        \\n        TreeMap<Integer, Integer> freqMap = map.get(tweetName);\\n        for(int time : freqMap.keySet()) {\\n            if(startTime <= time && time <= endTime){\\n                int idx = (time - startTime) / interval;\\n                result[idx] = result[idx] + freqMap.get(time);\\n                \\n            }\\n        }\\n        return Arrays.stream(result).boxed().collect(Collectors.toList());\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2136318,
                "title": "garbage-question",
                "content": "`The question is tooooooooooo vague!!!!!`",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2113727,
                "title": "map-solution",
                "content": "```\\nclass TweetCounts {\\npublic:\\n    \\n    unordered_map<string,vector<int>> m;\\n    \\n    TweetCounts(){\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time){\\n        \\n        m[tweetName].push_back(time);\\n        \\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        \\n        int k;\\n        if(freq==\"minute\") k=60;\\n        else if(freq==\"hour\") k=3600;\\n        else k=86400;\\n        \\n        int duration=endTime-startTime;\\n        vector<int> res(ceil((duration+1)/(k*1.0)),0);\\n        \\n        for(auto x:m[tweetName]){\\n            if(x>=startTime&&x<=endTime){\\n                res[ceil((x-startTime+1)/(k*1.0))-1]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    \\n    unordered_map<string,vector<int>> m;\\n    \\n    TweetCounts(){\\n        \\n    }\\n    \\n    void recordTweet(string tweetName, int time){\\n        \\n        m[tweetName].push_back(time);\\n        \\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        \\n        int k;\\n        if(freq==\"minute\") k=60;\\n        else if(freq==\"hour\") k=3600;\\n        else k=86400;\\n        \\n        int duration=endTime-startTime;\\n        vector<int> res(ceil((duration+1)/(k*1.0)),0);\\n        \\n        for(auto x:m[tweetName]){\\n            if(x>=startTime&&x<=endTime){\\n                res[ceil((x-startTime+1)/(k*1.0))-1]++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2092344,
                "title": "c-multiset-lower-bound-upper-bound-80ms",
                "content": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time)  {  tweets[tweetName].insert(time);}\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) \\n    {\\n        int period = (freq==\"hour\")?3600: ( (freq==\"day\")?86400:60);\\n        auto& times=tweets[tweetName];\\n        \\n        auto fStart = times.lower_bound(startTime);\\n        auto fEnd   = times.upper_bound(endTime); \\n        \\n        vector<int> periodCount((endTime-startTime)/period+1,0);\\n        if(fStart!=times.end())\\n        {\\n            for(auto f=fStart;;++f) {\\n                int seconds = *f-startTime;\\n                if(f==fEnd || seconds/period==periodCount.size()) break;                \\n                periodCount[seconds/period]++;\\n            }\\n        }\\n        return periodCount;\\n    }\\n    \\nprivate:\\n    unordered_map<string,multiset<int>> tweets;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\npublic:\\n    TweetCounts() {}\\n    \\n    void recordTweet(string tweetName, int time)  {  tweets[tweetName].insert(time);}\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) \\n    {\\n        int period = (freq==\"hour\")?3600: ( (freq==\"day\")?86400:60);\\n        auto& times=tweets[tweetName];\\n        \\n        auto fStart = times.lower_bound(startTime);\\n        auto fEnd   = times.upper_bound(endTime); \\n        \\n        vector<int> periodCount((endTime-startTime)/period+1,0);\\n        if(fStart!=times.end())\\n        {\\n            for(auto f=fStart;;++f) {\\n                int seconds = *f-startTime;\\n                if(f==fEnd || seconds/period==periodCount.size()) break;                \\n                periodCount[seconds/period]++;\\n            }\\n        }\\n        return periodCount;\\n    }\\n    \\nprivate:\\n    unordered_map<string,multiset<int>> tweets;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086904,
                "title": "c-ordered-multi-set-pbds",
                "content": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n\\n//less_equal to use it as a multiset\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, pbds> tweet;\\n    TweetCounts() {\\n        tweet.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweet[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval;\\n        if(freq == \"minute\") interval = 60;\\n        else if(freq == \"hour\") interval = 3600;\\n        else interval = 86400;\\n        \\n        vector<int> ans;\\n\\t\\t\\n        for(int i=startTime; i<=endTime; i+=interval)\\n        {\\n            int start = i, end = min(endTime, i+interval-1);\\n            \\n            //[start - end] or [start - end+1)\\n            auto low = tweet[tweetName].order_of_key(start);\\n            auto high = tweet[tweetName].order_of_key(end+1);\\n            \\n            ans.push_back(high-low);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\n\\nusing namespace std;\\nusing namespace __gnu_pbds;\\n\\n//less_equal to use it as a multiset\\ntypedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\\n\\nclass TweetCounts {\\npublic:\\n    unordered_map<string, pbds> tweet;\\n    TweetCounts() {\\n        tweet.clear();\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        tweet[tweetName].insert(time);\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        int interval;\\n        if(freq == \"minute\") interval = 60;\\n        else if(freq == \"hour\") interval = 3600;\\n        else interval = 86400;\\n        \\n        vector<int> ans;\\n\\t\\t\\n        for(int i=startTime; i<=endTime; i+=interval)\\n        {\\n            int start = i, end = min(endTime, i+interval-1);\\n            \\n            //[start - end] or [start - end+1)\\n            auto low = tweet[tweetName].order_of_key(start);\\n            auto high = tweet[tweetName].order_of_key(end+1);\\n            \\n            ans.push_back(high-low);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2078473,
                "title": "c-using-vector-of-set-used-as-a-hashtable",
                "content": "```\\nclass TweetCounts {\\nprivate:\\n    vector<multiset<pair<int,string>>> tweets;\\npublic:\\n    TweetCounts() {\\n        tweets = vector<multiset<pair<int,string>>>(12000);\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        int index = time/86400;\\n        tweets[index].insert({time,tweetName});\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int interval = freq != \"day\"?((freq != \"hour\")?60:3600):86400;\\n        //cout<<\"Interval = \"<<interval<<endl;\\n        for(int i=startTime;i<=endTime;i+=interval){\\n            int l = i;\\n            int h = min(endTime,i+interval-1);\\n            //cout<<\"l,h = \"<<l<<\",\"<<h<<endl;\\n            int l_ind = l/86400;\\n            int h_ind = h/86400;\\n            int cnt = 0;\\n            //cout<<\"search between \"<<l_ind<<\" and \"<<h_ind<<\" - >\";\\n            for(int j=l_ind;j<=h_ind;j++){\\n                auto it = tweets[j].lower_bound({l,\"\"});\\n                while(it != tweets[j].end()){\\n                    if((*it).first > h) break;\\n                    if((*it).second == tweetName){\\n                        //cout<<(*it).first<<\" \"<<(*it).second<<\",\";\\n                        cnt += 1;\\n                    }\\n                    it++;\\n                }\\n            }\\n            //cout<<\" Totl = \"<<cnt<<endl;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass TweetCounts {\\nprivate:\\n    vector<multiset<pair<int,string>>> tweets;\\npublic:\\n    TweetCounts() {\\n        tweets = vector<multiset<pair<int,string>>>(12000);\\n    }\\n    \\n    void recordTweet(string tweetName, int time) {\\n        int index = time/86400;\\n        tweets[index].insert({time,tweetName});\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        vector<int> ans;\\n        int interval = freq != \"day\"?((freq != \"hour\")?60:3600):86400;\\n        //cout<<\"Interval = \"<<interval<<endl;\\n        for(int i=startTime;i<=endTime;i+=interval){\\n            int l = i;\\n            int h = min(endTime,i+interval-1);\\n            //cout<<\"l,h = \"<<l<<\",\"<<h<<endl;\\n            int l_ind = l/86400;\\n            int h_ind = h/86400;\\n            int cnt = 0;\\n            //cout<<\"search between \"<<l_ind<<\" and \"<<h_ind<<\" - >\";\\n            for(int j=l_ind;j<=h_ind;j++){\\n                auto it = tweets[j].lower_bound({l,\"\"});\\n                while(it != tweets[j].end()){\\n                    if((*it).first > h) break;\\n                    if((*it).second == tweetName){\\n                        //cout<<(*it).first<<\" \"<<(*it).second<<\",\";\\n                        cnt += 1;\\n                    }\\n                    it++;\\n                }\\n            }\\n            //cout<<\" Totl = \"<<cnt<<endl;\\n            ans.push_back(cnt);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts* obj = new TweetCounts();\\n * obj->recordTweet(tweetName,time);\\n * vector<int> param_2 = obj->getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2014490,
                "title": "scala-map-linear-scan",
                "content": "```\\nclass TweetCounts() {\\n    // You can\\'t do segment tree or Fenwick tree because range is unknown in streaming\\n    // recordTweet is O(n) time and O(n) space for n operations\\n    // getTweetCountsPerFrequency is O(n) time and O(n) space for n operations\\n    import scala.collection.{mutable => scm}\\n    val t=Map ( \"hour\"->3600, \"minute\"->60, \"day\"-> 3600*24)\\n    var store=scm.Map[String,scm.ArrayBuffer[Int]]()\\n    //note that withDefaultValue if set to Object, all defaultValue points to the same Object, big BUG\\n    //var store=scm.Map[String,scm.ArrayBuffer[Int]]().withDefaultValue(new scm.ArrayBuffer[Int]())\\n    //Scala: scala.collection.mutable.Map[Int,Array[Int]]().withDefaultValue(new Array[Int](3)) -> creates a length-3 Array as default, but this default is shared by ALL KEYS in this Map that  does not exists! Same as Python\\'s default parameter. This happens on Scala/python when the default is an Object type , if it\\'s a primitive type, then each default instance is distinct.\\n    def recordTweet(tweetName: String, time: Int) {\\n        if (store contains tweetName)  store(tweetName) += time\\n        else store(tweetName) = scm.ArrayBuffer(time)\\n    }\\n\\n    def getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List[Int] = {\\n        var bucket= Array.fill[Int](Math.ceil((endTime-startTime+1)*1.0/t(freq)).toInt)(0)\\n        for (time <- store(tweetName)) {\\n            val target= (time-startTime)/t(freq)\\n            if ( time<=endTime && time>=startTime && target>=0 && target<bucket.length)  {\\n                    bucket(target)+=1\\n            }\\n        }\\n        return bucket.toList\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts() {\\n    // You can\\'t do segment tree or Fenwick tree because range is unknown in streaming\\n    // recordTweet is O(n) time and O(n) space for n operations\\n    // getTweetCountsPerFrequency is O(n) time and O(n) space for n operations\\n    import scala.collection.{mutable => scm}\\n    val t=Map ( \"hour\"->3600, \"minute\"->60, \"day\"-> 3600*24)\\n    var store=scm.Map[String,scm.ArrayBuffer[Int]]()\\n    //note that withDefaultValue if set to Object, all defaultValue points to the same Object, big BUG\\n    //var store=scm.Map[String,scm.ArrayBuffer[Int]]().withDefaultValue(new scm.ArrayBuffer[Int]())\\n    //Scala: scala.collection.mutable.Map[Int,Array[Int]]().withDefaultValue(new Array[Int](3)) -> creates a length-3 Array as default, but this default is shared by ALL KEYS in this Map that  does not exists! Same as Python\\'s default parameter. This happens on Scala/python when the default is an Object type , if it\\'s a primitive type, then each default instance is distinct.\\n    def recordTweet(tweetName: String, time: Int) {\\n        if (store contains tweetName)  store(tweetName) += time\\n        else store(tweetName) = scm.ArrayBuffer(time)\\n    }\\n\\n    def getTweetCountsPerFrequency(freq: String, tweetName: String, startTime: Int, endTime: Int): List[Int] = {\\n        var bucket= Array.fill[Int](Math.ceil((endTime-startTime+1)*1.0/t(freq)).toInt)(0)\\n        for (time <- store(tweetName)) {\\n            val target= (time-startTime)/t(freq)\\n            if ( time<=endTime && time>=startTime && target>=0 && target<bucket.length)  {\\n                    bucket(target)+=1\\n            }\\n        }\\n        return bucket.toList\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012147,
                "title": "python-clean-solution-using-sorted-list-and-bisect-o-logn",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets_to_list = {}\\n        self.intervals = {\\'minute\\':60, \\'hour\\':3600, \\'day\\':86400}\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.tweets_to_list:\\n            self.tweets_to_list[tweetName] = SortedList()\\n        \\n        self.tweets_to_list[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        sorted_list = self.tweets_to_list[tweetName]\\n        \\n        interval = self.intervals[freq]\\n        \\n        curStart = startTime\\n        ans = []\\n        while curStart <= endTime:\\n            curEnd = min(endTime,curStart+interval-1)\\n            \\n            first = sorted_list.bisect_left(curStart)\\n            last = sorted_list.bisect_right(curEnd)\\n            \\n            ans.append(last-first)\\n            \\n            curStart = curEnd+1\\n        return ans",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.tweets_to_list = {}\\n        self.intervals = {\\'minute\\':60, \\'hour\\':3600, \\'day\\':86400}\\n        \\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        if tweetName not in self.tweets_to_list:\\n            self.tweets_to_list[tweetName] = SortedList()\\n        \\n        self.tweets_to_list[tweetName].add(time)\\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        sorted_list = self.tweets_to_list[tweetName]\\n        \\n        interval = self.intervals[freq]\\n        \\n        curStart = startTime\\n        ans = []\\n        while curStart <= endTime:\\n            curEnd = min(endTime,curStart+interval-1)\\n            \\n            first = sorted_list.bisect_left(curStart)\\n            last = sorted_list.bisect_right(curEnd)\\n            \\n            ans.append(last-first)\\n            \\n            curStart = curEnd+1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1984898,
                "title": "go-solution-hashmap",
                "content": "```\\ntype TweetCounts struct {\\n    frequency map[string][]int\\n}\\n\\nfunc Constructor() TweetCounts {\\n    frequency := map[string][]int{}\\n    return TweetCounts{frequency}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    _, k := this.frequency[tweetName]\\n    if !k {\\n        this.frequency[tweetName] = []int{time}\\n    } else {\\n        this.frequency[tweetName] = append(this.frequency[tweetName], time)\\n    }\\n}\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\tvar increment int\\n\\tswitch freq {\\n\\tcase \"minute\":\\n\\t\\tincrement = 60\\n\\t\\n\\tcase \"hour\":\\n\\t\\tincrement = 3600\\n\\t\\n\\tcase \"day\":\\n\\t\\tincrement = 86400\\n\\t}\\n\\n\\tcounts := make([]int, (endTime - startTime)/increment + 1)\\n\\tfor _, time := range this.frequency[tweetName] {\\n\\t\\tif time < startTime || time > endTime {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tindex := (time - startTime) / increment\\n\\t\\tcounts[index]++\\n\\t}\\n\\n\\treturn counts\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype TweetCounts struct {\\n    frequency map[string][]int\\n}\\n\\nfunc Constructor() TweetCounts {\\n    frequency := map[string][]int{}\\n    return TweetCounts{frequency}\\n}\\n\\nfunc (this *TweetCounts) RecordTweet(tweetName string, time int)  {\\n    _, k := this.frequency[tweetName]\\n    if !k {\\n        this.frequency[tweetName] = []int{time}\\n    } else {\\n        this.frequency[tweetName] = append(this.frequency[tweetName], time)\\n    }\\n}\\n\\nfunc (this *TweetCounts) GetTweetCountsPerFrequency(freq string, tweetName string, startTime int, endTime int) []int {\\n\\tvar increment int\\n\\tswitch freq {\\n\\tcase \"minute\":\\n\\t\\tincrement = 60\\n\\t\\n\\tcase \"hour\":\\n\\t\\tincrement = 3600\\n\\t\\n\\tcase \"day\":\\n\\t\\tincrement = 86400\\n\\t}\\n\\n\\tcounts := make([]int, (endTime - startTime)/increment + 1)\\n\\tfor _, time := range this.frequency[tweetName] {\\n\\t\\tif time < startTime || time > endTime {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tindex := (time - startTime) / increment\\n\\t\\tcounts[index]++\\n\\t}\\n\\n\\treturn counts\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.RecordTweet(tweetName,time);\\n * param_2 := obj.GetTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1946995,
                "title": "python-straightforwad-o-n",
                "content": "```\\nimport collections\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.record_dict = collections.defaultdict(list)\\n        # self.max_time = 0\\n        # self.min_time = 0\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.record_dict[tweetName].append(time)\\n        # self.max_time = max(self.max_time, time)\\n        # self.min_time = min(self.min_time, time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        period_mapping = {\\n            \"minute\": 60,\\n            \"hour\": 3600,\\n            \"day\": 86400\\n        }\\n        period = period_mapping[freq]\\n        chunks = (endTime - startTime) // period + 1\\n        res = [0] * chunks\\n        for time in self.record_dict[tweetName]:\\n            if startTime <= time <= endTime:\\n                res[(time-startTime)//period] += 1\\n        return res\\n        \\n        \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        self.record_dict = collections.defaultdict(list)\\n        # self.max_time = 0\\n        # self.min_time = 0\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        self.record_dict[tweetName].append(time)\\n        # self.max_time = max(self.max_time, time)\\n        # self.min_time = min(self.min_time, time)\\n        \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        period_mapping = {\\n            \"minute\": 60,\\n            \"hour\": 3600,\\n            \"day\": 86400\\n        }\\n        period = period_mapping[freq]\\n        chunks = (endTime - startTime) // period + 1\\n        res = [0] * chunks\\n        for time in self.record_dict[tweetName]:\\n            if startTime <= time <= endTime:\\n                res[(time-startTime)//period] += 1\\n        return res\\n        \\n        \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946496,
                "title": "c-set-iterative-solution",
                "content": "Runtime: 93 ms, faster than 88.82% of C++ online submissions for Tweet Counts Per Frequency.\\nMemory Usage: 41.6 MB, less than 31.06% of C++ online submissions for Tweet Counts Per Frequency.\\n\\n\\n```\\nStore tweet times in the Set of Hash Table for each tweet name.\\nFind the start position of startTime in Set using binary search \\nand then iterate as long as time <= endTime or reach the end of Set.\\n```\\n\\n```\\nclass TweetCounts {\\npublic:\\n    \\n    // store tweet times in Set for each tweetName\\n    unordered_map<string,set<pair<int,int>>>data;\\n    int iter;\\n    \\n    TweetCounts() {\\n        iter = 0;    // handle duplicate value with pair in Set\\n    }\\n    \\n    // add time in to the Set of tweetName from HashTable\\n    void recordTweet(string tweetName, int time) {\\n        data[tweetName].insert({time,iter++});\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        \\n        // time chunk size for minute, hour and second\\n        int chunk = freq[0]==\\'m\\' ? 60 : (freq[0]==\\'h\\' ? 3600 : 24*3600);\\n        \\n        // find the first position of startTime and Set end\\n        set<pair<int,int>>::iterator start = data[tweetName].lower_bound({startTime,0});\\n        set<pair<int,int>>::iterator end = data[tweetName].end();\\n        \\n        // set all possible result values with 0  => number of chunk = range / chunk size  \\n        vector<int>res;\\n        for(int i=0;i<=(endTime - startTime)/chunk;i++)res.push_back(0);\\n        \\n        // loop through start to end or time<=endTime and count the frequency\\n        while(start!=end && (*start).first<=endTime)\\n        {\\n            res[((*start).first - startTime)/chunk]++;\\n            start++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\nStore tweet times in the Set of Hash Table for each tweet name.\\nFind the start position of startTime in Set using binary search \\nand then iterate as long as time <= endTime or reach the end of Set.\\n```\n```\\nclass TweetCounts {\\npublic:\\n    \\n    // store tweet times in Set for each tweetName\\n    unordered_map<string,set<pair<int,int>>>data;\\n    int iter;\\n    \\n    TweetCounts() {\\n        iter = 0;    // handle duplicate value with pair in Set\\n    }\\n    \\n    // add time in to the Set of tweetName from HashTable\\n    void recordTweet(string tweetName, int time) {\\n        data[tweetName].insert({time,iter++});\\n    }\\n    \\n    vector<int> getTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        \\n        // time chunk size for minute, hour and second\\n        int chunk = freq[0]==\\'m\\' ? 60 : (freq[0]==\\'h\\' ? 3600 : 24*3600);\\n        \\n        // find the first position of startTime and Set end\\n        set<pair<int,int>>::iterator start = data[tweetName].lower_bound({startTime,0});\\n        set<pair<int,int>>::iterator end = data[tweetName].end();\\n        \\n        // set all possible result values with 0  => number of chunk = range / chunk size  \\n        vector<int>res;\\n        for(int i=0;i<=(endTime - startTime)/chunk;i++)res.push_back(0);\\n        \\n        // loop through start to end or time<=endTime and count the frequency\\n        while(start!=end && (*start).first<=endTime)\\n        {\\n            res[((*start).first - startTime)/chunk]++;\\n            start++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1927557,
                "title": "java-treemap-solution-easy-to-understand",
                "content": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        //FILL THE MAP\\n        TreeMap<Integer, Integer> treeMap = map.getOrDefault(tweetName, new TreeMap<>());\\n        treeMap.put(time, treeMap.getOrDefault(time, 0) + 1);\\n        map.put(tweetName, treeMap);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400;\\n        int chunkSize = (endTime - startTime)/interval + 1;\\n        int[] bucket = new int[chunkSize];\\n        TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n\\t\\t//subMap filter the map and fetch only those elements which lies \\n\\t\\t//inside [startTime(inclusive) and endTime(exclusive))\\n        for(Map.Entry<Integer, Integer> entry : treeMap.subMap(startTime, endTime+1).entrySet()) {\\n            int idx = (entry.getKey() - startTime)/interval;\\n            bucket[idx] += entry.getValue();\\n        }\\n        List<Integer> list = new ArrayList();\\n        for (int num : bucket) list.add(num);\\n            return list;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String, TreeMap<Integer, Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        //FILL THE MAP\\n        TreeMap<Integer, Integer> treeMap = map.getOrDefault(tweetName, new TreeMap<>());\\n        treeMap.put(time, treeMap.getOrDefault(time, 0) + 1);\\n        map.put(tweetName, treeMap);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int interval = freq.equals(\"minute\") ? 60 : freq.equals(\"hour\") ? 3600 : 86400;\\n        int chunkSize = (endTime - startTime)/interval + 1;\\n        int[] bucket = new int[chunkSize];\\n        TreeMap<Integer, Integer> treeMap = map.get(tweetName);\\n\\t\\t//subMap filter the map and fetch only those elements which lies \\n\\t\\t//inside [startTime(inclusive) and endTime(exclusive))\\n        for(Map.Entry<Integer, Integer> entry : treeMap.subMap(startTime, endTime+1).entrySet()) {\\n            int idx = (entry.getKey() - startTime)/interval;\\n            bucket[idx] += entry.getValue();\\n        }\\n        List<Integer> list = new ArrayList();\\n        for (int num : bucket) list.add(num);\\n            return list;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898606,
                "title": "ruby-solution-low-memory-usage",
                "content": "Runtime: `474 ms`, faster than `50.00%` of Ruby online submissions for Tweet Counts Per Frequency.\\nMemory Usage: `217.8 MB`, less than `100.00%` of Ruby online submissions for Tweet Counts Per Frequency.\\n\\nThis was my ruby submission, with some added comments to help out others, breaking it down.\\nMy original was a brute force attempt but it consisted of too many loops and I ended up getting Time Limit Exceeded.\\nSo I went back and figured out that:\\n1. my initial datastructure could be optimized (from an array of hashes to a hash with arrays as values)\\n2. i don\\'t have to calculate each chunk i need and store that...I only need to use math to determine which chunk it should be.\\n\\nIn the end, I only have 1 iterator in the entire thing.\\n\\nI\\'m sure this could still be optimized, but this is using general Ruby without doing binary searches etc.\\n\\n```ruby\\nclass TweetCounts\\n    def initialize()\\n      @tweets = {}\\n\\t  \\n\\t  # frequencies are in strings, so instead of using symbols, use strings for hash\\n      @time_dict = {\\n        \\'minute\\' => 60,\\n        \\'hour\\' => 3600,\\n        \\'day\\' => 86400,\\n      }\\n    end\\n\\n    def record_tweet(tweet_name, time)\\n\\t  # ensure that we initialize the hash[key] as an array using conditional or\\n      @tweets[tweet_name] ||= []\\n      @tweets[tweet_name] << time\\n      \\n      return nil\\n    end\\n\\n    def get_tweet_counts_per_frequency(freq, tweet_name, start_time, end_time)\\n      difference = end_time - start_time\\n      \\n\\t  # this is why we needed the string version instead of symbols\\n      time_freq = @time_dict[freq]\\n      \\n      time_values = @tweets[tweet_name]\\n      \\n\\t  # this gives you the mathy version of how many chunks we can make from the start and end times\\n\\t  # eg 62 seconds would be 2 chunks: 0-59 then 60-62\\n\\t  # eg 57 seconds would be 1 chunk: 0-57\\n      total_chunks = (difference / time_freq).zero? ? 1 : difference / time_freq + 1\\n\\t  \\n\\t  # initialize the array with the number of total chunks and 0 as default values \\n      result = Array.new(total_chunks, 0)\\n\\n\\t  # iterate over the smallest array (time_values) and \\n\\t  # increment by 1 for each element in result\\n\\t  # account for edge cases\\n\\t  # account for the start time not being 0\\n\\t \\n      time_values.each do |time|\\n        next if time > end_time\\n\\t\\t\\n        chunk_number = ((time - start_time) / time_freq) + 1\\n        next if chunk_number <= 0\\n        \\n        if result[chunk_number - 1].nil?\\n          result[chunk_number - 1] = 0\\n        end\\n        result[chunk_number - 1] += 1\\n      end\\n            \\n      return [0] if result.empty?\\n        \\n      result\\n    end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nclass TweetCounts\\n    def initialize()\\n      @tweets = {}\\n\\t  \\n\\t  # frequencies are in strings, so instead of using symbols, use strings for hash\\n      @time_dict = {\\n        \\'minute\\' => 60,\\n        \\'hour\\' => 3600,\\n        \\'day\\' => 86400,\\n      }\\n    end\\n\\n    def record_tweet(tweet_name, time)\\n\\t  # ensure that we initialize the hash[key] as an array using conditional or\\n      @tweets[tweet_name] ||= []\\n      @tweets[tweet_name] << time\\n      \\n      return nil\\n    end\\n\\n    def get_tweet_counts_per_frequency(freq, tweet_name, start_time, end_time)\\n      difference = end_time - start_time\\n      \\n\\t  # this is why we needed the string version instead of symbols\\n      time_freq = @time_dict[freq]\\n      \\n      time_values = @tweets[tweet_name]\\n      \\n\\t  # this gives you the mathy version of how many chunks we can make from the start and end times\\n\\t  # eg 62 seconds would be 2 chunks: 0-59 then 60-62\\n\\t  # eg 57 seconds would be 1 chunk: 0-57\\n      total_chunks = (difference / time_freq).zero? ? 1 : difference / time_freq + 1\\n\\t  \\n\\t  # initialize the array with the number of total chunks and 0 as default values \\n      result = Array.new(total_chunks, 0)\\n\\n\\t  # iterate over the smallest array (time_values) and \\n\\t  # increment by 1 for each element in result\\n\\t  # account for edge cases\\n\\t  # account for the start time not being 0\\n\\t \\n      time_values.each do |time|\\n        next if time > end_time\\n\\t\\t\\n        chunk_number = ((time - start_time) / time_freq) + 1\\n        next if chunk_number <= 0\\n        \\n        if result[chunk_number - 1].nil?\\n          result[chunk_number - 1] = 0\\n        end\\n        result[chunk_number - 1] += 1\\n      end\\n            \\n      return [0] if result.empty?\\n        \\n      result\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1894142,
                "title": "java-treemap-buckets",
                "content": "```\\nclass TweetCounts {\\n    Map<String,TreeMap<Integer,Integer>> map=new HashMap<>();\\n    \\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeMap<Integer,Integer> tm=map.computeIfAbsent(tweetName,k->new TreeMap<>());\\n        tm.put(time,tm.getOrDefault(time,0)+1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int p=getP(freq);\\n        int[] buckets=new int[(endTime-startTime)/p+1];\\n        TreeMap<Integer,Integer> tm=map.get(tweetName);\\n        Integer key=startTime-1;\\n        while((key=tm.higherKey(key))!=null){\\n            if(key>endTime){\\n                break;\\n            }\\n            int t=(key-startTime)/p;\\n            buckets[t]+=tm.get(key);\\n        }\\n        List<Integer> list=new ArrayList();\\n        for(int n:buckets){\\n            list.add(n);\\n        }\\n        return list;\\n    }\\n    \\n    private int getP(String freq){\\n        int p=0;\\n        if(freq.equals(\"minute\")){\\n            p=60;\\n        }else if(freq.equals(\"hour\")){\\n            p=3600;\\n        }else{\\n            p=24*3600;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass TweetCounts {\\n    Map<String,TreeMap<Integer,Integer>> map=new HashMap<>();\\n    \\n    public TweetCounts() {\\n        \\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        TreeMap<Integer,Integer> tm=map.computeIfAbsent(tweetName,k->new TreeMap<>());\\n        tm.put(time,tm.getOrDefault(time,0)+1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int p=getP(freq);\\n        int[] buckets=new int[(endTime-startTime)/p+1];\\n        TreeMap<Integer,Integer> tm=map.get(tweetName);\\n        Integer key=startTime-1;\\n        while((key=tm.higherKey(key))!=null){\\n            if(key>endTime){\\n                break;\\n            }\\n            int t=(key-startTime)/p;\\n            buckets[t]+=tm.get(key);\\n        }\\n        List<Integer> list=new ArrayList();\\n        for(int n:buckets){\\n            list.add(n);\\n        }\\n        return list;\\n    }\\n    \\n    private int getP(String freq){\\n        int p=0;\\n        if(freq.equals(\"minute\")){\\n            p=60;\\n        }else if(freq.equals(\"hour\")){\\n            p=3600;\\n        }else{\\n            p=24*3600;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886530,
                "title": "java-map-and-binary-search-to-find-chuck-start-end-index",
                "content": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.get(tweetName);\\n        if (list == null){\\n            list = new ArrayList<Integer>();\\n            list.add(time);\\n            map.put(tweetName, list);\\n        } else {\\n            insertInOrder(list, time);\\n            \\n        }\\n    }\\n    \\n    void insertInOrder(List<Integer> list, int time){\\n        int start = 0, end = list.size() - 1;\\n        \\n        if (time >= list.get(end)){\\n            list.add(time);\\n            return ;\\n        }\\n        \\n        if (time < list.get(start)){\\n            list.add(0, time);\\n            return ;\\n        }\\n        \\n        // list.get(start) >= time < list.get(end)\\n        while (start < end){\\n            if (start + 1 == end){\\n                list.add(end, time);\\n                return ;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) <= time){\\n                start = middle;\\n            } else {\\n                end = middle;\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int chuckSize = 60;\\n        if (\"hour\".equals(freq) ){\\n            chuckSize = 3600;\\n        } else if (\"day\".equals(freq)){\\n            chuckSize = 86400;\\n        }\\n        \\n        List<Integer> list = map.get(tweetName);\\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        int iStart = findStartIndex(list, startTime);\\n        for (int cStart = startTime, cEnd = cStart + chuckSize - 1; cStart <= endTime; cStart += chuckSize, cEnd += chuckSize){\\n            if (cEnd > endTime){\\n                cEnd = endTime;\\n            }\\n            if (iStart == -1){\\n                result.add(0); // no element;\\n                continue;\\n            }\\n            \\n            int iEnd = findEndIndex(list, cEnd, iStart);\\n            if (iEnd == -1){\\n                // no element\\n                result.add(0);\\n                continue;\\n            }\\n            \\n            result.add(iEnd - iStart + 1);\\n            iStart = iEnd + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // find max index where list.get(index) <= endTime\\n    int findEndIndex(List<Integer> list, int endTime, int index){\\n        if (list == null || list.isEmpty()){\\n            return -1;\\n        }\\n        int start = index, end = list.size() -1;\\n        if (list.get(end) <= endTime){\\n            return end;\\n        }\\n        if (list.get(start) > endTime){\\n            return -1;\\n        }\\n        // max index in [start, end)\\n        while (start < end){\\n            if (start + 1 == end){\\n                return start;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) <= endTime){\\n                start = middle;\\n            } else {\\n                end = middle;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    // find min index where list.get(index) >= startTime\\n    int findStartIndex(List<Integer> list, int startTime){\\n        if (list == null || list.isEmpty()){\\n            return -1;\\n        }\\n        int start = 0, end = list.size() - 1;\\n        if (list.get(start) >= startTime){\\n            return start;\\n        }\\n        if (list.get(end) < startTime){\\n            return -1;\\n        }\\n        // min index in (start, end]\\n        while (start < end){\\n            if (start + 1 == end){\\n                return end;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) >= startTime){\\n                end = middle;\\n            } else {\\n                start = middle;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass TweetCounts {\\n    Map<String, List<Integer>> map;\\n    public TweetCounts() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        List<Integer> list = map.get(tweetName);\\n        if (list == null){\\n            list = new ArrayList<Integer>();\\n            list.add(time);\\n            map.put(tweetName, list);\\n        } else {\\n            insertInOrder(list, time);\\n            \\n        }\\n    }\\n    \\n    void insertInOrder(List<Integer> list, int time){\\n        int start = 0, end = list.size() - 1;\\n        \\n        if (time >= list.get(end)){\\n            list.add(time);\\n            return ;\\n        }\\n        \\n        if (time < list.get(start)){\\n            list.add(0, time);\\n            return ;\\n        }\\n        \\n        // list.get(start) >= time < list.get(end)\\n        while (start < end){\\n            if (start + 1 == end){\\n                list.add(end, time);\\n                return ;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) <= time){\\n                start = middle;\\n            } else {\\n                end = middle;\\n            }\\n        }\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, String tweetName, int startTime, int endTime) {\\n        int chuckSize = 60;\\n        if (\"hour\".equals(freq) ){\\n            chuckSize = 3600;\\n        } else if (\"day\".equals(freq)){\\n            chuckSize = 86400;\\n        }\\n        \\n        List<Integer> list = map.get(tweetName);\\n        List<Integer> result = new ArrayList<Integer>();\\n        \\n        int iStart = findStartIndex(list, startTime);\\n        for (int cStart = startTime, cEnd = cStart + chuckSize - 1; cStart <= endTime; cStart += chuckSize, cEnd += chuckSize){\\n            if (cEnd > endTime){\\n                cEnd = endTime;\\n            }\\n            if (iStart == -1){\\n                result.add(0); // no element;\\n                continue;\\n            }\\n            \\n            int iEnd = findEndIndex(list, cEnd, iStart);\\n            if (iEnd == -1){\\n                // no element\\n                result.add(0);\\n                continue;\\n            }\\n            \\n            result.add(iEnd - iStart + 1);\\n            iStart = iEnd + 1;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // find max index where list.get(index) <= endTime\\n    int findEndIndex(List<Integer> list, int endTime, int index){\\n        if (list == null || list.isEmpty()){\\n            return -1;\\n        }\\n        int start = index, end = list.size() -1;\\n        if (list.get(end) <= endTime){\\n            return end;\\n        }\\n        if (list.get(start) > endTime){\\n            return -1;\\n        }\\n        // max index in [start, end)\\n        while (start < end){\\n            if (start + 1 == end){\\n                return start;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) <= endTime){\\n                start = middle;\\n            } else {\\n                end = middle;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    // find min index where list.get(index) >= startTime\\n    int findStartIndex(List<Integer> list, int startTime){\\n        if (list == null || list.isEmpty()){\\n            return -1;\\n        }\\n        int start = 0, end = list.size() - 1;\\n        if (list.get(start) >= startTime){\\n            return start;\\n        }\\n        if (list.get(end) < startTime){\\n            return -1;\\n        }\\n        // min index in (start, end]\\n        while (start < end){\\n            if (start + 1 == end){\\n                return end;\\n            }\\n            int middle = start + (end - start)/2;\\n            if (list.get(middle) >= startTime){\\n                end = middle;\\n            } else {\\n                start = middle;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n\\n/**\\n * Your TweetCounts object will be instantiated and called as such:\\n * TweetCounts obj = new TweetCounts();\\n * obj.recordTweet(tweetName,time);\\n * List<Integer> param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875047,
                "title": "java-treemap",
                "content": "~~~java\\n\\nclass TweetCounts {\\n    // tweet name, <time, cnt>\\n    Map<String, TreeMap<Integer, Integer>> tweets;\\n    Map<String, Integer> bucketSizes;\\n\\n    public TweetCounts() {\\n        tweets = new HashMap<>();\\n        bucketSizes = new HashMap<>();\\n        bucketSizes.put(\"minute\", 60);\\n        bucketSizes.put(\"hour\", 3600);\\n        bucketSizes.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweets.computeIfAbsent(tweetName, m -> new TreeMap<>())\\n            .put(time, tweets.get(tweetName).getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, \\n                                                    String tweetName, \\n                                                    int startTime, \\n                                                    int endTime) {\\n        if (!tweets.containsKey(tweetName)) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<Integer> rst = new ArrayList<>();\\n        TreeMap<Integer, Integer> timeCnts = tweets.get(tweetName);\\n        int bucketSize = bucketSizes.get(freq);\\n        Integer time = timeCnts.ceilingKey(startTime);\\n        \\n        while (time != null && time <= endTime) {\\n            int bucketId = (time - startTime) / bucketSize;\\n            while (bucketId >= rst.size()) {\\n                rst.add(0);\\n            }\\n            rst.set(bucketId, rst.get(bucketId) + timeCnts.get(time));\\n            time = timeCnts.ceilingKey(time + 1);\\n        }\\n        \\n        int bucketNum = (endTime - startTime) / bucketSize + 1;\\n        while (rst.size() < bucketNum) {\\n            rst.add(0);\\n        }\\n        \\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "~~~java\\n\\nclass TweetCounts {\\n    // tweet name, <time, cnt>\\n    Map<String, TreeMap<Integer, Integer>> tweets;\\n    Map<String, Integer> bucketSizes;\\n\\n    public TweetCounts() {\\n        tweets = new HashMap<>();\\n        bucketSizes = new HashMap<>();\\n        bucketSizes.put(\"minute\", 60);\\n        bucketSizes.put(\"hour\", 3600);\\n        bucketSizes.put(\"day\", 86400);\\n    }\\n    \\n    public void recordTweet(String tweetName, int time) {\\n        tweets.computeIfAbsent(tweetName, m -> new TreeMap<>())\\n            .put(time, tweets.get(tweetName).getOrDefault(time, 0) + 1);\\n    }\\n    \\n    public List<Integer> getTweetCountsPerFrequency(String freq, \\n                                                    String tweetName, \\n                                                    int startTime, \\n                                                    int endTime) {\\n        if (!tweets.containsKey(tweetName)) {\\n            return new ArrayList<>();\\n        }\\n        \\n        List<Integer> rst = new ArrayList<>();\\n        TreeMap<Integer, Integer> timeCnts = tweets.get(tweetName);\\n        int bucketSize = bucketSizes.get(freq);\\n        Integer time = timeCnts.ceilingKey(startTime);\\n        \\n        while (time != null && time <= endTime) {\\n            int bucketId = (time - startTime) / bucketSize;\\n            while (bucketId >= rst.size()) {\\n                rst.add(0);\\n            }\\n            rst.set(bucketId, rst.get(bucketId) + timeCnts.get(time));\\n            time = timeCnts.ceilingKey(time + 1);\\n        }\\n        \\n        int bucketNum = (endTime - startTime) / bucketSize + 1;\\n        while (rst.size() < bucketNum) {\\n            rst.add(0);\\n        }\\n        \\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1859963,
                "title": "c-dictionary-solution-code-comments",
                "content": "Hope this helps! I found the problem a little confusing, and even reading some of the solutions was still a bit unsure. Added some comments to make things extremely clear for anyone as confused as I was lol\\n\\n\\n```\\npublic class TweetCounts {\\n\\n    // Create a dictionary at class level to store tweets along with a list of timestamps\\n    private Dictionary<string, List<int>> Tweets;\\n\\n    public TweetCounts() {        \\n        this.Tweets = new Dictionary<string, List<int>>();\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        // If a new tweet comes in, add it to dictionary\\n        if (!Tweets.ContainsKey(tweetName))\\n        {\\n            Tweets.Add(tweetName, new List<int>());\\n        }\\n        \\n        // Add timestamp to tweet in dictionary\\n        Tweets[tweetName].Add(time);\\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        // Calculate the delta based on passed in \"freq\" string\\n        var delta = 1;\\n        \\n        if (freq == \"minute\")\\n        {\\n            delta = 60;\\n        }\\n        else if (freq == \"hour\")\\n        {\\n            delta = 60 * 60;\\n        }\\n        else if (freq == \"day\")\\n        {\\n            delta = 60 * 60 * 24;\\n        }\\n        \\n        // Calculate how many time chunks there are between this start and end time, based on frequency\\n        var timeChunk = 1 + (endTime - startTime) / delta;\\n        \\n        // Instantiate array with length based on how many time chunks there are\\n        var result = new int[timeChunk];\\n        \\n        // Iterate thru timestamps for this tweet\\n        // If tweet happened during time frame between start and end times, add 1 to correct slot in array based on time chunks breakdown\\n        foreach (var time in Tweets[tweetName])\\n        {\\n            if (time >= startTime && time <= endTime)\\n            {\\n                var i = (time - startTime) / delta;\\n                result[i]++;\\n            }\\n        }\\n        \\n        return result.ToList();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class TweetCounts {\\n\\n    // Create a dictionary at class level to store tweets along with a list of timestamps\\n    private Dictionary<string, List<int>> Tweets;\\n\\n    public TweetCounts() {        \\n        this.Tweets = new Dictionary<string, List<int>>();\\n    }\\n    \\n    public void RecordTweet(string tweetName, int time) {\\n        // If a new tweet comes in, add it to dictionary\\n        if (!Tweets.ContainsKey(tweetName))\\n        {\\n            Tweets.Add(tweetName, new List<int>());\\n        }\\n        \\n        // Add timestamp to tweet in dictionary\\n        Tweets[tweetName].Add(time);\\n    }\\n    \\n    public IList<int> GetTweetCountsPerFrequency(string freq, string tweetName, int startTime, int endTime) {\\n        // Calculate the delta based on passed in \"freq\" string\\n        var delta = 1;\\n        \\n        if (freq == \"minute\")\\n        {\\n            delta = 60;\\n        }\\n        else if (freq == \"hour\")\\n        {\\n            delta = 60 * 60;\\n        }\\n        else if (freq == \"day\")\\n        {\\n            delta = 60 * 60 * 24;\\n        }\\n        \\n        // Calculate how many time chunks there are between this start and end time, based on frequency\\n        var timeChunk = 1 + (endTime - startTime) / delta;\\n        \\n        // Instantiate array with length based on how many time chunks there are\\n        var result = new int[timeChunk];\\n        \\n        // Iterate thru timestamps for this tweet\\n        // If tweet happened during time frame between start and end times, add 1 to correct slot in array based on time chunks breakdown\\n        foreach (var time in Tweets[tweetName])\\n        {\\n            if (time >= startTime && time <= endTime)\\n            {\\n                var i = (time - startTime) / delta;\\n                result[i]++;\\n            }\\n        }\\n        \\n        return result.ToList();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776616,
                "title": "javascript-solution-map-and-binary-search",
                "content": "```\\nvar TweetCounts = function() {\\n    this.map = new Map();\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (!this.map.has(tweetName)) this.map.set(tweetName, []);\\n    this.map.get(tweetName).push(time);\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    if (!this.map.has(tweetName)) return [];\\n\\n    const tweets = this.map.get(tweetName);\\n    const buckets = createBuckets(freq, startTime, endTime);\\n    \\n    for (let i = 0; i < tweets.length; i++) {\\n        const tweetTime = tweets[i];\\n        \\n        let left = 0;\\n        let right = buckets.length - 1;\\n        \\n        while (left <= right) {\\n            const mid = (left + right) >> 1;\\n            const [startTime, endTime, count] = buckets[mid];\\n            \\n            if (startTime <= tweetTime && tweetTime <= endTime) {\\n                buckets[mid][2] = count + 1;\\n                break;\\n            }\\n            \\n            if (endTime < tweetTime) left = mid + 1;\\n            else right = mid - 1;\\n        } \\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < buckets.length; i++) {\\n        res.push(buckets[i][2]);\\n    }\\n    \\n    return res;\\n\\n\\n    function createBuckets(freq, startTime, endTime) {\\n        const chunks = { \"minute\": 60, \"hour\": 3600, \"day\": 86400 };\\n        const buckets = [];\\n\\n        let start = startTime;\\n\\n        while (start <= endTime) {\\n            const end = Math.min(start + chunks[freq] - 1, endTime);\\n            buckets.push([start, end, 0])\\n            start = end + 1; \\n        }\\n\\n        return buckets;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar TweetCounts = function() {\\n    this.map = new Map();\\n};\\n\\nTweetCounts.prototype.recordTweet = function(tweetName, time) {\\n    if (!this.map.has(tweetName)) this.map.set(tweetName, []);\\n    this.map.get(tweetName).push(time);\\n};\\n\\nTweetCounts.prototype.getTweetCountsPerFrequency = function(freq, tweetName, startTime, endTime) {\\n    if (!this.map.has(tweetName)) return [];\\n\\n    const tweets = this.map.get(tweetName);\\n    const buckets = createBuckets(freq, startTime, endTime);\\n    \\n    for (let i = 0; i < tweets.length; i++) {\\n        const tweetTime = tweets[i];\\n        \\n        let left = 0;\\n        let right = buckets.length - 1;\\n        \\n        while (left <= right) {\\n            const mid = (left + right) >> 1;\\n            const [startTime, endTime, count] = buckets[mid];\\n            \\n            if (startTime <= tweetTime && tweetTime <= endTime) {\\n                buckets[mid][2] = count + 1;\\n                break;\\n            }\\n            \\n            if (endTime < tweetTime) left = mid + 1;\\n            else right = mid - 1;\\n        } \\n    }\\n    \\n    const res = [];\\n    \\n    for (let i = 0; i < buckets.length; i++) {\\n        res.push(buckets[i][2]);\\n    }\\n    \\n    return res;\\n\\n\\n    function createBuckets(freq, startTime, endTime) {\\n        const chunks = { \"minute\": 60, \"hour\": 3600, \"day\": 86400 };\\n        const buckets = [];\\n\\n        let start = startTime;\\n\\n        while (start <= endTime) {\\n            const end = Math.min(start + chunks[freq] - 1, endTime);\\n            buckets.push([start, end, 0])\\n            start = end + 1; \\n        }\\n\\n        return buckets;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729721,
                "title": "python-the-most-standard-template-for-binary-search",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        \\n        self.a = defaultdict(list)\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        def bs_right(target):\\n            \\n            if len(self.a[tweetName]) == 0:\\n                return 0\\n            \\n            left = 0\\n            right = len(self.a[tweetName]) - 1\\n            \\n            while left + 1 < right:\\n                \\n                mid = left + (right - left) // 2\\n                \\n                if self.a[tweetName][mid] <= target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            if target < self.a[tweetName][left]:\\n                return left\\n            elif self.a[tweetName][left] <= target < self.a[tweetName][right]:\\n                return right\\n            else:\\n                return right + 1\\n        \\n       \\n        self.a[tweetName].insert(bs_right(time), time)\\n        \\n        \\n       \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        def bs_left(target):\\n            \\n            left = 0\\n            right = len(self.a[tweetName]) - 1\\n            \\n            while left + 1 < right:\\n                mid = left + (right - left) // 2\\n                \\n                if self.a[tweetName][mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            if target <= self.a[tweetName][left]:\\n                return left\\n            elif self.a[tweetName][left] < target <= self.a[tweetName][right]:\\n                return right\\n            else:\\n                return right + 1\\n            \\n        \\n        if freq == \"minute\":\\n            delta = 60\\n        elif freq == \"hour\":\\n            delta = 3600\\n        else:\\n            delta = 86400\\n        \\n        i = startTime\\n        res = []\\n        \\n        while i <= endTime:\\n            \\n            j = min(i + delta, endTime + 1)\\n            \\n            diff = bs_left(j) - bs_left(i)\\n            \\n            res.append(diff)\\n            \\n            i += delta\\n        \\n        return res\\n            \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass TweetCounts:\\n\\n    def __init__(self):\\n        \\n        self.a = defaultdict(list)\\n        \\n\\n    def recordTweet(self, tweetName: str, time: int) -> None:\\n        \\n        def bs_right(target):\\n            \\n            if len(self.a[tweetName]) == 0:\\n                return 0\\n            \\n            left = 0\\n            right = len(self.a[tweetName]) - 1\\n            \\n            while left + 1 < right:\\n                \\n                mid = left + (right - left) // 2\\n                \\n                if self.a[tweetName][mid] <= target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            if target < self.a[tweetName][left]:\\n                return left\\n            elif self.a[tweetName][left] <= target < self.a[tweetName][right]:\\n                return right\\n            else:\\n                return right + 1\\n        \\n       \\n        self.a[tweetName].insert(bs_right(time), time)\\n        \\n        \\n       \\n\\n    def getTweetCountsPerFrequency(self, freq: str, tweetName: str, startTime: int, endTime: int) -> List[int]:\\n        \\n        def bs_left(target):\\n            \\n            left = 0\\n            right = len(self.a[tweetName]) - 1\\n            \\n            while left + 1 < right:\\n                mid = left + (right - left) // 2\\n                \\n                if self.a[tweetName][mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            if target <= self.a[tweetName][left]:\\n                return left\\n            elif self.a[tweetName][left] < target <= self.a[tweetName][right]:\\n                return right\\n            else:\\n                return right + 1\\n            \\n        \\n        if freq == \"minute\":\\n            delta = 60\\n        elif freq == \"hour\":\\n            delta = 3600\\n        else:\\n            delta = 86400\\n        \\n        i = startTime\\n        res = []\\n        \\n        while i <= endTime:\\n            \\n            j = min(i + delta, endTime + 1)\\n            \\n            diff = bs_left(j) - bs_left(i)\\n            \\n            res.append(diff)\\n            \\n            i += delta\\n        \\n        return res\\n            \\n\\n\\n# Your TweetCounts object will be instantiated and called as such:\\n# obj = TweetCounts()\\n# obj.recordTweet(tweetName,time)\\n# param_2 = obj.getTweetCountsPerFrequency(freq,tweetName,startTime,endTime)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573423,
                "content": [
                    {
                        "username": "ericlapton",
                        "content": "Same code, first pic on Leetcode, second pic on PyCharm. It returns differently. \\n\\n![image](https://assets.leetcode.com/users/user948/image_1581221017.png)\\n\\n![image](https://assets.leetcode.com/users/user948/image_1581221025.png)\\n\\n"
                    },
                    {
                        "username": "cairae22",
                        "content": "getting the same issue"
                    }
                ]
            },
            {
                "id": 1573423,
                "content": [
                    {
                        "username": "ericlapton",
                        "content": "Same code, first pic on Leetcode, second pic on PyCharm. It returns differently. \\n\\n![image](https://assets.leetcode.com/users/user948/image_1581221017.png)\\n\\n![image](https://assets.leetcode.com/users/user948/image_1581221025.png)\\n\\n"
                    },
                    {
                        "username": "cairae22",
                        "content": "getting the same issue"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Students Taking Exam",
        "question_content": "<p>Given a <code>m&nbsp;* n</code>&nbsp;matrix <code>seats</code>&nbsp;&nbsp;that represent seats distributions&nbsp;in a classroom.&nbsp;If a seat&nbsp;is&nbsp;broken, it is denoted by <code>&#39;#&#39;</code> character otherwise it is denoted by a <code>&#39;.&#39;</code> character.</p>\n\n<p>Students can see the answers of those sitting next to the left, right, upper left and upper right, but he cannot see the answers of the student sitting&nbsp;directly in front or behind him. Return the <strong>maximum </strong>number of students that can take the exam together&nbsp;without any cheating being possible..</p>\n\n<p>Students must be placed in seats in good condition.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img height=\"200\" src=\"https://assets.leetcode.com/uploads/2020/01/29/image.png\" width=\"339\" />\n<pre>\n<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;               [&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;],\n&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;#&quot;,&quot;#&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Teacher can place 4 students in available seats so they don&#39;t cheat on the exam. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> seats = [[&quot;.&quot;,&quot;#&quot;],\n&nbsp;               [&quot;#&quot;,&quot;#&quot;],\n&nbsp;               [&quot;#&quot;,&quot;.&quot;],\n&nbsp;               [&quot;#&quot;,&quot;#&quot;],\n&nbsp;               [&quot;.&quot;,&quot;#&quot;]]\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> Place all students in available seats. \n\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> seats = [[&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;],\n&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;               [&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;,&quot;#&quot;,&quot;<strong>.</strong>&quot;],\n&nbsp;               [&quot;#&quot;,&quot;.&quot;,&quot;<strong>.</strong>&quot;,&quot;.&quot;,&quot;#&quot;]]\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Place students in available seats in column 1, 3 and 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>seats</code>&nbsp;contains only characters&nbsp;<code>&#39;.&#39;<font face=\"sans-serif, Arial, Verdana, Trebuchet MS\">&nbsp;and</font></code><code>&#39;#&#39;.</code></li>\n\t<li><code>m ==&nbsp;seats.length</code></li>\n\t<li><code>n ==&nbsp;seats[i].length</code></li>\n\t<li><code>1 &lt;= m &lt;= 8</code></li>\n\t<li><code>1 &lt;= n &lt;= 8</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 503686,
                "title": "a-simple-tutorial-on-this-bitmasking-problem",
                "content": "Bitmasking DP rarely appears in weekly contests. This tutorial will introduce my own perspective of bitmasking DP as well as several coding tricks when dealing with bitmasking problems. I will also give my solution to this problem at the end of this tutorial.\\n\\nWhat is bitmasking? Bitmasking is something related to **bit** and **mask**. For the **bit** part, everything is encoded as a single **bit**, so the whole state can be encoded as a group of **bits**, i.e. a binary number. For the **mask** part, we use 0/1 to represent the state of something. In most cases, 1 stands for the valid state while 0 stands for the invalid state.\\n\\nLet us consider an example. There are 4 cards on the table and I am going to choose several of them. We can encode the 4 cards as 4 bits. Say, if we choose cards 0, 1 and 3, we will use the binary number \"1011\" to represent the state. If we choose card 2, we will use the binary number \"0100\" then. The bits on the right represent cards with smaller id.\\n\\nAs we all know, integers are stored as binary numbers in the memory but appear as decimal numbers when we are coding. As a result, we tend to use a decimal number instead of a binary number to represent a state. In the previous example, we would use \"11\" and \"4\" instead of \"1011\" and \"0100\".\\n\\nWhen doing Bitmasking DP, we are always handling problems like \"what is the i-th bit in the state\" or \"what is the number of valid bits in a state\". These problems can be very complicated if we do not handle them properly. I will show some coding tricks below which we can make use of and solve this problem.\\n\\n- We can use **(x >> i) & 1** to get i-th bit in state **x**, where **>>** is the right shift operation. If we are doing this in an if statement (i.e. to check whether the i-th bit is 1), we can also use **x & (1 << i)**, where the **<<** is the left shift operation.\\n\\n- We can use **(x & y) == x** to check if **x** is a subset of **y**. The subset means every state in **x** could be 1 only if the corresponding state in **y** is 1.\\n\\n- We can use **(x & (x >> 1)) == 0** to check if there are no adjancent valid states in **x**.\\n\\nNow we can come to the problem. We can use a bitmask of n bits to represent the validity of each row in the classroom. The i-th bit is 1 if and only if the i-th seat is not broken. For the first example in this problem, the bitmasks will be \"010010\", \"100001\" and \"010010\". When we arrange the students to seat in this row, we can also use n bits to represent the students. The i-th bit is 1 if and only if the i-th seat is occupied by a student. We should notice that n bits representing students must be a subset of n bits representing seats.\\n\\nWe denote **dp[i][mask]** as the maximum number of students for the first **i** rows while the students in the i-th row follow the masking **mask**. There should be no adjancent valid states in **mask**. The transition function is:\\n\\n```\\ndp[i][mask] = max(dp[i - 1][mask\\']) + number of valid bits(mask)\\n```\\n\\nwhere **mask\\'** is the masking for the (i-1)-th row. To prevent students from cheating, the following equation must hold:\\n\\n- **(mask & (mask\\' >> 1)) == 0**, there should be no students in the upper left position for every student.\\n\\n- **((mask >> 1) & mask\\') == 0**, there should be no students in the upper right position for every student.\\n\\nIf these two equation holds and **dp[i - 1][mask\\']** itself is valid, we could then transit from **dp[i - 1][mask\\']** to **dp[i][mask]** according to the transition function.\\n\\nAnd the last question is, how can we compute the number of valid bits in a masking efficiently? In C++, we can simply use the built-in function **__builtin_popcount(mask)**. For other programming languages, we can pre-compute by using **count[i] = count[i/2] + (i % 2 == 1)** and store them in an array.\\n\\n```C++\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<int> validity; // the validity of each row in the classroom\\n        for (int i = 0; i < m; ++i) {\\n            int cur = 0;\\n            for (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t// the j-th bit is 1 if and only if the j-th seat is not broken\\n\\t\\t\\t\\t// here the 0th bit is the most significant bit\\n                cur = cur * 2 + (seats[i][j] == \\'.\\');\\n            }\\n            validity.push_back(cur);\\n        }\\n\\t\\t\\n\\t\\t// all the f states are set -1 as invalid states in the beginning\\n\\t\\t// here f[i][mask] represents the first i-1 rows to handle corner cases\\n        vector<vector<int>> f(m + 1, vector<int>(1 << n, -1));\\n\\t\\t// f[0][0] is a valid state\\n\\t\\t// think of a virtual row in the front and no students are sitting in that row\\n        f[0][0] = 0;\\n        for (int i = 1; i <= m; ++i) {\\n            int valid = validity[i - 1];\\n\\t\\t\\t// the interval [0, 1 << n) includes all the n-bit states for a row of students\\n\\t\\t\\t// please note that state 0 represents no student sitting in this row\\n\\t\\t\\t// which is always a valid state\\n            for (int j = 0; j < (1 << n); ++j) {\\n\\t\\t\\t\\t// (j & valid) == j: check if j is a subset of valid\\n\\t\\t\\t\\t// !(j & (j >> 1)): check if there is no adjancent students in the row\\n                if ((j & valid) == j && !(j & (j >> 1))) {\\n\\t\\t\\t\\t\\t// f[i][j] may transit from f[i -1][k]\\n                    for (int k = 0; k < (1 << n); ++k) {\\n\\t\\t\\t\\t\\t\\t// !(j & (k >> 1)): no students in the upper left positions\\n\\t\\t\\t\\t\\t\\t// !((j >> 1) & k): no students in the upper right positions\\n\\t\\t\\t\\t\\t\\t// f[i - 1][k] != -1: the previous state is valid\\n                        if (!(j & (k >> 1)) && !((j >> 1) & k) && f[i - 1][k] != -1) {\\n                            f[i][j] = max(f[i][j], f[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// the answer is the maximum among all f[m][mask]\\n        return *max_element(f[m].begin(), f[m].end());\\n    }\\n};\\n```\\n\\n**Update 1:** Fix several typos and add comments to my code.\\n\\n",
                "solutionTags": [
                    "Bitmask"
                ],
                "code": "```\\ndp[i][mask] = max(dp[i - 1][mask\\']) + number of valid bits(mask)\\n```\n```C++\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<int> validity; // the validity of each row in the classroom\\n        for (int i = 0; i < m; ++i) {\\n            int cur = 0;\\n            for (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t// the j-th bit is 1 if and only if the j-th seat is not broken\\n\\t\\t\\t\\t// here the 0th bit is the most significant bit\\n                cur = cur * 2 + (seats[i][j] == \\'.\\');\\n            }\\n            validity.push_back(cur);\\n        }\\n\\t\\t\\n\\t\\t// all the f states are set -1 as invalid states in the beginning\\n\\t\\t// here f[i][mask] represents the first i-1 rows to handle corner cases\\n        vector<vector<int>> f(m + 1, vector<int>(1 << n, -1));\\n\\t\\t// f[0][0] is a valid state\\n\\t\\t// think of a virtual row in the front and no students are sitting in that row\\n        f[0][0] = 0;\\n        for (int i = 1; i <= m; ++i) {\\n            int valid = validity[i - 1];\\n\\t\\t\\t// the interval [0, 1 << n) includes all the n-bit states for a row of students\\n\\t\\t\\t// please note that state 0 represents no student sitting in this row\\n\\t\\t\\t// which is always a valid state\\n            for (int j = 0; j < (1 << n); ++j) {\\n\\t\\t\\t\\t// (j & valid) == j: check if j is a subset of valid\\n\\t\\t\\t\\t// !(j & (j >> 1)): check if there is no adjancent students in the row\\n                if ((j & valid) == j && !(j & (j >> 1))) {\\n\\t\\t\\t\\t\\t// f[i][j] may transit from f[i -1][k]\\n                    for (int k = 0; k < (1 << n); ++k) {\\n\\t\\t\\t\\t\\t\\t// !(j & (k >> 1)): no students in the upper left positions\\n\\t\\t\\t\\t\\t\\t// !((j >> 1) & k): no students in the upper right positions\\n\\t\\t\\t\\t\\t\\t// f[i - 1][k] != -1: the previous state is valid\\n                        if (!(j & (k >> 1)) && !((j >> 1) & k) && f[i - 1][k] != -1) {\\n                            f[i][j] = max(f[i][j], f[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// the answer is the maximum among all f[m][mask]\\n        return *max_element(f[m].begin(), f[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503790,
                "title": "python-hungarian-time-o-m-2-n-2-space-o-m-n-beat-100",
                "content": "The idea is that seats on even columns and seats on odd columns form a bipartite graph. Therefore, the maximum independent set on the bipartite graph is the solution.\\n\\nSolving such a problem with Hungarian is O(VE) where V is the number of vertices and E is the number of edges. In this problem, we have O(mn) nodes and O(mn) edges, thus total O(m^2  * n^2), where m and n are the dimensions of the input matrix.\\n\\nCredit goes to @cuiaoxiang @zerotrac2 for the idea and discussion.\\n\\n```\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        \\n        matching = [[-1] * C for _ in range(R)]\\n        \\n        def dfs(node, seen):\\n            r, c = node\\n            for nr, nc in [[r-1,c-1], [r,c-1],[r,c+1],[r-1,c+1],[r+1,c-1],[r+1,c+1]]: # assume a virtual edge connecting students who can spy\\n                if 0 <= nr < R and 0 <= nc < C and seen[nr][nc] == False and seats[nr][nc] == \\'.\\':\\n                    seen[nr][nc] = True\\n                    if matching[nr][nc] == -1 or dfs(matching[nr][nc], seen):\\n                        matching[nr][nc] = (r,c)\\n                        return True\\n            return False\\n        \\n        def Hungarian():\\n            res = 0\\n            for c in range(0,C,2):\\n                for r in range(R):\\n                    if seats[r][c] == \\'.\\':\\n                        seen = [[False] * C for _ in range(R)]\\n                        if dfs((r,c), seen):\\n                            res += 1\\n            return res\\n        \\n        res = Hungarian()\\n                \\n        count = 0\\n        for r in range(R):\\n            for c in range(C):\\n                if seats[r][c] == \\'.\\':\\n                    count += 1\\n        return count - res\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        \\n        matching = [[-1] * C for _ in range(R)]\\n        \\n        def dfs(node, seen):\\n            r, c = node\\n            for nr, nc in [[r-1,c-1], [r,c-1],[r,c+1],[r-1,c+1],[r+1,c-1],[r+1,c+1]]: # assume a virtual edge connecting students who can spy\\n                if 0 <= nr < R and 0 <= nc < C and seen[nr][nc] == False and seats[nr][nc] == \\'.\\':\\n                    seen[nr][nc] = True\\n                    if matching[nr][nc] == -1 or dfs(matching[nr][nc], seen):\\n                        matching[nr][nc] = (r,c)\\n                        return True\\n            return False\\n        \\n        def Hungarian():\\n            res = 0\\n            for c in range(0,C,2):\\n                for r in range(R):\\n                    if seats[r][c] == \\'.\\':\\n                        seen = [[False] * C for _ in range(R)]\\n                        if dfs((r,c), seen):\\n                            res += 1\\n            return res\\n        \\n        res = Hungarian()\\n                \\n        count = 0\\n        for r in range(R):\\n            for c in range(C):\\n                if seats[r][c] == \\'.\\':\\n                    count += 1\\n        return count - res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503491,
                "title": "java-top-down-dp-solution",
                "content": "* process row by row\\n* mask represents occupacy status for a row, for example 100001 means 1st  and 6th seats are taken\\n\\t* use backtrack to get all combination of seat assignment for a row based on previous row\\'s mask\\n* memo[i][j] stores the max student count for row range in [i, RowCount - 1] when the previous row\\'s mask is j\\n```\\nclass Solution {\\n    \\n    int r, c;\\n    int[][] memo;\\n    List<Integer> masks;\\n    \\n    public int maxStudents(char[][] seats) {\\n        r = seats.length;\\n        c = seats[0].length;\\n        memo = new int[r][1<<c];\\n        for (int i = 0; i < r; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return getMax(seats, 0, 0);\\n    }\\n    \\n    private int getMax(char[][] seats, int curRow, int prevRowMask) {\\n        if (curRow == r) {\\n            return 0;\\n        }\\n        if (memo[curRow][prevRowMask] != -1){\\n            return memo[curRow][prevRowMask];\\n        }\\n        masks = new LinkedList<>(); // reset the masks list for backtrack\\n        backtrack(seats[curRow], 0, prevRowMask, 0); // backtrack results store in masks list\\n        int res = 0;\\n        for (int m : masks) {\\n            res = Math.max(res, Integer.bitCount(m) + getMax(seats, curRow + 1, m));\\n        }\\n        memo[curRow][prevRowMask] = res;\\n        return res;\\n    }\\n    \\n    // this returns all combination of legal seat assignment for a given row based on prevous row\\'s mask\\n    private void backtrack(char[] seats, int cur, int prevRowMask, int curRowMask) {\\n        if (cur == c) {\\n            masks.add(curRowMask);\\n            return;\\n        }\\n        // cur seat is not taken\\n        backtrack(seats, cur + 1, prevRowMask, curRowMask);\\n        \\n        // cur seat is taken, check if left, upper left and upper right positions are empty\\n        if (seats[cur] != \\'#\\' \\n            && (cur == 0 || (((curRowMask & (1 << (cur-1))) == 0) && (prevRowMask & (1 << (cur-1))) == 0))\\n            && (cur == c - 1 || ((prevRowMask & (1 << (cur+1))) == 0))) {\\n            curRowMask |= (1 << (cur));\\n            backtrack(seats, cur + 1, prevRowMask, curRowMask);\\n            curRowMask ^= (1 << (cur));\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int r, c;\\n    int[][] memo;\\n    List<Integer> masks;\\n    \\n    public int maxStudents(char[][] seats) {\\n        r = seats.length;\\n        c = seats[0].length;\\n        memo = new int[r][1<<c];\\n        for (int i = 0; i < r; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n        return getMax(seats, 0, 0);\\n    }\\n    \\n    private int getMax(char[][] seats, int curRow, int prevRowMask) {\\n        if (curRow == r) {\\n            return 0;\\n        }\\n        if (memo[curRow][prevRowMask] != -1){\\n            return memo[curRow][prevRowMask];\\n        }\\n        masks = new LinkedList<>(); // reset the masks list for backtrack\\n        backtrack(seats[curRow], 0, prevRowMask, 0); // backtrack results store in masks list\\n        int res = 0;\\n        for (int m : masks) {\\n            res = Math.max(res, Integer.bitCount(m) + getMax(seats, curRow + 1, m));\\n        }\\n        memo[curRow][prevRowMask] = res;\\n        return res;\\n    }\\n    \\n    // this returns all combination of legal seat assignment for a given row based on prevous row\\'s mask\\n    private void backtrack(char[] seats, int cur, int prevRowMask, int curRowMask) {\\n        if (cur == c) {\\n            masks.add(curRowMask);\\n            return;\\n        }\\n        // cur seat is not taken\\n        backtrack(seats, cur + 1, prevRowMask, curRowMask);\\n        \\n        // cur seat is taken, check if left, upper left and upper right positions are empty\\n        if (seats[cur] != \\'#\\' \\n            && (cur == 0 || (((curRowMask & (1 << (cur-1))) == 0) && (prevRowMask & (1 << (cur-1))) == 0))\\n            && (cur == c - 1 || ((prevRowMask & (1 << (cur+1))) == 0))) {\\n            curRowMask |= (1 << (cur));\\n            backtrack(seats, cur + 1, prevRowMask, curRowMask);\\n            curRowMask ^= (1 << (cur));\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503598,
                "title": "java-dfs-with-memoization-represent-the-states-as-a-string",
                "content": "notice that  1<=m,n <=8. flatten the board to a string so charAt(i*n+j) was seat[i][j]. The string must be less than length 64. It\\'s ok to search on String and keep a hash map to store the entire board as a string. \\n\\nWell maybe we can use long and bitmask. Should be much faster, but same idea, just mask the unavailable seats with 1. 64 = 8x8 is maybe designed for this lol.\\n\\n\\n\\n```\\nclass Solution {\\n    int m, n;\\n    Map<String, Integer> memo;\\n    public int maxStudents(char[][] seats) {\\n        m=seats.length;\\n        if(m==0) return 0;\\n        n = seats[0].length;\\n        \\n        memo = new HashMap<String, Integer>();\\n        StringBuilder sb = new StringBuilder();\\n        for(char[] row: seats){\\n            sb.append(row);\\n        }\\n        \\n        return dfs(sb.toString());\\n    }\\n\\t\\n\\t/* dfs returns the max student we can place if start with the given state */\\n\\n    public int dfs(String state){\\n        if(memo.containsKey(state)) return memo.get(state);\\n        int max = 0;\\n        char[] C = state.toCharArray();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n\\t\\t\\t//we see an empty seat, there are two choices, place a student here or leave it empty.\\n                if(C[i*n+j]== \\'.\\'){\\n                    //choice (1): we choose not to place a student, but we place a x to mark this seat as unanvailable\\n\\t\\t\\t\\t\\t// so we don\\'t repeatedly search this state again. \\n\\t\\t\\t\\t\\t\\n                    C[i*n+j] = \\'x\\';\\n                    max = Math.max(max, dfs(new String(C)));\\n     \\n\\t\\t\\t\\t\\t //choice (2): we place a student, but this makes left, right, bottom left, bottom right seat unavailable. \\n                    if(j+1<n){\\n                        if(i<m-1 && C[(i+1)*n+j+1] == \\'.\\') C[(i+1)*n+j+1] = \\'x\\';\\n                        if(C[i*n+j+1] == \\'.\\') C[i*n+j+1] = \\'x\\';\\n                    }\\n                    if(j-1>=0){\\n                        if(i<m-1 && C[(i+1)*n+j-1] == \\'.\\') C[(i+1)*n+j-1]= \\'x\\';\\n                        if(C[i*n+j-1] == \\'.\\') C[i*n+j-1] = \\'x\\';\\n                    }\\n                    max = Math.max(max, 1+dfs(new String(C)));\\n                }\\n            }\\n        }\\n        memo.put(state, max);\\n        return max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    Map<String, Integer> memo;\\n    public int maxStudents(char[][] seats) {\\n        m=seats.length;\\n        if(m==0) return 0;\\n        n = seats[0].length;\\n        \\n        memo = new HashMap<String, Integer>();\\n        StringBuilder sb = new StringBuilder();\\n        for(char[] row: seats){\\n            sb.append(row);\\n        }\\n        \\n        return dfs(sb.toString());\\n    }\\n\\t\\n\\t/* dfs returns the max student we can place if start with the given state */\\n\\n    public int dfs(String state){\\n        if(memo.containsKey(state)) return memo.get(state);\\n        int max = 0;\\n        char[] C = state.toCharArray();\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n\\t\\t\\t//we see an empty seat, there are two choices, place a student here or leave it empty.\\n                if(C[i*n+j]== \\'.\\'){\\n                    //choice (1): we choose not to place a student, but we place a x to mark this seat as unanvailable\\n\\t\\t\\t\\t\\t// so we don\\'t repeatedly search this state again. \\n\\t\\t\\t\\t\\t\\n                    C[i*n+j] = \\'x\\';\\n                    max = Math.max(max, dfs(new String(C)));\\n     \\n\\t\\t\\t\\t\\t //choice (2): we place a student, but this makes left, right, bottom left, bottom right seat unavailable. \\n                    if(j+1<n){\\n                        if(i<m-1 && C[(i+1)*n+j+1] == \\'.\\') C[(i+1)*n+j+1] = \\'x\\';\\n                        if(C[i*n+j+1] == \\'.\\') C[i*n+j+1] = \\'x\\';\\n                    }\\n                    if(j-1>=0){\\n                        if(i<m-1 && C[(i+1)*n+j-1] == \\'.\\') C[(i+1)*n+j-1]= \\'x\\';\\n                        if(C[i*n+j-1] == \\'.\\') C[i*n+j-1] = \\'x\\';\\n                    }\\n                    max = Math.max(max, 1+dfs(new String(C)));\\n                }\\n            }\\n        }\\n        memo.put(state, max);\\n        return max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503763,
                "title": "c-dp-bitmasking-inspired-by-tmwilliamlin168",
                "content": "Firstly I would like to thank **tmwilliamlin168** (ranked 3 in this contest). He is a brilliant competitive programmer, and I really appreciative his effort in making videos and explaining his solutions. But it might be hard to understand his solution (as well as this post) if you know nothing about bitmasking. Please read relevant tutorials or other posts if you want to learn about bitmasking, I will not explain it here.\\n\\nThanks **tmwilliamlin168** again and here is the video. I also post my own explanation here.\\nhttps://www.youtube.com/watch?v=AUl8EztUNrA\\n\\nWe can do the dp row by row, we start from row 1 until row n. \\n`dp[i][mask]` represents that, we are now at row `i` and the state of this row is `mask`. \\n\\nNow, state conversion is: We consider every possible state of the last row, and check if the state conversion is legal (that is, there will be no cheating). Hence we have:\\n\\n`dp[i][mask] = max(dp[i][mask], dp[i-1][premask] + __builtin_popcount(mask));`\\nwhere `mask` and `premask` are both legal, and these two rows together will have no cheating.\\n\\nNote: `__builtin_popcount()` count the number of 1-bits in the mask.\\n\\nCode: \\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int ans = 0;\\n    int dp[9][(1<<8)+2];  //dp[i][mask]: we are in row i(i is from [1,9]), state is mask\\n    int avail[9];  //avail[i] is the mask representing available seats in row i\\n        \\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size(); m = seats[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (seats[i-1][j] == \\'.\\') {\\n                    avail[i] |= (1<<j);\\n                }\\n            }\\n        }\\n        \\n        for (int mask = 0; mask < (1<<m); mask++) {\\n            dp[0][mask] = 0;  //initialize all illegal states with 0\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {  //now we are at row i\\n            for (int premask = 0; premask < (1<<m); premask++) {\\n                if (dp[i-1][premask] == -1) continue;\\n                for (int mask = 0; mask < (1<<m); mask++) {\\n                    if ((mask & avail[i]) != mask) continue;\\n                    if (mask&(mask>>1)) continue;  //if there is adjacent 1\\n                    \\n                    /*checking this row and last row*/\\n                    if (mask&(premask<<1) || mask&(premask>>1)) continue;\\n                    dp[i][mask] = max(dp[i][mask], dp[i-1][premask] + __builtin_popcount(mask));\\n                }\\n            }\\n        }\\n        \\n        for (int mask = 0; mask < (1<<m); mask++) {\\n            ans = max(ans, dp[n][mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int ans = 0;\\n    int dp[9][(1<<8)+2];  //dp[i][mask]: we are in row i(i is from [1,9]), state is mask\\n    int avail[9];  //avail[i] is the mask representing available seats in row i\\n        \\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size(); m = seats[0].size();\\n        memset(dp, -1, sizeof(dp));\\n        for (int i = 1; i <= n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (seats[i-1][j] == \\'.\\') {\\n                    avail[i] |= (1<<j);\\n                }\\n            }\\n        }\\n        \\n        for (int mask = 0; mask < (1<<m); mask++) {\\n            dp[0][mask] = 0;  //initialize all illegal states with 0\\n        }\\n        \\n        for (int i = 1; i <= n; i++) {  //now we are at row i\\n            for (int premask = 0; premask < (1<<m); premask++) {\\n                if (dp[i-1][premask] == -1) continue;\\n                for (int mask = 0; mask < (1<<m); mask++) {\\n                    if ((mask & avail[i]) != mask) continue;\\n                    if (mask&(mask>>1)) continue;  //if there is adjacent 1\\n                    \\n                    /*checking this row and last row*/\\n                    if (mask&(premask<<1) || mask&(premask>>1)) continue;\\n                    dp[i][mask] = max(dp[i][mask], dp[i-1][premask] + __builtin_popcount(mask));\\n                }\\n            }\\n        }\\n        \\n        for (int mask = 0; mask < (1<<m); mask++) {\\n            ans = max(ans, dp[n][mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503558,
                "title": "python-15-line-simple-dp-using-yield-with-explanation",
                "content": "**Idea**\\nStarting from row 0, we enumerate all the possible combination of seats arrangements.\\nGiven a seats arrangement of row `n`, we can enumerate all the possible seats arrangement of row `n+1`.\\n\\n**Function `combination_row` Explanation**\\n- Inputs:\\n\\t- `i`: the index of row\\n\\t- `end`: the index of seat at row i under consideration\\n\\t- `prev`: the arrangement before the current seat, represented with string. E.g. \\'.#.\\'\\n\\t- `count`: the number of students seated to the left of the current position\\n\\t- `front`: the seat arrangement of the previous row\\n- Yield: \\n\\t- a seat arrangements at row i\\n\\t- the corresponding number of students seated at row i\\n\\n**Complexity**\\nWorst Case Time Complexity: `O(2^m * n)` (performances are much better on average cases)\\nWorst Case Space Complexity: `O(2^m)` (performances are much better on average cases)\\n\\n**Python3**\\n```\\nclass Solution:\\n    def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        \\n        def combination_row(i, end=0, prev=\\'\\', count=0, front=None):\\n            if end >= n:\\n                yield prev, count; return\\n            elif seats[i][end] == \\'.\\' and \\\\\\n                    (not prev or prev[-1] == \\'#\\') and \\\\\\n                    (end == 0 or front[end-1] == \\'#\\') and \\\\\\n                    (end == n-1 or front[end+1] == \\'#\\'):\\n                yield from combination_row(i, end+1, prev+\\'.\\', count+1, front)\\n            yield from combination_row(i, end+1, prev+\\'#\\', count, front)\\n                            \\n        new_dp = {\\'#\\'*n:0} # base case: a dummy row at the very front, with all seats broken\\n        for i in range(m):\\n            dp, new_dp = new_dp, {}\\n            for p,sm in dp.items():\\n                for k,v in combination_row(i, front=p):\\n                    new_dp[k] = max(v+sm, new_dp.get(k, 0))\\n        return max(new_dp.values())\\n```\\n\\n**Python3 using reduce (without comment and line break)**\\n```\\nfrom functools import reduce\\nclass Solution:\\n    def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        def combination_row(i, end=0, prev=\\'\\', count=0, front=None):\\n            if end >= n:\\n                yield prev, count; return\\n            elif seats[i][end] == \\'.\\' and (not prev or prev[-1] == \\'#\\') and (end == 0 or front[end-1] == \\'#\\') and (end == n-1 or front[end+1] == \\'#\\'):\\n                yield from combination_row(i, end+1, prev+\\'.\\', count+1, front)\\n            yield from combination_row(i, end+1, prev+\\'#\\', count, front)\\n                            \\n        dp = {\\'#\\'*n:0}\\n        for i in range(m):\\n            def update(d, k, v): \\n                d[k] = max(d.get(k, 0), v)\\n                return d\\n            dp = reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front=p)), {})\\n        return max(dp.values()) \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        \\n        def combination_row(i, end=0, prev=\\'\\', count=0, front=None):\\n            if end >= n:\\n                yield prev, count; return\\n            elif seats[i][end] == \\'.\\' and \\\\\\n                    (not prev or prev[-1] == \\'#\\') and \\\\\\n                    (end == 0 or front[end-1] == \\'#\\') and \\\\\\n                    (end == n-1 or front[end+1] == \\'#\\'):\\n                yield from combination_row(i, end+1, prev+\\'.\\', count+1, front)\\n            yield from combination_row(i, end+1, prev+\\'#\\', count, front)\\n                            \\n        new_dp = {\\'#\\'*n:0} # base case: a dummy row at the very front, with all seats broken\\n        for i in range(m):\\n            dp, new_dp = new_dp, {}\\n            for p,sm in dp.items():\\n                for k,v in combination_row(i, front=p):\\n                    new_dp[k] = max(v+sm, new_dp.get(k, 0))\\n        return max(new_dp.values())\\n```\n```\\nfrom functools import reduce\\nclass Solution:\\n    def maxStudents(self, seats):\\n        m, n = len(seats), len(seats[0])\\n        def combination_row(i, end=0, prev=\\'\\', count=0, front=None):\\n            if end >= n:\\n                yield prev, count; return\\n            elif seats[i][end] == \\'.\\' and (not prev or prev[-1] == \\'#\\') and (end == 0 or front[end-1] == \\'#\\') and (end == n-1 or front[end+1] == \\'#\\'):\\n                yield from combination_row(i, end+1, prev+\\'.\\', count+1, front)\\n            yield from combination_row(i, end+1, prev+\\'#\\', count, front)\\n                            \\n        dp = {\\'#\\'*n:0}\\n        for i in range(m):\\n            def update(d, k, v): \\n                d[k] = max(d.get(k, 0), v)\\n                return d\\n            dp = reduce(lambda x,pair:update(x,*pair), (k,v+sm) for p,sm in dp.items() for k,v in combination_row(i, front=p)), {})\\n        return max(dp.values()) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 503512,
                "title": "c-py3-dynamic-programming-with-bitmask",
                "content": "Given a grid of seats and place as many as students on the seats. There cannot be other students in one student\\'s left, right, upper left or upper right. \\n\\n# Explanation\\n\\nBecause the constraint is small (`n, m <= 8`), and each student only sees the current row and the row before it, it is a good idea to consider memorization searching or DP with bitmap. \\n\\nIn my code, the array `f[mask][row]` means the maximum number of students that can be placed in the grid before `row` (included) when the pattern of students sitting in this row is `mask`. Then for each `(mask, row)` pair, enumerate all valid `nmask` (valid mask of next row) and update corresponding `f[nmask][row+1]`.\\n\\nThe time complexity is `O(n * 2^m * 2^m * m)`.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\n    int f[1 << 8][8];  // the student distribution, row\\n    int n, m;\\n    vector<vector<char>> seats;\\n    \\n    // this bit is on\\n    bool on(int bit, int mask) {\\n        return (1 << bit) & mask;\\n    }\\n    \\n    bool checkRowValid(int row, int mask) {\\n        for (int i = 0; i < m; i++) {\\n            // if a student is put on a broken chair\\n            if (on(i, mask) && seats[row][i] == \\'#\\') return false;\\n            // if there is a student on the left of this student\\n            if (i > 0 && on(i - 1, mask) && on(i, mask)) return false;\\n            // if there is a student on the right of this student\\n            if (i < m - 1 && on(i + 1, mask) && on(i, mask)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkTwoRowCollision(int mask, int nmask) {\\n        for (int i = 0; i < m; i++) {\\n            // if there is a student on the upper left\\n            if (i > 0 && on(i, nmask) && on(i - 1, mask)) return false;\\n            // if there is a student on the upper right\\n            if (i < m - 1 && on(i, nmask) && on(i + 1, mask)) return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size();\\n        m = seats[0].size();\\n        memset(f, 0, sizeof(f));\\n        this->seats = seats;\\n        int ans = 0;\\n        \\n        // initialization\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            if (checkRowValid(0, mask)) {\\n                f[mask][0] = __builtin_popcount(mask);\\n                ans = max(ans, f[mask][0]);\\n            }\\n        }\\n        \\n        for (int row = 0; row < n - 1; row++) {\\n            for (int mask = 0; mask < (1 << m); mask++) {\\n                // the current row of students has to be valid\\n                if (!checkRowValid(row, mask)) continue;\\n                \\n                // generate each next row and check correctness\\n                for (int nmask = 0; nmask < (1 << m); nmask++) {\\n                    // first it has to be valid\\n                    if (!checkRowValid(row + 1, nmask))\\n                        continue;\\n                    // then it has to not collide with former row\\n                    if (!checkTwoRowCollision(mask, nmask))\\n                        continue;\\n\\n                    f[nmask][row + 1] = max(f[nmask][row + 1], f[mask][row] + __builtin_popcount(nmask));\\n                    ans = max(ans, f[nmask][row + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# PY3 Solution\\n\\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n = len(seats)\\n        m = len(seats[0])\\n        f = [[0] * 8 for _ in range((1 << 8))]\\n        \\n        def on(bit, mask):\\n            return (1 << bit) & mask > 0\\n        \\n        def onecnt(n):\\n            return bin(n).count(\"1\")\\n        \\n        def checkRowValid(row, mask):\\n            for i in range(m):\\n                # if a student is put on a broken chair\\n                if on(i, mask) and seats[row][i] == \"#\": return False\\n                # if there is a student on the left of this student\\n                if i > 0 and on(i - 1, mask) and on(i, mask): return False\\n                # if there is a student on the right of this student\\n                if i < m - 1 and on(i + 1, mask) and on(i, mask): return False\\n            return True\\n        \\n        def checkTwoRowCollision(mask, nmask):\\n            for i in range(m):\\n                # if there is a student on the upper left\\n                if i > 0 and on(i, nmask) and on(i - 1, mask): return False\\n                # if there is a student on the upper right\\n                if i < m - 1 and on(i, nmask) and on(i + 1, mask): return False\\n            return True\\n        \\n        ans = 0\\n        \\n        # initialization\\n        for mask in range(1 << m):\\n            if checkRowValid(0, mask):\\n                f[mask][0] = onecnt(mask)\\n                ans = max(ans, f[mask][0])\\n        \\n        for row in range(n - 1):\\n            for mask in range(1 << m):\\n                # the current row of students has to be valid\\n                if not checkRowValid(row, mask): continue\\n                \\n                # generate each next row and check correctness\\n                for nmask in range (1 << m):\\n                    # first it has to be valid\\n                    if not checkRowValid(row + 1, nmask): continue\\n                    # then it has to not collide with former row\\n                    if not checkTwoRowCollision(mask, nmask): continue\\n\\n                    f[nmask][row + 1] = max(f[nmask][row + 1], f[mask][row] + onecnt(nmask))\\n                    ans = max(ans, f[nmask][row + 1])\\n        \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    int f[1 << 8][8];  // the student distribution, row\\n    int n, m;\\n    vector<vector<char>> seats;\\n    \\n    // this bit is on\\n    bool on(int bit, int mask) {\\n        return (1 << bit) & mask;\\n    }\\n    \\n    bool checkRowValid(int row, int mask) {\\n        for (int i = 0; i < m; i++) {\\n            // if a student is put on a broken chair\\n            if (on(i, mask) && seats[row][i] == \\'#\\') return false;\\n            // if there is a student on the left of this student\\n            if (i > 0 && on(i - 1, mask) && on(i, mask)) return false;\\n            // if there is a student on the right of this student\\n            if (i < m - 1 && on(i + 1, mask) && on(i, mask)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool checkTwoRowCollision(int mask, int nmask) {\\n        for (int i = 0; i < m; i++) {\\n            // if there is a student on the upper left\\n            if (i > 0 && on(i, nmask) && on(i - 1, mask)) return false;\\n            // if there is a student on the upper right\\n            if (i < m - 1 && on(i, nmask) && on(i + 1, mask)) return false;\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size();\\n        m = seats[0].size();\\n        memset(f, 0, sizeof(f));\\n        this->seats = seats;\\n        int ans = 0;\\n        \\n        // initialization\\n        for (int mask = 0; mask < (1 << m); mask++) {\\n            if (checkRowValid(0, mask)) {\\n                f[mask][0] = __builtin_popcount(mask);\\n                ans = max(ans, f[mask][0]);\\n            }\\n        }\\n        \\n        for (int row = 0; row < n - 1; row++) {\\n            for (int mask = 0; mask < (1 << m); mask++) {\\n                // the current row of students has to be valid\\n                if (!checkRowValid(row, mask)) continue;\\n                \\n                // generate each next row and check correctness\\n                for (int nmask = 0; nmask < (1 << m); nmask++) {\\n                    // first it has to be valid\\n                    if (!checkRowValid(row + 1, nmask))\\n                        continue;\\n                    // then it has to not collide with former row\\n                    if (!checkTwoRowCollision(mask, nmask))\\n                        continue;\\n\\n                    f[nmask][row + 1] = max(f[nmask][row + 1], f[mask][row] + __builtin_popcount(nmask));\\n                    ans = max(ans, f[nmask][row + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n = len(seats)\\n        m = len(seats[0])\\n        f = [[0] * 8 for _ in range((1 << 8))]\\n        \\n        def on(bit, mask):\\n            return (1 << bit) & mask > 0\\n        \\n        def onecnt(n):\\n            return bin(n).count(\"1\")\\n        \\n        def checkRowValid(row, mask):\\n            for i in range(m):\\n                # if a student is put on a broken chair\\n                if on(i, mask) and seats[row][i] == \"#\": return False\\n                # if there is a student on the left of this student\\n                if i > 0 and on(i - 1, mask) and on(i, mask): return False\\n                # if there is a student on the right of this student\\n                if i < m - 1 and on(i + 1, mask) and on(i, mask): return False\\n            return True\\n        \\n        def checkTwoRowCollision(mask, nmask):\\n            for i in range(m):\\n                # if there is a student on the upper left\\n                if i > 0 and on(i, nmask) and on(i - 1, mask): return False\\n                # if there is a student on the upper right\\n                if i < m - 1 and on(i, nmask) and on(i + 1, mask): return False\\n            return True\\n        \\n        ans = 0\\n        \\n        # initialization\\n        for mask in range(1 << m):\\n            if checkRowValid(0, mask):\\n                f[mask][0] = onecnt(mask)\\n                ans = max(ans, f[mask][0])\\n        \\n        for row in range(n - 1):\\n            for mask in range(1 << m):\\n                # the current row of students has to be valid\\n                if not checkRowValid(row, mask): continue\\n                \\n                # generate each next row and check correctness\\n                for nmask in range (1 << m):\\n                    # first it has to be valid\\n                    if not checkRowValid(row + 1, nmask): continue\\n                    # then it has to not collide with former row\\n                    if not checkTwoRowCollision(mask, nmask): continue\\n\\n                    f[nmask][row + 1] = max(f[nmask][row + 1], f[mask][row] + onecnt(nmask))\\n                    ans = max(ans, f[nmask][row + 1])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505562,
                "title": "max-flow-edmonds-karp-algorithm-solution-c",
                "content": "The idea is same with Hungarian, but use max flow algo to compute max matches (maximum independent set on the bipartite graph). \\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> g;\\n    vector<vector<int>> dir={{0,-1},{-1,-1},{1,-1},{0,1},{-1,1},{1,1}};\\n    int S,T;\\n    int flow;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        m=seats.size();\\n        n=seats[0].size();\\n        S=m*n;\\n        T=m*n+1;\\n        g=vector<vector<int>>(m*n+2,vector<int>(m*n+2,0));  // residual capacity \\n        int seatcnt=0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(seats[i][j]==\\'#\\') continue;\\n                seatcnt++;\\n                if(j%2==0){\\n                    g[S][i*n+j]=1;\\n                    for(int d=0;d<6;++d){\\n                        int ni=i+dir[d][0];\\n                        int nj=j+dir[d][1];\\n                        if(ni<0 || ni>=m || nj<0 || nj>=n || seats[ni][nj]==\\'#\\') continue;\\n                        g[i*n+j][ni*n+nj]=1;\\n                    }\\n                }else{\\n                    g[i*n+j][T]=1;\\n                }\\n            }\\n        }\\n        flow=0;\\n        EK();\\n        return seatcnt-flow;\\n    }\\n    \\n    void EK(){\\n        while(true){\\n            vector<int> pre(m*n+2,-1);\\n            bfs(pre);\\n            if(pre[T]==-1) break;\\n            int v=T;\\n            while(true){\\n                int u=pre[v];\\n                g[u][v]--;\\n                g[v][u]++;\\n                v=u;\\n                if(v==S) break;\\n            }\\n            flow++;\\n        }\\n    }\\n    \\n    void bfs(vector<int> &pre){\\n        queue<int> q;\\n        q.push(S);\\n        vector<int> visited(m*n+2,0);\\n        visited[S]=1;\\n        while(!q.empty()){\\n            int cur=q.front();\\n            q.pop();\\n            for(int i=0;i<m*n+2;++i){\\n                if(visited[i]==0 && g[cur][i]==1){\\n                    visited[i]=1;\\n                    q.push(i);\\n                    pre[i]=cur;\\n                }\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>> g;\\n    vector<vector<int>> dir={{0,-1},{-1,-1},{1,-1},{0,1},{-1,1},{1,1}};\\n    int S,T;\\n    int flow;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        m=seats.size();\\n        n=seats[0].size();\\n        S=m*n;\\n        T=m*n+1;\\n        g=vector<vector<int>>(m*n+2,vector<int>(m*n+2,0));  // residual capacity \\n        int seatcnt=0;\\n        for(int i=0;i<m;++i){\\n            for(int j=0;j<n;++j){\\n                if(seats[i][j]==\\'#\\') continue;\\n                seatcnt++;\\n                if(j%2==0){\\n                    g[S][i*n+j]=1;\\n                    for(int d=0;d<6;++d){\\n                        int ni=i+dir[d][0];\\n                        int nj=j+dir[d][1];\\n                        if(ni<0 || ni>=m || nj<0 || nj>=n || seats[ni][nj]==\\'#\\') continue;\\n                        g[i*n+j][ni*n+nj]=1;\\n                    }\\n                }else{\\n                    g[i*n+j][T]=1;\\n                }\\n            }\\n        }\\n        flow=0;\\n        EK();\\n        return seatcnt-flow;\\n    }\\n    \\n    void EK(){\\n        while(true){\\n            vector<int> pre(m*n+2,-1);\\n            bfs(pre);\\n            if(pre[T]==-1) break;\\n            int v=T;\\n            while(true){\\n                int u=pre[v];\\n                g[u][v]--;\\n                g[v][u]++;\\n                v=u;\\n                if(v==S) break;\\n            }\\n            flow++;\\n        }\\n    }\\n    \\n    void bfs(vector<int> &pre){\\n        queue<int> q;\\n        q.push(S);\\n        vector<int> visited(m*n+2,0);\\n        visited[S]=1;\\n        while(!q.empty()){\\n            int cur=q.front();\\n            q.pop();\\n            for(int i=0;i<m*n+2;++i){\\n                if(visited[i]==0 && g[cur][i]==1){\\n                    visited[i]=1;\\n                    q.push(i);\\n                    pre[i]=cur;\\n                }\\n            }\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090322,
                "title": "easy-to-understand-solution-backtrack-with-dp-memorization-on-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m,ans;\\n    int dp[8][8][255][255];\\n    vector<vector<char>> a;\\n    \\n    bool is(int i,int j)\\n    {\\n        if(a[i][j]!=\\'.\\') return 0;\\n        if(i-1>=0 && j-1>=0 && a[i-1][j-1]==\\'$\\') return 0;\\n        if(i-1>=0 && j+1<m && a[i-1][j+1]==\\'$\\') return 0;\\n        if(j-1>=0 && a[i][j-1]==\\'$\\') return 0;\\n        if(j+1<m && a[i][j+1]==\\'$\\') return 0;\\n        \\n        return 1;\\n    }\\n    \\n    int sol(int i,int j,int premask,int curmask)\\n    {\\n        if(i==n) return 0;\\n        if(j==m) return sol(i+1,0,curmask,0);\\n        \\n        int ans=dp[i][j][premask][curmask];\\n        if(ans!=-1) return ans;\\n        ans=0;\\n        \\n        if(is(i,j))\\n        {\\n            a[i][j]=\\'$\\';\\n            ans=max(ans,1+sol(i,j+1,premask,curmask|(1<<j)));\\n            a[i][j]=\\'.\\';\\n        }\\n        ans=max(ans,sol(i,j+1,premask,curmask));\\n                    \\n        return dp[i][j][premask][curmask]=ans;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) \\n    {\\n        a=seats;\\n        n=a.size(),m=a[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m,ans;\\n    int dp[8][8][255][255];\\n    vector<vector<char>> a;\\n    \\n    bool is(int i,int j)\\n    {\\n        if(a[i][j]!=\\'.\\') return 0;\\n        if(i-1>=0 && j-1>=0 && a[i-1][j-1]==\\'$\\') return 0;\\n        if(i-1>=0 && j+1<m && a[i-1][j+1]==\\'$\\') return 0;\\n        if(j-1>=0 && a[i][j-1]==\\'$\\') return 0;\\n        if(j+1<m && a[i][j+1]==\\'$\\') return 0;\\n        \\n        return 1;\\n    }\\n    \\n    int sol(int i,int j,int premask,int curmask)\\n    {\\n        if(i==n) return 0;\\n        if(j==m) return sol(i+1,0,curmask,0);\\n        \\n        int ans=dp[i][j][premask][curmask];\\n        if(ans!=-1) return ans;\\n        ans=0;\\n        \\n        if(is(i,j))\\n        {\\n            a[i][j]=\\'$\\';\\n            ans=max(ans,1+sol(i,j+1,premask,curmask|(1<<j)));\\n            a[i][j]=\\'.\\';\\n        }\\n        ans=max(ans,sol(i,j+1,premask,curmask));\\n                    \\n        return dp[i][j][premask][curmask]=ans;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) \\n    {\\n        a=seats;\\n        n=a.size(),m=a[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        return sol(0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833729,
                "title": "python-greedy-graph-3-steps",
                "content": "```html5\\n<b>Time Complexity: O(max(rows &middot; columns, n<sup>2</sup>))</b> where n is the number of empty seats\\n<b>Space Complexity: O(n)</b>\\n```\\n\\n**Step-by-step:** Numbers match annotations in the code.\\n\\nFirst, convert the grid of seats into a graph (steps #1 and #2).\\n\\n**(#1)** Find\\'s all empty seats **(\".\")** and store their **(row,col)** location in **nodes**.\\nAssign each empty seat an **id** where the **id** is an integer from 1 to n ~ the number of empty seats.  The **id**s are stored in **node_id**.  \\n\\n**(#2)** Find all nodes that are connected.  Hypothetical nodes **a** and **b** are connected if seat **a** can see seat **b** or seat **b** can see seat **a**.  For each node, store a list of all the nodes that are connected to it in **edges**.  \\n\\nSecond, greedily seat each student (step #3).\\n\\n**(#3.1)** Greedily seating each student means iterate over the list of open seats (nodes) and if none of the neighboring seats are already taken, then put a student in the seat and mark it as taken using a bit-mask **(taken |= 1 << node_id)**.  Once you have checked every seat once, the result is the total number of seats taken **(bin(taken).count(\\'1\\'))**.\\n\\n**(#3.2) IMPORTANT:** This greedy approach will not always work if we stop after doing step (#3.1) once.  In fact, we need to do step (#3.1) **n** times where **n** is the number of empty seats.  \\n\\nThe first time, greedily fill seats starting at the first empty seat **(start = 0)**.  The second time start at the second empty seat **(start = 1)** and greedily fill seats, then try to fill the first seat last... The 10th time **(start == 9)** start at the 10th empty seat and loop around and try to fill the first 9 empty seats last.  This guarantees that in at least one of the **n** iterations, we will start on a seat that will greedily yield the maximum number of students seated.  \\n\\n```python\\ndef maxStudents(self, seats: List[List[str]]) -> int:\\n\\n\\tres = 0\\n\\n\\t# 1. Make a list of open seats (nodes)\\n\\tnodes = []\\n\\tfor r in range(len(seats)):\\n\\t\\tfor c in range(len(seats[0])):\\n\\t\\t\\tif seats[r][c] == \\'.\\':\\n\\t\\t\\t\\tnodes.append((r,c))\\n\\tnode_id = {node:i for i,node in enumerate(nodes)}\\n\\n\\t# 2. Make a list of connected seats (edges)\\n\\tedges = collections.defaultdict(list)       \\n\\tfor r,c in nodes:\\n\\t\\tfor i,j in ((r+1,c+1), (r,c+1), (r-1,c+1)):\\n\\t\\t\\tif (i,j) in node_id:\\n\\t\\t\\t\\tedges[node_id[(i,j)]].append(node_id[(r,c)])\\n\\t\\t\\t\\tedges[node_id[(r,c)]].append(node_id[(i,j)])\\n\\n\\t# 3. Greedily fill seats\\n\\tfor start in range(len(nodes)):                       # 3.2\\n\\t\\ttaken = 0\\n\\t\\tfor i in range(start, len(nodes) + start):        # 3.1\\n\\t\\t\\ti %= len(nodes)                               # 3.2\\n\\t\\t\\tif not any((1 << j)&taken for j in edges[i]): # 3.1\\n\\t\\t\\t\\ttaken |= (1 << i)\\n\\t\\t\\tres = max(res, bin(taken).count(\\'1\\'))         # 3.1\\n\\n\\treturn res\\n```\\n<img src=\"https://assets.leetcode.com/users/images/e3a9633f-9403-401f-8716-48b918178d2b_1599454447.6826067.png\" width=\"50%\">\\n",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Bitmask"
                ],
                "code": "```html5\\n<b>Time Complexity: O(max(rows &middot; columns, n<sup>2</sup>))</b> where n is the number of empty seats\\n<b>Space Complexity: O(n)</b>\\n```\n```python\\ndef maxStudents(self, seats: List[List[str]]) -> int:\\n\\n\\tres = 0\\n\\n\\t# 1. Make a list of open seats (nodes)\\n\\tnodes = []\\n\\tfor r in range(len(seats)):\\n\\t\\tfor c in range(len(seats[0])):\\n\\t\\t\\tif seats[r][c] == \\'.\\':\\n\\t\\t\\t\\tnodes.append((r,c))\\n\\tnode_id = {node:i for i,node in enumerate(nodes)}\\n\\n\\t# 2. Make a list of connected seats (edges)\\n\\tedges = collections.defaultdict(list)       \\n\\tfor r,c in nodes:\\n\\t\\tfor i,j in ((r+1,c+1), (r,c+1), (r-1,c+1)):\\n\\t\\t\\tif (i,j) in node_id:\\n\\t\\t\\t\\tedges[node_id[(i,j)]].append(node_id[(r,c)])\\n\\t\\t\\t\\tedges[node_id[(r,c)]].append(node_id[(i,j)])\\n\\n\\t# 3. Greedily fill seats\\n\\tfor start in range(len(nodes)):                       # 3.2\\n\\t\\ttaken = 0\\n\\t\\tfor i in range(start, len(nodes) + start):        # 3.1\\n\\t\\t\\ti %= len(nodes)                               # 3.2\\n\\t\\t\\tif not any((1 << j)&taken for j in edges[i]): # 3.1\\n\\t\\t\\t\\ttaken |= (1 << i)\\n\\t\\t\\tres = max(res, bin(taken).count(\\'1\\'))         # 3.1\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503772,
                "title": "7-lines-python-dp",
                "content": "```\\ndef maxStudents(self, seats):\\n    m = {0: 0}\\n    for row in seats:\\n        m = {b: bin(b).count(\\'1\\') + max(m[p] for p in m if not b & (p << 1) if not p & (b << 1))\\n             for b in range(2**len(row))\\n             if not b & (b << 1)\\n             if not any(seat == \\'#\\' and b & (1 << i) for i, seat in enumerate(row))}\\n    return max(m.values())\\n```\\nAccepted in 44 ms.\\n`b` is the bitmask of students in the current row\\n`p` is the bitmask of students in the previous row (i.e., the row in front)\\n`m[bitmask]` is the maximum number of students so far which ended in the bitmask\\nFrom one row to the next, consider any valid bitmask `b` and combine it with any compatible previous bitmask `p`.\\n",
                "solutionTags": [],
                "code": "```\\ndef maxStudents(self, seats):\\n    m = {0: 0}\\n    for row in seats:\\n        m = {b: bin(b).count(\\'1\\') + max(m[p] for p in m if not b & (p << 1) if not p & (b << 1))\\n             for b in range(2**len(row))\\n             if not b & (b << 1)\\n             if not any(seat == \\'#\\' and b & (1 << i) for i, seat in enumerate(row))}\\n    return max(m.values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503734,
                "title": "c-backtracking-exceeding-time-limit",
                "content": "This method exceeds time limit but is a corrrect solution. Any way to speed this up?\\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats)\\n    {\\n        int res = 0;\\n        solveBoard(seats, 0, 0, res);\\n        return res;\\n    }\\nprivate:\\n    inline bool isSafe(int i, int j, vector<vector<char>>& seats)\\n    {\\n        if (seats[i][j] == \\'#\\') // broken seat\\n            return false;\\n        if (j - 1 >= 0 && seats[i][j - 1] == \\'*\\')\\n            return false;\\n\\t   //\\tnot needed, there are no students seated to the right of the current\\n       // if (j + 1 < seats[0].size() && seats[i][j + 1] == \\'*\\')\\n       //     return false;\\n        if (j - 1 >= 0 && i - 1 >= 0 && seats[i - 1][j - 1] == \\'*\\')\\n            return false;\\n        if (j + 1 < seats[0].size() && i - 1 >= 0 && seats[i - 1][j + 1] == \\'*\\')\\n            return false;\\n        return true;\\n    }\\n\\n    void solveBoard(vector<vector<char>>& seats, int cur, int seated, int& res)\\n    {\\n        int n = seats.size();\\n        int m = seats[0].size();\\n\\n        if (cur == m * n)\\n        {\\n            res = max(res, seated);\\n            return;\\n        }\\n        \\n        int row = cur / m;\\n        int col = cur % m;\\n        if (isSafe(row, col, seats))\\n        {\\n            seats[row][col] = \\'*\\';\\n            // seat student\\n            solveBoard(seats, cur + 1, seated + 1, res);               \\n            // backtrack\\n            seats[row][col] = \\'.\\';\\n        }\\n        // just continue without seating student\\n        solveBoard(seats, cur + 1, seated, res);\\n    }    \\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats)\\n    {\\n        int res = 0;\\n        solveBoard(seats, 0, 0, res);\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 503475,
                "title": "clean-java",
                "content": "I notice the seats board is pretty small (8 * 8), so I just use brute force to explore it.\\n```\\nclass Solution {\\n    int m, n;\\n    Map<String, Integer> memo;\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, -1}, {1, 1}};\\n    public int maxStudents(char[][] seats) {\\n        m = seats.length;\\n        n = seats[0].length;\\n        memo = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char[] row : seats) sb.append(row);\\n        return dfs(sb.toString());\\n    }\\n    \\n    private int dfs(String state) {\\n        if (memo.containsKey(state)) return memo.get(state);\\n        int res = 0;\\n        char[] s = state.toCharArray();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s[i * n + j] == \\'.\\') {\\n                    s[i * n + j] = \\'x\\';  //pick empty seat\\n                    res = Math.max(res, dfs(new String(s))); //\\u653E\\u5F03seat\\uFF0C\\u6211\\u4EEC\\u8FD9\\u91CC\\u4E0D+1\\n                    for (int[] dir : dirs) { //lock seats\\n                        int x = i + dir[0], y = j + dir[1];\\n                        if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n                        if (s[x * n + y] == \\'.\\') s[x * n + y] = \\'x\\';\\n                    }\\n                    res = Math.max(res, dfs(new String(s)) + 1); //1\\uFF0C3\\u95F4\\u9694\\u7684\\u70B9\\u5728\\u8FD9\\u91CC\\u88AB\\u8986\\u76D6\\u5230\\u4E86\\u3002\\u53EA\\u6709ban seat\\u4E4B\\u540E\\u6211\\u4EEC\\u7B97+1\\n                }\\n            }\\n        }\\n        memo.put(state, res);\\n        return res;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    char[][] seats;\\n    int m;\\n    int n;\\n    public int maxStudents(char[][] seats) {\\n        this.seats = seats;\\n        this.m = seats.length;\\n        this.n = seats[0].length;\\n        int res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'.\\') {\\n                    int[] tmp = new int[1];\\n                    dfs(i, j, tmp, copy(seats));\\n                    res = Math.max(res, tmp[0]);\\n                } \\n        return res;\\n    }\\n    \\n    int[][] dirs = {{0, 1}, {0, -1}, {-1, -1}, {-1, 1}};\\n    \\n    private void dfs(int startX, int startY, int[] res, char[][] seats) {\\n        seats[startX][startY] = \\'X\\';\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (seats[x][y] == \\'.\\') seats[x][y] = \\'#\\';\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'.\\')\\n                    if (checkValid(i, j, seats))\\n                        banSeat(i, j, seats);\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'X\\') res[0]++;\\n    }\\n    \\n    private void banSeat(int startX, int startY, char[][] seats) {\\n        seats[startX][startY] = \\'X\\';\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            seats[x][y] = \\'#\\';\\n        }\\n    }\\n    \\n    private boolean checkValid(int startX, int startY, char[][] seats) {\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (seats[x][y] == \\'X\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    private char[][] copy(char[][] seats) {\\n        char[][] tmp = new char[m][n];\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                tmp[i][j] = seats[i][j];\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int m, n;\\n    Map<String, Integer> memo;\\n    int[][] dirs = {{0, 1}, {0, -1}, {1, -1}, {1, 1}};\\n    public int maxStudents(char[][] seats) {\\n        m = seats.length;\\n        n = seats[0].length;\\n        memo = new HashMap<>();\\n        StringBuilder sb = new StringBuilder();\\n        for (char[] row : seats) sb.append(row);\\n        return dfs(sb.toString());\\n    }\\n    \\n    private int dfs(String state) {\\n        if (memo.containsKey(state)) return memo.get(state);\\n        int res = 0;\\n        char[] s = state.toCharArray();\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (s[i * n + j] == \\'.\\') {\\n                    s[i * n + j] = \\'x\\';  //pick empty seat\\n                    res = Math.max(res, dfs(new String(s))); //\\u653E\\u5F03seat\\uFF0C\\u6211\\u4EEC\\u8FD9\\u91CC\\u4E0D+1\\n                    for (int[] dir : dirs) { //lock seats\\n                        int x = i + dir[0], y = j + dir[1];\\n                        if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n                        if (s[x * n + y] == \\'.\\') s[x * n + y] = \\'x\\';\\n                    }\\n                    res = Math.max(res, dfs(new String(s)) + 1); //1\\uFF0C3\\u95F4\\u9694\\u7684\\u70B9\\u5728\\u8FD9\\u91CC\\u88AB\\u8986\\u76D6\\u5230\\u4E86\\u3002\\u53EA\\u6709ban seat\\u4E4B\\u540E\\u6211\\u4EEC\\u7B97+1\\n                }\\n            }\\n        }\\n        memo.put(state, res);\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    char[][] seats;\\n    int m;\\n    int n;\\n    public int maxStudents(char[][] seats) {\\n        this.seats = seats;\\n        this.m = seats.length;\\n        this.n = seats[0].length;\\n        int res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'.\\') {\\n                    int[] tmp = new int[1];\\n                    dfs(i, j, tmp, copy(seats));\\n                    res = Math.max(res, tmp[0]);\\n                } \\n        return res;\\n    }\\n    \\n    int[][] dirs = {{0, 1}, {0, -1}, {-1, -1}, {-1, 1}};\\n    \\n    private void dfs(int startX, int startY, int[] res, char[][] seats) {\\n        seats[startX][startY] = \\'X\\';\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (seats[x][y] == \\'.\\') seats[x][y] = \\'#\\';\\n        }\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'.\\')\\n                    if (checkValid(i, j, seats))\\n                        banSeat(i, j, seats);\\n        \\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (seats[i][j] == \\'X\\') res[0]++;\\n    }\\n    \\n    private void banSeat(int startX, int startY, char[][] seats) {\\n        seats[startX][startY] = \\'X\\';\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            seats[x][y] = \\'#\\';\\n        }\\n    }\\n    \\n    private boolean checkValid(int startX, int startY, char[][] seats) {\\n        for (int[] dir : dirs) {\\n            int x = startX + dir[0], y = startY + dir[1];\\n            if (x < 0 || x >= m || y < 0 || y >= n) continue;\\n            if (seats[x][y] == \\'X\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    private char[][] copy(char[][] seats) {\\n        char[][] tmp = new char[m][n];\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                tmp[i][j] = seats[i][j];\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503433,
                "title": "python-dfs-with-memorization",
                "content": "Basically you don\\'t have to record every seats you\\'ve used, but just the seats in the current row and previous row, otherwise would result in TLE.\\nIf I want to check a cell in previous row, say on the ***j*** th column,  I would directly use ***mask & 1 << j*** to check. Otherwise for the cell in current row, I would use ***mask & 1 << (cl + j)*** to check, where ***cl*** is the number of columns.\\n\\nTime complexity: O(m * 2 ^ (2n)) = O(m * 4 ^ n), where m and n is the number of rows and columns respectively.\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        rl, cl = len(seats), len(seats[0])\\n        \\n        #get the new cell to the right\\n        def getNextSeat(x,y):\\n            return (x, y + 1) if y < cl - 1 else (x + 1, 0)\\n        \\n        #transform the mask when switch to a new row by truncate the first \"cl\"\\n        #number of digit in the binary representation of the bit-mask number\\n        def transform(mask):\\n            ans = 0\\n            for i in range(cl, 2 * cl):\\n                if mask & 1 << i:\\n                    ans |= 1 << (i - cl)\\n            return ans\\n        \\n        #x and y is the row and column of current position, mask is a bit-mask number that records the seats being used\\n        #in the previous row and current row, so the length of binary representation of \\'mask\\' is 2 * column number, where\\n\\t\\t#first cl number of digit for previous row, and the rest for current row\\n        @lru_cache(None)\\n        def solve(x, y, mask):\\n            #reach the end\\n            if x == rl:\\n                return 0\\n            #reach a new row\\n            if not y:\\n                mask = transform(mask)\\n            #get the next seat x and y coordinates\\n            nextSeatX, nextSeatY = getNextSeat(x,y)\\n            #case that not to use current seat\\n            ans = solve(nextSeatX, nextSeatY, mask)\\n            if seats[x][y] == \\'#\\':\\n                return ans\\n            #Check the other seats nearby\\n            for d in ((0,-1),(-1,1),(-1,-1)):\\n                nx, ny = x + d[0], y + d[1]\\n                #Found a nearby seat being used, which makes current seat unavailable\\n                if 0 <= nx < rl and 0 <= ny < cl and mask & 1 << ((nx == x) * cl + ny):\\n                    break\\n            else:\\n                #Case that occupy the seat at current position\\n                ans = max(ans, solve(nextSeatX, nextSeatY, mask | 1 << (cl + y)) + 1)\\n            return ans\\n        \\n        return solve(0,0,0)",
                "solutionTags": [],
                "code": "Basically you don\\'t have to record every seats you\\'ve used, but just the seats in the current row and previous row, otherwise would result in TLE.\\nIf I want to check a cell in previous row, say on the ***j*** th column,  I would directly use ***mask & 1 << j*** to check. Otherwise for the cell in current row, I would use ***mask & 1 << (cl + j)*** to check, where ***cl*** is the number of columns.\\n\\nTime complexity: O(m * 2 ^ (2n)) = O(m * 4 ^ n), where m and n is the number of rows and columns respectively.\\n```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        rl, cl = len(seats), len(seats[0])\\n        \\n        #get the new cell to the right\\n        def getNextSeat(x,y):\\n            return (x, y + 1) if y < cl - 1 else (x + 1, 0)\\n        \\n        #transform the mask when switch to a new row by truncate the first \"cl\"\\n        #number of digit in the binary representation of the bit-mask number\\n        def transform(mask):\\n            ans = 0\\n            for i in range(cl, 2 * cl):\\n                if mask & 1 << i:\\n                    ans |= 1 << (i - cl)\\n            return ans\\n        \\n        #x and y is the row and column of current position, mask is a bit-mask number that records the seats being used\\n        #in the previous row and current row, so the length of binary representation of \\'mask\\' is 2 * column number, where\\n\\t\\t#first cl number of digit for previous row, and the rest for current row\\n        @lru_cache(None)\\n        def solve(x, y, mask):\\n            #reach the end\\n            if x == rl:\\n                return 0\\n            #reach a new row\\n            if not y:\\n                mask = transform(mask)\\n            #get the next seat x and y coordinates\\n            nextSeatX, nextSeatY = getNextSeat(x,y)\\n            #case that not to use current seat\\n            ans = solve(nextSeatX, nextSeatY, mask)\\n            if seats[x][y] == \\'#\\':\\n                return ans\\n            #Check the other seats nearby\\n            for d in ((0,-1),(-1,1),(-1,-1)):\\n                nx, ny = x + d[0], y + d[1]\\n                #Found a nearby seat being used, which makes current seat unavailable\\n                if 0 <= nx < rl and 0 <= ny < cl and mask & 1 << ((nx == x) * cl + ny):\\n                    break\\n            else:\\n                #Case that occupy the seat at current position\\n                ans = max(ans, solve(nextSeatX, nextSeatY, mask | 1 << (cl + y)) + 1)\\n            return ans\\n        \\n        return solve(0,0,0)",
                "codeTag": "Java"
            },
            {
                "id": 764477,
                "title": "python-a-good-practice-of-hungarian",
                "content": "As wxy9018 [points out](https://leetcode.com/problems/maximum-students-taking-exam/discuss/503790/Python-Hungarian-Time-O(m2*n2)-Space-O(m*n)-beat-100) , this is a bipartite matching.\\nAll the available seats in odd columes are in set A and all the available seats in even columes are in set B. If two seats can cheat with each other, there is an edge between them. There is no edge between nodes within A or B. So its a bipartite graph.\\n\\nThen we can use Hungarian to find out the maximum matchings. We have to remove one node for each match. Then the nodes left cannot cheat with each other.\\n\\nIf you can find out another \"cheat\" pair after the removal, then you didn\\'t find out maximum matchings previously as these two nodes can still be paired. Hungarian bascially keep updating the pairing to increase matching number to eliminate such case.\\n\\nE.g. A-B-C-D:\\nIf you choose match B and C. Then after remove B or C, either C can cheat with D or A can cheat with B. Then you don\\'t find the maximum matchings as A matches B and C matches D.\\n\\n```\\ndef maxStudents(seats):\\n    m, n = len(seats), len(seats[0])\\n    match = [[-1] * n for _ in range(m)]\\n\\tvis = [[-1] * n for _ in range(m)]\\n\\n    def dfs(i, j, v):\\n        for x, y in ((i-1,j-1),(i,j-1),(i+1,j-1),(i-1,j+1),(i,j+1),(i+1,j+1)):\\n            if 0 <= x < m and 0 <= y < n and seats[x][y] == \\'.\\' and vis[x][y] != v:\\n                vis[x][y] = v\\n                if match[x][y] == -1 or dfs(*divmod(match[x][y], n), v):\\n                    match[x][y] = i*n+j\\n                    match[i][j] = x*n+y\\n                    return 1\\n        return 0\\n\\n    def hungarian():\\n        cnt = v = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if seats[i][j] == \\'.\\' and match[i][j] == -1:\\n\\t\\t\\t\\t    vis[i][j] = v\\n                    cnt += dfs(i, j, v)\\n\\t\\t\\t\\t\\tv += 1\\n        return cnt\\n\\n    return sum(seats[i][j] == \\'.\\' for i in range(m) for j in range(n)) - hungarian()\\n```\\n\\nThe complexity of Hungarian is O(VE)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxStudents(seats):\\n    m, n = len(seats), len(seats[0])\\n    match = [[-1] * n for _ in range(m)]\\n\\tvis = [[-1] * n for _ in range(m)]\\n\\n    def dfs(i, j, v):\\n        for x, y in ((i-1,j-1),(i,j-1),(i+1,j-1),(i-1,j+1),(i,j+1),(i+1,j+1)):\\n            if 0 <= x < m and 0 <= y < n and seats[x][y] == \\'.\\' and vis[x][y] != v:\\n                vis[x][y] = v\\n                if match[x][y] == -1 or dfs(*divmod(match[x][y], n), v):\\n                    match[x][y] = i*n+j\\n                    match[i][j] = x*n+y\\n                    return 1\\n        return 0\\n\\n    def hungarian():\\n        cnt = v = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if seats[i][j] == \\'.\\' and match[i][j] == -1:\\n\\t\\t\\t\\t    vis[i][j] = v\\n                    cnt += dfs(i, j, v)\\n\\t\\t\\t\\t\\tv += 1\\n        return cnt\\n\\n    return sum(seats[i][j] == \\'.\\' for i in range(m) for j in range(n)) - hungarian()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 512715,
                "title": "java-bitmask",
                "content": "```\\n    public int maxStudents(char[][] s) {\\n        int m = s.length, n = s[0].length;\\n        int[] mask = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mask[i] =(mask[i] << 1) + (s[i][j] == \\'.\\' ? 1 : 0);\\n            }\\n        }\\n        \\n        int state = (1 << n);\\n        int[][] dp = new int[m][state];\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < state; j++) {\\n                if( (j & mask[i]) == j && ((j >> 1) & j) == 0 ) {\\n                    if (i == 0) {\\n                        dp[i][j] = Integer.bitCount(j);\\n                    } else {\\n                        for (int k = 0; k < state; k++) {\\n                            if ((dp[i - 1][k] != -1)\\n                                && (((k >> 1) & j) == 0) \\n                                && (k & (j >> 1)) == 0) {\\n                                \\n                                dp[i][j] = Math.max(dp[i][j], dp[i-1][k] + Integer.bitCount(j));\\n                            }\\n                        }\\n                    }\\n                    ans = Math.max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int maxStudents(char[][] s) {\\n        int m = s.length, n = s[0].length;\\n        int[] mask = new int[m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mask[i] =(mask[i] << 1) + (s[i][j] == \\'.\\' ? 1 : 0);\\n            }\\n        }\\n        \\n        int state = (1 << n);\\n        int[][] dp = new int[m][state];\\n        \\n        int ans = 0;\\n        for (int i = 0; i < m; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < state; j++) {\\n                if( (j & mask[i]) == j && ((j >> 1) & j) == 0 ) {\\n                    if (i == 0) {\\n                        dp[i][j] = Integer.bitCount(j);\\n                    } else {\\n                        for (int k = 0; k < state; k++) {\\n                            if ((dp[i - 1][k] != -1)\\n                                && (((k >> 1) & j) == 0) \\n                                && (k & (j >> 1)) == 0) {\\n                                \\n                                dp[i][j] = Math.max(dp[i][j], dp[i-1][k] + Integer.bitCount(j));\\n                            }\\n                        }\\n                    }\\n                    ans = Math.max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2475512,
                "title": "ford-fulkerson-max-flow-max-matching-min-vertex-cover-max-independent-set-python",
                "content": "The docstring explains why we can solve this problem using the Ford-Fulkerson method. My understanding of this was aided by [another user\\'s solution](https://leetcode.com/problems/maximum-students-taking-exam/discuss/1460292/Python-oror-Ford-Fulkerson-with-DFS-oror-high-level-explanation). But it turns out that the relationship between vertex covers, matching, and cliques is well known to folks with an academic background in CS (not me).\\n```python\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \"\"\"We can regard the matrix of seats as defining a graph, wherein an\\n        edge exists from a seat u to a seat v iff u can see v and neither u nor\\n        v is a broken seat.\\n    \\n        Observe that the maximum number of students that can take the exam\\n        together without the possibility of cheating is equal to the size of a\\n        maximum independent set in this graph -- that is, a set of vertices no\\n        two of which are adjacent, and such that no set of larger cardinality\\n        has this property.\\n    \\n        We\\'ll compute the size of a maximum independent set indirectly, by\\n        first computing the size of a minimum vertex cover -- that is, a set of\\n        vertices that includes at least one endpoint from each edge, and such\\n        that no set of smaller cardinality has this property. Since the\\n        complement of a vertex cover is an independent set, the complement of a\\n        minimum vertex cover is a maximum independent set. Therefore the size\\n        of a maximum independent set is equal to the total number of vertices\\n        minus the size of a minimum vertex cover.\\n    \\n        In a further act of indirection, we\\'ll compute the size of a minimum\\n        vertex cover in terms of the size of a maximum matching -- that is, a\\n        set of edges no two of which share an endpoint, and such that no set of\\n        larger cardinality has this property. Konig\\'s theorem tells us that\\n        these two sizes are equal in any bipartite graph, and we can easily see\\n        that our graph is bipartite: if we color the seats in even columns red\\n        and the seats in odd columns green, then no edge connects two vertices\\n        of the same color.\\n    \\n        Finally, through yet one more layer of indirection, we\\'ll compute the\\n        size of a maximum matching in our bipartite graph by computing the\\n        maximum flow between a \"virtual\" source and sink added to our graph,\\n        where the sink has a unit-weight edge to each red vertex, each red\\n        vertex has a unit-weight edge to each green vertex, and each green\\n        vertex has a unit-weight edge to the sink. This computation will\\n        leverage the Ford-Fulkerson method.\\n    \\n        In short, the maximum number of students who can take the exam without\\n        the possibility of cheating equals the total number of vertices minus\\n        the maximum flow as computed by the Ford-Fulkerson method.\\n    \\n        Time complexity: O(mn + max_flow * V^2)\\n        - O(mn) to enumerate the nonbroken seats\\n        - O(max_flow * V^2) to compute maximum flow; using adjacency lists\\n          instead of an adjacency matrix, and finding augmenting paths with\\n          BFS instead of DFS would achieve O(mn + V * E^2)\\n    \\n        Space complexity: O(V^2)\\n        - O(V^2) to track capacities and flows; using adjacency lists instead\\n          of an adjacency matrix would achieve O(E)\\n    \\n    \\n        EXAMPLES:\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\".\",\".\",\".\",\"#\"],\\n        ...         [\".\",\"#\",\".\",\"#\",\".\"],\\n        ...         [\".\",\".\",\"#\",\".\",\".\"],\\n        ...         [\".\",\"#\",\".\",\"#\",\".\"],\\n        ...         [\"#\",\".\",\".\",\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        10\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\\n        ...         [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        4\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\".\",\"#\"],\\n        ...         [\"#\",\"#\"],\\n        ...         [\"#\",\".\"],\\n        ...         [\"#\",\"#\"],\\n        ...         [\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        3\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\"#\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\".\",\"#\",\".\",\".\"],\\n        ...         [\"#\",\".\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\".\",\".\",\".\",\".\"],\\n        ...         [\".\",\".\",\".\",\"#\",\".\"]\\n        ...     ]\\n        ...  )\\n        9\\n        \"\"\"\\n        dim_row = len(seats)\\n        dim_col = len(seats[0])\\n    \\n\\t    # This part is O(mn).\\n        nonbroken_seats = OrderedDict(\\n            ((i, j), True)\\n            for i in range(dim_row)\\n            for j in range(dim_col)\\n            if seats[i][j] == \".\"\\n        )\\n    \\n        # Assign successive integer IDs to the nonbroken seats. These IDs will be\\n        # the vertices in our flow network.\\n        vtx_by_seat = {(i, j): u for u, (i, j) in enumerate(nonbroken_seats)}\\n    \\n        # Two additional vertices for virtual source and sink, as needed to compute\\n        # a maximum bipartite matching by way of computing a maximum flow.\\n        num_vtx = len(vtx_by_seat) + 2\\n        source = num_vtx - 2\\n        sink = num_vtx - 1\\n    \\n        # Establish edge capacities in the flow network, according to which nonbroken\\n        # seats can see which other nonbroken seats.\\n        capacity = [[0] * num_vtx for _ in range(num_vtx)]\\n        for (i, j), u in vtx_by_seat.items():\\n            if j % 2 == 0:\\n                # Every even-column seat has an edge from the source.\\n                capacity[source][u] = 1\\n    \\n                neighbor_positions = (\\n                    (i, j - 1),\\n                    (i, j + 1),\\n                    (i - 1, j - 1),\\n                    (i - 1, j + 1),\\n                    (i + 1, j - 1),\\n                    (i + 1, j + 1),\\n                )\\n    \\n                neighbor_vertices = {\\n                    vtx_by_seat[v] for v in neighbor_positions if v in nonbroken_seats\\n                }\\n    \\n                # Every even-column seat has an edge to each odd-column seat that\\n                # either (a) can see the even-column seat, or (b) can be seen by the\\n                # even-column seat.\\n                for v in neighbor_vertices:\\n                    capacity[u][v] = 1\\n            else:\\n                # Every odd-column seat has an edge to the sink.\\n                capacity[u][sink] = 1\\n    \\n        flow = [[0] * num_vtx for _ in range(num_vtx)]\\n        visited = [0 for _ in range(num_vtx)]\\n        visited_token = 1\\n        max_flow = 0\\n    \\n        def find_flow(u: int, found_flow: float = float(\"inf\")) -> int:\\n            visited[u] = visited_token\\n    \\n            if u == sink and found_flow > 0:\\n                return int(found_flow)\\n            else:\\n                for v in range(num_vtx):\\n                    residual = capacity[u][v] - flow[u][v]\\n    \\n                    if residual > 0 and visited[v] != visited_token:\\n                        ff = find_flow(v, min(found_flow, residual))\\n    \\n                        if ff > 0:\\n                            flow[u][v] += ff\\n                            flow[v][u] -= ff\\n                            return ff\\n    \\n            return 0\\n    \\n        # Apply the Ford-Fulkerson method to compute the maximum flow. That is, as\\n        # long as you can find an augmenting path from the source to the sink,\\n        # apply a unit of flow along that path. This part is O(max_flow * V^2).\\n        while (found_flow := find_flow(source)) > 0:\\n            max_flow += found_flow\\n            visited_token += 1\\n    \\n        # Minus two to account for virtual source and sink.\\n        return num_vtx - 2 - max_flow\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import OrderedDict\\n\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \"\"\"We can regard the matrix of seats as defining a graph, wherein an\\n        edge exists from a seat u to a seat v iff u can see v and neither u nor\\n        v is a broken seat.\\n    \\n        Observe that the maximum number of students that can take the exam\\n        together without the possibility of cheating is equal to the size of a\\n        maximum independent set in this graph -- that is, a set of vertices no\\n        two of which are adjacent, and such that no set of larger cardinality\\n        has this property.\\n    \\n        We\\'ll compute the size of a maximum independent set indirectly, by\\n        first computing the size of a minimum vertex cover -- that is, a set of\\n        vertices that includes at least one endpoint from each edge, and such\\n        that no set of smaller cardinality has this property. Since the\\n        complement of a vertex cover is an independent set, the complement of a\\n        minimum vertex cover is a maximum independent set. Therefore the size\\n        of a maximum independent set is equal to the total number of vertices\\n        minus the size of a minimum vertex cover.\\n    \\n        In a further act of indirection, we\\'ll compute the size of a minimum\\n        vertex cover in terms of the size of a maximum matching -- that is, a\\n        set of edges no two of which share an endpoint, and such that no set of\\n        larger cardinality has this property. Konig\\'s theorem tells us that\\n        these two sizes are equal in any bipartite graph, and we can easily see\\n        that our graph is bipartite: if we color the seats in even columns red\\n        and the seats in odd columns green, then no edge connects two vertices\\n        of the same color.\\n    \\n        Finally, through yet one more layer of indirection, we\\'ll compute the\\n        size of a maximum matching in our bipartite graph by computing the\\n        maximum flow between a \"virtual\" source and sink added to our graph,\\n        where the sink has a unit-weight edge to each red vertex, each red\\n        vertex has a unit-weight edge to each green vertex, and each green\\n        vertex has a unit-weight edge to the sink. This computation will\\n        leverage the Ford-Fulkerson method.\\n    \\n        In short, the maximum number of students who can take the exam without\\n        the possibility of cheating equals the total number of vertices minus\\n        the maximum flow as computed by the Ford-Fulkerson method.\\n    \\n        Time complexity: O(mn + max_flow * V^2)\\n        - O(mn) to enumerate the nonbroken seats\\n        - O(max_flow * V^2) to compute maximum flow; using adjacency lists\\n          instead of an adjacency matrix, and finding augmenting paths with\\n          BFS instead of DFS would achieve O(mn + V * E^2)\\n    \\n        Space complexity: O(V^2)\\n        - O(V^2) to track capacities and flows; using adjacency lists instead\\n          of an adjacency matrix would achieve O(E)\\n    \\n    \\n        EXAMPLES:\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\".\",\".\",\".\",\"#\"],\\n        ...         [\".\",\"#\",\".\",\"#\",\".\"],\\n        ...         [\".\",\".\",\"#\",\".\",\".\"],\\n        ...         [\".\",\"#\",\".\",\"#\",\".\"],\\n        ...         [\"#\",\".\",\".\",\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        10\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\".\",\"#\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\"#\",\"#\",\"#\",\"#\",\".\"],\\n        ...         [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        4\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\".\",\"#\"],\\n        ...         [\"#\",\"#\"],\\n        ...         [\"#\",\".\"],\\n        ...         [\"#\",\"#\"],\\n        ...         [\".\",\"#\"]\\n        ...     ]\\n        ...  )\\n        3\\n    \\n        >>> max_students(\\n        ...     [\\n        ...         [\"#\",\"#\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\".\",\"#\",\".\",\".\"],\\n        ...         [\"#\",\".\",\"#\",\".\",\"#\"],\\n        ...         [\".\",\".\",\".\",\".\",\".\"],\\n        ...         [\".\",\".\",\".\",\"#\",\".\"]\\n        ...     ]\\n        ...  )\\n        9\\n        \"\"\"\\n        dim_row = len(seats)\\n        dim_col = len(seats[0])\\n    \\n\\t    # This part is O(mn).\\n        nonbroken_seats = OrderedDict(\\n            ((i, j), True)\\n            for i in range(dim_row)\\n            for j in range(dim_col)\\n            if seats[i][j] == \".\"\\n        )\\n    \\n        # Assign successive integer IDs to the nonbroken seats. These IDs will be\\n        # the vertices in our flow network.\\n        vtx_by_seat = {(i, j): u for u, (i, j) in enumerate(nonbroken_seats)}\\n    \\n        # Two additional vertices for virtual source and sink, as needed to compute\\n        # a maximum bipartite matching by way of computing a maximum flow.\\n        num_vtx = len(vtx_by_seat) + 2\\n        source = num_vtx - 2\\n        sink = num_vtx - 1\\n    \\n        # Establish edge capacities in the flow network, according to which nonbroken\\n        # seats can see which other nonbroken seats.\\n        capacity = [[0] * num_vtx for _ in range(num_vtx)]\\n        for (i, j), u in vtx_by_seat.items():\\n            if j % 2 == 0:\\n                # Every even-column seat has an edge from the source.\\n                capacity[source][u] = 1\\n    \\n                neighbor_positions = (\\n                    (i, j - 1),\\n                    (i, j + 1),\\n                    (i - 1, j - 1),\\n                    (i - 1, j + 1),\\n                    (i + 1, j - 1),\\n                    (i + 1, j + 1),\\n                )\\n    \\n                neighbor_vertices = {\\n                    vtx_by_seat[v] for v in neighbor_positions if v in nonbroken_seats\\n                }\\n    \\n                # Every even-column seat has an edge to each odd-column seat that\\n                # either (a) can see the even-column seat, or (b) can be seen by the\\n                # even-column seat.\\n                for v in neighbor_vertices:\\n                    capacity[u][v] = 1\\n            else:\\n                # Every odd-column seat has an edge to the sink.\\n                capacity[u][sink] = 1\\n    \\n        flow = [[0] * num_vtx for _ in range(num_vtx)]\\n        visited = [0 for _ in range(num_vtx)]\\n        visited_token = 1\\n        max_flow = 0\\n    \\n        def find_flow(u: int, found_flow: float = float(\"inf\")) -> int:\\n            visited[u] = visited_token\\n    \\n            if u == sink and found_flow > 0:\\n                return int(found_flow)\\n            else:\\n                for v in range(num_vtx):\\n                    residual = capacity[u][v] - flow[u][v]\\n    \\n                    if residual > 0 and visited[v] != visited_token:\\n                        ff = find_flow(v, min(found_flow, residual))\\n    \\n                        if ff > 0:\\n                            flow[u][v] += ff\\n                            flow[v][u] -= ff\\n                            return ff\\n    \\n            return 0\\n    \\n        # Apply the Ford-Fulkerson method to compute the maximum flow. That is, as\\n        # long as you can find an augmenting path from the source to the sink,\\n        # apply a unit of flow along that path. This part is O(max_flow * V^2).\\n        while (found_flow := find_flow(source)) > 0:\\n            max_flow += found_flow\\n            visited_token += 1\\n    \\n        # Minus two to account for virtual source and sink.\\n        return num_vtx - 2 - max_flow\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504406,
                "title": "c-dfs-memo-o-n-2-m",
                "content": "sub result only depends previous row status.\\nwithout memo, time complexity will be 2^nm\\nwith memo, it will be improved to be n*2^m\\n\\n```\\npublic int MaxStudents(char[][] seats) {\\n\\n\\tDictionary<string, int> dic = new Dictionary<string, int>();\\n\\n\\treturn dfs(0, 0, seats, dic);\\n}\\n\\n\\nint dfs(int i, int j, char[][] seats, Dictionary<string, int> dic)\\n{\\n\\tint n = seats.Length;\\n\\tint m = seats[0].Length;\\n\\n\\tif(j == m)\\n\\t{\\n\\t\\tstring key = i.ToString() + \"_\" + new string(seats[i]);\\n\\n\\t\\tif(dic.ContainsKey(key))\\n\\t\\t\\treturn dic[key];\\n\\n\\t\\tdic[key] = dfs(i+1, 0, seats, dic);\\n\\n\\t\\treturn dic[key];\\n\\t}\\n\\tif(i == n)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tchar c = seats[i][j];\\n\\n\\tint res = 0;\\n\\n\\tres = Math.Max(res, dfs(i, j+1, seats, dic));\\n\\n\\tif(c == \\'.\\' \\n\\t   && (j == 0 || seats[i][j-1] != \\'p\\')\\n\\t   && (j == 0 || i == 0 || seats[i-1][j-1] != \\'p\\')\\n\\t   && (j == m-1 || i == 0 || seats[i-1][j+1] != \\'p\\'))\\n\\t{\\n\\t\\tseats[i][j] = \\'p\\';\\n\\t\\tres = Math.Max(res, 1 + dfs(i, j+1, seats, dic));\\n\\t\\tseats[i][j] = \\'.\\';\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxStudents(char[][] seats) {\\n\\n\\tDictionary<string, int> dic = new Dictionary<string, int>();\\n\\n\\treturn dfs(0, 0, seats, dic);\\n}\\n\\n\\nint dfs(int i, int j, char[][] seats, Dictionary<string, int> dic)\\n{\\n\\tint n = seats.Length;\\n\\tint m = seats[0].Length;\\n\\n\\tif(j == m)\\n\\t{\\n\\t\\tstring key = i.ToString() + \"_\" + new string(seats[i]);\\n\\n\\t\\tif(dic.ContainsKey(key))\\n\\t\\t\\treturn dic[key];\\n\\n\\t\\tdic[key] = dfs(i+1, 0, seats, dic);\\n\\n\\t\\treturn dic[key];\\n\\t}\\n\\tif(i == n)\\n\\t{\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tchar c = seats[i][j];\\n\\n\\tint res = 0;\\n\\n\\tres = Math.Max(res, dfs(i, j+1, seats, dic));\\n\\n\\tif(c == \\'.\\' \\n\\t   && (j == 0 || seats[i][j-1] != \\'p\\')\\n\\t   && (j == 0 || i == 0 || seats[i-1][j-1] != \\'p\\')\\n\\t   && (j == m-1 || i == 0 || seats[i-1][j+1] != \\'p\\'))\\n\\t{\\n\\t\\tseats[i][j] = \\'p\\';\\n\\t\\tres = Math.Max(res, 1 + dfs(i, j+1, seats, dic));\\n\\t\\tseats[i][j] = \\'.\\';\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1460292,
                "title": "python-ford-fulkerson-with-dfs-high-level-explanation",
                "content": "First, why can this be reduced to max flow problem?\\n\\nVertex cover: set of vertices that includes at least one endpoint of every edge of the graph\\nIndependent set: set of vertices in a graph, no two of which are adjacent\\nMatching: in an undirected graph, is a set of edges without common vertices\\n\\nThe complement of a vertex cover in any graph is an independent set, so a minimum vertex cover is complementary to a maximum independent set.\\n\\nIn any bipartite graph, the number of edges in a maximum matching equals the number of vertices in a minimum vertex cover. (K\\u0151nig\\'s theorem)\\n\\nFinally, in any bipartite graph (V=A u B, E \\\\in A x B), the number of edges in a maximum matching equals the maximum flow in a network (V\\'=V u {s,t}, E\\', c(e)=1 for e \\\\in E\\'), with source s, sink t and E\\' containing:\\ns->a for a \\\\in A\\na->b for a \\\\in A, b \\\\in B\\nb->t for b \\\\in B\\n\\nIn the 1349. Maximum Students Taking Exam problem, if we construct undirected graph G with tiles in the mxn grid as vertices and edges for all pairs of conflicting chairs, then G is bipartite: there is no edge between two tiles with even column numbers and no edge between tiles with odd column numbers. The answer we seek is the size of the maximum independent set.\\n\\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        Q = True\\n        m, n = len(seats), len(seats[0])\\n        \\n        s, t = (m, 0), (m, 1)\\n        \\n        def adj(v):\\n            r, c = v\\n            if (r, c) == t:\\n                return\\n            if (r, c) == s:\\n                for nr in range(m):\\n                    for nc in range(0, n, 2):\\n                        if seats[nr][nc] == \".\":\\n                            yield (nr, nc)\\n                return\\n            if not c & 1:\\n                for dr in (0, -1, 1):\\n                    for dc in (-1, 1):\\n                        nr, nc = r + dr, c + dc\\n                        if nr in range(m) and nc in range(n):\\n                            if seats[nr][nc] == \".\":\\n                                yield nr, nc\\n            if c & 1:\\n                yield t\\n        def rev_adj(v):\\n            r, c = v\\n            if (r, c) == s:\\n                return\\n            if (r, c) == t:\\n                for nr in range(m):\\n                    for nc in range(1, n, 2):\\n                        if seats[nr][nc] == \".\":\\n                            yield (nr, nc)\\n                return\\n            if c & 1:\\n                for dr in (0, -1, 1):\\n                    for dc in (-1, 1):\\n                        nr, nc = r + dr, c + dc\\n                        if nr in range(m) and nc in range(n):\\n                            if seats[nr][nc] == \".\":\\n                                yield nr, nc\\n            if not c & 1:\\n                yield s\\n        \\n        cap = defaultdict(lambda: 1)\\n        \\n        rev_cap = defaultdict(int)\\n        flow = 0\\n        while True:\\n            q = [s]\\n            ps = {}\\n            seen = set([s])\\n            while q:\\n                v = q.pop()\\n                if v == t:\\n                    break\\n                for w in adj(v):\\n                    if not cap[v, w] or w in seen:\\n                        continue\\n                    ps[w] = v\\n                    seen.add(w)\\n                    q.append(w)\\n                for w in rev_adj(v):\\n                    if not rev_cap[v, w] or w in seen:\\n                        continue\\n                    ps[w] = v\\n                    seen.add(w)\\n                    q.append(w)\\n            if v != t:\\n                break\\n            flow += 1\\n            v = ps[t]\\n            cap[v, t] -= 1\\n            rev_cap[t, v] += 1\\n            pp = f\"{t}\"\\n            while v != s:\\n                if ps[v] == s or v == t or v[1] & 1:\\n                    cap[ps[v], v] -= 1\\n                    rev_cap[v, ps[v]] += 1\\n                else:\\n                    cap[v, ps[v]] += 1\\n                    rev_cap[ps[v], v] -= 1\\n                if not Q:\\n                    pp = f\"{v} -> {pp}\"\\n                v = ps[v]\\n            Q or print(pp)\\n        chairs = sum(1 for _ in filter(functools.partial(operator.eq, \".\"), chain(*seats)))\\n        return chairs - flow\\n\\n\\n\"\"\"\\n[[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],[\".\",\"#\",\"#\",\"#\",\"#\",\".\"],[\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\\n[[\".\",\"#\"],[\"#\",\"#\"],[\"#\",\".\"],[\"#\",\"#\"],[\".\",\"#\"]]\\n[[\"#\",\".\",\".\",\".\",\"#\"],[\".\",\"#\",\".\",\"#\",\".\"],[\".\",\".\",\"#\",\".\",\".\"],[\".\",\"#\",\".\",\"#\",\".\"],[\"#\",\".\",\".\",\".\",\"#\"]]\\n[[\"#\"]]\\n[[\"#\"],[\".\"],[\".\"]]\\n[[\"#\",\".\",\".\"]]\\n[[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\"#\",\".\",\"#\"],[\".\",\"#\",\"#\"],[\"#\",\".\",\"#\"]]\\n[[\".\",\".\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\".\",\".\",\"#\",\".\",\".\",\".\",\".\"]]\\n[[\"#\",\".\",\"#\",\".\",\".\",\".\",\".\"]]\\n[[\".\"]]\\n[[\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\"]]\\n[[\".\",\"#\",\"#\",\".\"],[\".\",\".\",\".\",\"#\"],[\".\",\".\",\".\",\".\"],[\"#\",\".\",\"#\",\"#\"]]\\n[[\".\",\"#\",\"#\",\".\"],[\".\",\".\",\".\",\"#\"],[\".\",\".\",\".\",\".\"]]\\n[[\"#\",\"#\",\"#\",\".\",\"#\"],[\".\",\".\",\"#\",\".\",\".\"],[\"#\",\".\",\"#\",\".\",\"#\"],[\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\"#\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"#\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"#\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"#\",\".\",\".\",\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"#\",\".\"],[\".\",\".\",\"#\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        Q = True\\n        m, n = len(seats), len(seats[0])\\n        \\n        s, t = (m, 0), (m, 1)\\n        \\n        def adj(v):\\n            r, c = v\\n            if (r, c) == t:\\n                return\\n            if (r, c) == s:\\n                for nr in range(m):\\n                    for nc in range(0, n, 2):\\n                        if seats[nr][nc] == \".\":\\n                            yield (nr, nc)\\n                return\\n            if not c & 1:\\n                for dr in (0, -1, 1):\\n                    for dc in (-1, 1):\\n                        nr, nc = r + dr, c + dc\\n                        if nr in range(m) and nc in range(n):\\n                            if seats[nr][nc] == \".\":\\n                                yield nr, nc\\n            if c & 1:\\n                yield t\\n        def rev_adj(v):\\n            r, c = v\\n            if (r, c) == s:\\n                return\\n            if (r, c) == t:\\n                for nr in range(m):\\n                    for nc in range(1, n, 2):\\n                        if seats[nr][nc] == \".\":\\n                            yield (nr, nc)\\n                return\\n            if c & 1:\\n                for dr in (0, -1, 1):\\n                    for dc in (-1, 1):\\n                        nr, nc = r + dr, c + dc\\n                        if nr in range(m) and nc in range(n):\\n                            if seats[nr][nc] == \".\":\\n                                yield nr, nc\\n            if not c & 1:\\n                yield s\\n        \\n        cap = defaultdict(lambda: 1)\\n        \\n        rev_cap = defaultdict(int)\\n        flow = 0\\n        while True:\\n            q = [s]\\n            ps = {}\\n            seen = set([s])\\n            while q:\\n                v = q.pop()\\n                if v == t:\\n                    break\\n                for w in adj(v):\\n                    if not cap[v, w] or w in seen:\\n                        continue\\n                    ps[w] = v\\n                    seen.add(w)\\n                    q.append(w)\\n                for w in rev_adj(v):\\n                    if not rev_cap[v, w] or w in seen:\\n                        continue\\n                    ps[w] = v\\n                    seen.add(w)\\n                    q.append(w)\\n            if v != t:\\n                break\\n            flow += 1\\n            v = ps[t]\\n            cap[v, t] -= 1\\n            rev_cap[t, v] += 1\\n            pp = f\"{t}\"\\n            while v != s:\\n                if ps[v] == s or v == t or v[1] & 1:\\n                    cap[ps[v], v] -= 1\\n                    rev_cap[v, ps[v]] += 1\\n                else:\\n                    cap[v, ps[v]] += 1\\n                    rev_cap[ps[v], v] -= 1\\n                if not Q:\\n                    pp = f\"{v} -> {pp}\"\\n                v = ps[v]\\n            Q or print(pp)\\n        chairs = sum(1 for _ in filter(functools.partial(operator.eq, \".\"), chain(*seats)))\\n        return chairs - flow\\n\\n\\n\"\"\"\\n[[\"#\",\".\",\"#\",\"#\",\".\",\"#\"],[\".\",\"#\",\"#\",\"#\",\"#\",\".\"],[\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]\\n[[\".\",\"#\"],[\"#\",\"#\"],[\"#\",\".\"],[\"#\",\"#\"],[\".\",\"#\"]]\\n[[\"#\",\".\",\".\",\".\",\"#\"],[\".\",\"#\",\".\",\"#\",\".\"],[\".\",\".\",\"#\",\".\",\".\"],[\".\",\"#\",\".\",\"#\",\".\"],[\"#\",\".\",\".\",\".\",\"#\"]]\\n[[\"#\"]]\\n[[\"#\"],[\".\"],[\".\"]]\\n[[\"#\",\".\",\".\"]]\\n[[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"],[\"#\",\"#\",\"#\",\"#\",\"#\",\"#\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\"#\",\".\",\"#\"],[\".\",\"#\",\"#\"],[\"#\",\".\",\"#\"]]\\n[[\".\",\".\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\".\",\".\",\"#\",\".\",\".\",\".\",\".\"]]\\n[[\"#\",\".\",\"#\",\".\",\".\",\".\",\".\"]]\\n[[\".\"]]\\n[[\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\"]]\\n[[\".\",\"#\",\"#\",\".\"],[\".\",\".\",\".\",\"#\"],[\".\",\".\",\".\",\".\"],[\"#\",\".\",\"#\",\"#\"]]\\n[[\".\",\"#\",\"#\",\".\"],[\".\",\".\",\".\",\"#\"],[\".\",\".\",\".\",\".\"]]\\n[[\"#\",\"#\",\"#\",\".\",\"#\"],[\".\",\".\",\"#\",\".\",\".\"],[\"#\",\".\",\"#\",\".\",\"#\"],[\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\"#\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"#\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\"#\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\"#\",\".\",\".\",\"#\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\"#\",\".\"],[\".\",\".\",\"#\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n[[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"]]\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504547,
                "title": "python3-bitmask-dp",
                "content": "```\\n# bitmask dp\\n# dp[i][mask]: maximum students in seats[:i+1] with valid mask in seats[i]\\n# dp[i][mask] = max(dp[i-1][mask\\'] + valid bit(mask))\\n# no adjacent students: x&(x>>1) == 0\\n# student on good seat: x&y == x                            (y = bit(seats[i]))\\n# can\\'t see front guys: x&(y>>1) == 0 and (x>>1)&y == 0     (y = pre_mask)\\n\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        dp = [collections.defaultdict(int) for _ in range(m+1)]\\n        dp[-1][0] = 0\\n        \\n        bits = []\\n        for row in seats:\\n            num = 0\\n            for i in range(n):\\n                num += (row[i]==\\'.\\')<<n-1-i\\n            bits.append(num)\\n        # print(bits)\\n        \\n        for i in range(m):\\n            for x in range(2**n):\\n                for y in dp[i-1]:\\n                    if x&(x>>1) == 0 and x&bits[i] == x and x&(y>>1) == 0 and (x>>1)&y == 0:\\n                        dp[i][x] = max(dp[i][x], dp[i-1][y] + bin(x).count(\\'1\\'))\\n        \\n        return max(dp[m-1][x] for x in dp[m-1])\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n# bitmask dp\\n# dp[i][mask]: maximum students in seats[:i+1] with valid mask in seats[i]\\n# dp[i][mask] = max(dp[i-1][mask\\'] + valid bit(mask))\\n# no adjacent students: x&(x>>1) == 0\\n# student on good seat: x&y == x                            (y = bit(seats[i]))\\n# can\\'t see front guys: x&(y>>1) == 0 and (x>>1)&y == 0     (y = pre_mask)\\n\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        dp = [collections.defaultdict(int) for _ in range(m+1)]\\n        dp[-1][0] = 0\\n        \\n        bits = []\\n        for row in seats:\\n            num = 0\\n            for i in range(n):\\n                num += (row[i]==\\'.\\')<<n-1-i\\n            bits.append(num)\\n        # print(bits)\\n        \\n        for i in range(m):\\n            for x in range(2**n):\\n                for y in dp[i-1]:\\n                    if x&(x>>1) == 0 and x&bits[i] == x and x&(y>>1) == 0 and (x>>1)&y == 0:\\n                        dp[i][x] = max(dp[i][x], dp[i-1][y] + bin(x).count(\\'1\\'))\\n        \\n        return max(dp[m-1][x] for x in dp[m-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505825,
                "title": "c-all-solutions-you-need-max-flow-max-matching-hungarian-dfs-bfs-dp-bitmask",
                "content": "if you are wondering, why this is a bipartite graph problem, please see the chart and explanation below\\n![1349.png](https://assets.leetcode.com/users/images/a49ef975-05d1-4a94-9b40-84692007abc9_1683734578.3166718.png)\\n\\nMax flow\\n```\\nclass Solution {\\npublic:\\n    /*\\n        if we imagine the seats matrix as two set of seats in odd columns and seats in even columns, we can convert this matrix to a bipartite graph. we can add one dummy source node and one dummy sink node and use the max flow algo to solve this problem\\n        neighbouring seats where students can cheat will have an edge between them and our target is figure out the max. number of student that can go from source node to sink node\\n        for simplicy, we can use index to represent each seat. seat at row r and column c will have the index of r* width of seats matrix + c\\n    */\\n    vector<int> bfs(vector<vector<int>> &network){\\n        // find a path from s to t that every (u, v) in p satisfies c_f(u, v) > 0\\n        vector<int> parents(network.size(),-1);\\n        queue<int> q;\\n        q.push(0);//source node\\n        int u=0;\\n        while (!q.empty() && parents.back()==-1){\\n            u=q.front();\\n            q.pop();\\n            for (int v = 0; v < parents.size(); v++) {\\n                if (network[u][v] > 0 && parents[v] == -1) {\\n                    q.push(v);\\n                    parents[v] = u;\\n                }\\n            }\\n        }\\n        vector<int> path;\\n        u = parents.back();\\n        if (u !=-1){\\n            path.push_back(parents.size()-1);\\n        }\\n        while (u != 0) {\\n            if (u == -1) return {};\\n            path.push_back(u);\\n            u = parents[u];\\n        }\\n        reverse(path.begin(),path.end());\\n        return path;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //construct the capacity matrix\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        //we will have non-broken seats +2 in our graph\\n        int available = 0;\\n        for (int i=0; i< m;i++){\\n            for (int j=0; j< n;j++){\\n                if (seats[i][j] == \\'.\\'){\\n                    available ++;\\n                }\\n            }\\n        } \\n        vector<int> v(available+2,0);\\n        vector<vector<int>> network (available+2,v);\\n        vector<int> vv(n,-1);\\n        unordered_map<int,pair<int,int>> mp;//record 1-1 relationship of index and [x,y]\\n        vector<vector<int>> s(m,vv);//record index for valid seat\\n        int index = 0;//index 0 is reserved for dummy source node       \\n        for (int x=0; x<m;x++ ){\\n            for (int y = 0; y< n; y++){\\n                if (seats[x][y] == \\'#\\'){\\n                    continue;//we don\\'t need to add broken seats into our graph\\n                }\\n                index++;\\n                mp[index] = {x,y};\\n                s[x][y] = index;\\n            }\\n        }\\n        for (int x=0; x<m;x++ ){\\n            for (int y = 0; y< n; y++){\\n                if (seats[x][y] == \\'#\\' || y%2 ==1){//only add capacity from odd col to even col\\n                    continue;//we don\\'t need to add broken seats into our graph\\n                }\\n                int iu = s[x][y];\\n                vector<pair<int, int>> edges ={ {x - 1,y - 1},{x,y - 1},{x + 1,y- 1},{x - 1,y + 1},{x,y + 1},{x + 1,y + 1} };//possible edges for cheating\\n                for (int i=0; i< edges.size();i++){\\n                    pair<int, int> v = edges[i];\\n                    if (v.first < 0 || v.second < 0 || v.first == m || v.second == n || seats[v.first][v.second] != \\'.\\' ) {//not a valid edge\\n                        continue;\\n                    }\\n                    //found a edge\\n                    int iv = s[v.first][v.second];\\n                    network[iu][iv] = 1;\\n                }\\n            }\\n            //update the capacity of source and link node to infinity\\n            for (int i=1; i< network.size()-1;i++){\\n                int col = mp[i].second;\\n                if (col%2 ==0){\\n                    network[0][i] =1;\\n                } else{\\n                    network[i][available+1] =1;\\n                }\\n                \\n                \\n            }\\n        }\\n        int max_flow = 0;\\n        vector<int> path = bfs(network);\\n        while (path.size()) {\\n            // calculate residual capacity c_f(p)\\n            int residual_capacity = available;\\n            int u = 0;\\n            cout <<\"path\" << endl;\\n            for (int v : path) {\\n                residual_capacity = min(residual_capacity, network[u][v]);\\n                u = v;\\n                //cout << v << \",\" <<residual_capacity << endl;\\n            }\\n            // increment max flow\\n            max_flow += residual_capacity;\\n            u = 0;\\n            // update residual network\\n            for (int v : path) {\\n                network[u][v] -= residual_capacity;\\n                network[v][u] += residual_capacity;\\n                u = v;\\n            }\\n            path = bfs(network);\\n        }\\n        return available - max_flow;\\n    }\\n};\\n```\\nAs wxy9018 and WangQiuc pointed out, this is a bipartite matching problem. If we imagine seats in even column and seats in odd column as two sets, we can connect those virtual edges where students can cheat in any neighbouring column. If we can find out the maximum pairs of students that can cheat, we can get the answer (available seats - max. pairs.)\\nBelow is a c++ implementation of Hungarian algorithm using BFS\\n\\nHungarian\\n# Code\\nBFS\\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int R = seats.size();\\n        int C = seats[0].size();        \\n        pair<int,int> ini = {-1,-1};\\n        vector<vector<pair<int,int>>> matching(R, vector<pair<int,int>>(C, ini));\\n        vector<vector<pair<int,int>>> check(R, vector<pair<int,int>>(C, ini));\\n        vector<vector<pair<int,int>>> prev(R, vector<pair<int,int>>(C, ini));\\n        queue<pair<int,int>> Q;\\n        int ans = 0;\\n        for (int row=0; row< R; row++){\\n            for (int col = 0; col < C; col++){\\n                if (seats[row][col]== \\'.\\' && matching[row][col].first == -1) {\\n                    while (!Q.empty()) Q.pop();\\n                    pair<int,int> p = {row,col};\\n                    Q.push(p);\\n                    prev[row][col] ={ -1,-1}; // set row,col as the starting point\\n                    bool flag = false; // agumenting path not found yet\\n                    while (!Q.empty() && !flag){\\n                        pair<int,int> u = Q.front();\\n                        int x = u.first;\\n                        int y = u.second;\\n                        vector<pair<int,int>> edges = \\n                        {{x-1,y-1},{x,y-1},{x+1,y\\n                        -1},{x-1,y+1},{x,y+1},{x+1,y+1}};\\n                        for (int i=0; i< edges.size();i++){\\n                            pair<int,int> v = edges[i];\\n                            if (v.first < 0 || v.second < 0 || v.first == R || v.second == C || seats[v.first][v.second] != \\'.\\' || flag){\\n                                continue;\\n                            }\\n                            if (check[v.first][v.second] != p) {\\n                                check[v.first][v.second] = p;\\n                                Q.push(matching[v.first][v.second]);\\n                                if (matching[v.first][v.second].first >= 0) { //a matched cell\\n                                    prev[matching[v.first][v.second].first][matching[v.first][v.second].second] = u;\\n                                    } else { // augumenting path found\\n                                        flag = true;\\n                                        pair<int,int> d=u, e=v;\\n                                        while (d.first != -1) {\\n                                            pair<int,int> t = matching[d.first][d.second];\\n                                            matching[d.first][d.second] = e;\\n                                            matching[e.first][e.second] = d;\\n                                            d = prev[d.first][d.second];\\n                                            e = t;\\n                                        }\\n                                    }\\n                            }\\n                        }\\n                        Q.pop();    \\n                    }  \\n                    if (matching[row][col].first != -1) ++ans;                    \\n                }\\n                             \\n            }\\n\\n        }\\n\\n        int available = 0;\\n        for (int i=0; i< R;i++){\\n            for (int j=0; j< C;j++){\\n                if (seats[i][j] == \\'.\\'){\\n                    available ++;\\n                }\\n            }\\n        }\\n        return available -ans;\\n    }\\n};\\n```\\nDFS\\n```\\nclass Solution {\\npublic:\\n    bool dfs(pair<int, int> u, vector<vector<char>>& seats, vector<vector<pair<int, int>>>& check, vector<vector<pair<int, int>>>& matching)\\n    {\\n        int x = u.first; int y = u.second;\\n        vector<pair<int, int>> edges = { {x - 1,y - 1},{x,y - 1},{x + 1,y - 1},{x - 1,y + 1},{x,y + 1},{x + 1,y + 1} };\\n        for (int i = 0; i < edges.size(); i++) {\\n            pair<int, int> v = edges[i];\\n            if (v.first < 0 || v.second < 0 || v.first == seats.size() || v.second == seats[0].size() || seats[v.first][v.second] != \\'.\\') {\\n                continue;\\n            }\\n            if (check[v.first][v.second].first == -1) {     // not in alternative path\\n                check[v.first][v.second] = u; // record in alternative path\\n                if (matching[v.first][v.second].first == -1 || dfs(matching[v.first][v.second], seats, check, matching)) {\\n                    // find an augumenting path, record the route and return true\\n                    matching[v.first][v.second] = u;\\n                    matching[u.first][u.second] = v;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false; // no augumenting path, return false\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int R = seats.size();\\n        int C = seats[0].size();\\n        pair<int, int> ini = { -1,-1 };\\n        vector<vector<pair<int, int>>> matching(R, vector<pair<int, int>>(C, ini));\\n        //vector<vector<pair<int,int>>> prev(R, vector<pair<int,int>>(C, ini));\\n        queue<pair<int, int>> Q;\\n        int ans = 0;\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                pair<int, int> u = { i,j };\\n                if (seats[i][j] == \\'.\\' && matching[u.first][u.second].first == -1) {\\n                    vector<vector<pair<int, int>>> check(R, vector<pair<int, int>>(C, ini));\\n                    if (dfs(u, seats, check, matching))\\n                        ++ans;\\n                }\\n            }\\n\\n        }\\n        int available = 0;\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (seats[i][j] == \\'.\\') {\\n                    available++;\\n                }\\n            }\\n        }\\n        return available - ans;\\n    }\\n};\\n```\\nBitmask\\n```\\nclass Solution {\\npublic:\\n    bool canPlace(vector<vector<char>>& seats, int r, int c){\\n        //check left, right, upper left and upper right if in boundary\\n        if (c-1>=0){\\n            if (r-1>=0){\\n                if (seats[r][c-1] == \\'s\\' || seats[r-1][c-1] == \\'s\\'){\\n                    return false;\\n                }\\n            }else{\\n                if (seats[r][c-1] == \\'s\\'){\\n                    return false;\\n                }               \\n            }\\n        }\\n        if (c+1< seats[0].size()){\\n            if (r-1>=0){\\n                if (seats[r][c+1] == \\'s\\' || seats[r-1][c+1] == \\'s\\'){\\n                    return false;\\n                }\\n            }else{\\n                if (seats[r][c+1] == \\'s\\'){\\n                    return false;\\n                }               \\n            }\\n        }\\n        return true;\\n    }\\n    int memo[8][8][255][255];\\n    int dfs(vector<vector<char>>& seats, int r, int c, int premask, int curmask){\\n        //we only need two rows\\' bitmask\\n        if (r == seats.size()){//no more student can be placed\\n            return 0;\\n        }        \\n\\n        if (c == seats[0].size()){//this row fully checked\\n            return dfs(seats,r+1,0,curmask,0);\\n        }\\n        if ( memo[r][c][premask][curmask] != -1){\\n            return memo[r][c][premask][curmask];\\n        }\\n        int s1 = 0; int s2 = 0;     \\n        if (seats[r][c] != \\'#\\' && canPlace(seats,r,c)){\\n            seats[r][c] = \\'s\\';//indicate there is a student here\\n            s1 = 1+ dfs(seats,r,c+1,premask,curmask | (1<< c));\\n            seats[r][c] = \\'.\\';//backtracking\\n        }\\n        s2 = dfs(seats,r,c+1,premask,curmask);//not place student here\\n        memo[r][c][premask][curmask] = max(s1,s2);\\n        return  memo[r][c][premask][curmask];\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(memo,-1,sizeof(memo));\\n        return dfs(seats,0,0,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        if we imagine the seats matrix as two set of seats in odd columns and seats in even columns, we can convert this matrix to a bipartite graph. we can add one dummy source node and one dummy sink node and use the max flow algo to solve this problem\\n        neighbouring seats where students can cheat will have an edge between them and our target is figure out the max. number of student that can go from source node to sink node\\n        for simplicy, we can use index to represent each seat. seat at row r and column c will have the index of r* width of seats matrix + c\\n    */\\n    vector<int> bfs(vector<vector<int>> &network){\\n        // find a path from s to t that every (u, v) in p satisfies c_f(u, v) > 0\\n        vector<int> parents(network.size(),-1);\\n        queue<int> q;\\n        q.push(0);//source node\\n        int u=0;\\n        while (!q.empty() && parents.back()==-1){\\n            u=q.front();\\n            q.pop();\\n            for (int v = 0; v < parents.size(); v++) {\\n                if (network[u][v] > 0 && parents[v] == -1) {\\n                    q.push(v);\\n                    parents[v] = u;\\n                }\\n            }\\n        }\\n        vector<int> path;\\n        u = parents.back();\\n        if (u !=-1){\\n            path.push_back(parents.size()-1);\\n        }\\n        while (u != 0) {\\n            if (u == -1) return {};\\n            path.push_back(u);\\n            u = parents[u];\\n        }\\n        reverse(path.begin(),path.end());\\n        return path;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //construct the capacity matrix\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        //we will have non-broken seats +2 in our graph\\n        int available = 0;\\n        for (int i=0; i< m;i++){\\n            for (int j=0; j< n;j++){\\n                if (seats[i][j] == \\'.\\'){\\n                    available ++;\\n                }\\n            }\\n        } \\n        vector<int> v(available+2,0);\\n        vector<vector<int>> network (available+2,v);\\n        vector<int> vv(n,-1);\\n        unordered_map<int,pair<int,int>> mp;//record 1-1 relationship of index and [x,y]\\n        vector<vector<int>> s(m,vv);//record index for valid seat\\n        int index = 0;//index 0 is reserved for dummy source node       \\n        for (int x=0; x<m;x++ ){\\n            for (int y = 0; y< n; y++){\\n                if (seats[x][y] == \\'#\\'){\\n                    continue;//we don\\'t need to add broken seats into our graph\\n                }\\n                index++;\\n                mp[index] = {x,y};\\n                s[x][y] = index;\\n            }\\n        }\\n        for (int x=0; x<m;x++ ){\\n            for (int y = 0; y< n; y++){\\n                if (seats[x][y] == \\'#\\' || y%2 ==1){//only add capacity from odd col to even col\\n                    continue;//we don\\'t need to add broken seats into our graph\\n                }\\n                int iu = s[x][y];\\n                vector<pair<int, int>> edges ={ {x - 1,y - 1},{x,y - 1},{x + 1,y- 1},{x - 1,y + 1},{x,y + 1},{x + 1,y + 1} };//possible edges for cheating\\n                for (int i=0; i< edges.size();i++){\\n                    pair<int, int> v = edges[i];\\n                    if (v.first < 0 || v.second < 0 || v.first == m || v.second == n || seats[v.first][v.second] != \\'.\\' ) {//not a valid edge\\n                        continue;\\n                    }\\n                    //found a edge\\n                    int iv = s[v.first][v.second];\\n                    network[iu][iv] = 1;\\n                }\\n            }\\n            //update the capacity of source and link node to infinity\\n            for (int i=1; i< network.size()-1;i++){\\n                int col = mp[i].second;\\n                if (col%2 ==0){\\n                    network[0][i] =1;\\n                } else{\\n                    network[i][available+1] =1;\\n                }\\n                \\n                \\n            }\\n        }\\n        int max_flow = 0;\\n        vector<int> path = bfs(network);\\n        while (path.size()) {\\n            // calculate residual capacity c_f(p)\\n            int residual_capacity = available;\\n            int u = 0;\\n            cout <<\"path\" << endl;\\n            for (int v : path) {\\n                residual_capacity = min(residual_capacity, network[u][v]);\\n                u = v;\\n                //cout << v << \",\" <<residual_capacity << endl;\\n            }\\n            // increment max flow\\n            max_flow += residual_capacity;\\n            u = 0;\\n            // update residual network\\n            for (int v : path) {\\n                network[u][v] -= residual_capacity;\\n                network[v][u] += residual_capacity;\\n                u = v;\\n            }\\n            path = bfs(network);\\n        }\\n        return available - max_flow;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int R = seats.size();\\n        int C = seats[0].size();        \\n        pair<int,int> ini = {-1,-1};\\n        vector<vector<pair<int,int>>> matching(R, vector<pair<int,int>>(C, ini));\\n        vector<vector<pair<int,int>>> check(R, vector<pair<int,int>>(C, ini));\\n        vector<vector<pair<int,int>>> prev(R, vector<pair<int,int>>(C, ini));\\n        queue<pair<int,int>> Q;\\n        int ans = 0;\\n        for (int row=0; row< R; row++){\\n            for (int col = 0; col < C; col++){\\n                if (seats[row][col]== \\'.\\' && matching[row][col].first == -1) {\\n                    while (!Q.empty()) Q.pop();\\n                    pair<int,int> p = {row,col};\\n                    Q.push(p);\\n                    prev[row][col] ={ -1,-1}; // set row,col as the starting point\\n                    bool flag = false; // agumenting path not found yet\\n                    while (!Q.empty() && !flag){\\n                        pair<int,int> u = Q.front();\\n                        int x = u.first;\\n                        int y = u.second;\\n                        vector<pair<int,int>> edges = \\n                        {{x-1,y-1},{x,y-1},{x+1,y\\n                        -1},{x-1,y+1},{x,y+1},{x+1,y+1}};\\n                        for (int i=0; i< edges.size();i++){\\n                            pair<int,int> v = edges[i];\\n                            if (v.first < 0 || v.second < 0 || v.first == R || v.second == C || seats[v.first][v.second] != \\'.\\' || flag){\\n                                continue;\\n                            }\\n                            if (check[v.first][v.second] != p) {\\n                                check[v.first][v.second] = p;\\n                                Q.push(matching[v.first][v.second]);\\n                                if (matching[v.first][v.second].first >= 0) { //a matched cell\\n                                    prev[matching[v.first][v.second].first][matching[v.first][v.second].second] = u;\\n                                    } else { // augumenting path found\\n                                        flag = true;\\n                                        pair<int,int> d=u, e=v;\\n                                        while (d.first != -1) {\\n                                            pair<int,int> t = matching[d.first][d.second];\\n                                            matching[d.first][d.second] = e;\\n                                            matching[e.first][e.second] = d;\\n                                            d = prev[d.first][d.second];\\n                                            e = t;\\n                                        }\\n                                    }\\n                            }\\n                        }\\n                        Q.pop();    \\n                    }  \\n                    if (matching[row][col].first != -1) ++ans;                    \\n                }\\n                             \\n            }\\n\\n        }\\n\\n        int available = 0;\\n        for (int i=0; i< R;i++){\\n            for (int j=0; j< C;j++){\\n                if (seats[i][j] == \\'.\\'){\\n                    available ++;\\n                }\\n            }\\n        }\\n        return available -ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool dfs(pair<int, int> u, vector<vector<char>>& seats, vector<vector<pair<int, int>>>& check, vector<vector<pair<int, int>>>& matching)\\n    {\\n        int x = u.first; int y = u.second;\\n        vector<pair<int, int>> edges = { {x - 1,y - 1},{x,y - 1},{x + 1,y - 1},{x - 1,y + 1},{x,y + 1},{x + 1,y + 1} };\\n        for (int i = 0; i < edges.size(); i++) {\\n            pair<int, int> v = edges[i];\\n            if (v.first < 0 || v.second < 0 || v.first == seats.size() || v.second == seats[0].size() || seats[v.first][v.second] != \\'.\\') {\\n                continue;\\n            }\\n            if (check[v.first][v.second].first == -1) {     // not in alternative path\\n                check[v.first][v.second] = u; // record in alternative path\\n                if (matching[v.first][v.second].first == -1 || dfs(matching[v.first][v.second], seats, check, matching)) {\\n                    // find an augumenting path, record the route and return true\\n                    matching[v.first][v.second] = u;\\n                    matching[u.first][u.second] = v;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false; // no augumenting path, return false\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int R = seats.size();\\n        int C = seats[0].size();\\n        pair<int, int> ini = { -1,-1 };\\n        vector<vector<pair<int, int>>> matching(R, vector<pair<int, int>>(C, ini));\\n        //vector<vector<pair<int,int>>> prev(R, vector<pair<int,int>>(C, ini));\\n        queue<pair<int, int>> Q;\\n        int ans = 0;\\n\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                pair<int, int> u = { i,j };\\n                if (seats[i][j] == \\'.\\' && matching[u.first][u.second].first == -1) {\\n                    vector<vector<pair<int, int>>> check(R, vector<pair<int, int>>(C, ini));\\n                    if (dfs(u, seats, check, matching))\\n                        ++ans;\\n                }\\n            }\\n\\n        }\\n        int available = 0;\\n        for (int i = 0; i < R; i++) {\\n            for (int j = 0; j < C; j++) {\\n                if (seats[i][j] == \\'.\\') {\\n                    available++;\\n                }\\n            }\\n        }\\n        return available - ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool canPlace(vector<vector<char>>& seats, int r, int c){\\n        //check left, right, upper left and upper right if in boundary\\n        if (c-1>=0){\\n            if (r-1>=0){\\n                if (seats[r][c-1] == \\'s\\' || seats[r-1][c-1] == \\'s\\'){\\n                    return false;\\n                }\\n            }else{\\n                if (seats[r][c-1] == \\'s\\'){\\n                    return false;\\n                }               \\n            }\\n        }\\n        if (c+1< seats[0].size()){\\n            if (r-1>=0){\\n                if (seats[r][c+1] == \\'s\\' || seats[r-1][c+1] == \\'s\\'){\\n                    return false;\\n                }\\n            }else{\\n                if (seats[r][c+1] == \\'s\\'){\\n                    return false;\\n                }               \\n            }\\n        }\\n        return true;\\n    }\\n    int memo[8][8][255][255];\\n    int dfs(vector<vector<char>>& seats, int r, int c, int premask, int curmask){\\n        //we only need two rows\\' bitmask\\n        if (r == seats.size()){//no more student can be placed\\n            return 0;\\n        }        \\n\\n        if (c == seats[0].size()){//this row fully checked\\n            return dfs(seats,r+1,0,curmask,0);\\n        }\\n        if ( memo[r][c][premask][curmask] != -1){\\n            return memo[r][c][premask][curmask];\\n        }\\n        int s1 = 0; int s2 = 0;     \\n        if (seats[r][c] != \\'#\\' && canPlace(seats,r,c)){\\n            seats[r][c] = \\'s\\';//indicate there is a student here\\n            s1 = 1+ dfs(seats,r,c+1,premask,curmask | (1<< c));\\n            seats[r][c] = \\'.\\';//backtracking\\n        }\\n        s2 = dfs(seats,r,c+1,premask,curmask);//not place student here\\n        memo[r][c][premask][curmask] = max(s1,s2);\\n        return  memo[r][c][premask][curmask];\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(memo,-1,sizeof(memo));\\n        return dfs(seats,0,0,0,0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1131990,
                "title": "c-bitset",
                "content": "This is kind of a dynamic programming problem. At any time, we only need to look at 2 rows, the current row and the row above.\\nWe use bitmask to indicate the seats that we select in a row.\\n\\n```\\nclass Solution {\\n    // Given a row represented by char and a mask, check if we can select the seats indicated by the mask.\\n    // Return the # of seats, if not valid, return -1.\\n    int line(vector<char>& row, int mask) {\\n        int sum = 0, last = -2;\\n        for(int i=0; i<row.size(); i++) {\\n            if(mask & (1 << i)) {\\n                if(row[i] == \\'#\\') return -1;\\n                else {\\n                    sum += 1;\\n                    if(i == (last + 1)) return -1;\\n                    else last = i;\\n                }\\n            } \\n        }\\n        return sum;\\n    }\\n    \\n    // Given two masks that contains the select seats of 2 adjacent rows, check if they are valid.\\n    bool twoLines(int maskC,  int maskP, int n) {\\n        for(int i=0; i<n; i++) {\\n            if(1 << i & maskP) {\\n                if(i - 1 >= 0 && ((1 << (i - 1)) & maskC)) return false;\\n                if(i + 1 < n && ((1 << (i + 1)) & maskC)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size();\\n        int len = pow(2, n);\\n        \\n        vector<int> prev(len, -1);\\n        vector<int> cur(len, -1);\\n        for(int i=0; i<len;++i) {\\n            prev[i] = line(seats[m-1], i);\\n        }\\n        \\n        for(int l = m-2; l >=0; l--) {\\n            for(int c=0; c<len; c++) {\\n                int cntCur = line(seats[l], c);\\n                if(cntCur == -1) continue; // Mask of current row is not valid.\\n                \\n                for(int p=0; p<len; p++) {\\n                    if(prev[p] == -1) continue; // Mask of previous row is not valid.\\n                    if(twoLines(c, p, n)) cur[c] = max(cur[c], cntCur + prev[p]);\\n                }\\n            }\\n            \\n            prev = cur;\\n        }\\n        \\n        int ans = 0;\\n        for(auto a : cur) ans = max(ans, a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Given a row represented by char and a mask, check if we can select the seats indicated by the mask.\\n    // Return the # of seats, if not valid, return -1.\\n    int line(vector<char>& row, int mask) {\\n        int sum = 0, last = -2;\\n        for(int i=0; i<row.size(); i++) {\\n            if(mask & (1 << i)) {\\n                if(row[i] == \\'#\\') return -1;\\n                else {\\n                    sum += 1;\\n                    if(i == (last + 1)) return -1;\\n                    else last = i;\\n                }\\n            } \\n        }\\n        return sum;\\n    }\\n    \\n    // Given two masks that contains the select seats of 2 adjacent rows, check if they are valid.\\n    bool twoLines(int maskC,  int maskP, int n) {\\n        for(int i=0; i<n; i++) {\\n            if(1 << i & maskP) {\\n                if(i - 1 >= 0 && ((1 << (i - 1)) & maskC)) return false;\\n                if(i + 1 < n && ((1 << (i + 1)) & maskC)) return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size();\\n        int len = pow(2, n);\\n        \\n        vector<int> prev(len, -1);\\n        vector<int> cur(len, -1);\\n        for(int i=0; i<len;++i) {\\n            prev[i] = line(seats[m-1], i);\\n        }\\n        \\n        for(int l = m-2; l >=0; l--) {\\n            for(int c=0; c<len; c++) {\\n                int cntCur = line(seats[l], c);\\n                if(cntCur == -1) continue; // Mask of current row is not valid.\\n                \\n                for(int p=0; p<len; p++) {\\n                    if(prev[p] == -1) continue; // Mask of previous row is not valid.\\n                    if(twoLines(c, p, n)) cur[c] = max(cur[c], cntCur + prev[p]);\\n                }\\n            }\\n            \\n            prev = cur;\\n        }\\n        \\n        int ans = 0;\\n        for(auto a : cur) ans = max(ans, a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030356,
                "title": "python3-bitmasking-dfs",
                "content": "inspired by https://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        masks = []\\n        for row in seats:\\n            mask = 0\\n            for j, v in enumerate(row):\\n                mask |= 1 << j if v == \\'.\\' else 0\\n            masks += mask,\\n            \\n        @lru_cache(None)\\n        def dfs(i, pre):\\n            if i == m: return 0\\n            res = 0\\n            for cur in range(1<<n):\\n                if (cur & masks[i]) == cur and not cur & (cur >> 1):\\n                    if not (pre >> 1) & cur and not pre & (cur >> 1):\\n                        res = max(res, bin(cur).count(\\'1\\') + dfs(i+1, cur))\\n            return res\\n        return dfs(0, 0)\\n",
                "solutionTags": [],
                "code": "inspired by https://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        masks = []\\n        for row in seats:\\n            mask = 0\\n            for j, v in enumerate(row):\\n                mask |= 1 << j if v == \\'.\\' else 0\\n            masks += mask,\\n            \\n        @lru_cache(None)\\n        def dfs(i, pre):\\n            if i == m: return 0\\n            res = 0\\n            for cur in range(1<<n):\\n                if (cur & masks[i]) == cur and not cur & (cur >> 1):\\n                    if not (pre >> 1) & cur and not pre & (cur >> 1):\\n                        res = max(res, bin(cur).count(\\'1\\') + dfs(i+1, cur))\\n            return res\\n        return dfs(0, 0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 841105,
                "title": "java-recursion-based-solution",
                "content": "```\\n    private int n, m;\\n    private ArrayList<Pair<Integer, Integer>> list = new ArrayList<>();\\n\\n    public int maxStudents(char[][] seats) {\\n\\n        n = seats.length;\\n        if (n != 0) m = seats[0].length;\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                if (seats[i][j] == \\'.\\') list.add(new Pair<>(i, j));\\n\\n        if (list.size() == 0) return 0;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            char[][] grid = new char[n][m];\\n            for (int j = 0; j < n; j++) grid[j] = Arrays.copyOf(seats[j], m);\\n\\n            ans = Math.max(ans, arrange(grid, list.get(i).getKey(), list.get(i).getValue()));\\n        }\\n        return ans;\\n    }\\n\\n    private int arrange(char[][] seats, Integer i, Integer j) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || seats[i][j] == \\'#\\' || seats[i][j] == \\'*\\') return 0;\\n        int seated = 1;\\n        if (j - 1 >= 0 && seats[i][j - 1] == \\'*\\') seated = 0;\\n        if (j + 1 < m && seats[i][j + 1] == \\'*\\') seated = 0;\\n        if (i - 1 >= 0 && j - 1 >= 0 && seats[i - 1][j - 1] == \\'*\\') seated = 0;\\n        if (i - 1 >= 0 && j + 1 < m && seats[i - 1][j + 1] == \\'*\\') seated = 0;\\n        if (i + 1 < n && j - 1 >= 0 && seats[i + 1][j - 1] == \\'*\\') seated = 0;\\n        if (i + 1 < n && j + 1 < m && seats[i + 1][j + 1] == \\'*\\') seated = 0;\\n\\n        if (seated == 1) seats[i][j] = \\'*\\';\\n        else return 0;\\n        \\n        for (int ind = 0; ind < list.size(); ind++) {\\n            seated += arrange(seats, list.get(ind).getKey(), list.get(ind).getValue());\\n        }\\n        return seated;\\n    }",
                "solutionTags": [],
                "code": "```\\n    private int n, m;\\n    private ArrayList<Pair<Integer, Integer>> list = new ArrayList<>();\\n\\n    public int maxStudents(char[][] seats) {\\n\\n        n = seats.length;\\n        if (n != 0) m = seats[0].length;\\n        int ans = Integer.MIN_VALUE;\\n        for (int i = 0; i < n; i++)\\n            for (int j = 0; j < m; j++)\\n                if (seats[i][j] == \\'.\\') list.add(new Pair<>(i, j));\\n\\n        if (list.size() == 0) return 0;\\n\\n        for (int i = 0; i < list.size(); i++) {\\n            char[][] grid = new char[n][m];\\n            for (int j = 0; j < n; j++) grid[j] = Arrays.copyOf(seats[j], m);\\n\\n            ans = Math.max(ans, arrange(grid, list.get(i).getKey(), list.get(i).getValue()));\\n        }\\n        return ans;\\n    }\\n\\n    private int arrange(char[][] seats, Integer i, Integer j) {\\n        if (i < 0 || i >= n || j < 0 || j >= m || seats[i][j] == \\'#\\' || seats[i][j] == \\'*\\') return 0;\\n        int seated = 1;\\n        if (j - 1 >= 0 && seats[i][j - 1] == \\'*\\') seated = 0;\\n        if (j + 1 < m && seats[i][j + 1] == \\'*\\') seated = 0;\\n        if (i - 1 >= 0 && j - 1 >= 0 && seats[i - 1][j - 1] == \\'*\\') seated = 0;\\n        if (i - 1 >= 0 && j + 1 < m && seats[i - 1][j + 1] == \\'*\\') seated = 0;\\n        if (i + 1 < n && j - 1 >= 0 && seats[i + 1][j - 1] == \\'*\\') seated = 0;\\n        if (i + 1 < n && j + 1 < m && seats[i + 1][j + 1] == \\'*\\') seated = 0;\\n\\n        if (seated == 1) seats[i][j] = \\'*\\';\\n        else return 0;\\n        \\n        for (int ind = 0; ind < list.size(); ind++) {\\n            seated += arrange(seats, list.get(ind).getKey(), list.get(ind).getValue());\\n        }\\n        return seated;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 503728,
                "title": "simple-dfs-memo-java-solution",
                "content": "```\\nclass Solution {\\n    int n, m;\\n    char[][] s;\\n    Map<String, Integer> mem = new HashMap();\\n    public int maxStudents(char[][] seats) {\\n        n = seats.length;\\n        m = seats[0].length;\\n        s = seats;\\n    \\n        return dfs(0, 0, 0);\\n    }\\n    \\n    public int dfs(int level, int state, int count) {\\n        if (level == n) {\\n            return count;\\n        }\\n        \\n        if (mem.containsKey(level+\"_\"+state+\"_\"+count)) {\\n            return mem.get(level+\"_\"+state+\"_\"+count);\\n        }\\n        \\n        // check each state\\n        int max = 0;\\n        for (int i = 0; i < 1 << m; i++) {\\n            if (isValid(level, state, i)) {\\n                max = Math.max(max, dfs(level+1, i, count + getBits(i)));\\n            }\\n        }\\n        \\n        mem.put(level+\"_\"+state+\"_\"+count, max);\\n        return mem.get(level+\"_\"+state+\"_\"+count);\\n    }\\n    \\n    public int getBits(int x) {\\n        int count = 0;\\n        while (x != 0) {\\n            x = x & (x-1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isValid(int level, int a, int b) {\\n        // if left, right, left-top, right-top has no students from prevous line (a)\\n        int na = a >>> 1 | a << 1;\\n        if ((na & b) > 0) return false;\\n        int x = b;\\n        \\n        // if there are no coutinuous 1s from current line (b)\\n        while (x != 0) {\\n            if ((x&1)==1 && ((x>>1)&1)==1) {\\n                return false;\\n            }\\n            \\n            x >>= 1;\\n        }\\n        \\n        // if position with 1 is not a \\'#\\'\\n        while (b != 0) {\\n            int j = b & -b;\\n            int c = 0;\\n            while ((j & 1) != 1) {\\n                j >>= 1;\\n                c++;\\n            }\\n            b = b & (b-1);\\n            if (s[level][c] == \\'#\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n, m;\\n    char[][] s;\\n    Map<String, Integer> mem = new HashMap();\\n    public int maxStudents(char[][] seats) {\\n        n = seats.length;\\n        m = seats[0].length;\\n        s = seats;\\n    \\n        return dfs(0, 0, 0);\\n    }\\n    \\n    public int dfs(int level, int state, int count) {\\n        if (level == n) {\\n            return count;\\n        }\\n        \\n        if (mem.containsKey(level+\"_\"+state+\"_\"+count)) {\\n            return mem.get(level+\"_\"+state+\"_\"+count);\\n        }\\n        \\n        // check each state\\n        int max = 0;\\n        for (int i = 0; i < 1 << m; i++) {\\n            if (isValid(level, state, i)) {\\n                max = Math.max(max, dfs(level+1, i, count + getBits(i)));\\n            }\\n        }\\n        \\n        mem.put(level+\"_\"+state+\"_\"+count, max);\\n        return mem.get(level+\"_\"+state+\"_\"+count);\\n    }\\n    \\n    public int getBits(int x) {\\n        int count = 0;\\n        while (x != 0) {\\n            x = x & (x-1);\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n    \\n    public boolean isValid(int level, int a, int b) {\\n        // if left, right, left-top, right-top has no students from prevous line (a)\\n        int na = a >>> 1 | a << 1;\\n        if ((na & b) > 0) return false;\\n        int x = b;\\n        \\n        // if there are no coutinuous 1s from current line (b)\\n        while (x != 0) {\\n            if ((x&1)==1 && ((x>>1)&1)==1) {\\n                return false;\\n            }\\n            \\n            x >>= 1;\\n        }\\n        \\n        // if position with 1 is not a \\'#\\'\\n        while (b != 0) {\\n            int j = b & -b;\\n            int c = 0;\\n            while ((j & 1) != 1) {\\n                j >>= 1;\\n                c++;\\n            }\\n            b = b & (b-1);\\n            if (s[level][c] == \\'#\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2974125,
                "title": "python-easy-solution-bitmask-dp-faster-than-65",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        numRows, numCols = len(seats), len(seats[0])\\n\\n        def check(col: int, prevMask: int) -> bool:\\n            if col <= 0:\\n                if prevMask & (1 << (col + 1)):\\n                    return False\\n            elif col >= numCols - 1:\\n                if prevMask & (1 << (col - 1)):\\n                    return False\\n            else:\\n                if prevMask & (1 << (col - 1)) or prevMask & (1 << (col + 1)):\\n                    return False\\n            return True\\n\\n        @cache\\n        def solve(row: int, col: int, prevMask: int, mask: int) -> int:\\n            if row >= numRows:\\n                return 0\\n            if col == numCols:\\n                return solve(row + 1, 0, mask, 0)\\n            ans = 0\\n            if seats[row][col] == \\'.\\' and check(col, prevMask):\\n                if col == 0:\\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\\n                elif not (mask & (1 << (col - 1))):\\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\\n            ans = max(ans, solve(row, col + 1, prevMask, mask))\\n            return ans\\n\\n        return solve(0, 0, 0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        numRows, numCols = len(seats), len(seats[0])\\n\\n        def check(col: int, prevMask: int) -> bool:\\n            if col <= 0:\\n                if prevMask & (1 << (col + 1)):\\n                    return False\\n            elif col >= numCols - 1:\\n                if prevMask & (1 << (col - 1)):\\n                    return False\\n            else:\\n                if prevMask & (1 << (col - 1)) or prevMask & (1 << (col + 1)):\\n                    return False\\n            return True\\n\\n        @cache\\n        def solve(row: int, col: int, prevMask: int, mask: int) -> int:\\n            if row >= numRows:\\n                return 0\\n            if col == numCols:\\n                return solve(row + 1, 0, mask, 0)\\n            ans = 0\\n            if seats[row][col] == \\'.\\' and check(col, prevMask):\\n                if col == 0:\\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\\n                elif not (mask & (1 << (col - 1))):\\n                    ans = 1 + solve(row, col + 1, prevMask, mask | (1 << (col)))\\n            ans = max(ans, solve(row, col + 1, prevMask, mask))\\n            return ans\\n\\n        return solve(0, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596795,
                "title": "c-dp-with-bitmask-easy-to-understand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //one of the best of the best dp with bitmasking problem itself to understand dp with bitmask\\n        \\n         int m=seats.size();//rows\\n        int n=seats[0].size();//columns\\n        vector<int> validity(m+1);//remember we are taking m+1 not m\\n        //so first row is the 1th row not 0th\\n        for(int i=0;i<m;i++){\\n            int rowvalid=0;\\n            for(int j=0;j<n;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    rowvalid+=(1<<j);\\n                }\\n            }\\n            validity[i+1]=rowvalid;\\n        }\\n        \\n        //dp\\n        vector<vector<int>> dp(m+1,vector<int>((1<<n)+1,-1));\\n        //dp[i][j] represents the maximum number of students that can be placed till the ith row from the first row satisfying the condition that they cant cheat where j is the configuration of seated students in the ith row which satisfies the optimal result till this row\\n        dp[0][0]=0;//initializing\\n        for(int i=1;i<=m;i++){\\n            //go through each row\\n            int valid=validity[i];\\n            for(int j=0;j<(1<<n);j++){\\n                //go through the configuration of seats,total configurations 1<<n i.e 2^n\\n                if((j&valid)!=j){\\n                    continue;//j must be a subset of valid\\n\\t\\t\\t\\t\\t//valid contains the valid configuraion of avaliable seats where students can be placed for this ith row,\\n\\t\\t\\t\\t\\t//if the given configuration of students i.e \"j\" itself is invalid which means it isn\\'t a subset of the \"valid\" then continue\\n                }\\n                if((j&(j>>1))){\\n                    continue;//no two students must be adjacent,given in the question\\n                }\\n                for(int k=0;k<(1<<n);k++){\\n                    if(dp[i-1][k]==-1){\\n                        continue;//invalid state\\n                    }\\n                    if((j&(k>>1)) || (k&(j>>1))){\\n                        continue;//checking if upper right and upper left seats are occupied which will lead to cheating\\n                    }\\n                    //reaching this state all the constraints are satisfied\\n                    dp[i][j]=max(dp[i][j],dp[i-1][k]+__builtin_popcount(j));\\n                }\\n            }\\n        }\\n        return *max_element(dp[m].begin(),dp[m].end());//last row\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //one of the best of the best dp with bitmasking problem itself to understand dp with bitmask\\n        \\n         int m=seats.size();//rows\\n        int n=seats[0].size();//columns\\n        vector<int> validity(m+1);//remember we are taking m+1 not m\\n        //so first row is the 1th row not 0th\\n        for(int i=0;i<m;i++){\\n            int rowvalid=0;\\n            for(int j=0;j<n;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    rowvalid+=(1<<j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1913478,
                "title": "dp-memoization-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[9][9][256][256];\\n    \\n    // Function to check if a state is valid\\n    \\n    bool check(int mask,int i)\\n    {\\n        if(i<0)\\n            return true;\\n        return (((1<<i)&mask) ==0);\\n    }\\n    int solve(int i,int j,int prev,int curr,vector<vector<char>> a)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(dp[i][j][prev][curr]!=-1)\\n            return dp[i][j][prev][curr];\\n        int ans = 0;\\n        \\n        // check If the state is valid and can we place a student at i,j ?\\n        \\n        if(check(prev,j-1) && check(prev,j+1) && check(curr,j-1) && a[i][j]!=\\'#\\')\\n        {\\n            if(j == n-1)\\n                ans = 1 + solve(i+1,0,curr|1<<j,0,a);     // if it is the last column   \\n            else\\n                ans = 1 + solve(i,j+1,prev,curr|1<<j,a); \\n        }\\n        \\n        // proceed without placing a student at i,j\\n        \\n        if(j == n-1)\\n            ans = max(ans,solve(i+1,0,curr,0,a));\\n        else\\n            ans = max(ans,solve(i,j+1,prev,curr,a));\\n            \\n        dp[i][j][prev][curr] = ans;\\n        return dp[i][j][prev][curr];\\n        \\n    }\\n    int maxStudents(vector<vector<char>>& seats) \\n    {    \\n        memset(dp,-1,sizeof(dp));\\n        m = seats.size();\\n        n = seats[0].size();\\n        return solve(0,0,0,0,seats);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[9][9][256][256];\\n    \\n    // Function to check if a state is valid\\n    \\n    bool check(int mask,int i)\\n    {\\n        if(i<0)\\n            return true;\\n        return (((1<<i)&mask) ==0);\\n    }\\n    int solve(int i,int j,int prev,int curr,vector<vector<char>> a)\\n    {\\n        if(i==m)\\n            return 0;\\n        if(dp[i][j][prev][curr]!=-1)\\n            return dp[i][j][prev][curr];\\n        int ans = 0;\\n        \\n        // check If the state is valid and can we place a student at i,j ?\\n        \\n        if(check(prev,j-1) && check(prev,j+1) && check(curr,j-1) && a[i][j]!=\\'#\\')\\n        {\\n            if(j == n-1)\\n                ans = 1 + solve(i+1,0,curr|1<<j,0,a);     // if it is the last column   \\n            else\\n                ans = 1 + solve(i,j+1,prev,curr|1<<j,a); \\n        }\\n        \\n        // proceed without placing a student at i,j\\n        \\n        if(j == n-1)\\n            ans = max(ans,solve(i+1,0,curr,0,a));\\n        else\\n            ans = max(ans,solve(i,j+1,prev,curr,a));\\n            \\n        dp[i][j][prev][curr] = ans;\\n        return dp[i][j][prev][curr];\\n        \\n    }\\n    int maxStudents(vector<vector<char>>& seats) \\n    {    \\n        memset(dp,-1,sizeof(dp));\\n        m = seats.size();\\n        n = seats[0].size();\\n        return solve(0,0,0,0,seats);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703500,
                "title": "python-max-flow-edmond-karp-algorithm",
                "content": "Below is the Python implementation of Max Flow Algorithm (Edmond-Karp) based on BFS. \\nNot as clean as other\\'s Hungarian Algorithm, but might be useful for some.\\n\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        \\n        graph = defaultdict(dict)\\n        total_seats = 0\\n        source = (-1, -1)\\n        sink = (R, C)\\n        \\n\\t\\t# seats at even row are on the source side\\n\\t\\t# create forward edge as well as backward edge (residual edge) with all neighbours (including odd-row seats and source)\\n        for r in range(R):\\n            for c in range(0, C, 2):\\n                if seats[r][c] == \\'#\\': continue\\n                total_seats += 1\\n                graph[source][r, c] = 1\\n                graph[r, c][source] = 0\\n                for nr, nc in [(r, c-1), (r-1, c-1), (r-1, c+1), (r, c+1), (r+1, c+1), (r+1, c-1)]:\\n                    if 0 <= nr < R and 0 <= nc < C and seats[nr][nc] == \\'.\\':\\n                        graph[r, c][nr, nc] = 1\\n                        graph[nr, nc][r, c] = 0\\n        \\n\\t\\t# create edges for the odd-row seats with sink\\n        for r in range(R):\\n            for c in range(1, C, 2):\\n                if seats[r][c] == \\'#\\': continue\\n                total_seats += 1\\n                graph[r, c][sink] = 1\\n                graph[sink][r, c] = 0\\n    \\n\\t\\t# bfs to find a path from source to sink. if found, augmenting the edges along the path\\n\\t\\t# here all the edge capacity is max 1, therefore, once a path is found, we can include max network flow by 1\\n        def bfs(node, graph):\\n            visited = {node}\\n            queue = deque([node])\\n            parent = {node: None}\\n            \\n            found = False\\n            while queue:\\n                curr = queue.popleft()\\n                if curr == (R, C):\\n                    found = True\\n                    break\\n                for nei in graph[curr]:\\n                    if nei in visited or graph[curr][nei] == 0: continue\\n                    visited.add(nei)\\n                    queue.append(nei)\\n                    parent[nei] = curr\\n            \\n            if not found: return False\\n            curr = (R, C)\\n            prev = parent[curr]\\n            while prev:               # this is the augmenting part, decrease forward edge by 1, and increase backwared edge by 1\\n                graph[prev][curr] -= 1\\n                graph[curr][prev] += 1\\n                curr, prev = prev, parent[prev]\\n            return True\\n        \\n\\t\\t# max flow equals min cut, equals maximum bipartite matching, meaning at least this amount of seats can\\'t be used.\\n        min_cut = 0\\n        while bfs(source, graph):\\n            min_cut += 1\\n\\n        return total_seats - min_cut\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        \\n        graph = defaultdict(dict)\\n        total_seats = 0\\n        source = (-1, -1)\\n        sink = (R, C)\\n        \\n\\t\\t# seats at even row are on the source side\\n\\t\\t# create forward edge as well as backward edge (residual edge) with all neighbours (including odd-row seats and source)\\n        for r in range(R):\\n            for c in range(0, C, 2):\\n                if seats[r][c] == \\'#\\': continue\\n                total_seats += 1\\n                graph[source][r, c] = 1\\n                graph[r, c][source] = 0\\n                for nr, nc in [(r, c-1), (r-1, c-1), (r-1, c+1), (r, c+1), (r+1, c+1), (r+1, c-1)]:\\n                    if 0 <= nr < R and 0 <= nc < C and seats[nr][nc] == \\'.\\':\\n                        graph[r, c][nr, nc] = 1\\n                        graph[nr, nc][r, c] = 0\\n        \\n\\t\\t# create edges for the odd-row seats with sink\\n        for r in range(R):\\n            for c in range(1, C, 2):\\n                if seats[r][c] == \\'#\\': continue\\n                total_seats += 1\\n                graph[r, c][sink] = 1\\n                graph[sink][r, c] = 0\\n    \\n\\t\\t# bfs to find a path from source to sink. if found, augmenting the edges along the path\\n\\t\\t# here all the edge capacity is max 1, therefore, once a path is found, we can include max network flow by 1\\n        def bfs(node, graph):\\n            visited = {node}\\n            queue = deque([node])\\n            parent = {node: None}\\n            \\n            found = False\\n            while queue:\\n                curr = queue.popleft()\\n                if curr == (R, C):\\n                    found = True\\n                    break\\n                for nei in graph[curr]:\\n                    if nei in visited or graph[curr][nei] == 0: continue\\n                    visited.add(nei)\\n                    queue.append(nei)\\n                    parent[nei] = curr\\n            \\n            if not found: return False\\n            curr = (R, C)\\n            prev = parent[curr]\\n            while prev:               # this is the augmenting part, decrease forward edge by 1, and increase backwared edge by 1\\n                graph[prev][curr] -= 1\\n                graph[curr][prev] += 1\\n                curr, prev = prev, parent[prev]\\n            return True\\n        \\n\\t\\t# max flow equals min cut, equals maximum bipartite matching, meaning at least this amount of seats can\\'t be used.\\n        min_cut = 0\\n        while bfs(source, graph):\\n            min_cut += 1\\n\\n        return total_seats - min_cut\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578328,
                "title": "4ms-cpp-dp-bitmask-bottom-top-using-all-mask-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), S = 1 << n;\\n        vector<int> valid(m);\\n        for(int i = 0; i < m; i++){\\n            int a = 0;\\n            for(int j = 0; j < n; j++){\\n                if(A[i][j] == \\'.\\')\\n                    a += (1 << j);\\n            }\\n            valid[i] = a;\\n        }\\n        \\n        vector<vector<int>> dp(m, vector<int>(S));\\n        for(int i = valid[0]; i > 0; i = (i-1)&valid[0]){\\n            if((i << 1 & i) == 0)\\n                dp[0][i] = __builtin_popcount(i);\\n            \\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            dp[i][0] = *max_element(dp[i-1].begin(), dp[i-1].end());\\n            for(int j = valid[i]; j > 0; j = (j-1)&valid[i]){\\n                if(j << 1 & j) continue;\\n                int sb = __builtin_popcount(j);\\n                dp[i][j] = sb + dp[i-1][0];\\n                for(int k = valid[i-1]; k > 0; k = (k-1) & valid[i-1]){\\n                    if((j << 1 & k) == 0 and (j & k << 1) == 0){\\n                        dp[i][j] = max(dp[i-1][k] + sb, dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```\\n\\nhttps://cp-algorithms.com/algebra/all-submasks.html",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& A) {\\n        int m = A.size(), n = A[0].size(), S = 1 << n;\\n        vector<int> valid(m);\\n        for(int i = 0; i < m; i++){\\n            int a = 0;\\n            for(int j = 0; j < n; j++){\\n                if(A[i][j] == \\'.\\')\\n                    a += (1 << j);\\n            }\\n            valid[i] = a;\\n        }\\n        \\n        vector<vector<int>> dp(m, vector<int>(S));\\n        for(int i = valid[0]; i > 0; i = (i-1)&valid[0]){\\n            if((i << 1 & i) == 0)\\n                dp[0][i] = __builtin_popcount(i);\\n            \\n        }\\n        \\n        for(int i = 1; i < m; i++){\\n            dp[i][0] = *max_element(dp[i-1].begin(), dp[i-1].end());\\n            for(int j = valid[i]; j > 0; j = (j-1)&valid[i]){\\n                if(j << 1 & j) continue;\\n                int sb = __builtin_popcount(j);\\n                dp[i][j] = sb + dp[i-1][0];\\n                for(int k = valid[i-1]; k > 0; k = (k-1) & valid[i-1]){\\n                    if((j << 1 & k) == 0 and (j & k << 1) == 0){\\n                        dp[i][j] = max(dp[i-1][k] + sb, dp[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m-1].begin(), dp[m-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1102427,
                "title": "clean-java-bitmask-with-rolling-dp",
                "content": "```\\nclass Solution {\\n    public int maxStudents(char[][] seats) {\\n       \\n        int m = seats.length, n = seats[0].length;\\n \\n        int max =0;\\n        int[][] dp = new int[2][1<<n];\\n        for(int i=0;i<m;i++){\\n            int valid = 0;\\n            for(int k=0;k<n;k++){\\n                if(seats[i][k]==\\'.\\'){\\n                    valid = valid |(1<<k);\\n                }\\n            }\\n           \\n            for(int j=0;j<1<<n;j++){\\n                int curRow = Integer.bitCount(j);\\n                if((j|valid)!=valid) continue;\\n                if((j & (j >> 1))>0) continue;\\n                \\n                for(int p=0;p<1<<n;p++){\\n                    if((j&(p>>1))>0) continue;\\n                    if((j&(p<<1))>0) continue;\\n                    dp[i%2][j] = Math.max(dp[i%2][j],dp[(i+1)%2][p]+curRow);\\n                }\\n                if(i==m-1){\\n                    max=Math.max(max,dp[i%2][j]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxStudents(char[][] seats) {\\n       \\n        int m = seats.length, n = seats[0].length;\\n \\n        int max =0;\\n        int[][] dp = new int[2][1<<n];\\n        for(int i=0;i<m;i++){\\n            int valid = 0;\\n            for(int k=0;k<n;k++){\\n                if(seats[i][k]==\\'.\\'){\\n                    valid = valid |(1<<k);\\n                }\\n            }\\n           \\n            for(int j=0;j<1<<n;j++){\\n                int curRow = Integer.bitCount(j);\\n                if((j|valid)!=valid) continue;\\n                if((j & (j >> 1))>0) continue;\\n                \\n                for(int p=0;p<1<<n;p++){\\n                    if((j&(p>>1))>0) continue;\\n                    if((j&(p<<1))>0) continue;\\n                    dp[i%2][j] = Math.max(dp[i%2][j],dp[(i+1)%2][p]+curRow);\\n                }\\n                if(i==m-1){\\n                    max=Math.max(max,dp[i%2][j]);\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 988450,
                "title": "max-flow-ford-fulkerson-and-edmonds-karp-algorithm-solution-in-javascript",
                "content": "Refer solution posted by @SGwin  https://leetcode.com/problems/maximum-students-taking-exam/discuss/505562/Max-Flow-(Edmonds-Karp-algorithm)-solution-(C%2B%2B)\\n\\n\\n```\\nconst bfs = (graph, source, target) => {\\n    const n = graph.length;\\n    const visited = new Array(n).fill(false); \\n    const parent = new Array(n).fill(null);\\n    \\n    // initialize queue\\n    const queue = [source];\\n    visited[source] = true;\\n    parent[source] = null;\\n    \\n    while(queue.length > 0) {\\n        const node = queue.shift();\\n        \\n        // if match to target then return\\n        if(node === target) {\\n            return parent\\n        }\\n        \\n        // process neighbor of current node as per available residual capacity and edge\\n        \\n        \\n        for (let neighbor=0; neighbor < n; neighbor++) {\\n            if(!visited[neighbor] && graph[node][neighbor] >=1) {\\n                visited[neighbor]= true;\\n                parent[neighbor] = node;\\n                queue.push(neighbor); // Add into queue\\n            }\\n        }\\n    }\\n    return parent;\\n}\\n\\nconst buildGraph = (seats) => {\\n    const m = seats.length;\\n    const n = seats[0].length;  \\n    \\n    /* \\n    - Each cell in grid represent vertext of graph\\n    - This is going to a weighted graph to store residual capacity for edge\\n    - Since we need to keep updating residual capacity therefore adjacency list representation is not a optimal approach to represent graph\\n    - Best is to represent in adjacency matrix for easy way to update weight which is residual capacity of graph        \\n    - There will be total m *n nodes\\n    - Goal is to apply Ford Fulkerson Edmon Karp algo therefore add two more additional nodes as source and target\\n    - First need to divide graph into bipartite graph\\n    - Then add source to left and target to right to mimic network flow\\n    - Place alternate column nodes to two different bipartite graph\\n    - i.e. j = 0, 2, 4, 6,....n will be in group A\\n        - j = 1, 3, 5 ......n will be in group B\\n        - source node will be connected to even column \\n        - target node will be connected to odd column\\n    */\\n    const source = m * n ;\\n    const target = m * n + 1;\\n    \\n    // direction for cheating\\n    const directions = [[0,-1],[-1,-1],[1,-1],[0,1],[-1,1],[1,1]];\\n    \\n    // adjacency matrix will be of size (m*n + 2)\\n    const graph = new Array(m*n+2).fill(0).map(a => new Array(m*n+2).fill(0)); // initialize residual capacity as 0\\n    let seatCount = 0;\\n    // iterate given seats to build graph\\n    for (let i=0; i < m; i++) {\\n        for (let j=0; j < n; j++) {\\n            \\n            // if broken seat then skip\\n            if(seats[i][j] === \\'#\\') {\\n                continue;\\n            }\\n            seatCount++;\\n            const node = i * n + j;\\n            \\n            if(j % 2 === 0) {\\n                // bipartite group A\\n                // Add capacity as 1 edge from source to node\\n                graph[source][node] = 1;\\n                \\n                // Add bipartite edge from node to neighbor\\n                for (const [p,q] of directions) {\\n                    const x = i + p;\\n                    const y = j + q;\\n\\n                    // skip\\n                    if(x < 0 || x >= m || y < 0 || y >= n || seats[x][y]===\\'#\\') {\\n                        continue;\\n                    }\\n                    const neighbor = x * n + y;\\n                    \\n                    // Add 1 as residual capacity                    \\n                    graph[node][neighbor] = 1; \\n                }  \\n                 \\n                \\n            }  else {\\n                // bipartite group B\\n                // Add capacity as 1 edge to target\\n                graph[node][target] = 1;\\n            }\\n            \\n        }\\n    } \\n    return {\\n        seatCount,\\n        graph,\\n        source,\\n        target\\n    }\\n}\\nconst getMaxNetworkFlow = (graph, source, target) => {\\n    // Keep applying max network flow algo if shortest path is available\\n    let flow = 0;\\n    while(true) {\\n        const parent = bfs(graph, source, target);\\n        if(!parent[target]) {\\n            break;\\n        }\\n        // decrease residual capacity for shortest path and increase for reverse\\n        let v = target;\\n        while(v !== source) {\\n            const u = parent[v];\\n            graph[u][v]--;\\n            graph[v][u]++;\\n            \\n            v = u;\\n        }\\n        \\n        flow++;\\n    }\\n    return flow;\\n}\\n/**\\n * @param {character[][]} seats\\n * @return {number}\\n */\\nvar maxStudents = function(seats) {\\n    /**\\n    - m * n matrix seat\\n    - seats distributions in a classroom\\n    - If a seat is broken, it is denoted by \\'#\\'\\n    - otherwise it is denoted by a \\'.\\'\\n    - Students can see the answers of those sitting next to the left, right, upper left and upper right,\\n    - but he cannot see the answers of the student sitting directly in front or behind him.\\n    - Return the maximum number of students that can take the exam together without any cheating being possible..\\n    - Students must be placed in seats in good condition.\\n    - Approach: \\n        - use max flow algo to compute max matches\\n            - maximum independent set on the bipartite graph)\\n        - \\n    */\\n    \\n    // Build adjacency matrix graph and retrieve other related data\\n    const { seatCount, graph, source, target } = buildGraph(seats);\\n    // Get max number of students can do cheating after applying network flow algo\\n    const maxCheatingAsPerFlowNetwork = getMaxNetworkFlow(graph, source, target);\\n    \\n    // remaining students can be placed safely\\n    return seatCount - maxCheatingAsPerFlowNetwork;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst bfs = (graph, source, target) => {\\n    const n = graph.length;\\n    const visited = new Array(n).fill(false); \\n    const parent = new Array(n).fill(null);\\n    \\n    // initialize queue\\n    const queue = [source];\\n    visited[source] = true;\\n    parent[source] = null;\\n    \\n    while(queue.length > 0) {\\n        const node = queue.shift();\\n        \\n        // if match to target then return\\n        if(node === target) {\\n            return parent\\n        }\\n        \\n        // process neighbor of current node as per available residual capacity and edge\\n        \\n        \\n        for (let neighbor=0; neighbor < n; neighbor++) {\\n            if(!visited[neighbor] && graph[node][neighbor] >=1) {\\n                visited[neighbor]= true;\\n                parent[neighbor] = node;\\n                queue.push(neighbor); // Add into queue\\n            }\\n        }\\n    }\\n    return parent;\\n}\\n\\nconst buildGraph = (seats) => {\\n    const m = seats.length;\\n    const n = seats[0].length;  \\n    \\n    /* \\n    - Each cell in grid represent vertext of graph\\n    - This is going to a weighted graph to store residual capacity for edge\\n    - Since we need to keep updating residual capacity therefore adjacency list representation is not a optimal approach to represent graph\\n    - Best is to represent in adjacency matrix for easy way to update weight which is residual capacity of graph        \\n    - There will be total m *n nodes\\n    - Goal is to apply Ford Fulkerson Edmon Karp algo therefore add two more additional nodes as source and target\\n    - First need to divide graph into bipartite graph\\n    - Then add source to left and target to right to mimic network flow\\n    - Place alternate column nodes to two different bipartite graph\\n    - i.e. j = 0, 2, 4, 6,....n will be in group A\\n        - j = 1, 3, 5 ......n will be in group B\\n        - source node will be connected to even column \\n        - target node will be connected to odd column\\n    */\\n    const source = m * n ;\\n    const target = m * n + 1;\\n    \\n    // direction for cheating\\n    const directions = [[0,-1],[-1,-1],[1,-1],[0,1],[-1,1],[1,1]];\\n    \\n    // adjacency matrix will be of size (m*n + 2)\\n    const graph = new Array(m*n+2).fill(0).map(a => new Array(m*n+2).fill(0)); // initialize residual capacity as 0\\n    let seatCount = 0;\\n    // iterate given seats to build graph\\n    for (let i=0; i < m; i++) {\\n        for (let j=0; j < n; j++) {\\n            \\n            // if broken seat then skip\\n            if(seats[i][j] === \\'#\\') {\\n                continue;\\n            }\\n            seatCount++;\\n            const node = i * n + j;\\n            \\n            if(j % 2 === 0) {\\n                // bipartite group A\\n                // Add capacity as 1 edge from source to node\\n                graph[source][node] = 1;\\n                \\n                // Add bipartite edge from node to neighbor\\n                for (const [p,q] of directions) {\\n                    const x = i + p;\\n                    const y = j + q;\\n\\n                    // skip\\n                    if(x < 0 || x >= m || y < 0 || y >= n || seats[x][y]===\\'#\\') {\\n                        continue;\\n                    }\\n                    const neighbor = x * n + y;\\n                    \\n                    // Add 1 as residual capacity                    \\n                    graph[node][neighbor] = 1; \\n                }  \\n                 \\n                \\n            }  else {\\n                // bipartite group B\\n                // Add capacity as 1 edge to target\\n                graph[node][target] = 1;\\n            }\\n            \\n        }\\n    } \\n    return {\\n        seatCount,\\n        graph,\\n        source,\\n        target\\n    }\\n}\\nconst getMaxNetworkFlow = (graph, source, target) => {\\n    // Keep applying max network flow algo if shortest path is available\\n    let flow = 0;\\n    while(true) {\\n        const parent = bfs(graph, source, target);\\n        if(!parent[target]) {\\n            break;\\n        }\\n        // decrease residual capacity for shortest path and increase for reverse\\n        let v = target;\\n        while(v !== source) {\\n            const u = parent[v];\\n            graph[u][v]--;\\n            graph[v][u]++;\\n            \\n            v = u;\\n        }\\n        \\n        flow++;\\n    }\\n    return flow;\\n}\\n/**\\n * @param {character[][]} seats\\n * @return {number}\\n */\\nvar maxStudents = function(seats) {\\n    /**\\n    - m * n matrix seat\\n    - seats distributions in a classroom\\n    - If a seat is broken, it is denoted by \\'#\\'\\n    - otherwise it is denoted by a \\'.\\'\\n    - Students can see the answers of those sitting next to the left, right, upper left and upper right,\\n    - but he cannot see the answers of the student sitting directly in front or behind him.\\n    - Return the maximum number of students that can take the exam together without any cheating being possible..\\n    - Students must be placed in seats in good condition.\\n    - Approach: \\n        - use max flow algo to compute max matches\\n            - maximum independent set on the bipartite graph)\\n        - \\n    */\\n    \\n    // Build adjacency matrix graph and retrieve other related data\\n    const { seatCount, graph, source, target } = buildGraph(seats);\\n    // Get max number of students can do cheating after applying network flow algo\\n    const maxCheatingAsPerFlowNetwork = getMaxNetworkFlow(graph, source, target);\\n    \\n    // remaining students can be placed safely\\n    return seatCount - maxCheatingAsPerFlowNetwork;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653043,
                "title": "c-bitmask-dp",
                "content": "eg. [student , no , student , no , student] -> 10101\\nlet S = status of seating student on row i\\nDP[S][i] = max{DP[S\\'][i - 1] | as long as S\\' can be S\\'s previous row} + number of 1s in S\\nans = max{DP[S][N] | as long as S is good status}\\n```\\nclass Solution {\\npublic:\\n    \\n    const int inf = 1e9;\\n    int DP[1 << 8][9];\\n    int N , M;\\n        \\n    bool check1(vector<vector<char>>& a , int i , int j){\\n        for(int x = 0; x < M; ++x){\\n            if((1 << x) & j){\\n                if(a[i - 1][x] == \\'#\\')\\n                    return 0;\\n                if(x - 1 >= 0 && (1 << (x - 1)) & j)\\n                    return 0;\\n                if(x + 1 < M && (1 << (x + 1)) & j)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    bool check2(int j , int k){\\n        for(int i = 0; i < M; ++i){\\n            if((1 << i) & j){\\n                if(i - 1 >= 0 && k & (1 << (i - 1))){\\n                    return 0;\\n                }\\n                if(i + 1 < M && k & (1 << (i + 1))){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& a) {\\n        N = a.size(); M = a[0].size();\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < (1 << M); ++j){\\n                DP[j][i] = -inf;\\n            }\\n        }\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < (1 << M); ++j){\\n                if(check1(a , i , j)){\\n                    for(int k = 0; k < (1 << M); ++k){\\n                        if(check2(j , k)){\\n                            DP[j][i] = max(DP[j][i] , DP[k][i - 1] + __builtin_popcount(j));\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for(int s = 0; s < (1 << M); ++s){\\n            ret = max(ret , DP[s][N]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    const int inf = 1e9;\\n    int DP[1 << 8][9];\\n    int N , M;\\n        \\n    bool check1(vector<vector<char>>& a , int i , int j){\\n        for(int x = 0; x < M; ++x){\\n            if((1 << x) & j){\\n                if(a[i - 1][x] == \\'#\\')\\n                    return 0;\\n                if(x - 1 >= 0 && (1 << (x - 1)) & j)\\n                    return 0;\\n                if(x + 1 < M && (1 << (x + 1)) & j)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    bool check2(int j , int k){\\n        for(int i = 0; i < M; ++i){\\n            if((1 << i) & j){\\n                if(i - 1 >= 0 && k & (1 << (i - 1))){\\n                    return 0;\\n                }\\n                if(i + 1 < M && k & (1 << (i + 1))){\\n                    return 0;\\n                }\\n            }\\n        }\\n        return 1;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& a) {\\n        N = a.size(); M = a[0].size();\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < (1 << M); ++j){\\n                DP[j][i] = -inf;\\n            }\\n        }\\n        for(int i = 1; i <= N; ++i){\\n            for(int j = 0; j < (1 << M); ++j){\\n                if(check1(a , i , j)){\\n                    for(int k = 0; k < (1 << M); ++k){\\n                        if(check2(j , k)){\\n                            DP[j][i] = max(DP[j][i] , DP[k][i - 1] + __builtin_popcount(j));\\n                        }\\n                    } \\n                }\\n            }\\n        }\\n        int ret = 0;\\n        for(int s = 0; s < (1 << M); ++s){\\n            ret = max(ret , DP[s][N]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577331,
                "title": "c-top-down-dp-solution-0ms-beat-100",
                "content": "Please go through [this](https://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem) tutorial first. Coding style is moslty inspired from the below tutorial.\\nhttps://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\n\\n`dp[height][mask] = number of 1\\'s in mask + max(dp[height - 1][mask\\'])` for all possible mask\\' \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>locations;//To store non-broken seats in each row as a bitmask\\n    int m,n;\\n    vector<vector<int>>memo;\\n    int dp(vector<vector<char>>& seats,int height,int prevRowArrangement){\\n        if(height>=m )return 0;\\n        if(memo[height][prevRowArrangement]!=-1) return memo[height][prevRowArrangement];\\n        int ans=0;\\n        for(int i=0;i<(1<<n);++i){\\n            if( ( (locations[height]&i)==i) && !(i&(i<<1)) && !(i&(i>>1)) ){//Students should sit on non-broken seats and no student should sit adjacent to each other. Refer to the tutorial for more understanding\\n                if(height>0){\\n                    if(i & (prevRowArrangement<<1)) continue; //for any student, no other student should sit on NorthEast\\n                    if(i & (prevRowArrangement>>1)) continue; //for any student, no other student should sit on NorthWest\\n                }\\n                ans=max(ans,dp(seats,height+1,i)+__builtin_popcount(i));\\n            }\\n        }\\n        return memo[height][prevRowArrangement]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        m=seats.size();\\n        if(!m) return 0;\\n        locations.clear();\\n        n=seats.front().size();\\n        for(int i=0;i<m;i++){\\n            int res=0;\\n            for(int j=0;j<n;++j){\\n                res=2*res+(seats[i][j]==\\'.\\');\\n            }\\n            locations.push_back(res); \\n        }\\n        \\n        memo.assign(m,vector<int>(1<<n,-1));\\n        \\n        return dp(seats,0,0);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>locations;//To store non-broken seats in each row as a bitmask\\n    int m,n;\\n    vector<vector<int>>memo;\\n    int dp(vector<vector<char>>& seats,int height,int prevRowArrangement){\\n        if(height>=m )return 0;\\n        if(memo[height][prevRowArrangement]!=-1) return memo[height][prevRowArrangement];\\n        int ans=0;\\n        for(int i=0;i<(1<<n);++i){\\n            if( ( (locations[height]&i)==i) && !(i&(i<<1)) && !(i&(i>>1)) ){//Students should sit on non-broken seats and no student should sit adjacent to each other. Refer to the tutorial for more understanding\\n                if(height>0){\\n                    if(i & (prevRowArrangement<<1)) continue; //for any student, no other student should sit on NorthEast\\n                    if(i & (prevRowArrangement>>1)) continue; //for any student, no other student should sit on NorthWest\\n                }\\n                ans=max(ans,dp(seats,height+1,i)+__builtin_popcount(i));\\n            }\\n        }\\n        return memo[height][prevRowArrangement]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        m=seats.size();\\n        if(!m) return 0;\\n        locations.clear();\\n        n=seats.front().size();\\n        for(int i=0;i<m;i++){\\n            int res=0;\\n            for(int j=0;j<n;++j){\\n                res=2*res+(seats[i][j]==\\'.\\');\\n            }\\n            locations.push_back(res); \\n        }\\n        \\n        memo.assign(m,vector<int>(1<<n,-1));\\n        \\n        return dp(seats,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504941,
                "title": "java-dfs-memo-bitmask-and-maxflow-sol",
                "content": "DP\\n```\\nclass Solution {\\n    int dp[][]=new int[260][260];\\n    List<Integer>lists[];\\n    public int maxStudents(char[][] grid) {\\n        int res=0;\\n        lists=new ArrayList[grid.length];\\n        for(int i=0;i<lists.length;i++)lists[i]=new ArrayList<>();\\n        for(int i=0;i<grid.length;i++)generate(grid,i,0,0);\\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++)dp[r][c]=-1;\\n        }\\n        return dfs(-1,0);\\n    }\\n    public int dfs(int r,int index){\\n        if(r==lists.length-1){\\n            return Integer.bitCount(lists[r].get(index));\\n        }\\n        if(r!=-1&&dp[r][index]!=-1)return dp[r][index];\\n        List<Integer>nextrow=lists[r+1];\\n        int curState=0;int ans=0;\\n        if(r>=0){\\n            curState=lists[r].get(index);\\n        }\\n        for(int i=0;i<nextrow.size();i++){\\n            int nextstate=nextrow.get(i);\\n            if(check(curState,nextstate)){\\n                ans=Math.max(ans,Integer.bitCount(curState)+dfs(r+1,i));\\n            }\\n        }\\n        if(r!=-1)dp[r][index]=ans;\\n        return ans;\\n    }\\n    \\n    public void generate(char[][] grid,int r,int c,int bit){\\n        if(c>=grid[0].length){\\n            lists[r].add(bit);\\n            return;\\n        }\\n        if(grid[r][c]==\\'#\\'){\\n            generate(grid,r,c+1,bit);\\n        }\\n        else if(c>=1&&(bit&(1<<c-1))!=0){//we have placeed the previous\\n            generate(grid,r,c+1,bit);\\n        }\\n        else{\\n            generate(grid,r,c+1,bit);\\n            generate(grid,r,c+1,(bit|(1<<c)));\\n        }\\n    }\\n    \\n    public boolean check(int curbit,int nextbit){\\n        List<Integer>list1=new ArrayList<>();\\n        List<Integer>list2=new ArrayList<>();\\n        for(int i=0;i<10;i++){\\n            list1.add(curbit&1);\\n            list2.add(nextbit&1);\\n            curbit=curbit>>1;\\n            nextbit=nextbit>>1;\\n        }\\n        for(int i=0;i<list1.size()-1;i++){\\n            if(i==0){\\n                if(list1.get(i)==1&&list2.get(i+1)==1)return false;\\n            }\\n            else if(list1.get(i)==1){\\n                if(list2.get(i-1)==1||list2.get(i+1)==1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\nMAX Flow\\n```\\nclass Solution {\\n    int flow=0;\\n    int S,T;\\n    int graph[][];\\n    public int maxStudents(char[][] seats) {\\n        int total=0;\\n        int row=seats.length,col=seats[0].length;\\n        graph=new int[row*col+2][row*col+2];\\n        S=row*col;\\n        T=row*col+1;\\n        int dir[][]=new int[][]{{0,-1},{-1,-1},{1,-1},{0,1},{-1,1},{1,1}};\\n        for(int r=0;r<seats.length;r++){\\n            for(int c=0;c<seats[0].length;c++){\\n                if(seats[r][c]==\\'#\\')continue;\\n                total++;\\n                int pos=r*seats[0].length+c;\\n                if(c%2!=0){//even\\n                    graph[S][pos]=1;\\n                    for(int i=0;i<6;i++){\\n                        int nr=r+dir[i][0];\\n                        int nc=c+dir[i][1];\\n                        if(nr<0||nr>=seats.length||nc<0||nc>=seats[0].length||seats[nr][nc]==\\'#\\')continue;\\n                        graph[pos][nr*seats[0].length+nc]=1;\\n                    }\\n                }else{//odd\\n                    graph[pos][T]=1;\\n                }\\n            }\\n        }\\n        while(true){\\n            int path[]=new int[graph.length];\\n            Arrays.fill(path,-1);\\n            boolean visit[]=new boolean[path.length];\\n            Queue<Integer>queue=new LinkedList<>();\\n            queue.add(S);\\n            visit[S]=true;\\n            while(queue.size()!=0){\\n                int parent=queue.poll();\\n                if(parent==T)break;\\n                for(int i=0;i<graph.length;i++){\\n                    if(!visit[i]&&graph[parent][i]==1){\\n                        visit[i]=true;\\n                        path[i]=parent;\\n                        queue.add(i);\\n                    }\\n                }\\n            }\\n            if(path[T]==-1)break;\\n            int cur=T;\\n            while(true){\\n                int p=path[cur];\\n                graph[p][cur]-=1;\\n                graph[cur][p]+=1;\\n                cur=p;\\n                if(cur==S)break;\\n            }\\n            flow++;\\n        }\\n        return total-flow;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[][]=new int[260][260];\\n    List<Integer>lists[];\\n    public int maxStudents(char[][] grid) {\\n        int res=0;\\n        lists=new ArrayList[grid.length];\\n        for(int i=0;i<lists.length;i++)lists[i]=new ArrayList<>();\\n        for(int i=0;i<grid.length;i++)generate(grid,i,0,0);\\n        for(int r=0;r<dp.length;r++){\\n            for(int c=0;c<dp[0].length;c++)dp[r][c]=-1;\\n        }\\n        return dfs(-1,0);\\n    }\\n    public int dfs(int r,int index){\\n        if(r==lists.length-1){\\n            return Integer.bitCount(lists[r].get(index));\\n        }\\n        if(r!=-1&&dp[r][index]!=-1)return dp[r][index];\\n        List<Integer>nextrow=lists[r+1];\\n        int curState=0;int ans=0;\\n        if(r>=0){\\n            curState=lists[r].get(index);\\n        }\\n        for(int i=0;i<nextrow.size();i++){\\n            int nextstate=nextrow.get(i);\\n            if(check(curState,nextstate)){\\n                ans=Math.max(ans,Integer.bitCount(curState)+dfs(r+1,i));\\n            }\\n        }\\n        if(r!=-1)dp[r][index]=ans;\\n        return ans;\\n    }\\n    \\n    public void generate(char[][] grid,int r,int c,int bit){\\n        if(c>=grid[0].length){\\n            lists[r].add(bit);\\n            return;\\n        }\\n        if(grid[r][c]==\\'#\\'){\\n            generate(grid,r,c+1,bit);\\n        }\\n        else if(c>=1&&(bit&(1<<c-1))!=0){//we have placeed the previous\\n            generate(grid,r,c+1,bit);\\n        }\\n        else{\\n            generate(grid,r,c+1,bit);\\n            generate(grid,r,c+1,(bit|(1<<c)));\\n        }\\n    }\\n    \\n    public boolean check(int curbit,int nextbit){\\n        List<Integer>list1=new ArrayList<>();\\n        List<Integer>list2=new ArrayList<>();\\n        for(int i=0;i<10;i++){\\n            list1.add(curbit&1);\\n            list2.add(nextbit&1);\\n            curbit=curbit>>1;\\n            nextbit=nextbit>>1;\\n        }\\n        for(int i=0;i<list1.size()-1;i++){\\n            if(i==0){\\n                if(list1.get(i)==1&&list2.get(i+1)==1)return false;\\n            }\\n            else if(list1.get(i)==1){\\n                if(list2.get(i-1)==1||list2.get(i+1)==1)return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int flow=0;\\n    int S,T;\\n    int graph[][];\\n    public int maxStudents(char[][] seats) {\\n        int total=0;\\n        int row=seats.length,col=seats[0].length;\\n        graph=new int[row*col+2][row*col+2];\\n        S=row*col;\\n        T=row*col+1;\\n        int dir[][]=new int[][]{{0,-1},{-1,-1},{1,-1},{0,1},{-1,1},{1,1}};\\n        for(int r=0;r<seats.length;r++){\\n            for(int c=0;c<seats[0].length;c++){\\n                if(seats[r][c]==\\'#\\')continue;\\n                total++;\\n                int pos=r*seats[0].length+c;\\n                if(c%2!=0){//even\\n                    graph[S][pos]=1;\\n                    for(int i=0;i<6;i++){\\n                        int nr=r+dir[i][0];\\n                        int nc=c+dir[i][1];\\n                        if(nr<0||nr>=seats.length||nc<0||nc>=seats[0].length||seats[nr][nc]==\\'#\\')continue;\\n                        graph[pos][nr*seats[0].length+nc]=1;\\n                    }\\n                }else{//odd\\n                    graph[pos][T]=1;\\n                }\\n            }\\n        }\\n        while(true){\\n            int path[]=new int[graph.length];\\n            Arrays.fill(path,-1);\\n            boolean visit[]=new boolean[path.length];\\n            Queue<Integer>queue=new LinkedList<>();\\n            queue.add(S);\\n            visit[S]=true;\\n            while(queue.size()!=0){\\n                int parent=queue.poll();\\n                if(parent==T)break;\\n                for(int i=0;i<graph.length;i++){\\n                    if(!visit[i]&&graph[parent][i]==1){\\n                        visit[i]=true;\\n                        path[i]=parent;\\n                        queue.add(i);\\n                    }\\n                }\\n            }\\n            if(path[T]==-1)break;\\n            int cur=T;\\n            while(true){\\n                int p=path[cur];\\n                graph[p][cur]-=1;\\n                graph[cur][p]+=1;\\n                cur=p;\\n                if(cur==S)break;\\n            }\\n            flow++;\\n        }\\n        return total-flow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503650,
                "title": "c-dfs-memo-bitcoding-two-rows",
                "content": "\\tint maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size(), mn = m*n;\\n        \\n\\t\\t/* can sit @ (p, q) ? */\\n        auto cansit = [&](int p, int q){\\n            if (seats[p][q] != \\'.\\'){return false;};\\n            if ((q > (  0)) && (seats[p][q-1] == \\'S\\')){return false;};\\n            if ((q < (n-1)) && (seats[p][q+1] == \\'S\\')){return false;};\\n            \\n            if (((p > 0) && (q > (  0))) && (seats[p-1][q-1] == \\'S\\')){return false;};\\n            if (((p > 0) && (q < (n-1))) && (seats[p-1][q+1] == \\'S\\')){return false;};\\n            \\n            return true;\\n        };\\n        \\n\\t\\t/* memo of dp (prev row, curr row, x, y) */\\n        unordered_map<int, int> memo;\\n        \\n        function<int(int, int,int,int)> dfs;\\n        dfs = [&](int p, int q, int prev, int curr){\\n            if (p == m){return 0;}\\n            if (q == 0){prev = curr; curr = 0;}\\n            \\n\\t\\t\\t/* bitcoding dp state */\\n            int codes = (prev << 16) | (curr << 8) | (p << 4) | q;\\n            if (memo.count(codes)){return memo[codes];}\\n            \\n\\t\\t\\t/* next position */\\n            int x = p, y = q + 1;\\n            if (y == n){\\n                y = 0;\\n                x = x + 1;\\n            }\\n            \\n            /* can I put a student here */\\n            int S1 = dfs(x, y, prev, curr) + 0;\\n            int S2 = 0;\\n            \\n            if (cansit(p, q)){\\n                curr |= (1 << q);\\n                \\n                seats[p][q] = \\'S\\';\\n                S2 = dfs(x, y, prev, curr) + 1;\\n                seats[p][q] = \\'.\\';\\n            }\\n            \\n            return (memo[codes] = max(S1, S2));\\n        };\\n        \\n        return dfs(0, 0, 0, 0);\\n    }",
                "solutionTags": [],
                "code": "\\tint maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size(), mn = m*n;\\n        \\n\\t\\t/* can sit @ (p, q) ? */\\n        auto cansit = [&](int p, int q){\\n            if (seats[p][q] != \\'.\\'){return false;};\\n            if ((q > (  0)) && (seats[p][q-1] == \\'S\\')){return false;};\\n            if ((q < (n-1)) && (seats[p][q+1] == \\'S\\')){return false;};\\n            \\n            if (((p > 0) && (q > (  0))) && (seats[p-1][q-1] == \\'S\\')){return false;};\\n            if (((p > 0) && (q < (n-1))) && (seats[p-1][q+1] == \\'S\\')){return false;};\\n            \\n            return true;\\n        };\\n        \\n\\t\\t/* memo of dp (prev row, curr row, x, y) */\\n        unordered_map<int, int> memo;\\n        \\n        function<int(int, int,int,int)> dfs;\\n        dfs = [&](int p, int q, int prev, int curr){\\n            if (p == m){return 0;}\\n            if (q == 0){prev = curr; curr = 0;}\\n            \\n\\t\\t\\t/* bitcoding dp state */\\n            int codes = (prev << 16) | (curr << 8) | (p << 4) | q;\\n            if (memo.count(codes)){return memo[codes];}\\n            \\n\\t\\t\\t/* next position */\\n            int x = p, y = q + 1;\\n            if (y == n){\\n                y = 0;\\n                x = x + 1;\\n            }\\n            \\n            /* can I put a student here */\\n            int S1 = dfs(x, y, prev, curr) + 0;\\n            int S2 = 0;\\n            \\n            if (cansit(p, q)){\\n                curr |= (1 << q);\\n                \\n                seats[p][q] = \\'S\\';\\n                S2 = dfs(x, y, prev, curr) + 1;\\n                seats[p][q] = \\'.\\';\\n            }\\n            \\n            return (memo[codes] = max(S1, S2));\\n        };\\n        \\n        return dfs(0, 0, 0, 0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3878662,
                "title": "w-o-bitmasking-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string, int>mp;\\n    int n, m;\\n\\n    bool isValid(int i, int j, vector<vector<char>>& seats) {\\n        if(i == 0) {\\n            if(j-1 >= 0 && seats[0][j-1] == \\'@\\')return false;\\n            if(j+1 < m && seats[0][j+1] == \\'@\\')return false;\\n            return true;\\n        }\\n        if(j-1 >= 0 && (seats[i-1][j-1] == \\'@\\' || seats[i][j-1] == \\'@\\'))return false;\\n        if(j+1 < m && (seats[i-1][j+1] == \\'@\\' || seats[i][j+1] == \\'@\\'))return false;\\n        return true;\\n    }\\n\\n    int f(int ind, vector<vector<char>>& seats) {\\n        if(ind == n * m)return 0;\\n\\n        int i = ind / m, j = ind % m;\\n        string s = to_string(ind);\\n        if(i-1 >= 0) \\n            for(int j = 0; j < m; j++) s += \"_\" + to_string(seats[i-1][j]);\\n        for(int j = 0; j < m; j++) s += \"_\" + to_string(seats[i][j]);\\n\\n        if(mp.find(s) != mp.end())return mp[s];\\n\\n        int skip = f(ind+1, seats);\\n        int pick = 0;\\n        if(seats[i][j] == \\'.\\' && isValid(i, j, seats)) {\\n            seats[i][j] = \\'@\\';\\n            pick = 1 + f(ind+1, seats);\\n            seats[i][j] = \\'.\\';\\n        }\\n        return mp[s] = max(pick, skip);\\n    }\\n\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size(), m = seats[0].size();\\n        return f(0, seats);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string, int>mp;\\n    int n, m;\\n\\n    bool isValid(int i, int j, vector<vector<char>>& seats) {\\n        if(i == 0) {\\n            if(j-1 >= 0 && seats[0][j-1] == \\'@\\')return false;\\n            if(j+1 < m && seats[0][j+1] == \\'@\\')return false;\\n            return true;\\n        }\\n        if(j-1 >= 0 && (seats[i-1][j-1] == \\'@\\' || seats[i][j-1] == \\'@\\'))return false;\\n        if(j+1 < m && (seats[i-1][j+1] == \\'@\\' || seats[i][j+1] == \\'@\\'))return false;\\n        return true;\\n    }\\n\\n    int f(int ind, vector<vector<char>>& seats) {\\n        if(ind == n * m)return 0;\\n\\n        int i = ind / m, j = ind % m;\\n        string s = to_string(ind);\\n        if(i-1 >= 0) \\n            for(int j = 0; j < m; j++) s += \"_\" + to_string(seats[i-1][j]);\\n        for(int j = 0; j < m; j++) s += \"_\" + to_string(seats[i][j]);\\n\\n        if(mp.find(s) != mp.end())return mp[s];\\n\\n        int skip = f(ind+1, seats);\\n        int pick = 0;\\n        if(seats[i][j] == \\'.\\' && isValid(i, j, seats)) {\\n            seats[i][j] = \\'@\\';\\n            pick = 1 + f(ind+1, seats);\\n            seats[i][j] = \\'.\\';\\n        }\\n        return mp[s] = max(pick, skip);\\n    }\\n\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        n = seats.size(), m = seats[0].size();\\n        return f(0, seats);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882400,
                "title": "javascript-hungary-105ms",
                "content": "```\\n//////////////////////// Template /////////////////////////////////\\nfunction HungarianBipartiteGraph(g) {\\n    let vis = new Set(), n = g.length, match = Array(n).fill(-1);\\n    return { maxMatch }\\n    function maxMatch() {\\n        let res = 0;\\n        for (let i = 0; i < n; i++) {\\n            vis.clear();\\n            res += dfs(i);\\n        }\\n        return res;\\n    }\\n    function dfs(cur) {\\n        for (const child of g[cur]) {\\n            if (vis.has(child)) continue;\\n            vis.add(child);\\n            if (match[child] < 0 || dfs(match[child])) {\\n                match[child] = cur;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n////////////////////////////////////////////////////////////////\\n\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst maxStudents = (seats) => {\\n    let n = seats.length, m = seats[0].length, cnt = 0, g = initializeGraph(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (seats[i][j] == \\'.\\') {\\n                cnt++;\\n                let x = i * m + j, y;\\n                for (let k = -1; k <= 1; k++) {\\n                    if (i + k >= 0 && i + k < n && j - 1 >= 0 && seats[i + k][j - 1] == \\'.\\') {\\n                        y = (i + k) * m + (j - 1);\\n                        g[x].push(y);\\n                    }\\n                    if (i + k >= 0 && i + k < n && j + 1 < m && seats[i + k][j + 1] == \\'.\\') {\\n                        y = (i + k) * m + (j + 1);\\n                        g[x].push(y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    let hun = HungarianBipartiteGraph(g), conflict = hun.maxMatch();\\n    return cnt - conflict / 2;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Graph"
                ],
                "code": "```\\n//////////////////////// Template /////////////////////////////////\\nfunction HungarianBipartiteGraph(g) {\\n    let vis = new Set(), n = g.length, match = Array(n).fill(-1);\\n    return { maxMatch }\\n    function maxMatch() {\\n        let res = 0;\\n        for (let i = 0; i < n; i++) {\\n            vis.clear();\\n            res += dfs(i);\\n        }\\n        return res;\\n    }\\n    function dfs(cur) {\\n        for (const child of g[cur]) {\\n            if (vis.has(child)) continue;\\n            vis.add(child);\\n            if (match[child] < 0 || dfs(match[child])) {\\n                match[child] = cur;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n////////////////////////////////////////////////////////////////\\n\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst maxStudents = (seats) => {\\n    let n = seats.length, m = seats[0].length, cnt = 0, g = initializeGraph(n * m);\\n    for (let i = 0; i < n; i++) {\\n        for (let j = 0; j < m; j++) {\\n            if (seats[i][j] == \\'.\\') {\\n                cnt++;\\n                let x = i * m + j, y;\\n                for (let k = -1; k <= 1; k++) {\\n                    if (i + k >= 0 && i + k < n && j - 1 >= 0 && seats[i + k][j - 1] == \\'.\\') {\\n                        y = (i + k) * m + (j - 1);\\n                        g[x].push(y);\\n                    }\\n                    if (i + k >= 0 && i + k < n && j + 1 < m && seats[i + k][j + 1] == \\'.\\') {\\n                        y = (i + k) * m + (j + 1);\\n                        g[x].push(y);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    let hun = HungarianBipartiteGraph(g), conflict = hun.maxMatch();\\n    return cnt - conflict / 2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2522928,
                "title": "d-p-the-4th-dimension",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(vi(vi(vi(ll))))dp;\\n    ll func(vi(vi(char))& v, ll i, ll j, ll bmu, ll bml) {\\n        if (j == n) {\\n            ++i, j = bmu = bml = 0;\\n            for (ll k = 0;k < n;++k) {\\n                if (v[i - 1][k] == \\'*\\') {\\n                    bmu |= 1 << k;\\n                }\\n            }\\n        }\\n        if (i == m) {\\n            return 0;\\n        }\\n        if (dp[i][j][bmu][bml] == -1) {\\n            dp[i][j][bmu][bml] = func(v, i, j + 1, bmu, bml);\\n            if (v[i][j] == \\'.\\' && (j == 0 || v[i][j - 1] != \\'*\\') && (j == n - 1 || v[i][j + 1] != \\'*\\') && (i == 0 || j == 0 || v[i - 1][j - 1] != \\'*\\') && (i == 0 || j == n - 1 || v[i - 1][j + 1] != \\'*\\')) {\\n                v[i][j] = \\'*\\';\\n                dp[i][j][bmu][bml] = max(dp[i][j][bmu][bml], 1 + func(v, i, j + 1, bmu, bml | (1 << j)));\\n                v[i][j] = \\'.\\';\\n            }\\n        }\\n        return dp[i][j][bmu][bml];\\n    }\\n    int maxStudents(vector<vector<char>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(vi(vi(ll)))(n, vi(vi(ll))(1 << n, vi(ll)(1 << n, -1))));\\n        return func(v, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\n#define vi(x) vector<x>\\npublic:\\n    ll m, n;\\n    vi(vi(vi(vi(ll))))dp;\\n    ll func(vi(vi(char))& v, ll i, ll j, ll bmu, ll bml) {\\n        if (j == n) {\\n            ++i, j = bmu = bml = 0;\\n            for (ll k = 0;k < n;++k) {\\n                if (v[i - 1][k] == \\'*\\') {\\n                    bmu |= 1 << k;\\n                }\\n            }\\n        }\\n        if (i == m) {\\n            return 0;\\n        }\\n        if (dp[i][j][bmu][bml] == -1) {\\n            dp[i][j][bmu][bml] = func(v, i, j + 1, bmu, bml);\\n            if (v[i][j] == \\'.\\' && (j == 0 || v[i][j - 1] != \\'*\\') && (j == n - 1 || v[i][j + 1] != \\'*\\') && (i == 0 || j == 0 || v[i - 1][j - 1] != \\'*\\') && (i == 0 || j == n - 1 || v[i - 1][j + 1] != \\'*\\')) {\\n                v[i][j] = \\'*\\';\\n                dp[i][j][bmu][bml] = max(dp[i][j][bmu][bml], 1 + func(v, i, j + 1, bmu, bml | (1 << j)));\\n                v[i][j] = \\'.\\';\\n            }\\n        }\\n        return dp[i][j][bmu][bml];\\n    }\\n    int maxStudents(vector<vector<char>>& v) {\\n        m = v.size(), n = v[0].size();\\n        dp.assign(m, vi(vi(vi(ll)))(n, vi(vi(ll))(1 << n, vi(ll)(1 << n, -1))));\\n        return func(v, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454138,
                "title": "detailed-explanation-of-solution",
                "content": "Let\\u2019s consider a sample case where no seat is broken.\\n`seats = [[\".\",\".\",\".\",\".\",\".\"], [\".\",\".\",\".\",\".\",\".\"],[\".\",\".\",\".\",\".\",\".\"]]`\\n\\n*Q. What is the maximum number of students that can take the exam together without cheating?*\\nA. **9**. It is when they sit in alternate columns.\\n\\n```\\nO X O X O\\nO X O X O\\nO X O X O\\n```\\nO means position where a student is sitting and X is a vacant seat.\\n\\nThe above example gives us the following intuition:-\\nLet the non-broken seats be nodes in a graph G with an edge going from a node u to v if cheating is possible.\\nWe can see that the graph G is a bipartite graph with odd and even columns making the two disjoint sets (since there can be no edge between two seats in even columns and no edge between two seats in odd columns).\\nOur goal is then to find the **maximum independent set** in this graph.\\n\\n*Maximum independent set is an independent set with maximum cardinality, where independent set is a subset of nodes U such that any two nodes u, v \\u03B5 U are not adjacent.*\\n\\nNow, `Maximum Independent Set = Number of Nodes - Maximum Bipartite Matching`\\n\\nWe know that maximum bipartite matching can be easily transformed to a max-flow network problem (by adding source and sink dummy nodes).\\n\\nHence, eventually the approach to this problem is like this:-\\n1. Build a bipartite graph using the available non-broken seats, and add a source and sink node to convert it to a network. All edges will have a capacity of 1. Let the number of nodes in the bipartite graph (without source and sink node) be N.\\n1. Compute the max-flow in the network using Ford-Fulkerson. Let the max-flow value be F.\\n1. Solution = Maximum Independent Set = N - F\\n\\nSample Case:\\n`seats = [[\"#\",\".\",\"#\",\"#\",\".\",\"#\"], [\".\",\"#\",\"#\",\"#\",\"#\",\".\"], [\"#\",\".\",\"#\",\"#\",\".\",\"#\"]]`\\nLet us name the seats/nodes as `[[\"#\",\"A\",\"#\",\"#\",\"B\",\"#\"], [\"C\",\"#\",\"#\",\"#\",\"#\",\"D\"], [\"#\",\"E\",\"#\",\"#\",\"F\",\"#\"]]`\\n\\nAnd let the source node be S and sink node be T.\\nNOTE: All edges have a capacity of 1.\\n![image](https://assets.leetcode.com/users/images/b351a9b3-8ab7-48e7-a5a1-c639128bb6d4_1661010826.868703.png)\\n\\nThen, the network will look as below:-\\n   Value of number of nodes (N) = 6 Value of max-flow (F) = 2 Solution = N - F = 4.",
                "solutionTags": [],
                "code": "```\\nO X O X O\\nO X O X O\\nO X O X O\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297586,
                "title": "c-solution-based-on-bfs-and-recursion-with-memorization",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, int> records;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        int m = seats.size(), n = seats.front().size();\\n        if (n == 1){// special case: there is only one column\\n            int result = 0;\\n            for (int y = 0; y < m; y++){\\n                if (seats[y][0] == \\'.\\'){\\n                    result++;\\n                }\\n            }\\n            return result;\\n        }\\n        return helper(seats, m, n, 0, string(n, \\'#\\'));\\n    }\\n    \\n    /*  subproblem function, initially call:\\n        helper(seats, m, n, 0)\\n    */\\n    int helper(vector<vector<char>>& seats, int m, int n, int y, string prev){\\n        \\n        if (y == m){\\n            return 0;\\n        }\\n        string state = string(1, y - \\'0\\') + prev;\\n        if (this->records.count(state) == 1){\\n            return this->records[state];\\n        }\\n        \\n        /*  according to the prev layer, calculate all the possible permutations in this layer\\n        */\\n        int sub, result = 0;\\n        queue<pair<int, string>> units;\\n        units.push({0, string()});\\n        /*  sign description:  \\'#\\': damage seat\\n                                \\'.\\': a space available seat\\n                                \\'*\\': a seat with person\\n        */\\n        int x = 0;\\n        while(x < n){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                auto unit = units.front();  units.pop();\\n                // unit.second is the current state\\n                if (seats[y][x] == \\'#\\'){\\n                    unit.second.push_back(\\'#\\');\\n                    units.push(unit);\\n                }   \\n                else{// seats[y][x] is \\'.\\'\\n                    if (x == 0){\\n                        if (prev[1] != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();\\n                        }\\n                    }\\n                    else if (x == n - 1){\\n                        if (prev[x - 1] != \\'*\\' && unit.second.back() != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();                                \\n                        }                        \\n                    }\\n                    else{// x >= 1 and x <= n - 2\\n                        if (prev[x - 1] != \\'*\\' && prev[x + 1] != \\'*\\' && unit.second.back() != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();                                \\n                        }\\n                    }\\n                    // do not seat\\n                    unit.second.push_back(\\'.\\');\\n                    units.push(unit);\\n                    unit.second.pop_back();\\n                }\\n            }\\n            x++;\\n        }\\n        while(!units.empty()){\\n            auto unit = units.front();  units.pop();\\n            sub = unit.first + helper(seats, m, n, y + 1, unit.second);\\n            result = max(result, sub);\\n        }\\n        this->records.insert({state, result});\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<string, int> records;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        int m = seats.size(), n = seats.front().size();\\n        if (n == 1){// special case: there is only one column\\n            int result = 0;\\n            for (int y = 0; y < m; y++){\\n                if (seats[y][0] == \\'.\\'){\\n                    result++;\\n                }\\n            }\\n            return result;\\n        }\\n        return helper(seats, m, n, 0, string(n, \\'#\\'));\\n    }\\n    \\n    /*  subproblem function, initially call:\\n        helper(seats, m, n, 0)\\n    */\\n    int helper(vector<vector<char>>& seats, int m, int n, int y, string prev){\\n        \\n        if (y == m){\\n            return 0;\\n        }\\n        string state = string(1, y - \\'0\\') + prev;\\n        if (this->records.count(state) == 1){\\n            return this->records[state];\\n        }\\n        \\n        /*  according to the prev layer, calculate all the possible permutations in this layer\\n        */\\n        int sub, result = 0;\\n        queue<pair<int, string>> units;\\n        units.push({0, string()});\\n        /*  sign description:  \\'#\\': damage seat\\n                                \\'.\\': a space available seat\\n                                \\'*\\': a seat with person\\n        */\\n        int x = 0;\\n        while(x < n){\\n            int round_size = units.size();\\n            for (int i = 0; i < round_size; i++){\\n                auto unit = units.front();  units.pop();\\n                // unit.second is the current state\\n                if (seats[y][x] == \\'#\\'){\\n                    unit.second.push_back(\\'#\\');\\n                    units.push(unit);\\n                }   \\n                else{// seats[y][x] is \\'.\\'\\n                    if (x == 0){\\n                        if (prev[1] != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();\\n                        }\\n                    }\\n                    else if (x == n - 1){\\n                        if (prev[x - 1] != \\'*\\' && unit.second.back() != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();                                \\n                        }                        \\n                    }\\n                    else{// x >= 1 and x <= n - 2\\n                        if (prev[x - 1] != \\'*\\' && prev[x + 1] != \\'*\\' && unit.second.back() != \\'*\\'){// can seat here\\n                            unit.second.push_back(\\'*\\');\\n                            unit.first++;\\n                            units.push(unit);\\n                            unit.first--;\\n                            unit.second.pop_back();                                \\n                        }\\n                    }\\n                    // do not seat\\n                    unit.second.push_back(\\'.\\');\\n                    units.push(unit);\\n                    unit.second.pop_back();\\n                }\\n            }\\n            x++;\\n        }\\n        while(!units.empty()){\\n            auto unit = units.front();  units.pop();\\n            sub = unit.first + helper(seats, m, n, y + 1, unit.second);\\n            result = max(result, sub);\\n        }\\n        this->records.insert({state, result});\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191378,
                "title": "c-dp-with-bit-masking",
                "content": "```\\nclass Solution {\\nprivate:\\n    //checks whether cheating is possible\\n    bool cheat(int prev_mask,int curr_mask){\\n        //whether the student can cheat from their own row\\n        if(curr_mask&(curr_mask>>1) or (curr_mask&(curr_mask<<1))){\\n            return true;\\n        } else if(curr_mask&(prev_mask>>1) or curr_mask&(prev_mask<<1)){\\n            //whether the students can cheat from the row in front of them\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int rows=seats.size(),cols=seats[0].size();\\n        //stores the configuration of chairs\\n        //0->broken chair\\n        //1->good condition\\n        vector<int>validpos(rows,0);\\n        for(int i=0;i<seats.size();i++){\\n            for(int j=0;j<seats[i].size();j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    validpos[i]^=(1<<j);\\n                }\\n            }\\n        }\\n\\t\\t//stores the row and current row seating as state variables\\n        vector<vector<int>>dp(rows,vector<int>(1<<cols,-1));\\n        for(int i=0;i<rows;i++){\\n            //enumerating all possible combination of seating plans for the current row\\n            for(int curr_mask=0;curr_mask<(1<<cols);curr_mask++){\\n                //the current seating plan should not place a student on a broken chair, meaning \\n                //the current seating plan should only place a student(1) where the chair is in good condition\\n                if((curr_mask|validpos[i])==validpos[i]){\\n\\t\\t\\t\\t//count the number of 1s in the binary representation of a number\\n                    int cnt=__builtin_popcount(curr_mask);\\n                    if(i==0){\\n                        if(!cheat(0,curr_mask)){\\n                            dp[i][curr_mask]=cnt;\\n                        }\\n                    } else {\\n                        //enumerating all possible seating arrangements for the previous row\\n                        for(int prev_mask=0;prev_mask<(1<<cols);prev_mask++){\\n                            if((prev_mask|validpos[i-1])==validpos[i-1]){\\n                                if(dp[i-1][prev_mask]!=-1 and !cheat(prev_mask,curr_mask)){\\n                                    dp[i][curr_mask]=max(dp[i][curr_mask],dp[i-1][prev_mask]+cnt);\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return *max_element(dp[rows-1].begin(),dp[rows-1].end());\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "class Solution {\\nprivate:\\n    //checks whether cheating is possible\\n    bool cheat(int prev_mask,int curr_mask){\\n        //whether the student can cheat from their own row\\n        if(curr_mask&(curr_mask>>1) or (curr_mask&(curr_mask<<1))){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2069634,
                "title": "backtracking-and-memo",
                "content": "```\\nclass Solution {\\n    int dp[8][8][255][255];\\n    int dfs(vector<vector<char>>& s, int x, int y, int thisrow_mask, int prevrow_mask) {\\n        int m = s.size();\\n        int n = s[0].size();\\n        if (y == n) {\\n            y = 0;\\n            x++;\\n            prevrow_mask = thisrow_mask;\\n            thisrow_mask = 0;\\n        }\\n        if (x == m)\\n            return 0;\\n        if (dp[x][y][thisrow_mask][prevrow_mask] != -1)\\n            return dp[x][y][thisrow_mask][prevrow_mask];\\n        int res = dfs(s, x, y + 1, thisrow_mask, prevrow_mask);\\n        bool cancopy = (x > 0 && y > 0 && (prevrow_mask & (1 << (y - 1)))) ||\\n                       (x > 0 && y < n - 1 && (prevrow_mask & (1 << (y + 1)))) ||\\n                       (y > 0 && (thisrow_mask & (1 << (y - 1))));\\n        if (!cancopy && s[x][y] == \\'.\\')\\n            res = max(res, 1 + dfs(s, x, y + 1, thisrow_mask | (1 << y), prevrow_mask));\\n        return dp[x][y][thisrow_mask][prevrow_mask] = res;\\n    }\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(seats, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int dp[8][8][255][255];\\n    int dfs(vector<vector<char>>& s, int x, int y, int thisrow_mask, int prevrow_mask) {\\n        int m = s.size();\\n        int n = s[0].size();\\n        if (y == n) {\\n            y = 0;\\n            x++;\\n            prevrow_mask = thisrow_mask;\\n            thisrow_mask = 0;\\n        }\\n        if (x == m)\\n            return 0;\\n        if (dp[x][y][thisrow_mask][prevrow_mask] != -1)\\n            return dp[x][y][thisrow_mask][prevrow_mask];\\n        int res = dfs(s, x, y + 1, thisrow_mask, prevrow_mask);\\n        bool cancopy = (x > 0 && y > 0 && (prevrow_mask & (1 << (y - 1)))) ||\\n                       (x > 0 && y < n - 1 && (prevrow_mask & (1 << (y + 1)))) ||\\n                       (y > 0 && (thisrow_mask & (1 << (y - 1))));\\n        if (!cancopy && s[x][y] == \\'.\\')\\n            res = max(res, 1 + dfs(s, x, y + 1, thisrow_mask | (1 << y), prevrow_mask));\\n        return dp[x][y][thisrow_mask][prevrow_mask] = res;\\n    }\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp, -1, sizeof(dp));\\n        return dfs(seats, 0, 0, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953941,
                "title": "c-clean-bit-masking-solution-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/maximum-students-taking-exam/\\n    \\n    Core idea is for the ith row, we need to decide the sitting arrangement based on the\\n    arrangement of previous row.\\n    We use bit masking for storing the seating layout for each row, since there are can be\\n    2^cols arrangements, we create a dp[rows+1][2^cols].\\n    \\n    Now iterate through each row and for each row, check if the layout is valid or not (seats are avail).\\n    Then check with each of the possible seating layouts of prev row, each time ensuring that there are \\n    no diagonal seats, left and right seats in the current row. If the previous layout is compatible with\\n    current row layout, then update the number of students that can sit till current row.\\n    \\n    TC: O(N * 2^M * 2^M)\\n    SC: O(N*2^M)\\n*/\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if(seats.empty())\\n            return 0;\\n        const int N = seats.size();\\n        const int M = seats[0].size();\\n        \\n        // avail_seats[i] = bit encoded representation of all avail seating positions\\n        // 1: avail seat, 0: seat not avail\\n        vector<int> avail_seats(N+1);\\n        \\n        // for each row, find the avail seats\\n        for(int i = 1; i <= N; i++)\\n            for(int j = 0; j < M; j++)\\n                if(seats[i-1][j] == \\'.\\')\\n                    avail_seats[i] = avail_seats[i] | (1 << j);\\n        \\n        // dp[i][mask]: Total number of students that can sit till ith row\\n        // mask: sitting layout of each student in the row, \\n        // eg: 1001 => students sitting at 0th and 3rd index\\n        // To make the code simpler, one extra row is taken, which doesnt exists\\n        vector<vector<int>> dp(N+1, vector<int>(1 << M, -1));\\n        \\n        // init starting row doesnt exists so it can have 0 students \\n        for(int mask = 0; mask < (1 << M); mask++)\\n            dp[0][mask] = 0;\\n        \\n        for(int i = 1; i <= N; i++) \\n            for(int mask = 0; mask < (1 << M); mask++) {\\n                // if current sitting layout is valid (positions have vacant seats)\\n                // below line checks if mask layout is a subset of avail_seats[i] (valid positions)\\n                if((mask & avail_seats[i]) != mask)\\n                    continue;\\n                // Also check if there are adjacent (both left and right) avail seats in curr layout\\n                if((mask & (mask << 1)) || (mask & (mask >> 1))) \\n                    continue;\\n                // once we know current layout has valid sitting positions,\\n                // we check tha max students that can sit in this layout by comparing\\n                // against the positions of student in prev row\\n                for(int prev_mask = 0; prev_mask < (1 << M); prev_mask++) {\\n                    // check if prev layout is valid or not\\n                    if(dp[i-1][prev_mask] == -1) \\n                        continue;\\n                    // check if any seats in prev layout is diagonally adjacent\\n                    // to seats in curr layout\\n                    if((mask & (prev_mask << 1)) || (mask & (prev_mask >> 1)))\\n                        continue;\\n                    dp[i][mask] = max(dp[i][mask],\\n                                      dp[i-1][prev_mask] + __builtin_popcount(mask));\\n                }\\n            }\\n        // pick the sitting arrangement that can sit the max students  \\n        return *max_element(dp[N].begin(), dp[N].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/maximum-students-taking-exam/\\n    \\n    Core idea is for the ith row, we need to decide the sitting arrangement based on the\\n    arrangement of previous row.\\n    We use bit masking for storing the seating layout for each row, since there are can be\\n    2^cols arrangements, we create a dp[rows+1][2^cols].\\n    \\n    Now iterate through each row and for each row, check if the layout is valid or not (seats are avail).\\n    Then check with each of the possible seating layouts of prev row, each time ensuring that there are \\n    no diagonal seats, left and right seats in the current row. If the previous layout is compatible with\\n    current row layout, then update the number of students that can sit till current row.\\n    \\n    TC: O(N * 2^M * 2^M)\\n    SC: O(N*2^M)\\n*/\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if(seats.empty())\\n            return 0;\\n        const int N = seats.size();\\n        const int M = seats[0].size();\\n        \\n        // avail_seats[i] = bit encoded representation of all avail seating positions\\n        // 1: avail seat, 0: seat not avail\\n        vector<int> avail_seats(N+1);\\n        \\n        // for each row, find the avail seats\\n        for(int i = 1; i <= N; i++)\\n            for(int j = 0; j < M; j++)\\n                if(seats[i-1][j] == \\'.\\')\\n                    avail_seats[i] = avail_seats[i] | (1 << j);\\n        \\n        // dp[i][mask]: Total number of students that can sit till ith row\\n        // mask: sitting layout of each student in the row, \\n        // eg: 1001 => students sitting at 0th and 3rd index\\n        // To make the code simpler, one extra row is taken, which doesnt exists\\n        vector<vector<int>> dp(N+1, vector<int>(1 << M, -1));\\n        \\n        // init starting row doesnt exists so it can have 0 students \\n        for(int mask = 0; mask < (1 << M); mask++)\\n            dp[0][mask] = 0;\\n        \\n        for(int i = 1; i <= N; i++) \\n            for(int mask = 0; mask < (1 << M); mask++) {\\n                // if current sitting layout is valid (positions have vacant seats)\\n                // below line checks if mask layout is a subset of avail_seats[i] (valid positions)\\n                if((mask & avail_seats[i]) != mask)\\n                    continue;\\n                // Also check if there are adjacent (both left and right) avail seats in curr layout\\n                if((mask & (mask << 1)) || (mask & (mask >> 1))) \\n                    continue;\\n                // once we know current layout has valid sitting positions,\\n                // we check tha max students that can sit in this layout by comparing\\n                // against the positions of student in prev row\\n                for(int prev_mask = 0; prev_mask < (1 << M); prev_mask++) {\\n                    // check if prev layout is valid or not\\n                    if(dp[i-1][prev_mask] == -1) \\n                        continue;\\n                    // check if any seats in prev layout is diagonally adjacent\\n                    // to seats in curr layout\\n                    if((mask & (prev_mask << 1)) || (mask & (prev_mask >> 1)))\\n                        continue;\\n                    dp[i][mask] = max(dp[i][mask],\\n                                      dp[i-1][prev_mask] + __builtin_popcount(mask));\\n                }\\n            }\\n        // pick the sitting arrangement that can sit the max students  \\n        return *max_element(dp[N].begin(), dp[N].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886808,
                "title": "c-backtracking-with-memoization",
                "content": "This one was tricky. My approach was to write regular backtracking solution and then optimize with memoization.\\n\\nTo write the backtracking problem, you basically iterate over each spot and try to place a student there.\\nI iterated through the seats using a single index that goes left to right at each row, working downward:\\nm = num rows\\nn = num cols\\ni = 0, ..., (mn - 1)\\nr = i / n\\nc = i % n\\n\\n* I use a recursive function that depends on i and counts the max number of students that can be placed starting from i.\\n* At each position (r, c) (which is computed from i), you try placing a student and not placing a student. Note that you can only place a student there if they do not enable cheating. I wrote a helper function to check around the position for possible cheating.\\n* If I place a student there, I marked the position with a \\'x\\' and make a recursive call.\\n* After the recursive call, I unmarked the position (hence this is backtracking).\\n* We have to compare the both outcomes of placing a student and not placing a student and pick the maximum.\\n\\nWhile this is a correct implementation, it will fail at the 53rd test case with TLE.\\n\\nThe key realization is that the max number of students that can be placed starting at some row depends only on the previous row. Since our backtracking solution is trying all possibilities, there are many times when the algorithm encounters a row with the same choice at the previous row as a previous encounter. In other words, there are redundant subproblems making DP/memoization applicable.\\n\\nTo actually implement this, we can just do a check at the beginning of each row and see if we have been there before with the same selection made in the previous row.\\nThere are two dimensions of this table, the first is the row number and the second is the selection at the previous row. We can represent the selection in the previous row using a bit mask, where a 1 in some ith bit position means that a student was place at column i in the last row.\\n\\nThe runtime of the backtracking solution is something like O(2^(MN)) where M and N are the number of rows and columns, respectively. (It\\'s actually less, since you can\\'t actually have a full row of students.)\\nWith memoization, the runtime becomes O(M2^(2N)). Here\\'s a crude diagram illustrating this:\\n(You have to go down two levels before you see the same row number and selection combinations.)\\n![image](https://assets.leetcode.com/users/images/c3f667e5-05d6-4e6a-97cd-6207ffa3f93a_1648355452.749866.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> cache;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        // for each open spot, try to place if possible\\n        return helper(seats, 0);\\n    }\\n    \\n    // need to cache based on last row\\n    int helper(vector<vector<char>>& seats, int i) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        if (i == m * n) {\\n            return 0;\\n        }\\n        int r = i / n;\\n        int c = i % n;\\n        if (c == 0 && r > 0) {\\n            // convert last row into int\\n            int key = convert(seats[r-1]);\\n            // check cache\\n            if (cache.find(r) != cache.end() && cache[r].find(key) != cache[r].end()) {\\n                return cache[r][key];\\n            }\\n        }\\n        \\n        int max_count = helper(seats, i + 1);\\n        if (seats[r][c] == \\'.\\') {\\n            // check to see if cheating is possible\\n            // no one is up left, up right, left, right, bottom left, bottom right\\n            if (check_neighbors(seats, r, c)) {\\n                seats[r][c] = \\'x\\';\\n                max_count = max(max_count, helper(seats, i + 1) + 1);\\n                seats[r][c] = \\'.\\';\\n            }\\n        }\\n        if (c == 0 && r > 0) {\\n            int key = convert(seats[r-1]);\\n            cache[r][key] = max_count;\\n        }\\n        \\n        return max_count;\\n    }\\n    \\n    int convert(vector<char>& row) {\\n        int n = 0;\\n        for (int i = 0; i < row.size(); ++i) {\\n            n = n * 2 + (row[i] == \\'x\\');\\n        }\\n        return n;\\n    }\\n    \\n    bool check_neighbors(vector<vector<char>>& seats, int r, int c) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        // upper\\n        if (r - 1 >= 0) {\\n            // upper left\\n            if (c - 1 >= 0 && seats[r-1][c-1] == \\'x\\') {\\n                return false;\\n            }\\n            // upper right\\n            if (c + 1 < n && seats[r-1][c+1] == \\'x\\') {\\n                return false;\\n            }\\n        } \\n        // left\\n        if (c - 1 >= 0 && seats[r][c-1] == \\'x\\') {\\n            return false;\\n        }\\n        // right\\n        if (c + 1 < n && seats[r][c+1] == \\'x\\') {\\n            return false;\\n        }\\n        // lower\\n        if (r + 1 < m) {\\n            // lower left\\n            if (c - 1 >= 0 && seats[r+1][c-1] == \\'x\\') {\\n                return false;\\n            }\\n            // lower right\\n            if (c + 1 < n && seats[r+1][c+1] == \\'x\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> cache;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        // for each open spot, try to place if possible\\n        return helper(seats, 0);\\n    }\\n    \\n    // need to cache based on last row\\n    int helper(vector<vector<char>>& seats, int i) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        if (i == m * n) {\\n            return 0;\\n        }\\n        int r = i / n;\\n        int c = i % n;\\n        if (c == 0 && r > 0) {\\n            // convert last row into int\\n            int key = convert(seats[r-1]);\\n            // check cache\\n            if (cache.find(r) != cache.end() && cache[r].find(key) != cache[r].end()) {\\n                return cache[r][key];\\n            }\\n        }\\n        \\n        int max_count = helper(seats, i + 1);\\n        if (seats[r][c] == \\'.\\') {\\n            // check to see if cheating is possible\\n            // no one is up left, up right, left, right, bottom left, bottom right\\n            if (check_neighbors(seats, r, c)) {\\n                seats[r][c] = \\'x\\';\\n                max_count = max(max_count, helper(seats, i + 1) + 1);\\n                seats[r][c] = \\'.\\';\\n            }\\n        }\\n        if (c == 0 && r > 0) {\\n            int key = convert(seats[r-1]);\\n            cache[r][key] = max_count;\\n        }\\n        \\n        return max_count;\\n    }\\n    \\n    int convert(vector<char>& row) {\\n        int n = 0;\\n        for (int i = 0; i < row.size(); ++i) {\\n            n = n * 2 + (row[i] == \\'x\\');\\n        }\\n        return n;\\n    }\\n    \\n    bool check_neighbors(vector<vector<char>>& seats, int r, int c) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        // upper\\n        if (r - 1 >= 0) {\\n            // upper left\\n            if (c - 1 >= 0 && seats[r-1][c-1] == \\'x\\') {\\n                return false;\\n            }\\n            // upper right\\n            if (c + 1 < n && seats[r-1][c+1] == \\'x\\') {\\n                return false;\\n            }\\n        } \\n        // left\\n        if (c - 1 >= 0 && seats[r][c-1] == \\'x\\') {\\n            return false;\\n        }\\n        // right\\n        if (c + 1 < n && seats[r][c+1] == \\'x\\') {\\n            return false;\\n        }\\n        // lower\\n        if (r + 1 < m) {\\n            // lower left\\n            if (c - 1 >= 0 && seats[r+1][c-1] == \\'x\\') {\\n                return false;\\n            }\\n            // lower right\\n            if (c + 1 < n && seats[r+1][c+1] == \\'x\\') {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383352,
                "title": "dp-rawmask-short",
                "content": "dp[i][pmask] :\\n           prev mask for each valid seat combination in a i raw\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int M, N;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        M = seats.size(), N = seats[0].size();\\n        dp.resize(M,vector<int>(1<<N,-1));\\n        return dfs(seats);\\n    }\\n    int dfs(vector<vector<char>>& seats, int i = 0, int pmask = 0){\\n        if(i==M) return  0;\\n        if (dp[i][pmask] !=  -1) return dp[i][pmask];\\n        int ans = 0, cur=0;\\n        \\n        for (int k=0; k < N; k++)  if (seats[i][k] != \\'#\\')  cur |= (1<<k);\\n        \\n        for ( int j=0, mask = cur & j; j< (1<<N); mask = cur & ++j){\\n            if (!(mask & (mask >> 1) || (pmask & (mask<<1)) || pmask & (mask>>1)) )\\n                ans  = max(ans,cntbits(mask) +  dfs(seats,i+1,mask));\\n        }\\n        return dp[i][pmask] = ans;\\n    }\\n    int cntbits(int n, int cnt=0){        \\n        while(n) ++cnt, n&=n-1;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int M, N;\\n    int maxStudents(vector<vector<char>>& seats) {\\n        M = seats.size(), N = seats[0].size();\\n        dp.resize(M,vector<int>(1<<N,-1));\\n        return dfs(seats);\\n    }\\n    int dfs(vector<vector<char>>& seats, int i = 0, int pmask = 0){\\n        if(i==M) return  0;\\n        if (dp[i][pmask] !=  -1) return dp[i][pmask];\\n        int ans = 0, cur=0;\\n        \\n        for (int k=0; k < N; k++)  if (seats[i][k] != \\'#\\')  cur |= (1<<k);\\n        \\n        for ( int j=0, mask = cur & j; j< (1<<N); mask = cur & ++j){\\n            if (!(mask & (mask >> 1) || (pmask & (mask<<1)) || pmask & (mask>>1)) )\\n                ans  = max(ans,cntbits(mask) +  dfs(seats,i+1,mask));\\n        }\\n        return dp[i][pmask] = ans;\\n    }\\n    int cntbits(int n, int cnt=0){        \\n        while(n) ++cnt, n&=n-1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761426,
                "title": "python-greedy",
                "content": "\\tclass Solution:\\n\\t\\tdef maxStudents(self, A: List[List[str]]) -> int:\\n\\n\\t\\t\\tm, n = len(A), len(A[0])\\n\\n\\t\\t\\td = defaultdict(set)\\n\\t\\t\\ts = set()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif A[i][j] == \\'.\\':\\n\\t\\t\\t\\t\\t\\ts.add((i, j))\\n\\t\\t\\t\\t\\t\\tfor x, y in [(i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j + 1), (i - 1, j - 1), (i - 1, j + 1)]:\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and A[x][y] == \\'.\\':\\n\\t\\t\\t\\t\\t\\t\\t\\td[(i, j)].add((x, y))\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile s:\\n\\t\\t\\t\\t# Crucial: Find the chair which has least influence\\n\\t\\t\\t\\tcur = min(list(s), key = lambda x:len(d[x]))\\n\\t\\t\\t\\ts.remove(cur)\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tfor sec in d[cur]:\\n\\t\\t\\t\\t\\tfor trd in d[sec]:\\n\\t\\t\\t\\t\\t\\tif trd != cur:\\n\\t\\t\\t\\t\\t\\t\\td[trd].remove(sec)\\n\\t\\t\\t\\t\\ts.remove(sec)\\n\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxStudents(self, A: List[List[str]]) -> int:\\n\\n\\t\\t\\tm, n = len(A), len(A[0])\\n\\n\\t\\t\\td = defaultdict(set)\\n\\t\\t\\ts = set()\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif A[i][j] == \\'.\\':\\n\\t\\t\\t\\t\\t\\ts.add((i, j))\\n\\t\\t\\t\\t\\t\\tfor x, y in [(i, j - 1), (i, j + 1), (i + 1, j - 1), (i + 1, j + 1), (i - 1, j - 1), (i - 1, j + 1)]:\\n\\t\\t\\t\\t\\t\\t\\tif 0 <= x < m and 0 <= y < n and A[x][y] == \\'.\\':\\n\\t\\t\\t\\t\\t\\t\\t\\td[(i, j)].add((x, y))\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile s:\\n\\t\\t\\t\\t# Crucial: Find the chair which has least influence\\n\\t\\t\\t\\tcur = min(list(s), key = lambda x:len(d[x]))\\n\\t\\t\\t\\ts.remove(cur)\\n\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\tfor sec in d[cur]:\\n\\t\\t\\t\\t\\tfor trd in d[sec]:\\n\\t\\t\\t\\t\\t\\tif trd != cur:\\n\\t\\t\\t\\t\\t\\t\\td[trd].remove(sec)\\n\\t\\t\\t\\t\\ts.remove(sec)\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 742276,
                "title": "easy-to-understand-dp-bitmasking-c",
                "content": "Here I used dp[i][mask] to store the value of maximum number of students in ith row and \"mask\" orientation(only if it is compatible with current row and above row).\\nThe function isvalid checks whether orientation \"mask\" is compatible for the current row(i.e. there is no 1 present on the broken chair). \\nThe function noconse checks if there is no two consecutive 1s in the mask(By shifting 1 place left and taking bitwise AND).\\nThe idea of the approach is as follows:\\nif i==0 then the maximum students will be equal to the number of 1s in mask if it is compatible with 0th row.\\nElse for any other row if the orientation mask is compatible with current row then dp[i][mask] will be maximum of all valid configurations of previous row + number of 1s in mask of current row.\\nFor checking validity of current row mask and previous row mask, I took the xor of both the values and checked for the consecutive ones(This proof is obvious). \\n```\\nclass Solution {\\npublic:\\n    \\n    bool isvalid(int mask,vector<char> &a)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int p=n-1-i;\\n            \\n            if(a[i]==\\'#\\' and (mask&(1<<p)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool noconse(int mask)\\n    {\\n        int p=mask<<1;\\n        int ans=p&mask;\\n        return (ans==0);\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        int m1=1<<m;\\n        vector<vector<int> >dp(n,vector<int>(m1,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=0;mask<m1;mask++)\\n            {\\n                if(isvalid(mask,seats[i]) and noconse(mask))\\n                {\\n                    \\n                    int cnt=__builtin_popcount(mask);\\n                    \\n                    if(i==0)\\n                    {\\n                        dp[i][mask]=cnt;\\n                    }\\n                    else{\\n                        int maxi=0;\\n\\n                        for(int temp=0;temp<m1;temp++)\\n                        {\\n                            int x1=mask^temp;\\n\\n                            if(noconse(x1) and dp[i-1][temp]!=-1)\\n                            {\\n                                maxi=max(maxi,cnt+dp[i-1][temp]);\\n                            }\\n\\n                        }\\n                        dp[i][mask]=maxi;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int mask=0;mask<m1;mask++)\\n        {\\n\\n            ans=max(ans,dp[n-1][mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isvalid(int mask,vector<char> &a)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int p=n-1-i;\\n            \\n            if(a[i]==\\'#\\' and (mask&(1<<p)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool noconse(int mask)\\n    {\\n        int p=mask<<1;\\n        int ans=p&mask;\\n        return (ans==0);\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        int m1=1<<m;\\n        vector<vector<int> >dp(n,vector<int>(m1,-1));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int mask=0;mask<m1;mask++)\\n            {\\n                if(isvalid(mask,seats[i]) and noconse(mask))\\n                {\\n                    \\n                    int cnt=__builtin_popcount(mask);\\n                    \\n                    if(i==0)\\n                    {\\n                        dp[i][mask]=cnt;\\n                    }\\n                    else{\\n                        int maxi=0;\\n\\n                        for(int temp=0;temp<m1;temp++)\\n                        {\\n                            int x1=mask^temp;\\n\\n                            if(noconse(x1) and dp[i-1][temp]!=-1)\\n                            {\\n                                maxi=max(maxi,cnt+dp[i-1][temp]);\\n                            }\\n\\n                        }\\n                        dp[i][mask]=maxi;\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(int mask=0;mask<m1;mask++)\\n        {\\n\\n            ans=max(ans,dp[n-1][mask]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700837,
                "title": "java-easy-to-understand-recursion-memoize",
                "content": "The below solution works but it can also be optimized with minor tweaks.\\n\\n```\\nprivate Map<String, Integer> MEMO = new HashMap<>();\\npublic int maxStudents(char[][] seats) {\\n       return recursion(seats, 0, 0, 0); \\n}\\n\\t\\nprivate int recursion(char[][] seats, int row, int col, int count) {\\n\\tif(row>seats.length-1 || col>seats[0].length-1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tString key = getKey(seats, row, col);\\n\\tif(MEMO.containsKey(key)) {\\n\\t\\treturn MEMO.get(key);\\n\\t}\\n\\tint result = 0;\\n\\tfor(int i=row; i<seats.length;i++) {\\n\\t\\tfor(int j=0;j<seats[0].length;j++) {\\n\\t\\t\\tif((i==row && j<col) || seats[i][j] != \\'.\\') {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else if((i-1>=0 && j-1 >= 0 && seats[i-1][j-1] == \\'1\\') || (i-1>=0 && j+1 <= seats[0].length-1 && seats[i-1][j+1] == \\'1\\') || (j-1>=0 && seats[i][j-1] == \\'1\\')){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tseats[i][j] = \\'1\\';\\n\\t\\t\\t\\tresult = Math.max(result, 1+recursion(seats, i, j, count));\\n\\t\\t\\t\\tseats[i][j] = \\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tMEMO.put(key, result);\\n\\treturn result;\\n}\\n\\t\\nprivate String getKey(char[][] seats, int i, int j) {\\n\\tString key = \"\";\\n\\tif(i-1>=0) {\\n\\t\\t  key += Arrays.toString(seats[i-1]);\\t\\n\\t}\\n\\tkey+=\":\" + Arrays.toString(seats[i]);\\n\\tkey+=\":\"+i+\":\"+j;\\n\\treturn key;\\n}",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "The below solution works but it can also be optimized with minor tweaks.\\n\\n```\\nprivate Map<String, Integer> MEMO = new HashMap<>();\\npublic int maxStudents(char[][] seats) {\\n       return recursion(seats, 0, 0, 0); \\n}\\n\\t\\nprivate int recursion(char[][] seats, int row, int col, int count) {\\n\\tif(row>seats.length-1 || col>seats[0].length-1) {\\n\\t\\treturn 0;\\n\\t}\\n\\tString key = getKey(seats, row, col);\\n\\tif(MEMO.containsKey(key)) {\\n\\t\\treturn MEMO.get(key);\\n\\t}\\n\\tint result = 0;\\n\\tfor(int i=row; i<seats.length;i++) {\\n\\t\\tfor(int j=0;j<seats[0].length;j++) {\\n\\t\\t\\tif((i==row && j<col) || seats[i][j] != \\'.\\') {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else if((i-1>=0 && j-1 >= 0 && seats[i-1][j-1] == \\'1\\') || (i-1>=0 && j+1 <= seats[0].length-1 && seats[i-1][j+1] == \\'1\\') || (j-1>=0 && seats[i][j-1] == \\'1\\')){\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tseats[i][j] = \\'1\\';\\n\\t\\t\\t\\tresult = Math.max(result, 1+recursion(seats, i, j, count));\\n\\t\\t\\t\\tseats[i][j] = \\'.\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tMEMO.put(key, result);\\n\\treturn result;\\n}\\n\\t\\nprivate String getKey(char[][] seats, int i, int j) {\\n\\tString key = \"\";\\n\\tif(i-1>=0) {\\n\\t\\t  key += Arrays.toString(seats[i-1]);\\t\\n\\t}\\n\\tkey+=\":\" + Arrays.toString(seats[i]);\\n\\tkey+=\":\"+i+\":\"+j;\\n\\treturn key;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 647128,
                "title": "c-simple-well-commented-and-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        \\n        vector<int>arr; // vector to store mask\\n        \\n        //calculating mask column-wise\\n        for(int i = 0; i < n; ++i){\\n            int num = 0;\\n            for(int j = 0; j < m; ++j){\\n                num += pow(2, j)*(seats[j][i] == \\'.\\');\\n            }\\n            arr.push_back(num);\\n        }\\n        \\n        //dp[i][j] = maximum number that can be placed till ith column if number of students in ith column is equal to number of set bits in j, provided it does not violate the rules.\\n        vector<vector<int>>dp(n, vector<int>(1<<m, -1));\\n        \\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < (1 << m); ++j){\\n                //student should only sit on not-broken seat.\\n               if((arr[i] | j) == arr[i]){\\n                   //for the first column\\n                   if(i == 0){\\n                        dp[i][j] =  __builtin_popcount(j);\\n                        continue;\\n                    }\\n                   \\n                   //for the rest column\\n                    for(int k = 0; k < (1 << m); ++k){\\n                        if(dp[i-1][k] != -1){\\n                            \\n                            //students should not be sharing adjacent seat or the adjacent corners.\\n                            if(!(j & k) && !((j<<1) & k) && !((j >> 1) & k)){\\n                                dp[i][j] = max(dp[i][j], dp[i-1][k] + __builtin_popcount(j));\\n                            }\\n                        }\\n                    }\\n               }\\n            }\\n        }\\n        \\n        return *max_element(dp[n-1].begin(), dp[n-1].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        \\n        vector<int>arr; // vector to store mask\\n        \\n        //calculating mask column-wise\\n        for(int i = 0; i < n; ++i){\\n            int num = 0;\\n            for(int j = 0; j < m; ++j){\\n                num += pow(2, j)*(seats[j][i] == \\'.\\');\\n            }\\n            arr.push_back(num);\\n        }\\n        \\n        //dp[i][j] = maximum number that can be placed till ith column if number of students in ith column is equal to number of set bits in j, provided it does not violate the rules.\\n        vector<vector<int>>dp(n, vector<int>(1<<m, -1));\\n        \\n        for(int i = 0; i < n; ++i){\\n            for(int j = 0; j < (1 << m); ++j){\\n                //student should only sit on not-broken seat.\\n               if((arr[i] | j) == arr[i]){\\n                   //for the first column\\n                   if(i == 0){\\n                        dp[i][j] =  __builtin_popcount(j);\\n                        continue;\\n                    }\\n                   \\n                   //for the rest column\\n                    for(int k = 0; k < (1 << m); ++k){\\n                        if(dp[i-1][k] != -1){\\n                            \\n                            //students should not be sharing adjacent seat or the adjacent corners.\\n                            if(!(j & k) && !((j<<1) & k) && !((j >> 1) & k)){\\n                                dp[i][j] = max(dp[i][j], dp[i-1][k] + __builtin_popcount(j));\\n                            }\\n                        }\\n                    }\\n               }\\n            }\\n        }\\n        \\n        return *max_element(dp[n-1].begin(), dp[n-1].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642564,
                "title": "python-simple-backtracking-solution-w-memoization-lots-of-comments",
                "content": "For each empty seat, we try both possibilities: either the seat is occupied or it isn\\'t. In order to save space, instead of creating a new array each time we recurse, we modify the existing array and then undo our modifications (i.e. backtracking). In order to save time, we memoize all of our (partial) solutions.\\n\\n**Time-complexity**: let *k* be the number of empty seats. Our algorithm reaches every possible state of the seating arrangement, thus we have *2^k*. In the worst-case, *k = mn* where *m* and *n* are the dimensions of the classroom.\\n\\n**Space-complexity**: constant -- we only modify the input array.\\n\\n\\n```\\nclass Solution:\\n    \\n    memo = {}\\n    \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \\n        strrep = \\'\\'.join([\\'\\'.join(row) for row in seats])\\n        \\n        if all(ch == \\'#\\' for ch in strrep):\\n            return 0\\n        if strrep in self.memo:\\n            return self.memo[strrep]\\n        \\n        # find first empty seat\\n        def __find_first(seats):\\n            # making function since you can\\'t break\\n            # out of python double for-loop\\n            for i,row in enumerate(seats):\\n                for j,seat in enumerate(row):\\n                    if seats[i][j] == \\'.\\':\\n                        i0, j0 = i, j\\n                        return (i0, j0)\\n                    \\n        i0, j0 = __find_first(seats)\\n        \\n        def __get_nearby(i0, j0):\\n            result = []\\n            \\'\\'\\'\\n            if seats looks like:\\n            . . .\\n            . . .\\n            . . .\\n            and we place someone in the center:\\n            . . .\\n            . X .\\n            . . .\\n            the following seats cannot be occupied:\\n            # . #\\n            # X #\\n            # . #\\n            \\'\\'\\'\\n            for dy, dx in [(0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\\n                ii, jj = i0 + dy, j0 + dx\\n                if 0 <= ii < len(seats) and 0 <= jj < len(seats[0]):\\n                    if seats[ii][jj] != \\'#\\':\\n                        result.append((ii, jj))\\n            return result\\n            \\n        # Case #1: don\\'t use chair\\n        seats[i0][j0] = \\'#\\'\\n        res1 = self.maxStudents(seats)\\n                    \\n        # Case #2: student sits here; we mark as \"broken\"\\n        nearby = __get_nearby(i0, j0)\\n        for i, j in nearby:\\n            seats[i][j] = \\'#\\'\\n        res2 = 1 + self.maxStudents(seats)\\n\\n        res = max(res1, res2)\\n        self.memo[strrep] = res\\n        \\n        # undo all changes before returning; i.e. \"backtracking\"\\n        seats[i0][j0] = \\'.\\'\\n        for i, j in nearby:\\n            seats[i][j] = \\'.\\'\\n\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    memo = {}\\n    \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \\n        strrep = \\'\\'.join([\\'\\'.join(row) for row in seats])\\n        \\n        if all(ch == \\'#\\' for ch in strrep):\\n            return 0\\n        if strrep in self.memo:\\n            return self.memo[strrep]\\n        \\n        # find first empty seat\\n        def __find_first(seats):\\n            # making function since you can\\'t break\\n            # out of python double for-loop\\n            for i,row in enumerate(seats):\\n                for j,seat in enumerate(row):\\n                    if seats[i][j] == \\'.\\':\\n                        i0, j0 = i, j\\n                        return (i0, j0)\\n                    \\n        i0, j0 = __find_first(seats)\\n        \\n        def __get_nearby(i0, j0):\\n            result = []\\n            \\'\\'\\'\\n            if seats looks like:\\n            . . .\\n            . . .\\n            . . .\\n            and we place someone in the center:\\n            . . .\\n            . X .\\n            . . .\\n            the following seats cannot be occupied:\\n            # . #\\n            # X #\\n            # . #\\n            \\'\\'\\'\\n            for dy, dx in [(0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\\n                ii, jj = i0 + dy, j0 + dx\\n                if 0 <= ii < len(seats) and 0 <= jj < len(seats[0]):\\n                    if seats[ii][jj] != \\'#\\':\\n                        result.append((ii, jj))\\n            return result\\n            \\n        # Case #1: don\\'t use chair\\n        seats[i0][j0] = \\'#\\'\\n        res1 = self.maxStudents(seats)\\n                    \\n        # Case #2: student sits here; we mark as \"broken\"\\n        nearby = __get_nearby(i0, j0)\\n        for i, j in nearby:\\n            seats[i][j] = \\'#\\'\\n        res2 = 1 + self.maxStudents(seats)\\n\\n        res = max(res1, res2)\\n        self.memo[strrep] = res\\n        \\n        # undo all changes before returning; i.e. \"backtracking\"\\n        seats[i0][j0] = \\'.\\'\\n        for i, j in nearby:\\n            seats[i][j] = \\'.\\'\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 537608,
                "title": "javascript-bitwise-dp-bfs-w-explanation",
                "content": "```javascript\\nvar maxStudents = function(seats) {\\n    if (!seats.length) return 0;\\n    \\n\\t// precalculate the seat that will be off the matrix\\n    const lastPos = 1 << seats[0].length;\\n\\t// encode the classroom into binary where 1 will be an available seat and 0 will be a broken seat\\n    const classroom = seats.map((row) => (\\n        row.reduce((a,c,i) => c === \\'#\\' ? a : (a | (1 << i)), 0))\\n    );\\n\\t\\n\\t// create a store to store the max seating for each row arrangment\\n\\t// each row will be off +1 of seats rows\\n    const dp = new Array(seats.length + 1).fill(null).map(() => new Map());\\n\\t// since no one can sit at row=-1 set the max number of no one sitting on that row as 0\\n    dp[0].set(0,0);    \\n\\t\\n\\t// iterate through every row in seats matrix\\n\\t// remember that dp\\'s rows are +1 of seats rows\\n    for (let row = 0; row < seats.length; row++) {\\n\\t\\n\\t    // start with no one sitting on the row\\n        let queue = [0];\\n\\t\\t// this will count the number of students sitting on this row\\n\\t\\t// we will increment this up as we add students to the row\\n        let numStudents = 0;\\n\\t\\t\\n        while (queue.length > 0) {\\n            \\n\\t\\t\\t// this will store all the different arrangments possible when we add 1 more student from the previous\\n            const next = [];\\n\\t\\t\\t\\n\\t\\t\\t// iterate through all the previous arrangements\\n\\t\\t\\t// calculate the maximum number of students that can sit on current and all previous rows\\n\\t\\t\\t// try adding a student to all possible available seats meeting the rules of the game\\n            for (let arrangement of queue) {\\n\\t\\t\\t\\n \\t\\t\\t    // this calculates the maximum number of students that can sit with this row arrangment\\n\\t\\t\\t\\t// if the arrangement doesn\\'t allow any students to sit in the previous row this will be handled\\n\\t\\t\\t\\t// by the 0 case in the previous row\\n\\t\\t\\t\\t// *see helper function that checks to see if the arrangement conflicts with the previous arrangment\\n                let max = 0;\\n                for (let [prevArrang, count] of dp[row]) {\\n                    if (conflicts(prevArrang, arrangement)) continue;  \\n                    max = Math.max(max, count + numStudents);\\n                }\\n                dp[row + 1].set(arrangement, max);\\n                \\n\\t\\t\\t\\t// try adding an additional student to all elements in the row checking if it conflicts\\n\\t\\t\\t\\t// arrangement | i  => adds the student to the arrangement\\n                for (let i = 1; i < lastPos; i <<= 1) {\\n                    if (canSit(classroom[row], arrangement, i)) next.push(arrangement | i);\\n                }\\n            }            \\n            \\n            queue = next;\\n            numStudents++;\\n        }\\n    }\\n    \\n\\t// return the maximum value from the last row\\n\\t// the last row holds the maximum number of students for each arrangment\\n    return Math.max(...dp[seats.length].values());\\n};\\n\\n// this checks if the there are any students to the left or right of current arrangment\\n// curr << 1 => checks if there are any students to the left\\n// curr >> 1 => check if there are any students to the right\\nfunction conflicts(prev, curr) {\\n    return (prev & (curr << 1)) || (prev & (curr >> 1));\\n}\\n\\n// this checks if we can place the new student in this spot\\n// row & newStudent => checks if the classroom\\'s row\\'s seat is not broken\\n// arrangment & newStudent => will return truthy if there is a student sitting in that position (so we ! it because we don\\'t want anyone sitting there)\\n// arrangement & (newStudent << 1) => will return truthy if there is a student sitting to the left of that position (so we ! it because we don\\'t want anyone sitting there)\\n// arrangement & (newStudent >> 1) => will return truthy if there is a student sitting to the right of that position (so we ! it because we don\\'t want anyone sitting there)\\nfunction canSit(row, arrangement, newStudent) {\\n    return row & newStudent && !(arrangement & newStudent) && !(arrangement & (newStudent << 1)) && !(arrangement & (newStudent >> 1));\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```javascript\\nvar maxStudents = function(seats) {\\n    if (!seats.length) return 0;\\n    \\n\\t// precalculate the seat that will be off the matrix\\n    const lastPos = 1 << seats[0].length;\\n\\t// encode the classroom into binary where 1 will be an available seat and 0 will be a broken seat\\n    const classroom = seats.map((row) => (\\n        row.reduce((a,c,i) => c === \\'#\\' ? a : (a | (1 << i)), 0))\\n    );\\n\\t\\n\\t// create a store to store the max seating for each row arrangment\\n\\t// each row will be off +1 of seats rows\\n    const dp = new Array(seats.length + 1).fill(null).map(() => new Map());\\n\\t// since no one can sit at row=-1 set the max number of no one sitting on that row as 0\\n    dp[0].set(0,0);    \\n\\t\\n\\t// iterate through every row in seats matrix\\n\\t// remember that dp\\'s rows are +1 of seats rows\\n    for (let row = 0; row < seats.length; row++) {\\n\\t\\n\\t    // start with no one sitting on the row\\n        let queue = [0];\\n\\t\\t// this will count the number of students sitting on this row\\n\\t\\t// we will increment this up as we add students to the row\\n        let numStudents = 0;\\n\\t\\t\\n        while (queue.length > 0) {\\n            \\n\\t\\t\\t// this will store all the different arrangments possible when we add 1 more student from the previous\\n            const next = [];\\n\\t\\t\\t\\n\\t\\t\\t// iterate through all the previous arrangements\\n\\t\\t\\t// calculate the maximum number of students that can sit on current and all previous rows\\n\\t\\t\\t// try adding a student to all possible available seats meeting the rules of the game\\n            for (let arrangement of queue) {\\n\\t\\t\\t\\n \\t\\t\\t    // this calculates the maximum number of students that can sit with this row arrangment\\n\\t\\t\\t\\t// if the arrangement doesn\\'t allow any students to sit in the previous row this will be handled\\n\\t\\t\\t\\t// by the 0 case in the previous row\\n\\t\\t\\t\\t// *see helper function that checks to see if the arrangement conflicts with the previous arrangment\\n                let max = 0;\\n                for (let [prevArrang, count] of dp[row]) {\\n                    if (conflicts(prevArrang, arrangement)) continue;  \\n                    max = Math.max(max, count + numStudents);\\n                }\\n                dp[row + 1].set(arrangement, max);\\n                \\n\\t\\t\\t\\t// try adding an additional student to all elements in the row checking if it conflicts\\n\\t\\t\\t\\t// arrangement | i  => adds the student to the arrangement\\n                for (let i = 1; i < lastPos; i <<= 1) {\\n                    if (canSit(classroom[row], arrangement, i)) next.push(arrangement | i);\\n                }\\n            }            \\n            \\n            queue = next;\\n            numStudents++;\\n        }\\n    }\\n    \\n\\t// return the maximum value from the last row\\n\\t// the last row holds the maximum number of students for each arrangment\\n    return Math.max(...dp[seats.length].values());\\n};\\n\\n// this checks if the there are any students to the left or right of current arrangment\\n// curr << 1 => checks if there are any students to the left\\n// curr >> 1 => check if there are any students to the right\\nfunction conflicts(prev, curr) {\\n    return (prev & (curr << 1)) || (prev & (curr >> 1));\\n}\\n\\n// this checks if we can place the new student in this spot\\n// row & newStudent => checks if the classroom\\'s row\\'s seat is not broken\\n// arrangment & newStudent => will return truthy if there is a student sitting in that position (so we ! it because we don\\'t want anyone sitting there)\\n// arrangement & (newStudent << 1) => will return truthy if there is a student sitting to the left of that position (so we ! it because we don\\'t want anyone sitting there)\\n// arrangement & (newStudent >> 1) => will return truthy if there is a student sitting to the right of that position (so we ! it because we don\\'t want anyone sitting there)\\nfunction canSit(row, arrangement, newStudent) {\\n    return row & newStudent && !(arrangement & newStudent) && !(arrangement & (newStudent << 1)) && !(arrangement & (newStudent >> 1));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 509699,
                "title": "python-memo-broken-seats-real-broken-seats-destroyed-seats-based-on-prev",
                "content": "```python\\nclass Solution(object):\\n    def maxStudents(self, seats:list):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        self.rlen, self.clen = len(seats), len(seats[0])\\n        self.memo = [[-1] * (1 << (self.clen + 1)) for i in range(self.rlen + 1)]\\n        brokens = [0] * self.rlen\\n        for i in range(len(seats)):\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'#\\':\\n                    brokens[i] = brokens[i] | (1 << (self.clen - (j + 1)))\\n        return self.dp(0,0,brokens)\\n\\n    def dp(self, row: int, previous: int, brokens: list):\\n        if row == self.rlen:\\n            return 0\\n        if self.memo[row][previous] != -1:\\n            print(\\'a\\')\\n            return self.memo[row][previous]\\n        else:\\n            res = -1\\n            blocks = brokens[row] # 1 representing walls, \\n            possible = set()\\n            virtual_wall = self.make_wall(previous)\\n            for i in range(1 << self.clen):\\n                possible.add(i & (~blocks) & (~virtual_wall))\\n            valid_plan = [(0, 0)]\\n\\n            for plan in possible:\\n                num = plan\\n                must_empty = False\\n                valid = True\\n                count = 0 \\n                # check if there is consecutive bit in the potential plan\\n                while num:\\n                    if num & 1 == 1:\\n                        count += 1\\n                        if must_empty:\\n                            valid = False\\n                            break\\n                        else:\\n                            must_empty = True\\n                    else:\\n                        must_empty = False\\n                    num = num >> 1\\n                if valid: valid_plan.append((plan, count))\\n            for bitmask, cnt in valid_plan:\\n                res = max(res, self.dp(row + 1, bitmask, brokens) + cnt)\\n            self.memo[row][previous] = res\\n            return res\\n \\n    def make_wall(self, prev):\\n        count = 0\\n        wall = 0\\n        while prev:\\n            if prev & 1 == 1:\\n                if count - 1 >= 0:\\n                    wall |= (1 << (count -1))\\n                if count + 1 < self.clen:\\n                    wall |= (1 << (count +1))\\n            prev = prev >> 1\\n            count += 1\\n        return wall\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def maxStudents(self, seats:list):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        self.rlen, self.clen = len(seats), len(seats[0])\\n        self.memo = [[-1] * (1 << (self.clen + 1)) for i in range(self.rlen + 1)]\\n        brokens = [0] * self.rlen\\n        for i in range(len(seats)):\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'#\\':\\n                    brokens[i] = brokens[i] | (1 << (self.clen - (j + 1)))\\n        return self.dp(0,0,brokens)\\n\\n    def dp(self, row: int, previous: int, brokens: list):\\n        if row == self.rlen:\\n            return 0\\n        if self.memo[row][previous] != -1:\\n            print(\\'a\\')\\n            return self.memo[row][previous]\\n        else:\\n            res = -1\\n            blocks = brokens[row] # 1 representing walls, \\n            possible = set()\\n            virtual_wall = self.make_wall(previous)\\n            for i in range(1 << self.clen):\\n                possible.add(i & (~blocks) & (~virtual_wall))\\n            valid_plan = [(0, 0)]\\n\\n            for plan in possible:\\n                num = plan\\n                must_empty = False\\n                valid = True\\n                count = 0 \\n                # check if there is consecutive bit in the potential plan\\n                while num:\\n                    if num & 1 == 1:\\n                        count += 1\\n                        if must_empty:\\n                            valid = False\\n                            break\\n                        else:\\n                            must_empty = True\\n                    else:\\n                        must_empty = False\\n                    num = num >> 1\\n                if valid: valid_plan.append((plan, count))\\n            for bitmask, cnt in valid_plan:\\n                res = max(res, self.dp(row + 1, bitmask, brokens) + cnt)\\n            self.memo[row][previous] = res\\n            return res\\n \\n    def make_wall(self, prev):\\n        count = 0\\n        wall = 0\\n        while prev:\\n            if prev & 1 == 1:\\n                if count - 1 >= 0:\\n                    wall |= (1 << (count -1))\\n                if count + 1 < self.clen:\\n                    wall |= (1 << (count +1))\\n            prev = prev >> 1\\n            count += 1\\n        return wall\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507980,
                "title": "python-bottom-up-dp-bitmask-clean-code",
                "content": "The idea is from https://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\n\\nBelow is my implementation with 1D DP.\\n\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \\n        def get_masks(seats):\\n            res = []\\n            for row in seats:\\n                cur = 0\\n                for c in row:\\n                    cur *= 2\\n                    if c == \\'.\\':\\n                        cur += 1\\n                res.append(cur)\\n            return res\\n                \\n        def count(num):\\n            res = 0\\n            while num > 0:\\n                res += (num%2)\\n                num //= 2\\n            return res\\n        \\n        masks = get_masks(seats)\\n        m, n = len(seats), len(seats[0])\\n        dp = {0:0}\\n        for i in range(m):\\n            dp2 = collections.Counter({0:max(dp.values())})\\n            for pre, cnt in dp.items():\\n                mask = masks[i]\\n                sub = mask\\n                while sub > 0:\\n                    if sub&(sub>>1) == 0 and sub&(pre>>1) == 0 and (sub>>1)&pre == 0:\\n                        dp2[sub] = max(dp2[sub], cnt + count(sub))\\n                    sub = (sub-1)&mask\\n            dp = dp2\\n        return max(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        \\n        def get_masks(seats):\\n            res = []\\n            for row in seats:\\n                cur = 0\\n                for c in row:\\n                    cur *= 2\\n                    if c == \\'.\\':\\n                        cur += 1\\n                res.append(cur)\\n            return res\\n                \\n        def count(num):\\n            res = 0\\n            while num > 0:\\n                res += (num%2)\\n                num //= 2\\n            return res\\n        \\n        masks = get_masks(seats)\\n        m, n = len(seats), len(seats[0])\\n        dp = {0:0}\\n        for i in range(m):\\n            dp2 = collections.Counter({0:max(dp.values())})\\n            for pre, cnt in dp.items():\\n                mask = masks[i]\\n                sub = mask\\n                while sub > 0:\\n                    if sub&(sub>>1) == 0 and sub&(pre>>1) == 0 and (sub>>1)&pre == 0:\\n                        dp2[sub] = max(dp2[sub], cnt + count(sub))\\n                    sub = (sub-1)&mask\\n            dp = dp2\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505194,
                "title": "python-dp",
                "content": "didnt see this in the (virtual) contest, pretty tough to see in my opinion\\n \\n**subproblem definition**\\n```\\ndp[i][v] = max number of seats placed in matrix[:i+1] while having the ith row being v\\n```\\nfor example \\n```\\ndp[i][(1,0,0,1,0,1)] = max number of seats placed in matrix[:i+1] while having the ith row being (1,0,0,1,0,1)\\n```\\nwe then actually need the last two rows exclusively, and compare all possiblities\\n\\ndefinitely practical to work with mask to check for seats not allowed, but tough to see where it goes wrong if so, so went ahead with tuples\\n\\n**recurrence** \\ndp[i] is a hashmap where the key is the tuple and the value is the max cumulated number of seats up to ith line included in the matrix\\n\\nbottom up dp pseudo code\\n```\\nfor u in dp[i]:\\n\\tif u and v are compatible:\\n\\t\\tdp[i][v] = max(dp[i][v], dp[i-1][u] + number of 1s in v)\\n```\\n\\n\\n**final answer**\\n```\\nmax(dp[-1].values())\\n```\\n\\nshoutout to the ones that solved it in contest\\ndefinitely will try to remember to break down these matrixes problems correctly as the reach of one student was one row above only \\n\\n**runtime**\\n\\nm = number of columns\\nn = number of lines\\n\\nnumber of subproblems O(n (2 ** m))\\ntime per subproblems O(2 ** m)\\n\\nO(n 2 ** (2m)) \\npractical number of m is at most 8,  2 to the 16 is 2 ** 10 x 2 ** 6 = 60K \\nif n is at most 8 its 8 x 60 K = 480 K at most\\n\\n```\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        n = len(seats[0])\\n        prev = collections.defaultdict(int)\\n        prev[(0,) * n]= 0\\n        for l in seats:\\n            dp = collections.defaultdict(int)\\n            dp[(0,) * n] = max(prev.values())\\n            for v in self.possibilities(l):\\n                for u in prev:\\n                    if self.f(u,v): \\n                        dp[v] = max(dp[v], sum(v) + prev[u])\\n            prev = dp\\n        return max(prev.values())\\n    \\n    def possibilities(self,l):\\n        res= []\\n        self.dfs(0,[],[ii for ii in range(len(l)) if l[ii] == \\'.\\'],res)\\n        return [self.g(e, len(l)) for e in res]\\n    \\n    def g(self, e,n):\\n        return tuple([(1 if i in e else 0) for i in range(n)])\\n\\t\\t\\n    def dfs(self,i,path,idxes, res):\\n        if i == len(idxes):\\n            res.append(path[::])\\n            return\\n        if len(path) == 0 or (idxes[i] - path[-1]) > 1: \\n            path.append(idxes[i])\\n            self.dfs(i+1, path, idxes, res)\\n            path.pop()\\n        self.dfs(i+1, path, idxes, res)\\n    \\n    def f(self,u,v):\\n        idxes = set([ii for ii in range(len(u)) if u[ii]])\\n        for jj in range(len(v)):\\n            if v[jj]:\\n                if jj-1 in idxes: return False\\n                if jj+1 in idxes: return False\\n        return True\\n```\\n\\n\\nin the contest, I put all seats in a new list \\nthen either picked the seat, either skip it\\n```2 ** (m*n) = 2 ** 60 with memoization```\\nTLE :( \\n50/55 testcases were ok\\n\\n\\n```\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        seats = [(i,j) for i in range(len(seats)) for j in range(len(seats[0])) if seats[i][j] == \\'.\\']\\n        seats.sort()\\n        mem = {}\\n        return self.dfs(0, seats, set([]),0, mem)\\n    \\n    def dfs(self,i,seats,taken, mask, mem):\\n        if i == len(seats) : return 0\\n        if (i,mask) in mem:\\n            return mem[(i,mask)]\\n        m = self.dfs(i+1, seats, taken, mask, mem)\\n        if self.f(seats[i],taken):\\n            m = max(m, 1+ self.dfs(i+1,seats, taken | set([seats[i]]), mask + (1<<i), mem))\\n        mem[(i,mask)] = m\\n        return m\\n    \\n    def f(self, X, taken):\\n        ii,jj = X\\n    \\n        return all([not(u in taken) for u in [(ii,jj-1),(ii,jj+1),(ii-1,jj+1),(ii-1,jj-1)]])\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndp[i][v] = max number of seats placed in matrix[:i+1] while having the ith row being v\\n```\n```\\ndp[i][(1,0,0,1,0,1)] = max number of seats placed in matrix[:i+1] while having the ith row being (1,0,0,1,0,1)\\n```\n```\\nfor u in dp[i]:\\n\\tif u and v are compatible:\\n\\t\\tdp[i][v] = max(dp[i][v], dp[i-1][u] + number of 1s in v)\\n```\n```\\nmax(dp[-1].values())\\n```\n```\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        n = len(seats[0])\\n        prev = collections.defaultdict(int)\\n        prev[(0,) * n]= 0\\n        for l in seats:\\n            dp = collections.defaultdict(int)\\n            dp[(0,) * n] = max(prev.values())\\n            for v in self.possibilities(l):\\n                for u in prev:\\n                    if self.f(u,v): \\n                        dp[v] = max(dp[v], sum(v) + prev[u])\\n            prev = dp\\n        return max(prev.values())\\n    \\n    def possibilities(self,l):\\n        res= []\\n        self.dfs(0,[],[ii for ii in range(len(l)) if l[ii] == \\'.\\'],res)\\n        return [self.g(e, len(l)) for e in res]\\n    \\n    def g(self, e,n):\\n        return tuple([(1 if i in e else 0) for i in range(n)])\\n\\t\\t\\n    def dfs(self,i,path,idxes, res):\\n        if i == len(idxes):\\n            res.append(path[::])\\n            return\\n        if len(path) == 0 or (idxes[i] - path[-1]) > 1: \\n            path.append(idxes[i])\\n            self.dfs(i+1, path, idxes, res)\\n            path.pop()\\n        self.dfs(i+1, path, idxes, res)\\n    \\n    def f(self,u,v):\\n        idxes = set([ii for ii in range(len(u)) if u[ii]])\\n        for jj in range(len(v)):\\n            if v[jj]:\\n                if jj-1 in idxes: return False\\n                if jj+1 in idxes: return False\\n        return True\\n```\n```2 ** (m*n) = 2 ** 60 with memoization```\n```\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        seats = [(i,j) for i in range(len(seats)) for j in range(len(seats[0])) if seats[i][j] == \\'.\\']\\n        seats.sort()\\n        mem = {}\\n        return self.dfs(0, seats, set([]),0, mem)\\n    \\n    def dfs(self,i,seats,taken, mask, mem):\\n        if i == len(seats) : return 0\\n        if (i,mask) in mem:\\n            return mem[(i,mask)]\\n        m = self.dfs(i+1, seats, taken, mask, mem)\\n        if self.f(seats[i],taken):\\n            m = max(m, 1+ self.dfs(i+1,seats, taken | set([seats[i]]), mask + (1<<i), mem))\\n        mem[(i,mask)] = m\\n        return m\\n    \\n    def f(self, X, taken):\\n        ii,jj = X\\n    \\n        return all([not(u in taken) for u in [(ii,jj-1),(ii,jj+1),(ii-1,jj+1),(ii-1,jj-1)]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504500,
                "title": "top-down-dynamic-programming-solution-in-python",
                "content": "For any position, if I occupy, the positions on the left, right, rear left and rear right will be not available. \\n```Python\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        cache={}\\n        positions=[]\\n        height = len(seats)\\n        width = len(seats[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if(seats[i][j]==\\'.\\'):\\n                    positions.append((i,j))\\n        return self.dfs(positions,cache)\\n\\n    def dfs(self,positions,cache):\\n        if(len(positions)==0):\\n            return 0\\n        if(tuple(positions) in cache):\\n            return cache[tuple(positions)]\\n        positions0 = [a for a in positions[1:]]\\n        positions1 = [a for a in positions[1:]]\\n        # if I do not use positions[0]\\n        res0 = self.dfs(positions0,cache)\\n        # if I use positions[0], then the positions on the left, right, rear left and rear right will be not available\\n        curr = positions[0]\\n        for i,j in [(curr[0],curr[1]+1),(curr[0],curr[1]-1),(curr[0]+1,curr[1]-1),(curr[0]+1,curr[1]+1)]:\\n            if((i,j) in positions1):\\n                positions1.remove((i,j))\\n        res1 = self.dfs(positions1,cache)\\n        cache[tuple(positions)] = max(res0,res1+1)\\n        return cache[tuple(positions)]\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def maxStudents(self, seats):\\n        \"\"\"\\n        :type seats: List[List[str]]\\n        :rtype: int\\n        \"\"\"\\n        cache={}\\n        positions=[]\\n        height = len(seats)\\n        width = len(seats[0])\\n        for i in range(height):\\n            for j in range(width):\\n                if(seats[i][j]==\\'.\\'):\\n                    positions.append((i,j))\\n        return self.dfs(positions,cache)\\n\\n    def dfs(self,positions,cache):\\n        if(len(positions)==0):\\n            return 0\\n        if(tuple(positions) in cache):\\n            return cache[tuple(positions)]\\n        positions0 = [a for a in positions[1:]]\\n        positions1 = [a for a in positions[1:]]\\n        # if I do not use positions[0]\\n        res0 = self.dfs(positions0,cache)\\n        # if I use positions[0], then the positions on the left, right, rear left and rear right will be not available\\n        curr = positions[0]\\n        for i,j in [(curr[0],curr[1]+1),(curr[0],curr[1]-1),(curr[0]+1,curr[1]-1),(curr[0]+1,curr[1]+1)]:\\n            if((i,j) in positions1):\\n                positions1.remove((i,j))\\n        res1 = self.dfs(positions1,cache)\\n        cache[tuple(positions)] = max(res0,res1+1)\\n        return cache[tuple(positions)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504121,
                "title": "clean-c-code-memoization-dp-solution",
                "content": "1. method 1 - memoization, O(m * 4^n)\\n```\\nclass Solution {\\npublic:\\n    int rec(const vector<int>& broken, vector<vector<int>>& dp, int m, int n, int prevMask, int row) {\\n        if (row >= m)\\n            return 0;\\n\\n        if (dp[row][prevMask] >= 0)\\n            return dp[row][prevMask];\\n\\n        int res = 0;\\n        for (int currMask = 0; currMask < (1 << n); currMask++) {\\n            if ((currMask & broken[row]) || (currMask & (currMask << 1)))\\n                continue;\\n            if ((prevMask & (currMask << 1)) || (prevMask & (currMask >> 1)))\\n                continue;\\n\\n            int bitCnt = 0;\\n            for (int t = currMask; t; t &= t - 1)\\n                bitCnt++;\\n\\n            res = max(res, rec(broken, dp, m, n, currMask, row + 1) + bitCnt);\\n        }\\n\\n        return dp[row][prevMask] = res;\\n    }\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = int(seats.size());\\n        int n = int(seats[0].size());\\n\\n        vector<int> broken(m);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\')\\n                    broken[i] |= 1 << j;\\n            }\\n        }\\n\\n        // dp[row][mask]\\n        vector<vector<int>> dp(m, vector<int>(1 << n, -1));\\n        return rec(broken, dp, m, n, 0, 0);\\n    }\\n};\\n```\\n\\n2. method 2 - dynamic programming, O(m * 4^n)\\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = int(seats.size());\\n        int n = int(seats[0].size());\\n\\n        vector<int> broken(m);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\')\\n                    broken[i] |= 1 << j;\\n            }\\n        }\\n\\n        // dp[row][mask]\\n        vector<vector<int>> dp(m + 1, vector<int>(1 << n, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int currMask = 0; currMask < (1 << n); currMask++) {\\n                if ((currMask & broken[i - 1]) || (currMask & (currMask << 1)))\\n                    continue;\\n\\n                int bitCnt = 0;\\n                for (int t = currMask; t; t &= t - 1)\\n                    bitCnt++;\\n\\n                for (int prevMask = 0; prevMask < (1 << n); prevMask++) {\\n                    if ((prevMask & (currMask << 1)) || (prevMask & (currMask >> 1)))\\n                        continue;\\n                    dp[i][currMask] = max(dp[i][currMask], dp[i - 1][prevMask] + bitCnt);\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(const vector<int>& broken, vector<vector<int>>& dp, int m, int n, int prevMask, int row) {\\n        if (row >= m)\\n            return 0;\\n\\n        if (dp[row][prevMask] >= 0)\\n            return dp[row][prevMask];\\n\\n        int res = 0;\\n        for (int currMask = 0; currMask < (1 << n); currMask++) {\\n            if ((currMask & broken[row]) || (currMask & (currMask << 1)))\\n                continue;\\n            if ((prevMask & (currMask << 1)) || (prevMask & (currMask >> 1)))\\n                continue;\\n\\n            int bitCnt = 0;\\n            for (int t = currMask; t; t &= t - 1)\\n                bitCnt++;\\n\\n            res = max(res, rec(broken, dp, m, n, currMask, row + 1) + bitCnt);\\n        }\\n\\n        return dp[row][prevMask] = res;\\n    }\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = int(seats.size());\\n        int n = int(seats[0].size());\\n\\n        vector<int> broken(m);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\')\\n                    broken[i] |= 1 << j;\\n            }\\n        }\\n\\n        // dp[row][mask]\\n        vector<vector<int>> dp(m, vector<int>(1 << n, -1));\\n        return rec(broken, dp, m, n, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = int(seats.size());\\n        int n = int(seats[0].size());\\n\\n        vector<int> broken(m);\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\')\\n                    broken[i] |= 1 << j;\\n            }\\n        }\\n\\n        // dp[row][mask]\\n        vector<vector<int>> dp(m + 1, vector<int>(1 << n, 0));\\n        for (int i = 1; i <= m; i++) {\\n            for (int currMask = 0; currMask < (1 << n); currMask++) {\\n                if ((currMask & broken[i - 1]) || (currMask & (currMask << 1)))\\n                    continue;\\n\\n                int bitCnt = 0;\\n                for (int t = currMask; t; t &= t - 1)\\n                    bitCnt++;\\n\\n                for (int prevMask = 0; prevMask < (1 << n); prevMask++) {\\n                    if ((prevMask & (currMask << 1)) || (prevMask & (currMask >> 1)))\\n                        continue;\\n                    dp[i][currMask] = max(dp[i][currMask], dp[i - 1][prevMask] + bitCnt);\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504091,
                "title": "python-memoizing-cur-and-prev-rows",
                "content": "```python\\ndef maxStudents(self, a: List[List[str]]) -> int:\\n        @lru_cache(maxsize=None)\\n        def backtrack(state, i, j):\\n            if i == -1:\\n                return 0\\n            (nexti, nextj) = (i, j+1) if j+1 < n else (i+1, 0) if i+1 < m else (-1, -1)\\n            \\n            s = [char for char in state] \\n            s1, s2 = s[0:n], s[n:]\\n            if j == 0 and i > 0:\\n                s1 = s2\\n                s2 = copy(a[i])\\n                state = \\'\\'.join(s1) + \\'\\'.join(s2)\\n            if a[i][j] == \\'#\\':\\n                res = backtrack(state, nexti, nextj)\\n                return res\\n          \\n            res = []\\n            if i == 0:\\n                if j == 0 or s1[j-1] != \\'X\\':\\n                    s1[j] = \\'X\\'\\n                    res.append(1 + backtrack(\\'\\'.join(s1) + \\'\\'.join(s1), nexti, nextj))\\n            else:\\n                if (j == 0 or  s2[j-1] != \\'X\\') and (j == 0 or  s1[j-1] != \\'X\\') and (j == n-1 or s1[j+1] != \\'X\\'):\\n                    s2[j] = \\'X\\'\\n                    res.append(1 + backtrack(\\'\\'.join(s1) + \\'\\'.join(s2), nexti, nextj))\\n            \\n            res.append(backtrack(state, nexti, nextj))\\n            \\n            res =  0 if not res else max(res) \\n            return res\\n        m,n = len(a), len(a[0])\\n        res = backtrack(\\'\\'.join(a[0]) + \\'\\'.join(a[0]), 0, 0)\\n \\xA0 \\xA0 \\xA0 \\xA0return res\\n",
                "solutionTags": [],
                "code": "```python\\ndef maxStudents(self, a: List[List[str]]) -> int:\\n        @lru_cache(maxsize=None)\\n        def backtrack(state, i, j):\\n            if i == -1:\\n                return 0\\n            (nexti, nextj) = (i, j+1) if j+1 < n else (i+1, 0) if i+1 < m else (-1, -1)\\n            \\n            s = [char for char in state] \\n            s1, s2 = s[0:n], s[n:]\\n            if j == 0 and i > 0:\\n                s1 = s2\\n                s2 = copy(a[i])\\n                state = \\'\\'.join(s1) + \\'\\'.join(s2)\\n            if a[i][j] == \\'#\\':\\n                res = backtrack(state, nexti, nextj)\\n                return res\\n          \\n            res = []\\n            if i == 0:\\n                if j == 0 or s1[j-1] != \\'X\\':\\n                    s1[j] = \\'X\\'\\n                    res.append(1 + backtrack(\\'\\'.join(s1) + \\'\\'.join(s1), nexti, nextj))\\n            else:\\n                if (j == 0 or  s2[j-1] != \\'X\\') and (j == 0 or  s1[j-1] != \\'X\\') and (j == n-1 or s1[j+1] != \\'X\\'):\\n                    s2[j] = \\'X\\'\\n                    res.append(1 + backtrack(\\'\\'.join(s1) + \\'\\'.join(s2), nexti, nextj))\\n            \\n            res.append(backtrack(state, nexti, nextj))\\n            \\n            res =  0 if not res else max(res) \\n            return res\\n        m,n = len(a), len(a[0])\\n        res = backtrack(\\'\\'.join(a[0]) + \\'\\'.join(a[0]), 0, 0)\\n \\xA0 \\xA0 \\xA0 \\xA0return res\\n",
                "codeTag": "Python3"
            },
            {
                "id": 503592,
                "title": "python-bitmask-dp-solution",
                "content": "**Idea:Scan from column to column.**\\nFor every possible state```cur```(encoded in bitmask) of current column , loop through all state of previous column ```prev```. \\nFor every valid pair of ```cur, prev```, update the result:\\n```dp[j][cur] = max(dp[j][cur], dp[j-1][prev] + nbits)``` where j is the column number and nbits is the ```set bits``` in ```cur```.\\n\\n**Bitmask encoding of column state**:\\nTake a column of \\'.xx.xx\\' for example.\\nAll possible state of the column:\\n000000(0)---take no seat from current column\\n100000(1)---take the first seat from current column\\n000100(8)---take the fourth seat from current column\\n100100(9)---take first and fourth seats from current column\\n\\n**Validation of cur and prev state pair***:\\nState being encoded in bitmask, the validation of ```cur and prev``` became straight forward:\\n``` prev & cur == 0 and (prev >> 1) & cur == 0 and (prev << 1) & cur == 0```\\n\\n```python\\ndef maxStudents(self, A: List[List[str]]) -> int:\\n        ROW, COL = len(A), len(A[0])\\n        dp = [{} for _ in range(COL+1)]\\n        \\n        def count_bits(c):\\n            res = 0\\n            while c:\\n                res += c&1\\n                c >>= 1\\n            return res\\n        \\n        for j in range(COL):\\n            comb = [0]\\n            for i in range(ROW):\\n                if A[i][j] == \\'.\\':\\n                    comb += [c | 1 << i for c in comb]\\n            for c in comb:\\n                nbits = count_bits(c)\\n                for prev in range(1<<ROW):\\n                    if prev & c == 0 and (prev >> 1) & c == 0 and (prev << 1) & c == 0:\\n                        dp[j+1][c] = max(dp[j+1].get(c, 0), nbits + dp[j].get(prev, 0))\\n        return max(dp[-1].values())\\n```",
                "solutionTags": [],
                "code": "```cur```\n```prev```\n```cur, prev```\n```dp[j][cur] = max(dp[j][cur], dp[j-1][prev] + nbits)```\n```set bits```\n```cur```\n```cur and prev```\n``` prev & cur == 0 and (prev >> 1) & cur == 0 and (prev << 1) & cur == 0```\n```python\\ndef maxStudents(self, A: List[List[str]]) -> int:\\n        ROW, COL = len(A), len(A[0])\\n        dp = [{} for _ in range(COL+1)]\\n        \\n        def count_bits(c):\\n            res = 0\\n            while c:\\n                res += c&1\\n                c >>= 1\\n            return res\\n        \\n        for j in range(COL):\\n            comb = [0]\\n            for i in range(ROW):\\n                if A[i][j] == \\'.\\':\\n                    comb += [c | 1 << i for c in comb]\\n            for c in comb:\\n                nbits = count_bits(c)\\n                for prev in range(1<<ROW):\\n                    if prev & c == 0 and (prev >> 1) & c == 0 and (prev << 1) & c == 0:\\n                        dp[j+1][c] = max(dp[j+1].get(c, 0), nbits + dp[j].get(prev, 0))\\n        return max(dp[-1].values())\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 503568,
                "title": "accepted-java-dp-solution",
                "content": "Intuition:  current selection of putting student on i,j or not only depends on the last column, so the status is no bigger than 2^8\\nDP Status: we are at i,j. last column status (which rows are taken) stored in last, current column status stored in cur\\n\\n```\\nclass Solution {\\n    int[][][][] dp;\\n    public int maxStudents(char[][] s) {\\n        int m = s.length;\\n        int n = s[0].length;\\n        dp = new int[m][n][1<<m][1<<m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < dp[i][j].length; k++) {\\n                    Arrays.fill(dp[i][j][k], -1);\\n                }\\n            }\\n        }\\n        return domax(0, 0, 0, 0, s);\\n    }\\n\\n    int domax(int i, int j, int last, int cur, char[][] s) {\\n\\n        int m = s.length;\\n        int n = s[0].length;\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n        if (dp[i][j][last][cur] != -1) {\\n            return dp[i][j][last][cur];\\n        }\\n        int nop = i + 1 < m ? domax(i + 1, j, last, cur, s) : domax(0, j + 1, cur, 0, s);\\n        if (s[i][j] == \\'#\\' ){\\n            dp[i][j][last][cur] = nop;\\n            return nop;\\n        }\\n        if(bad(last, i)) {\\n            dp[i][j][last][cur] = nop;\\n            return nop;\\n        }\\n        int ns = cur | (1 << i);\\n        int p = i + 1 < m ? 1 + domax(i + 1, j, last, ns, s) : 1 + domax(0, j + 1, ns, 0, s);\\n        int rt = Math.max(p, nop);\\n        dp[i][j][last][cur] = rt;\\n        return rt;\\n    }\\n\\n    private boolean bad(int last, int i) {\\n        if (((last >> i) & 1) == 1) {\\n            return true;\\n        }\\n        if (((last >> (i - 1)) & 1) == 1) {\\n            return true;\\n        }\\n        if (((last >> (i + 1)) & 1) == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][][][] dp;\\n    public int maxStudents(char[][] s) {\\n        int m = s.length;\\n        int n = s[0].length;\\n        dp = new int[m][n][1<<m][1<<m];\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                for (int k = 0; k < dp[i][j].length; k++) {\\n                    Arrays.fill(dp[i][j][k], -1);\\n                }\\n            }\\n        }\\n        return domax(0, 0, 0, 0, s);\\n    }\\n\\n    int domax(int i, int j, int last, int cur, char[][] s) {\\n\\n        int m = s.length;\\n        int n = s[0].length;\\n        if (i == m || j == n) {\\n            return 0;\\n        }\\n        if (dp[i][j][last][cur] != -1) {\\n            return dp[i][j][last][cur];\\n        }\\n        int nop = i + 1 < m ? domax(i + 1, j, last, cur, s) : domax(0, j + 1, cur, 0, s);\\n        if (s[i][j] == \\'#\\' ){\\n            dp[i][j][last][cur] = nop;\\n            return nop;\\n        }\\n        if(bad(last, i)) {\\n            dp[i][j][last][cur] = nop;\\n            return nop;\\n        }\\n        int ns = cur | (1 << i);\\n        int p = i + 1 < m ? 1 + domax(i + 1, j, last, ns, s) : 1 + domax(0, j + 1, ns, 0, s);\\n        int rt = Math.max(p, nop);\\n        dp[i][j][last][cur] = rt;\\n        return rt;\\n    }\\n\\n    private boolean bad(int last, int i) {\\n        if (((last >> i) & 1) == 1) {\\n            return true;\\n        }\\n        if (((last >> (i - 1)) & 1) == 1) {\\n            return true;\\n        }\\n        if (((last >> (i + 1)) & 1) == 1) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503537,
                "title": "python-state-compression-dp",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        maxx = 2 ** R\\n        dp = [0] * maxx\\n        \\n        for c in range(C):\\n            n_dp = [0] * maxx\\n            for i in range(maxx):\\n                count = 0\\n                flag = False\\n                for k in range(R):\\n                    t = (1 << k) & i\\n                    if t:\\n                        count += 1\\n                    if t and seats[k][c] == \\'#\\':\\n                        flag = True\\n                if flag:\\n                    continue\\n                for j in range(maxx):\\n                    if ((i | (i >> 1)) & j) == 0 and ((j | j >> 1) & i == 0):\\n                        n_dp[i] = max(n_dp[i], dp[j] + count)\\n            dp = n_dp\\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        R, C = len(seats), len(seats[0])\\n        maxx = 2 ** R\\n        dp = [0] * maxx\\n        \\n        for c in range(C):\\n            n_dp = [0] * maxx\\n            for i in range(maxx):\\n                count = 0\\n                flag = False\\n                for k in range(R):\\n                    t = (1 << k) & i\\n                    if t:\\n                        count += 1\\n                    if t and seats[k][c] == \\'#\\':\\n                        flag = True\\n                if flag:\\n                    continue\\n                for j in range(maxx):\\n                    if ((i | (i >> 1)) & j) == 0 and ((j | j >> 1) & i == 0):\\n                        n_dp[i] = max(n_dp[i], dp[j] + count)\\n            dp = n_dp\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503524,
                "title": "java-dp-bit-solution",
                "content": "```\\nclass Solution {\\n    int n;\\n    int m;\\n    int s;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int maxStudents(char[][] seats) {\\n        int n = seats.length;\\n        int m = seats[0].length;\\n        s = n * m;\\n        long state = 1 << s;\\n        return dfs(0, 0, seats, new boolean[n][m], state);\\n    }\\n    int dfs(int x, int y, char[][] seats, boolean[][] visited, long state) {\\n        int left = x * m + y;\\n        if (x == seats.length) {\\n            return 0;\\n        }\\n        String key = x + \" \" + y + \" \"+ state;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        int res = 0;\\n        if (seats[x][y] == \\'.\\') {\\n            int x1 = x - 1;\\n            int y1 = y - 1;\\n            int x2 = x - 1;\\n            int y2 = y + 1;\\n            int x3 = x;\\n            int y3 = y - 1;\\n            int x4 = x;\\n            int y4 = y + 1;\\n            if ((check(x1, y1, seats) || visited[x1][y1] == false) \\n                && (check(x2, y2, seats) || visited[x2][y2] == false)\\n               && (check(x3, y3, seats) || visited[x3][y3] == false)\\n               && (check(x4, y4, seats) || visited[x4][y4] == false)) {\\n                if (y == seats[x].length - 1) {\\n                    visited[x][y] = true;\\n                    state = state | (1 << left);\\n                    res = Math.max(res, dfs(x + 1, 0, seats, visited, state) + 1);\\n                    state = state ^ (1 << left);\\n                    visited[x][y] = false;\\n                } else {\\n                    visited[x][y] = true;\\n                    state = state | (1 << left);\\n                    res = Math.max(res, dfs(x, y + 1, seats, visited, state) + 1);\\n                    state = state ^ (1 << left);\\n                    visited[x][y] = false;\\n                }\\n            } \\n        }\\n        if (y == seats[x].length - 1) {\\n            res = Math.max(res, dfs(x + 1, 0, seats, visited, state));\\n        } else {\\n            res = Math.max(res, dfs(x, y + 1, seats, visited, state));\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    boolean check(int x, int y, char[][] seats) {\\n        if (x < 0 || y < 0 || x >= seats.length || y >= seats[0].length) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int n;\\n    int m;\\n    int s;\\n    Map<String, Integer> memo = new HashMap<>();\\n    public int maxStudents(char[][] seats) {\\n        int n = seats.length;\\n        int m = seats[0].length;\\n        s = n * m;\\n        long state = 1 << s;\\n        return dfs(0, 0, seats, new boolean[n][m], state);\\n    }\\n    int dfs(int x, int y, char[][] seats, boolean[][] visited, long state) {\\n        int left = x * m + y;\\n        if (x == seats.length) {\\n            return 0;\\n        }\\n        String key = x + \" \" + y + \" \"+ state;\\n        if (memo.containsKey(key)) {\\n            return memo.get(key);\\n        }\\n        int res = 0;\\n        if (seats[x][y] == \\'.\\') {\\n            int x1 = x - 1;\\n            int y1 = y - 1;\\n            int x2 = x - 1;\\n            int y2 = y + 1;\\n            int x3 = x;\\n            int y3 = y - 1;\\n            int x4 = x;\\n            int y4 = y + 1;\\n            if ((check(x1, y1, seats) || visited[x1][y1] == false) \\n                && (check(x2, y2, seats) || visited[x2][y2] == false)\\n               && (check(x3, y3, seats) || visited[x3][y3] == false)\\n               && (check(x4, y4, seats) || visited[x4][y4] == false)) {\\n                if (y == seats[x].length - 1) {\\n                    visited[x][y] = true;\\n                    state = state | (1 << left);\\n                    res = Math.max(res, dfs(x + 1, 0, seats, visited, state) + 1);\\n                    state = state ^ (1 << left);\\n                    visited[x][y] = false;\\n                } else {\\n                    visited[x][y] = true;\\n                    state = state | (1 << left);\\n                    res = Math.max(res, dfs(x, y + 1, seats, visited, state) + 1);\\n                    state = state ^ (1 << left);\\n                    visited[x][y] = false;\\n                }\\n            } \\n        }\\n        if (y == seats[x].length - 1) {\\n            res = Math.max(res, dfs(x + 1, 0, seats, visited, state));\\n        } else {\\n            res = Math.max(res, dfs(x, y + 1, seats, visited, state));\\n        }\\n        memo.put(key, res);\\n        return res;\\n    }\\n    boolean check(int x, int y, char[][] seats) {\\n        if (x < 0 || y < 0 || x >= seats.length || y >= seats[0].length) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074435,
                "title": "dfs-bitmask-with-memoization-in-python3",
                "content": "This is basically a backtracking question. First bitmask question I solved myself...\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m = len(seats)\\n        n = len(seats[0])\\n        self.res = 0\\n        @cache \\n        def dp(i,premask,j,currmask,stu):\\n            if i == m:\\n                self.res = max(stu,self.res)\\n                return \\n            if j == n:\\n                dp(i+1,currmask,0,0,stu)\\n                return \\n            possible = seats[i][j] == \\'.\\' \\n            if j > 0:\\n                possible = possible and ((premask >> (j-1) & 1)  == 0) and ((currmask >> (j-1)) & 1 ==0)\\n            if j < n-1:\\n                possible = possible and ((premask >> (j+1)) & 1  == 0)\\n            if possible:\\n                dp(i,premask,j+1,currmask | (1<<j),stu+1)\\n            dp(i,premask,j+1,currmask,stu)\\n        dp(0,0,0,0,0)\\n        return self.res\\n                    \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m = len(seats)\\n        n = len(seats[0])\\n        self.res = 0\\n        @cache \\n        def dp(i,premask,j,currmask,stu):\\n            if i == m:\\n                self.res = max(stu,self.res)\\n                return \\n            if j == n:\\n                dp(i+1,currmask,0,0,stu)\\n                return \\n            possible = seats[i][j] == \\'.\\' \\n            if j > 0:\\n                possible = possible and ((premask >> (j-1) & 1)  == 0) and ((currmask >> (j-1)) & 1 ==0)\\n            if j < n-1:\\n                possible = possible and ((premask >> (j+1)) & 1  == 0)\\n            if possible:\\n                dp(i,premask,j+1,currmask | (1<<j),stu+1)\\n            dp(i,premask,j+1,currmask,stu)\\n        dp(0,0,0,0,0)\\n        return self.res\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073255,
                "title": "python-nooby-dp-bitmasking-solution-150-ms-beats-30-unknown-tc",
                "content": "unknown time complexity, i know the two mask can be compressed for state, just too lazy to modify existing solution. Normal backtrack + memoization, we store prevmask for knowing when to skip. Unknown time complexity, possible ones are M*2^M , the maximum recursive function calls counted are around 25k for 8x8 with all good seats.\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        bitmap = []\\n        COL = len(seats[0])\\n        ROW =  len(seats)\\n        dp = {}\\n        def backtrack(mask,ind,nmask):\\n            if (ind,mask,nmask) in dp:\\n                return dp[(ind,mask,nmask)]\\n            if ind < 0:\\n                return 0 \\n            dp[(ind,mask,nmask)] = 0\\n            \\n            for i in range(COL):\\n                if (mask&(1<<(COL-1-i))) or (seats[ind][i] ==\\'#\\') or(mask&(1<<(COL-i))) or (nmask&(1<<(COL-i))):\\n                    continue \\n                if ((COL-2-i)>=0) and (mask&(1<<(COL-2-i)) or (nmask&(1<<(COL-2-i)))):   \\n                    continue\\n                new_mask  =  mask|(1<<(COL-1-i)) \\n               \\n                dp[(ind,mask,nmask)] = max(dp[(ind,mask,nmask)],1+backtrack(new_mask,ind,nmask))\\n            dp[(ind,mask,nmask)] = max(dp[(ind,mask,nmask)],backtrack(0,ind-1,mask))\\n                \\n            return dp[(ind,mask,nmask)]\\n        return backtrack(0,ROW-1,0)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "class Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        bitmap = []\\n        COL = len(seats[0])\\n        ROW =  len(seats)\\n        dp = {}",
                "codeTag": "Java"
            },
            {
                "id": 4069092,
                "title": "java-simple-dfs-dp-sliding-window-bit-mask",
                "content": "* Place students in the order - (0,0) -> (0,1),..(m-1,n-1)\\n* DFS - 2 branches\\n\\t* 1 - proceed by placing a student in current position\\n\\t* 1 - proceed by not placing a student in current position\\n* Placing a student in a seat depends only on the last n+1 positions in the grid.\\n\\n```\\nclass Solution {\\n    char[][] st;\\n    int m, n;\\n    int[][][] dp;\\n    int mask;\\n    public int maxStudents(char[][] seats) {\\n        st=seats;\\n        m=seats.length;\\n        n=seats[0].length;\\n        mask=(1<<(n+1))-1;\\n        dp=new int[m][n][mask+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return dfs(0, 0, 0);\\n    }\\n    public int dfs(int i, int j, int preMask){\\n        if(i==m-1 && j==n){\\n           return 0; \\n        }\\n        if(j==n){\\n            i++;\\n            j=0;\\n        }\\n        if(dp[i][j][preMask]!=-1){\\n            return dp[i][j][preMask];\\n        }\\n        dp[i][j][preMask]=dfs(i, j+1, (preMask<<1)&mask);\\n        if(st[i][j]!=\\'#\\' && canAccomodate(i, j, preMask)){\\n            dp[i][j][preMask]=Math.max(dp[i][j][preMask], 1+dfs(i, j+1, ((preMask<<1)|1)&mask));\\n        }\\n        return dp[i][j][preMask];\\n    }\\n    public boolean canAccomodate(int i, int j, int preMask){\\n        boolean uLOccupied=(preMask&(1<<n)) > 0;\\n        boolean uROccupied=(preMask&(1<<(n-2))) > 0;\\n        boolean lOccupied=(preMask&(1)) > 0;\\n        boolean possible=(j==0 || (!uLOccupied && !lOccupied)) && (j==n-1 || !uROccupied);\\n        return possible;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    char[][] st;\\n    int m, n;\\n    int[][][] dp;\\n    int mask;\\n    public int maxStudents(char[][] seats) {\\n        st=seats;\\n        m=seats.length;\\n        n=seats[0].length;\\n        mask=(1<<(n+1))-1;\\n        dp=new int[m][n][mask+1];\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                Arrays.fill(dp[i][j], -1);\\n            }\\n        }\\n        return dfs(0, 0, 0);\\n    }\\n    public int dfs(int i, int j, int preMask){\\n        if(i==m-1 && j==n){\\n           return 0; \\n        }\\n        if(j==n){\\n            i++;\\n            j=0;\\n        }\\n        if(dp[i][j][preMask]!=-1){\\n            return dp[i][j][preMask];\\n        }\\n        dp[i][j][preMask]=dfs(i, j+1, (preMask<<1)&mask);\\n        if(st[i][j]!=\\'#\\' && canAccomodate(i, j, preMask)){\\n            dp[i][j][preMask]=Math.max(dp[i][j][preMask], 1+dfs(i, j+1, ((preMask<<1)|1)&mask));\\n        }\\n        return dp[i][j][preMask];\\n    }\\n    public boolean canAccomodate(int i, int j, int preMask){\\n        boolean uLOccupied=(preMask&(1<<n)) > 0;\\n        boolean uROccupied=(preMask&(1<<(n-2))) > 0;\\n        boolean lOccupied=(preMask&(1)) > 0;\\n        boolean possible=(j==0 || (!uLOccupied && !lOccupied)) && (j==n-1 || !uROccupied);\\n        return possible;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030792,
                "title": "c-python-bitmask-dp-solution-with-explanation",
                "content": "### bitmask dp\\n\\ndp_0[mask] is max number of person can join the exam from row 0 to previous row and ```mask``` people seated in previous row.\\ndp_1[mask] is max number of person can join the exam from row 0 to current row and ```mask``` people seated in current row.\\ndp_0[mask] = -1 mean there is no way.\\nFirst, dp_0[0] = 0, and we can use a array of bitmask to indicate where are seats in a row.\\n\\nAnd we can enumearte all possible mask in pervious row (mask_0) and current row (mask_1).\\nif dp_0[mask_0] = -1, we can skip it.\\n\\nmask_1 & avail[i] != mask_1 check if there has a person seat on a broken seat in current row.\\nmask_1 & (mask_1 >> 1) check if there there has any adjacent person in current row.\\nmask_1 & (mask_0 >> 1) and mask_1 & (mask_0 << 1) check if a person is sitting on upper left and upper right of another person.\\n\\ndp_1[mask_1] = max(dp_1[mask_1], dp_0[mask_0] + cnt) where cnt is how many people seat on current row.\\ntc is O(2^(2n) * m), sc is O(2^n).\\n\\n### python\\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        dp_0 = [-1] * (1 << n)\\n        dp_1 = [-1] * (1 << n)\\n        dp_0[0] = 0\\n        avail = [0] * m\\n        for i, row in enumerate(seats):\\n            for j, ch in enumerate(row):\\n                if ch == \\'.\\': avail[i] |= 1 << j\\n        \\n        for i in range(m):\\n            for mask_0 in range(1 << n):\\n                if dp_0[mask_0] == -1: continue\\n                for mask_1 in range(1 << n):\\n                    if mask_1 & avail[i] != mask_1 or mask_1 & (mask_1 >> 1) or mask_1 & (mask_0 >> 1) or mask_1 & (mask_0 << 1): continue\\n                    cnt = mask_1.bit_count()\\n                    dp_1[mask_1] = max(dp_1[mask_1], dp_0[mask_0] + cnt)\\n            dp_0, dp_1 = dp_1, dp_0\\n            for j in range(1 << n):\\n                dp_1[j] = -1\\n        return max(dp_0)\\n```\\n\\n### c++\\n```cpp\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size();\\n        vector<int> dp_0 (1 << n, -1), dp_1 (1 << n, -1);\\n        dp_0[0] = 0;\\n        vector<int> avail (m);\\n        for (int i = 0; i < m; i+=1) {\\n            for (int j = 0; j < n; j+=1)\\n                if (seats[i][j] == \\'.\\')\\n                    avail[i] |= 1 << j; \\n        }\\n        for (int i = 0; i < m; i+=1) {\\n            for (int mask_0 = 0; mask_0 < 1 << n; mask_0 += 1) {\\n                if (dp_0[mask_0] == -1) continue;\\n                for (int mask_1 = 0, cnt; mask_1 < 1 << n; mask_1 += 1) {\\n                    if ((mask_1 & avail[i]) != mask_1 || mask_1 & (mask_1 >> 1) || mask_1 & (mask_0 >> 1) || mask_1 & (mask_0 << 1)) continue;\\n                    cnt = __builtin_popcount(mask_1);\\n                    dp_1[mask_1] = max(dp_1[mask_1], dp_0[mask_0] + cnt);\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << n; j+=1) dp_1[j] = -1;\\n        }\\n        return *max_element(dp_0.begin(), dp_0.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```mask```\n```mask```\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        dp_0 = [-1] * (1 << n)\\n        dp_1 = [-1] * (1 << n)\\n        dp_0[0] = 0\\n        avail = [0] * m\\n        for i, row in enumerate(seats):\\n            for j, ch in enumerate(row):\\n                if ch == \\'.\\': avail[i] |= 1 << j\\n        \\n        for i in range(m):\\n            for mask_0 in range(1 << n):\\n                if dp_0[mask_0] == -1: continue\\n                for mask_1 in range(1 << n):\\n                    if mask_1 & avail[i] != mask_1 or mask_1 & (mask_1 >> 1) or mask_1 & (mask_0 >> 1) or mask_1 & (mask_0 << 1): continue\\n                    cnt = mask_1.bit_count()\\n                    dp_1[mask_1] = max(dp_1[mask_1], dp_0[mask_0] + cnt)\\n            dp_0, dp_1 = dp_1, dp_0\\n            for j in range(1 << n):\\n                dp_1[j] = -1\\n        return max(dp_0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size(), n = seats[0].size();\\n        vector<int> dp_0 (1 << n, -1), dp_1 (1 << n, -1);\\n        dp_0[0] = 0;\\n        vector<int> avail (m);\\n        for (int i = 0; i < m; i+=1) {\\n            for (int j = 0; j < n; j+=1)\\n                if (seats[i][j] == \\'.\\')\\n                    avail[i] |= 1 << j; \\n        }\\n        for (int i = 0; i < m; i+=1) {\\n            for (int mask_0 = 0; mask_0 < 1 << n; mask_0 += 1) {\\n                if (dp_0[mask_0] == -1) continue;\\n                for (int mask_1 = 0, cnt; mask_1 < 1 << n; mask_1 += 1) {\\n                    if ((mask_1 & avail[i]) != mask_1 || mask_1 & (mask_1 >> 1) || mask_1 & (mask_0 >> 1) || mask_1 & (mask_0 << 1)) continue;\\n                    cnt = __builtin_popcount(mask_1);\\n                    dp_1[mask_1] = max(dp_1[mask_1], dp_0[mask_0] + cnt);\\n                }\\n            }\\n            swap(dp_0, dp_1);\\n            for (int j = 0; j < 1 << n; j+=1) dp_1[j] = -1;\\n        }\\n        return *max_element(dp_0.begin(), dp_0.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025510,
                "title": "java-bitmask-easy-to-understand-with-comments",
                "content": "```\\n/*\\nexplanation: maximum students taking exam using bitmask! The algorithm works by using and maintaining a long bit mask for all the possible placements, and at each step it tries to place the student and avoid it, while finding maximum value!\\n\\ntestcase: -> Works\\n\\nTime & Space Complexity: O(n * 2^(n^2)) & O(n^2): Time complexity is n multiply by 2 raise to power n square, this is due to the maximum number of possible unique combinations that can be formed with board! While space complexity is quadratic due to board, etc.\\n*/\\nclass BitMask {\\n    long mask;\\n    int len;\\n    \\n    BitMask(int _len) {\\n        mask = 0; // Set all to 0\\n        mask = ~mask; // Flip, now all are ones!\\n        \\n        len = _len;\\n    }\\n    \\n    void setBit(int index, boolean bit) {\\n        if (index >= len) {\\n            throw new RuntimeException(\"Bit overflow\");\\n        }\\n\\n        if (bit) {\\n            _bitset(index, 1);\\n        } else {\\n            _bitset(index, 0);\\n        }\\n    }\\n    \\n    void _bitset(int index, int bit) {\\n        if (bit == 1) {\\n            // turn on\\n            mask = mask | ((long)1 << index);\\n        } else {\\n            // turn off\\n            mask = mask & ~((long)1 << index);\\n        }\\n    }\\n    \\n    int _bitget(int index) {\\n        return ((mask & ((long)1 << index)) != 0) ? 1 : 0;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i<len; i++) {\\n            sb.append(_bitget(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass BitBoard {\\n    BitMask bmask;\\n    int row;\\n    int col;\\n\\n    BitBoard(int _row, int _col) {\\n        row = _row;\\n        col = _col;\\n        \\n        bmask = new BitMask(row * col);\\n    }\\n    \\n    void setAt(int x, int y, int bit) {\\n        if (x < 0 || x >= row || y < 0 || y >= col)\\n            return;\\n\\n        bmask._bitset(col*x + y, bit);\\n    }\\n    \\n    int getAt(int x, int y) {\\n        return bmask._bitget(col*x + y);\\n    }\\n    \\n    long getState() {\\n        return bmask.mask;\\n    }\\n    \\n    void setState(long state) {\\n        bmask.mask = state;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                sb.append(getAt(i, j));\\n            }\\n            sb.append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass Solution {\\n    public boolean isInside(int x, int y, char[][] seats) {\\n        if (x < 0 || x >= seats.length || y < 0 || y >= seats[0].length)\\n            return false;\\n        \\n        return true;\\n    }\\n\\n    public int minimumSeats(int index, BitBoard board, HashMap<Integer, HashMap<Long, Integer>> dp) {\\n        if (index >= board.row * board.col)\\n            return 0;\\n        \\n        if (dp.getOrDefault(index, new HashMap<>()).containsKey(board.getState())) {\\n            // System.out.println(\"Reuse\");\\n            return dp.get(index).get(board.getState());\\n        }\\n        \\n        int row = index / board.col;\\n        int col = index % board.col;\\n        \\n        int ret = -1;\\n\\n        if (board.getAt(row, col) == 0) {\\n            // Cannot place anything here, get to next\\n            ret = minimumSeats(index + 1, board, dp);\\n        } else {\\n            int min = -1;\\n            long state_save = board.getState();\\n            \\n            \\n            // Place a student here\\n            board.setAt(row, col-1, 0);\\n            board.setAt(row, col+1, 0);\\n            board.setAt(row+1, col-1, 0);\\n            board.setAt(row+1, col+1, 0);\\n            board.setAt(row, col, 0);\\n            int placed = 1 + minimumSeats(index + 1, board, dp);\\n            \\n            // System.out.println(\"At row:\"+row+\" col:\"+col+\", place:\"+placed+\" board:\");\\n            // System.out.println(board);\\n            \\n            // Reset back\\n            board.setState(state_save);\\n\\n            // Do not place\\n            board.setAt(row, col, 0);\\n            int not_place = minimumSeats(index + 1, board, dp);\\n            board.setAt(row, col, 1);\\n            \\n            ret = Math.max(placed, not_place);\\n        }\\n        \\n        \\n        HashMap<Long, Integer> st = dp.getOrDefault(index, new HashMap<>());\\n        st.put(board.getState(), ret);\\n        dp.put(index, st);\\n        \\n        return ret;\\n    }\\n\\n    public int maxStudents(char[][] seats) {\\n        // BitMask bm = new BitMask(64);\\n        // System.out.println(bm);\\n\\n        BitBoard board = new BitBoard(seats.length, seats[0].length);\\n        for (int i=0; i<seats.length; i++) {\\n            for (int j=0; j<seats[0].length; j++) {\\n                board.setAt(i, j, seats[i][j] == \\'.\\' ? 1 : 0);\\n            }\\n        }\\n\\n        HashMap<Integer, HashMap<Long, Integer>> dp = new HashMap<>();\\n        // System.out.println(board);\\n\\n        return minimumSeats(0, board, dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bitmask"
                ],
                "code": "```\\n/*\\nexplanation: maximum students taking exam using bitmask! The algorithm works by using and maintaining a long bit mask for all the possible placements, and at each step it tries to place the student and avoid it, while finding maximum value!\\n\\ntestcase: -> Works\\n\\nTime & Space Complexity: O(n * 2^(n^2)) & O(n^2): Time complexity is n multiply by 2 raise to power n square, this is due to the maximum number of possible unique combinations that can be formed with board! While space complexity is quadratic due to board, etc.\\n*/\\nclass BitMask {\\n    long mask;\\n    int len;\\n    \\n    BitMask(int _len) {\\n        mask = 0; // Set all to 0\\n        mask = ~mask; // Flip, now all are ones!\\n        \\n        len = _len;\\n    }\\n    \\n    void setBit(int index, boolean bit) {\\n        if (index >= len) {\\n            throw new RuntimeException(\"Bit overflow\");\\n        }\\n\\n        if (bit) {\\n            _bitset(index, 1);\\n        } else {\\n            _bitset(index, 0);\\n        }\\n    }\\n    \\n    void _bitset(int index, int bit) {\\n        if (bit == 1) {\\n            // turn on\\n            mask = mask | ((long)1 << index);\\n        } else {\\n            // turn off\\n            mask = mask & ~((long)1 << index);\\n        }\\n    }\\n    \\n    int _bitget(int index) {\\n        return ((mask & ((long)1 << index)) != 0) ? 1 : 0;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i<len; i++) {\\n            sb.append(_bitget(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass BitBoard {\\n    BitMask bmask;\\n    int row;\\n    int col;\\n\\n    BitBoard(int _row, int _col) {\\n        row = _row;\\n        col = _col;\\n        \\n        bmask = new BitMask(row * col);\\n    }\\n    \\n    void setAt(int x, int y, int bit) {\\n        if (x < 0 || x >= row || y < 0 || y >= col)\\n            return;\\n\\n        bmask._bitset(col*x + y, bit);\\n    }\\n    \\n    int getAt(int x, int y) {\\n        return bmask._bitget(col*x + y);\\n    }\\n    \\n    long getState() {\\n        return bmask.mask;\\n    }\\n    \\n    void setState(long state) {\\n        bmask.mask = state;\\n    }\\n    \\n    @Override\\n    public String toString() {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                sb.append(getAt(i, j));\\n            }\\n            sb.append(\"\\\\n\");\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\nclass Solution {\\n    public boolean isInside(int x, int y, char[][] seats) {\\n        if (x < 0 || x >= seats.length || y < 0 || y >= seats[0].length)\\n            return false;\\n        \\n        return true;\\n    }\\n\\n    public int minimumSeats(int index, BitBoard board, HashMap<Integer, HashMap<Long, Integer>> dp) {\\n        if (index >= board.row * board.col)\\n            return 0;\\n        \\n        if (dp.getOrDefault(index, new HashMap<>()).containsKey(board.getState())) {\\n            // System.out.println(\"Reuse\");\\n            return dp.get(index).get(board.getState());\\n        }\\n        \\n        int row = index / board.col;\\n        int col = index % board.col;\\n        \\n        int ret = -1;\\n\\n        if (board.getAt(row, col) == 0) {\\n            // Cannot place anything here, get to next\\n            ret = minimumSeats(index + 1, board, dp);\\n        } else {\\n            int min = -1;\\n            long state_save = board.getState();\\n            \\n            \\n            // Place a student here\\n            board.setAt(row, col-1, 0);\\n            board.setAt(row, col+1, 0);\\n            board.setAt(row+1, col-1, 0);\\n            board.setAt(row+1, col+1, 0);\\n            board.setAt(row, col, 0);\\n            int placed = 1 + minimumSeats(index + 1, board, dp);\\n            \\n            // System.out.println(\"At row:\"+row+\" col:\"+col+\", place:\"+placed+\" board:\");\\n            // System.out.println(board);\\n            \\n            // Reset back\\n            board.setState(state_save);\\n\\n            // Do not place\\n            board.setAt(row, col, 0);\\n            int not_place = minimumSeats(index + 1, board, dp);\\n            board.setAt(row, col, 1);\\n            \\n            ret = Math.max(placed, not_place);\\n        }\\n        \\n        \\n        HashMap<Long, Integer> st = dp.getOrDefault(index, new HashMap<>());\\n        st.put(board.getState(), ret);\\n        dp.put(index, st);\\n        \\n        return ret;\\n    }\\n\\n    public int maxStudents(char[][] seats) {\\n        // BitMask bm = new BitMask(64);\\n        // System.out.println(bm);\\n\\n        BitBoard board = new BitBoard(seats.length, seats[0].length);\\n        for (int i=0; i<seats.length; i++) {\\n            for (int j=0; j<seats[0].length; j++) {\\n                board.setAt(i, j, seats[i][j] == \\'.\\' ? 1 : 0);\\n            }\\n        }\\n\\n        HashMap<Integer, HashMap<Long, Integer>> dp = new HashMap<>();\\n        // System.out.println(board);\\n\\n        return minimumSeats(0, board, dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016122,
                "title": "python-95-intuition",
                "content": "# Intuition\\nWe start with a brute force approach. This involves recursively backtracking over the entire set of states and choosing to place or not place children in seats. This will result in a cost of about O(2^(mn)).\\n\\nWhen it comes to recursive problems, a good question is to ask: is it possible to memoize, bounding the number of states? To do this, we need independent subproblems: specifically, later recursive calls should be self-sufficient, not having to regard previous states. \\n\\nTo create such independent subproblems, notice how we know when we place a student at some state, the seats to their left and right as well as bottom left and bottom right can no longer be occupied. This means if we selectively only visit valid seats later, we don\\'t have to worry about whether we placed a student at this current state or not. This means we can memoize our solution.\\n\\nSo that\\'s exactly what we\\'ll do!\\n\\n# Approach\\nUsing bitmasks to track the available seating for the next row, we will recursively backtrack through the states and place children in seats. This way, starting from a row, we can memoize our recursive calls.\\n\\n# Complexity\\n- Time complexity:\\nO((4^m))*m*n) - we track two bitmasks for the current row and the next row, as well as the current location (i,j). \\n\\n- Space complexity:\\nO((4^m))*m*n) - number of cached states\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        initial = ~((~0)<<len(seats[0]))\\n        # reset b for each row\\n        # rb is current row. cb is the next row\\n        @lru_cache(None)\\n        def dfs(i,j,rb,cb):\\n            if i == len(seats):\\n                return 0\\n            if j == len(seats[0]):\\n                return dfs(i+1,0,cb,initial)\\n            \\n            res = dfs(i,j+1,rb,cb)\\n            if rb & (1<<j) and seats[i][j] == \".\":\\n                leftb = ~(1<<(j-1)) if j > 0 else ~0\\n                crb = rb & ~(1<<(j+1)) & leftb & ~(1<<j)\\n                ccb = cb & ~(1<<(j+1)) & leftb\\n                res = max(res, dfs(i,j+1,crb,ccb)+1)\\n            return res\\n        # indices are flipped (i.e. j @ 0 is to the rightmost bit)\\n        return dfs(0,0,initial,initial)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        initial = ~((~0)<<len(seats[0]))\\n        # reset b for each row\\n        # rb is current row. cb is the next row\\n        @lru_cache(None)\\n        def dfs(i,j,rb,cb):\\n            if i == len(seats):\\n                return 0\\n            if j == len(seats[0]):\\n                return dfs(i+1,0,cb,initial)\\n            \\n            res = dfs(i,j+1,rb,cb)\\n            if rb & (1<<j) and seats[i][j] == \".\":\\n                leftb = ~(1<<(j-1)) if j > 0 else ~0\\n                crb = rb & ~(1<<(j+1)) & leftb & ~(1<<j)\\n                ccb = cb & ~(1<<(j+1)) & leftb\\n                res = max(res, dfs(i,j+1,crb,ccb)+1)\\n            return res\\n        # indices are flipped (i.e. j @ 0 is to the rightmost bit)\\n        return dfs(0,0,initial,initial)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000233,
                "title": "bitmask-dp",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    int DP[64][1<<8][1<<8];\\n    int m,n;\\n    bool eligible(int curmask, int prevmask,int i, int j)\\n    {\\n        if(j!=0 && (curmask& 1<<(j-1)))\\n            return false;\\n        if(j!=0 && (prevmask& 1<<(j-1)))\\n            return false;\\n        if(j+1<n && (prevmask& 1<<(j+1)))\\n            return false;\\n        return true;\\n    }\\n    int solve(int i,int curmask, int prevmask,vector<pair<int,int>>&chairs)\\n    {\\n        if(i== chairs.size())\\n            return 0;\\n        if(DP[i][curmask][prevmask]!=-1)\\n                return DP[i][curmask][prevmask];\\n        int notpick=0,pick=0;\\n        if(i+1<chairs.size() && chairs[i+1].first-chairs[i].first==1)\\n        { //when next chair is on just next row\\n            notpick = solve(i+1,0,curmask,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick=solve(i+1,0,curmask |1<<chairs[i].second,chairs)+1;\\n        }\\n        else if(i+1<chairs.size()&& (chairs[i+1].first-chairs[i].first)>1)\\n        { //when next chair is not on just next row \\n            notpick= solve(i+1,0,0,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick=solve(i+1,0,0,chairs)+1;\\n        }\\n        else\\n        {\\n            //when next chair is on same row\\n            notpick= solve(i+1,curmask,prevmask,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick= solve(i+1,curmask|1<<chairs[i].second,prevmask,chairs)+1;\\n        }\\n        return DP[i][curmask][prevmask]= max(pick,notpick);\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(DP,-1,sizeof(DP));\\n        m=seats.size();\\n        n=seats[0].size();\\n        vector<pair<int,int>> chairs;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(seats[i][j]==\\'.\\')\\n                    chairs.push_back({i,j});\\n            }\\n        }\\n       \\n        int mask=0;\\n        return solve(0,0,0,chairs);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    int DP[64][1<<8][1<<8];\\n    int m,n;\\n    bool eligible(int curmask, int prevmask,int i, int j)\\n    {\\n        if(j!=0 && (curmask& 1<<(j-1)))\\n            return false;\\n        if(j!=0 && (prevmask& 1<<(j-1)))\\n            return false;\\n        if(j+1<n && (prevmask& 1<<(j+1)))\\n            return false;\\n        return true;\\n    }\\n    int solve(int i,int curmask, int prevmask,vector<pair<int,int>>&chairs)\\n    {\\n        if(i== chairs.size())\\n            return 0;\\n        if(DP[i][curmask][prevmask]!=-1)\\n                return DP[i][curmask][prevmask];\\n        int notpick=0,pick=0;\\n        if(i+1<chairs.size() && chairs[i+1].first-chairs[i].first==1)\\n        { //when next chair is on just next row\\n            notpick = solve(i+1,0,curmask,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick=solve(i+1,0,curmask |1<<chairs[i].second,chairs)+1;\\n        }\\n        else if(i+1<chairs.size()&& (chairs[i+1].first-chairs[i].first)>1)\\n        { //when next chair is not on just next row \\n            notpick= solve(i+1,0,0,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick=solve(i+1,0,0,chairs)+1;\\n        }\\n        else\\n        {\\n            //when next chair is on same row\\n            notpick= solve(i+1,curmask,prevmask,chairs);\\n            if(eligible(curmask,prevmask,chairs[i].first,chairs[i].second))\\n                pick= solve(i+1,curmask|1<<chairs[i].second,prevmask,chairs)+1;\\n        }\\n        return DP[i][curmask][prevmask]= max(pick,notpick);\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(DP,-1,sizeof(DP));\\n        m=seats.size();\\n        n=seats[0].size();\\n        vector<pair<int,int>> chairs;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(seats[i][j]==\\'.\\')\\n                    chairs.push_back({i,j});\\n            }\\n        }\\n       \\n        int mask=0;\\n        return solve(0,0,0,chairs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861266,
                "title": "c-dp-iterative-bitmask",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n * 2^m * 2^m)$$\\n\\n- Space complexity:\\n$$O(n * 2^m)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[8][1 << 8]; // max no of students that can take the exam considering the first i students which have a seating arrangement of j\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int n = seats.size();\\n        int m = seats[0].size();\\n        for(int i=0;i<(1 << m);i++)\\n        {\\n            int ok = 1;\\n            for(int j=0;j<m;j++)\\n            {\\n                if((i>>j & 1) && (seats[0][m - 1 - j] == \\'#\\'))ok = 0;\\n            }\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if((i>>j & 1) && (i>>(j + 1) & 1))ok = 0;\\n            }\\n            if(ok)\\n            {\\n                dp[0][i] = __builtin_popcount(i);\\n            }\\n            else\\n            {\\n                dp[0][i] = 0;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<(1 << m);j++)\\n            {\\n                int ok = 1;\\n                for(int k=0;k<m;k++)\\n                {\\n                    if((j>>k & 1) && (seats[i][m - 1 - k] == \\'#\\'))ok = 0;\\n                }\\n                for(int k=0;k<m-1;k++)\\n                {\\n                    if((j>>k & 1) && (j>>(k + 1) & 1))ok = 0;\\n                }\\n                if(ok)\\n                {\\n                    int mx = 0;\\n                    for(int p=0;p<(1 << m);p++)\\n                    {\\n                        int ok = 1;\\n                        for(int q=0;q<m;q++)\\n                        {\\n                            if((p>>q & 1) && (seats[i - 1][m - 1 - q] == \\'#\\'))ok = 0;\\n                        }\\n                        for(int q=0;q<m-1;q++)\\n                        {\\n                            if((p>>q & 1) && (p>>(q + 1) & 1))ok = 0;\\n                        }\\n                        for(int q=0;q<m;q++)\\n                        {\\n                            if(j>>q & 1)\\n                            {\\n                                if(q + 1 < m && (p>>(q + 1) & 1))ok = 0;\\n                                if(q - 1 >= 0 && (p>>(q - 1) & 1))ok = 0;\\n                            }\\n                        }\\n                        if(ok)\\n                        {\\n                            mx = max(mx,dp[i - 1][p]);\\n                        }\\n                    }\\n                    dp[i][j] = mx + __builtin_popcount(j);\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<(1 << m);j++)\\n        {\\n            ans = max(ans,dp[n - 1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[8][1 << 8]; // max no of students that can take the exam considering the first i students which have a seating arrangement of j\\n\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int n = seats.size();\\n        int m = seats[0].size();\\n        for(int i=0;i<(1 << m);i++)\\n        {\\n            int ok = 1;\\n            for(int j=0;j<m;j++)\\n            {\\n                if((i>>j & 1) && (seats[0][m - 1 - j] == \\'#\\'))ok = 0;\\n            }\\n            for(int j=0;j<m-1;j++)\\n            {\\n                if((i>>j & 1) && (i>>(j + 1) & 1))ok = 0;\\n            }\\n            if(ok)\\n            {\\n                dp[0][i] = __builtin_popcount(i);\\n            }\\n            else\\n            {\\n                dp[0][i] = 0;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            for(int j=0;j<(1 << m);j++)\\n            {\\n                int ok = 1;\\n                for(int k=0;k<m;k++)\\n                {\\n                    if((j>>k & 1) && (seats[i][m - 1 - k] == \\'#\\'))ok = 0;\\n                }\\n                for(int k=0;k<m-1;k++)\\n                {\\n                    if((j>>k & 1) && (j>>(k + 1) & 1))ok = 0;\\n                }\\n                if(ok)\\n                {\\n                    int mx = 0;\\n                    for(int p=0;p<(1 << m);p++)\\n                    {\\n                        int ok = 1;\\n                        for(int q=0;q<m;q++)\\n                        {\\n                            if((p>>q & 1) && (seats[i - 1][m - 1 - q] == \\'#\\'))ok = 0;\\n                        }\\n                        for(int q=0;q<m-1;q++)\\n                        {\\n                            if((p>>q & 1) && (p>>(q + 1) & 1))ok = 0;\\n                        }\\n                        for(int q=0;q<m;q++)\\n                        {\\n                            if(j>>q & 1)\\n                            {\\n                                if(q + 1 < m && (p>>(q + 1) & 1))ok = 0;\\n                                if(q - 1 >= 0 && (p>>(q - 1) & 1))ok = 0;\\n                            }\\n                        }\\n                        if(ok)\\n                        {\\n                            mx = max(mx,dp[i - 1][p]);\\n                        }\\n                    }\\n                    dp[i][j] = mx + __builtin_popcount(j);\\n                }\\n                else\\n                {\\n                    dp[i][j] = 0;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j<(1 << m);j++)\\n        {\\n            ans = max(ans,dp[n - 1][j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716191,
                "title": "dp-bitmask-95-faster-c",
                "content": "# Intuition\\nThe state of a row can be contructed by previous row which has compatible state (without cheating)\\n# Approach\\nUsing bitmask to represent state (1 when there is a student)\\n```\\n// can be used to check whether current state is a subset of previous state\\n(Current state & previous state) == current state \\n```\\n\\n```\\n// can be used to check whether there are continuous bit \\n// (can\\'t sit next to each other)\\nstate & (state >> 1) == 0\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * 2^n)$$\\n- Space complexity:\\n$$O(m * 2^n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n\\n        // every rows\\' state\\n        vector<int> row(m, 0);\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                row[i] = row[i] * 2 + (seats[i][j] == \\'.\\');\\n            }\\n        }\\n\\n        vector<vector<int>> dp(m + 1, vector<int>((1 << n) + 1, -1));\\n\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            int all = row[i - 1];\\n\\n            // this round\\'s states\\n            for(int j = 0; j < (1 << n); ++j) {\\n\\n                // subset of all bits\\n                if((j & all) == j && (j & (j >> 1)) == 0) {\\n                    for(int k = 0; k < (1 << n); ++k) {\\n                        if(\\n                            !((j >> 1) & k) \\n                            && !((k >> 1) & j) \\n                            && dp[i - 1][k] != -1\\n                        ) {\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\n// can be used to check whether current state is a subset of previous state\\n(Current state & previous state) == current state \\n```\n```\\n// can be used to check whether there are continuous bit \\n// (can\\'t sit next to each other)\\nstate & (state >> 1) == 0\\n```\n```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n\\n        // every rows\\' state\\n        vector<int> row(m, 0);\\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                row[i] = row[i] * 2 + (seats[i][j] == \\'.\\');\\n            }\\n        }\\n\\n        vector<vector<int>> dp(m + 1, vector<int>((1 << n) + 1, -1));\\n\\n        dp[0][0] = 0;\\n        for(int i = 1; i <= m; ++i) {\\n            int all = row[i - 1];\\n\\n            // this round\\'s states\\n            for(int j = 0; j < (1 << n); ++j) {\\n\\n                // subset of all bits\\n                if((j & all) == j && (j & (j >> 1)) == 0) {\\n                    for(int k = 0; k < (1 << n); ++k) {\\n                        if(\\n                            !((j >> 1) & k) \\n                            && !((k >> 1) & j) \\n                            && dp[i - 1][k] != -1\\n                        ) {\\n                            dp[i][j] = max(dp[i][j], dp[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546381,
                "title": "primal-dual-solution-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are asked to find how many students we can maximally seat. We can instead consider what is the minimal number of seats that have an invalid placement. From this, we can then take our total number of seats and reduce it by the total of invalid placement seats to get the number of maximal placement. This is a similar problem to the originally hungarian algorithm, found here : https://en.wikipedia.org/wiki/Hungarian_algorithm\\n\\nPrimal Dual type solutions have more on them here : https://en.wikipedia.org/wiki/Duality_(optimization)\\n\\nIt can be seen that we have a strict qualification condition in that we obviously could use all seats if no seats led to a possibility of cheating, and if there is a chance of cheating for a seat, we necessarily will lose some seats by inference. This lets us use the primal dual approach succesfully. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt the start, set up the rows, cols, number of seats in total, the nodes visited originally (all -1 for dimensions of seats), and seat matching matrix (all -1 for dimensions of seats) \\n\\nThen we set up a dfs progression function to find if a seat is cheatable or not \\nIn this function, we are givin a row and col contained within a given node. Then, using the row and col in the node \\n- If any of our neighbors either left or right or diagonally forward or back are a valid seat in bounds and that is not yet visited \\n    - visit that node at the neighbor positions \\n    - if seat matching at the given location is -1 or a dfs off of the seat matching matrix at nr nc using nodes visited now updated is True,\\n        - mark this location in seat matching as the nr, nc \\n        - return True -> this implies we could cheat here \\n- If all neighbors attempted to visit but did not progress, return False, this is a safe seat \\n\\nFor the hungarian algorithm, we will be finding the total number of invalid chairs (ones that we can cheat from) To do so \\n- In col major order with col steps of 2 and row steps of 1 to avoid overcounting\\n    - if seats at row col is a seat \\n        - set up a fresh nodes visited \\n        - if dfs using row, col and new nodes visited is True \\n            - increment our number of invalid seats by 1 \\n        - reset the nodes visited originally after \\n- When done, return number of invalid chairs \\n\\nWe can optimally seat the number of total chairs minus the total number of invalid chairs. Return this valuation.      \\n\\n# Complexity\\n- Time complexity : O(R * C)\\n    - We visit all chairs to get the value of the number of chairs \\n    - This dominates time complexity overall, so O(R * C) where R is rows and C is columns   \\n\\n- Space complexity : O(R * C) \\n    - recursively we could at worst match time complexity for progression overall valid spaces. This would result in O(R * C) space complexity \\n    - We also use this in our number of seats, nodes visited, seat matching, etc. So this is also conditioned on that.  \\n\\n# Code\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int :\\n        # set up the rows, cols, number of seats, nodes visited originally, and the seat matching matrix to start \\n        self.rows = len(seats)\\n        self.cols = len(seats[0])\\n        self.number_of_seats = sum([sum([int(seat == \".\") for seat in row]) for row in seats])\\n        self.nodes_visited_originally = [[-1] * self.cols for _ in range(self.rows)]\\n        seat_matching_matrix = [[-1] * self.cols for _ in range(self.rows)]\\n        \\n        # set up a dfs progression \\n        def dfs(node, nodes_visited) :\\n            # get row and col from node  \\n            row, col = node \\n            # consider directions in those left and right, forward and backward diagonal \\n            for nr, nc in [[row, col+1], [row, col-1], [row+1, col+1], [row+1, col-1], [row-1, col+1], [row-1, col-1]] :\\n                # if in bounds, valid, and not visited \\n                if ((0 <= nr < self.rows) and (0 <= nc < self.cols)) and seats[nr][nc] == \".\" and nodes_visited[nr][nc] == -1 : \\n                    # visit it \\n                    nodes_visited[nr][nc] = 1\\n                    # if we have a seat matching matrix of -1 or dfs on seat matching matrix nr nc is true  \\n                    if seat_matching_matrix[nr][nc] == -1 or dfs(seat_matching_matrix[nr][nc], nodes_visited) :\\n                        # match it and return True  \\n                        seat_matching_matrix[nr][nc] = (row, col) \\n                        return True \\n            # return False \\n            return False \\n        \\n        # set up hungarian algorithm \\n        def hungarian_algorithm() : \\n            # overall result of the optimization \\n            result = 0 \\n            # col major order in steps of 2 to not overcount \\n            for col in range(0, self.cols, 2) : \\n                # row major order in steps of 1 \\n                for row in range(0, self.rows) :\\n                    # if we have a seat to consider  \\n                    if seats[row][col] == \".\" : \\n                        # set up fresh nodes visited \\n                        nodes_visited = self.nodes_visited_originally\\n                        # if successful, increment result \\n                        if dfs((row, col), nodes_visited) : \\n                            result += 1\\n                        # then reset nodes visited originally \\n                        self.nodes_visited_originally = [[-1]*self.cols for _ in range(self.rows)]\\n            # return when done \\n            return result \\n\\n        # get the number of invalid chairs  \\n        number_of_invalid_chairs = hungarian_algorithm()\\n        # you can only seat as many students as you have less the number of invalid chairs \\n        return self.number_of_seats - number_of_invalid_chairs  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int :\\n        # set up the rows, cols, number of seats, nodes visited originally, and the seat matching matrix to start \\n        self.rows = len(seats)\\n        self.cols = len(seats[0])\\n        self.number_of_seats = sum([sum([int(seat == \".\") for seat in row]) for row in seats])\\n        self.nodes_visited_originally = [[-1] * self.cols for _ in range(self.rows)]\\n        seat_matching_matrix = [[-1] * self.cols for _ in range(self.rows)]\\n        \\n        # set up a dfs progression \\n        def dfs(node, nodes_visited) :\\n            # get row and col from node  \\n            row, col = node \\n            # consider directions in those left and right, forward and backward diagonal \\n            for nr, nc in [[row, col+1], [row, col-1], [row+1, col+1], [row+1, col-1], [row-1, col+1], [row-1, col-1]] :\\n                # if in bounds, valid, and not visited \\n                if ((0 <= nr < self.rows) and (0 <= nc < self.cols)) and seats[nr][nc] == \".\" and nodes_visited[nr][nc] == -1 : \\n                    # visit it \\n                    nodes_visited[nr][nc] = 1\\n                    # if we have a seat matching matrix of -1 or dfs on seat matching matrix nr nc is true  \\n                    if seat_matching_matrix[nr][nc] == -1 or dfs(seat_matching_matrix[nr][nc], nodes_visited) :\\n                        # match it and return True  \\n                        seat_matching_matrix[nr][nc] = (row, col) \\n                        return True \\n            # return False \\n            return False \\n        \\n        # set up hungarian algorithm \\n        def hungarian_algorithm() : \\n            # overall result of the optimization \\n            result = 0 \\n            # col major order in steps of 2 to not overcount \\n            for col in range(0, self.cols, 2) : \\n                # row major order in steps of 1 \\n                for row in range(0, self.rows) :\\n                    # if we have a seat to consider  \\n                    if seats[row][col] == \".\" : \\n                        # set up fresh nodes visited \\n                        nodes_visited = self.nodes_visited_originally\\n                        # if successful, increment result \\n                        if dfs((row, col), nodes_visited) : \\n                            result += 1\\n                        # then reset nodes visited originally \\n                        self.nodes_visited_originally = [[-1]*self.cols for _ in range(self.rows)]\\n            # return when done \\n            return result \\n\\n        # get the number of invalid chairs  \\n        number_of_invalid_chairs = hungarian_algorithm()\\n        # you can only seat as many students as you have less the number of invalid chairs \\n        return self.number_of_seats - number_of_invalid_chairs  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544523,
                "title": "dp-bitmask-python3",
                "content": "# Intuition\\nplain back-tracking\\nO(2^(n*n)) TLE\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        def can_place(i, j):\\n            if seats[i][j]==\\'#\\':\\n                return False\\n            for x, y in [(i, j-1), (i, j+1), (i-1,j+1), (i-1, j-1)]:\\n                if 0<=x<len(seats) and 0<=y<len(seats[0]) and seats[x][y]==\\'S\\':\\n                    return False\\n            return True\\n        def place(i, j, count):\\n            if i==len(seats)-1 and j==len(seats[0]):\\n                place.max = max(place.max, count)\\n                return\\n            if j==len(seats[0]):\\n                place(i+1, 0, count)\\n                return\\n            if can_place(i, j):\\n                seats[i][j] = \\'S\\'\\n                place(i, j+1, count+1)\\n                seats[i][j] = \\'.\\'\\n            place(i, j+1, count)\\n        place.max = 0\\n        place(0, 0, 0)\\n        return place.max\\n```\\n\\nbut we can do better we only need to memorize previous and current row state , we can use two bitmask for that.\\n(O(m*n*2^m*2^n))\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        def can_place(i, j, prev_mask, cur_mask):\\n            if seats[i][j]==\\'#\\':\\n                return False\\n            for y in [j+1, j-1]:\\n                if 0<=y<len(seats[0]) and (prev_mask&1<<y or cur_mask&1<<y):\\n                    return False\\n            return True\\n        memo = {}\\n        def place(i, j, prev_mask, cur_mask):\\n            key= (i, j, prev_mask, cur_mask) \\n            if key in memo:\\n                return memo[key]\\n            if i==len(seats)-1 and j==len(seats[0]):\\n                return 0\\n            if j==len(seats[0]):\\n                return place(i+1, 0, cur_mask, 0)\\n            max_ = 0  \\n            if can_place(i, j, prev_mask, cur_mask):\\n                max_ = max(1+place(i, j+1, prev_mask, cur_mask|1<<j),max_)\\n            max_ = max(place(i, j+1, prev_mask, cur_mask), max_)\\n            memo[key] = max_\\n            return max_\\n        res = place(0, 0, 0, 0)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        def can_place(i, j):\\n            if seats[i][j]==\\'#\\':\\n                return False\\n            for x, y in [(i, j-1), (i, j+1), (i-1,j+1), (i-1, j-1)]:\\n                if 0<=x<len(seats) and 0<=y<len(seats[0]) and seats[x][y]==\\'S\\':\\n                    return False\\n            return True\\n        def place(i, j, count):\\n            if i==len(seats)-1 and j==len(seats[0]):\\n                place.max = max(place.max, count)\\n                return\\n            if j==len(seats[0]):\\n                place(i+1, 0, count)\\n                return\\n            if can_place(i, j):\\n                seats[i][j] = \\'S\\'\\n                place(i, j+1, count+1)\\n                seats[i][j] = \\'.\\'\\n            place(i, j+1, count)\\n        place.max = 0\\n        place(0, 0, 0)\\n        return place.max\\n```\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        def can_place(i, j, prev_mask, cur_mask):\\n            if seats[i][j]==\\'#\\':\\n                return False\\n            for y in [j+1, j-1]:\\n                if 0<=y<len(seats[0]) and (prev_mask&1<<y or cur_mask&1<<y):\\n                    return False\\n            return True\\n        memo = {}\\n        def place(i, j, prev_mask, cur_mask):\\n            key= (i, j, prev_mask, cur_mask) \\n            if key in memo:\\n                return memo[key]\\n            if i==len(seats)-1 and j==len(seats[0]):\\n                return 0\\n            if j==len(seats[0]):\\n                return place(i+1, 0, cur_mask, 0)\\n            max_ = 0  \\n            if can_place(i, j, prev_mask, cur_mask):\\n                max_ = max(1+place(i, j+1, prev_mask, cur_mask|1<<j),max_)\\n            max_ = max(place(i, j+1, prev_mask, cur_mask), max_)\\n            memo[key] = max_\\n            return max_\\n        res = place(0, 0, 0, 0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460264,
                "title": "c-3ms-dp-with-bitmask-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nstart filling the rows one by one  only thing you need to bother about while filling a row is the arrangement of the previous row filled above it.\\ntrying to fill it completely together as a whole will give you TLE\\ngenerate a bitmask of the prev row seating arrangement\\nand side by side keep tracking the curr row\\'s arrangemnt\\nuse DP for [curr_row,prev arrangement] update and use it only at the start of any row as on the sytarting point curr_mask is 0 for all other cols it can be diff at diff scenarios and can give a wrong result\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDP with Bitmask\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^m x 2^n x m)\\nstates m x 2^m for each state every col of a row is filled or not filled 2^n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m x 2^m)\\n\\n**PLS UPVOTE IF IT HELPED**\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[8][(1<<9)];\\nint dfs(int row,int col,vector<vector<char>>& seats,int pre_mask,int ind_mask){\\n    if(row==seats.size()) return 0;\\n    if(col>=seats[0].size()) return dfs(row+1,0,seats,ind_mask,0);\\n    if(col==0 && dp[row][pre_mask]!=-1) return dp[row][pre_mask];\\n    int m=seats.size();\\n    int n=seats[0].size();\\n    int allocate=0;\\n    int not_allocate=dfs(row,col+1,seats,pre_mask,ind_mask);\\n    bool temp=1;\\n    if(seats[row][col]==\\'#\\') temp=0;\\n    else if(col>0 && row>0 && (pre_mask & (1<<(col-1)))) temp=0;\\n    else if(col<n-1 && row>0 && (pre_mask & (1<<(col+1)))) temp=0;\\n    if(temp) allocate=1+dfs(row,col+2,seats,pre_mask,ind_mask | (1<<col));\\n    int ans=max(allocate,not_allocate);\\n    if(col==0) dp[row][pre_mask]=ans;\\n    return ans;\\n}\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        return dfs(0,0,seats,0,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[8][(1<<9)];\\nint dfs(int row,int col,vector<vector<char>>& seats,int pre_mask,int ind_mask){\\n    if(row==seats.size()) return 0;\\n    if(col>=seats[0].size()) return dfs(row+1,0,seats,ind_mask,0);\\n    if(col==0 && dp[row][pre_mask]!=-1) return dp[row][pre_mask];\\n    int m=seats.size();\\n    int n=seats[0].size();\\n    int allocate=0;\\n    int not_allocate=dfs(row,col+1,seats,pre_mask,ind_mask);\\n    bool temp=1;\\n    if(seats[row][col]==\\'#\\') temp=0;\\n    else if(col>0 && row>0 && (pre_mask & (1<<(col-1)))) temp=0;\\n    else if(col<n-1 && row>0 && (pre_mask & (1<<(col+1)))) temp=0;\\n    if(temp) allocate=1+dfs(row,col+2,seats,pre_mask,ind_mask | (1<<col));\\n    int ans=max(allocate,not_allocate);\\n    if(col==0) dp[row][pre_mask]=ans;\\n    return ans;\\n}\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        return dfs(0,0,seats,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432096,
                "title": "short-solution-with-memoization-in-python-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor every seat, we have two choices: to assign or not to assign a student. To assign a student, the seat should be not broken and no students assigned in its four neighboring seats (i.e., left, right, upper-left, and upper-right). The input size is quite small so we can explore all possible assignments with dynamic programming. The existing assignment of the front row and the current row can be represented in two integers with bit mask. \\nFinally I implement the algorithm with memoization, which is slower but very easy to write and read. \\n\\n\\n# Complexity\\n- Time complexity: $$O(nm2^{m})$$, where $$n$$ is the number of rows and $$m$$ is the size of each row. \\n\\n# Code\\n```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j, front, current):\\n        if j >= self.m:\\n            i += 1\\n            j = 0\\n            front, current = current, 0\\n        if i >= self.n:\\n            return 0\\n        ans = self.dp(i, j + 1, front, current)\\n        if (self.seats[i][j] == \\'.\\' \\n            and (j == 0 or (current & (1 << (j-1)) == 0)) \\n            and (j == 0 or (front & (1 << (j-1)) == 0)) \\n            and (j == self.m - 1 or (front & (1 << (j+1)) == 0))):\\n            ans = max(ans, self.dp(i, j + 2, front, current | (1 << j)) + 1)\\n        return ans\\n        \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        self.seats = seats\\n        self.n, self.m = len(seats), len(seats[0])\\n        return self.dp(0, 0, 0, 0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    @cache\\n    def dp(self, i, j, front, current):\\n        if j >= self.m:\\n            i += 1\\n            j = 0\\n            front, current = current, 0\\n        if i >= self.n:\\n            return 0\\n        ans = self.dp(i, j + 1, front, current)\\n        if (self.seats[i][j] == \\'.\\' \\n            and (j == 0 or (current & (1 << (j-1)) == 0)) \\n            and (j == 0 or (front & (1 << (j-1)) == 0)) \\n            and (j == self.m - 1 or (front & (1 << (j+1)) == 0))):\\n            ans = max(ans, self.dp(i, j + 2, front, current | (1 << j)) + 1)\\n        return ans\\n        \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        self.seats = seats\\n        self.n, self.m = len(seats), len(seats[0])\\n        return self.dp(0, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339810,
                "title": "maximum-students-taking-exam-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private Integer[][] f;\\n    private int n;\\n    private int[] ss;\\n\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length;\\n        n = seats[0].length;\\n        ss = new int[m];\\n        f = new Integer[1 << n][m];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (seats[i][j] == \\'.\\') {\\n                    ss[i] |= 1 << j;\\n                }\\n            }\\n        }\\n        return dfs(ss[0], 0);\\n    }\\n\\n    private int dfs(int seat, int i) {\\n        if (f[seat][i] != null) {\\n            return f[seat][i];\\n        }\\n        int ans = 0;\\n        for (int mask = 0; mask < 1 << n; ++mask) {\\n            if ((seat | mask) != seat || (mask & (mask << 1)) != 0) {\\n                continue;\\n            }\\n            int cnt = Integer.bitCount(mask);\\n            if (i == ss.length - 1) {\\n                ans = Math.max(ans, cnt);\\n            } else {\\n                int nxt = ss[i + 1];\\n                nxt &= ~(mask << 1);\\n                nxt &= ~(mask >> 1);\\n                ans = Math.max(ans, cnt + dfs(nxt, i + 1));\\n            }\\n        }\\n        return f[seat][i] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private Integer[][] f;\\n    private int n;\\n    private int[] ss;\\n\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length;\\n        n = seats[0].length;\\n        ss = new int[m];\\n        f = new Integer[1 << n][m];\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (seats[i][j] == \\'.\\') {\\n                    ss[i] |= 1 << j;\\n                }\\n            }\\n        }\\n        return dfs(ss[0], 0);\\n    }\\n\\n    private int dfs(int seat, int i) {\\n        if (f[seat][i] != null) {\\n            return f[seat][i];\\n        }\\n        int ans = 0;\\n        for (int mask = 0; mask < 1 << n; ++mask) {\\n            if ((seat | mask) != seat || (mask & (mask << 1)) != 0) {\\n                continue;\\n            }\\n            int cnt = Integer.bitCount(mask);\\n            if (i == ss.length - 1) {\\n                ans = Math.max(ans, cnt);\\n            } else {\\n                int nxt = ss[i + 1];\\n                nxt &= ~(mask << 1);\\n                nxt &= ~(mask >> 1);\\n                ans = Math.max(ans, cnt + dfs(nxt, i + 1));\\n            }\\n        }\\n        return f[seat][i] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195029,
                "title": "recursive-bitmask-dp-with-memoization-python",
                "content": "# Intuition\\nThe ```mask``` that has been used in this solution is for a row, mask of a row shows the seats that has a student on them(1 if there is a student on a seat and 0 otherwise)\\n\\nwe are filling rows from last to first(from ```m-1``` to 0). ```dfs(row, index, curr_mask, prev_mask)``` return the number of maximum students to have a seat for rows from number 1 to number```row``` under the condition that the previous row(row with number ```row + 1```) has a mask of ```prev_mask```.\\n\\n# Code\\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef maxStudents(self, seats: List[List[str]]) -> int:\\n\\t\\tm, n = len(seats), len(seats[0])\\n\\t\\tmem = dict()\\n\\n\\t\\tdef dfs(row, index, curr_mask, prev_mask):\\n\\t\\t\\tif row == -1:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tif (row, curr_mask, prev_mask) in mem:\\n\\t\\t\\t\\treturn mem[(row, curr_mask, prev_mask)]\\n\\n\\t\\t\\tif index == n:\\n\\t\\t\\t\\tmem[(row, curr_mask, prev_mask)] = curr_mask.bit_count() + dfs(row - 1, 0, 0, curr_mask)\\n\\t\\t\\t\\treturn mem[(row, curr_mask, prev_mask)]\\n\\n\\t\\t\\tans = dfs(row, index + 1, curr_mask, prev_mask)\\n\\t\\t\\tcurr_mask |= 1 << (n - 1 - index)\\n\\t\\t\\tif (\\n\\t\\t\\t\\t\\tseats[row][index] != \\'#\\' and\\n\\t\\t\\t\\t\\tcurr_mask & prev_mask >> 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & prev_mask << 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & curr_mask >> 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & curr_mask << 1 == 0\\n\\t\\t\\t):\\n\\t\\t\\t\\tans = max(ans, dfs(row, index + 1, curr_mask, prev_mask))\\n\\t\\t\\tcurr_mask ^= 1 << (n - 1 - index)\\n\\t\\t\\tmem[(row, curr_mask, prev_mask)] = ans\\n\\t\\t\\treturn ans\\n\\n\\t\\treturn dfs(m - 1, 0, 0, 0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```mask```\n```m-1```\n```dfs(row, index, curr_mask, prev_mask)```\n```row```\n```row + 1```\n```prev_mask```\n```\\nfrom typing import List\\n\\n\\nclass Solution:\\n\\tdef maxStudents(self, seats: List[List[str]]) -> int:\\n\\t\\tm, n = len(seats), len(seats[0])\\n\\t\\tmem = dict()\\n\\n\\t\\tdef dfs(row, index, curr_mask, prev_mask):\\n\\t\\t\\tif row == -1:\\n\\t\\t\\t\\treturn 0\\n\\n\\t\\t\\tif (row, curr_mask, prev_mask) in mem:\\n\\t\\t\\t\\treturn mem[(row, curr_mask, prev_mask)]\\n\\n\\t\\t\\tif index == n:\\n\\t\\t\\t\\tmem[(row, curr_mask, prev_mask)] = curr_mask.bit_count() + dfs(row - 1, 0, 0, curr_mask)\\n\\t\\t\\t\\treturn mem[(row, curr_mask, prev_mask)]\\n\\n\\t\\t\\tans = dfs(row, index + 1, curr_mask, prev_mask)\\n\\t\\t\\tcurr_mask |= 1 << (n - 1 - index)\\n\\t\\t\\tif (\\n\\t\\t\\t\\t\\tseats[row][index] != \\'#\\' and\\n\\t\\t\\t\\t\\tcurr_mask & prev_mask >> 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & prev_mask << 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & curr_mask >> 1 == 0 and\\n\\t\\t\\t\\t\\tcurr_mask & curr_mask << 1 == 0\\n\\t\\t\\t):\\n\\t\\t\\t\\tans = max(ans, dfs(row, index + 1, curr_mask, prev_mask))\\n\\t\\t\\tcurr_mask ^= 1 << (n - 1 - index)\\n\\t\\t\\tmem[(row, curr_mask, prev_mask)] = ans\\n\\t\\t\\treturn ans\\n\\n\\t\\treturn dfs(m - 1, 0, 0, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3177587,
                "title": "scala-top-down-dp",
                "content": "```Scala\\nimport collection.mutable\\nobject Solution {\\n  def maxStudents(seats: Array[Array[Char]]): Int = {\\n    val bitSeats = seats.map(s => s.foldLeft(0){\\n      case (x, \\'#\\') => x << 1\\n      case (x, \\'.\\') => (x << 1) | 1\\n    })\\n        \\n    def check(row: Int, prev: Int, seat: Int) = {\\n      if ((row | seat) != seat) false\\n      else if ((row & (prev >> 1)) != 0) false\\n      else if ((row & (prev << 1)) != 0) false\\n      else if ((row & (row << 1)) != 0) false\\n      else if ((row & (row >> 1)) != 0) false\\n      else true\\n    }\\n    \\n    def ones(x: Int): Int = if (x == 0) 0 else 1 + ones(x & (x - 1))\\n    \\n    def mem[I, O](f: I => O) = new mutable.HashMap[I, O]() {\\n      override def apply(k: I) = getOrElseUpdate(k, f(k))\\n    }\\n    \\n    lazy val dp: ((Int, Int)) => Int = mem {\\n      case (0, bits) => ones(bits)\\n      case (i, bits) => {\\n        (0 until (1 << seats(0).size)).filter(check(_, bits, bitSeats(i - 1)))\\n          .map(dp(i - 1, _)).max + ones(bits)\\n      }\\n    }\\n    \\n    (0 until (1 << seats(0).size)).filter(check(_, 0, bitSeats.last)).map(dp(seats.size - 1, _)).max\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```Scala\\nimport collection.mutable\\nobject Solution {\\n  def maxStudents(seats: Array[Array[Char]]): Int = {\\n    val bitSeats = seats.map(s => s.foldLeft(0){\\n      case (x, \\'#\\') => x << 1\\n      case (x, \\'.\\') => (x << 1) | 1\\n    })\\n        \\n    def check(row: Int, prev: Int, seat: Int) = {\\n      if ((row | seat) != seat) false\\n      else if ((row & (prev >> 1)) != 0) false\\n      else if ((row & (prev << 1)) != 0) false\\n      else if ((row & (row << 1)) != 0) false\\n      else if ((row & (row >> 1)) != 0) false\\n      else true\\n    }\\n    \\n    def ones(x: Int): Int = if (x == 0) 0 else 1 + ones(x & (x - 1))\\n    \\n    def mem[I, O](f: I => O) = new mutable.HashMap[I, O]() {\\n      override def apply(k: I) = getOrElseUpdate(k, f(k))\\n    }\\n    \\n    lazy val dp: ((Int, Int)) => Int = mem {\\n      case (0, bits) => ones(bits)\\n      case (i, bits) => {\\n        (0 until (1 << seats(0).size)).filter(check(_, bits, bitSeats(i - 1)))\\n          .map(dp(i - 1, _)).max + ones(bits)\\n      }\\n    }\\n    \\n    (0 until (1 << seats(0).size)).filter(check(_, 0, bitSeats.last)).map(dp(seats.size - 1, _)).max\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3100472,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {\\n        let m = seats.len();\\n        let n = seats[0].len();\\n        let mut validity = vec![0; m + 1];\\n        for i in 0..m {\\n            let mut rowvalid = 0;\\n            for j in 0..n {\\n                if seats[i][j] == \\'.\\' {\\n                    rowvalid += 1 << j;\\n                }\\n            }\\n            validity[i + 1] = rowvalid;\\n        }\\n        let mut dp = vec![vec![-1; (1 << n) + 1]; m + 1];\\n        dp[0][0] = 0;\\n        for i in 1..=m {\\n            let valid = validity[i];\\n            for j in 0..(1 << n) {\\n                if (j & valid) != j {\\n                    continue;\\n                }\\n                if (j & (j >> 1)) != 0 {\\n                    continue;\\n                }\\n                for k in 0..(1 << n) {\\n                    if dp[i - 1][k] == -1 {\\n                        continue;\\n                    }\\n                    if (j & (k >> 1)) != 0 || (k & (j >> 1)) != 0 {\\n                        continue;\\n                    }\\n                    dp[i][j] = dp[i][j].max(dp[i - 1][k] + j.count_ones() as i32);\\n                }\\n            }\\n        }\\n        *dp[m].iter().max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {\\n        let m = seats.len();\\n        let n = seats[0].len();\\n        let mut validity = vec![0; m + 1];\\n        for i in 0..m {\\n            let mut rowvalid = 0;\\n            for j in 0..n {\\n                if seats[i][j] == \\'.\\' {\\n                    rowvalid += 1 << j;\\n                }\\n            }\\n            validity[i + 1] = rowvalid;\\n        }\\n        let mut dp = vec![vec![-1; (1 << n) + 1]; m + 1];\\n        dp[0][0] = 0;\\n        for i in 1..=m {\\n            let valid = validity[i];\\n            for j in 0..(1 << n) {\\n                if (j & valid) != j {\\n                    continue;\\n                }\\n                if (j & (j >> 1)) != 0 {\\n                    continue;\\n                }\\n                for k in 0..(1 << n) {\\n                    if dp[i - 1][k] == -1 {\\n                        continue;\\n                    }\\n                    if (j & (k >> 1)) != 0 || (k & (j >> 1)) != 0 {\\n                        continue;\\n                    }\\n                    dp[i][j] = dp[i][j].max(dp[i - 1][k] + j.count_ones() as i32);\\n                }\\n            }\\n        }\\n        *dp[m].iter().max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3012329,
                "title": "evolution-from-normal-backtracking-to-optimized-bitmasking-with-thought-process",
                "content": "# Intuition and initial thoughts\\nSince it was 8x8 grid I thought backtracking was a great idea. Also remember we only need to check to the left, up_left and up_right because we know we have not placed any student on the right at any given point.\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^M*2^N)$$\\n\\n- Space complexity:\\n$$O(M+N)$$ *for recursive stack*\\n\\n# Code (TLE\\'d)\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n,self.max_students = len(seats),len(seats[0]),0\\n        def backtrack(r,c,students):\\n            if r==m:\\n                self.max_students = max(self.max_students,students)\\n                return \\n            \\n            if c==n-1: backtrack(r+1,0,students)\\n            else: backtrack(r,c+1,students)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and seats[r][c-1]==\"*\"\\n                up_left = c>0 and r>0 and seats[r-1][c-1]==\"*\"\\n                up_right = c<n-1 and r>0 and seats[r-1][c+1]==\"*\"\\n                if left or up_left or up_right: return\\n\\n                seats[r][c]=\"*\"\\n                backtrack(r,c,students+1)\\n                seats[r][c]=\".\"\\n\\n        backtrack(0,0,0)\\n        return self.max_students\\n```\\n\\nThe above solution gave me TLE so I realized that converting it to a recurive solution and memoizing the results might be a good idea. But memoizing an 8x8 grid can get expensive. But since its 8x8 we can use bitmasking to replicate the grid in form of bits and memoize the mask.\\n\\nAlso I found a better way to move to the next row. I just increase column every time and whenever column goes out of bounds I increase the row and reset column to 0. \\n# Code (TLE\\'d)\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n = len(seats),len(seats[0])\\n        dp = {}\\n        def dfs(arrangement,r,c):\\n            if c==n:\\n                r+=1\\n                c=0\\n\\n            if r==m: return 0\\n            if (arrangement,r,c) in dp: return dp[(arrangement,r,c)]\\n\\n            seat,not_seat = 0,0\\n            not_seat = dfs(arrangement,r,c+1)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and arrangement&1<<(r*n+c-1)\\n                up_l = c>0 and r>0 and arrangement&1<<((r-1)*n+c-1)\\n                up_r = c<n-1 and r>0 and arrangement&1<<((r-1)*n+c+1)\\n                if not left and not up_l and not up_r: \\n                    arrangement^=1<<(r*n)+c\\n                    seat = 1 + dfs(arrangement,r,c+1)\\n                    arrangement^=1<<(r*n)+c\\n            \\n            dp[(arrangement,r,c)] = max(seat,not_seat)\\n            return dp[(arrangement,r,c)]\\n\\n        return dfs(0,0,0)\\n```\\nSadly the above code TLE\\'d too. When your code usually fails after memoization you are either trying to solve some greedy problem using DP or you are memoizing information more than you need to. In this case it\\'s the later. I realized we dont need to check the entire arrangement to determine if we can place a student. We just need the previous and the current row. After this it was just slight changes to the code.\\n\\nAnd yes I found even better way to switch rows and columns. I visualized all rows to be 1 single long row. So now I can just have a position variable that I increment. For any given position we can find its row and column as shown below\\n![image.png](https://assets.leetcode.com/users/images/10f403ce-e955-4f92-9e6b-14be96b6444c_1673075177.490607.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n = len(seats),len(seats[0])\\n        dp = {}\\n        \\n        def dfs(prev_row,cur_row,pos):\\n            r,c = pos//n,pos%n\\n            if r==m: return 0\\n            if c==0:\\n                prev_row = cur_row\\n                cur_row = 0\\n\\n            if (prev_row,cur_row,pos) in dp: return dp[(prev_row,cur_row,pos)]\\n\\n            seat,not_seat = 0,0\\n            not_seat = dfs(prev_row,cur_row,pos+1)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and cur_row&1<<(c-1)\\n                up_l = c>0 and r>0 and prev_row&1<<(c-1)\\n                up_r = c<n-1 and r>0 and prev_row&1<<(c+1)\\n                if not left and not up_l and not up_r: \\n                    cur_row^=1<<c\\n                    seat = 1 + dfs(prev_row,cur_row,pos+1)\\n                    cur_row^=1<<c\\n            \\n            dp[(prev_row,cur_row,pos)] = max(seat,not_seat)\\n            return dp[(prev_row,cur_row,pos)]\\n\\n        return dfs(0,0,0)\\n\\n```\\n\\n***I hope this was helpful. If it was pls do upvote : )***\\n\\n# Complexity\\n- Time complexity:\\n$$O(M^2*N^2)$$\\n\\n- Space complexity:\\n$$O(M*N)$$ *for DP*\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n,self.max_students = len(seats),len(seats[0]),0\\n        def backtrack(r,c,students):\\n            if r==m:\\n                self.max_students = max(self.max_students,students)\\n                return \\n            \\n            if c==n-1: backtrack(r+1,0,students)\\n            else: backtrack(r,c+1,students)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and seats[r][c-1]==\"*\"\\n                up_left = c>0 and r>0 and seats[r-1][c-1]==\"*\"\\n                up_right = c<n-1 and r>0 and seats[r-1][c+1]==\"*\"\\n                if left or up_left or up_right: return\\n\\n                seats[r][c]=\"*\"\\n                backtrack(r,c,students+1)\\n                seats[r][c]=\".\"\\n\\n        backtrack(0,0,0)\\n        return self.max_students\\n```\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n = len(seats),len(seats[0])\\n        dp = {}\\n        def dfs(arrangement,r,c):\\n            if c==n:\\n                r+=1\\n                c=0\\n\\n            if r==m: return 0\\n            if (arrangement,r,c) in dp: return dp[(arrangement,r,c)]\\n\\n            seat,not_seat = 0,0\\n            not_seat = dfs(arrangement,r,c+1)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and arrangement&1<<(r*n+c-1)\\n                up_l = c>0 and r>0 and arrangement&1<<((r-1)*n+c-1)\\n                up_r = c<n-1 and r>0 and arrangement&1<<((r-1)*n+c+1)\\n                if not left and not up_l and not up_r: \\n                    arrangement^=1<<(r*n)+c\\n                    seat = 1 + dfs(arrangement,r,c+1)\\n                    arrangement^=1<<(r*n)+c\\n            \\n            dp[(arrangement,r,c)] = max(seat,not_seat)\\n            return dp[(arrangement,r,c)]\\n\\n        return dfs(0,0,0)\\n```\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        m,n = len(seats),len(seats[0])\\n        dp = {}\\n        \\n        def dfs(prev_row,cur_row,pos):\\n            r,c = pos//n,pos%n\\n            if r==m: return 0\\n            if c==0:\\n                prev_row = cur_row\\n                cur_row = 0\\n\\n            if (prev_row,cur_row,pos) in dp: return dp[(prev_row,cur_row,pos)]\\n\\n            seat,not_seat = 0,0\\n            not_seat = dfs(prev_row,cur_row,pos+1)\\n\\n            if seats[r][c]==\".\":\\n                left = c>0 and cur_row&1<<(c-1)\\n                up_l = c>0 and r>0 and prev_row&1<<(c-1)\\n                up_r = c<n-1 and r>0 and prev_row&1<<(c+1)\\n                if not left and not up_l and not up_r: \\n                    cur_row^=1<<c\\n                    seat = 1 + dfs(prev_row,cur_row,pos+1)\\n                    cur_row^=1<<c\\n            \\n            dp[(prev_row,cur_row,pos)] = max(seat,not_seat)\\n            return dp[(prev_row,cur_row,pos)]\\n\\n        return dfs(0,0,0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967718,
                "title": "from-o-2-n-m-o-n-2-2m-o-n-m-2-m-1-c-solution",
                "content": "\\n# Code\\n**Approach 1: Storing the state of the whole matrix**\\n```\\nO(2^(n*m))\\n\\nint n, m; \\nunordered_map<long long, int> dp;\\n\\nstring block(int &i, int &j, vector<vector<char>>& seats){\\n    string v = \"\";\\n    if (j<m-1) {\\n        v.push_back(seats[i][j+1]);\\n        seats[i][j+1] = \\'*\\';\\n    }\\n    if (i<n-1){\\n        if (j<m-1) {\\n            v.push_back(seats[i+1][j+1]);\\n            seats[i+1][j+1] = \\'*\\';\\n        }\\n        if (j>0) {\\n            v.push_back(seats[i+1][j-1]);\\n            seats[i+1][j-1] = \\'*\\';\\n        }\\n    }\\n    return v;\\n}\\n\\nvoid unblock(int &i, int &j, vector<vector<char>>& seats, string &v){\\n    int k = 0;\\n    if (j<m-1) {\\n        seats[i][j+1] = v[k++];\\n    }\\n    if (i<n-1){\\n        if (j<m-1) {\\n            seats[i+1][j+1] = v[k++];\\n        }\\n        if (j>0) {\\n            seats[i+1][j-1] = v[k++];\\n        }\\n    }\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, long long mask){\\n    if (j==m) {i++; j=0;};\\n    if (i==n) return 0;\\n    if (dp.count(mask)) return dp[mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\'){\\n        seats[i][j] = \\'*\\';\\n        string state = block(i, j, seats);\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^(1LL<<(i*m+j))));\\n        unblock(i, j, seats, state);\\n        seats[i][j] = \\'.\\';\\n    }\\n    return dp[mask] = max(ans, rec(i, j+1, seats, mask));\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    long long mask = 1LL<<(n*m) - 1;\\n    return rec(0, 0, seats, mask);\\n}\\n```\\n**Approach 2: Storing the state of the last 2 rows**\\n```\\nO(n*2^(2m))\\n\\nint n, m; \\nint dp[8][65537];\\n\\nbool check(int &i, int &j, vector<vector<char>>& seats){\\n    if (i>0 && j>0 && seats[i-1][j-1]==\\'*\\') return false;\\n    if (i>0 && j<m-1 && seats[i-1][j+1]==\\'*\\') return false;\\n    if (j>0 && seats[i][j-1]==\\'*\\') return false;\\n    if (j<m-1 && seats[i][j+1]==\\'*\\') return false;\\n    return true;\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, int mask){\\n    if (j==m) {i++; j=0; mask%=(1<<m); mask<<=m; mask^=(1<<m)-1;};\\n    if (i==n) return 0;\\n    if (dp[i][mask] != -1) return dp[i][mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\' && check(i, j, seats)){\\n        seats[i][j] = \\'*\\';\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^(1<<j)));\\n        seats[i][j] = \\'.\\';\\n    }\\n    ans = max(ans, rec(i, j+1, seats, mask));\\n    return dp[i][mask] = ans;\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    int mask = 1<<(2*m) - 1;\\n    for (int i=0; i<n; i++){\\n        for (int j=0; j<2*mask; j++){\\n            dp[i][j] = -1;\\n        }\\n    }\\n    return rec(0, 0, seats, mask);\\n}\\n```\\n**Approach 3: Storing the state of the last m+2 characters**\\n```\\nO(n*m*2^m)\\n\\nint n, m, Max; \\nint dp[8][8][1025];\\n\\nbool check(int &i, int &j, vector<vector<char>>& seats){\\n    if (i>0 && j>0 && seats[i-1][j-1]==\\'*\\') return false;\\n    if (i>0 && j<m-1 && seats[i-1][j+1]==\\'*\\') return false;\\n    if (j>0 && seats[i][j-1]==\\'*\\') return false;\\n    if (j<m-1 && seats[i][j+1]==\\'*\\') return false;\\n    return true;\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, int mask){\\n    if (j == m) {i++; j=0;};\\n    if (i == n) return 0;\\n    mask <<= 1; mask %= Max; mask |= 1;\\n    if (dp[i][j][mask] != -1) return dp[i][j][mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\' && check(i, j, seats)){\\n        seats[i][j] = \\'*\\';\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^1));\\n        seats[i][j] = \\'.\\';\\n    }\\n    ans = max(ans, rec(i, j+1, seats, mask));\\n    return dp[i][j][mask] = ans;\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    Max = 1<<(m+2);\\n    for (int i=0; i<n; i++){\\n        for (int j=0; j<m; j++){\\n            for (int k=0; k<Max; k++){\\n                dp[i][j][k] = -1;\\n            }\\n        }\\n    }\\n    return rec(0, 0, seats, Max-1);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nO(2^(n*m))\\n\\nint n, m; \\nunordered_map<long long, int> dp;\\n\\nstring block(int &i, int &j, vector<vector<char>>& seats){\\n    string v = \"\";\\n    if (j<m-1) {\\n        v.push_back(seats[i][j+1]);\\n        seats[i][j+1] = \\'*\\';\\n    }\\n    if (i<n-1){\\n        if (j<m-1) {\\n            v.push_back(seats[i+1][j+1]);\\n            seats[i+1][j+1] = \\'*\\';\\n        }\\n        if (j>0) {\\n            v.push_back(seats[i+1][j-1]);\\n            seats[i+1][j-1] = \\'*\\';\\n        }\\n    }\\n    return v;\\n}\\n\\nvoid unblock(int &i, int &j, vector<vector<char>>& seats, string &v){\\n    int k = 0;\\n    if (j<m-1) {\\n        seats[i][j+1] = v[k++];\\n    }\\n    if (i<n-1){\\n        if (j<m-1) {\\n            seats[i+1][j+1] = v[k++];\\n        }\\n        if (j>0) {\\n            seats[i+1][j-1] = v[k++];\\n        }\\n    }\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, long long mask){\\n    if (j==m) {i++; j=0;};\\n    if (i==n) return 0;\\n    if (dp.count(mask)) return dp[mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\'){\\n        seats[i][j] = \\'*\\';\\n        string state = block(i, j, seats);\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^(1LL<<(i*m+j))));\\n        unblock(i, j, seats, state);\\n        seats[i][j] = \\'.\\';\\n    }\\n    return dp[mask] = max(ans, rec(i, j+1, seats, mask));\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    long long mask = 1LL<<(n*m) - 1;\\n    return rec(0, 0, seats, mask);\\n}\\n```\n```\\nO(n*2^(2m))\\n\\nint n, m; \\nint dp[8][65537];\\n\\nbool check(int &i, int &j, vector<vector<char>>& seats){\\n    if (i>0 && j>0 && seats[i-1][j-1]==\\'*\\') return false;\\n    if (i>0 && j<m-1 && seats[i-1][j+1]==\\'*\\') return false;\\n    if (j>0 && seats[i][j-1]==\\'*\\') return false;\\n    if (j<m-1 && seats[i][j+1]==\\'*\\') return false;\\n    return true;\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, int mask){\\n    if (j==m) {i++; j=0; mask%=(1<<m); mask<<=m; mask^=(1<<m)-1;};\\n    if (i==n) return 0;\\n    if (dp[i][mask] != -1) return dp[i][mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\' && check(i, j, seats)){\\n        seats[i][j] = \\'*\\';\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^(1<<j)));\\n        seats[i][j] = \\'.\\';\\n    }\\n    ans = max(ans, rec(i, j+1, seats, mask));\\n    return dp[i][mask] = ans;\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    int mask = 1<<(2*m) - 1;\\n    for (int i=0; i<n; i++){\\n        for (int j=0; j<2*mask; j++){\\n            dp[i][j] = -1;\\n        }\\n    }\\n    return rec(0, 0, seats, mask);\\n}\\n```\n```\\nO(n*m*2^m)\\n\\nint n, m, Max; \\nint dp[8][8][1025];\\n\\nbool check(int &i, int &j, vector<vector<char>>& seats){\\n    if (i>0 && j>0 && seats[i-1][j-1]==\\'*\\') return false;\\n    if (i>0 && j<m-1 && seats[i-1][j+1]==\\'*\\') return false;\\n    if (j>0 && seats[i][j-1]==\\'*\\') return false;\\n    if (j<m-1 && seats[i][j+1]==\\'*\\') return false;\\n    return true;\\n}\\n\\nint rec(int i, int j, vector<vector<char>>& seats, int mask){\\n    if (j == m) {i++; j=0;};\\n    if (i == n) return 0;\\n    mask <<= 1; mask %= Max; mask |= 1;\\n    if (dp[i][j][mask] != -1) return dp[i][j][mask];\\n\\n    int ans = 0;\\n    if (seats[i][j] == \\'.\\' && check(i, j, seats)){\\n        seats[i][j] = \\'*\\';\\n        ans = max(ans, 1 + rec(i, j+1, seats, mask^1));\\n        seats[i][j] = \\'.\\';\\n    }\\n    ans = max(ans, rec(i, j+1, seats, mask));\\n    return dp[i][j][mask] = ans;\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n    n = seats.size();\\n    m = seats[0].size();\\n    Max = 1<<(m+2);\\n    for (int i=0; i<n; i++){\\n        for (int j=0; j<m; j++){\\n            for (int k=0; k<Max; k++){\\n                dp[i][j][k] = -1;\\n            }\\n        }\\n    }\\n    return rec(0, 0, seats, Max-1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869195,
                "title": "c-very-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[9][1024];\\n    bool check(int c,int prevmask){\\n        if(c == 0){\\n            if(prevmask&(1<<(c+1)))\\n                return false;\\n        }\\n        else if(c == m-1){\\n            if(prevmask&(1<<(c-1)))\\n                return false;\\n        }\\n        else{\\n            if(prevmask&(1<<(c-1)) || prevmask&(1<<(c+1)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    int solve(int r,int c,int prevmask,int mask,vector<vector<char>>&st){\\n        if(r >= n) return 0;\\n        if(c == m){\\n            return solve(r+1,0,mask,0,st);\\n        }\\n        if(c ==0 && dp[r][prevmask]!=-1) \\n            return dp[r][prevmask];\\n        int ans=0;\\n        if(st[r][c] ==\\'.\\' && check(c,prevmask)){\\n            if(c == 0){\\n                ans = 1+solve(r,c+1,prevmask,mask|(1<<(c)),st);\\n            }\\n            else if(!(mask&(1<<(c-1)))){\\n                ans = 1+solve(r,c+1,prevmask,mask|(1<<(c)),st);\\n            }\\n        }\\n        ans=max(ans , solve(r,c+1,prevmask,mask,st));\\n        return dp[r][prevmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& st) {\\n        n = st.size();\\n        m = st[0].size();\\n        memset(dp ,-1,sizeof dp);\\n        return solve(0,0,0,0,st);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    int dp[9][1024];\\n    bool check(int c,int prevmask){\\n        if(c == 0){\\n            if(prevmask&(1<<(c+1)))\\n                return false;\\n        }\\n        else if(c == m-1){\\n            if(prevmask&(1<<(c-1)))\\n                return false;\\n        }\\n        else{\\n            if(prevmask&(1<<(c-1)) || prevmask&(1<<(c+1)))\\n                return false;\\n        }\\n        return true;\\n    }\\n    int solve(int r,int c,int prevmask,int mask,vector<vector<char>>&st){\\n        if(r >= n) return 0;\\n        if(c == m){\\n            return solve(r+1,0,mask,0,st);\\n        }\\n        if(c ==0 && dp[r][prevmask]!=-1) \\n            return dp[r][prevmask];\\n        int ans=0;\\n        if(st[r][c] ==\\'.\\' && check(c,prevmask)){\\n            if(c == 0){\\n                ans = 1+solve(r,c+1,prevmask,mask|(1<<(c)),st);\\n            }\\n            else if(!(mask&(1<<(c-1)))){\\n                ans = 1+solve(r,c+1,prevmask,mask|(1<<(c)),st);\\n            }\\n        }\\n        ans=max(ans , solve(r,c+1,prevmask,mask,st));\\n        return dp[r][prevmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& st) {\\n        n = st.size();\\n        m = st[0].size();\\n        memset(dp ,-1,sizeof dp);\\n        return solve(0,0,0,0,st);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854502,
                "title": "swift-version-of-most-voted-answer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhttps://leetcode.com/problems/maximum-students-taking-exam/solutions/503686/a-simple-tutorial-on-this-bitmasking-problem/\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m * 4^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m * 2^n)\\n\\n# Code\\n```\\nclass Solution {\\n    func maxStudents(_ seats: [[Character]]) -> Int {\\n        let m = seats.count\\n        let n = seats[0].count\\n\\n        var validRows: [Int] = .init(repeating: 0, count: m)\\n\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                validRows[i] = (validRows[i] << 1) + (seats[i][j] == \".\" ? 1 : 0)\\n            }\\n        }\\n\\n        var stateSize = 1 << n\\n        var dp: [[Int]] = .init(repeating: .init(repeating: -1, count: stateSize), count: m)\\n\\n        var ans = 0\\n\\n        for i in 0..<m {\\n            for j in 0..<stateSize {\\n                if (((j & validRows[i]) == j) && ((j & (j >> 1)) == 0)) {\\n                    if (i == 0) {\\n                        dp[i][j] = j.nonzeroBitCount\\n                    } else {\\n                        for k in 0..<stateSize {\\n                            if ((j & (k >> 1)) == 0 && ((j >> 1) & k) == 0 && dp[i-1][k] != -1)  {\\n                                dp[i][j] = max(dp[i][j], dp[i-1][k] + j.nonzeroBitCount);\\n                            }\\n                        }\\n                    }\\n                     ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func maxStudents(_ seats: [[Character]]) -> Int {\\n        let m = seats.count\\n        let n = seats[0].count\\n\\n        var validRows: [Int] = .init(repeating: 0, count: m)\\n\\n        for i in 0..<m {\\n            for j in 0..<n {\\n                validRows[i] = (validRows[i] << 1) + (seats[i][j] == \".\" ? 1 : 0)\\n            }\\n        }\\n\\n        var stateSize = 1 << n\\n        var dp: [[Int]] = .init(repeating: .init(repeating: -1, count: stateSize), count: m)\\n\\n        var ans = 0\\n\\n        for i in 0..<m {\\n            for j in 0..<stateSize {\\n                if (((j & validRows[i]) == j) && ((j & (j >> 1)) == 0)) {\\n                    if (i == 0) {\\n                        dp[i][j] = j.nonzeroBitCount\\n                    } else {\\n                        for k in 0..<stateSize {\\n                            if ((j & (k >> 1)) == 0 && ((j >> 1) & k) == 0 && dp[i-1][k] != -1)  {\\n                                dp[i][j] = max(dp[i][j], dp[i-1][k] + j.nonzeroBitCount);\\n                            }\\n                        }\\n                    }\\n                     ans = max(ans, dp[i][j]);\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853098,
                "title": "pure-functional-dynamic-programming-in-scala",
                "content": "# Intuition\\nDynamic Programming with generating the absolute minimum states (see comments in the code).\\n\\n## Time complexity:\\nWorst case: $$O(m.2^{2n})$$\\nThis is the worst case. \\n\\nIf available seats are sparse, the time complexity will be a lot better, since we are only generating permissible permutations (and not all $$2^n$$ permutations for each row). For instance, if a row\\'s binary represenation is $$01101$$ instead of $$2^5 = 32$$ permutations, we only generate the $$6$$ permissible ones, namely\\n\\n$$00000$$, $$01000$$, $$01001$$, $$00100$$, $$00101$$, $$00001$$\\n\\n\\n## Space complexity:\\n$$O(2^n)$$ \\nNote that there is no need to tabulate the whole dp array. All we need is the current row and the last row, therefore at any given moment, only the set of all permissible permutations of the current row, and the last row is in memory.\\n\\n# Code\\n```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n\\n  /* Represents a single row pattern with its max possible capacity*/\\n  private final case class Choice(pat: Int, cap: Int)\\n\\n  @inline private def unsetLSB(n: Int) = n & (n-1)\\n  \\n  /* Hamming weight or number of 1\\'s in binary rep of n */\\n  @inline private def hw(n: Int) = \\n    Iterator.iterate(n)(unsetLSB).takeWhile(_ != 0).size\\n  \\n  /* True if r allows cheating in the same row, false otherwise */\\n  @inline private def ok(r: Int) = \\n    ((r & (r << 1)) | (r & (r >> 1))) == 0\\n\\n  /* Given a row n, returns all possible and permissible \\n     permutations of students sitting in this row. \\n     Generates the absolute minimum number of permutations \\n     per row, therefore optimising space and time on average */\\n  @tailrec private def perms(n: Int, acc: List[Int] = List(0)): List[Int] = \\n    if (n==0) acc \\n    else {\\n      val lsb = n & -n\\n      perms(unsetLSB(n), acc ++ acc.iterator.map(_ | lsb).filter(ok).toList)\\n    }\\n  \\n  /* True if the given choice c does not allow any cheating in \\n     the row r that is right behind c */  \\n  @inline private def okWith(r: Int)(c: Choice) = \\n    ((c.pat & (r << 1)) | (c.pat & (r >> 1))) == 0\\n\\n  /* Heart of the solution:\\n   * choices is all possible choices for the row right in front of\\n   * us at any given moment.\\n   * pat is a candidate pattern for the current row\\n   * Returns the best possible choice by iterating over all choices and\\n   * adding the capacity of pat with the best compatible choice from the\\n   * choices row (row in front of us). */\\n  private def gen(choices: List[Choice])(pat: Int) =\\n    Choice(pat, hw(pat) + choices.iterator.filter(okWith(pat)).map(_.cap).max)\\n  \\n  /* Dynamic programming solver. Just lego-ing everything together \\n     Initial state is Choice(0, 0) which can be considered as an empty row \\n     in the very front of the class. */\\n  private def maxPossible(rows: Iterator[Int]) =\\n    rows\\n      .map(perms(_))\\n      .foldLeft(List(Choice(0, 0))){ (state, perms) => perms.map(gen(state)) }\\n      .iterator\\n      .map(_.cap)\\n      .max\\n    \\n  /* char => bit: 1 = available, 0 = broken */\\n  @inline private def toBit(seat: Char) = \\n    if (seat == \\'.\\') 1 else 0\\n\\n  /* row => binary: 1\\'s denote available seats */\\n  @inline private def toBinary(bits: Array[Char]) = \\n    bits.iterator.map(toBit).reduce { (acc, b) => (acc << 1) + b }\\n\\n  /* main function */\\n  def maxStudents(seats: Array[Array[Char]]) =\\n    maxPossible(seats.iterator.map(toBinary))  \\n\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nimport scala.annotation.tailrec\\n\\nobject Solution {\\n\\n  /* Represents a single row pattern with its max possible capacity*/\\n  private final case class Choice(pat: Int, cap: Int)\\n\\n  @inline private def unsetLSB(n: Int) = n & (n-1)\\n  \\n  /* Hamming weight or number of 1\\'s in binary rep of n */\\n  @inline private def hw(n: Int) = \\n    Iterator.iterate(n)(unsetLSB).takeWhile(_ != 0).size\\n  \\n  /* True if r allows cheating in the same row, false otherwise */\\n  @inline private def ok(r: Int) = \\n    ((r & (r << 1)) | (r & (r >> 1))) == 0\\n\\n  /* Given a row n, returns all possible and permissible \\n     permutations of students sitting in this row. \\n     Generates the absolute minimum number of permutations \\n     per row, therefore optimising space and time on average */\\n  @tailrec private def perms(n: Int, acc: List[Int] = List(0)): List[Int] = \\n    if (n==0) acc \\n    else {\\n      val lsb = n & -n\\n      perms(unsetLSB(n), acc ++ acc.iterator.map(_ | lsb).filter(ok).toList)\\n    }\\n  \\n  /* True if the given choice c does not allow any cheating in \\n     the row r that is right behind c */  \\n  @inline private def okWith(r: Int)(c: Choice) = \\n    ((c.pat & (r << 1)) | (c.pat & (r >> 1))) == 0\\n\\n  /* Heart of the solution:\\n   * choices is all possible choices for the row right in front of\\n   * us at any given moment.\\n   * pat is a candidate pattern for the current row\\n   * Returns the best possible choice by iterating over all choices and\\n   * adding the capacity of pat with the best compatible choice from the\\n   * choices row (row in front of us). */\\n  private def gen(choices: List[Choice])(pat: Int) =\\n    Choice(pat, hw(pat) + choices.iterator.filter(okWith(pat)).map(_.cap).max)\\n  \\n  /* Dynamic programming solver. Just lego-ing everything together \\n     Initial state is Choice(0, 0) which can be considered as an empty row \\n     in the very front of the class. */\\n  private def maxPossible(rows: Iterator[Int]) =\\n    rows\\n      .map(perms(_))\\n      .foldLeft(List(Choice(0, 0))){ (state, perms) => perms.map(gen(state)) }\\n      .iterator\\n      .map(_.cap)\\n      .max\\n    \\n  /* char => bit: 1 = available, 0 = broken */\\n  @inline private def toBit(seat: Char) = \\n    if (seat == \\'.\\') 1 else 0\\n\\n  /* row => binary: 1\\'s denote available seats */\\n  @inline private def toBinary(bits: Array[Char]) = \\n    bits.iterator.map(toBit).reduce { (acc, b) => (acc << 1) + b }\\n\\n  /* main function */\\n  def maxStudents(seats: Array[Array[Char]]) =\\n    maxPossible(seats.iterator.map(toBinary))  \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2746680,
                "title": "easy-to-understand-memoized-bit-mask-dp-solution-with-2-states",
                "content": "\\n\\tclass Solution {\\n\\t\\n\\tpublic:\\n    \\n    int dp[9][1<<9+5];\\n    \\n    int rec(int idx, int mask, vector<vector<char>>& seats)\\n    {\\n        // if all the rows has been processed \\n        if(idx==seats.size())\\n        {\\n            return 0;\\n        }\\n        // if the state is alredy calculated then don\\'t calculate it\\n        if(dp[idx][mask]!=-1)\\n        {\\n            return dp[idx][mask];\\n        }\\n        int ans=0;\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        //generating all the subsets\\n        for(int i=0;i<(1<<m);i++)\\n        {\\n            int flg=0;\\n            // checking for all the entry in a subset \\n            for(int j=0;j<m;j++)\\n            {\\n                if(i&(1<<j))\\n                {\\n                    if(seats[idx][j]==\\'#\\')\\n                        flg=1;\\n                    if(j>0&&(i&(1<<(j-1))))\\n                       flg=1;\\n                    if(j<m-1&&(i&(1<<(j+1))))\\n                       flg=1;\\n                    if(j>0&&(mask&(1<<(j-1))))\\n                       flg=1;\\n                    if(j<m-1&&(mask&(1<<(j+1))))\\n                       flg=1;\\n                     \\n                }\\n            }\\n            if(flg)\\n                continue;\\n            ans=max(rec(idx+1,i,seats)+__builtin_popcount(i),ans);\\n            \\n        }\\n        \\n        dp[idx][mask]=ans;\\n        return ans;\\n                    \\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        return rec(0,0,seats);\\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Bitmask"
                ],
                "code": "class Solution {\\n\\t\\n\\tpublic:\\n    \\n    int dp[9][1<<9+5];\\n    \\n    int rec(int idx, int mask, vector<vector<char>>& seats)\\n    {\\n        // if all the rows has been processed \\n        if(idx==seats.size())\\n        {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2668744,
                "title": "c-bit-masking-dp-memoization-detailed-explanation",
                "content": "EXPLANATION:\\nWHY WE CANT USE BRUTE FORCE:\\nAt First This Question Seems Simple BackTracking Problem where we can simply make two choices for each place either to make a student sit at particular position (x,y) or not(with the given constraints) and at the end compile the results obtained in every iteration and compute mas possible answer.\\nBut THIS APPROACH  exceeds the time limit since we have at max 64 max position possible and if we make 2 choices for each position then Worst Time complexity woiuld be 2^64 which is more then 2^20(which can be processed in one cycle).\\nSOLUTION EXPLANATION:\\nIf we try to Memoize the above approach the constraint we would have faced that the table(demonstraiting the current arrangement when we have made certains students sit)is continuously changing along with cords X and Y.So We Require something else to do.\\nRATHER then dealing with single single cordinate I thought to deal with the complete row at once.\\nSTEPS:\\n1.First Generate all the possible Arrangements we can Make in a row keeping in mind the constraints of the (i-1)th row (that if we can place the child at pos (x,y)only if we do not have element place at (x-1,y-1),(x-1,y+1);\\n2.Since if we do the above step row wise it would have been cumbersome since we need to have checked multiple positions in the prev+current row we are processing.So we took the Transpose of the matrix and now i need to check for the prev row only and not the current row.\\n3.We USED BIT-MASKING to Store the previous row arrangement.\\n4.WE GENERATE ALL THE POSSIBLE ARRANGEMENTS WE COULD HAVE FOR THE CURRENT ROW. AND CHECK WHICH ARRANGEMENT IS POSSIBLE AND RECURSIVELY SOLVE FOR THE REST OF THE ROWS.\\n5.AMONG ALL THE POSSIBLE ARRANGEMENTS GET THE ONE FETHCING YOU THE MAX ANS. \\n```\\nclass Solution {\\npublic:\\n    int rows=0;\\n    int cols=0;\\n   //To Check If The Arragement you are looking for is Possible or Not With the Previous Row arrangement given\\n   /*\\n   posmask=Possible Mask for Current Row\\n   currmask=This Mask is Generated for the current row.This Mask Mark Those Bit as One where the chair are broken and we cannot make the child sit.\\n   mask=This Is previous row mask.This Shows where all the children are sitted in the previous row\\n   **Important** 0 in a mask shows children is present on the seat ,1 shows either the broken chair or no one is sitting.\\n   row=currnt row number.\\n   */\\n    bool PossibleMask(int posMask,int currmask,int mask,int row){\\n        if((posMask & currmask)!=currmask)return false;\\n        //1 means noOne is there while 0 means someone is seated there....\\n      \\n        for(int i=0;i<cols;i++){//possible mask positions\\n            if((i==cols-1||(mask&(1<<(i+1)))!=0) and (i==0||(mask&(1<<(i-1)))!=0) and ((mask&(1<<i))!=0))\\n                continue;\\n             else{//if at the concerned positions the bit is present then check wether at the respective position in the possible mask wether the element is present or not\\n                 if((posMask&(1<<i))==0)\\n                     return false;//Since at the position also someone was present;                 \\n             }\\n                \\n         }\\n        return true;       \\n    }\\n  \\n    int solve(vector<vector<char>>&seats,int row,int mask,vector<vector<int>>&dp){\\n        //We are Done processing all the Rows.\\n\\t\\tif(row>=rows)return 0;\\n        int ans=0;\\n        int currmask=0;\\n        if(dp[mask][row]!=-1)return dp[mask][row];\\n\\t\\t//Current Mask shows which all seats in the current row are broken.\\n        for(int col=0;col<seats[row].size();col++)\\n            if(seats[row][col]==\\'#\\')\\n                currmask|=(1<<col);   \\n    \\n        //GENERATE ALL THE POSSIBLE SUBSET ie All the Possible Arrangements in the current Row\\n        for(int posMask=0;posMask<=(1<<seats[row].size());posMask++){\\n \\n        //CHECK IF THE MASK GENEREATED IS POSSIBLE OR NOT\\n        if(PossibleMask(posMask,currmask,mask,row))\\n        ans=max(ans,(cols-(__builtin_popcount(posMask)))+solve(seats,row+1,posMask,dp));\\n        //(cols-(__builtint_popcount()) gives the number of student sitting in the current row .*0 shows that a student in sitting at a particular index.while 1 mark the broken chair or no one is sitting.\\n        }\\n       \\n        return dp[mask][row]=ans;    \\n        \\n    }\\n    int maxStudents(vector<vector<char>>& arrangement){\\n        //CHANGE THE ROWS TO COLUMNS AND COLUMNS TO ROWS.\\n        rows=arrangement.size();\\n        cols=arrangement[0].size();\\n        vector<vector<char>>seats(cols,vector<char>(rows));\\n         \\n        //Transpose is taken because ..if we would have not taken that in that case we need to have cheched the current row arrangement (for (x,y) ->(x,y-1) and (x,y+1) position also) but since we have taken the transpose so while processing the rows we have to check only the previous rows cords.\\n        int col=0;\\n        for(auto vec:arrangement){\\n            for(int i=0;i<vec.size();i++)\\n                seats[i][col]=vec[i];\\n            col++;\\n        }\\n        rows=seats.size();\\n        cols=seats[0].size();\\n      \\n        for(auto vec:seats){\\n            for(auto x:vec)\\n                cout<<x<<\" \";\\n        cout<<endl;}\\n        \\n        \\n        vector<vector<int>>dp(1024,vector<int>(10,-1));\\n        int mask=0;\\n        for(int i=0;i<cols;i++)\\n            mask|=(1<<i);\\n        \\n        return solve(seats,0,mask,dp);\\n       \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int rows=0;\\n    int cols=0;\\n   //To Check If The Arragement you are looking for is Possible or Not With the Previous Row arrangement given\\n   /*\\n   posmask=Possible Mask for Current Row\\n   currmask=This Mask is Generated for the current row.This Mask Mark Those Bit as One where the chair are broken and we cannot make the child sit.\\n   mask=This Is previous row mask.This Shows where all the children are sitted in the previous row\\n   **Important** 0 in a mask shows children is present on the seat ,1 shows either the broken chair or no one is sitting.\\n   row=currnt row number.\\n   */\\n    bool PossibleMask(int posMask,int currmask,int mask,int row){\\n        if((posMask & currmask)!=currmask)return false;\\n        //1 means noOne is there while 0 means someone is seated there....\\n      \\n        for(int i=0;i<cols;i++){//possible mask positions\\n            if((i==cols-1||(mask&(1<<(i+1)))!=0) and (i==0||(mask&(1<<(i-1)))!=0) and ((mask&(1<<i))!=0))\\n                continue;\\n             else{//if at the concerned positions the bit is present then check wether at the respective position in the possible mask wether the element is present or not\\n                 if((posMask&(1<<i))==0)\\n                     return false;//Since at the position also someone was present;                 \\n             }\\n                \\n         }\\n        return true;       \\n    }\\n  \\n    int solve(vector<vector<char>>&seats,int row,int mask,vector<vector<int>>&dp){\\n        //We are Done processing all the Rows.\\n\\t\\tif(row>=rows)return 0;\\n        int ans=0;\\n        int currmask=0;\\n        if(dp[mask][row]!=-1)return dp[mask][row];\\n\\t\\t//Current Mask shows which all seats in the current row are broken.\\n        for(int col=0;col<seats[row].size();col++)\\n            if(seats[row][col]==\\'#\\')\\n                currmask|=(1<<col);   \\n    \\n        //GENERATE ALL THE POSSIBLE SUBSET ie All the Possible Arrangements in the current Row\\n        for(int posMask=0;posMask<=(1<<seats[row].size());posMask++){\\n \\n        //CHECK IF THE MASK GENEREATED IS POSSIBLE OR NOT\\n        if(PossibleMask(posMask,currmask,mask,row))\\n        ans=max(ans,(cols-(__builtin_popcount(posMask)))+solve(seats,row+1,posMask,dp));\\n        //(cols-(__builtint_popcount()) gives the number of student sitting in the current row .*0 shows that a student in sitting at a particular index.while 1 mark the broken chair or no one is sitting.\\n        }\\n       \\n        return dp[mask][row]=ans;    \\n        \\n    }\\n    int maxStudents(vector<vector<char>>& arrangement){\\n        //CHANGE THE ROWS TO COLUMNS AND COLUMNS TO ROWS.\\n        rows=arrangement.size();\\n        cols=arrangement[0].size();\\n        vector<vector<char>>seats(cols,vector<char>(rows));\\n         \\n        //Transpose is taken because ..if we would have not taken that in that case we need to have cheched the current row arrangement (for (x,y) ->(x,y-1) and (x,y+1) position also) but since we have taken the transpose so while processing the rows we have to check only the previous rows cords.\\n        int col=0;\\n        for(auto vec:arrangement){\\n            for(int i=0;i<vec.size();i++)\\n                seats[i][col]=vec[i];\\n            col++;\\n        }\\n        rows=seats.size();\\n        cols=seats[0].size();\\n      \\n        for(auto vec:seats){\\n            for(auto x:vec)\\n                cout<<x<<\" \";\\n        cout<<endl;}\\n        \\n        \\n        vector<vector<int>>dp(1024,vector<int>(10,-1));\\n        int mask=0;\\n        for(int i=0;i<cols;i++)\\n            mask|=(1<<i);\\n        \\n        return solve(seats,0,mask,dp);\\n       \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2652802,
                "title": "python-solution-dp-from-top-to-down",
                "content": "```\\nclass Solution:\\n    # 1 <= m <= 8, 1 <= n <= 8\\n    # Also, because a student at row i can only cheat on student one row ahead or on the same row, so this problem should be solved by DPing from top to bottom\\n    # Also, a free spot can be either occupied or not, a bitmask would be useful to represent states\\n    # dp[i] = maximum number of students that can take the exam together without any cheating being possible seats[:i] are to be seated\\n    # We want to get dp[m-1]\\n    # dp[i] = max(dp(i, state): state = all possible combinations of available seats for seats[i] are either occupied or not occupied\\n    # dp(i, state) = dp(i-1, state in which the four corners are not occupied)\\n    # There is a catch when we consider contributions from the same row (left and right), because we might be asking for dp(i, state\\') which has not been calculated\\n    # But this is irrelevant because neighbouring even and odd columns cannot be occupied together. We just check the states to remove states like 3 = \"00000011\".\\n    \\n    def valid_states(self, row, n):\\n        states = []\\n        for state in range(1<<n):\\n            # Check of consecutive occupation\\n            if \"11\" not in bin(state)[2:]:\\n                okay = True\\n                for i in range(n):\\n                    # if I want to seat a student, it must be free seat\\n                    if state & (1 << i) != 0:\\n                        okay &= (self.seats[row][i] == \".\")\\n                if okay:\\n                    states.append(state)                        \\n        return states\\n    \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n, dp, self.seats = len(seats), len(seats[0]), {}, seats\\n        for i in range(m):\\n            # For each row, first get the candidate states\\n            candidates, dp_new = self.valid_states(i, n), {}\\n            for candidate in candidates:\\n                student_this_row = bin(candidate)[2:].count(\"1\")\\n                if i == 0:\\n                    # No previous row limitation\\n                    dp_new[candidate] = student_this_row\\n                else:\\n                    last_states = list(dp.keys())\\n                    for last in last_states:\\n                        # Check for all the columns, see for each occupied seat has no cheating opportunities on upper left and upper right\\n                        for j in range(n):\\n                            no_cheat = True\\n                            if candidate & (1<<j) != 0 and j > 0:\\n                                no_cheat &= (last&(1<<(j-1))==0)\\n                            if candidate & (1<<j) != 0 and j < n-1:\\n                                no_cheat &= (last&(1<<(j+1))==0)\\n                            if not no_cheat:\\n                                break\\n                        if no_cheat:\\n                            dp_new[candidate] = max(dp_new.get(candidate, 0), student_this_row + dp[last])\\n            dp = dp_new.copy()\\n        return max(dp.values())\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 1 <= m <= 8, 1 <= n <= 8\\n    # Also, because a student at row i can only cheat on student one row ahead or on the same row, so this problem should be solved by DPing from top to bottom\\n    # Also, a free spot can be either occupied or not, a bitmask would be useful to represent states\\n    # dp[i] = maximum number of students that can take the exam together without any cheating being possible seats[:i] are to be seated\\n    # We want to get dp[m-1]\\n    # dp[i] = max(dp(i, state): state = all possible combinations of available seats for seats[i] are either occupied or not occupied\\n    # dp(i, state) = dp(i-1, state in which the four corners are not occupied)\\n    # There is a catch when we consider contributions from the same row (left and right), because we might be asking for dp(i, state\\') which has not been calculated\\n    # But this is irrelevant because neighbouring even and odd columns cannot be occupied together. We just check the states to remove states like 3 = \"00000011\".\\n    \\n    def valid_states(self, row, n):\\n        states = []\\n        for state in range(1<<n):\\n            # Check of consecutive occupation\\n            if \"11\" not in bin(state)[2:]:\\n                okay = True\\n                for i in range(n):\\n                    # if I want to seat a student, it must be free seat\\n                    if state & (1 << i) != 0:\\n                        okay &= (self.seats[row][i] == \".\")\\n                if okay:\\n                    states.append(state)                        \\n        return states\\n    \\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n, dp, self.seats = len(seats), len(seats[0]), {}, seats\\n        for i in range(m):\\n            # For each row, first get the candidate states\\n            candidates, dp_new = self.valid_states(i, n), {}\\n            for candidate in candidates:\\n                student_this_row = bin(candidate)[2:].count(\"1\")\\n                if i == 0:\\n                    # No previous row limitation\\n                    dp_new[candidate] = student_this_row\\n                else:\\n                    last_states = list(dp.keys())\\n                    for last in last_states:\\n                        # Check for all the columns, see for each occupied seat has no cheating opportunities on upper left and upper right\\n                        for j in range(n):\\n                            no_cheat = True\\n                            if candidate & (1<<j) != 0 and j > 0:\\n                                no_cheat &= (last&(1<<(j-1))==0)\\n                            if candidate & (1<<j) != 0 and j < n-1:\\n                                no_cheat &= (last&(1<<(j+1))==0)\\n                            if not no_cheat:\\n                                break\\n                        if no_cheat:\\n                            dp_new[candidate] = max(dp_new.get(candidate, 0), student_this_row + dp[last])\\n            dp = dp_new.copy()\\n        return max(dp.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591357,
                "title": "python-bitmask-dp",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n = len(seats) ; m = len(seats[0])\\n        M = 1<<m\\n        dp = [[0]*M for i in range(n)]\\n        for mask in range(M):\\n            x = bin(mask)[2:]\\n            ok = 1\\n            for i in range(m):\\n                if ((1<<i)&mask) and seats[0][i]==\\'#\\': \\n                    ok = 0\\n                    break \\n            if ok==0: continue\\n            if \\'11\\'  not in x:\\n                dp[0][mask] = bin(mask).count(\\'1\\')\\n        for row in range(1,n):\\n            for thismask in range(M):\\n                ok = 1 \\n                for i in range(m):\\n                    if ((1<<i)&thismask) and seats[row][i]==\\'#\\': \\n                        ok = 0\\n                        break \\n                if ok==0 or \\'11\\' in bin(thismask):\\n                    continue\\n                for prevmask in range(M):\\n                    ok = 1\\n                    for i in range(m):\\n                        if ((1<<i)&prevmask) and seats[row-1][i]==\\'#\\': \\n                            ok = 0\\n                            break \\n                        if ((1<<i)&thismask):\\n                            if i>0 and ((1<<(i-1))&prevmask):\\n                                ok = 0\\n                                break \\n                            if i<m-1 and ((1<<(i+1))&prevmask):\\n                                ok = 0\\n                                break \\n                                \\n                    if (\\'11\\' in bin(prevmask) or ok==0): continue\\n                    dp[row][thismask] = max(dp[row-1][prevmask] + bin(thismask).count(\\'1\\') , dp[row][thismask])\\n        return max(dp[-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n = len(seats) ; m = len(seats[0])\\n        M = 1<<m\\n        dp = [[0]*M for i in range(n)]\\n        for mask in range(M):\\n            x = bin(mask)[2:]\\n            ok = 1\\n            for i in range(m):\\n                if ((1<<i)&mask) and seats[0][i]==\\'#\\': \\n                    ok = 0\\n                    break \\n            if ok==0: continue\\n            if \\'11\\'  not in x:\\n                dp[0][mask] = bin(mask).count(\\'1\\')\\n        for row in range(1,n):\\n            for thismask in range(M):\\n                ok = 1 \\n                for i in range(m):\\n                    if ((1<<i)&thismask) and seats[row][i]==\\'#\\': \\n                        ok = 0\\n                        break \\n                if ok==0 or \\'11\\' in bin(thismask):\\n                    continue\\n                for prevmask in range(M):\\n                    ok = 1\\n                    for i in range(m):\\n                        if ((1<<i)&prevmask) and seats[row-1][i]==\\'#\\': \\n                            ok = 0\\n                            break \\n                        if ((1<<i)&thismask):\\n                            if i>0 and ((1<<(i-1))&prevmask):\\n                                ok = 0\\n                                break \\n                            if i<m-1 and ((1<<(i+1))&prevmask):\\n                                ok = 0\\n                                break \\n                                \\n                    if (\\'11\\' in bin(prevmask) or ok==0): continue\\n                    dp[row][thismask] = max(dp[row-1][prevmask] + bin(thismask).count(\\'1\\') , dp[row][thismask])\\n        return max(dp[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554711,
                "title": "c-dp-with-bitmask-cleanest-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //one of the best of the best dp with bitmasking problem itself to understand dp with bitmask\\n        \\n         int m=seats.size();//rows\\n        int n=seats[0].size();//columns\\n        vector<int> validity(m+1);//remember we are taking m+1 not m\\n        //so first row is the 1th row not 0th\\n        for(int i=0;i<m;i++){\\n            int rowvalid=0;\\n            for(int j=0;j<n;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    rowvalid+=(1<<j);\\n                }\\n            }\\n            validity[i+1]=rowvalid;\\n        }\\n        \\n        //dp\\n        vector<vector<int>> dp(m+1,vector<int>((1<<n)+1,-1));\\n        //dp[i][j] represents the maximum number of students that can be placed till the ith row from the first row satisfying the condition that they cant cheat where j is the configuration of seated students in the ith row which satisfies the optimal result till this row\\n        dp[0][0]=0;//initializing\\n        for(int i=1;i<=m;i++){\\n            //go through each row\\n            int valid=validity[i];\\n            for(int j=0;j<(1<<n);j++){\\n                //go through the configuration of seats,total configurations 1<<n i.e 2^n\\n                if((j&valid)!=j){\\n                    continue;//j must be a subset of valid\\n\\t\\t\\t\\t\\t//valid contains the valid configuraion of avaliable seats where students can be placed for this ith row,\\n\\t\\t\\t\\t\\t//if the given configuration of students i.e \"j\" itself is invalid which means it isn\\'t a subset of the \"valid\" then continue\\n                }\\n                if((j&(j>>1))){\\n                    continue;//no two students must be adjacent,given in the question\\n                }\\n                for(int k=0;k<(1<<n);k++){\\n                    if(dp[i-1][k]==-1){\\n                        continue;//invalid state\\n                    }\\n                    if((j&(k>>1)) || (k&(j>>1))){\\n                        continue;//checking if upper right and upper left seats are occupied which will lead to cheating\\n                    }\\n                    //reaching this state all the constraints are satisfied\\n                    dp[i][j]=max(dp[i][j],dp[i-1][k]+__builtin_popcount(j));\\n                }\\n            }\\n        }\\n        return *max_element(dp[m].begin(),dp[m].end());//last row\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        //one of the best of the best dp with bitmasking problem itself to understand dp with bitmask\\n        \\n         int m=seats.size();//rows\\n        int n=seats[0].size();//columns\\n        vector<int> validity(m+1);//remember we are taking m+1 not m\\n        //so first row is the 1th row not 0th\\n        for(int i=0;i<m;i++){\\n            int rowvalid=0;\\n            for(int j=0;j<n;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    rowvalid+=(1<<j);\\n                }\\n            }\\n            validity[i+1]=rowvalid;\\n        }\\n        \\n        //dp\\n        vector<vector<int>> dp(m+1,vector<int>((1<<n)+1,-1));\\n        //dp[i][j] represents the maximum number of students that can be placed till the ith row from the first row satisfying the condition that they cant cheat where j is the configuration of seated students in the ith row which satisfies the optimal result till this row\\n        dp[0][0]=0;//initializing\\n        for(int i=1;i<=m;i++){\\n            //go through each row\\n            int valid=validity[i];\\n            for(int j=0;j<(1<<n);j++){\\n                //go through the configuration of seats,total configurations 1<<n i.e 2^n\\n                if((j&valid)!=j){\\n                    continue;//j must be a subset of valid\\n\\t\\t\\t\\t\\t//valid contains the valid configuraion of avaliable seats where students can be placed for this ith row,\\n\\t\\t\\t\\t\\t//if the given configuration of students i.e \"j\" itself is invalid which means it isn\\'t a subset of the \"valid\" then continue\\n                }\\n                if((j&(j>>1))){\\n                    continue;//no two students must be adjacent,given in the question\\n                }\\n                for(int k=0;k<(1<<n);k++){\\n                    if(dp[i-1][k]==-1){\\n                        continue;//invalid state\\n                    }\\n                    if((j&(k>>1)) || (k&(j>>1))){\\n                        continue;//checking if upper right and upper left seats are occupied which will lead to cheating\\n                    }\\n                    //reaching this state all the constraints are satisfied\\n                    dp[i][j]=max(dp[i][j],dp[i-1][k]+__builtin_popcount(j));\\n                }\\n            }\\n        }\\n        return *max_element(dp[m].begin(),dp[m].end());//last row\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457983,
                "title": "go-golang-dp-bitmask-solution",
                "content": "```\\nfunc maxStudents(seats [][]byte) int {\\n    dp := make([]int, 1 << len(seats[0]))\\n    \\n    for _, row := range seats {\\n        prevDP := dp\\n        dp = make([]int, 1<<len(row))\\n        \\n        rowMask := 0\\n        \\n        for i := range row {\\n            if row[i] ==\\'.\\' {\\n                rowMask += 1<<i\\n            }\\n        }\\n        \\n        for mask := 0; mask < 1<<len(row); mask++ {\\n            if mask&rowMask != mask {\\n                continue\\n            }\\n            \\n            count := bits.OnesCount(uint(mask))\\n            \\n            for prevMask := 0; prevMask < 1<<len(row); prevMask++ {\\n                if mask<<1 & mask > 0 || prevMask<<1 & mask > 0 || prevMask>>1 & mask > 0 {\\n                    continue\\n                }\\n                \\n                dp[mask] = max(dp[mask], prevDP[prevMask]+count)\\n            }\\n        }\\n    }\\n    \\n    result := 0\\n\\n    for i := 0; i < 1<<len(seats[0]); i++ {\\n        result = max(result, dp[i])\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nfunc maxStudents(seats [][]byte) int {\\n    dp := make([]int, 1 << len(seats[0]))\\n    \\n    for _, row := range seats {\\n        prevDP := dp\\n        dp = make([]int, 1<<len(row))\\n        \\n        rowMask := 0\\n        \\n        for i := range row {\\n            if row[i] ==\\'.\\' {\\n                rowMask += 1<<i\\n            }\\n        }\\n        \\n        for mask := 0; mask < 1<<len(row); mask++ {\\n            if mask&rowMask != mask {\\n                continue\\n            }\\n            \\n            count := bits.OnesCount(uint(mask))\\n            \\n            for prevMask := 0; prevMask < 1<<len(row); prevMask++ {\\n                if mask<<1 & mask > 0 || prevMask<<1 & mask > 0 || prevMask>>1 & mask > 0 {\\n                    continue\\n                }\\n                \\n                dp[mask] = max(dp[mask], prevDP[prevMask]+count)\\n            }\\n        }\\n    }\\n    \\n    result := 0\\n\\n    for i := 0; i < 1<<len(seats[0]); i++ {\\n        result = max(result, dp[i])\\n    }\\n    \\n    return result\\n}\\n\\nfunc max(i, j int) int {\\n    if i > j {\\n        return i\\n    }\\n    \\n    return j\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2359084,
                "title": "easy-top-down",
                "content": "\\tvoid find(string prev, string inp, int count, vector<pair<string,int>> &ans, vector<vector<char>>& seats, int row, int col) {\\n        if(col == seats[0].size()){\\n            ans.push_back({inp,count});\\n            return;\\n        }\\n        \\n        if(seats[row][col] == \\'#\\') {\\n            find(prev, inp+\\'#\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col > 0 && prev[col-1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col+1 < seats[0].size() && prev[col+1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col > 0 && inp[col-1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        //put\\n        find(prev, inp+\\'G\\',1+count,ans,seats,row,col+1);\\n        //notput\\n        find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n    } \\n    \\n    unordered_map<string, int> dp;\\n    \\n    string makepair(string prev, int i) {\\n        return prev + \"_\" + to_string(i);\\n    }\\n    \\n    int solve(string prev, int i, vector<vector<char>>& seats) {\\n        if(i == seats.size())\\n            return 0;\\n        \\n\\t\\t// storing prev row as a string and curr row number\\n        if(dp.count(makepair(prev,i)) > 0)\\n            return dp[makepair(prev,i)];\\n        \\n        int m = seats[0].size();\\n        vector<pair<string,int>> ans;\\n\\t\\t\\n\\t\\t//could be more optimal to convert find function into dp\\n        find(prev, \"\", 0, ans, seats, i, 0);\\n        \\n        int temp = 0;\\n        for(auto k : ans)\\n            temp = max(temp, k.second + solve(k.first, i+1, seats));\\n        \\n        return dp[makepair(prev,i)] = temp;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        return solve(string(seats[0].size(), \\'#\\'), 0, seats);\\n    }",
                "solutionTags": [
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "\\tvoid find(string prev, string inp, int count, vector<pair<string,int>> &ans, vector<vector<char>>& seats, int row, int col) {\\n        if(col == seats[0].size()){\\n            ans.push_back({inp,count});\\n            return;\\n        }\\n        \\n        if(seats[row][col] == \\'#\\') {\\n            find(prev, inp+\\'#\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col > 0 && prev[col-1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col+1 < seats[0].size() && prev[col+1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        if(col > 0 && inp[col-1] == \\'G\\') {\\n            find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n            return;\\n        }\\n        \\n        //put\\n        find(prev, inp+\\'G\\',1+count,ans,seats,row,col+1);\\n        //notput\\n        find(prev, inp+\\'.\\',count,ans,seats,row,col+1);\\n    } \\n    \\n    unordered_map<string, int> dp;\\n    \\n    string makepair(string prev, int i) {\\n        return prev + \"_\" + to_string(i);\\n    }\\n    \\n    int solve(string prev, int i, vector<vector<char>>& seats) {\\n        if(i == seats.size())\\n            return 0;\\n        \\n\\t\\t// storing prev row as a string and curr row number\\n        if(dp.count(makepair(prev,i)) > 0)\\n            return dp[makepair(prev,i)];\\n        \\n        int m = seats[0].size();\\n        vector<pair<string,int>> ans;\\n\\t\\t\\n\\t\\t//could be more optimal to convert find function into dp\\n        find(prev, \"\", 0, ans, seats, i, 0);\\n        \\n        int temp = 0;\\n        for(auto k : ans)\\n            temp = max(temp, k.second + solve(k.first, i+1, seats));\\n        \\n        return dp[makepair(prev,i)] = temp;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        return solve(string(seats[0].size(), \\'#\\'), 0, seats);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2309168,
                "title": "easy-understanding-c-time-o-m-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if (seats.empty() || seats[0].empty()) return 0;\\n        int width = seats[0].size();\\n\\n        // just remember current line, and one line below\\n        std::vector<std::unordered_map<unsigned, unsigned>> best(2);\\n\\n        // try put one more chair, or move chair to right\\n        auto IncreaseLinecode = [&](unsigned& line_code, int row) {\\n            unsigned mask = 0x01;\\n            for (int n = 0; n < width; ++n) {\\n                if (seats[row][n] == \\'.\\') {\\n                    if (line_code & mask) {\\n                        line_code ^= mask;\\n                    }\\n                    else if (!(line_code & (mask << 1)) && !(line_code & (mask >> 1))) {\\n                        line_code |= mask;\\n                        return true;\\n                    }\\n                }\\n                mask <<= 1;\\n            }\\n            return false;\\n        };\\n        \\n        // how much chairs in this row?\\n        auto Score = [](unsigned i)\\n        {\\n            i = i - ((i >> 1) & 0x55555555);        // add pairs of bits\\n            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);  // quads\\n            i = (i + (i >> 4)) & 0x0F0F0F0F;        // groups of 8\\n            return (i * 0x01010101) >> 24;          // horizontal sum of bytes\\n        };\\n\\n        auto Valid = [](unsigned line_code, unsigned line_code2) {\\n            return !((line_code & (line_code2 >> 1)) || (line_code & (line_code2 << 1)));\\n        };\\n\\n        auto UpdateBest = [&](unsigned line_code, int row) {\\n            unsigned score = Score(line_code);\\n            std::pair<unsigned, unsigned> below_best{ 0, 0 };\\n            if (row < seats.size() - 1) {\\n                for (auto& kv : best[1]) {\\n                    if (kv.second > below_best.second && Valid(line_code, kv.first)) {\\n                        below_best = kv;\\n                    }\\n                }\\n            }\\n            best[0][line_code] = score + below_best.second;\\n        };\\n\\n        auto Best = [&](int row) {\\n            if (row >= best.size() || best[row].empty()) return 0u;\\n            return std::max_element(best[row].begin(), best[row].end(), [](const auto& l, const auto& r) { return l.second < r.second; })->second;\\n        };\\n\\n        for (int row = seats.size() - 1; row >= 0; --row) {\\n            unsigned line_code = 0;\\n            best[0][0] = Best(1);   // with no seats in current row, we got same best score as next row\\n            while (IncreaseLinecode(line_code, row)) {\\n                UpdateBest(line_code, row);\\n            }\\n            best[1] = std::move(best[0]);\\n        }\\n\\n        return Best(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if (seats.empty() || seats[0].empty()) return 0;\\n        int width = seats[0].size();\\n\\n        // just remember current line, and one line below\\n        std::vector<std::unordered_map<unsigned, unsigned>> best(2);\\n\\n        // try put one more chair, or move chair to right\\n        auto IncreaseLinecode = [&](unsigned& line_code, int row) {\\n            unsigned mask = 0x01;\\n            for (int n = 0; n < width; ++n) {\\n                if (seats[row][n] == \\'.\\') {\\n                    if (line_code & mask) {\\n                        line_code ^= mask;\\n                    }\\n                    else if (!(line_code & (mask << 1)) && !(line_code & (mask >> 1))) {\\n                        line_code |= mask;\\n                        return true;\\n                    }\\n                }\\n                mask <<= 1;\\n            }\\n            return false;\\n        };\\n        \\n        // how much chairs in this row?\\n        auto Score = [](unsigned i)\\n        {\\n            i = i - ((i >> 1) & 0x55555555);        // add pairs of bits\\n            i = (i & 0x33333333) + ((i >> 2) & 0x33333333);  // quads\\n            i = (i + (i >> 4)) & 0x0F0F0F0F;        // groups of 8\\n            return (i * 0x01010101) >> 24;          // horizontal sum of bytes\\n        };\\n\\n        auto Valid = [](unsigned line_code, unsigned line_code2) {\\n            return !((line_code & (line_code2 >> 1)) || (line_code & (line_code2 << 1)));\\n        };\\n\\n        auto UpdateBest = [&](unsigned line_code, int row) {\\n            unsigned score = Score(line_code);\\n            std::pair<unsigned, unsigned> below_best{ 0, 0 };\\n            if (row < seats.size() - 1) {\\n                for (auto& kv : best[1]) {\\n                    if (kv.second > below_best.second && Valid(line_code, kv.first)) {\\n                        below_best = kv;\\n                    }\\n                }\\n            }\\n            best[0][line_code] = score + below_best.second;\\n        };\\n\\n        auto Best = [&](int row) {\\n            if (row >= best.size() || best[row].empty()) return 0u;\\n            return std::max_element(best[row].begin(), best[row].end(), [](const auto& l, const auto& r) { return l.second < r.second; })->second;\\n        };\\n\\n        for (int row = seats.size() - 1; row >= 0; --row) {\\n            unsigned line_code = 0;\\n            best[0][0] = Best(1);   // with no seats in current row, we got same best score as next row\\n            while (IncreaseLinecode(line_code, row)) {\\n                UpdateBest(line_code, row);\\n            }\\n            best[1] = std::move(best[0]);\\n        }\\n\\n        return Best(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272404,
                "title": "detailed-explanation-with-recursion-you-can-get-bitmask-dp-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<char>> seats;\\n    int dp[10][10][256][256]; //2^8 is 256\\n    \\n    bool valid(int i,int j,int mask,int pmask){\\n        if(((mask<<1) & (1<<j)) or ((mask>>1) & (1<<j))) return false;\\n        if(((pmask<<1) & (1<<j)) or ((pmask>>1) & (1<<j))) return false;\\n        return true;\\n    }\\n    \\n    int rec(int i,int j,int mask,int pmask){\\n        if(j==m){\\n            i+=1;\\n            j=0;\\n            pmask=mask;\\n            mask=0;\\n        }\\n        \\n        if(i==n and j==0) return 0;\\n        \\n        if(dp[i][j][mask][pmask]!=-1) return dp[i][j][mask][pmask];\\n        \\n        int ans=0;\\n        if(seats[i][j]==\\'.\\' and valid(i,j,mask,pmask)){\\n            ans=1+rec(i,j+1,mask|(1<<j),pmask);\\n        }\\n        \\n        ans=max(ans,rec(i,j+1,mask,pmask));\\n        \\n        return dp[i][j][mask][pmask]=ans;\\n    }\\n    \\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        this->seats=seats;\\n        this->n=seats.size();\\n        this->m=seats[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        set<pair<int,int>> ss;\\n        int ans=rec(0,0,0,0);\\n        return ans;\\n    }\\n};\\n```\\n/*\\n\\nwe simply loop on the grid \\nas i,j+1(next cell) when j<m-1 and \\nas i+1,0(new row) when j has reached m-1.\\nTo deal with this we in the start of the recursion call we just modify the indexes. when we shift to new row, we put the mask of the current row as prev_mask of prev_row and now we explore the mask of the new row by setting mask=0.\\n\\nafter first if, we dont put else_if. since for the position where we can place the student we have option to either place it (first_if_block_executed) or we can choose to not_place it in the hope that we could place more_students via this configuration. so when we have option to put the student we can either put it or choose not to put it. Consider the option which returns max_students_placed. \\n\\nFor the if_block, we assign some answer to it and then for the option of not choosing we take max from the answer already calculated via the placed configuration. \\n\\nIf we cant place the student or if we have \\'#\\' i.e., if_block not executed then we choose to move ahead. We can move ahead just like the way described in the beginning. \\n\\nwe neednot to worry about checking \\'#\\' in our valid since we never insert it into our mask. Also the regular check of pointer moving outside the grid is also not needed since we just want to check are the students placed at the possible 4 locations. the check can be done via : \\nin the same row: just left check: mask>>1 & (1<<j) ; right check: mask<<1 & (1<<j)\\nin the prev row: left-upper check: pmask>>1 & (1<<j) ; right-upper check: pmask<<1 &(1<<j)\\nif any of the above cond(s) is valid then we cant place the student @jth location in ith row.\\n\\nBC: is imp in the aspect that we need to cover all the cells. or we can say, when 0.....n-1 rows covered then i reaches n and column we just decide to make it 0. even if(i==n) return 0. will work.\\n\\n\\n*/\\n/*\\n\\ninspired from : \\n\\nby Myself. and \\n\\nhttps://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\nhttps://leetcode.com/problems/maximum-students-taking-exam/discuss/2191378/C%2B%2B-or-DP-with-bit-masking\\n\\n\\n*/",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<char>> seats;\\n    int dp[10][10][256][256]; //2^8 is 256\\n    \\n    bool valid(int i,int j,int mask,int pmask){\\n        if(((mask<<1) & (1<<j)) or ((mask>>1) & (1<<j))) return false;\\n        if(((pmask<<1) & (1<<j)) or ((pmask>>1) & (1<<j))) return false;\\n        return true;\\n    }\\n    \\n    int rec(int i,int j,int mask,int pmask){\\n        if(j==m){\\n            i+=1;\\n            j=0;\\n            pmask=mask;\\n            mask=0;\\n        }\\n        \\n        if(i==n and j==0) return 0;\\n        \\n        if(dp[i][j][mask][pmask]!=-1) return dp[i][j][mask][pmask];\\n        \\n        int ans=0;\\n        if(seats[i][j]==\\'.\\' and valid(i,j,mask,pmask)){\\n            ans=1+rec(i,j+1,mask|(1<<j),pmask);\\n        }\\n        \\n        ans=max(ans,rec(i,j+1,mask,pmask));\\n        \\n        return dp[i][j][mask][pmask]=ans;\\n    }\\n    \\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        this->seats=seats;\\n        this->n=seats.size();\\n        this->m=seats[0].size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        set<pair<int,int>> ss;\\n        int ans=rec(0,0,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223700,
                "title": "bitmasking-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        max_st = [0] * len(seats)\\n        for i in range(len(seats)):\\n            cnt = 1\\n            st = 0\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'.\\':\\n                    st += cnt\\n                cnt = cnt * 2\\n            max_st[i] = st\\n        ans = 0\\n        \\n        dp = {}\\n        for i in range(len(seats)): \\n            for j in range(1 << len(seats[i])):\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n                if j & max_st[i] == j and (j & (j >> 1)) == 0:\\n                    dp[i, j] = 0\\n                    set_bits = self.find_set_bits(j)\\n                    if i - 1 >= 0:\\n                        for k in range(1 << len(seats[i-1])):\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n                            if (i-1, k) in dp and (((j >> 1 & k) == 0) and ((j << 1 & k) == 0)):\\n                                dp[i, j] = max(dp[i, j], dp[i-1, k] + set_bits)\\n                            \\n                    else:\\n                        dp[i, j] = set_bits\\n                    ans = max(ans, dp[i, j])\\n        return ans\\n    \\n    def find_set_bits(self, num):\\n        set_bits = 0\\n        while(num):\\n            if num % 2:\\n                set_bits += 1\\n            num //= 2\\n        return set_bits\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        max_st = [0] * len(seats)\\n        for i in range(len(seats)):\\n            cnt = 1\\n            st = 0\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'.\\':\\n                    st += cnt\\n                cnt = cnt * 2\\n            max_st[i] = st\\n        ans = 0\\n        \\n        dp = {}\\n        for i in range(len(seats)): \\n            for j in range(1 << len(seats[i])):\\n\\t\\t\\t\\n\\t\\t\\t\\t\\n                if j & max_st[i] == j and (j & (j >> 1)) == 0:\\n                    dp[i, j] = 0\\n                    set_bits = self.find_set_bits(j)\\n                    if i - 1 >= 0:\\n                        for k in range(1 << len(seats[i-1])):\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\n                            if (i-1, k) in dp and (((j >> 1 & k) == 0) and ((j << 1 & k) == 0)):\\n                                dp[i, j] = max(dp[i, j], dp[i-1, k] + set_bits)\\n                            \\n                    else:\\n                        dp[i, j] = set_bits\\n                    ans = max(ans, dp[i, j])\\n        return ans\\n    \\n    def find_set_bits(self, num):\\n        set_bits = 0\\n        while(num):\\n            if num % 2:\\n                set_bits += 1\\n            num //= 2\\n        return set_bits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221714,
                "title": "java-o-m-2-n-bitmask-dp",
                "content": "```\\nclass Solution {\\n    \\n    char[][] seats;\\n    public int maxStudents(char[][] seats) {\\n        this.seats = seats;\\n        \\n        int m = seats.length;\\n        int n = seats[0].length;\\n        \\n        int[] dp = new int[1<<n];\\n        \\n        int ret = 0;\\n        \\n        for (int i = 1; i <= m; i++) {\\n            int[] temp = new int[dp.length];\\n            System.arraycopy(dp, 0, temp, 0, dp.length);\\n            dp = new int[1<<n];\\n            \\n            for (int j = 0; j < dp.length; j++) {\\n                if (!isValid(j, i-1)) continue;\\n                \\n                if (i == 1) {\\n                   dp[j] = Math.max(dp[j], count(j));\\n                }else {\\n                    for (int k = 0; k < dp.length; k++) {\\n                        if (!isValid(k, i-2)) continue;\\n                        if (!isAllowed(j, k)) continue;\\n                        \\n                        dp[j] = Math.max(temp[k]+count(j), dp[j]);\\n                    }\\n                }\\n                \\n                if (i == m) {\\n                    ret = Math.max(ret, dp[j]);\\n                }\\n            }\\n        }\\n        \\n        return ret;\\n        \\n    }\\n    \\n    public boolean isValid(int val, int row) {\\n        char[] seat = seats[row];\\n        \\n        for (int i = 0; i < seat.length; i++) {\\n            int cur = ((val>>i) & 1);\\n            if (seat[i] == \\'#\\' && cur == 1) return false;\\n            \\n            if (i > 0) {\\n                int pre = ((val>>(i-1)) &1);\\n                if (cur == 1 && pre == 1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public boolean isAllowed(int val1, int val2) {\\n        \\n        for (int i = 0; i < seats[0].length;i++) {\\n            int cur = ((val1>>i)&1);\\n            if (cur != 1) continue;\\n            \\n            if (i >= 1) {\\n                int pre1 =((val2>>(i-1))&1);\\n                if (pre1 == 1) return false;\\n            }\\n            \\n            if (i < seats[0].length-1) {\\n                int pre2 =((val2>>(i+1))&1);\\n                if (pre2 == 1) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    public int count(int n) {\\n        \\n        int ret = 0;\\n        \\n        while (n > 0) {\\n            ret += (n & 1);\\n            n = (n>>1);\\n        }\\n        \\n        return ret;\\n    }\\n}\\n``",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    char[][] seats;\\n    public int maxStudents(char[][] seats) {\\n        this.seats = seats;\\n        \\n        int m = seats.length;\\n        int n = seats[0].length;\\n        \\n        int[] dp = new int[1<<n];\\n        \\n        int ret = 0;\\n        \\n        for (int i = 1; i <= m; i++) {\\n            int[] temp = new int[dp.length];\\n            System.arraycopy(dp, 0, temp, 0, dp.length);\\n            dp = new int[1<<n];\\n            \\n            for (int j = 0; j < dp.length; j++) {\\n                if (!isValid(j, i-1)) continue;\\n                \\n                if (i == 1) {\\n                   dp[j] = Math.max(dp[j], count(j));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2133396,
                "title": "fast-go-solution-beats-100",
                "content": "```\\nfunc bcnt(x int) int {\\n    r := 0\\n    for x > 0 {\\n        r++\\n        x = x & (x - 1)\\n    }\\n    return r\\n}\\n\\nfunc maxStudents(seats [][]byte) int {\\n    m, n := len(seats), len(seats[0])\\n    mm, ss := make([][]int, 2), make([]int, m)\\n    b := 1 << n\\n    for i := 0; i < 2; i++ {\\n        mm[i] = make([]int, 1 << n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if seats[i][j] == \\'#\\' {\\n                ss[i] |= 1 << j\\n            }\\n        }\\n    }\\n        \\n    for i := 0; i < b; i++ {\\n        if ss[0] & i == 0  && i & (i << 1) == 0 && i & (i >> 1) == 0 {\\n            mm[0][i] = bcnt(i)        \\n        }\\n    }\\n    \\n    now, pre := 0, 0\\n    for i := 1; i < m; i++ {\\n        pre = now\\n        now ^= 1\\n        \\n        for j := 0; j < b; j++ {\\n            mm[now][j] = 0\\n        }\\n        \\n        for k := 0; k < b; k++ {\\n            if k & ss[i] == 0 && k & (k << 1) == 0 && k & (k >> 1) == 0 {\\n                for j := 0; j < b; j++ {\\n                    if mm[pre][j] > 0 && k & (j << 1) == 0 && k & (j >> 1) == 0 && mm[now][k] < mm[pre][j] {\\n                        mm[now][k] = mm[pre][j]\\n                    }\\n                }\\n                mm[now][k] += bcnt(k)\\n            }                     \\n        }\\n    }        \\n    \\n    res := 0\\n    for j := 0; j < b; j++ {\\n        if mm[now][j] > res {\\n            res = mm[now][j]\\n        }\\n    }\\n    return res\\n}",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc bcnt(x int) int {\\n    r := 0\\n    for x > 0 {\\n        r++\\n        x = x & (x - 1)\\n    }\\n    return r\\n}\\n\\nfunc maxStudents(seats [][]byte) int {\\n    m, n := len(seats), len(seats[0])\\n    mm, ss := make([][]int, 2), make([]int, m)\\n    b := 1 << n\\n    for i := 0; i < 2; i++ {\\n        mm[i] = make([]int, 1 << n)\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if seats[i][j] == \\'#\\' {\\n                ss[i] |= 1 << j\\n            }\\n        }\\n    }\\n        \\n    for i := 0; i < b; i++ {\\n        if ss[0] & i == 0  && i & (i << 1) == 0 && i & (i >> 1) == 0 {\\n            mm[0][i] = bcnt(i)        \\n        }\\n    }\\n    \\n    now, pre := 0, 0\\n    for i := 1; i < m; i++ {\\n        pre = now\\n        now ^= 1\\n        \\n        for j := 0; j < b; j++ {\\n            mm[now][j] = 0\\n        }\\n        \\n        for k := 0; k < b; k++ {\\n            if k & ss[i] == 0 && k & (k << 1) == 0 && k & (k >> 1) == 0 {\\n                for j := 0; j < b; j++ {\\n                    if mm[pre][j] > 0 && k & (j << 1) == 0 && k & (j >> 1) == 0 && mm[now][k] < mm[pre][j] {\\n                        mm[now][k] = mm[pre][j]\\n                    }\\n                }\\n                mm[now][k] += bcnt(k)\\n            }                     \\n        }\\n    }        \\n    \\n    res := 0\\n    for j := 0; j < b; j++ {\\n        if mm[now][j] > res {\\n            res = mm[now][j]\\n        }\\n    }\\n    return res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2095826,
                "title": "js-dfs-memo",
                "content": "```\\nvar maxStudents = function (seats) {\\n\\tconst memo = {},\\n\\t\\tm = seats[0].length,\\n\\t\\tgetRowPossibilities = (prevRow, curRow) => {\\n\\t\\t\\tconst allPossibilities = { [-1]: [\"\"] };\\n\\t\\t\\tfor (let i = 0; i < m; i++) {\\n\\t\\t\\t\\tallPossibilities[i] = [];\\n\\t\\t\\t\\tallPossibilities[i - 1].forEach(possibility => {\\n\\t\\t\\t\\t\\t//dont place a student\\n\\t\\t\\t\\t\\tallPossibilities[i].push(possibility + curRow[i]);\\n\\t\\t\\t\\t\\t//if possible, place a student\\n\\t\\t\\t\\t\\tcurRow[i] === \".\" &&\\n\\t\\t\\t\\t\\t\\tprevRow[i - 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tprevRow[i + 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tpossibility[i - 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tallPossibilities[i].push(possibility + \"1\");\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn allPossibilities[m - 1];\\n\\t\\t},\\n\\t\\tplace = (prevRow, curRowIndex) => {\\n\\t\\t\\tif (curRowIndex === seats.length) return 0;\\n\\t\\t\\tconst key = prevRow + curRowIndex;\\n\\t\\t\\tif (memo[key]) return memo[key];\\n\\t\\t\\tlet max = 0;\\n\\t\\t\\tgetRowPossibilities(prevRow, seats[curRowIndex]).forEach(pos => {\\n\\t\\t\\t\\tmax = Math.max(\\n\\t\\t\\t\\t\\tmax,\\n\\t\\t\\t\\t\\tplace(pos, curRowIndex + 1) + pos.split(\"1\").length - 1\\n\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t\\tmemo[key] = max;\\n\\t\\t\\treturn max;\\n\\t\\t};\\n\\treturn place(\"\", 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nvar maxStudents = function (seats) {\\n\\tconst memo = {},\\n\\t\\tm = seats[0].length,\\n\\t\\tgetRowPossibilities = (prevRow, curRow) => {\\n\\t\\t\\tconst allPossibilities = { [-1]: [\"\"] };\\n\\t\\t\\tfor (let i = 0; i < m; i++) {\\n\\t\\t\\t\\tallPossibilities[i] = [];\\n\\t\\t\\t\\tallPossibilities[i - 1].forEach(possibility => {\\n\\t\\t\\t\\t\\t//dont place a student\\n\\t\\t\\t\\t\\tallPossibilities[i].push(possibility + curRow[i]);\\n\\t\\t\\t\\t\\t//if possible, place a student\\n\\t\\t\\t\\t\\tcurRow[i] === \".\" &&\\n\\t\\t\\t\\t\\t\\tprevRow[i - 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tprevRow[i + 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tpossibility[i - 1] !== \"1\" &&\\n\\t\\t\\t\\t\\t\\tallPossibilities[i].push(possibility + \"1\");\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn allPossibilities[m - 1];\\n\\t\\t},\\n\\t\\tplace = (prevRow, curRowIndex) => {\\n\\t\\t\\tif (curRowIndex === seats.length) return 0;\\n\\t\\t\\tconst key = prevRow + curRowIndex;\\n\\t\\t\\tif (memo[key]) return memo[key];\\n\\t\\t\\tlet max = 0;\\n\\t\\t\\tgetRowPossibilities(prevRow, seats[curRowIndex]).forEach(pos => {\\n\\t\\t\\t\\tmax = Math.max(\\n\\t\\t\\t\\t\\tmax,\\n\\t\\t\\t\\t\\tplace(pos, curRowIndex + 1) + pos.split(\"1\").length - 1\\n\\t\\t\\t\\t);\\n\\t\\t\\t});\\n\\t\\t\\tmemo[key] = max;\\n\\t\\t\\treturn max;\\n\\t\\t};\\n\\treturn place(\"\", 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041043,
                "title": "python-dp-bitmask",
                "content": "\\tclass Solution:\\n\\t\\tdef maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        def check_valid(state, row):\\n            row_in_seats = seats[row]\\n            col = len(seats[row]) - 1\\n            while state != 0:\\n                if (state) & 1 == 1:\\n                    if row_in_seats[col] == \"#\":\\n                        return False\\n                col -= 1\\n                state = state >> 1\\n            return True\\n        \\n        def check_no_conflict(state_1, state_2):\\n            col = len(seats[0]) - 1\\n            for j in range(col + 1):\\n                pos_j = (state_1 >> j) & 1\\n                if pos_j == 1:\\n                    if j > 0 and (state_1 >> (j - 1)) & 1 == 1:\\n                        return False\\n                    if j < col and (state_1 >> (j + 1)) & 1 == 1:\\n                        return False\\n                    if j > 0 and (state_2 >> (j - 1)) & 1 == 1:\\n                        return False\\n                    if j < col and (state_2 >> (j + 1)) & 1 == 1:\\n                        return False\\n            return True\\n                        \\n        def count(state):\\n            cnt = 0\\n            while state != 0:\\n                if (state) & 1 == 1:\\n                    cnt += 1\\n                state = state >> 1\\n            return cnt\\n                    \\n        m = len(seats)\\n        n = len(seats[0])\\n        dp = [[0 for i in range( 2 ** n )] for j in range(m)]\\n        \\n        for state in range(2 ** n ):\\n            if check_valid(state, 0) and check_no_conflict(state, 0):\\n                cnt = count(state)\\n                dp[0][state] = cnt\\n        for i in range(1, m):\\n            for state in range(2 ** n ):\\n                for state_2 in range(2 ** n ):\\n                    if check_valid(state, i) and check_valid(state_2, i - 1) and check_no_conflict(state, state_2):\\n                        cnt = count(state)\\n                        dp[i][state] = max(dp[i - 1][state_2] + cnt, dp[i][state])\\n        return max(dp[m - 1])\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxStudents(self, seats: List[List[str]]) -> int:\\n\\n        def check_valid(state, row):\\n            row_in_seats = seats[row]\\n            col = len(seats[row]) - 1\\n            while state != 0:\\n                if (state) & 1 == 1:\\n                    if row_in_seats[col] == \"#\":\\n                        return False\\n                col -= 1\\n                state = state >> 1\\n            return True\\n        \\n        def check_no_conflict(state_1, state_2):\\n            col = len(seats[0]) - 1\\n            for j in range(col + 1):\\n                pos_j = (state_1 >> j) & 1\\n                if pos_j == 1:\\n                    if j > 0 and (state_1 >> (j - 1)) & 1 == 1:\\n                        return False\\n                    if j < col and (state_1 >> (j + 1)) & 1 == 1:\\n                        return False\\n                    if j > 0 and (state_2 >> (j - 1)) & 1 == 1:\\n                        return False\\n                    if j < col and (state_2 >> (j + 1)) & 1 == 1:\\n                        return False\\n            return True\\n                        \\n        def count(state):\\n            cnt = 0\\n            while state != 0:\\n                if (state) & 1 == 1:\\n                    cnt += 1\\n                state = state >> 1\\n            return cnt\\n                    \\n        m = len(seats)\\n        n = len(seats[0])\\n        dp = [[0 for i in range( 2 ** n )] for j in range(m)]\\n        \\n        for state in range(2 ** n ):\\n            if check_valid(state, 0) and check_no_conflict(state, 0):\\n                cnt = count(state)\\n                dp[0][state] = cnt\\n        for i in range(1, m):\\n            for state in range(2 ** n ):\\n                for state_2 in range(2 ** n ):\\n                    if check_valid(state, i) and check_valid(state_2, i - 1) and check_no_conflict(state, state_2):\\n                        cnt = count(state)\\n                        dp[i][state] = max(dp[i - 1][state_2] + cnt, dp[i][state])\\n        return max(dp[m - 1])\\n",
                "codeTag": "Java"
            },
            {
                "id": 2006358,
                "title": "python-using-maximum-bipartite-matching",
                "content": "Based on https://leetcode.com/problems/maximum-students-taking-exam/discuss/503790/Python-Hungarian-Time-O(m2*n2)-Space-O(m*n)-beat-100\\nNote that the number of element in maximum independent set in a bipartite set is same as #(total elements) - #(maximum bipartite set)\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        match = [[-1]*n for _ in range(m)]\\n        def dfs(i, j, visited):\\n            for x, y in [(i-1,j-1),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j+1)]:\\n                if 0 <= x < m and 0 <= y < n and seats[x][y] == \".\" and (x, y) not in visited:\\n                    visited.add((x, y))\\n                    if match[x][y] == -1 or dfs(*match[x][y], visited):\\n                        match[x][y] = (i, j)\\n                        match[i][j] = (x, y)\\n                        return True\\n            return False\\n        def max_matching():\\n            cnt = 0\\n            for i in range(m):\\n                for j in range(0,n,2):\\n                    if seats[i][j] == \\'.\\' and match[i][j] == -1:\\n                        visited = set()\\n                        cnt += dfs(i, j, visited)\\n            return cnt\\n\\t\\t#returns the number of elements of the maximum independent set in the bipartite set\\n        return sum(seats[i][j]==\\'.\\' for i in range(m) for j in range(n)) - max_matching()",
                "solutionTags": [
                    "Python"
                ],
                "code": "Based on https://leetcode.com/problems/maximum-students-taking-exam/discuss/503790/Python-Hungarian-Time-O(m2*n2)-Space-O(m*n)-beat-100\\nNote that the number of element in maximum independent set in a bipartite set is same as #(total elements) - #(maximum bipartite set)\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0])\\n        match = [[-1]*n for _ in range(m)]\\n        def dfs(i, j, visited):\\n            for x, y in [(i-1,j-1),(i-1,j+1),(i,j-1),(i,j+1),(i+1,j-1),(i+1,j+1)]:\\n                if 0 <= x < m and 0 <= y < n and seats[x][y] == \".\" and (x, y) not in visited:\\n                    visited.add((x, y))\\n                    if match[x][y] == -1 or dfs(*match[x][y], visited):\\n                        match[x][y] = (i, j)\\n                        match[i][j] = (x, y)\\n                        return True\\n            return False\\n        def max_matching():\\n            cnt = 0\\n            for i in range(m):\\n                for j in range(0,n,2):\\n                    if seats[i][j] == \\'.\\' and match[i][j] == -1:\\n                        visited = set()\\n                        cnt += dfs(i, j, visited)\\n            return cnt\\n\\t\\t#returns the number of elements of the maximum independent set in the bipartite set\\n        return sum(seats[i][j]==\\'.\\' for i in range(m) for j in range(n)) - max_matching()",
                "codeTag": "Java"
            },
            {
                "id": 1980134,
                "title": "easy-to-understand-java",
                "content": "\\nTC: O((1<<N) * M)\\nSC: O((1<<N) * M)\\n\\n```\\nclass Solution {\\n    int M, N;\\n    int[][] dp;\\n    public int maxStudents(char[][] seats) {\\n        int prev = 0;\\n        this.M = seats.length;\\n        this.N = seats[0].length;\\n        dp = new int[M][(1 << N)];\\n        return dfs(0, seats, prev);\\n    }\\n    \\n    private int dfs(int index, char[][] seats, int prev){\\n        \\n        if (index == M) return 0;\\n        \\n        if (dp[index][prev] > 0) return dp[index][prev];\\n        char[] cur = seats[index];\\n        int res = 0;\\n        for (int i = 0; i < (1 << N); i++) {\\n            if (isOkSeatingPlan(i, prev, cur)){\\n                // System.out.println(\"i: \" + i + \" prev: \" + prev);\\n                res = Math.max(res, Integer.bitCount(i) + dfs(index + 1, seats, i)) ;\\n            }\\n        }\\n        return dp[index][prev] = res;\\n    }\\n    \\n    private boolean isOkSeatingPlan(int cur, int prev, char[] A) {\\n                \\n        int preCurBit = 0;\\n        for (int i = 0; i < N; i++) {\\n            int curbit = (cur >> i) & 1;\\n            if (curbit == 0){\\n                continue;\\n            }\\n            // cannot sit at broken seats\\n            if (A[i] != \\'.\\') return false;\\n            // cannot sit side by side\\n            if (i > 0){\\n                preCurBit = (cur >> (i - 1)) & 1;\\n            }\\n            if (curbit == preCurBit) return false;\\n            if (i + 1 < N && ((prev >> (i + 1)) & 1)==1){\\n                return false;\\n            }\\n            \\n            if (i - 1 >= 0 && ((prev >> (i - 1)) & 1)==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int M, N;\\n    int[][] dp;\\n    public int maxStudents(char[][] seats) {\\n        int prev = 0;\\n        this.M = seats.length;\\n        this.N = seats[0].length;\\n        dp = new int[M][(1 << N)];\\n        return dfs(0, seats, prev);\\n    }\\n    \\n    private int dfs(int index, char[][] seats, int prev){\\n        \\n        if (index == M) return 0;\\n        \\n        if (dp[index][prev] > 0) return dp[index][prev];\\n        char[] cur = seats[index];\\n        int res = 0;\\n        for (int i = 0; i < (1 << N); i++) {\\n            if (isOkSeatingPlan(i, prev, cur)){\\n                // System.out.println(\"i: \" + i + \" prev: \" + prev);\\n                res = Math.max(res, Integer.bitCount(i) + dfs(index + 1, seats, i)) ;\\n            }\\n        }\\n        return dp[index][prev] = res;\\n    }\\n    \\n    private boolean isOkSeatingPlan(int cur, int prev, char[] A) {\\n                \\n        int preCurBit = 0;\\n        for (int i = 0; i < N; i++) {\\n            int curbit = (cur >> i) & 1;\\n            if (curbit == 0){\\n                continue;\\n            }\\n            // cannot sit at broken seats\\n            if (A[i] != \\'.\\') return false;\\n            // cannot sit side by side\\n            if (i > 0){\\n                preCurBit = (cur >> (i - 1)) & 1;\\n            }\\n            if (curbit == preCurBit) return false;\\n            if (i + 1 < N && ((prev >> (i + 1)) & 1)==1){\\n                return false;\\n            }\\n            \\n            if (i - 1 >= 0 && ((prev >> (i - 1)) & 1)==1){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1975683,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        \\n        // generate a mask for each row in seats\\n        vector<int> availableSeats(m + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i - 1][j] == \\'.\\') {\\n                    availableSeats[i] = availableSeats[i] | (1 << j);\\n                }\\n            }\\n        }\\n        // dp table: [row, mask] the max students given row id ans a mask\\n        vector<vector<int>> dp(m + 1, vector<int>(1 << n, -1));\\n        \\n        // init dp row 0\\n        for (int mask = 0; mask < (1 << n); mask++) dp[0][mask] = 0;\\n        \\n        // for each row\\n        for (int i = 1; i <= m; i++) {\\n            // for mask in the current row\\n            for (int mask = 0; mask < (1 << n); mask++) {\\n                // if the mask is now allowed according to the available seats -> continue\\n                if ((mask & availableSeats[i]) != mask) continue;\\n                // if the mask has two adjacent seats -> continue \\n                if (mask & (mask << 1) || mask & (mask >> 1)) continue;\\n                \\n                // for mask in the prev row\\n                for (int prevMask = 0; prevMask < (1 << n); prevMask++) {\\n                    // if the previous mask does not exist -> continue\\n                    if (dp[i - 1][prevMask] == -1) continue;\\n                    \\n                    // if the previous mask has any seat diagonal to the current mask -> continue\\n                    if (((prevMask << 1) & mask) || ((prevMask >> 1) & mask)) continue;\\n                    \\n                    // update the dp table -> previous # of student + the # of 1 in the current mask\\n                    dp[i][mask] = max(dp[i][mask], dp[i - 1][prevMask] + __builtin_popcount(mask));\\n                }\\n            }\\n        }\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        \\n        // generate a mask for each row in seats\\n        vector<int> availableSeats(m + 1, 0);\\n        for (int i = 1; i <= m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i - 1][j] == \\'.\\') {\\n                    availableSeats[i] = availableSeats[i] | (1 << j);\\n                }\\n            }\\n        }\\n        // dp table: [row, mask] the max students given row id ans a mask\\n        vector<vector<int>> dp(m + 1, vector<int>(1 << n, -1));\\n        \\n        // init dp row 0\\n        for (int mask = 0; mask < (1 << n); mask++) dp[0][mask] = 0;\\n        \\n        // for each row\\n        for (int i = 1; i <= m; i++) {\\n            // for mask in the current row\\n            for (int mask = 0; mask < (1 << n); mask++) {\\n                // if the mask is now allowed according to the available seats -> continue\\n                if ((mask & availableSeats[i]) != mask) continue;\\n                // if the mask has two adjacent seats -> continue \\n                if (mask & (mask << 1) || mask & (mask >> 1)) continue;\\n                \\n                // for mask in the prev row\\n                for (int prevMask = 0; prevMask < (1 << n); prevMask++) {\\n                    // if the previous mask does not exist -> continue\\n                    if (dp[i - 1][prevMask] == -1) continue;\\n                    \\n                    // if the previous mask has any seat diagonal to the current mask -> continue\\n                    if (((prevMask << 1) & mask) || ((prevMask >> 1) & mask)) continue;\\n                    \\n                    // update the dp table -> previous # of student + the # of 1 in the current mask\\n                    dp[i][mask] = max(dp[i][mask], dp[i - 1][prevMask] + __builtin_popcount(mask));\\n                }\\n            }\\n        }\\n        return *max_element(dp[m].begin(), dp[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941848,
                "title": "python-easy-understood-solution-with-o-m-n-2-n-follow-the-problem-description",
                "content": "code is enough:\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats),len(seats[0])\\n        def cutmask(mask):\\n            #only (n+1) bit information is needed \\n            return mask - (mask & 1<<10)\\n        \\n        def valid(i,j,mask):\\n            #check if (i,j) is valid with given mask\\n            if j>0 and mask & 1==1:\\n                return False\\n            if j<n-1 and i>0 and mask&(1<<(n-2))>0:\\n                return False\\n            if j>0 and i>0 and mask&(1<<(n))>0:\\n                return False\\n            return True\\n        \\n        @cache\\n        def dfs(i,j,mask):\\n            if i==m:\\n                return 0\\n            ni,nj = i,j+1\\n            if nj==n:\\n                ni,nj = i+1,0\\n            if seats[i][j]==\\'#\\':\\n                return dfs(ni,nj,mask<<1)\\n            return max(dfs(ni,nj,cutmask(mask<<1) ),(dfs(ni,nj,cutmask((mask<<1)+1))+1) if valid(i,j,mask) else 0)\\n            \\n        return dfs(0,0,0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats),len(seats[0])\\n        def cutmask(mask):\\n            #only (n+1) bit information is needed \\n            return mask - (mask & 1<<10)\\n        \\n        def valid(i,j,mask):\\n            #check if (i,j) is valid with given mask\\n            if j>0 and mask & 1==1:\\n                return False\\n            if j<n-1 and i>0 and mask&(1<<(n-2))>0:\\n                return False\\n            if j>0 and i>0 and mask&(1<<(n))>0:\\n                return False\\n            return True\\n        \\n        @cache\\n        def dfs(i,j,mask):\\n            if i==m:\\n                return 0\\n            ni,nj = i,j+1\\n            if nj==n:\\n                ni,nj = i+1,0\\n            if seats[i][j]==\\'#\\':\\n                return dfs(ni,nj,mask<<1)\\n            return max(dfs(ni,nj,cutmask(mask<<1) ),(dfs(ni,nj,cutmask((mask<<1)+1))+1) if valid(i,j,mask) else 0)\\n            \\n        return dfs(0,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1928816,
                "title": "bit-mask",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        @cache\\n        def tot(i=0,j=0,pb=0,nb=0):\\n            if j>=len(seats[0]):\\n                pb,nb=nb,0\\n                i,j=i+1,0\\n            if i==len(seats):return 0\\n            if seats[i][j]==\\'.\\':\\n                f=tot(i,j+1,pb,nb)\\n                if (j>0 and (pb & (1<<(j-1))))  or (pb & 1<<(j+1)) :\\n                    return f\\n                nb=nb | (1<<j)\\n                return max(f,1+tot(i,j+2,pb,nb))\\n            return tot(i,j+1,pb,nb)\\n        return tot()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        @cache\\n        def tot(i=0,j=0,pb=0,nb=0):\\n            if j>=len(seats[0]):\\n                pb,nb=nb,0\\n                i,j=i+1,0\\n            if i==len(seats):return 0\\n            if seats[i][j]==\\'.\\':\\n                f=tot(i,j+1,pb,nb)\\n                if (j>0 and (pb & (1<<(j-1))))  or (pb & 1<<(j+1)) :\\n                    return f\\n                nb=nb | (1<<j)\\n                return max(f,1+tot(i,j+2,pb,nb))\\n            return tot(i,j+1,pb,nb)\\n        return tot()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899957,
                "title": "python-bitmasking-dp-solution-with-explanation",
                "content": "```python\\nclass Solution:\\n    def maxStudents(self, seats: list[list[str]]) -> int:\\n        def count_bits(num: int) -> int:\\n            # Count how many bits having value 1 in num.\\n            cnt = 0\\n            while num:\\n                cnt += 1\\n                num &= num - 1\\n\\n            return cnt\\n\\n        R, C = len(seats), len(seats[0])\\n        validSeats = []\\n\\n        # Calculate valid seats mask for each row.\\n        for row in seats:\\n            curr = 0\\n            for seat in row:\\n                curr = (curr << 1) + (seat == \\'.\\')\\n\\n            validSeats.append(curr)\\n\\n        # dp[i][mask] stands for the maximum students on ith row with students\\n        # following the mask.\\n        dp = [[-1] * (1 << C) for _ in range(R + 1)]\\n        dp[0][0] = 0\\n        for r in range(1, R + 1):\\n            seatMask = validSeats[r - 1]\\n            for studentMask in range(1 << C):\\n                validBits = count_bits(studentMask)\\n\\n                # 1. Check if a student mask is a subset of seatMask so that\\n                #   the target student could sit on a seat.\\n                # 2. The student should not sit next to each other.\\n                if (\\n                    studentMask & seatMask == studentMask and\\n                    studentMask & (studentMask >> 1) == 0\\n                ):\\n                    # Then check the upper student mask and make sure that\\n                    # 1. no student is on the upper left.\\n                    # 2. no student is on the upper right.\\n                    # Then the upper mask is a valid candidate for the current\\n                    # student mask.\\n                    for upperStudentMask in range(1 << C):\\n                        if (\\n                            studentMask & (upperStudentMask >> 1) == 0 and\\n                            studentMask & (upperStudentMask << 1) == 0 and\\n                            dp[r - 1][upperStudentMask] != -1\\n                        ):\\n                            dp[r][studentMask] = max(\\n                                dp[r][studentMask],\\n                                dp[r - 1][upperStudentMask] + validBits\\n                            )\\n\\n        return max(dp[-1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxStudents(self, seats: list[list[str]]) -> int:\\n        def count_bits(num: int) -> int:\\n            # Count how many bits having value 1 in num.\\n            cnt = 0\\n            while num:\\n                cnt += 1\\n                num &= num - 1\\n\\n            return cnt\\n\\n        R, C = len(seats), len(seats[0])\\n        validSeats = []\\n\\n        # Calculate valid seats mask for each row.\\n        for row in seats:\\n            curr = 0\\n            for seat in row:\\n                curr = (curr << 1) + (seat == \\'.\\')\\n\\n            validSeats.append(curr)\\n\\n        # dp[i][mask] stands for the maximum students on ith row with students\\n        # following the mask.\\n        dp = [[-1] * (1 << C) for _ in range(R + 1)]\\n        dp[0][0] = 0\\n        for r in range(1, R + 1):\\n            seatMask = validSeats[r - 1]\\n            for studentMask in range(1 << C):\\n                validBits = count_bits(studentMask)\\n\\n                # 1. Check if a student mask is a subset of seatMask so that\\n                #   the target student could sit on a seat.\\n                # 2. The student should not sit next to each other.\\n                if (\\n                    studentMask & seatMask == studentMask and\\n                    studentMask & (studentMask >> 1) == 0\\n                ):\\n                    # Then check the upper student mask and make sure that\\n                    # 1. no student is on the upper left.\\n                    # 2. no student is on the upper right.\\n                    # Then the upper mask is a valid candidate for the current\\n                    # student mask.\\n                    for upperStudentMask in range(1 << C):\\n                        if (\\n                            studentMask & (upperStudentMask >> 1) == 0 and\\n                            studentMask & (upperStudentMask << 1) == 0 and\\n                            dp[r - 1][upperStudentMask] != -1\\n                        ):\\n                            dp[r][studentMask] = max(\\n                                dp[r][studentMask],\\n                                dp[r - 1][upperStudentMask] + validBits\\n                            )\\n\\n        return max(dp[-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884273,
                "title": "neat-dp-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[9][500];\\n    bool valid(int prevMask,int currMask,int row,vector<vector<char>>& seats){\\n        int n=seats[0].size();\\n        for(int i=0;i<n;i++){\\n            if(seats[row][i]==\\'#\\' && ((currMask)&(1<<i))){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(currMask&(1<<i)){\\n                if(i>=1){\\n                    if((currMask&(1<<(i-1))) || (prevMask&(1<<(i-1))))\\n                        return false;\\n                }\\n                if(i<n-1){\\n                    if((currMask&(1<<(i+1))) || (prevMask&(1<<(i+1))))\\n                        return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int helper(int row,int mask,vector<vector<char>>& seats){\\n        //dp state=(current row, previous row mask)\\n        if(row==seats.size())\\n            return 0;\\n        int n=seats[0].size();\\n        int ans=0;\\n        if(dp[row][mask]!=-1)\\n            return dp[row][mask];\\n        for(int currmask=0;currmask<(1<<n);currmask++){\\n            if(valid(mask,currmask,row,seats)){\\n                ans=max(ans,__builtin_popcount(currmask)+\\n                        helper(row+1,currmask,seats));\\n            }\\n        }\\n        return dp[row][mask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<500;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return helper(0,0,seats);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[9][500];\\n    bool valid(int prevMask,int currMask,int row,vector<vector<char>>& seats){\\n        int n=seats[0].size();\\n        for(int i=0;i<n;i++){\\n            if(seats[row][i]==\\'#\\' && ((currMask)&(1<<i))){\\n                return false;\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(currMask&(1<<i)){\\n                if(i>=1){\\n                    if((currMask&(1<<(i-1))) || (prevMask&(1<<(i-1))))\\n                        return false;\\n                }\\n                if(i<n-1){\\n                    if((currMask&(1<<(i+1))) || (prevMask&(1<<(i+1))))\\n                        return false;\\n                } \\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int helper(int row,int mask,vector<vector<char>>& seats){\\n        //dp state=(current row, previous row mask)\\n        if(row==seats.size())\\n            return 0;\\n        int n=seats[0].size();\\n        int ans=0;\\n        if(dp[row][mask]!=-1)\\n            return dp[row][mask];\\n        for(int currmask=0;currmask<(1<<n);currmask++){\\n            if(valid(mask,currmask,row,seats)){\\n                ans=max(ans,__builtin_popcount(currmask)+\\n                        helper(row+1,currmask,seats));\\n            }\\n        }\\n        return dp[row][mask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        for(int i=0;i<9;i++){\\n            for(int j=0;j<500;j++){\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return helper(0,0,seats);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747788,
                "title": "dp-with-bitmasking",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[10][1 << 10];\\n\\n\\tvoid generateAllBitMasks(int i, int j, vector<int> &bitMasks, int prevBitMask, int currentBitMask, vector<vector<char>> &seats, int &cols) {\\n\\t\\tif (j == cols) {\\n\\t\\t\\tbitMasks.push_back(currentBitMask);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\\n\\n\\t\\tgenerateAllBitMasks(i, j + 1, bitMasks, prevBitMask, currentBitMask, seats, cols);\\n\\t\\t\\n\\t\\tif (seats[i][j] == \\'.\\'\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == 0 || !(prevBitMask & (1 << (j - 1))))\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == cols - 1 || !(prevBitMask & (1 << (j + 1))))\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == 0 || !(currentBitMask & (1 << (j - 1))))\\n\\t\\t   )\\n\\n\\t\\t{\\n\\t\\t\\tgenerateAllBitMasks(i, j + 1, bitMasks, prevBitMask, currentBitMask | (1 << j), seats, cols);\\n\\t\\t}\\n\\n\\t}\\n\\n\\n\\tint solve(int i, int prevBitMask, int &rows, int &cols, vector<vector<char>> &seats) {\\n\\t\\tif (i == rows) return 0;\\n\\n\\n\\t\\tif (dp[i][prevBitMask] != -1) return dp[i][prevBitMask];\\n\\n\\t\\tvector<int> bitMasks; int currentBitMask = 0;\\n\\t\\tgenerateAllBitMasks(i, 0, bitMasks, prevBitMask, currentBitMask, seats, cols);\\n\\n\\t\\tint curAns = 0;\\n\\n\\t\\tfor (int bitMask : bitMasks) {\\n\\t\\t\\tint x = __builtin_popcount(bitMask) + solve(i + 1, bitMask, rows, cols, seats);\\n\\t\\t\\tcurAns = max(curAns, x);\\n\\t\\t}\\n\\n\\t\\treturn dp[i][prevBitMask] = curAns;\\n\\t}\\n\\tint maxStudents(vector<vector<char>>& seats) {\\n\\t\\tint rows = seats.size();\\n\\t\\tint cols = seats[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn solve(0, 0, rows, cols, seats);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\tint dp[10][1 << 10];\\n\\n\\tvoid generateAllBitMasks(int i, int j, vector<int> &bitMasks, int prevBitMask, int currentBitMask, vector<vector<char>> &seats, int &cols) {\\n\\t\\tif (j == cols) {\\n\\t\\t\\tbitMasks.push_back(currentBitMask);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t\\n\\n\\t\\tgenerateAllBitMasks(i, j + 1, bitMasks, prevBitMask, currentBitMask, seats, cols);\\n\\t\\t\\n\\t\\tif (seats[i][j] == \\'.\\'\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == 0 || !(prevBitMask & (1 << (j - 1))))\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == cols - 1 || !(prevBitMask & (1 << (j + 1))))\\n\\n\\t\\t        &&\\n\\n\\t\\t        (j == 0 || !(currentBitMask & (1 << (j - 1))))\\n\\t\\t   )\\n\\n\\t\\t{\\n\\t\\t\\tgenerateAllBitMasks(i, j + 1, bitMasks, prevBitMask, currentBitMask | (1 << j), seats, cols);\\n\\t\\t}\\n\\n\\t}\\n\\n\\n\\tint solve(int i, int prevBitMask, int &rows, int &cols, vector<vector<char>> &seats) {\\n\\t\\tif (i == rows) return 0;\\n\\n\\n\\t\\tif (dp[i][prevBitMask] != -1) return dp[i][prevBitMask];\\n\\n\\t\\tvector<int> bitMasks; int currentBitMask = 0;\\n\\t\\tgenerateAllBitMasks(i, 0, bitMasks, prevBitMask, currentBitMask, seats, cols);\\n\\n\\t\\tint curAns = 0;\\n\\n\\t\\tfor (int bitMask : bitMasks) {\\n\\t\\t\\tint x = __builtin_popcount(bitMask) + solve(i + 1, bitMask, rows, cols, seats);\\n\\t\\t\\tcurAns = max(curAns, x);\\n\\t\\t}\\n\\n\\t\\treturn dp[i][prevBitMask] = curAns;\\n\\t}\\n\\tint maxStudents(vector<vector<char>>& seats) {\\n\\t\\tint rows = seats.size();\\n\\t\\tint cols = seats[0].size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\t\\treturn solve(0, 0, rows, cols, seats);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1741657,
                "title": "brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int n,m;\\n    \\n    int maxS(vector<vector<char>>& seats,int i,int mask,vector<vector<int>>& dp){\\n        if(i==n) return 0;\\n         \\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=0;\\n        for(int nmask=0;nmask< (1<<m) ; nmask++  ){\\n            \\n            bool flag=1;\\n            \\n            int students=0;\\n            for(int j=0;j<m;j++){\\n                \\n                if( nmask&(1<<j) ){\\n                    if(seats[i][j]==\\'#\\') flag=0;\\n                    if(j!=0  &&  (nmask&(1<<(j-1))) ) flag=0;\\n                    if(j!=m-1 &&  (nmask&(1<<(j+1))) ) flag=0;\\n                    if(j!=0 &&  (mask&(1<<(j-1))) )  flag=0;\\n                    if(j!=m-1 &&  (mask&(1<<(j+1))) ) flag=0;\\n                    students++;\\n                    \\n                } \\n                \\n            }\\n            if(flag) ans=max(ans,students+ maxS(seats,i+1,nmask,dp));\\n            \\n        }\\n         \\n        return  dp[i][mask]=ans;\\n         \\n    }\\n        \\n         \\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        n=seats.size();\\n        m=seats[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>((1<<m),-1));\\n        \\n        return maxS(seats,0,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int n,m;\\n    \\n    int maxS(vector<vector<char>>& seats,int i,int mask,vector<vector<int>>& dp){\\n        if(i==n) return 0;\\n         \\n        if(dp[i][mask]!=-1) return dp[i][mask];\\n        int ans=0;\\n        for(int nmask=0;nmask< (1<<m) ; nmask++  ){\\n            \\n            bool flag=1;\\n            \\n            int students=0;\\n            for(int j=0;j<m;j++){\\n                \\n                if( nmask&(1<<j) ){\\n                    if(seats[i][j]==\\'#\\') flag=0;\\n                    if(j!=0  &&  (nmask&(1<<(j-1))) ) flag=0;\\n                    if(j!=m-1 &&  (nmask&(1<<(j+1))) ) flag=0;\\n                    if(j!=0 &&  (mask&(1<<(j-1))) )  flag=0;\\n                    if(j!=m-1 &&  (mask&(1<<(j+1))) ) flag=0;\\n                    students++;\\n                    \\n                } \\n                \\n            }\\n            if(flag) ans=max(ans,students+ maxS(seats,i+1,nmask,dp));\\n            \\n        }\\n         \\n        return  dp[i][mask]=ans;\\n         \\n    }\\n        \\n         \\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        n=seats.size();\\n        m=seats[0].size();\\n        \\n        vector<vector<int>> dp(n,vector<int>((1<<m),-1));\\n        \\n        return maxS(seats,0,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734630,
                "title": "c-two-solutions-optimized-bitmask-dp-and-hopcroft-karp-bipartite-mis",
                "content": "**Optimized Top-Down bitmask DP**\\nWe only need to store the seats in the previous row that are located at columns [y - 1...N - 1] in the bitmask. We also only need to store the seats placed in [0...y - 1] in the current row. Notice that there is overlap only at position (y - 1). So we only need a bitmask of N bits plus a boolean for the overlap at position (y - 1). So instead of two bitmasks of size 2^columns for the current and upper row, we use one bitmask of size 2^columns to contain all necessary information of the current and upper row, plus a boolean for our DP state to reach *O(N * M * 2^(M + 1))*.\\n\\n```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int DP[8][8][2][1 << 8];\\n    \\n    bool valid(const int x, const int y, const bool left, const int bm) {\\n        if (y > 0 && (left || (bm & (1 << (y - 1)))))\\n            return false;\\n        if (y + 1 < n && (bm & (1 << (y + 1))))\\n            return false;\\n        return true;\\n    }\\n    \\n    int insertLeftInBm(const int y, const bool left, int bm) {\\n        if (y == 0)\\n            return bm;\\n        if (!left && (bm & (1 << (y - 1))))\\n            bm -= (1 << (y - 1));            \\n        else if (left && !(bm & (1 << (y - 1))))\\n            bm += (1 << (y - 1));\\n        return bm;\\n    }\\n    \\n    int solve(const int x, const int y, const bool left, const int bm, const vector<vector<char>>& seats) {\\n        if (x == m)\\n            return 0;\\n        if (y == n)\\n            return solve(x + 1, 0, 0, insertLeftInBm(y, left, bm), seats);\\n        else if (DP[x][y][left][bm] != -1)\\n            return DP[x][y][left][bm];\\n        DP[x][y][left][bm] = solve(x, y + 1, false, insertLeftInBm(y, left, bm), seats);\\n        if (seats[x][y] != \\'#\\' && valid(x, y, left, bm))\\n            DP[x][y][left][bm] = max(DP[x][y][left][bm], 1 + solve(x, y + 1, true, insertLeftInBm(y, left, bm), seats));\\n        return DP[x][y][left][bm];\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        m = int(seats.size());\\n        n = int(seats[0].size());\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 0, seats);\\n    }\\n};\\n```\\n\\n\\n**We can do better: bipartite matching Maximum Independent Set**\\nActually an even better complexity can be reached using a maximum flow algorithm to find the maximum independent set. We can transform the input array into a bipartite graph, with edges between seats that cannot be both in the solution. The resulting graph will be bipartite as it is possible to color columns with two colors alternatively (0-1-0-1-0-1-0-1) and building the graph as follows: \\n*  Place all the seats in columns of color 0 on the left side.\\n* Place all seats in columns of color 1 on the right side.\\n* For each two seats that cannot be both in the solution, add an edge between their corresponding vertices.\\n\\nIt is not possible to have an edge connecting seats in columns of the same color, as seats in the same column are independent on each other, and seats in two different columns with at least one column in between are also not dependent on each other. We can now find the answer by calculating the maximum independent set (MIS) of the bipartite graph, which is equal to |Seats| - MCBM (Maximum cardinality bipartite matching). I have used the Hopcroft-Karp algorithm to calculate the answer in just *O(E * \\u221A(|seats|))*, where E is the number of edges. If you are not familiair with bipartite matching, there are tutorials available to study this topic, for example [here](https://ali-ibrahim137.github.io/competitive/programming/2020/01/02/maximum-independent-set-in-bipartite-graphs.html).\\n\\n```\\ntypedef long long LL;\\ntypedef pair<int, int> ii;\\nconst int INF = 1e9;\\nconst int MAXN = 100;\\n\\nconst int DX[6] = {0, -1, -1, 0, 1, 1};\\nconst int DY[6] = {-1, -1, 1, 1, -1, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> edges;\\n\\n    int N;\\n    bool matched[MAXN];\\n    int dist[MAXN];\\n    int matching[MAXN];\\n\\n    bool BFS() {\\n       queue<int> Q;\\n       bool flag = false;\\n\\n       for (int i = 0; i < N; i++) {\\n          if (!matched[i]) {\\n             Q.push(i);\\n             dist[i] = 0;\\n          }\\n          else\\n             dist[i] = INF;\\n       }\\n       while (!Q.empty()) {\\n          int l = Q.front();\\n          Q.pop();\\n          for (int r : edges[l]) {\\n             if (matching[r] != -1) {\\n                if (dist[matching[r]] == INF) {\\n                   dist[matching[r]] = dist[l] + 1;\\n                   Q.push(matching[r]);\\n                }\\n             }\\n             else\\n                flag = true;\\n          }\\n       }\\n       return flag;\\n    }\\n\\n    bool DFS(const int l) {\\n       for (int r : edges[l]) {\\n          if (matching[r] == -1) {\\n             matched[l] = 1;\\n             matching[r] = l;\\n             return true;\\n          }\\n          if (dist[matching[r]] == dist[l] + 1) {\\n             if (DFS(matching[r])) {\\n                matched[l] = 1;\\n                matching[r] = l;\\n                return true;\\n             }\\n          }\\n       }\\n       dist[l] = INF;\\n       return false;\\n    }\\n\\n    int HopcroftKarp() {\\n       memset(matched, 0, sizeof(matched));\\n       memset(matching, -1, sizeof(matching));\\n       int mf = 0;\\n       while (BFS()) {\\n          for (int i = 0; i < N; i++) {\\n             if (!matched[i])\\n                mf += DFS(i);\\n          }\\n       }\\n       return mf;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        N = int(seats.size()) * int(seats[0].size());\\n        edges.assign(N, vector<int>());        \\n        int totSeats = 0;\\n        for (int i = 0; i < int(seats.size()); i++) {\\n            for (int j = 0; j < int(seats[0].size()); j++) {\\n                if (seats[i][j] == \\'.\\') {\\n                    totSeats++;\\n                    if (j % 2 == 1)\\n                        continue;\\n                    int idxFrom = i * int(seats[0].size()) + j;\\n                    for (int k = 0; k < 6; k++) {\\n                        int nx = i + DX[k];\\n                        int ny = j + DY[k];\\n                        if (nx >= 0 && nx < int(seats.size()) && ny >= 0 && ny < int(seats[0].size()) && seats[nx][ny] == \\'.\\') {\\n                            int idxTo = nx * int(seats[0].size()) + ny;\\n                            edges[idxFrom].push_back(idxTo);\\n                        }\\n                    }\\n                }                \\n            }\\n        }\\n        return totSeats - HopcroftKarp();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n, m;\\n    int DP[8][8][2][1 << 8];\\n    \\n    bool valid(const int x, const int y, const bool left, const int bm) {\\n        if (y > 0 && (left || (bm & (1 << (y - 1)))))\\n            return false;\\n        if (y + 1 < n && (bm & (1 << (y + 1))))\\n            return false;\\n        return true;\\n    }\\n    \\n    int insertLeftInBm(const int y, const bool left, int bm) {\\n        if (y == 0)\\n            return bm;\\n        if (!left && (bm & (1 << (y - 1))))\\n            bm -= (1 << (y - 1));            \\n        else if (left && !(bm & (1 << (y - 1))))\\n            bm += (1 << (y - 1));\\n        return bm;\\n    }\\n    \\n    int solve(const int x, const int y, const bool left, const int bm, const vector<vector<char>>& seats) {\\n        if (x == m)\\n            return 0;\\n        if (y == n)\\n            return solve(x + 1, 0, 0, insertLeftInBm(y, left, bm), seats);\\n        else if (DP[x][y][left][bm] != -1)\\n            return DP[x][y][left][bm];\\n        DP[x][y][left][bm] = solve(x, y + 1, false, insertLeftInBm(y, left, bm), seats);\\n        if (seats[x][y] != \\'#\\' && valid(x, y, left, bm))\\n            DP[x][y][left][bm] = max(DP[x][y][left][bm], 1 + solve(x, y + 1, true, insertLeftInBm(y, left, bm), seats));\\n        return DP[x][y][left][bm];\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        m = int(seats.size());\\n        n = int(seats[0].size());\\n        memset(DP, -1, sizeof(DP));\\n        return solve(0, 0, 0, 0, seats);\\n    }\\n};\\n```\n```\\ntypedef long long LL;\\ntypedef pair<int, int> ii;\\nconst int INF = 1e9;\\nconst int MAXN = 100;\\n\\nconst int DX[6] = {0, -1, -1, 0, 1, 1};\\nconst int DY[6] = {-1, -1, 1, 1, -1, 1};\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> edges;\\n\\n    int N;\\n    bool matched[MAXN];\\n    int dist[MAXN];\\n    int matching[MAXN];\\n\\n    bool BFS() {\\n       queue<int> Q;\\n       bool flag = false;\\n\\n       for (int i = 0; i < N; i++) {\\n          if (!matched[i]) {\\n             Q.push(i);\\n             dist[i] = 0;\\n          }\\n          else\\n             dist[i] = INF;\\n       }\\n       while (!Q.empty()) {\\n          int l = Q.front();\\n          Q.pop();\\n          for (int r : edges[l]) {\\n             if (matching[r] != -1) {\\n                if (dist[matching[r]] == INF) {\\n                   dist[matching[r]] = dist[l] + 1;\\n                   Q.push(matching[r]);\\n                }\\n             }\\n             else\\n                flag = true;\\n          }\\n       }\\n       return flag;\\n    }\\n\\n    bool DFS(const int l) {\\n       for (int r : edges[l]) {\\n          if (matching[r] == -1) {\\n             matched[l] = 1;\\n             matching[r] = l;\\n             return true;\\n          }\\n          if (dist[matching[r]] == dist[l] + 1) {\\n             if (DFS(matching[r])) {\\n                matched[l] = 1;\\n                matching[r] = l;\\n                return true;\\n             }\\n          }\\n       }\\n       dist[l] = INF;\\n       return false;\\n    }\\n\\n    int HopcroftKarp() {\\n       memset(matched, 0, sizeof(matched));\\n       memset(matching, -1, sizeof(matching));\\n       int mf = 0;\\n       while (BFS()) {\\n          for (int i = 0; i < N; i++) {\\n             if (!matched[i])\\n                mf += DFS(i);\\n          }\\n       }\\n       return mf;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        N = int(seats.size()) * int(seats[0].size());\\n        edges.assign(N, vector<int>());        \\n        int totSeats = 0;\\n        for (int i = 0; i < int(seats.size()); i++) {\\n            for (int j = 0; j < int(seats[0].size()); j++) {\\n                if (seats[i][j] == \\'.\\') {\\n                    totSeats++;\\n                    if (j % 2 == 1)\\n                        continue;\\n                    int idxFrom = i * int(seats[0].size()) + j;\\n                    for (int k = 0; k < 6; k++) {\\n                        int nx = i + DX[k];\\n                        int ny = j + DY[k];\\n                        if (nx >= 0 && nx < int(seats.size()) && ny >= 0 && ny < int(seats[0].size()) && seats[nx][ny] == \\'.\\') {\\n                            int idxTo = nx * int(seats[0].size()) + ny;\\n                            edges[idxFrom].push_back(idxTo);\\n                        }\\n                    }\\n                }                \\n            }\\n        }\\n        return totSeats - HopcroftKarp();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640976,
                "title": "java-solution-with-max-flow-edmond-karp-algorithm",
                "content": "Max Independent Set of Nodes for Bipartie Graph = Number of Nodes - Maximum Cardinality Matching in Bipartite Graphs\\nMaximum Cardinality Matching in Bipartite Graphs can be transformed to max flow problem and solved by Edmond Karp/Ford Fulkerson/Dinic Algorithm.\\n\\n\\n```\\nclass Solution {\\n//     int[][] dp;\\n//     public int maxStudents(char[][] seats) {\\n//         int m = seats.length, n = seats[0].length;\\n//         dp = new int[m][1<<n];\\n//         for(int i = 0; i < m; i++)\\n//         {\\n//             Arrays.fill(dp[i], -1);\\n//         }\\n//         return dfs(seats, 0, 0);\\n//     }\\n    \\n//     public int dfs(char[][] seats, int ind, int prev)\\n//     {\\n//         if(ind==seats.length)return 0;\\n//         int res = 0;\\n//         if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        \\n//         int forbiddened = 0;\\n//         for(int i = 0; i < seats[0].length; i++)\\n//         {\\n//             int temp = prev & (1<<i);\\n//             if(temp!=0)\\n//             {\\n//                 if (i>=1)\\n//                 {\\n//                     forbiddened |= (1<<(i-1));\\n//                 }\\n                \\n//                 if (i+1<seats[0].length)\\n//                 {\\n//                     forbiddened |= (1<<(i+1));\\n//                 }\\n//             }\\n            \\n//             if(seats[ind][i] == \\'#\\')\\n//             {\\n//                 forbiddened |= (1<<i);\\n//             }\\n//         }\\n        \\n//         for(int i = 0; i < (1 << seats[0].length); i++)\\n//         {\\n//             boolean isValid = true;\\n//             int cnt = 0;\\n//             for(int j = 0; j < seats[0].length; j++)\\n//             {\\n//                 int temp1 = forbiddened & (1<<j);\\n//                 int temp2 = i & (1<<j);\\n//                 int temp3 = j >= 1 ? i & (1<<(j-1)) : 0;\\n//                 int temp4 = j + 1 <seats[0].length ? i & (1<<(j+1)) : 0;\\n//                 if(temp1!=0&&temp2!=0)\\n//                 {\\n//                     isValid = false;\\n//                     break;\\n//                 }\\n                \\n//                 if((temp3!=0||temp4!=0)&&temp2!=0)\\n//                 {\\n//                     isValid = false;\\n//                     break;\\n//                 }\\n                \\n//                 if(temp2!=0)\\n//                 {\\n//                     cnt++;\\n//                 }\\n//             }\\n            \\n//             if(isValid)\\n//             {\\n//                 res = Math.max(res, cnt+dfs(seats, ind+1, i));\\n//             }\\n//         }\\n        \\n//         dp[ind][prev] = res;\\n//         return res;\\n//     }\\n    \\n    int[][] residual;\\n    int[] pre;\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length, n = seats[0].length;\\n        residual = new int[m*n + 2][m*n + 2];\\n        int S = m*n, T = m*n+1;\\n        int[][] dirs = {{0,-1},{0,1},{-1,-1},{-1,1},{1,1},{1,-1}};\\n        int validseats = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int ind = i * n + j;\\n                if(seats[i][j]==\\'#\\')continue;\\n                validseats++;\\n                if(j%2==0)\\n                {\\n                    residual[S][ind] = 1;\\n                    for(int[] dir: dirs)\\n                    {\\n                        int nx = i+dir[0], ny = j+dir[1];\\n                        if(nx<0||nx>=m||ny<0||ny>=n||seats[nx][ny]==\\'#\\')continue;\\n                        int nind = nx*n + ny;\\n                        residual[ind][nind] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    residual[ind][T] = 1;\\n                }\\n            }\\n        }\\n        \\n        int count = maxflow(residual, m*n, m*n+1);\\n        return validseats - count;\\n    }\\n    \\n    public int maxflow(int[][] residual, int S, int T)\\n    {\\n        int res = 0;\\n        while(true)\\n        {\\n            int[] pre = new int[residual.length];\\n            Arrays.fill(pre, -1);\\n            bfs(residual, pre, S, T);\\n            if(pre[T] == -1)break;\\n            int cur = T;\\n            while(cur!=S)\\n            {\\n                residual[pre[cur]][cur]--;\\n                residual[cur][pre[cur]]++;\\n                cur = pre[cur];\\n            }\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void bfs(int[][] residual, int[] pre, int S, int T)\\n    {\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        queue.offer(S);\\n        while(!queue.isEmpty())\\n        {\\n            int cur = queue.poll();\\n            for(int i = 0; i < residual[cur].length; i++)\\n            {\\n                if(residual[cur][i]>0 && !visited.contains(i))\\n                {\\n                    visited.add(i);\\n                    queue.offer(i);\\n                    pre[i] = cur;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n//     int[][] dp;\\n//     public int maxStudents(char[][] seats) {\\n//         int m = seats.length, n = seats[0].length;\\n//         dp = new int[m][1<<n];\\n//         for(int i = 0; i < m; i++)\\n//         {\\n//             Arrays.fill(dp[i], -1);\\n//         }\\n//         return dfs(seats, 0, 0);\\n//     }\\n    \\n//     public int dfs(char[][] seats, int ind, int prev)\\n//     {\\n//         if(ind==seats.length)return 0;\\n//         int res = 0;\\n//         if(dp[ind][prev]!=-1)return dp[ind][prev];\\n        \\n//         int forbiddened = 0;\\n//         for(int i = 0; i < seats[0].length; i++)\\n//         {\\n//             int temp = prev & (1<<i);\\n//             if(temp!=0)\\n//             {\\n//                 if (i>=1)\\n//                 {\\n//                     forbiddened |= (1<<(i-1));\\n//                 }\\n                \\n//                 if (i+1<seats[0].length)\\n//                 {\\n//                     forbiddened |= (1<<(i+1));\\n//                 }\\n//             }\\n            \\n//             if(seats[ind][i] == \\'#\\')\\n//             {\\n//                 forbiddened |= (1<<i);\\n//             }\\n//         }\\n        \\n//         for(int i = 0; i < (1 << seats[0].length); i++)\\n//         {\\n//             boolean isValid = true;\\n//             int cnt = 0;\\n//             for(int j = 0; j < seats[0].length; j++)\\n//             {\\n//                 int temp1 = forbiddened & (1<<j);\\n//                 int temp2 = i & (1<<j);\\n//                 int temp3 = j >= 1 ? i & (1<<(j-1)) : 0;\\n//                 int temp4 = j + 1 <seats[0].length ? i & (1<<(j+1)) : 0;\\n//                 if(temp1!=0&&temp2!=0)\\n//                 {\\n//                     isValid = false;\\n//                     break;\\n//                 }\\n                \\n//                 if((temp3!=0||temp4!=0)&&temp2!=0)\\n//                 {\\n//                     isValid = false;\\n//                     break;\\n//                 }\\n                \\n//                 if(temp2!=0)\\n//                 {\\n//                     cnt++;\\n//                 }\\n//             }\\n            \\n//             if(isValid)\\n//             {\\n//                 res = Math.max(res, cnt+dfs(seats, ind+1, i));\\n//             }\\n//         }\\n        \\n//         dp[ind][prev] = res;\\n//         return res;\\n//     }\\n    \\n    int[][] residual;\\n    int[] pre;\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length, n = seats[0].length;\\n        residual = new int[m*n + 2][m*n + 2];\\n        int S = m*n, T = m*n+1;\\n        int[][] dirs = {{0,-1},{0,1},{-1,-1},{-1,1},{1,1},{1,-1}};\\n        int validseats = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int ind = i * n + j;\\n                if(seats[i][j]==\\'#\\')continue;\\n                validseats++;\\n                if(j%2==0)\\n                {\\n                    residual[S][ind] = 1;\\n                    for(int[] dir: dirs)\\n                    {\\n                        int nx = i+dir[0], ny = j+dir[1];\\n                        if(nx<0||nx>=m||ny<0||ny>=n||seats[nx][ny]==\\'#\\')continue;\\n                        int nind = nx*n + ny;\\n                        residual[ind][nind] = 1;\\n                    }\\n                }\\n                else\\n                {\\n                    residual[ind][T] = 1;\\n                }\\n            }\\n        }\\n        \\n        int count = maxflow(residual, m*n, m*n+1);\\n        return validseats - count;\\n    }\\n    \\n    public int maxflow(int[][] residual, int S, int T)\\n    {\\n        int res = 0;\\n        while(true)\\n        {\\n            int[] pre = new int[residual.length];\\n            Arrays.fill(pre, -1);\\n            bfs(residual, pre, S, T);\\n            if(pre[T] == -1)break;\\n            int cur = T;\\n            while(cur!=S)\\n            {\\n                residual[pre[cur]][cur]--;\\n                residual[cur][pre[cur]]++;\\n                cur = pre[cur];\\n            }\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void bfs(int[][] residual, int[] pre, int S, int T)\\n    {\\n        Queue<Integer> queue = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        queue.offer(S);\\n        while(!queue.isEmpty())\\n        {\\n            int cur = queue.poll();\\n            for(int i = 0; i < residual[cur].length; i++)\\n            {\\n                if(residual[cur][i]>0 && !visited.contains(i))\\n                {\\n                    visited.add(i);\\n                    queue.offer(i);\\n                    pre[i] = cur;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574078,
                "title": "python-some-fancy-bits-manipulation-techniques",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, seats):\\n        seats.reverse()\\n        memo, n, m = {}, len(seats), len(seats[0])\\n        seats_bits = [sum(1 << j for j in range(m) if seats[i][j] == \\'#\\') for i in range(n)]\\n        next_row_occupation = lambda b: b << 1 | b >> 1\\n        can_sit = lambda b: not any(b & 1 << i and b & 1 << (i + 1) for i in range(m - 1))\\n\\n        # i-th row and bits you cant place\\n        def rec(i = 0, occupied = 0):\\n            if i == n: return 0\\n            if (i, occupied) not in memo:\\n                memo[(i, occupied)] = max(bin(b).count(\\'1\\') + rec(i + 1, next_row_occupation(b))\\n                                          for b in range(1 << m)\\n                                          if b & (seats_bits[i] | occupied) == 0 and can_sit(b))\\n            return memo[(i, occupied)]\\n        return rec()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats):\\n        seats.reverse()\\n        memo, n, m = {}, len(seats), len(seats[0])\\n        seats_bits = [sum(1 << j for j in range(m) if seats[i][j] == \\'#\\') for i in range(n)]\\n        next_row_occupation = lambda b: b << 1 | b >> 1\\n        can_sit = lambda b: not any(b & 1 << i and b & 1 << (i + 1) for i in range(m - 1))\\n\\n        # i-th row and bits you cant place\\n        def rec(i = 0, occupied = 0):\\n            if i == n: return 0\\n            if (i, occupied) not in memo:\\n                memo[(i, occupied)] = max(bin(b).count(\\'1\\') + rec(i + 1, next_row_occupation(b))\\n                                          for b in range(1 << m)\\n                                          if b & (seats_bits[i] | occupied) == 0 and can_sit(b))\\n            return memo[(i, occupied)]\\n        return rec()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1539589,
                "title": "java-bottom-up-bitmask-dp",
                "content": "```\\nclass Solution {\\n    static final int _inf = (int)1e9;\\n    public int maxStudents(char[][] seats) {\\n        int n = seats.length, m = seats[0].length;\\n        int[] masks = new int[n+1];\\n        masks[0] = 0;\\n        for(int i = 0; i < n; i++) {\\n            char[] s = seats[i];\\n            int mk = 0;\\n            for(int j = 0; j < m; j++) {\\n                if(s[j] == \\'.\\') mk |= (1<<j);\\n            }\\n            \\n            masks[i+1] = mk;\\n        }\\n        \\n        int[] dp = new int[1<<m];\\n        Arrays.fill(dp, -_inf);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            int[] ndp = new int[1<<m];\\n            Arrays.fill(ndp, -_inf);\\n            int prev = masks[i-1];\\n            for(int sm1 = prev; ; sm1 = (sm1-1)&prev) {\\n                int cur = masks[i];\\n                for(int sm2 = cur; ; sm2 = (sm2-1)&cur) {\\n                    if(!isValid(sm1, sm2, m)) continue;\\n                    ndp[sm2] = Math.max(ndp[sm2], dp[sm1] + Integer.bitCount(sm2));\\n                    if(sm2 == 0) break;\\n                }\\n                \\n                if(sm1 == 0) break;\\n            }\\n            \\n            dp = ndp;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 1<<m; i++) ans = Math.max(ans, dp[i]);\\n        return ans;\\n    }\\n    \\n    public boolean isValid(int m1, int m2, int m) {\\n        for(int i = 0; i < m; i++) {\\n            if((m2&1<<i) > 0) {\\n                if(i-1 >= 0 && (m1&1<<(i-1)) > 0) return false;\\n                if(i+1 < m && (m1&1<<(i+1)) > 0) return false;\\n                if(i-1 >= 0 && (m2&1<<(i-1)) > 0) return false;\\n                if(i+1 < m && (m2&1<<(i+1)) > 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\n    static final int _inf = (int)1e9;\\n    public int maxStudents(char[][] seats) {\\n        int n = seats.length, m = seats[0].length;\\n        int[] masks = new int[n+1];\\n        masks[0] = 0;\\n        for(int i = 0; i < n; i++) {\\n            char[] s = seats[i];\\n            int mk = 0;\\n            for(int j = 0; j < m; j++) {\\n                if(s[j] == \\'.\\') mk |= (1<<j);\\n            }\\n            \\n            masks[i+1] = mk;\\n        }\\n        \\n        int[] dp = new int[1<<m];\\n        Arrays.fill(dp, -_inf);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++) {\\n            int[] ndp = new int[1<<m];\\n            Arrays.fill(ndp, -_inf);\\n            int prev = masks[i-1];\\n            for(int sm1 = prev; ; sm1 = (sm1-1)&prev) {\\n                int cur = masks[i];\\n                for(int sm2 = cur; ; sm2 = (sm2-1)&cur) {\\n                    if(!isValid(sm1, sm2, m)) continue;\\n                    ndp[sm2] = Math.max(ndp[sm2], dp[sm1] + Integer.bitCount(sm2));\\n                    if(sm2 == 0) break;\\n                }\\n                \\n                if(sm1 == 0) break;\\n            }\\n            \\n            dp = ndp;\\n        }\\n        \\n        int ans = 0;\\n        for(int i = 0; i < 1<<m; i++) ans = Math.max(ans, dp[i]);\\n        return ans;\\n    }\\n    \\n    public boolean isValid(int m1, int m2, int m) {\\n        for(int i = 0; i < m; i++) {\\n            if((m2&1<<i) > 0) {\\n                if(i-1 >= 0 && (m1&1<<(i-1)) > 0) return false;\\n                if(i+1 < m && (m1&1<<(i+1)) > 0) return false;\\n                if(i-1 >= 0 && (m2&1<<(i-1)) > 0) return false;\\n                if(i+1 < m && (m2&1<<(i+1)) > 0) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436312,
                "title": "c-o-n-2-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[9][258][258];\\n    long long solve(vector<vector<char>>& s,int index,int i,long long prev_mask,long long curr_mask){\\n        if(index == s.size() || i>=s[0].size()){\\n            return 0;\\n        }\\n        if(dp[index][prev_mask][curr_mask]>=0){\\n            return dp[index][prev_mask][curr_mask];\\n        }\\n\\n        long long ans = 0;\\n\\n       \\n            \\n        int l = (i == 0) ? -1 : i-1;\\n        int r = (i == s[0].size()-1) ? -1 : i+1;\\n        int flag = 1;\\n        if(s[index][i] == \\'#\\'){flag = 0;};\\n        \\n        if(l!=-1 && (prev_mask & (1<<l))){flag = 0;};\\n        if(l!=-1 && (curr_mask & (1<<l))){flag = 0;};\\n        if(r!=-1 && (prev_mask & (1<<r))){flag = 0;};\\n        if(r!=-1 && (curr_mask & (1<<r))){flag = 0;};\\n        if(curr_mask & (1<<i)){flag = 0;};\\n        if(flag){\\n            ans = max(ans,1+solve(s,index,i+1,prev_mask,curr_mask | (1<<i)));\\n            ans = max(ans,solve(s,index,i+1,prev_mask,curr_mask));\\n            ans = max(ans,1+solve(s,index+1,0,curr_mask | (1<<i),0));\\n            ans = max(ans,solve(s,index+1,0,curr_mask,0));\\n        }\\n        else\\n        {\\n            ans = max(ans,solve(s,index,i+1,prev_mask,curr_mask));\\n            ans = max(ans,solve(s,index+1,0,curr_mask,0));\\n        }\\n        \\n        return dp[index][prev_mask][curr_mask] = ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(seats,0,0,0,0);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long dp[9][258][258];\\n    long long solve(vector<vector<char>>& s,int index,int i,long long prev_mask,long long curr_mask){\\n        if(index == s.size() || i>=s[0].size()){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1403676,
                "title": "scala-100-100",
                "content": "```\\nobject Solution {\\n  private val Seat = \\'.\\'\\n\\n  def maxStudents(seats: Array[Array[Char]]): Int = seats\\n    .foldLeft(Map(0 -> 0)) {\\n      case (frontRowSeatingToMaxSeatedStudents, backRow) => seatings(backRow).flatMap {\\n        case (backRowSeating, numStudentsInBackRowSeating) => frontRowSeatingToMaxSeatedStudents\\n          .collect {\\n            case (frontRowSeating, maxSeatedStudents) if !canStudentsCheat(frontRowSeating, backRowSeating) =>\\n              maxSeatedStudents\\n          }\\n          .maxOption\\n          .map(numStudentsInBackRowSeating + _)\\n          .map(backRowSeating -> _)\\n      }\\n    }\\n    .values\\n    .max\\n\\n  private def seatings(row: Array[Char]) = row\\n    .zipWithIndex\\n    .collect { case (Seat, index) => index }\\n    .toSet\\n    .subsets\\n    .map(seats => seats.foldLeft(0) { case (mask, seat) => mask | (1 << seat) } -> seats.size)\\n    .toMap\\n\\n  private def canStudentsCheat(frontRowSeating: Int, backRowSeating: Int) = {\\n    (frontRowSeating & (backRowSeating << 1)) != 0 ||\\n      (frontRowSeating & (backRowSeating >> 1)) != 0 ||\\n      (backRowSeating & (backRowSeating << 1)) != 0 ||\\n      (backRowSeating & (backRowSeating >> 1)) != 0\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nobject Solution {\\n  private val Seat = \\'.\\'\\n\\n  def maxStudents(seats: Array[Array[Char]]): Int = seats\\n    .foldLeft(Map(0 -> 0)) {\\n      case (frontRowSeatingToMaxSeatedStudents, backRow) => seatings(backRow).flatMap {\\n        case (backRowSeating, numStudentsInBackRowSeating) => frontRowSeatingToMaxSeatedStudents\\n          .collect {\\n            case (frontRowSeating, maxSeatedStudents) if !canStudentsCheat(frontRowSeating, backRowSeating) =>\\n              maxSeatedStudents\\n          }\\n          .maxOption\\n          .map(numStudentsInBackRowSeating + _)\\n          .map(backRowSeating -> _)\\n      }\\n    }\\n    .values\\n    .max\\n\\n  private def seatings(row: Array[Char]) = row\\n    .zipWithIndex\\n    .collect { case (Seat, index) => index }\\n    .toSet\\n    .subsets\\n    .map(seats => seats.foldLeft(0) { case (mask, seat) => mask | (1 << seat) } -> seats.size)\\n    .toMap\\n\\n  private def canStudentsCheat(frontRowSeating: Int, backRowSeating: Int) = {\\n    (frontRowSeating & (backRowSeating << 1)) != 0 ||\\n      (frontRowSeating & (backRowSeating >> 1)) != 0 ||\\n      (backRowSeating & (backRowSeating << 1)) != 0 ||\\n      (backRowSeating & (backRowSeating >> 1)) != 0\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1403273,
                "title": "what-an-awesome-question",
                "content": "```\\nclass Solution {\\n    int ans=0;\\n    \\n    public int maxStudents(char[][] seats) {\\n        if(seats==null || seats.length==0) return 0;\\n        int r = seats.length;\\n        int c = seats[0].length;\\n        boolean [][] visited = new boolean[r][c];\\n        for(int i=0;i<r;i++) {\\n            for(int j=0; j<c; j++) {\\n                visited[i][j] = false;\\n            }\\n        }\\n        int dp[][] = new int[r][(1<<c) + 1];\\n        for(int i=0; i<r;i++) {\\n            for(int j=0; j< (1<<c);j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        return dfs(seats, 0, 0, dp);\\n    }\\n    int dfs(char[][] seats,int i,  int pmask, int dp[][]) {\\n        \\n        int r = seats.length;\\n        int c = seats[0].length;\\n        if(i>=r) {\\n            return 0;\\n        }\\n        int rc = 0;\\n        int curr = 0;\\n        \\n        if(dp[i][pmask] != -1) {\\n            return dp[i][pmask];\\n        }\\n        \\n        for(int j=0;j<c;j++) {\\n            if(seats[i][j] != \\'#\\') {\\n                curr |= (1<<j);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j< (1<<c); j++) {\\n            int mask = curr & j;\\n            if(((mask & (mask>>1)) | (mask & (pmask>>1)) | (mask & (pmask<<1))) == 0) {\\n                int res = dfs(seats, i+1, mask, dp) ;\\n                ans = Math.max(ans, res+ cntbits(mask));\\n            }\\n        }\\n        \\n        return dp[i][pmask] = ans;\\n    }\\n    int cntbits(int n ){        \\n        int cnt=0;\\n        while(n>0) {\\n            ++cnt;\\n            n&=n-1;\\n        }\\n        return cnt;\\n    }\\n\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans=0;\\n    \\n    public int maxStudents(char[][] seats) {\\n        if(seats==null || seats.length==0) return 0;\\n        int r = seats.length;\\n        int c = seats[0].length;\\n        boolean [][] visited = new boolean[r][c];\\n        for(int i=0;i<r;i++) {\\n            for(int j=0; j<c; j++) {\\n                visited[i][j] = false;\\n            }\\n        }\\n        int dp[][] = new int[r][(1<<c) + 1];\\n        for(int i=0; i<r;i++) {\\n            for(int j=0; j< (1<<c);j++) {\\n                dp[i][j] = -1;\\n            }\\n        }\\n        \\n        return dfs(seats, 0, 0, dp);\\n    }\\n    int dfs(char[][] seats,int i,  int pmask, int dp[][]) {\\n        \\n        int r = seats.length;\\n        int c = seats[0].length;\\n        if(i>=r) {\\n            return 0;\\n        }\\n        int rc = 0;\\n        int curr = 0;\\n        \\n        if(dp[i][pmask] != -1) {\\n            return dp[i][pmask];\\n        }\\n        \\n        for(int j=0;j<c;j++) {\\n            if(seats[i][j] != \\'#\\') {\\n                curr |= (1<<j);\\n            }\\n        }\\n        int ans = 0;\\n        for(int j=0;j< (1<<c); j++) {\\n            int mask = curr & j;\\n            if(((mask & (mask>>1)) | (mask & (pmask>>1)) | (mask & (pmask<<1))) == 0) {\\n                int res = dfs(seats, i+1, mask, dp) ;\\n                ans = Math.max(ans, res+ cntbits(mask));\\n            }\\n        }\\n        \\n        return dp[i][pmask] = ans;\\n    }\\n    int cntbits(int n ){        \\n        int cnt=0;\\n        while(n>0) {\\n            ++cnt;\\n            n&=n-1;\\n        }\\n        return cnt;\\n    }\\n\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296366,
                "title": "dp-bitmask-solution-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int isMaskValid(int rowmask,int mask,int n){\\n        if((rowmask&mask)!=mask){\\n            return -1;\\n        }\\n        int i,j,k;\\n        int ans=0;\\n        if(1&mask){\\n            ans++;\\n        }\\n        for(i=1;i<n;i++){\\n            j=1<<i;\\n            if(j&mask){\\n                ans++;\\n            }\\n            else{\\n                continue;\\n            }\\n            k=1<<(i-1);\\n            if(k&mask){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool areMasksCompatible(int mask1,int mask2,int n){\\n        int i,j,k;\\n        for(i=0;i<n;i++){\\n            j=1<<i;\\n            if(j&mask1){\\n                if(i>0){\\n                    k=1<<(i-1);\\n                    if(mask2&k){\\n                        return false;\\n                    }\\n                }\\n                if(i<n-1){\\n                    k=1<<(i+1);\\n                    if(mask2&k){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maxStudents(vector<vector<char>>&seats) {\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        int mask=pow(2,n);\\n        vector<int>bitmasks(m);\\n        int i,j,k,l;\\n        for(i=0;i<seats.size();i++){\\n            for(j=0;j<seats[i].size();j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    bitmasks[i]+=1<<j;\\n                }\\n            }\\n        }\\n        vector<vector<int>>dp(m,vector<int>(mask));\\n        for(i=0;i<mask;i++){\\n            j=isMaskValid(bitmasks[0],i,n);\\n            if(j>0){\\n                dp[0][i]=j;\\n            }\\n        }\\n        for(i=1;i<m;i++){\\n            for(j=0;j<mask;j++){\\n                l=isMaskValid(bitmasks[i],j,n);\\n                for(k=0;k<mask;k++){\\n                    if(l>=0 && isMaskValid(bitmasks[i-1],k,n)>=0 && areMasksCompatible(j,k,n)){\\n                        dp[i][j]=max(dp[i][j],l+dp[i-1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(i=0;i<mask;i++){\\n            ans=max(ans,dp[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int isMaskValid(int rowmask,int mask,int n){\\n        if((rowmask&mask)!=mask){\\n            return -1;\\n        }\\n        int i,j,k;\\n        int ans=0;\\n        if(1&mask){\\n            ans++;\\n        }\\n        for(i=1;i<n;i++){\\n            j=1<<i;\\n            if(j&mask){\\n                ans++;\\n            }\\n            else{\\n                continue;\\n            }\\n            k=1<<(i-1);\\n            if(k&mask){\\n                return -1;\\n            }\\n        }\\n        return ans;\\n    }\\n    bool areMasksCompatible(int mask1,int mask2,int n){\\n        int i,j,k;\\n        for(i=0;i<n;i++){\\n            j=1<<i;\\n            if(j&mask1){\\n                if(i>0){\\n                    k=1<<(i-1);\\n                    if(mask2&k){\\n                        return false;\\n                    }\\n                }\\n                if(i<n-1){\\n                    k=1<<(i+1);\\n                    if(mask2&k){\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    int maxStudents(vector<vector<char>>&seats) {\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        int mask=pow(2,n);\\n        vector<int>bitmasks(m);\\n        int i,j,k,l;\\n        for(i=0;i<seats.size();i++){\\n            for(j=0;j<seats[i].size();j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    bitmasks[i]+=1<<j;\\n                }\\n            }\\n        }\\n        vector<vector<int>>dp(m,vector<int>(mask));\\n        for(i=0;i<mask;i++){\\n            j=isMaskValid(bitmasks[0],i,n);\\n            if(j>0){\\n                dp[0][i]=j;\\n            }\\n        }\\n        for(i=1;i<m;i++){\\n            for(j=0;j<mask;j++){\\n                l=isMaskValid(bitmasks[i],j,n);\\n                for(k=0;k<mask;k++){\\n                    if(l>=0 && isMaskValid(bitmasks[i-1],k,n)>=0 && areMasksCompatible(j,k,n)){\\n                        dp[i][j]=max(dp[i][j],l+dp[i-1][k]);\\n                    }\\n                }\\n            }\\n        }\\n        int ans=0;\\n        for(i=0;i<mask;i++){\\n            ans=max(ans,dp[m-1][i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242159,
                "title": "swift-dp",
                "content": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var seats = [[Character]]()\\n    private var M  = 0\\n    private var N = 0\\n    //\\u72B6\\u6001--->\\u5B66\\u751F\\u4EBA\\u6570\\n    private var stateToStudentNumbers = [Int]()\\n    //8\\u4E2A\\u5EA7\\u4F4D\\u65F6\\uFF0C\\u6BCF\\u884C\\u7684\\u53EF\\u80FD\\u72B6\\u6001\\uFF1A\\u4FDD\\u8BC1\\u4E0D\\u76F8\\u90BB\\n    private var possibleSatesOfEachRow = [Int]()\\n    //\\u4E0A\\u4E00\\u5C42\\u72B6\\u6001\\u786E\\u5B9A\\u65F6\\uFF0C\\u5F53\\u524D\\u5C42\\u72B6\\u6001\\u53EF\\u80FD\\u9009\\u9879\\n    private var lastLevelStateToCurrentLevelstate = [Int:Set<Int>]()\\n    init() {\\n        self.stateToStudentNumbers = (0...255).map({ countOnes(of: $0)})\\n        self.possibleSatesOfEachRow = (0...255).filter({ check($0)})\\n        self.lastLevelStateToCurrentLevelstate = caculatePossibleAdjentStates()\\n    }\\n    func maxStudents(_ seats: [[Character]]) -> Int {\\n        \\n        self.seats = seats\\n        self.M = seats.count\\n        self.N = seats[0].count\\n        self.memo = [:]\\n        let curPossibleStatesOfEachRow = self.possibleSatesOfEachRow.filter { $0 < (1 << N)}\\n        \\n        var possibleStateOfSpecificRow = [[Int]]()\\n        \\n        (0..<M).forEach { row in\\n            possibleStateOfSpecificRow.append(curPossibleStatesOfEachRow.filter({ state in\\n                checkBrokenSeats(row, state)\\n            }))\\n        }\\n        \\n\\n        return dfs(0, 0, possibleStateOfSpecificRow) ?? 0\\n    }\\n    \\n    //\\u4FDD\\u8BC1\\u5DE6\\u53F3\\u4E0D\\u76F8\\u90BB\\n    private func check(_ state: Int) -> Bool {\\n        for bit in 0...7 {\\n            guard (state & (1 << bit)) * (state & (1 << (bit + 1))) == 0 else {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    //\\u4FDD\\u8BC1\\u635F\\u574F\\u7684\\u5EA7\\u4F4D\\u6CA1\\u6709\\u4EBA\\n    private func checkBrokenSeats(_ row: Int, _ state: Int) -> Bool {\\n        for col in 0..<N {\\n            guard state & (1 << col) == 0 || self.seats[row][col] != \"#\" else {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func caculatePossibleAdjentStates() -> [Int:Set<Int>] {\\n        \\n        //(r,c)\\u4F4D\\u7F6E\\u6709\\u8003\\u751F\\uFF0C\\u5219(r + 1,c - 1)\\u548C(r + 1, c + 1)\\u4F4D\\u7F6E\\u4E0A\\u4E0D\\u80FD\\u6709\\u8003\\u751F\\u3002\\n        func checkInternal(lastLevelState: Int, currentLevelState: Int) -> Bool {\\n            guard lastLevelState != currentLevelState else {\\n                return true\\n            }\\n            for bit in 0...7 {\\n                guard  lastLevelState & (1 << bit) != 0 else {\\n                    continue\\n                }\\n                guard bit - 1 < 0 || currentLevelState & 1 << (bit - 1) == 0 else {\\n                    return false\\n                }\\n                guard bit + 1 > 7 ||  currentLevelState & 1 << (bit + 1) == 0 else {\\n                    return false\\n                }\\n            }\\n            \\n            return true\\n        }\\n        \\n        var ans = [Int:Set<Int>]()\\n        //\\u679A\\u4E3E\\u4E0A\\u4E00\\u5C42\\u7684\\u72B6\\u6001\\n        for ls in self.possibleSatesOfEachRow {\\n            var temp = Set<Int>()\\n            for cs in self.possibleSatesOfEachRow {\\n                if checkInternal(lastLevelState: ls, currentLevelState: cs) {\\n                    temp.insert(cs)\\n                }\\n            }\\n            ans[ls] = temp\\n        }\\n        return ans\\n        \\n    }\\n    private func countOnes(of num: Int) -> Int {\\n        return (0...7).reduce(0) { $0 + (num & (1 << $1) == 0 ? 0 : 1)}\\n    }\\n    \\n    private func dfs(_ lastLevelState: Int, _ row: Int, _ possibleStatesOfSpecificRow: [[Int]]) -> Int? {\\n        guard row < M  else {\\n            return 0\\n        }\\n        let key = row << 16 | lastLevelState\\n        guard nil == memo[key] else {\\n            return memo[key]! == -1 ? nil : memo[key]\\n        }\\n        var curMaxStudengtsNumber: Int? = nil\\n        guard let nextLevelPossibleStates = self.lastLevelStateToCurrentLevelstate[lastLevelState] else {\\n            return nil\\n        }\\n\\n        for s in possibleStatesOfSpecificRow[row] {\\n            guard nextLevelPossibleStates.contains(s) else {\\n                continue\\n            }\\n            if let v = dfs(s, row + 1, possibleStatesOfSpecificRow) {\\n                curMaxStudengtsNumber = max(curMaxStudengtsNumber ?? 0, v + self.stateToStudentNumbers[s])\\n            }\\n        }\\n        guard let v = curMaxStudengtsNumber else {\\n            return nil\\n        }\\n        defer {\\n            memo[key] = curMaxStudengtsNumber ?? -1\\n        }\\n        return v\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    private var memo = [Int:Int]()\\n    private var seats = [[Character]]()\\n    private var M  = 0\\n    private var N = 0\\n    //\\u72B6\\u6001--->\\u5B66\\u751F\\u4EBA\\u6570\\n    private var stateToStudentNumbers = [Int]()\\n    //8\\u4E2A\\u5EA7\\u4F4D\\u65F6\\uFF0C\\u6BCF\\u884C\\u7684\\u53EF\\u80FD\\u72B6\\u6001\\uFF1A\\u4FDD\\u8BC1\\u4E0D\\u76F8\\u90BB\\n    private var possibleSatesOfEachRow = [Int]()\\n    //\\u4E0A\\u4E00\\u5C42\\u72B6\\u6001\\u786E\\u5B9A\\u65F6\\uFF0C\\u5F53\\u524D\\u5C42\\u72B6\\u6001\\u53EF\\u80FD\\u9009\\u9879\\n    private var lastLevelStateToCurrentLevelstate = [Int:Set<Int>]()\\n    init() {\\n        self.stateToStudentNumbers = (0...255).map({ countOnes(of: $0)})\\n        self.possibleSatesOfEachRow = (0...255).filter({ check($0)})\\n        self.lastLevelStateToCurrentLevelstate = caculatePossibleAdjentStates()\\n    }\\n    func maxStudents(_ seats: [[Character]]) -> Int {\\n        \\n        self.seats = seats\\n        self.M = seats.count\\n        self.N = seats[0].count\\n        self.memo = [:]\\n        let curPossibleStatesOfEachRow = self.possibleSatesOfEachRow.filter { $0 < (1 << N)}\\n        \\n        var possibleStateOfSpecificRow = [[Int]]()\\n        \\n        (0..<M).forEach { row in\\n            possibleStateOfSpecificRow.append(curPossibleStatesOfEachRow.filter({ state in\\n                checkBrokenSeats(row, state)\\n            }))\\n        }\\n        \\n\\n        return dfs(0, 0, possibleStateOfSpecificRow) ?? 0\\n    }\\n    \\n    //\\u4FDD\\u8BC1\\u5DE6\\u53F3\\u4E0D\\u76F8\\u90BB\\n    private func check(_ state: Int) -> Bool {\\n        for bit in 0...7 {\\n            guard (state & (1 << bit)) * (state & (1 << (bit + 1))) == 0 else {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    //\\u4FDD\\u8BC1\\u635F\\u574F\\u7684\\u5EA7\\u4F4D\\u6CA1\\u6709\\u4EBA\\n    private func checkBrokenSeats(_ row: Int, _ state: Int) -> Bool {\\n        for col in 0..<N {\\n            guard state & (1 << col) == 0 || self.seats[row][col] != \"#\" else {\\n                return false\\n            }\\n        }\\n        return true\\n    }\\n    \\n    private func caculatePossibleAdjentStates() -> [Int:Set<Int>] {\\n        \\n        //(r,c)\\u4F4D\\u7F6E\\u6709\\u8003\\u751F\\uFF0C\\u5219(r + 1,c - 1)\\u548C(r + 1, c + 1)\\u4F4D\\u7F6E\\u4E0A\\u4E0D\\u80FD\\u6709\\u8003\\u751F\\u3002\\n        func checkInternal(lastLevelState: Int, currentLevelState: Int) -> Bool {\\n            guard lastLevelState != currentLevelState else {\\n                return true\\n            }\\n            for bit in 0...7 {\\n                guard  lastLevelState & (1 << bit) != 0 else {\\n                    continue\\n                }\\n                guard bit - 1 < 0 || currentLevelState & 1 << (bit - 1) == 0 else {\\n                    return false\\n                }\\n                guard bit + 1 > 7 ||  currentLevelState & 1 << (bit + 1) == 0 else {\\n                    return false\\n                }\\n            }\\n            \\n            return true\\n        }\\n        \\n        var ans = [Int:Set<Int>]()\\n        //\\u679A\\u4E3E\\u4E0A\\u4E00\\u5C42\\u7684\\u72B6\\u6001\\n        for ls in self.possibleSatesOfEachRow {\\n            var temp = Set<Int>()\\n            for cs in self.possibleSatesOfEachRow {\\n                if checkInternal(lastLevelState: ls, currentLevelState: cs) {\\n                    temp.insert(cs)\\n                }\\n            }\\n            ans[ls] = temp\\n        }\\n        return ans\\n        \\n    }\\n    private func countOnes(of num: Int) -> Int {\\n        return (0...7).reduce(0) { $0 + (num & (1 << $1) == 0 ? 0 : 1)}\\n    }\\n    \\n    private func dfs(_ lastLevelState: Int, _ row: Int, _ possibleStatesOfSpecificRow: [[Int]]) -> Int? {\\n        guard row < M  else {\\n            return 0\\n        }\\n        let key = row << 16 | lastLevelState\\n        guard nil == memo[key] else {\\n            return memo[key]! == -1 ? nil : memo[key]\\n        }\\n        var curMaxStudengtsNumber: Int? = nil\\n        guard let nextLevelPossibleStates = self.lastLevelStateToCurrentLevelstate[lastLevelState] else {\\n            return nil\\n        }\\n\\n        for s in possibleStatesOfSpecificRow[row] {\\n            guard nextLevelPossibleStates.contains(s) else {\\n                continue\\n            }\\n            if let v = dfs(s, row + 1, possibleStatesOfSpecificRow) {\\n                curMaxStudengtsNumber = max(curMaxStudengtsNumber ?? 0, v + self.stateToStudentNumbers[s])\\n            }\\n        }\\n        guard let v = curMaxStudengtsNumber else {\\n            return nil\\n        }\\n        defer {\\n            memo[key] = curMaxStudengtsNumber ?? -1\\n        }\\n        return v\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208934,
                "title": "python3-bitmask-dp",
                "content": "\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0]) # dimensions \\n        \\n        valid = []\\n        for i in range(m): \\n            val = 0\\n            for j in range(n): \\n                if seats[i][j] == \".\": val |= 1 << j \\n            valid.append(val)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return max students taking seats[i:] given previous row as mask.\"\"\"\\n            if i == len(seats): return 0 \\n            ans = fn(i+1, 0)\\n            for x in range(1 << n): \\n                if x & valid[i] == x and (x >> 1) & x == 0 and (mask >> 1) & x == 0 and (mask << 1) & x == 0: \\n                    ans = max(ans, bin(x).count(\"1\") + fn(i+1, x))\\n            return ans \\n        \\n        return fn(0, 0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m, n = len(seats), len(seats[0]) # dimensions \\n        \\n        valid = []\\n        for i in range(m): \\n            val = 0\\n            for j in range(n): \\n                if seats[i][j] == \".\": val |= 1 << j \\n            valid.append(val)\\n        \\n        @cache\\n        def fn(i, mask): \\n            \"\"\"Return max students taking seats[i:] given previous row as mask.\"\"\"\\n            if i == len(seats): return 0 \\n            ans = fn(i+1, 0)\\n            for x in range(1 << n): \\n                if x & valid[i] == x and (x >> 1) & x == 0 and (mask >> 1) & x == 0 and (mask << 1) & x == 0: \\n                    ans = max(ans, bin(x).count(\"1\") + fn(i+1, x))\\n            return ans \\n        \\n        return fn(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107330,
                "title": "intuitive-topdown",
                "content": "enumerate valid cases and recursion\\n```\\nint n, dp[][];\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length; n = seats[0].length;\\n        dp = new int[m][1<<n];\\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(dp[i],Integer.MIN_VALUE);\\n        }\\n        return dfs(seats,0,0);\\n    }\\n    int dfs(char[][] seats, int lv, int key){\\n        if (lv == dp.length) return 0;\\n        if (dp[lv][key] != Integer.MIN_VALUE) return dp[lv][key];\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++){\\n            if ((1 << i & key) != 0){\\n                if (i+1 <n) set.add(i+1);\\n                if (i-1>=0) set.add(i-1);\\n            }\\n            if (seats[lv][i] == \\'#\\'){\\n                set.add(i);\\n            }\\n        }\\n        int forbidden = 0, res = 0;\\n        for (int x: set){\\n            forbidden += 1<<x;\\n        }\\n        for (int i = 0; i < 1<<n; i++){\\n            if ((i & forbidden) == 0 && (i&i>>1) == 0){\\n                res = Math.max(res,Integer.bitCount(i)+dfs(seats,lv+1,i));\\n            }\\n        }\\n        dp[lv][key] = res;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint n, dp[][];\\n    public int maxStudents(char[][] seats) {\\n        int m = seats.length; n = seats[0].length;\\n        dp = new int[m][1<<n];\\n        for (int i = 0; i < m; i++){\\n            Arrays.fill(dp[i],Integer.MIN_VALUE);\\n        }\\n        return dfs(seats,0,0);\\n    }\\n    int dfs(char[][] seats, int lv, int key){\\n        if (lv == dp.length) return 0;\\n        if (dp[lv][key] != Integer.MIN_VALUE) return dp[lv][key];\\n        Set<Integer> set = new HashSet<>();\\n        for (int i = 0; i < n; i++){\\n            if ((1 << i & key) != 0){\\n                if (i+1 <n) set.add(i+1);\\n                if (i-1>=0) set.add(i-1);\\n            }\\n            if (seats[lv][i] == \\'#\\'){\\n                set.add(i);\\n            }\\n        }\\n        int forbidden = 0, res = 0;\\n        for (int x: set){\\n            forbidden += 1<<x;\\n        }\\n        for (int i = 0; i < 1<<n; i++){\\n            if ((i & forbidden) == 0 && (i&i>>1) == 0){\\n                res = Math.max(res,Integer.bitCount(i)+dfs(seats,lv+1,i));\\n            }\\n        }\\n        dp[lv][key] = res;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1052302,
                "title": "c-dp-with-bitmask",
                "content": "The state is given by location plus row configuration.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool canTake(const vector<vector<char>>& seats, int row, int col) {\\n        \\n        const int rows = seats.size();\\n        const int cols = seats[0].size();\\n        \\n        if (seats[row][col] == \\'#\\') {\\n            return false;\\n        }\\n        \\n        // Check only left seat\\n        if (row == 0) {\\n            return col == 0 ? true : seats[row][col - 1] != \\'S\\';\\n        }\\n        \\n        // Check only top right\\n        if (col == 0) {\\n            return (col + 1 == cols) ? true : seats[row - 1][col + 1] != \\'S\\';\\n        }\\n        \\n        // Check all: left, topLeft and topRight\\n        bool leftOK = seats[row][col - 1] != \\'S\\';\\n        bool topLeftOK = seats[row - 1][col - 1] != \\'S\\';\\n        bool topRightOK = (col + 1 == cols) ? true : seats[row - 1][col + 1] != \\'S\\';\\n        \\n        return leftOK && topLeftOK && topRightOK;\\n    }\\n    \\n    int dfs(vector<vector<char>>& seats, int r, int c, int state) {\\n        \\n        if (r >= seats.size()) {\\n            return 0;\\n        }\\n        \\n        int loc = r * seats[0].size() + c;\\n        if (dp[loc][state] != -1) {\\n            return dp[loc][state];\\n        }\\n        \\n        int next_col = (c + 1) < seats[0].size() ? (c + 1) : 0;\\n        int next_row = next_col ? r : r + 1;\\n\\n        // Take branch\\n        int taken = 0;\\n        if (canTake(seats, r, c)) {\\n            seats[r][c] = \\'S\\';\\n            // Set the bit\\n            state |= (1 << c);\\n            taken = 1 + dfs(seats, next_row, next_col, state);\\n            // Clear the bit\\n            state &= ~(1 << c);\\n            seats[r][c] = \\'.\\';\\n        }\\n\\n        int not_taken = dfs(seats, next_row, next_col, state);\\n        \\n        dp[loc][state] = max(taken, not_taken);\\n        \\n        return dp[loc][state];\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n     \\n        if (seats.empty()) {\\n            return 0;\\n        }\\n        \\n        dp = move(vector<vector<int>>(seats.size() * seats[0].size(), vector<int>(1 << seats[0].size(), -1)));\\n        \\n        return dfs(seats, 0, 0, 0);\\n    }\\n    \\n    vector<vector<int>> dp;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool canTake(const vector<vector<char>>& seats, int row, int col) {\\n        \\n        const int rows = seats.size();\\n        const int cols = seats[0].size();\\n        \\n        if (seats[row][col] == \\'#\\') {\\n            return false;\\n        }\\n        \\n        // Check only left seat\\n        if (row == 0) {\\n            return col == 0 ? true : seats[row][col - 1] != \\'S\\';\\n        }\\n        \\n        // Check only top right\\n        if (col == 0) {\\n            return (col + 1 == cols) ? true : seats[row - 1][col + 1] != \\'S\\';\\n        }\\n        \\n        // Check all: left, topLeft and topRight\\n        bool leftOK = seats[row][col - 1] != \\'S\\';\\n        bool topLeftOK = seats[row - 1][col - 1] != \\'S\\';\\n        bool topRightOK = (col + 1 == cols) ? true : seats[row - 1][col + 1] != \\'S\\';\\n        \\n        return leftOK && topLeftOK && topRightOK;\\n    }\\n    \\n    int dfs(vector<vector<char>>& seats, int r, int c, int state) {\\n        \\n        if (r >= seats.size()) {\\n            return 0;\\n        }\\n        \\n        int loc = r * seats[0].size() + c;\\n        if (dp[loc][state] != -1) {\\n            return dp[loc][state];\\n        }\\n        \\n        int next_col = (c + 1) < seats[0].size() ? (c + 1) : 0;\\n        int next_row = next_col ? r : r + 1;\\n\\n        // Take branch\\n        int taken = 0;\\n        if (canTake(seats, r, c)) {\\n            seats[r][c] = \\'S\\';\\n            // Set the bit\\n            state |= (1 << c);\\n            taken = 1 + dfs(seats, next_row, next_col, state);\\n            // Clear the bit\\n            state &= ~(1 << c);\\n            seats[r][c] = \\'.\\';\\n        }\\n\\n        int not_taken = dfs(seats, next_row, next_col, state);\\n        \\n        dp[loc][state] = max(taken, not_taken);\\n        \\n        return dp[loc][state];\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n     \\n        if (seats.empty()) {\\n            return 0;\\n        }\\n        \\n        dp = move(vector<vector<int>>(seats.size() * seats[0].size(), vector<int>(1 << seats[0].size(), -1)));\\n        \\n        return dfs(seats, 0, 0, 0);\\n    }\\n    \\n    vector<vector<int>> dp;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047618,
                "title": "using-bitmask-bottomup-with-topdown-clean-and-easy-to-understand-0ms-2-1mb-beats-100",
                "content": "```\\nvar validMasks = []int{}\\n\\nfunc init(){ //pre enumerate validMasks by the rule \"Students can see the answers of those sitting next to the left, right\"\\n    th := 1<<8\\n    for mask := 0; mask < th; mask++{\\n        prevj := -2\\n        for j := 0; j < 8; j++{\\n            if 1<<j & mask != 0 {\\n                if j-prevj > 1{\\n                    prevj = j\\n                }else{\\n                    goto nextite\\n                }\\n            }\\n        }\\n        validMasks = append(validMasks, mask)\\n        nextite:\\n    }\\n}\\n\\n\\nfunc maxStudents(seats [][]byte) (ans int) {\\n    m, n := len(seats), len(seats[0])\\n    comEachRow := 1<<n\\n\\n    dp := make([]int, comEachRow, comEachRow)\\n    dptmp := make([]int, comEachRow, comEachRow)\\n\\n    var dfsRow func(i, j int, takenjs []int)\\n    dfsRow = func(i, j int, takenjs []int){\\n        if j == n { \\n            if len(takenjs) == 0 {dptmp[0] = ans; return} //no seats taken, the result should be max of the prev row\\n            \\n            seatsMask, actTakeCnt := 0, 0\\n            for _, takenj := range takenjs {\\n                seatsMask |= 1<<takenj\\n                if seats[i][takenj] == \\'.\\' {actTakeCnt++}\\n            }\\n            \\n            if i == 0 { //at row 0, we do not have to compare with prev row\\n                dptmp[seatsMask] = actTakeCnt\\n            }else{ \\n                frontSeatsMax := 0\\n                for _, frontSeatMask := range validMasks {\\n                    if frontSeatMask == comEachRow {break} //upper bound of current test case\\n                    \\n                    for _, takenj := range takenjs {\\n                        seatjMask := 1<<takenj\\n                        if seatjMask<<1 & frontSeatMask != 0 || seatjMask>>1 & frontSeatMask != 0 { //check the rule \"exclude upper left and upper right\"\\n\\t\\t\\t\\t\\t\\t\\tgoto nextite \\n\\t\\t\\t\\t\\t\\t}\\n                    }\\n                    if dp[frontSeatMask] > frontSeatsMax {frontSeatsMax = dp[frontSeatMask]} \\n                    \\n                    nextite:\\n                }\\n                \\n                dptmp[seatsMask] = actTakeCnt + frontSeatsMax\\n            }\\n            if dptmp[seatsMask] > ans {ans = dptmp[seatsMask]}\\n            \\n            return\\n        }\\n        \\n        dfsRow(i, j+1, takenjs) //not take seats j at row i\\n        if len(takenjs) == 0 || j-1 > takenjs[len(takenjs)-1] {dfsRow(i, j+1, append(takenjs, j))} //take seats j at row i\\n    }\\n    \\n    for i := 0; i < m; i++{ //bottom up each row\\n        dfsRow(i, 0, []int{}) \\n        dp, dptmp = dptmp, dp\\n    }\\n    \\n    return\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar validMasks = []int{}\\n\\nfunc init(){ //pre enumerate validMasks by the rule \"Students can see the answers of those sitting next to the left, right\"\\n    th := 1<<8\\n    for mask := 0; mask < th; mask++{\\n        prevj := -2\\n        for j := 0; j < 8; j++{\\n            if 1<<j & mask != 0 {\\n                if j-prevj > 1{\\n                    prevj = j\\n                }else{\\n                    goto nextite\\n                }\\n            }\\n        }\\n        validMasks = append(validMasks, mask)\\n        nextite:\\n    }\\n}\\n\\n\\nfunc maxStudents(seats [][]byte) (ans int) {\\n    m, n := len(seats), len(seats[0])\\n    comEachRow := 1<<n\\n\\n    dp := make([]int, comEachRow, comEachRow)\\n    dptmp := make([]int, comEachRow, comEachRow)\\n\\n    var dfsRow func(i, j int, takenjs []int)\\n    dfsRow = func(i, j int, takenjs []int){\\n        if j == n { \\n            if len(takenjs) == 0 {dptmp[0] = ans; return} //no seats taken, the result should be max of the prev row\\n            \\n            seatsMask, actTakeCnt := 0, 0\\n            for _, takenj := range takenjs {\\n                seatsMask |= 1<<takenj\\n                if seats[i][takenj] == \\'.\\' {actTakeCnt++}\\n            }\\n            \\n            if i == 0 { //at row 0, we do not have to compare with prev row\\n                dptmp[seatsMask] = actTakeCnt\\n            }else{ \\n                frontSeatsMax := 0\\n                for _, frontSeatMask := range validMasks {\\n                    if frontSeatMask == comEachRow {break} //upper bound of current test case\\n                    \\n                    for _, takenj := range takenjs {\\n                        seatjMask := 1<<takenj\\n                        if seatjMask<<1 & frontSeatMask != 0 || seatjMask>>1 & frontSeatMask != 0 { //check the rule \"exclude upper left and upper right\"\\n\\t\\t\\t\\t\\t\\t\\tgoto nextite \\n\\t\\t\\t\\t\\t\\t}\\n                    }\\n                    if dp[frontSeatMask] > frontSeatsMax {frontSeatsMax = dp[frontSeatMask]} \\n                    \\n                    nextite:\\n                }\\n                \\n                dptmp[seatsMask] = actTakeCnt + frontSeatsMax\\n            }\\n            if dptmp[seatsMask] > ans {ans = dptmp[seatsMask]}\\n            \\n            return\\n        }\\n        \\n        dfsRow(i, j+1, takenjs) //not take seats j at row i\\n        if len(takenjs) == 0 || j-1 > takenjs[len(takenjs)-1] {dfsRow(i, j+1, append(takenjs, j))} //take seats j at row i\\n    }\\n    \\n    for i := 0; i < m; i++{ //bottom up each row\\n        dfsRow(i, 0, []int{}) \\n        dp, dptmp = dptmp, dp\\n    }\\n    \\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1024502,
                "title": "p23-5",
                "content": "Bitmask dp\\nFor all possble combination for a row(2^8) ways\\nmaintains prev row config\\ncheck weather cureent cofig is compatible with seats(no sitting at forbidden places) and with pre row config(no malicous practice allowing)\\n",
                "solutionTags": [],
                "code": "Bitmask dp\\nFor all possble combination for a row(2^8) ways\\nmaintains prev row config\\ncheck weather cureent cofig is compatible with seats(no sitting at forbidden places) and with pre row config(no malicous practice allowing)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1012523,
                "title": "c-4ms-o-n-2-m",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        const int n = seats.size(), m = seats[0].size(), k = (1<<m);\\n        auto vdp = vector(n, vector(k,0));\\n        \\n        {\\n            Row bad = badSeats(seats[0]);\\n            for(int i=0; i<k; i++){\\n                if(!isValidRow(i, bad)) continue;\\n                vdp[0][i] = count(i);\\n            }\\n        }\\n        \\n        for(int r=1;r<n;r++){\\n            Row bad = badSeats(seats[r]);\\n            for(int i=0; i<k; i++){\\n                if(!isValidRow(i, bad)) continue;\\n                int cnt = count(i);\\n                for(int j=0;j<k;j++){\\n                    if(isValid(j, i)) vdp[r][i] = max(vdp[r][i], cnt + vdp[r-1][j]);\\n                }\\n            }\\n        }\\n        \\n        return *max_element(vdp.back().begin(), vdp.back().end());\\n    }\\n    \\n    using Row = unsigned char;\\n    bool isValid(Row x, Row y){\\n        auto shiftL = y<<1, shiftR = y>>1;\\n        return (x&shiftL) == 0 && (x&shiftR) == 0;\\n    }    \\n    \\n    bool isValidRow(Row x, Row badSeats){ \\n        return isValid(x, x) && ((x&badSeats) == 0);\\n    }\\n    \\n    Row badSeats(vector<char>& seats){\\n        Row r = 0;\\n        for(int i=0;i<seats.size();i++){\\n            if(seats[i] == \\'#\\') r |= (1<<i);\\n        }\\n        return r;\\n    }\\n    \\n    int count(Row r){\\n        int cnt = 0;\\n        for(int i=0;i<8;i++)\\n            if((1<<i) & r) cnt++;\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        const int n = seats.size(), m = seats[0].size(), k = (1<<m);\\n        auto vdp = vector(n, vector(k,0));\\n        \\n        {\\n            Row bad = badSeats(seats[0]);\\n            for(int i=0; i<k; i++){\\n                if(!isValidRow(i, bad)) continue;\\n                vdp[0][i] = count(i);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1002381,
                "title": "c-dp-bitmask-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        vector<int> dp(256,0);\\n        vector<int> dp_tmp(256, 0);\\n        int ret=0;\\n        for(auto s: seats) {\\n            int mask = 0;\\n            for(char c: s) {\\n                mask <<=1;\\n                if(c==\\'.\\')\\n                    mask |=1;\\n            }\\n            dp_tmp[0] = ret;\\n            // find all submask \\n            for (int i=mask; i; i=(i-1)&mask){  // submask of I\\n                if((i&(i>>1))||(i&(i<<1)))\\n                    continue;\\n                int seat =0;\\n                for(int j=i; j>0; j=(j>>1)) {\\n                    if(j&1)\\n                        seat++;\\n                }\\n                int allow_mask = (~((i<<1)|(i>>1)))&0xFF;\\n                int pre_seat=dp[0];\\n                for(int j=allow_mask; j; j=(j-1)&allow_mask) {\\n                    pre_seat = max(pre_seat, dp[j]);\\n                }\\n                int best = seat+pre_seat;\\n                //cout<<i<<\",\"<<best<<endl;\\n                dp_tmp[i] = best;\\n                ret= max(ret, best);\\n            }\\n            ret = max(ret, dp_tmp[0]);\\n            dp = dp_tmp;\\n            fill(dp_tmp.begin(), dp_tmp.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        vector<int> dp(256,0);\\n        vector<int> dp_tmp(256, 0);\\n        int ret=0;\\n        for(auto s: seats) {\\n            int mask = 0;\\n            for(char c: s) {\\n                mask <<=1;\\n                if(c==\\'.\\')\\n                    mask |=1;\\n            }\\n            dp_tmp[0] = ret;\\n            // find all submask \\n            for (int i=mask; i; i=(i-1)&mask){  // submask of I\\n                if((i&(i>>1))||(i&(i<<1)))\\n                    continue;\\n                int seat =0;\\n                for(int j=i; j>0; j=(j>>1)) {\\n                    if(j&1)\\n                        seat++;\\n                }\\n                int allow_mask = (~((i<<1)|(i>>1)))&0xFF;\\n                int pre_seat=dp[0];\\n                for(int j=allow_mask; j; j=(j-1)&allow_mask) {\\n                    pre_seat = max(pre_seat, dp[j]);\\n                }\\n                int best = seat+pre_seat;\\n                //cout<<i<<\",\"<<best<<endl;\\n                dp_tmp[i] = best;\\n                ret= max(ret, best);\\n            }\\n            ret = max(ret, dp_tmp[0]);\\n            dp = dp_tmp;\\n            fill(dp_tmp.begin(), dp_tmp.end(), 0);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 971266,
                "title": "python-bitmask-dp-with-explanation-and-comments",
                "content": "**Intuition** :- The core idea of the solution is that the number of students in the current row depends only on the arrangement of students in the upper row. Now to represent arrangement we could use something like bits(1 if students could sit there and 0 if the seat is broken). So we calcute first independently the maximum number of students that could sit in a row and store them.\\n\\nThen what we do for each row is go through all valid states and for each valid state find the maximum answer using the previous rows states and store them in a dp. The answer is the maximum anwer for any state in a row.\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        max_st = [0] * len(seats)\\n        for i in range(len(seats)):\\n            cnt = 1\\n            st = 0\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'.\\':\\n                    st += cnt\\n                cnt = cnt * 2\\n            max_st[i] = st\\n        ans = 0\\n        \\n        dp = {}\\n        for i in range(len(seats)): \\n            for j in range(1 << len(seats[i])):\\n\\t\\t\\t\\n\\t\\t\\t\\t# checking if the state is a subset of the total students that could sit in this row and also checking if the state doesn\\'t have any adjacent ones\\n                if j & max_st[i] == j and (j & (j >> 1)) == 0:\\n                    dp[i, j] = 0\\n                    set_bits = self.find_set_bits(j)\\n                    if i - 1 >= 0:\\n                        for k in range(1 << len(seats[i-1])):\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# checking if this state exists in previous row and checking if the upper left and upper right corners don\\'t have 1\\'s\\n                            if (i-1, k) in dp and (((j >> 1 & k) == 0) and ((j << 1 & k) == 0)):\\n                                dp[i, j] = max(dp[i, j], dp[i-1, k] + set_bits)\\n                            \\n                    else:\\n                        dp[i, j] = set_bits\\n                    ans = max(ans, dp[i, j])\\n        return ans\\n    \\n    def find_set_bits(self, num):\\n        set_bits = 0\\n        while(num):\\n            if num % 2:\\n                set_bits += 1\\n            num //= 2\\n        return set_bits\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        max_st = [0] * len(seats)\\n        for i in range(len(seats)):\\n            cnt = 1\\n            st = 0\\n            for j in range(len(seats[i])):\\n                if seats[i][j] == \\'.\\':\\n                    st += cnt\\n                cnt = cnt * 2\\n            max_st[i] = st\\n        ans = 0\\n        \\n        dp = {}\\n        for i in range(len(seats)): \\n            for j in range(1 << len(seats[i])):\\n\\t\\t\\t\\n\\t\\t\\t\\t# checking if the state is a subset of the total students that could sit in this row and also checking if the state doesn\\'t have any adjacent ones\\n                if j & max_st[i] == j and (j & (j >> 1)) == 0:\\n                    dp[i, j] = 0\\n                    set_bits = self.find_set_bits(j)\\n                    if i - 1 >= 0:\\n                        for k in range(1 << len(seats[i-1])):\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t# checking if this state exists in previous row and checking if the upper left and upper right corners don\\'t have 1\\'s\\n                            if (i-1, k) in dp and (((j >> 1 & k) == 0) and ((j << 1 & k) == 0)):\\n                                dp[i, j] = max(dp[i, j], dp[i-1, k] + set_bits)\\n                            \\n                    else:\\n                        dp[i, j] = set_bits\\n                    ans = max(ans, dp[i, j])\\n        return ans\\n    \\n    def find_set_bits(self, num):\\n        set_bits = 0\\n        while(num):\\n            if num % 2:\\n                set_bits += 1\\n            num //= 2\\n        return set_bits\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917962,
                "title": "standard-dp-with-row-vector-as-the-state-80ms",
                "content": "```\\n#Implementation #1\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats), len(seats[0])\\n\\n        def backtrack(prev,i,curr,j): #generate all possible row vectors given previous row\\n            if j==n:\\n                self.perm.append(curr)\\n                return\\n            if seats[i][j]==\".\" and (j==0 or curr[-1]==0) and (j==0 or prev[j-1]==0) and (j==n-1 or prev[j+1]==0):\\n                backtrack(prev,i,curr+tuple([1]),j+1)\\n            backtrack(prev,i,curr+tuple([0]),j+1)\\n        \\n        @lru_cache(None)        \\n        def dp(prev,i):\\n            if i==m: return 0\\n            self.perm = []\\n            backtrack(prev,i,(),0)\\n            return max(sum(curr)+dp(tuple(curr),i+1) for curr in self.perm)\\n        return dp(tuple([0]*n),0)\\n\\t\\t\\n# Implementation #2\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats), len(seats[0])\\n\\n        def genSet(i): #generate all possible row vectors\\n            out = [()]\\n            for j in range(n):\\n                nOut = []\\n                for s in out:\\n                    if seats[i][j]==\".\" and (len(s)==0 or s[-1]==0):\\n                        nOut.append(s+tuple([1]))\\n                    nOut.append(s+tuple([0]))\\n                out=nOut\\n            return out\\n        \\n        S={i:genSet(i) for i in range(m)}\\n                \\n        @lru_cache(None)        \\n        def dp(prev,i):\\n            if i==m: return 0\\n            ans = 0\\n            for curr in S[i]:\\n                if any(curr[j] and ((j>0 and prev[j-1]) or (j<n-1 and prev[j+1])) for j in range(n)):\\n                    continue\\n                ans = max(ans, sum(curr) + dp(curr,i+1))\\n            return ans\\n        return dp(tuple([0]*n),0)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#Implementation #1\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats), len(seats[0])\\n\\n        def backtrack(prev,i,curr,j): #generate all possible row vectors given previous row\\n            if j==n:\\n                self.perm.append(curr)\\n                return\\n            if seats[i][j]==\".\" and (j==0 or curr[-1]==0) and (j==0 or prev[j-1]==0) and (j==n-1 or prev[j+1]==0):\\n                backtrack(prev,i,curr+tuple([1]),j+1)\\n            backtrack(prev,i,curr+tuple([0]),j+1)\\n        \\n        @lru_cache(None)        \\n        def dp(prev,i):\\n            if i==m: return 0\\n            self.perm = []\\n            backtrack(prev,i,(),0)\\n            return max(sum(curr)+dp(tuple(curr),i+1) for curr in self.perm)\\n        return dp(tuple([0]*n),0)\\n\\t\\t\\n# Implementation #2\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        m,n = len(seats), len(seats[0])\\n\\n        def genSet(i): #generate all possible row vectors\\n            out = [()]\\n            for j in range(n):\\n                nOut = []\\n                for s in out:\\n                    if seats[i][j]==\".\" and (len(s)==0 or s[-1]==0):\\n                        nOut.append(s+tuple([1]))\\n                    nOut.append(s+tuple([0]))\\n                out=nOut\\n            return out\\n        \\n        S={i:genSet(i) for i in range(m)}\\n                \\n        @lru_cache(None)        \\n        def dp(prev,i):\\n            if i==m: return 0\\n            ans = 0\\n            for curr in S[i]:\\n                if any(curr[j] and ((j>0 and prev[j-1]) or (j<n-1 and prev[j+1])) for j in range(n)):\\n                    continue\\n                ans = max(ans, sum(curr) + dp(curr,i+1))\\n            return ans\\n        return dp(tuple([0]*n),0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917347,
                "title": "java-state-compressed-dp-38-55-tle",
                "content": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    private final int[][] direction = new int[][]{{0,1}, {-1,1}, {0,-1}, {-1,-1}, {1,1}, {1,-1}};\\n\\n    public int maxStudents(char[][] seats) {\\n        int row = seats.length;\\n        int col = seats[0].length;\\n\\n        List<int[]> record = new ArrayList<>();\\n        int emptySeatsCnt = 0;\\n        int[][] recordRev = new int[row][col];\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(seats[i][j] == \\'.\\') {\\n                    record.add(new int[]{i,j});\\n                    recordRev[i][j] = emptySeatsCnt;\\n                    emptySeatsCnt++;\\n                }\\n            }\\n        }\\n\\n        int emptySeats = record.size();\\n        int fullSet = (1<<emptySeats) - 1;\\n        int[] dp = new int[fullSet + 1];\\n        int maxStudentCnt = 0;\\n        // base case\\n        dp[0] = 0;\\n        // iteration\\n        for(int state = 0; state < fullSet; state++) {\\n            for(int idx = 0; idx < record.size(); idx++) {\\n                if((state>>idx & 1) == 1) {\\n                    continue;\\n                }\\n                int[] idx_row_col = record.get(idx);\\n                int idx_row = idx_row_col[0];\\n                int idx_col = idx_row_col[1];\\n\\n                int new_state = state;\\n                for (int[] ints : direction) {\\n                    int n_i = idx_row + ints[0];\\n                    int n_j = idx_col + ints[1];\\n                    if (n_i >= 0 && n_i < row && n_j >= 0 && n_j < col && seats[n_i][n_j] == \\'.\\') {\\n                        new_state = new_state | (1<<recordRev[n_i][n_j]);\\n                    }\\n                }\\n                new_state = new_state | (1<<idx);\\n                dp[new_state] = Math.max(dp[new_state], dp[state] + 1);\\n                maxStudentCnt = Math.max(dp[new_state], maxStudentCnt);\\n            }\\n        }\\n        // res\\n        return maxStudentCnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    private final int[][] direction = new int[][]{{0,1}, {-1,1}, {0,-1}, {-1,-1}, {1,1}, {1,-1}};\\n\\n    public int maxStudents(char[][] seats) {\\n        int row = seats.length;\\n        int col = seats[0].length;\\n\\n        List<int[]> record = new ArrayList<>();\\n        int emptySeatsCnt = 0;\\n        int[][] recordRev = new int[row][col];\\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(seats[i][j] == \\'.\\') {\\n                    record.add(new int[]{i,j});\\n                    recordRev[i][j] = emptySeatsCnt;\\n                    emptySeatsCnt++;\\n                }\\n            }\\n        }\\n\\n        int emptySeats = record.size();\\n        int fullSet = (1<<emptySeats) - 1;\\n        int[] dp = new int[fullSet + 1];\\n        int maxStudentCnt = 0;\\n        // base case\\n        dp[0] = 0;\\n        // iteration\\n        for(int state = 0; state < fullSet; state++) {\\n            for(int idx = 0; idx < record.size(); idx++) {\\n                if((state>>idx & 1) == 1) {\\n                    continue;\\n                }\\n                int[] idx_row_col = record.get(idx);\\n                int idx_row = idx_row_col[0];\\n                int idx_col = idx_row_col[1];\\n\\n                int new_state = state;\\n                for (int[] ints : direction) {\\n                    int n_i = idx_row + ints[0];\\n                    int n_j = idx_col + ints[1];\\n                    if (n_i >= 0 && n_i < row && n_j >= 0 && n_j < col && seats[n_i][n_j] == \\'.\\') {\\n                        new_state = new_state | (1<<recordRev[n_i][n_j]);\\n                    }\\n                }\\n                new_state = new_state | (1<<idx);\\n                dp[new_state] = Math.max(dp[new_state], dp[state] + 1);\\n                maxStudentCnt = Math.max(dp[new_state], maxStudentCnt);\\n            }\\n        }\\n        // res\\n        return maxStudentCnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873844,
                "title": "bitmask-dp",
                "content": "The critical step is to get the dp formula.  Learned from here: \\nhttps://leetcode.com/problems/maximum-students-taking-exam/discuss/503686/A-simple-tutorial-on-this-bitmasking-problem\\n```\\n// dp[i][bitmask] i-th row with bitmask, #people, including this row\\n// dp[i][bitmask] = dp[i - 1][compatible_bitmask] + my_people\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<unordered_map<int, int>> dp(m, unordered_map<int, int>());\\n        int ans = 0;\\n        for (int bitmask = 0; bitmask < (1 << n); ++bitmask) {\\n            if (safeSeatCompatible(bitmask, seats.back()) && selfCompatible(bitmask)) {\\n                ans = max(ans, getdp(seats, m - 1, bitmask, dp));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    int getdp(vector<vector<char>>& seats, int i, int curBitmask, vector<unordered_map<int, int>>& dp) {\\n        if (auto it = dp[i].find(curBitmask); it != dp[i].end()) {\\n            return it->second;\\n        }\\n        if (i == 0) {\\n            return dp[i][curBitmask] = countOnes(curBitmask);\\n        }\\n\\n        int n = seats[0].size();\\n        int ans = 0;\\n        int people = countOnes(curBitmask);\\n        for (int nextBitMask = 0; nextBitMask < (1 << n); ++nextBitMask) {\\n            if (safeSeatCompatible(nextBitMask, seats[i - 1])\\n                && selfCompatible(nextBitMask)\\n                && twoRowsCompatible(curBitmask, nextBitMask)) {\\n                ans = max(ans, people + getdp(seats, i - 1, nextBitMask, dp));\\n            }\\n        }\\n\\n        return dp[i][curBitmask] = ans;\\n    }\\n\\n    bool safeSeatCompatible(int bitmask, vector<char>& seat) {\\n        int n = seat.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (seat[i] == \\'#\\' && (bitmask & (1 << i))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool selfCompatible(int bitmask) {\\n        if ((bitmask >> 1) & bitmask) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    bool twoRowsCompatible(int bitmask1, int bitmask2) {\\n        if ((bitmask1 >> 1) & bitmask2) {\\n            return false;\\n        }\\n        if ((bitmask2 >> 1) & bitmask1) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int countOnes(int bitmask) {\\n        int ans = 0;\\n        while (bitmask) {\\n            ++ans;\\n            bitmask &= bitmask - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// dp[i][bitmask] i-th row with bitmask, #people, including this row\\n// dp[i][bitmask] = dp[i - 1][compatible_bitmask] + my_people\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<unordered_map<int, int>> dp(m, unordered_map<int, int>());\\n        int ans = 0;\\n        for (int bitmask = 0; bitmask < (1 << n); ++bitmask) {\\n            if (safeSeatCompatible(bitmask, seats.back()) && selfCompatible(bitmask)) {\\n                ans = max(ans, getdp(seats, m - 1, bitmask, dp));\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    int getdp(vector<vector<char>>& seats, int i, int curBitmask, vector<unordered_map<int, int>>& dp) {\\n        if (auto it = dp[i].find(curBitmask); it != dp[i].end()) {\\n            return it->second;\\n        }\\n        if (i == 0) {\\n            return dp[i][curBitmask] = countOnes(curBitmask);\\n        }\\n\\n        int n = seats[0].size();\\n        int ans = 0;\\n        int people = countOnes(curBitmask);\\n        for (int nextBitMask = 0; nextBitMask < (1 << n); ++nextBitMask) {\\n            if (safeSeatCompatible(nextBitMask, seats[i - 1])\\n                && selfCompatible(nextBitMask)\\n                && twoRowsCompatible(curBitmask, nextBitMask)) {\\n                ans = max(ans, people + getdp(seats, i - 1, nextBitMask, dp));\\n            }\\n        }\\n\\n        return dp[i][curBitmask] = ans;\\n    }\\n\\n    bool safeSeatCompatible(int bitmask, vector<char>& seat) {\\n        int n = seat.size();\\n        for (int i = 0; i < n; ++i) {\\n            if (seat[i] == \\'#\\' && (bitmask & (1 << i))) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    bool selfCompatible(int bitmask) {\\n        if ((bitmask >> 1) & bitmask) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    bool twoRowsCompatible(int bitmask1, int bitmask2) {\\n        if ((bitmask1 >> 1) & bitmask2) {\\n            return false;\\n        }\\n        if ((bitmask2 >> 1) & bitmask1) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    int countOnes(int bitmask) {\\n        int ans = 0;\\n        while (bitmask) {\\n            ++ans;\\n            bitmask &= bitmask - 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838748,
                "title": "java-bitmask-easy-solution",
                "content": "```\\nclass Solution {\\n    static int maxx(int row,int bitprev,int bit,char[][] sea){\\n        if(row>=sea.length){\\n            return 0;\\n        }\\n        if(aa[row][bitprev][bit]!=-1){return aa[row][bitprev][bit];}\\n        int maxs=-1;\\n        for(int j=0;j<sea[0].length;j++){\\n            if(sea[row][j]==\\'#\\'){continue;}\\n            int ii=bit & (1 << j);\\n            if(ii!=0){continue;}\\n            if(j!=0 && j!=sea[0].length-1){\\n                int ij=bitprev & ( 1 << (j-1) );\\n                int ji=bitprev & ( 1 << (j+1 ));\\n                int ij1=bit & ( 1 << (j-1) );\\n                int ji1=bit & ( 1 << (j+1 ));\\n\\n                if(ij==0 && ji==0 && ij1==0 && ji1==0){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                  \\n\\n                    }\\n                }\\n            else if(j==0){\\n                \\n                int ji=bitprev & ( 1 << (j+1 ));\\n                int ji1=bit & ( 1 << (j+1 ));\\n                if( ji==0 && ji1==0){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                   \\n\\n                    }\\n                \\n            }\\n            else{\\n                int ij=bitprev & ( 1 << (j-1) );\\n                int ij1=bit & ( 1 << (j-1) );\\n                if(ij==0 && ij1==0 ){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                  \\n\\n                    }\\n                }\\n    }\\n        \\n            maxs=Math.max(maxs,maxx(row+1,bit,0,sea) );\\n   \\n        return aa[row][bitprev][bit]=maxs;\\n            }\\n    static int[][][] aa;\\n        \\n    \\n    public int maxStudents(char[][] seats) {\\n        aa=new int[seats.length][(int)Math.pow(2,seats[0].length)+1][(int)Math.pow(2,seats[0].length)+1];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<aa[0][0].length;k++){\\n                    aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return maxx(0,0,0,seats);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static int maxx(int row,int bitprev,int bit,char[][] sea){\\n        if(row>=sea.length){\\n            return 0;\\n        }\\n        if(aa[row][bitprev][bit]!=-1){return aa[row][bitprev][bit];}\\n        int maxs=-1;\\n        for(int j=0;j<sea[0].length;j++){\\n            if(sea[row][j]==\\'#\\'){continue;}\\n            int ii=bit & (1 << j);\\n            if(ii!=0){continue;}\\n            if(j!=0 && j!=sea[0].length-1){\\n                int ij=bitprev & ( 1 << (j-1) );\\n                int ji=bitprev & ( 1 << (j+1 ));\\n                int ij1=bit & ( 1 << (j-1) );\\n                int ji1=bit & ( 1 << (j+1 ));\\n\\n                if(ij==0 && ji==0 && ij1==0 && ji1==0){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                  \\n\\n                    }\\n                }\\n            else if(j==0){\\n                \\n                int ji=bitprev & ( 1 << (j+1 ));\\n                int ji1=bit & ( 1 << (j+1 ));\\n                if( ji==0 && ji1==0){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                   \\n\\n                    }\\n                \\n            }\\n            else{\\n                int ij=bitprev & ( 1 << (j-1) );\\n                int ij1=bit & ( 1 << (j-1) );\\n                if(ij==0 && ij1==0 ){\\n                    maxs=Math.max(maxs,maxx(row,bitprev,bit|(1<<j),sea)+1 );\\n                  \\n\\n                    }\\n                }\\n    }\\n        \\n            maxs=Math.max(maxs,maxx(row+1,bit,0,sea) );\\n   \\n        return aa[row][bitprev][bit]=maxs;\\n            }\\n    static int[][][] aa;\\n        \\n    \\n    public int maxStudents(char[][] seats) {\\n        aa=new int[seats.length][(int)Math.pow(2,seats[0].length)+1][(int)Math.pow(2,seats[0].length)+1];\\n        for(int j=0;j<aa.length;j++){\\n            for(int i=0;i<aa[0].length;i++){\\n                for(int k=0;k<aa[0][0].length;k++){\\n                    aa[j][i][k]=-1;\\n                }\\n            }\\n        }\\n        return maxx(0,0,0,seats);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835370,
                "title": "bfs-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxnum = 0;\\n    map<string,int> scnt;\\n    queue<string> q;\\n    void dfs(string& pre,string& cur, vector<char>& seat, int pos, int cnt)\\n    {\\n        if(pos>=seat.size())\\n        {\\n            maxnum = max(maxnum,cnt);\\n            if(scnt.count(cur)==0)  q.push(cur);\\n            scnt[cur] = max(scnt[cur],cnt);\\n            return;\\n        }\\n        if(seat[pos]!=\\'#\\'&& (pos==0||pre[pos-1]!=\\'@\\')&&((pos==seat.size()-1)||pre[pos+1]!=\\'@\\'))\\n        {\\n            cur[pos]=\\'@\\';       \\n            dfs(pre,cur,seat,pos+2,cnt+1); \\n        }\\n        cur[pos]=\\'#\\';       \\n        dfs(pre,cur,seat,pos+1,cnt); \\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        int w = seats[0].size();\\n        string s(w+1,\\'#\\');\\n        s[w] = -1;  //row info\\n        scnt[s] = 0;\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n            auto pre = q.front(); q.pop();\\n            if(pre[w]==seats.size()-1) break;\\n            string cur = string(w+1,\\'#\\');\\n            cur[w] = pre[w]+1;\\n            dfs(pre,cur,seats[cur[w]],0,scnt[pre]);\\n        }\\n        return maxnum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxnum = 0;\\n    map<string,int> scnt;\\n    queue<string> q;\\n    void dfs(string& pre,string& cur, vector<char>& seat, int pos, int cnt)\\n    {\\n        if(pos>=seat.size())\\n        {\\n            maxnum = max(maxnum,cnt);\\n            if(scnt.count(cur)==0)  q.push(cur);\\n            scnt[cur] = max(scnt[cur],cnt);\\n            return;\\n        }\\n        if(seat[pos]!=\\'#\\'&& (pos==0||pre[pos-1]!=\\'@\\')&&((pos==seat.size()-1)||pre[pos+1]!=\\'@\\'))\\n        {\\n            cur[pos]=\\'@\\';       \\n            dfs(pre,cur,seat,pos+2,cnt+1); \\n        }\\n        cur[pos]=\\'#\\';       \\n        dfs(pre,cur,seat,pos+1,cnt); \\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        int w = seats[0].size();\\n        string s(w+1,\\'#\\');\\n        s[w] = -1;  //row info\\n        scnt[s] = 0;\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n            auto pre = q.front(); q.pop();\\n            if(pre[w]==seats.size()-1) break;\\n            string cur = string(w+1,\\'#\\');\\n            cur[w] = pre[w]+1;\\n            dfs(pre,cur,seats[cur[w]],0,scnt[pre]);\\n        }\\n        return maxnum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810000,
                "title": "simple-c-code-using-bitmask",
                "content": "```\\nvoid maxStudents_(int val, int num, int row, int col, vector<vector<int>>& m, vector<vector<char>>& seats) {\\n\\n\\tif (col >= seats[0].size()) {\\n\\t\\tint v = 0;\\n\\n\\t\\tfor (int i = 0; i < 256; ++i) {\\n\\t\\t\\tif (((val << 1) & i) == 0 && ((val >> 1) & i) == 0) {\\n\\t\\t\\t\\tv = max(v, m[row - 1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tm[row][val] = v + num;\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (seats[row - 1][col] == \\'.\\') {\\n\\t\\tif (col == 0 || ((val & (1 << (col - 1))) == 0)) {\\n\\t\\t\\tval |= (1 << col);\\n\\t\\t\\tmaxStudents_(val, num + 1, row, col + 1, m, seats);\\n\\t\\t\\tval &= ~(1 << col);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxStudents_(val, num, row, col + 1, m, seats);\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n\\n\\tvector<vector<int>> m(seats.size() + 1, vector<int>(256, 0));\\n\\n\\tfor (int i = 0; i < seats.size(); ++i)\\n\\t\\tmaxStudents_(0, 0, i + 1, 0, m, seats);\\n\\n\\tint val = 0;\\n\\n\\tfor (int i = 0; i < 256; ++i) val = max(val, m.back()[i]);\\n\\n\\treturn val;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid maxStudents_(int val, int num, int row, int col, vector<vector<int>>& m, vector<vector<char>>& seats) {\\n\\n\\tif (col >= seats[0].size()) {\\n\\t\\tint v = 0;\\n\\n\\t\\tfor (int i = 0; i < 256; ++i) {\\n\\t\\t\\tif (((val << 1) & i) == 0 && ((val >> 1) & i) == 0) {\\n\\t\\t\\t\\tv = max(v, m[row - 1][i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tm[row][val] = v + num;\\n\\t\\treturn;\\n\\t}\\n\\n\\tif (seats[row - 1][col] == \\'.\\') {\\n\\t\\tif (col == 0 || ((val & (1 << (col - 1))) == 0)) {\\n\\t\\t\\tval |= (1 << col);\\n\\t\\t\\tmaxStudents_(val, num + 1, row, col + 1, m, seats);\\n\\t\\t\\tval &= ~(1 << col);\\n\\t\\t}\\n\\t}\\n\\n\\treturn maxStudents_(val, num, row, col + 1, m, seats);\\n}\\n\\nint maxStudents(vector<vector<char>>& seats) {\\n\\n\\tvector<vector<int>> m(seats.size() + 1, vector<int>(256, 0));\\n\\n\\tfor (int i = 0; i < seats.size(); ++i)\\n\\t\\tmaxStudents_(0, 0, i + 1, 0, m, seats);\\n\\n\\tint val = 0;\\n\\n\\tfor (int i = 0; i < 256; ++i) val = max(val, m.back()[i]);\\n\\n\\treturn val;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 788609,
                "title": "anyone-knows-where-my-bugs-are",
                "content": "```\\npublic int maxStudents(char[][] seats) {\\n        int m = seats.length;\\n        int n = seats[0].length;\\n        int[][] dp = new int[m + 1][1 << n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int prev = 0; prev < (1 << n); prev++) {\\n                for (int cur = 0; cur < (1 << n); cur++) {\\n                    boolean valid = true;\\n                    for (int j = 0; j < n && valid; j++) {\\n                        if ((cur & (1 << j)) == 0) {\\n                            continue;\\n                        }\\n                        if (seats[i][j] == \\'#\\') {\\n                            valid = false;\\n                        }\\n                        // 00010\\n                        // 00100 1 << (n - j)\\n                        // 00001 1 << (n - j - 2)\\n                        boolean l = (j == 0 ? false : ((cur & (1 << (n - j))) == 1));\\n                        boolean r = (j == n - 1 ? false : ((cur & (1 << (n - j - 2))) == 1));\\n                        boolean ul = ((j == 0 || i == 0) ? false : ((prev & (1 << (n - j))) == 1));\\n                        boolean ur = ((j == n - 1 || i == 0) ? false : ((prev & (1 << (n - j - 2))) == 1));\\n                        if (l || r || ul || ur) {\\n                            valid = false;\\n                        }\\n                    }\\n                    if (valid) {\\n                        dp[i + 1][cur] = Math.max(dp[i + 1][cur], dp[i][prev] + count(cur));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int j = 0; j < (1 << n); j++) {\\n            result = Math.max(result, dp[m][j]);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int state) {\\n        int count = 0;\\n        while (state > 0) {\\n            if ((state & 1) == 1) {\\n                count++;\\n            }\\n            state >>>= 1;\\n        }\\n        return count;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\npublic int maxStudents(char[][] seats) {\\n        int m = seats.length;\\n        int n = seats[0].length;\\n        int[][] dp = new int[m + 1][1 << n];\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int prev = 0; prev < (1 << n); prev++) {\\n                for (int cur = 0; cur < (1 << n); cur++) {\\n                    boolean valid = true;\\n                    for (int j = 0; j < n && valid; j++) {\\n                        if ((cur & (1 << j)) == 0) {\\n                            continue;\\n                        }\\n                        if (seats[i][j] == \\'#\\') {\\n                            valid = false;\\n                        }\\n                        // 00010\\n                        // 00100 1 << (n - j)\\n                        // 00001 1 << (n - j - 2)\\n                        boolean l = (j == 0 ? false : ((cur & (1 << (n - j))) == 1));\\n                        boolean r = (j == n - 1 ? false : ((cur & (1 << (n - j - 2))) == 1));\\n                        boolean ul = ((j == 0 || i == 0) ? false : ((prev & (1 << (n - j))) == 1));\\n                        boolean ur = ((j == n - 1 || i == 0) ? false : ((prev & (1 << (n - j - 2))) == 1));\\n                        if (l || r || ul || ur) {\\n                            valid = false;\\n                        }\\n                    }\\n                    if (valid) {\\n                        dp[i + 1][cur] = Math.max(dp[i + 1][cur], dp[i][prev] + count(cur));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        int result = 0;\\n        for (int j = 0; j < (1 << n); j++) {\\n            result = Math.max(result, dp[m][j]);\\n        }\\n        return result;\\n    }\\n    \\n    private int count(int state) {\\n        int count = 0;\\n        while (state > 0) {\\n            if ((state & 1) == 1) {\\n                count++;\\n            }\\n            state >>>= 1;\\n        }\\n        return count;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 785897,
                "title": "dp-with-bit-masking",
                "content": "```\\n/*\\nWe denote dp[i][mask] as the maximum number of students for the first i rows while the students in the i-th row follow the masking mask. There should be no adjancent valid states in mask. The transition function is:\\n\\ndp[i][mask] = max(dp[i - 1][mask\\']) + number of valid bits(mask)\\nwhere mask\\' is the masking for the (i-1)-th row. To prevent students from cheating, the following equation must hold:\\n\\n(mask & (mask\\' >> 1)) == 0, there should be no students in the upper left position for every student.\\n\\n((mask >> 1) & mask\\') == 0, there should be no students in the upper right position for every student.\\n\\nIf these two equation holds and dp[i - 1][mask\\'] itself is valid, we could then transit from dp[i - 1][mask\\'] to dp[i][mask] according to the transition function.\\n\\nAnd the last question is, how can we compute the number of valid bits in a masking efficiently? In C++, we can simply use the built-in function __builtin_popcount(mask). For other programming languages, we can pre-compute by using count[i] = count[i/2] + (i % 2 == 1) and store them in an array.\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<int> validity; // the validity of each row in the classroom\\n        for (int i = 0; i < m; ++i) {\\n            int cur = 0;\\n            for (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t// the j-th bit is 1 if and only if the j-th seat is not broken\\n\\t\\t\\t\\t// here the 0th bit is the most significant bit\\n                cur = cur * 2 + (seats[i][j] == \\'.\\');\\n            }\\n            validity.push_back(cur);\\n        }\\n\\t\\t\\n\\t\\t// all the f states are set -1 as invalid states in the beginning\\n\\t\\t// here f[i][mask] represents the first i-1 rows to handle corner cases\\n        vector<vector<int>> f(m + 1, vector<int>(1 << n, -1));\\n\\t\\t// f[0][0] is a valid state\\n\\t\\t// think of a virtual row in the front and no students are sitting in that row\\n        f[0][0] = 0;\\n        for (int i = 1; i <= m; ++i) {\\n            int valid = validity[i - 1];\\n\\t\\t\\t// the interval [0, 1 << n) includes all the n-bit states for a row of students\\n\\t\\t\\t// please note that state 0 represents no student sitting in this row\\n\\t\\t\\t// which is always a valid state\\n            for (int j = 0; j < (1 << n); ++j) {\\n\\t\\t\\t\\t// (j & valid) == j: check if j is a subset of valid\\n\\t\\t\\t\\t// !(j & (j >> 1)): check if there is no adjancent students in the row\\n                if ((j & valid) == j && !(j & (j >> 1))) {\\n\\t\\t\\t\\t\\t// f[i][j] may transit from f[i -1][k]\\n                    for (int k = 0; k < (1 << n); ++k) {\\n\\t\\t\\t\\t\\t\\t// !(j & (k >> 1)): no students in the upper left positions\\n\\t\\t\\t\\t\\t\\t// !((j >> 1) & k): no students in the upper right positions\\n\\t\\t\\t\\t\\t\\t// f[i - 1][k] != -1: the previous state is valid\\n                        if (!(j & (k >> 1)) && !((j >> 1) & k) && f[i - 1][k] != -1) {\\n                            f[i][j] = max(f[i][j], f[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// the answer is the maximum among all f[m][mask]\\n        return *max_element(f[m].begin(), f[m].end());\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nWe denote dp[i][mask] as the maximum number of students for the first i rows while the students in the i-th row follow the masking mask. There should be no adjancent valid states in mask. The transition function is:\\n\\ndp[i][mask] = max(dp[i - 1][mask\\']) + number of valid bits(mask)\\nwhere mask\\' is the masking for the (i-1)-th row. To prevent students from cheating, the following equation must hold:\\n\\n(mask & (mask\\' >> 1)) == 0, there should be no students in the upper left position for every student.\\n\\n((mask >> 1) & mask\\') == 0, there should be no students in the upper right position for every student.\\n\\nIf these two equation holds and dp[i - 1][mask\\'] itself is valid, we could then transit from dp[i - 1][mask\\'] to dp[i][mask] according to the transition function.\\n\\nAnd the last question is, how can we compute the number of valid bits in a masking efficiently? In C++, we can simply use the built-in function __builtin_popcount(mask). For other programming languages, we can pre-compute by using count[i] = count[i/2] + (i % 2 == 1) and store them in an array.\\n*/\\n\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int m = seats.size();\\n        int n = seats[0].size();\\n        vector<int> validity; // the validity of each row in the classroom\\n        for (int i = 0; i < m; ++i) {\\n            int cur = 0;\\n            for (int j = 0; j < n; ++j) {\\n\\t\\t\\t\\t// the j-th bit is 1 if and only if the j-th seat is not broken\\n\\t\\t\\t\\t// here the 0th bit is the most significant bit\\n                cur = cur * 2 + (seats[i][j] == \\'.\\');\\n            }\\n            validity.push_back(cur);\\n        }\\n\\t\\t\\n\\t\\t// all the f states are set -1 as invalid states in the beginning\\n\\t\\t// here f[i][mask] represents the first i-1 rows to handle corner cases\\n        vector<vector<int>> f(m + 1, vector<int>(1 << n, -1));\\n\\t\\t// f[0][0] is a valid state\\n\\t\\t// think of a virtual row in the front and no students are sitting in that row\\n        f[0][0] = 0;\\n        for (int i = 1; i <= m; ++i) {\\n            int valid = validity[i - 1];\\n\\t\\t\\t// the interval [0, 1 << n) includes all the n-bit states for a row of students\\n\\t\\t\\t// please note that state 0 represents no student sitting in this row\\n\\t\\t\\t// which is always a valid state\\n            for (int j = 0; j < (1 << n); ++j) {\\n\\t\\t\\t\\t// (j & valid) == j: check if j is a subset of valid\\n\\t\\t\\t\\t// !(j & (j >> 1)): check if there is no adjancent students in the row\\n                if ((j & valid) == j && !(j & (j >> 1))) {\\n\\t\\t\\t\\t\\t// f[i][j] may transit from f[i -1][k]\\n                    for (int k = 0; k < (1 << n); ++k) {\\n\\t\\t\\t\\t\\t\\t// !(j & (k >> 1)): no students in the upper left positions\\n\\t\\t\\t\\t\\t\\t// !((j >> 1) & k): no students in the upper right positions\\n\\t\\t\\t\\t\\t\\t// f[i - 1][k] != -1: the previous state is valid\\n                        if (!(j & (k >> 1)) && !((j >> 1) & k) && f[i - 1][k] != -1) {\\n                            f[i][j] = max(f[i][j], f[i - 1][k] + __builtin_popcount(j));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n\\t\\t// the answer is the maximum among all f[m][mask]\\n        return *max_element(f[m].begin(), f[m].end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785816,
                "title": "cpp-better-pruning-tle-38-55",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<vector<char>> v,int i,int j){\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(i>0){\\n            if(j>0){\\n                if(v[i-1][j-1]==\\'o\\')\\n                    return false;\\n            }\\n            if(j<n-1){\\n                if(v[i-1][j+1]==\\'o\\')\\n                    return false;\\n            }\\n        }\\n        if(j>0)\\n            if(v[i][j-1]==\\'o\\')\\n                return false;\\n        if(j<n-1)\\n            if(v[i][j+1]==\\'o\\')\\n                return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>> seats, int&x, int i,int c){\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        if(i==m*n)\\n            x=max(x,c);\\n        else{\\n            if(seats[i/n][i%n]==\\'#\\')\\n                dfs(seats,x,i+1,c);\\n            else if(seats[i/n][i%n]==\\'.\\'){\\n                seats[i/n][i%n]=\\'o\\';\\n                if(check(seats,i/n,i%n)){\\n                    dfs(seats,x,i+1,c+1);\\n                }\\n                seats[i/n][i%n]=\\'.\\';\\n                dfs(seats,x,i+1,c);\\n            }\\n        }\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        int x=0;\\n        dfs(seats,x,0,0);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<vector<char>> v,int i,int j){\\n        int m=v.size();\\n        int n=v[0].size();\\n        if(i>0){\\n            if(j>0){\\n                if(v[i-1][j-1]==\\'o\\')\\n                    return false;\\n            }\\n            if(j<n-1){\\n                if(v[i-1][j+1]==\\'o\\')\\n                    return false;\\n            }\\n        }\\n        if(j>0)\\n            if(v[i][j-1]==\\'o\\')\\n                return false;\\n        if(j<n-1)\\n            if(v[i][j+1]==\\'o\\')\\n                return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>> seats, int&x, int i,int c){\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        if(i==m*n)\\n            x=max(x,c);\\n        else{\\n            if(seats[i/n][i%n]==\\'#\\')\\n                dfs(seats,x,i+1,c);\\n            else if(seats[i/n][i%n]==\\'.\\'){\\n                seats[i/n][i%n]=\\'o\\';\\n                if(check(seats,i/n,i%n)){\\n                    dfs(seats,x,i+1,c+1);\\n                }\\n                seats[i/n][i%n]=\\'.\\';\\n                dfs(seats,x,i+1,c);\\n            }\\n        }\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& seats) {\\n        int x=0;\\n        dfs(seats,x,0,0);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 785808,
                "title": "cpp-simple-prune-backtracking-tle-38-55",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<vector<char>> v){\\n        int m=v.size();\\n        int n=v[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i][j]!=\\'o\\')\\n                    continue;\\n                if(i>0){\\n                    if(j>0){\\n                        if(v[i-1][j-1]==\\'o\\')\\n                            return false;\\n                    }\\n                    if(j<n-1){\\n                        if(v[i-1][j+1]==\\'o\\')\\n                            return false;\\n                    }\\n                }\\n                if(j>0)\\n                    if(v[i][j-1]==\\'o\\')\\n                        return false;\\n                if(j<n-1)\\n                    if(v[i][j+1]==\\'o\\')\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>> seats, int&x, int i,int c){\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        if(i==m*n)\\n            x=max(x,c);\\n        else{\\n            if(seats[i/n][i%n]==\\'#\\')\\n                dfs(seats,x,i+1,c);\\n            else if(seats[i/n][i%n]==\\'.\\'){\\n                seats[i/n][i%n]=\\'o\\';\\n                if(check(seats)){\\n                    dfs(seats,x,i+1,c+1);\\n                }\\n                seats[i/n][i%n]=\\'.\\';\\n                dfs(seats,x,i+1,c);\\n            }\\n        }\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int x=0;\\n        dfs(seats,x,0,0);\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool check(vector<vector<char>> v){\\n        int m=v.size();\\n        int n=v[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(v[i][j]!=\\'o\\')\\n                    continue;\\n                if(i>0){\\n                    if(j>0){\\n                        if(v[i-1][j-1]==\\'o\\')\\n                            return false;\\n                    }\\n                    if(j<n-1){\\n                        if(v[i-1][j+1]==\\'o\\')\\n                            return false;\\n                    }\\n                }\\n                if(j>0)\\n                    if(v[i][j-1]==\\'o\\')\\n                        return false;\\n                if(j<n-1)\\n                    if(v[i][j+1]==\\'o\\')\\n                        return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>> seats, int&x, int i,int c){\\n        int m=seats.size();\\n        int n=seats[0].size();\\n        if(i==m*n)\\n            x=max(x,c);\\n        else{\\n            if(seats[i/n][i%n]==\\'#\\')\\n                dfs(seats,x,i+1,c);\\n            else if(seats[i/n][i%n]==\\'.\\'){\\n                seats[i/n][i%n]=\\'o\\';\\n                if(check(seats)){\\n                    dfs(seats,x,i+1,c+1);\\n                }\\n                seats[i/n][i%n]=\\'.\\';\\n                dfs(seats,x,i+1,c);\\n            }\\n        }\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        int x=0;\\n        dfs(seats,x,0,0);\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782785,
                "title": "dfs-memo-python",
                "content": "```\\nclass Solution:\\n    def maxStudents(self, A: List[List[str]]) -> int:\\n        if not A:\\n            return 0\\n        row, col = len(A), len(A[0])\\n        ref = {}\\n        # if we start from row 0 all we need to care about \\n        # is the row after and how its changed\\n        def recurse(cur_r,nex_r,col_v):\\n            if cur_r == row - 1:\\n                return onerow(row-1)\\n            if (cur_r,nex_r,col_v,tuple(A[cur_r]),tuple(A[nex_r])) in ref:\\n                return ref[(cur_r,nex_r,col_v,tuple(A[cur_r]),tuple(A[nex_r]))]\\n            temp = 0\\n            if col_v < col:\\n                if A[cur_r][col_v] == \\'.\\':\\n                    seen = set()\\n                    for a,b in ((cur_r,col_v), (cur_r,col_v+1),(cur_r + 1,col_v-1),(cur_r +1, col_v + 1)):\\n                        if -1 < a < row and -1 < b < col and A[a][b] == \\'.\\':\\n                            A[a][b] = \\'X\\'\\n                            seen.add((a,b))\\n                    temp = max(temp, 1 + recurse(cur_r,nex_r,col_v + 2))\\n                    for r,c in seen:\\n                        A[r][c] = \\'.\\'\\n                temp = max(temp,recurse(cur_r, nex_r,col_v + 1))\\n            else:\\n                temp = recurse(cur_r+1, nex_r+1,0)\\n            ref[(cur_r,nex_r,col_v,tuple(A[cur_r]),tuple(A[nex_r]))] = temp\\n            return temp\\n        def onerow(index):\\n            take,ntake = [-3,0],[0,0]\\n            for i in range(col):\\n                if A[index][i] == \\'.\\':\\n                    if take[0] < i-1:\\n                        take = [i,take[1] + 1]\\n                    else:\\n                        ntake =[i, ntake[1] + 1]\\n                else:\\n                    if take[1] > ntake[1]:\\n                        ntake = take\\n                    else:\\n                        take = ntake\\n            return max(take[1],ntake[1])\\n        return recurse(0,1,0)\\n\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def maxStudents(self, A: List[List[str]]) -> int:\\n        if not A:\\n            return 0\\n        row, col = len(A), len(A[0])\\n        ref = {}",
                "codeTag": "Java"
            },
            {
                "id": 753257,
                "title": "java-dp-explanation",
                "content": "ith row\\'s count only directly depends on i-1 th row. although i-1 th row depends on i-2, we only consider direct impact\\ntwo thing to make a valid arrangement:\\n1. ith row itself is valid, means no adjcent students, for example \"0,0,0,1,1\" is not valid, we don\\'t need to consider this, to check validality, we only need to shift it one position to the right, make it \"0,0,0,0,1\" then do AND operation with \"0,0,0,1,1\", if result is not zero, mean invalid(meaning there are some adjcent 1s)\\nin the code, we have n columns, the possible options(we call it state) in ith row are 2^n, we compare each of these states by AND with original state, if the result is not zero means this state is a valid sub state(contains some 1s and no adjcent 1s)\\n2. check up left seat and up right seats, which related to i-1 th row\\nwe compare these valid state with i-1 th rows, how many states in i-1th row, 2^n, the way to get the count is pretty similar with step 1, just change \"original state\" to one of the 2^n states in i-1 th row which we have calculated already, represented in maxs[i-1][k], it means max students int i-1 th row, at state k\\nwe need to shift i-1 th row\\'s state(state k) one position to right then AND with ith row\\'s valid state, and also shift i th row\\'s valid state one position to right then AND with state k\\n```\\nclass Solution {\\n    public int maxStudents(char[][] seats) {\\n        int rows = seats.length;\\n        int cols = seats[0].length;\\n\\t\\t// dp means ith row\\'s original state, available spot filled with \\'1\\' otherwise \\'0\\', may not be a valid state\\n        int[] dp = new int[rows+1];\\n        for(int i=1; i<=rows; i++){\\n            for(int j=0; j<cols; j++){\\n                dp[i] = (dp[i]<<1) + (seats[i-1][j]==\\'.\\'?1:0);\\n            }\\n        }\\n        int res = 0;\\n        int state = 1<<cols;\\n        int[][] maxs = new int[rows+1][state];\\n        for(int i=1; i<=rows; i++){\\n            for(int j=0; j<state; j++){\\n                if((dp[i]&j)==j && (j&(j>>1))==0){\\n                    for(int m=0; m<state; m++){\\n                        if((m&dp[i-1])==m && ((m>>1)&j)==0 && ((j>>1)&m)==0)\\n                            maxs[i][j] = Math.max(maxs[i][j], maxs[i-1][m]+Integer.bitCount(j));\\n                    }\\n                    res = Math.max(res, maxs[i][j]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxStudents(char[][] seats) {\\n        int rows = seats.length;\\n        int cols = seats[0].length;\\n\\t\\t// dp means ith row\\'s original state, available spot filled with \\'1\\' otherwise \\'0\\', may not be a valid state\\n        int[] dp = new int[rows+1];\\n        for(int i=1; i<=rows; i++){\\n            for(int j=0; j<cols; j++){\\n                dp[i] = (dp[i]<<1) + (seats[i-1][j]==\\'.\\'?1:0);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 752797,
                "title": "clean-top-down-solution-beat-100",
                "content": "class Solution {\\n    public int maxStudents(char[][] seats) {\\n        int row = seats.length;\\n        int col = seats[0].length;\\n        int[] validSets = new int[row];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                validSets[i] = (validSets[i] << 1) + (seats[i][j] == \\'#\\' ? 0 : 1);\\n            }\\n        }\\n        Integer[][] dp = new Integer[row][1<<col];\\n        return dpUpDown(1<<col, row-1, 0, validSets, dp);\\n    }\\n\\n    int dpUpDown(int stateSize, int i, int mask, int[] validSets, Integer[][] dp) {\\n        if (i < 0) return 0;\\n        if (dp[i][mask] != null) return dp[i][mask];\\n        int ans = 0;\\n        for (int j = 0; j < stateSize; j++) {\\n            if (((j & validSets[i]) == j) && ((j>>1 & j) == 0) && ((j >> 1 & mask) == 0) && ((mask >> 1 & j) == 0)) {\\n               ans = Math.max(ans, Integer.bitCount(j) + dpUpDown(stateSize, i-1, j, validSets, dp));\\n            }\\n        }\\n        return dp[i][mask] = ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxStudents(char[][] seats) {\\n        int row = seats.length;\\n        int col = seats[0].length;\\n        int[] validSets = new int[row];\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                validSets[i] = (validSets[i] << 1) + (seats[i][j] == \\'#\\' ? 0 : 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 733638,
                "title": "java-bitmask-dp-state-compression-dp-time-o-m-2-n-2-n",
                "content": "```\\npublic int maxStudents(char[][] seats) {\\n        int m = seats.length, n = seats[0].length;\\n        //generate the number matches the available seats\\n        int[] s = new int[m];// seats bits -> (.->0) (#->1)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\') {\\n                    s[i] += (1 << (n - 1 - j));\\n                }\\n            }\\n        } \\n        //count 1s \\n        int[] count = new int[1 << n];\\n        for (int i = 0; i < (1 << n); i++) {\\n            int cnt = 0;\\n            int j = i;\\n            while (j > 0) {\\n                if ((j & 1) == 1) {\\n                    cnt++;\\n                }\\n                j = (j >> 1);\\n            }\\n            count[i] = cnt;\\n        }\\n        //state compression dp starts here.\\n        int[][] dp = new int[m][1 << n];\\n        for (int[] a : dp) {\\n            Arrays.fill(a, -1);\\n        }\\n        int max = 0;\\n        //initial state in first row\\n        for (int j = 0; j < (1 << n); j++) {\\n            if (((j & (j >> 1)) == 0) && ((s[0] & j) == 0)) {\\n                dp[0][j] = count[j];\\n                max = Math.max(max, dp[0][j]);\\n            }\\n        }\\n        //start dp from 2nd row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < (1 << n); j++) {\\n                if (((j & (j >> 1)) == 0) && ((s[i] & j) == 0)) {\\n                    for (int k = 0; k < (1 << n); k++) {\\n                        if (dp[i - 1][k] != -1 && ((k & (j << 1)) == 0) && ((k & (j >> 1)) == 0)) {\\n                            dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + count[j]);\\n                            max = Math.max(max, dp[i][j]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxStudents(char[][] seats) {\\n        int m = seats.length, n = seats[0].length;\\n        //generate the number matches the available seats\\n        int[] s = new int[m];// seats bits -> (.->0) (#->1)\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (seats[i][j] == \\'#\\') {\\n                    s[i] += (1 << (n - 1 - j));\\n                }\\n            }\\n        } \\n        //count 1s \\n        int[] count = new int[1 << n];\\n        for (int i = 0; i < (1 << n); i++) {\\n            int cnt = 0;\\n            int j = i;\\n            while (j > 0) {\\n                if ((j & 1) == 1) {\\n                    cnt++;\\n                }\\n                j = (j >> 1);\\n            }\\n            count[i] = cnt;\\n        }\\n        //state compression dp starts here.\\n        int[][] dp = new int[m][1 << n];\\n        for (int[] a : dp) {\\n            Arrays.fill(a, -1);\\n        }\\n        int max = 0;\\n        //initial state in first row\\n        for (int j = 0; j < (1 << n); j++) {\\n            if (((j & (j >> 1)) == 0) && ((s[0] & j) == 0)) {\\n                dp[0][j] = count[j];\\n                max = Math.max(max, dp[0][j]);\\n            }\\n        }\\n        //start dp from 2nd row\\n        for (int i = 1; i < m; i++) {\\n            for (int j = 0; j < (1 << n); j++) {\\n                if (((j & (j >> 1)) == 0) && ((s[i] & j) == 0)) {\\n                    for (int k = 0; k < (1 << n); k++) {\\n                        if (dp[i - 1][k] != -1 && ((k & (j << 1)) == 0) && ((k & (j >> 1)) == 0)) {\\n                            dp[i][j] = Math.max(dp[i][j], dp[i - 1][k] + count[j]);\\n                            max = Math.max(max, dp[i][j]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729316,
                "title": "easy-c-dp-bitmasks",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<char>>S;\\n    int n,m;\\n    int M ;\\n    \\n    vector<vector<int>> dp;\\n    vector<vector<int>> safe;\\n    vector<vector<int>>stored_masks;\\n    \\n    bool intersafe(int m1,int m2){\\n        if(safe[m1][m2] != -1) return safe[m1][m2];\\n        \\n        for(int i = 0;i+1<m;i++){\\n            int upleft = (m1&(1<<(i+1))) >=1;\\n            int curr = (m2&(1<<i)) >=1;\\n            if(curr && upleft) return safe[m1][m2] = 0;\\n        }\\n        for(int i = m-1;i>0;i--){\\n            int upright = (m1&(1<<(i-1))) >=1;\\n            int curr = (m2&(1<<i)) >=1;\\n            if(curr && upright) return safe[m1][m2] =  0;\\n        }\\n        return safe[m1][m2] = 1;\\n    }\\n    int solve(int pos = 0,int mask = 0){\\n        \\n        if(pos == n){\\n            return 0;\\n        }\\n        if(dp[pos][mask] != -1){\\n            return dp[pos][mask];\\n        }\\n        int &ans = dp[pos][mask];\\n        vector<int> masks = stored_masks[pos];\\n        \\n        for(int m : masks){\\n            if(intersafe(m,mask)){\\n                ans = max(ans,__builtin_popcount(m) + solve(pos+1,m));\\n            }\\n        }\\n        return ans;\\n    }\\n    void make_masks(){\\n        for(int k =0;k<n;k++){\\n            for(int i = 0;i<M;i++){\\n                bool safe = 1;\\n                for(int j=0;j<m;j++){\\n                    if(i&(1<<j) && S[k][j] == \\'#\\'){\\n                        safe = 0;\\n                    }\\n                }\\n                if(safe && !( (i&(i >>1))>=1)) stored_masks[k].push_back(i);\\n            }\\n        }\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        S = seats;\\n        n = seats.size();\\n        m = seats[0].size();\\n        M = (1 << m);\\n        stored_masks.resize(n);\\n        safe = vector<vector<int>> (M,vector<int>(M,-1));\\n        \\n        int ans = 0;\\n        \\n        make_masks();\\n        vector<int> masks1 = stored_masks[0];\\n        for(int m :masks1){\\n            dp.clear();\\n            dp = vector<vector<int>>(n+1,vector<int>(M+1,-1));\\n                                     \\n            ans = max(ans,solve(0,m));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    vector<vector<char>>S;\\n    int n,m;\\n    int M ;\\n    \\n    vector<vector<int>> dp;\\n    vector<vector<int>> safe;\\n    vector<vector<int>>stored_masks;\\n    \\n    bool intersafe(int m1,int m2){\\n        if(safe[m1][m2] != -1) return safe[m1][m2];\\n        \\n        for(int i = 0;i+1<m;i++){\\n            int upleft = (m1&(1<<(i+1))) >=1;\\n            int curr = (m2&(1<<i)) >=1;\\n            if(curr && upleft) return safe[m1][m2] = 0;\\n        }\\n        for(int i = m-1;i>0;i--){\\n            int upright = (m1&(1<<(i-1))) >=1;\\n            int curr = (m2&(1<<i)) >=1;\\n            if(curr && upright) return safe[m1][m2] =  0;\\n        }\\n        return safe[m1][m2] = 1;\\n    }\\n    int solve(int pos = 0,int mask = 0){\\n        \\n        if(pos == n){\\n            return 0;\\n        }\\n        if(dp[pos][mask] != -1){\\n            return dp[pos][mask];\\n        }\\n        int &ans = dp[pos][mask];\\n        vector<int> masks = stored_masks[pos];\\n        \\n        for(int m : masks){\\n            if(intersafe(m,mask)){\\n                ans = max(ans,__builtin_popcount(m) + solve(pos+1,m));\\n            }\\n        }\\n        return ans;\\n    }\\n    void make_masks(){\\n        for(int k =0;k<n;k++){\\n            for(int i = 0;i<M;i++){\\n                bool safe = 1;\\n                for(int j=0;j<m;j++){\\n                    if(i&(1<<j) && S[k][j] == \\'#\\'){\\n                        safe = 0;\\n                    }\\n                }\\n                if(safe && !( (i&(i >>1))>=1)) stored_masks[k].push_back(i);\\n            }\\n        }\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        S = seats;\\n        n = seats.size();\\n        m = seats[0].size();\\n        M = (1 << m);\\n        stored_masks.resize(n);\\n        safe = vector<vector<int>> (M,vector<int>(M,-1));\\n        \\n        int ans = 0;\\n        \\n        make_masks();\\n        vector<int> masks1 = stored_masks[0];\\n        for(int m :masks1){\\n            dp.clear();\\n            dp = vector<vector<int>>(n+1,vector<int>(M+1,-1));\\n                                     \\n            ans = max(ans,solve(0,m));\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706360,
                "title": "python3-pure-bit-manipulation-top-down-4-liner",
                "content": "```\\ndef maxStudents(self, seats: List[List[str]]) -> int:\\n\\tbins = list(map(lambda a : reduce(lambda x,y : x<<1 | (y==\\'.\\'), a, 0), seats))   \\n\\t@lru_cache(None)\\n\\tdef dp(i,mask): return (0 if i ==len(seats) else max( bin(curr).count(\\'1\\') + dp(i+1,curr) for curr in range(2**len(seats[0])) if (curr | bins[i] == bins[i]) and (curr | mask) & ((curr | mask) >> 1) == 0))\\n\\treturn dp(0,0)\\n```\\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        bins = list(map(lambda a : reduce(lambda x,y : x<<1 | (y==\\'.\\'), a, 0), seats))   \\n        @lru_cache(None)\\n        def dp(i,mask):\\n            if i == len(seats): return 0\\n            return max(bin(curr).count(\\'1\\') + dp(i+1,curr)   \\n                        for curr in range(1 << len(seats[0])) \\n                            if (  (curr | bins[i] == bins[i]) and \\n                                (curr | mask) & ((curr | mask) >> 1) == 0  ) )\\n        return dp(0,0)\\n```\\n\\nTime Complexity : O(r\\\\*c\\\\*(2^c)^2) (Would be O(r*(2^c)^2) if there was popcount in python)\\nSpace complexity : O(r*2^c)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef maxStudents(self, seats: List[List[str]]) -> int:\\n\\tbins = list(map(lambda a : reduce(lambda x,y : x<<1 | (y==\\'.\\'), a, 0), seats))   \\n\\t@lru_cache(None)\\n\\tdef dp(i,mask): return (0 if i ==len(seats) else max( bin(curr).count(\\'1\\') + dp(i+1,curr) for curr in range(2**len(seats[0])) if (curr | bins[i] == bins[i]) and (curr | mask) & ((curr | mask) >> 1) == 0))\\n\\treturn dp(0,0)\\n```\n```\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        bins = list(map(lambda a : reduce(lambda x,y : x<<1 | (y==\\'.\\'), a, 0), seats))   \\n        @lru_cache(None)\\n        def dp(i,mask):\\n            if i == len(seats): return 0\\n            return max(bin(curr).count(\\'1\\') + dp(i+1,curr)   \\n                        for curr in range(1 << len(seats[0])) \\n                            if (  (curr | bins[i] == bins[i]) and \\n                                (curr | mask) & ((curr | mask) >> 1) == 0  ) )\\n        return dp(0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700908,
                "title": "java-dfs-memo-explained",
                "content": "```\\nclass Solution {\\n    \\n    // transform seats[][] array to a string so its easier to store state snapshots in a map\\n    // state snapshot is an entire array concatenated as a string\\n    // dfs on each \\'.\\' for two ways, either take a sit (+ 1 and mark related seats as not allowed with \\'#\\')\\n    // or dont take a sit and move to the next one\\n\\n    int n;\\n    int m;\\n    Map<String, Integer> memo;\\n    char[][] seats;\\n\\n    public int maxStudents(char[][] s) {\\n        memo = new HashMap<>();\\n        seats = s;\\n        n = seats.length;\\n        m = seats[0].length;\\n\\n        // build seats[][] as a string\\n        String state = \"\";\\n        for (int i = 0; i < n; i++) {\\n            state += new String(s[i]);\\n        }\\n\\n        return dfs(0, state.toCharArray());\\n    }\\n\\n    public int dfs(int p, char[] state) {\\n        int max = 0;\\n        String stateStr = new String(state);\\n\\n        // check if result for a state is already calculated\\n        Integer res = memo.get(stateStr);\\n        if (res != null) return res;\\n\\n        while (p < n * m) {\\n\\n            if (state[p] == \\'.\\') {\\n\\n                int i = p / m;\\n                int j = p % m;\\n\\n                // dfs for not taking a sit\\n                state[p] = \\'#\\';\\n                max = Math.max(max, dfs(p + 1, Arrays.copyOf(state, state.length)));\\n\\n                // dfs for taking a sit, marking relative sits as not allowed with \\'#\\'\\n                if (j + 1 < m) {\\n                    state[i * m + j + 1] = \\'#\\';\\n                    if (i + 1 < n) {\\n                        state[(i + 1) * m + j + 1] = \\'#\\';\\n                    }\\n                }\\n                if (j - 1 >= 0) {\\n                    state[i * m + j - 1] = \\'#\\';\\n                    if (i + 1 < n) {\\n                        state[(i + 1) * m + j - 1] = \\'#\\';\\n                    }\\n                }\\n                max = Math.max(max, 1 + dfs(p + 1, Arrays.copyOf(state, state.length)));\\n            }\\n\\n            p++;\\n        }\\n\\n        memo.put(stateStr, max);\\n\\n        return max;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // transform seats[][] array to a string so its easier to store state snapshots in a map\\n    // state snapshot is an entire array concatenated as a string\\n    // dfs on each \\'.\\' for two ways, either take a sit (+ 1 and mark related seats as not allowed with \\'#\\')\\n    // or dont take a sit and move to the next one\\n\\n    int n;\\n    int m;\\n    Map<String, Integer> memo;\\n    char[][] seats;\\n\\n    public int maxStudents(char[][] s) {\\n        memo = new HashMap<>();\\n        seats = s;\\n        n = seats.length;\\n        m = seats[0].length;\\n\\n        // build seats[][] as a string\\n        String state = \"\";\\n        for (int i = 0; i < n; i++) {\\n            state += new String(s[i]);\\n        }\\n\\n        return dfs(0, state.toCharArray());\\n    }\\n\\n    public int dfs(int p, char[] state) {\\n        int max = 0;\\n        String stateStr = new String(state);\\n\\n        // check if result for a state is already calculated\\n        Integer res = memo.get(stateStr);\\n        if (res != null) return res;\\n\\n        while (p < n * m) {\\n\\n            if (state[p] == \\'.\\') {\\n\\n                int i = p / m;\\n                int j = p % m;\\n\\n                // dfs for not taking a sit\\n                state[p] = \\'#\\';\\n                max = Math.max(max, dfs(p + 1, Arrays.copyOf(state, state.length)));\\n\\n                // dfs for taking a sit, marking relative sits as not allowed with \\'#\\'\\n                if (j + 1 < m) {\\n                    state[i * m + j + 1] = \\'#\\';\\n                    if (i + 1 < n) {\\n                        state[(i + 1) * m + j + 1] = \\'#\\';\\n                    }\\n                }\\n                if (j - 1 >= 0) {\\n                    state[i * m + j - 1] = \\'#\\';\\n                    if (i + 1 < n) {\\n                        state[(i + 1) * m + j - 1] = \\'#\\';\\n                    }\\n                }\\n                max = Math.max(max, 1 + dfs(p + 1, Arrays.copyOf(state, state.length)));\\n            }\\n\\n            p++;\\n        }\\n\\n        memo.put(stateStr, max);\\n\\n        return max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653176,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if(seats.empty() || seats[0].empty())return 0;\\n        int m = seats.size(), n = seats[0].size();\\n        map<string, int>memo;\\n        string str = \"\";\\n        for(auto a:seats){\\n            for(auto aa:a)str+=aa;\\n        }\\n        return dfs(str, memo, m, n);\\n    }\\n    \\n    int dfs(string& str, map<string, int>&memo, int m, int n){\\n        if(memo.count(str))return memo[str];\\n        string res = str;\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(str[i*n + j] == \\'.\\'){\\n                    res[i*n + j] = \\'x\\';\\n                    cnt = max(cnt, dfs(res, memo, m, n));\\n                    \\n                    if(j+1 < n){\\n                        if(res[i*n + j+1] == \\'.\\')res[i*n + j+1] = \\'x\\';\\n                        if(i+1 < m && res[(i+1)*n + j+1] == \\'.\\')res[(i+1)*n + j+1] = \\'x\\';\\n                    }\\n                    if(j-1 >= 0){\\n                        if(res[i*n + j-1] == \\'.\\')res[i*n + j-1] = \\'x\\';\\n                        if(i+1 < m && res[(i+1)*n + j-1] == \\'.\\')res[(i+1)*n + j-1] = \\'x\\';\\n                    }\\n                    cnt = max(cnt, 1+dfs(res, memo, m, n));\\n                }\\n            }\\n        }\\n        memo[str] = cnt;\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        if(seats.empty() || seats[0].empty())return 0;\\n        int m = seats.size(), n = seats[0].size();\\n        map<string, int>memo;\\n        string str = \"\";\\n        for(auto a:seats){\\n            for(auto aa:a)str+=aa;\\n        }\\n        return dfs(str, memo, m, n);\\n    }\\n    \\n    int dfs(string& str, map<string, int>&memo, int m, int n){\\n        if(memo.count(str))return memo[str];\\n        string res = str;\\n        int cnt = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(str[i*n + j] == \\'.\\'){\\n                    res[i*n + j] = \\'x\\';\\n                    cnt = max(cnt, dfs(res, memo, m, n));\\n                    \\n                    if(j+1 < n){\\n                        if(res[i*n + j+1] == \\'.\\')res[i*n + j+1] = \\'x\\';\\n                        if(i+1 < m && res[(i+1)*n + j+1] == \\'.\\')res[(i+1)*n + j+1] = \\'x\\';\\n                    }\\n                    if(j-1 >= 0){\\n                        if(res[i*n + j-1] == \\'.\\')res[i*n + j-1] = \\'x\\';\\n                        if(i+1 < m && res[(i+1)*n + j-1] == \\'.\\')res[(i+1)*n + j-1] = \\'x\\';\\n                    }\\n                    cnt = max(cnt, 1+dfs(res, memo, m, n));\\n                }\\n            }\\n        }\\n        memo[str] = cnt;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651906,
                "title": "c-dp-bitmask",
                "content": "```\\nclass Solution {\\npublic:\\n    int N, M;\\n    unordered_map<int,unordered_map<int,int>> MAP;\\n    int countSetBits(int a){\\n        int s = 0;\\n        for(int i=0;i<32;i++){\\n            if(((a>>i) & 1)==1) s++;\\n        }\\n        \\n        return s;        \\n    }\\n    int recurse(vector<vector<char>>& seats, int i, int j, int prevMask, int currMask){                        \\n        if(j>=M) {       \\n            \\n            if(MAP.find(i)!=MAP.end()){\\n                if(MAP[i].find(currMask)!=MAP[i].end()){\\n                    return MAP[i][currMask];\\n                }\\n            } \\n            \\n            MAP[i][currMask] = countSetBits(currMask)+recurse(seats,i+1,0,currMask,0);            \\n            return MAP[i][currMask];\\n        }\\n        if(i>=N){\\n            return 0;\\n        }                                                \\n        \\n        int ans = 0;\\n        if(((j-1)>=0 ? (((currMask >> (j-1)) & 1)==0) : true) &&\\n           ((j-1)>=0 ? (((prevMask >> (j-1)) & 1)==0) : true) &&             \\n           (((prevMask >> (j+1)) & 1)==0) &&  \\n           seats[i][j]==\\'.\\'){            \\n            ans = max(ans, recurse(seats,i,j+2,prevMask,currMask | (1<<j)));\\n            \\n        }        \\n        ans = max(ans, recurse(seats,i,j+1,prevMask,currMask));\\n        \\n        \\n        return ans;\\n        \\n    }\\n    int maxStudents(vector<vector<char>>& seats) {        \\n        N = seats.size();\\n        M = seats[0].size(); \\n        int ans =  recurse(seats,0,0,0,0);\\n        return ans;\\n    }\\n};\\n\\nstatic bool a = ios_base::sync_with_stdio(false);\\nstatic ostream *b = cin.tie(NULL);\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int N, M;\\n    unordered_map<int,unordered_map<int,int>> MAP;\\n    int countSetBits(int a){\\n        int s = 0;\\n        for(int i=0;i<32;i++){\\n            if(((a>>i) & 1)==1) s++;\\n        }\\n        \\n        return s;        \\n    }\\n    int recurse(vector<vector<char>>& seats, int i, int j, int prevMask, int currMask){                        \\n        if(j>=M) {       \\n            \\n            if(MAP.find(i)!=MAP.end()){\\n                if(MAP[i].find(currMask)!=MAP[i].end()){\\n                    return MAP[i][currMask];\\n                }\\n            } \\n            \\n            MAP[i][currMask] = countSetBits(currMask)+recurse(seats,i+1,0,currMask,0);            \\n            return MAP[i][currMask];\\n        }\\n        if(i>=N){\\n            return 0;\\n        }                                                \\n        \\n        int ans = 0;\\n        if(((j-1)>=0 ? (((currMask >> (j-1)) & 1)==0) : true) &&\\n           ((j-1)>=0 ? (((prevMask >> (j-1)) & 1)==0) : true) &&             \\n           (((prevMask >> (j+1)) & 1)==0) &&  \\n           seats[i][j]==\\'.\\'){            \\n            ans = max(ans, recurse(seats,i,j+2,prevMask,currMask | (1<<j)));\\n            \\n        }        \\n        ans = max(ans, recurse(seats,i,j+1,prevMask,currMask));\\n        \\n        \\n        return ans;\\n        \\n    }\\n    int maxStudents(vector<vector<char>>& seats) {        \\n        N = seats.size();\\n        M = seats[0].size(); \\n        int ans =  recurse(seats,0,0,0,0);\\n        return ans;\\n    }\\n};\\n\\nstatic bool a = ios_base::sync_with_stdio(false);\\nstatic ostream *b = cin.tie(NULL);\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621849,
                "title": "clean-c-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        int n = seats[0].size();\\n        int m = 1 << n;\\n        \\n        vector<pair<int, int>> dp = {{0, 0}};\\n        vector<pair<int, int>> dp_next;\\n       \\n        for(auto &row: seats) {\\n            dp_next.clear();\\n            \\n            for(int mask = m - 1; mask >= 0; mask--) {\\n                \\n                bool flag = true;\\n                for(int i = 0; i < n && flag; i++)\\n                    if(row[i] == \\'#\\' && (mask & (1 << i)))flag = false;\\n                \\n                if(!flag) continue;\\n                \\n                for(int i = 2; i < m && flag; i = i << 1)\\n                    if((mask & i) && (mask & (i >> 1)))flag = false;\\n                \\n                if(!flag) continue;\\n                \\n                int c = __builtin_popcount(mask);\\n                \\n                int bestScore = 0;\\n                \\n                for(auto [mask2, score]: dp) {\\n                    if(bestScore >= score) continue;\\n                    bool flag = true;\\n                    \\n                    for(int i = 2; i < m && flag; i = i << 1) {\\n                        if((mask & i) && (mask2 & (i / 2))) \\n                            flag = false; \\n                        if((mask2 & i) && (mask & (i / 2))) \\n                            flag = false;\\n                    }\\n                    \\n                    if(!flag) continue;\\n                    \\n                    bestScore = score;\\n                }\\n                \\n                dp_next.emplace_back(mask, bestScore + c);\\n                \\n            }\\n            \\n            swap(dp, dp_next);\\n        }\\n        \\n        int ans = 0;\\n        for(auto [_, s]: dp)\\n            ans = max(ans, s);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStudents(vector<vector<char>>& seats) {\\n        \\n        int n = seats[0].size();\\n        int m = 1 << n;\\n        \\n        vector<pair<int, int>> dp = {{0, 0}};\\n        vector<pair<int, int>> dp_next;\\n       \\n        for(auto &row: seats) {\\n            dp_next.clear();\\n            \\n            for(int mask = m - 1; mask >= 0; mask--) {\\n                \\n                bool flag = true;\\n                for(int i = 0; i < n && flag; i++)\\n                    if(row[i] == \\'#\\' && (mask & (1 << i)))flag = false;\\n                \\n                if(!flag) continue;\\n                \\n                for(int i = 2; i < m && flag; i = i << 1)\\n                    if((mask & i) && (mask & (i >> 1)))flag = false;\\n                \\n                if(!flag) continue;\\n                \\n                int c = __builtin_popcount(mask);\\n                \\n                int bestScore = 0;\\n                \\n                for(auto [mask2, score]: dp) {\\n                    if(bestScore >= score) continue;\\n                    bool flag = true;\\n                    \\n                    for(int i = 2; i < m && flag; i = i << 1) {\\n                        if((mask & i) && (mask2 & (i / 2))) \\n                            flag = false; \\n                        if((mask2 & i) && (mask & (i / 2))) \\n                            flag = false;\\n                    }\\n                    \\n                    if(!flag) continue;\\n                    \\n                    bestScore = score;\\n                }\\n                \\n                dp_next.emplace_back(mask, bestScore + c);\\n                \\n            }\\n            \\n            swap(dp, dp_next);\\n        }\\n        \\n        int ans = 0;\\n        for(auto [_, s]: dp)\\n            ans = max(ans, s);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606656,
                "title": "python-hungarian-solution",
                "content": "- [K\\u0151nig\\'s theorem (graph theory)](https://en.wikipedia.org/wiki/K%C5%91nig%27s_theorem_(graph_theory))\\n- [\\u4E8C\\u5206\\u56FE\\u6700\\u5927\\u5339\\u914D\\u7684K\\xF6nig\\u5B9A\\u7406\\u53CA\\u5176\\u8BC1\\u660E](http://www.matrix67.com/blog/archives/116)\\n- [[Tutorial] Maximum Independent Set in Bipartite Graphs](https://codeforces.com/blog/entry/72751)\\n```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n, m = len(seats), len(seats[0])\\n        def Hungarian():\\n            total, res = 0, 0\\n            match = [[-1]*m for _ in range(n)]\\n            for r in range(n):\\n                for c in range(m):\\n                    if seats[r][c] == \\'.\\':\\n                        total += 1\\n                    # if c&1:\\n                    #     continue\\n                    if seats[r][c] == \\'.\\' and match[r][c] == -1:\\n                        visited = set()\\n                        if dfs(r,c,visited,match):\\n                            res += 1\\n            return total-res\\n\\n        def dfs(r_,c_,visited_,match_):\\n            for dr in [-1,0,1]:\\n                for dc in [-1,1]:\\n                    x, y = r_+dr, c_+dc\\n                    if 0 <= x < n and 0 <= y < m and seats[x][y] == \\'.\\' and (x,y) not in visited_:\\n                        visited_.add((x,y))\\n                        if match_[x][y] == -1 or dfs(match_[x][y][0],match_[x][y][1],visited_,match_):\\n                            match_[x][y] = (r_,c_)\\n                            match_[r_][c_] = (x,y)\\n                            return True\\n            return False\\n\\n        return Hungarian()\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxStudents(self, seats: List[List[str]]) -> int:\\n        n, m = len(seats), len(seats[0])\\n        def Hungarian():\\n            total, res = 0, 0\\n            match = [[-1]*m for _ in range(n)]\\n            for r in range(n):\\n                for c in range(m):\\n                    if seats[r][c] == \\'.\\':\\n                        total += 1\\n                    # if c&1:\\n                    #     continue\\n                    if seats[r][c] == \\'.\\' and match[r][c] == -1:\\n                        visited = set()\\n                        if dfs(r,c,visited,match):\\n                            res += 1\\n            return total-res\\n\\n        def dfs(r_,c_,visited_,match_):\\n            for dr in [-1,0,1]:\\n                for dc in [-1,1]:\\n                    x, y = r_+dr, c_+dc\\n                    if 0 <= x < n and 0 <= y < m and seats[x][y] == \\'.\\' and (x,y) not in visited_:\\n                        visited_.add((x,y))\\n                        if match_[x][y] == -1 or dfs(match_[x][y][0],match_[x][y][1],visited_,match_):\\n                            match_[x][y] = (r_,c_)\\n                            match_[r_][c_] = (x,y)\\n                            return True\\n            return False\\n\\n        return Hungarian()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570584,
                "title": "a-c-solution-using-dp-and-bit-operation",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// dp[row][bitmask]\\n\\tint length;\\n\\tint maxStudents(vector<vector<char>>& seats) {\\n\\t\\tvector<int> s;\\n\\t\\tlength = seats[0].size();\\n\\t\\tvector<vector<int>> dp(seats.size(), vector<int>(int(pow(2,length))));\\n\\t\\tfor (int i = 0; i < seats.size(); i++) {\\n\\t\\t\\tint bitnum = 0;\\n\\t\\t\\tfor (int j = seats[i].size() - 1,k=1; j >= 0; j--,k=k*2) {\\n\\t\\t\\t\\tif (seats[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tbitnum += k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(bitnum);\\n\\t\\t}\\n\\t\\treturn dfs(0,0,s,dp);\\n\\t}\\n\\tint dfs(int row, int bitmask, vector<int>&seats, vector<vector<int>>&dp) {\\n\\t\\tif (row >= seats.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[row][bitmask] != 0)\\n\\t\\t\\treturn dp[row][bitmask];\\n\\t\\tint forbid = ~((bitmask >> 1)|(bitmask<<1));\\n\\t\\tint option = forbid & seats[row];\\n\\t\\tvector<int> options;\\n\\t\\tgetAllOptions(option,0,options);\\n\\t\\tint curMax = 0,cur;\\n\\t\\t// How to select bitmask in option?\\n\\t\\tfor (int i = 0; i < options.size(); i++) {\\n\\t\\t\\tcur=getNum(options[i])+dfs(row+1,options[i],seats,dp);\\n\\t\\t\\tif (curMax < cur)\\n\\t\\t\\t\\tcurMax = cur;\\n\\t\\t}\\n\\t\\tdp[row][bitmask] = curMax;\\n\\t\\treturn curMax;\\n\\t}\\n\\tint getNum(int option) {\\n\\t\\tint num = 0;\\n\\t\\twhile (option) {\\n\\t\\t\\tnum += option & 1;\\n\\t\\t\\toption = option >> 1;\\n\\t\\t}\\n\\t\\treturn num;\\n\\t}\\n\\tbool isRight(int option) {\\n\\t\\tint pre = -2;\\n\\t\\tint cur = 0;\\n\\t\\twhile (option) {\\n\\t\\t\\tif (option & 1) {\\n\\t\\t\\t\\tif (cur - pre == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t}\\n\\t\\t\\tcur++;\\n\\t\\t\\toption = option >> 1;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid getAllOptions(int option,int i,vector<int>& options) {\\n\\t\\tif (i == length) {\\n\\t\\t\\tif(isRight(option))\\n\\t\\t\\t\\toptions.push_back(option);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif ((1 << (length - i - 1))&option) {\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t\\t\\toption = ((~(1 << (length - i - 1))))&option;\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t}\\n\\t}\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// dp[row][bitmask]\\n\\tint length;\\n\\tint maxStudents(vector<vector<char>>& seats) {\\n\\t\\tvector<int> s;\\n\\t\\tlength = seats[0].size();\\n\\t\\tvector<vector<int>> dp(seats.size(), vector<int>(int(pow(2,length))));\\n\\t\\tfor (int i = 0; i < seats.size(); i++) {\\n\\t\\t\\tint bitnum = 0;\\n\\t\\t\\tfor (int j = seats[i].size() - 1,k=1; j >= 0; j--,k=k*2) {\\n\\t\\t\\t\\tif (seats[i][j] == \\'.\\') {\\n\\t\\t\\t\\t\\tbitnum += k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ts.push_back(bitnum);\\n\\t\\t}\\n\\t\\treturn dfs(0,0,s,dp);\\n\\t}\\n\\tint dfs(int row, int bitmask, vector<int>&seats, vector<vector<int>>&dp) {\\n\\t\\tif (row >= seats.size())\\n\\t\\t\\treturn 0;\\n\\t\\tif (dp[row][bitmask] != 0)\\n\\t\\t\\treturn dp[row][bitmask];\\n\\t\\tint forbid = ~((bitmask >> 1)|(bitmask<<1));\\n\\t\\tint option = forbid & seats[row];\\n\\t\\tvector<int> options;\\n\\t\\tgetAllOptions(option,0,options);\\n\\t\\tint curMax = 0,cur;\\n\\t\\t// How to select bitmask in option?\\n\\t\\tfor (int i = 0; i < options.size(); i++) {\\n\\t\\t\\tcur=getNum(options[i])+dfs(row+1,options[i],seats,dp);\\n\\t\\t\\tif (curMax < cur)\\n\\t\\t\\t\\tcurMax = cur;\\n\\t\\t}\\n\\t\\tdp[row][bitmask] = curMax;\\n\\t\\treturn curMax;\\n\\t}\\n\\tint getNum(int option) {\\n\\t\\tint num = 0;\\n\\t\\twhile (option) {\\n\\t\\t\\tnum += option & 1;\\n\\t\\t\\toption = option >> 1;\\n\\t\\t}\\n\\t\\treturn num;\\n\\t}\\n\\tbool isRight(int option) {\\n\\t\\tint pre = -2;\\n\\t\\tint cur = 0;\\n\\t\\twhile (option) {\\n\\t\\t\\tif (option & 1) {\\n\\t\\t\\t\\tif (cur - pre == 1)\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\tpre = cur;\\n\\t\\t\\t}\\n\\t\\t\\tcur++;\\n\\t\\t\\toption = option >> 1;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n\\tvoid getAllOptions(int option,int i,vector<int>& options) {\\n\\t\\tif (i == length) {\\n\\t\\t\\tif(isRight(option))\\n\\t\\t\\t\\toptions.push_back(option);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tif ((1 << (length - i - 1))&option) {\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t\\t\\toption = ((~(1 << (length - i - 1))))&option;\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t\\tgetAllOptions(option, i + 1, options);\\n\\t\\t}\\n\\t}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570087,
                "title": "rust-with-dfs-and-memo",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nfn dfs(seats: Vec<Vec<char>>, mut memo: &mut HashMap<String, i32>) -> i32 {\\n    let key = format!(\"{:?}\", seats);\\n    if memo.contains_key(&key) { return memo[&key]; }\\n    let mut res = 0;\\n    \\n    if !seats.iter().all(|r| r.iter().all(|x| *x == \\'#\\')) {\\n        res = res.max(dfs(take_first_available(&seats), &mut memo) + 1);\\n        res = res.max(dfs(not_take_first_available(&seats), &mut memo));\\n    }\\n    \\n    memo.insert(key, res);\\n    res\\n}\\n\\nfn take_first_available(seats: &Vec<Vec<char>>) -> Vec<Vec<char>> {\\n    let m = seats.len();\\n    let n = seats[0].len();\\n    let mut res = vec![vec![\\'-\\'; n]; m];\\n    let mut any_marked = false;\\n    for i in 0..m {\\n        for j in 0..n {\\n            if !any_marked && seats[i][j] == \\'.\\' {\\n                res[i][j] = \\'#\\';\\n                if j > 0 { res[i][j - 1] = \\'#\\' }\\n                if j < n - 1 { res[i][j + 1] = \\'#\\' }\\n                if i < m - 1 && j > 0 { res[i + 1][j - 1] = \\'#\\' }\\n                if i < m - 1 && j < n - 1 { res[i + 1][j + 1] = \\'#\\' }\\n                any_marked = true;\\n            } else if res[i][j] == \\'-\\' {\\n                res[i][j] = seats[i][j];   \\n            }\\n        }\\n    }\\n    res\\n}\\n\\nfn not_take_first_available(seats: &Vec<Vec<char>>) -> Vec<Vec<char>> {\\n    let m = seats.len();\\n    let n = seats[0].len();\\n    let mut res = vec![vec![\\'-\\'; n]; m];\\n    let mut any_marked = false;\\n    for i in 0..m {\\n        for j in 0..n {\\n            if !any_marked && seats[i][j] == \\'.\\' {\\n                res[i][j] = \\'#\\';\\n                any_marked = true;\\n            } else if res[i][j] == \\'-\\' {\\n                res[i][j] = seats[i][j];   \\n            }\\n        }\\n    }\\n    res\\n}\\n\\nimpl Solution {\\n    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {\\n        let mut memo = HashMap::new();\\n        dfs(seats, &mut memo)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nfn dfs(seats: Vec<Vec<char>>, mut memo: &mut HashMap<String, i32>) -> i32 {\\n    let key = format!(\"{:?}\", seats);\\n    if memo.contains_key(&key) { return memo[&key]; }\\n    let mut res = 0;\\n    \\n    if !seats.iter().all(|r| r.iter().all(|x| *x == \\'#\\')) {\\n        res = res.max(dfs(take_first_available(&seats), &mut memo) + 1);\\n        res = res.max(dfs(not_take_first_available(&seats), &mut memo));\\n    }\\n    \\n    memo.insert(key, res);\\n    res\\n}\\n\\nfn take_first_available(seats: &Vec<Vec<char>>) -> Vec<Vec<char>> {\\n    let m = seats.len();\\n    let n = seats[0].len();\\n    let mut res = vec![vec![\\'-\\'; n]; m];\\n    let mut any_marked = false;\\n    for i in 0..m {\\n        for j in 0..n {\\n            if !any_marked && seats[i][j] == \\'.\\' {\\n                res[i][j] = \\'#\\';\\n                if j > 0 { res[i][j - 1] = \\'#\\' }\\n                if j < n - 1 { res[i][j + 1] = \\'#\\' }\\n                if i < m - 1 && j > 0 { res[i + 1][j - 1] = \\'#\\' }\\n                if i < m - 1 && j < n - 1 { res[i + 1][j + 1] = \\'#\\' }\\n                any_marked = true;\\n            } else if res[i][j] == \\'-\\' {\\n                res[i][j] = seats[i][j];   \\n            }\\n        }\\n    }\\n    res\\n}\\n\\nfn not_take_first_available(seats: &Vec<Vec<char>>) -> Vec<Vec<char>> {\\n    let m = seats.len();\\n    let n = seats[0].len();\\n    let mut res = vec![vec![\\'-\\'; n]; m];\\n    let mut any_marked = false;\\n    for i in 0..m {\\n        for j in 0..n {\\n            if !any_marked && seats[i][j] == \\'.\\' {\\n                res[i][j] = \\'#\\';\\n                any_marked = true;\\n            } else if res[i][j] == \\'-\\' {\\n                res[i][j] = seats[i][j];   \\n            }\\n        }\\n    }\\n    res\\n}\\n\\nimpl Solution {\\n    pub fn max_students(seats: Vec<Vec<char>>) -> i32 {\\n        let mut memo = HashMap::new();\\n        dfs(seats, &mut memo)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560004,
                "title": "accepted-c-dp-solution-with-bit-manipulation",
                "content": "```\\n    public class Solution\\n    {\\n        public int MaxStudents(char[][] seats)\\n        {\\n            checked\\n            {\\n                int n = seats.Length;\\n                int m = seats[0].Length;\\n\\n                int[] rows = new int[n];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    int r = 0;\\n\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        if (seats[i][j] == \\'.\\')\\n                        {\\n                            r |= (1 << j);\\n                        }\\n                    }\\n\\n                    rows[i] = r;\\n                }\\n\\n                int maxMask = (int)Math.Pow(2, m);\\n\\n                int[,] dp = new int[n,maxMask];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int cand = 0; cand < maxMask; cand++)\\n                    {\\n                        var thisRow = cand & rows[i];\\n\\n                        bool valid = true;\\n\\n                        for (int j = 1; j < m - 1; j++)\\n                        {\\n                            if( (thisRow & (1 << j)) != 0)\\n                            {\\n                                if (((thisRow & (1 << (j - 1))) != 0) || ((thisRow & (1 << (j + 1))) != 0))\\n                                {\\n                                    valid = false;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n\\n                        if (!valid)\\n                        {\\n                            dp[i, cand] = -1;\\n                            continue;\\n                        }\\n\\n                        int current = 0;\\n                        for (int j = 0; j < m; j++)\\n                        {\\n                            if ((thisRow & (1 << j)) != 0)\\n                            {\\n                                current++;\\n                            }\\n                        }\\n\\n                        dp[i, cand] = current;\\n\\n                        if (i == 0)\\n                        {\\n                            continue;\\n                        }\\n\\n                        for (int prevCand = 0; prevCand < maxMask; prevCand++)\\n                        {\\n                            if (dp[i - 1, prevCand] < 0)\\n                            {\\n                                continue;\\n                            }\\n\\n                            var prevRow = prevCand & rows[i - 1];\\n                            bool canCombineWithPrevRow = true;\\n\\n                            for (int j = 0; j < m; j++)\\n                            {\\n                                if ((thisRow & (1 << j)) != 0)\\n                                {\\n                                    if (j > 0 && (prevRow & (1 << (j - 1))) != 0)\\n                                    {\\n                                        canCombineWithPrevRow = false;\\n                                        break;\\n                                    }\\n\\n                                    if (j < m - 1 && (prevRow & (1 << (j + 1))) != 0)\\n                                    {\\n                                        canCombineWithPrevRow = false;\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n\\n                            if (canCombineWithPrevRow)\\n                            {\\n                                dp[i, cand] = Math.Max(dp[i, cand], current + dp[i - 1, prevRow]);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int i = 0; i < maxMask; i++)\\n                {\\n                    res = Math.Max(res, dp[n - 1, i]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Bit Manipulation"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public int MaxStudents(char[][] seats)\\n        {\\n            checked\\n            {\\n                int n = seats.Length;\\n                int m = seats[0].Length;\\n\\n                int[] rows = new int[n];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    int r = 0;\\n\\n                    for (int j = 0; j < m; j++)\\n                    {\\n                        if (seats[i][j] == \\'.\\')\\n                        {\\n                            r |= (1 << j);\\n                        }\\n                    }\\n\\n                    rows[i] = r;\\n                }\\n\\n                int maxMask = (int)Math.Pow(2, m);\\n\\n                int[,] dp = new int[n,maxMask];\\n\\n                for (int i = 0; i < n; i++)\\n                {\\n                    for (int cand = 0; cand < maxMask; cand++)\\n                    {\\n                        var thisRow = cand & rows[i];\\n\\n                        bool valid = true;\\n\\n                        for (int j = 1; j < m - 1; j++)\\n                        {\\n                            if( (thisRow & (1 << j)) != 0)\\n                            {\\n                                if (((thisRow & (1 << (j - 1))) != 0) || ((thisRow & (1 << (j + 1))) != 0))\\n                                {\\n                                    valid = false;\\n                                    break;\\n                                }\\n                            }\\n                        }\\n\\n                        if (!valid)\\n                        {\\n                            dp[i, cand] = -1;\\n                            continue;\\n                        }\\n\\n                        int current = 0;\\n                        for (int j = 0; j < m; j++)\\n                        {\\n                            if ((thisRow & (1 << j)) != 0)\\n                            {\\n                                current++;\\n                            }\\n                        }\\n\\n                        dp[i, cand] = current;\\n\\n                        if (i == 0)\\n                        {\\n                            continue;\\n                        }\\n\\n                        for (int prevCand = 0; prevCand < maxMask; prevCand++)\\n                        {\\n                            if (dp[i - 1, prevCand] < 0)\\n                            {\\n                                continue;\\n                            }\\n\\n                            var prevRow = prevCand & rows[i - 1];\\n                            bool canCombineWithPrevRow = true;\\n\\n                            for (int j = 0; j < m; j++)\\n                            {\\n                                if ((thisRow & (1 << j)) != 0)\\n                                {\\n                                    if (j > 0 && (prevRow & (1 << (j - 1))) != 0)\\n                                    {\\n                                        canCombineWithPrevRow = false;\\n                                        break;\\n                                    }\\n\\n                                    if (j < m - 1 && (prevRow & (1 << (j + 1))) != 0)\\n                                    {\\n                                        canCombineWithPrevRow = false;\\n                                        break;\\n                                    }\\n                                }\\n                            }\\n\\n                            if (canCombineWithPrevRow)\\n                            {\\n                                dp[i, cand] = Math.Max(dp[i, cand], current + dp[i - 1, prevRow]);\\n                            }\\n                        }\\n                    }\\n                }\\n\\n                int res = 0;\\n                for (int i = 0; i < maxMask; i++)\\n                {\\n                    res = Math.Max(res, dp[n - 1, i]);\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557414,
                "title": "c-bitmask-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int mask1,int mask2,vector<vector<char>>& s,int indx){\\n        for(int i = 0;i<10;i++){\\n            int x = mask2 & (1<<i);\\n            int y = mask2 &(1<<(i+1));\\n            if(i<s[0].size()&&x>0&&s[indx][i]==\\'#\\')\\n                return false;\\n            if(x>0&&y>0)\\n                return false;\\n            y = mask1 &(1<<(i+1));\\n            if(y>0&&x>0)\\n                return false;\\n            if(i){\\n                y = mask1 & (1<<(i-1));\\n                if(y>0&&x>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int giveres(int row,int mask,int n,int m,vector<vector<int>>&dp,vector<vector<char>>& s){\\n        if(row==n)\\n            return 0;\\n        int &ret = dp[row][mask];\\n        if(ret!=-1)\\n            return ret;\\n        for(int i = 0;i<(1<<m);i++){\\n            if(check(mask,i,s,row))\\n                ret = max(ret,__builtin_popcount(i) + giveres(row+1,i,n,m,dp,s));\\n        }\\n        return ret;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& s) {\\n        int n = s.size();\\n        int m = s[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(1<<m+1,-1));\\n        return giveres(0,0,n,m,dp,s);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    bool check(int mask1,int mask2,vector<vector<char>>& s,int indx){\\n        for(int i = 0;i<10;i++){\\n            int x = mask2 & (1<<i);\\n            int y = mask2 &(1<<(i+1));\\n            if(i<s[0].size()&&x>0&&s[indx][i]==\\'#\\')\\n                return false;\\n            if(x>0&&y>0)\\n                return false;\\n            y = mask1 &(1<<(i+1));\\n            if(y>0&&x>0)\\n                return false;\\n            if(i){\\n                y = mask1 & (1<<(i-1));\\n                if(y>0&&x>0)\\n                    return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int giveres(int row,int mask,int n,int m,vector<vector<int>>&dp,vector<vector<char>>& s){\\n        if(row==n)\\n            return 0;\\n        int &ret = dp[row][mask];\\n        if(ret!=-1)\\n            return ret;\\n        for(int i = 0;i<(1<<m);i++){\\n            if(check(mask,i,s,row))\\n                ret = max(ret,__builtin_popcount(i) + giveres(row+1,i,n,m,dp,s));\\n        }\\n        return ret;\\n    }\\n    \\n    int maxStudents(vector<vector<char>>& s) {\\n        int n = s.size();\\n        int m = s[0].size();\\n        vector<vector<int>>dp(n+1,vector<int>(1<<m+1,-1));\\n        return giveres(0,0,n,m,dp,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526345,
                "title": "python-3-short-solution-w-lru-cache",
                "content": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maxStudents(self, a: List[List[str]]) -> int:\\n        n = len(a)\\n        m = len(a[0])\\n        \\n        g = [sum((x == \\'#\\') << i for i,x in enumerate(row)) for row in a]\\n            \\n        @lru_cache(None)\\n        def solve(i,x):\\n            if x & g[i]:\\n                return 0\\n            if x & (x << 1):\\n                return 0\\n            popcnt = bin(x).count(\"1\")\\n            if i == 0:\\n                return popcnt\\n            ret = popcnt\\n            for y in range(1<<m):\\n                if not ((x << 1) & y) and not ((x >> 1) & y):\\n                    ret = max(ret, popcnt + solve(i-1, y))\\n            return ret\\n        \\n        return max(solve(n-1, x) for x in range(1 << m))\\n```",
                "solutionTags": [],
                "code": "```\\nfrom functools import lru_cache\\nclass Solution:\\n    def maxStudents(self, a: List[List[str]]) -> int:\\n        n = len(a)\\n        m = len(a[0])\\n        \\n        g = [sum((x == \\'#\\') << i for i,x in enumerate(row)) for row in a]\\n            \\n        @lru_cache(None)\\n        def solve(i,x):\\n            if x & g[i]:\\n                return 0\\n            if x & (x << 1):\\n                return 0\\n            popcnt = bin(x).count(\"1\")\\n            if i == 0:\\n                return popcnt\\n            ret = popcnt\\n            for y in range(1<<m):\\n                if not ((x << 1) & y) and not ((x >> 1) & y):\\n                    ret = max(ret, popcnt + solve(i-1, y))\\n            return ret\\n        \\n        return max(solve(n-1, x) for x in range(1 << m))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565156,
                "content": [
                    {
                        "username": "chejianchao",
                        "content": "![image](https://assets.leetcode.com/users/chejianchao/image_1581221544.png)\\n\\nand I can\\'t  report someone. lol"
                    },
                    {
                        "username": "tryfu",
                        "content": "Same problem: https://code.google.com/codejam/contest/32002/dashboard#s=p2\\nI solved it about 40 minutes in this contest. You can search and download my solution if needed (ranked 37th)"
                    },
                    {
                        "username": "lucifer_65",
                        "content": "class Solution {\\npublic:\\n    int dp[65][(1<<8)][(1<<8)];\\n    vector<int>dx={0,-1,-1,0};\\n    vector<int>dy={-1,-1,+1,+1};\\n    bool valid(int x,int y,int n,int m){\\n        return (x<n && x>=0 && y<m && y>=0);\\n    }\\n    int solve(int i,int rmask,int cmask,int n,int m,vector<pair<int,int>>&chair){\\n        if(i==chair.size()){\\n            return 0;\\n        }\\n        int x=chair[i].first;\\n        int y=chair[i].second;\\n        int ans=0;\\n        if(dp[i][rmask][cmask]!=-1){\\n            return dp[i][rmask][cmask];\\n        }\\n        bool cantake=1;\\n        for(int ii=0;ii<4;ii++){\\n            int nx=x+dx[ii];\\n            int ny=y+dy[ii];\\n            if(valid(nx,ny,n,m)){\\n                if(((rmask>>nx)&1) && ((cmask>>ny)&1)){\\n                    cantake=0;\\n                    break;\\n                }\\n            }\\n        }\\n        if(cantake){\\n            int nrmask=(rmask|(1<<x));\\n            int ncmask=(cmask|(1<<y));\\n            ans=max(solve(i+1,rmask,cmask,n,m,chair),1+solve(i+1,nrmask,ncmask,n,m,chair));\\n        }else{\\n            ans=solve(i+1,rmask,cmask,n,m,chair);\\n        }\\n       \\n        return dp[i][rmask][cmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        vector<pair<int,int>>chair;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    chair.push_back({i,j});\\n                }\\n            }\\n        }\\n        // for(auto i:chair){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=solve(0,0,0,n,m,chair);\\n        return ans;\\n    }\\n};\\n\\nwhy this is failing  the 38th testcase??"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I saw all the solutions and I wasn\\'t able to understand any of it. So I decided to post [my own solution](https://leetcode.com/problems/maximum-students-taking-exam/solutions/3012329/evolution-from-normal-backtracking-to-optimized-bitmasking-with-thought-process/) starting from backtracking to optimized bitmasking. I have also show the thought process on how and why I decided to do something I did. "
                    },
                    {
                        "username": "lyi29512",
                        "content": "Your solution really helped me! Thank you. "
                    }
                ]
            },
            {
                "id": 1566919,
                "content": [
                    {
                        "username": "chejianchao",
                        "content": "![image](https://assets.leetcode.com/users/chejianchao/image_1581221544.png)\\n\\nand I can\\'t  report someone. lol"
                    },
                    {
                        "username": "tryfu",
                        "content": "Same problem: https://code.google.com/codejam/contest/32002/dashboard#s=p2\\nI solved it about 40 minutes in this contest. You can search and download my solution if needed (ranked 37th)"
                    },
                    {
                        "username": "lucifer_65",
                        "content": "class Solution {\\npublic:\\n    int dp[65][(1<<8)][(1<<8)];\\n    vector<int>dx={0,-1,-1,0};\\n    vector<int>dy={-1,-1,+1,+1};\\n    bool valid(int x,int y,int n,int m){\\n        return (x<n && x>=0 && y<m && y>=0);\\n    }\\n    int solve(int i,int rmask,int cmask,int n,int m,vector<pair<int,int>>&chair){\\n        if(i==chair.size()){\\n            return 0;\\n        }\\n        int x=chair[i].first;\\n        int y=chair[i].second;\\n        int ans=0;\\n        if(dp[i][rmask][cmask]!=-1){\\n            return dp[i][rmask][cmask];\\n        }\\n        bool cantake=1;\\n        for(int ii=0;ii<4;ii++){\\n            int nx=x+dx[ii];\\n            int ny=y+dy[ii];\\n            if(valid(nx,ny,n,m)){\\n                if(((rmask>>nx)&1) && ((cmask>>ny)&1)){\\n                    cantake=0;\\n                    break;\\n                }\\n            }\\n        }\\n        if(cantake){\\n            int nrmask=(rmask|(1<<x));\\n            int ncmask=(cmask|(1<<y));\\n            ans=max(solve(i+1,rmask,cmask,n,m,chair),1+solve(i+1,nrmask,ncmask,n,m,chair));\\n        }else{\\n            ans=solve(i+1,rmask,cmask,n,m,chair);\\n        }\\n       \\n        return dp[i][rmask][cmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        vector<pair<int,int>>chair;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    chair.push_back({i,j});\\n                }\\n            }\\n        }\\n        // for(auto i:chair){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=solve(0,0,0,n,m,chair);\\n        return ans;\\n    }\\n};\\n\\nwhy this is failing  the 38th testcase??"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I saw all the solutions and I wasn\\'t able to understand any of it. So I decided to post [my own solution](https://leetcode.com/problems/maximum-students-taking-exam/solutions/3012329/evolution-from-normal-backtracking-to-optimized-bitmasking-with-thought-process/) starting from backtracking to optimized bitmasking. I have also show the thought process on how and why I decided to do something I did. "
                    },
                    {
                        "username": "lyi29512",
                        "content": "Your solution really helped me! Thank you. "
                    }
                ]
            },
            {
                "id": 2024328,
                "content": [
                    {
                        "username": "chejianchao",
                        "content": "![image](https://assets.leetcode.com/users/chejianchao/image_1581221544.png)\\n\\nand I can\\'t  report someone. lol"
                    },
                    {
                        "username": "tryfu",
                        "content": "Same problem: https://code.google.com/codejam/contest/32002/dashboard#s=p2\\nI solved it about 40 minutes in this contest. You can search and download my solution if needed (ranked 37th)"
                    },
                    {
                        "username": "lucifer_65",
                        "content": "class Solution {\\npublic:\\n    int dp[65][(1<<8)][(1<<8)];\\n    vector<int>dx={0,-1,-1,0};\\n    vector<int>dy={-1,-1,+1,+1};\\n    bool valid(int x,int y,int n,int m){\\n        return (x<n && x>=0 && y<m && y>=0);\\n    }\\n    int solve(int i,int rmask,int cmask,int n,int m,vector<pair<int,int>>&chair){\\n        if(i==chair.size()){\\n            return 0;\\n        }\\n        int x=chair[i].first;\\n        int y=chair[i].second;\\n        int ans=0;\\n        if(dp[i][rmask][cmask]!=-1){\\n            return dp[i][rmask][cmask];\\n        }\\n        bool cantake=1;\\n        for(int ii=0;ii<4;ii++){\\n            int nx=x+dx[ii];\\n            int ny=y+dy[ii];\\n            if(valid(nx,ny,n,m)){\\n                if(((rmask>>nx)&1) && ((cmask>>ny)&1)){\\n                    cantake=0;\\n                    break;\\n                }\\n            }\\n        }\\n        if(cantake){\\n            int nrmask=(rmask|(1<<x));\\n            int ncmask=(cmask|(1<<y));\\n            ans=max(solve(i+1,rmask,cmask,n,m,chair),1+solve(i+1,nrmask,ncmask,n,m,chair));\\n        }else{\\n            ans=solve(i+1,rmask,cmask,n,m,chair);\\n        }\\n       \\n        return dp[i][rmask][cmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        vector<pair<int,int>>chair;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    chair.push_back({i,j});\\n                }\\n            }\\n        }\\n        // for(auto i:chair){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=solve(0,0,0,n,m,chair);\\n        return ans;\\n    }\\n};\\n\\nwhy this is failing  the 38th testcase??"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I saw all the solutions and I wasn\\'t able to understand any of it. So I decided to post [my own solution](https://leetcode.com/problems/maximum-students-taking-exam/solutions/3012329/evolution-from-normal-backtracking-to-optimized-bitmasking-with-thought-process/) starting from backtracking to optimized bitmasking. I have also show the thought process on how and why I decided to do something I did. "
                    },
                    {
                        "username": "lyi29512",
                        "content": "Your solution really helped me! Thank you. "
                    }
                ]
            },
            {
                "id": 1745879,
                "content": [
                    {
                        "username": "chejianchao",
                        "content": "![image](https://assets.leetcode.com/users/chejianchao/image_1581221544.png)\\n\\nand I can\\'t  report someone. lol"
                    },
                    {
                        "username": "tryfu",
                        "content": "Same problem: https://code.google.com/codejam/contest/32002/dashboard#s=p2\\nI solved it about 40 minutes in this contest. You can search and download my solution if needed (ranked 37th)"
                    },
                    {
                        "username": "lucifer_65",
                        "content": "class Solution {\\npublic:\\n    int dp[65][(1<<8)][(1<<8)];\\n    vector<int>dx={0,-1,-1,0};\\n    vector<int>dy={-1,-1,+1,+1};\\n    bool valid(int x,int y,int n,int m){\\n        return (x<n && x>=0 && y<m && y>=0);\\n    }\\n    int solve(int i,int rmask,int cmask,int n,int m,vector<pair<int,int>>&chair){\\n        if(i==chair.size()){\\n            return 0;\\n        }\\n        int x=chair[i].first;\\n        int y=chair[i].second;\\n        int ans=0;\\n        if(dp[i][rmask][cmask]!=-1){\\n            return dp[i][rmask][cmask];\\n        }\\n        bool cantake=1;\\n        for(int ii=0;ii<4;ii++){\\n            int nx=x+dx[ii];\\n            int ny=y+dy[ii];\\n            if(valid(nx,ny,n,m)){\\n                if(((rmask>>nx)&1) && ((cmask>>ny)&1)){\\n                    cantake=0;\\n                    break;\\n                }\\n            }\\n        }\\n        if(cantake){\\n            int nrmask=(rmask|(1<<x));\\n            int ncmask=(cmask|(1<<y));\\n            ans=max(solve(i+1,rmask,cmask,n,m,chair),1+solve(i+1,nrmask,ncmask,n,m,chair));\\n        }else{\\n            ans=solve(i+1,rmask,cmask,n,m,chair);\\n        }\\n       \\n        return dp[i][rmask][cmask]=ans;\\n    }\\n    int maxStudents(vector<vector<char>>& seats) {\\n        memset(dp,-1,sizeof(dp));\\n        int n=seats.size();\\n        int m=seats[0].size();\\n        vector<pair<int,int>>chair;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(seats[i][j]==\\'.\\'){\\n                    chair.push_back({i,j});\\n                }\\n            }\\n        }\\n        // for(auto i:chair){\\n        //     cout<<i.first<<\" \"<<i.second<<endl;\\n        // }\\n        int ans=solve(0,0,0,n,m,chair);\\n        return ans;\\n    }\\n};\\n\\nwhy this is failing  the 38th testcase??"
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "I saw all the solutions and I wasn\\'t able to understand any of it. So I decided to post [my own solution](https://leetcode.com/problems/maximum-students-taking-exam/solutions/3012329/evolution-from-normal-backtracking-to-optimized-bitmasking-with-thought-process/) starting from backtracking to optimized bitmasking. I have also show the thought process on how and why I decided to do something I did. "
                    },
                    {
                        "username": "lyi29512",
                        "content": "Your solution really helped me! Thank you. "
                    }
                ]
            }
        ]
    }
]