[
    {
        "title": "Delete Greatest Value in Each Row",
        "question_content": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\n\tDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\n\tAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\n&nbsp;\nExample 1:\n\nInput: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\n\nExample 2:\n\nInput: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 50\n\t1 <= grid[i][j] <= 100",
        "solutions": [
            {
                "id": 2899965,
                "title": "sort-rows",
                "content": "We sort all rows first, then go column by column and pick the largest value.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(max(c) for c in zip(*[sorted(r) for r in grid]))\\n```\\n\\n**C++**\\n```cpp\\nint deleteGreatestValue(vector<vector<int>>& g) {\\n    int res = 0, si = g.size(), sj = g[0].size();\\n    for (auto &r : g)\\n        sort(begin(r), end(r));\\n    for (int j = 0; j < sj; ++j) {\\n        int max_row = 0;\\n        for (int i = 0; i < si; ++i) \\n            max_row = max(max_row, g[i][j]);\\n        res += max_row;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3",
                    "C"
                ],
                "code": "```python\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(max(c) for c in zip(*[sorted(r) for r in grid]))\\n```\n```cpp\\nint deleteGreatestValue(vector<vector<int>>& g) {\\n    int res = 0, si = g.size(), sj = g[0].size();\\n    for (auto &r : g)\\n        sort(begin(r), end(r));\\n    for (int j = 0; j < sj; ++j) {\\n        int max_row = 0;\\n        for (int i = 0; i < si; ++i) \\n            max_row = max(max_row, g[i][j]);\\n        res += max_row;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899397,
                "title": "python-c-sort-rows-then-sum-max-of-cols-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs sorting of rows to allow fast extraction of maximal values in each column. Time complexity is log-linear: **O(M\\\\*N\\\\*logN)**, where **MxN** are the dimensions of the matrix.  Space complexity is constant: **O(1)**.\\n****\\n\\n**Python #1.**\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid : row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n```\\n\\n**Python #2.** This solution can be compactified further into a one-liner.\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,grid))))\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        int sum = 0;\\n        \\n        for (auto& row : grid) sort(row.begin(), row.end());\\n        \\n        for (int j = 0; j < grid[0].size(); ++j)\\n        {\\n            int n = 0;\\n            for (int i = 0; i < grid.size(); ++i)\\n                n = max(n, grid[i][j]);\\n            sum += n;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid : row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n```\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max,zip(*map(sorted,grid))))\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        int sum = 0;\\n        \\n        for (auto& row : grid) sort(row.begin(), row.end());\\n        \\n        for (int j = 0; j < grid[0].size(); ++j)\\n        {\\n            int n = 0;\\n            for (int i = 0; i < grid.size(); ++i)\\n                n = max(n, grid[i][j]);\\n            sum += n;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899453,
                "title": "c-simple",
                "content": "```\\ndry run\\n\\ngiven:\\n[[1,2,4],\\n [3,3,1]]\\n \\nstep 1 : (Sort each row)\\n[[4,2,1],\\n [3,3,1]]\\n \\nstep 2 : (Change col to row)\\n[[4,3],\\n [2,3],\\n [1,1]]\\n \\nstep 3 : (took max from each new row and add to the answer)\\nans = 4 + 3 + 1 = 8\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();                   // row\\n        int m = grid[0].size();                // col\\n        int answer = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end(),greater<>());                  // sort each row in dexreasing order as we need max value from whole row\\n            // cout<<grid[i][0]<<\" \";\\n        }\\n        \\n        // it will store the column as row and we will took the greatest from that particular row\\n        for(int i=0;i<m;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(int j=0;j<n;j++)\\n            {\\n                mx = max(mx,grid[j][i]);               // storing mx for curr column                               \\n            }\\n             \\n            answer += mx;                                // add up the max value of column to answer\\n        }\\n        return answer;\\n    }\\n};\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ndry run\\n\\ngiven:\\n[[1,2,4],\\n [3,3,1]]\\n \\nstep 1 : (Sort each row)\\n[[4,2,1],\\n [3,3,1]]\\n \\nstep 2 : (Change col to row)\\n[[4,3],\\n [2,3],\\n [1,1]]\\n \\nstep 3 : (took max from each new row and add to the answer)\\nans = 4 + 3 + 1 = 8\\n```\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        int n = grid.size();                   // row\\n        int m = grid[0].size();                // col\\n        int answer = 0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end(),greater<>());                  // sort each row in dexreasing order as we need max value from whole row\\n            // cout<<grid[i][0]<<\" \";\\n        }\\n        \\n        // it will store the column as row and we will took the greatest from that particular row\\n        for(int i=0;i<m;i++)\\n        {\\n            int mx = INT_MIN;\\n            for(int j=0;j<n;j++)\\n            {\\n                mx = max(mx,grid[j][i]);               // storing mx for curr column                               \\n            }\\n             \\n            answer += mx;                                // add up the max value of column to answer\\n        }\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2899447,
                "title": "beginner-friendly-java-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n*mlogm)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++)    Arrays.sort(grid[i]);\\n        int res = 0;\\n        for(int i=0; i<grid[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<grid.length; j++)    \\n                max = Math.max(max, grid[j][i]);\\n            res += max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++)    Arrays.sort(grid[i]);\\n        int res = 0;\\n        for(int i=0; i<grid[0].length; i++){\\n            int max = 0;\\n            for(int j=0; j<grid.length; j++)    \\n                max = Math.max(max, grid[j][i]);\\n            res += max;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2905342,
                "title": "python-3-3-lines-w-explanation-and-example-t-m-102-ms-14mb",
                "content": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n\\n        for i in range(len(grid)): grid[i].sort()   # <-- sort each row\\n\\n        grid = list(zip(*grid))                     # <-- transpose grid; rows become\\n                                                    #     cols and cols become rows\\n\\n        return sum(max(row) for row in grid)        # <-- sum the maxs from each row\\n                                                    #_________________________________\\n                                                    #    Example: grid  = [[4,1,2]\\n                                                    #                      [3,3,1]]\\n\\n                                                    #  Sort rows: grid  = [[1,2,4]\\n                                                    #                      [1,3,3]]\\n                                                    #\\n                                                    #  Transpose: grid  = [[1,1]  <-- max: 1\\n                                                    #                      [2,3]  <-- max: 3\\n                                                    #                      [4,3]] <-- max: 4\\n                                                    #                                     \\u2013\\u2013\\u2013\\n                                                    #        Sum:              return \\u2013\\u2013>  8                          \\n                                                    \\n```\\n\\n\\n\\nI could be wrong, but I think that time is *O*(*N*log*N*) and space is *O*(*N*), worst case.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n\\n        for i in range(len(grid)): grid[i].sort()   # <-- sort each row\\n\\n        grid = list(zip(*grid))                     # <-- transpose grid; rows become\\n                                                    #     cols and cols become rows\\n\\n        return sum(max(row) for row in grid)        # <-- sum the maxs from each row\\n                                                    #_________________________________\\n                                                    #    Example: grid  = [[4,1,2]\\n                                                    #                      [3,3,1]]\\n\\n                                                    #  Sort rows: grid  = [[1,2,4]\\n                                                    #                      [1,3,3]]\\n                                                    #\\n                                                    #  Transpose: grid  = [[1,1]  <-- max: 1\\n                                                    #                      [2,3]  <-- max: 3\\n                                                    #                      [4,3]] <-- max: 4\\n                                                    #                                     \\u2013\\u2013\\u2013\\n                                                    #        Sum:              return \\u2013\\u2013>  8                          \\n                                                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901675,
                "title": "short-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar deleteGreatestValue = function (grid) {\\n    grid.forEach(row => row.sort((a, b) => a - b))\\n    let sum = 0\\n\\n    while (grid[0].length) {\\n        let column = []\\n        for (let row of grid) column.push(row.pop())\\n        sum += Math.max(...column)\\n    }\\n\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteGreatestValue = function (grid) {\\n    grid.forEach(row => row.sort((a, b) => a - b))\\n    let sum = 0\\n\\n    while (grid[0].length) {\\n        let column = []\\n        for (let row of grid) column.push(row.pop())\\n        sum += Math.max(...column)\\n    }\\n\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899403,
                "title": "c-simple",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); ++i) sort(grid[i].begin(), grid[i].end());\\n        for(int i = 0; i < grid[0].size(); ++i){\\n            int t = 0;\\n            for(int j = 0; j < grid.size(); ++j) t = max(t, grid[j][i]);\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        for(int i = 0; i < grid.size(); ++i) sort(grid[i].begin(), grid[i].end());\\n        for(int i = 0; i < grid[0].size(); ++i){\\n            int t = 0;\\n            for(int j = 0; j < grid.size(); ++j) t = max(t, grid[j][i]);\\n            ans += t;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223800,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int res = 0;\\n        for (int[] i : grid){\\n            Arrays.sort(i);\\n        }\\n\\n        for (int i = 0; i < grid[0].length; i++){\\n            int max = 0;\\n            for (int[] element : grid) {\\n                if (max <= element[i]) {\\n                    max = element[i];\\n                }\\n            }\\n            res = res + max;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int res = 0;\\n        for (int[] i : grid){\\n            Arrays.sort(i);\\n        }\\n\\n        for (int i = 0; i < grid[0].length; i++){\\n            int max = 0;\\n            for (int[] element : grid) {\\n                if (max <= element[i]) {\\n                    max = element[i];\\n                }\\n            }\\n            res = res + max;\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150531,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        i = 0\\n        output = 0\\n        current_max = 0\\n        while True:\\n            if len(grid[i]) == 0:\\n                break\\n            grid[i] = sorted(grid[i])\\n            current_max = max(current_max,grid[i][-1])\\n            grid[i].pop(-1)\\n            i+=1\\n            if i == len(grid):\\n                output += current_max\\n                current_max = 0\\n                i = 0\\n        return output\\n        \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        i = 0\\n        output = 0\\n        current_max = 0\\n        while True:\\n            if len(grid[i]) == 0:\\n                break\\n            grid[i] = sorted(grid[i])\\n            current_max = max(current_max,grid[i][-1])\\n            grid[i].pop(-1)\\n            i+=1\\n            if i == len(grid):\\n                output += current_max\\n                current_max = 0\\n                i = 0\\n        return output\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914480,
                "title": "easy-java-solution-with-o-m-n-time-complexity-o-1-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Initially, start with sortiing each row.\\n- Once the rows are sorted, start traversing the grid column wise from last column and find the greatest element in that column and add it to the result.\\n- Once all the columns are traversed, we\\'ll have the result with us.\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum=0;\\n        for(int i =0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        for(int i= grid[0].length-1;i>=0;i--){\\n            int max = 0;\\n            for(int j=0;j<grid.length;j++){\\n\\n                max = Math.max(max, grid[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum=0;\\n        for(int i =0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        for(int i= grid[0].length-1;i>=0;i--){\\n            int max = 0;\\n            for(int j=0;j<grid.length;j++){\\n\\n                max = Math.max(max, grid[j][i]);\\n            }\\n            sum+=max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899411,
                "title": "c-sorting-simple-approach",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        for(auto &it:grid)\\n        {\\n            sort(it.begin(), it.end());\\n        }\\n        \\n        int ans=0;\\n        int j=0;\\n        while(j<grid[0].size())\\n        {\\n            int maxi=0;\\n            for(int i=0; i<grid.size(); i++)\\n            {\\n                maxi = max(maxi, grid[i][j]);  \\n            }\\n            j++;\\n            ans += maxi; \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) \\n    {\\n        for(auto &it:grid)\\n        {\\n            sort(it.begin(), it.end());\\n        }\\n        \\n        int ans=0;\\n        int j=0;\\n        while(j<grid[0].size())\\n        {\\n            int maxi=0;\\n            for(int i=0; i<grid.size(); i++)\\n            {\\n                maxi = max(maxi, grid[i][j]);  \\n            }\\n            j++;\\n            ans += maxi; \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899359,
                "title": "cpp-sollution",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int result = 0 ; \\n        for(vector<int> &grid1: grid) {\\n           \\n                sort(grid1.begin(), grid1.end());\\n        }\\n        for(int j = 0; j < grid[0].size(); j++){\\n            int mx = INT_MIN;\\n            for(int i = 0; i < grid.size(); i++){\\n                mx = max(mx, grid[i][j]);\\n            }\\n            result += mx;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int result = 0 ; \\n        for(vector<int> &grid1: grid) {\\n           \\n                sort(grid1.begin(), grid1.end());\\n        }\\n        for(int j = 0; j < grid[0].size(); j++){\\n            int mx = INT_MIN;\\n            for(int i = 0; i < grid.size(); i++){\\n                mx = max(mx, grid[i][j]);\\n            }\\n            result += mx;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327896,
                "title": "java-maxheap",
                "content": "# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        // Creating a list of priority queue. It will store the rows.\\n    \\tArrayList<PriorityQueue<Integer>> list=new ArrayList<>();\\n    \\t\\n    \\tint m=grid.length; // total number of rows in grid.\\n    \\tint n=grid[0].length; // total number of columns in grid.\\n\\n        // Let\\'s fill the list.\\n    \\tfor (int i=0;i<grid.length;i++) {\\n    \\t\\tPriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n    \\t\\tfor (int j=0;j<grid[0].length;j++) {\\n    \\t\\t\\tpq.add(grid[i][j]);\\n    \\t\\t}\\n    \\t\\tlist.add(pq);\\n\\t\\t\\t}\\n\\t\\t\\t\\n    \\tint result=0;\\n    \\tfor (int i=0;i<n;i++) {\\n    \\t\\tint num=-1;\\n    \\t\\tfor (int j=0;j<m;j++) {\\n    \\t\\t\\tPriorityQueue<Integer> pq=list.get(j);\\n    \\t\\t\\tint temp = pq.poll();\\n\\t\\t\\t\\t\\t\\n    \\t\\t\\tnum=Math.max(num, temp);\\n    \\t\\t}\\n    \\t\\tresult+=num;\\n    \\t}\\n    \\treturn result;\\n    \\t\\n    }\\n}\\n```\\n\\n![90f09615-d42d-402c-897e-8d81a9fb5f37_1677988379.954136.jpeg](https://assets.leetcode.com/users/images/89b6c8f2-bdab-4707-aca0-9e19e465fb52_1679474556.0524573.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        // Creating a list of priority queue. It will store the rows.\\n    \\tArrayList<PriorityQueue<Integer>> list=new ArrayList<>();\\n    \\t\\n    \\tint m=grid.length; // total number of rows in grid.\\n    \\tint n=grid[0].length; // total number of columns in grid.\\n\\n        // Let\\'s fill the list.\\n    \\tfor (int i=0;i<grid.length;i++) {\\n    \\t\\tPriorityQueue<Integer> pq=new PriorityQueue<>(Collections.reverseOrder());\\n    \\t\\tfor (int j=0;j<grid[0].length;j++) {\\n    \\t\\t\\tpq.add(grid[i][j]);\\n    \\t\\t}\\n    \\t\\tlist.add(pq);\\n\\t\\t\\t}\\n\\t\\t\\t\\n    \\tint result=0;\\n    \\tfor (int i=0;i<n;i++) {\\n    \\t\\tint num=-1;\\n    \\t\\tfor (int j=0;j<m;j++) {\\n    \\t\\t\\tPriorityQueue<Integer> pq=list.get(j);\\n    \\t\\t\\tint temp = pq.poll();\\n\\t\\t\\t\\t\\t\\n    \\t\\t\\tnum=Math.max(num, temp);\\n    \\t\\t}\\n    \\t\\tresult+=num;\\n    \\t}\\n    \\treturn result;\\n    \\t\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899605,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0; i<m; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<n; j++ ){\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            res = (res + maxi);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0; i<m; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<n; j++ ){\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            res = (res + maxi);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899409,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def deleteGreatestValue(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        for i in range(len(grid[0])):\\n            m1 = -1\\n            for j in range(len(grid)):\\n                mx = max(grid[j])\\n                m1 = max(m1,mx)\\n                grid[j].remove(mx)\\n            ans += m1\\n        return ans\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteGreatestValue(self, grid):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        for i in range(len(grid[0])):\\n            m1 = -1\\n            for j in range(len(grid)):\\n                mx = max(grid[j])\\n                m1 = max(m1,mx)\\n                grid[j].remove(mx)\\n            ans += m1\\n        return ans\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899368,
                "title": "beginner-friendly-python",
                "content": "\\n\\n# Code\\n```\\n# sort each row\\n        for i in range(len(grid)):\\n            grid[i].sort(reverse = True)\\n            \\n        sum = 0\\n        \\n        # traverse through each column\\n        for i in range(len(grid[0])):\\n            maxVal = 0\\n            \\n            # traverse through each row\\n            for j in range(len(grid)):\\n                \\n                # get max from each row\\n                maxVal = max(grid[j][i], maxVal)\\n                \\n            sum += maxVal\\n            \\n        return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# sort each row\\n        for i in range(len(grid)):\\n            grid[i].sort(reverse = True)\\n            \\n        sum = 0\\n        \\n        # traverse through each column\\n        for i in range(len(grid[0])):\\n            maxVal = 0\\n            \\n            # traverse through each row\\n            for j in range(len(grid)):\\n                \\n                # get max from each row\\n                maxVal = max(grid[j][i], maxVal)\\n                \\n            sum += maxVal\\n            \\n        return sum\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3201072,
                "title": "c-two-methods-easy-to-understand-code",
                "content": "**Method -1**\\n\\n![image](https://assets.leetcode.com/users/images/03bf93cc-e9f3-450f-b349-56c9fc246c40_1676719780.3950496.png)\\n\\n**T->O(m * n^2) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint deleteGreatestValue(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint m = grid.size();\\n\\t\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\t\\tint temp = n,ans = 0;\\n\\n\\t\\t\\t\\twhile(temp--){\\n\\t\\t\\t\\t\\tint max_ele = 0;\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < m ; i++){\\n\\t\\t\\t\\t\\t\\tauto max_ele_it = max_element(grid[i].begin(),grid[i].end());\\n\\t\\t\\t\\t\\t\\tmax_ele = max(max_ele,*max_ele_it);\\n\\t\\t\\t\\t\\t\\tgrid[i].erase(max_ele_it);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans += max_ele;\\n\\t\\t\\t\\t}     \\n\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n**Method - 2**\\n![image](https://assets.leetcode.com/users/images/f124a386-3b73-4abe-bc1f-1069adf32067_1676721364.8780785.png)\\n\\n**T->O(m nlogn) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint deleteGreatestValue(vector<vector<int>>& grid) {\\n\\t\\t\\tint m = grid.size();\\n\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\tint temp = n,ans = 0;\\n\\n\\t\\t\\twhile(temp--){\\n\\t\\t\\t\\tint max_ele = 0;\\n\\t\\t\\t\\tfor(int i = 0 ; i < m ; i++){\\n\\t\\t\\t\\t\\tsort(grid[i].begin(),grid[i].end());\\n\\t\\t\\t\\t\\tmax_ele = max(max_ele,grid[i].back());\\n\\t\\t\\t\\t\\tgrid[i].pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans += max_ele;\\n\\t\\t\\t}     \\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint deleteGreatestValue(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tint m = grid.size();\\n\\t\\t\\t\\tint n = grid[0].size();\\n\\t\\t\\t\\tint temp = n,ans = 0;\\n\\n\\t\\t\\t\\twhile(temp--){\\n\\t\\t\\t\\t\\tint max_ele = 0;\\n\\t\\t\\t\\t\\tfor(int i = 0 ; i < m ; i++){\\n\\t\\t\\t\\t\\t\\tauto max_ele_it = max_element(grid[i].begin(),grid[i].end());\\n\\t\\t\\t\\t\\t\\tmax_ele = max(max_ele,*max_ele_it);\\n\\t\\t\\t\\t\\t\\tgrid[i].erase(max_ele_it);\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2899466,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 407 ms, faster than 20.00% of Python3 online submissions for Delete Greatest Value in Each Row.\\n# Memory Usage: 14 MB, less than 20.00% of Python3 online submissions for Delete Greatest Value in Each Row.\\n\\n\\tclass Solution:\\n\\t\\tdef deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\twhile True:\\n\\n\\t\\t\\t\\tif len(grid[0]) == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tcurrent_max = []\\n\\n\\t\\t\\t\\tfor row in range(length):\\n\\t\\t\\t\\t\\tmax_element = max(grid[row])\\n\\n\\t\\t\\t\\t\\tgrid[row].remove(max_element)\\n\\t\\t\\t\\t\\tcurrent_max.append(max_element)\\n\\n\\t\\t\\t\\tresult = result + max(current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 407 ms, faster than 20.00% of Python3 online submissions for Delete Greatest Value in Each Row.\\n# Memory Usage: 14 MB, less than 20.00% of Python3 online submissions for Delete Greatest Value in Each Row.\\n\\n\\tclass Solution:\\n\\t\\tdef deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n\\n\\t\\t\\tlength = len(grid)\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\twhile True:\\n\\n\\t\\t\\t\\tif len(grid[0]) == 0:\\n\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\tcurrent_max = []\\n\\n\\t\\t\\t\\tfor row in range(length):\\n\\t\\t\\t\\t\\tmax_element = max(grid[row])\\n\\n\\t\\t\\t\\t\\tgrid[row].remove(max_element)\\n\\t\\t\\t\\t\\tcurrent_max.append(max_element)\\n\\n\\t\\t\\t\\tresult = result + max(current_max)\\n\\n\\t\\t\\treturn result\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2899434,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {        \\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int k=grid[0].size()-1; k>=0; k--)\\n        {\\n            int maxValue=0;\\n            for(int i=0; i<grid.size(); i++)\\n            {\\n                maxValue=max(maxValue,grid[i][k]);\\n            }\\n            sum+=maxValue;            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {        \\n        for(int i=0; i<grid.size(); i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        \\n        int sum=0;\\n        \\n        for(int k=grid[0].size()-1; k>=0; k--)\\n        {\\n            int maxValue=0;\\n            for(int i=0; i<grid.size(); i++)\\n            {\\n                maxValue=max(maxValue,grid[i][k]);\\n            }\\n            sum+=maxValue;            \\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899382,
                "title": "c-explanation-easy-solution",
                "content": "\\n* Sorting each rows and find out max element in each cols\\n### Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(auto &x : grid) sort(x.begin(), x.end());\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++) {\\n            int maxi = INT_MIN;\\n            \\n            for(int j = 0; j < n; j++) \\n                maxi = max(maxi, grid[j][i]);\\n\\n            ans += maxi;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(auto &x : grid) sort(x.begin(), x.end());\\n        \\n        int ans = 0;\\n        for(int i = 0; i < m; i++) {\\n            int maxi = INT_MIN;\\n            \\n            for(int j = 0; j < n; j++) \\n                maxi = max(maxi, grid[j][i]);\\n\\n            ans += maxi;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327912,
                "title": "python-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        result=0\\n        for i in range(len(grid[0])):\\n            temp=[]\\n            for j in range(len(grid)):\\n                ele=max(grid[j])\\n                temp.append(max(grid[j]))\\n                grid[j].remove(ele)\\n            result += max(temp)\\n        return result\\n            \\n```\\n![90f09615-d42d-402c-897e-8d81a9fb5f37_1677988379.954136.jpeg](https://assets.leetcode.com/users/images/dc6b6bf4-c50a-4b80-897b-ad7eb6f86d71_1679474922.797928.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        result=0\\n        for i in range(len(grid[0])):\\n            temp=[]\\n            for j in range(len(grid)):\\n                ele=max(grid[j])\\n                temp.append(max(grid[j]))\\n                grid[j].remove(ele)\\n            result += max(temp)\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282718,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();                  \\n        int n = grid[0].size();               \\n        int result = 0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());          \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int maxValue = INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n                maxValue = max(maxValue,grid[j][i]);                                    \\n            }\\n             \\n            result += maxValue;                                \\n        }\\n        return result;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();                  \\n        int n = grid[0].size();               \\n        int result = 0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());          \\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            int maxValue = INT_MIN;\\n            for(int j=0;j<m;j++)\\n            {\\n                maxValue = max(maxValue,grid[j][i]);                                    \\n            }\\n             \\n            result += maxValue;                                \\n        }\\n        return result;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118315,
                "title": "using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=grid[0].length-1; i>=0; i--){\\n            int temp = 0;\\n            for(int j=0; j<grid.length; j++){\\n                temp = Math.max(temp , grid[j][i]);\\n            }\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        int ans = 0;\\n        for(int i=grid[0].length-1; i>=0; i--){\\n            int temp = 0;\\n            for(int j=0; j<grid.length; j++){\\n                temp = Math.max(temp , grid[j][i]);\\n            }\\n            ans += temp;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2947603,
                "title": "js-sort-then-compare-naive-but-faster-than-95",
                "content": "# Complexity\\n- Time complexity:\\nO(n Log n) due to sort\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar deleteGreatestValue = function (grid, res = 0) {\\n  for (let arr of grid) {\\n    arr.sort((a, b) => b - a);\\n  }\\n  for (let i = 0; i < grid[0].length; i++) {\\n    let max = -Infinity;\\n//get max of each column\\n    for (let arr of grid) {\\n      max = Math.max(max, arr[i]);\\n    }\\n    res += max;\\n  }\\n  return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar deleteGreatestValue = function (grid, res = 0) {\\n  for (let arr of grid) {\\n    arr.sort((a, b) => b - a);\\n  }\\n  for (let i = 0; i < grid[0].length; i++) {\\n    let max = -Infinity;\\n//get max of each column\\n    for (let arr of grid) {\\n      max = Math.max(max, arr[i]);\\n    }\\n    res += max;\\n  }\\n  return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2945758,
                "title": "easy-java-solution",
                "content": "**If you found it easy to understand, Please do upvote :)\\nThankyou!!**\\n**--------------------------------------------------------------------------------------------------**\\n![Today Leetcode Pic.JPG](https://assets.leetcode.com/users/images/9990d8d6-1ee4-48c1-9d65-1d83578f34a0_1671886016.8473728.jpeg)\\n**--------------------------------------------------------------------------------------------------**\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) \\n    {\\n        for(int i=0; i<grid.length; i++) Arrays.sort(grid[i]);  \\n\\n        int cost=0;\\n        for(int i=0; i<grid[0].length; i++)\\n        {\\n            int max=0;\\n            for(int j=0; j<grid.length; j++)\\n                if(max<grid[j][i]) \\n                    max=grid[j][i];\\n            cost+=max;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) \\n    {\\n        for(int i=0; i<grid.length; i++) Arrays.sort(grid[i]);  \\n\\n        int cost=0;\\n        for(int i=0; i<grid[0].length; i++)\\n        {\\n            int max=0;\\n            for(int j=0; j<grid.length; j++)\\n                if(max<grid[j][i]) \\n                    max=grid[j][i];\\n            cost+=max;\\n        }\\n        return cost;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901275,
                "title": "presort-rows-on-js-ts",
                "content": "# Approach\\n- Sort rows in descending order\\n- Iterate over columns, find max value for each column and add it to result sum \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m * n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```typescript []\\nfunction deleteGreatestValue(grid: number[][]): number {\\n    for (const row of grid) {\\n        row.sort((a, b) => b - a);\\n    }\\n\\n    let sum = 0;\\n\\n    for (let x = 0; x < grid[0].length; x++) {\\n        let max = 0;\\n\\n        for (let y = 0; y < grid.length; y++) {\\n            max = Math.max(max, grid[y][x]);\\n        }\\n        sum += max;\\n    }\\n\\n    return sum;\\n}\\n```\\n\\n```javascript []\\nfunction deleteGreatestValue(grid) {\\n    for (const row of grid) {\\n        row.sort((a, b) => b - a);\\n    }\\n\\n    let sum = 0;\\n\\n    for (let x = 0; x < grid[0].length; x++) {\\n        let max = 0;\\n\\n        for (let y = 0; y < grid.length; y++) {\\n            max = Math.max(max, grid[y][x]);\\n        }\\n        sum += max;\\n    }\\n\\n    return sum;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sort"
                ],
                "code": "```typescript []\\nfunction deleteGreatestValue(grid: number[][]): number {\\n    for (const row of grid) {\\n        row.sort((a, b) => b - a);\\n    }\\n\\n    let sum = 0;\\n\\n    for (let x = 0; x < grid[0].length; x++) {\\n        let max = 0;\\n\\n        for (let y = 0; y < grid.length; y++) {\\n            max = Math.max(max, grid[y][x]);\\n        }\\n        sum += max;\\n    }\\n\\n    return sum;\\n}\\n```\n```javascript []\\nfunction deleteGreatestValue(grid) {\\n    for (const row of grid) {\\n        row.sort((a, b) => b - a);\\n    }\\n\\n    let sum = 0;\\n\\n    for (let x = 0; x < grid[0].length; x++) {\\n        let max = 0;\\n\\n        for (let y = 0; y < grid.length; y++) {\\n            max = Math.max(max, grid[y][x]);\\n        }\\n        sum += max;\\n    }\\n\\n    return sum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899402,
                "title": "c-sort-and-find-max-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int res  = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n    \\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi = INT_MIN;\\n            for(int j=0;j<n;j++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            \\n            res += maxi;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        \\n        int res  = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n    \\n        for(int i=0;i<m;i++)\\n        {\\n            int maxi = INT_MIN;\\n            for(int j=0;j<n;j++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            \\n            res += maxi;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899373,
                "title": "python-java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in grid:\\n            row.sort()\\n        for j in range(len(grid[0])):\\n            maxVal = -float(\"inf\")\\n            for row in grid:\\n                maxVal = max(maxVal, row[j])\\n            res += maxVal\\n        return res\\n\\n\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int res = 0;\\n        for (int[] row: grid) {\\n            Arrays.sort(row);\\n        }\\n        for (int j = 0; j < grid[0].length; j ++) {\\n            int maxVal = Integer.MIN_VALUE;\\n            for (int[] row: grid) {\\n                maxVal = Math.max(maxVal, row[j]);\\n            }\\n            res += maxVal;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in grid:\\n            row.sort()\\n        for j in range(len(grid[0])):\\n            maxVal = -float(\"inf\")\\n            for row in grid:\\n                maxVal = max(maxVal, row[j])\\n            res += maxVal\\n        return res\\n\\n\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int res = 0;\\n        for (int[] row: grid) {\\n            Arrays.sort(row);\\n        }\\n        for (int j = 0; j < grid[0].length; j ++) {\\n            int maxVal = Integer.MIN_VALUE;\\n            for (int[] row: grid) {\\n                maxVal = Math.max(maxVal, row[j]);\\n            }\\n            res += maxVal;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3569068,
                "title": "c-sorting-easy-o-n",
                "content": "# Intuition\\nJust know all basics of 2-d vector and stl for vectors\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort each of the 2-d vector rows.\\nGetting the maximum of last element from each of the row and removing the last number at the same time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0, maxi = -1;\\n        // sorting each row\\n        for(int i=0; i<m; i++)\\n            sort(grid[i].begin(), grid[i].end());\\n\\n        for(int i=n-1; i>=0; i--){\\n            // removing the last element from each row\\n            maxi = -1;\\n            for(int j=0; j<m; j++){\\n                maxi = max(maxi, grid[j][i]);\\n                grid[j].pop_back();\\n            }\\n            // storing the maximum value\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n\\n        int ans = 0, maxi = -1;\\n        // sorting each row\\n        for(int i=0; i<m; i++)\\n            sort(grid[i].begin(), grid[i].end());\\n\\n        for(int i=n-1; i>=0; i--){\\n            // removing the last element from each row\\n            maxi = -1;\\n            for(int j=0; j<m; j++){\\n                maxi = max(maxi, grid[j][i]);\\n                grid[j].pop_back();\\n            }\\n            // storing the maximum value\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3118339,
                "title": "c",
                "content": "# Intuition\\nSort each row\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSort each row, and compare reach row by column\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:?\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int DeleteGreatestValue(int[][] grid)\\n            {\\n                int result = 0;\\n                foreach (int[] row in grid)\\n                {\\n                    Array.Sort(row);\\n                }\\n\\n                for(int i = 0; i < grid[0].Length ; i++)\\n                {\\n                    int max = 0;\\n                    for(int j = 0;j<grid.Length ;j++)\\n                    {\\n                        if (max < grid[j][i])\\n                            max = grid[j][i]; \\n                    }\\n                    result = result + max;\\n                }\\n\\n                return result;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int DeleteGreatestValue(int[][] grid)\\n            {\\n                int result = 0;\\n                foreach (int[] row in grid)\\n                {\\n                    Array.Sort(row);\\n                }\\n\\n                for(int i = 0; i < grid[0].Length ; i++)\\n                {\\n                    int max = 0;\\n                    for(int j = 0;j<grid.Length ;j++)\\n                    {\\n                        if (max < grid[j][i])\\n                            max = grid[j][i]; \\n                    }\\n                    result = result + max;\\n                }\\n\\n                return result;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066368,
                "title": "using-sorting-c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for(int i=nums[0].size()-1;i>=0;i--){\\n            int mx=0;\\n            for(int j=0;j<nums.size();j++){\\n                mx=max(nums[j][i],mx);\\n            }\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            sort(nums[i].begin(),nums[i].end());\\n        }\\n        int ans=0;\\n        for(int i=nums[0].size()-1;i>=0;i--){\\n            int mx=0;\\n            for(int j=0;j<nums.size();j++){\\n                mx=max(nums[j][i],mx);\\n            }\\n            ans+=mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064755,
                "title": "c-solution-beats-97-constant-space",
                "content": "# Intuition : Sort each row, after that add the max no. of each column to the answer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * mlogm)$$ + $$O(n * m)$$ = $$O(n * logm)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++) sort(grid[i].begin(), grid[i].end());\\n        int maxi = 0;\\n        int ans = 0;\\n        for(int i=0;i<grid[0].size();i++){\\n            maxi = 0;\\n            for(int j=0;j<grid.size();j++) {\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++) sort(grid[i].begin(), grid[i].end());\\n        int maxi = 0;\\n        int ans = 0;\\n        for(int i=0;i<grid[0].size();i++){\\n            maxi = 0;\\n            for(int j=0;j<grid.size();j++) {\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2972195,
                "title": "heap-easy-python-solution",
                "content": "```class Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        # Heap\\n        count = 0\\n        ans = 0\\n        k = len(grid[0])\\n        while count < k:\\n            a = -1\\n            for i in range(len(grid)):\\n                heapq._heapify_max(grid[i])\\n                a = max(a , heapq.heappop(grid[i]))               \\n            count+=1\\n            ans+=a\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```class Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        # Heap\\n        count = 0\\n        ans = 0\\n        k = len(grid[0])\\n        while count < k:\\n            a = -1\\n            for i in range(len(grid)):\\n                heapq._heapify_max(grid[i])\\n                a = max(a , heapq.heappop(grid[i]))               \\n            count+=1\\n            ans+=a\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2964492,
                "title": "100-0ms-easy-one-pass-o-1-space-faster",
                "content": "# upvote pls\\n\\n# Complexity\\n- Time complexity: o(m* nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] g) {\\n        int a=0;\\n        for(var v:g){\\n            Arrays.sort(v);\\n        }\\n        for(int c=0;c<g[0].length;c++){\\n            int t=0;\\n            for(int r=0;r<g.length;r++) t=Math.max(t,g[r][c]);\\n            a+=t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] g) {\\n        int a=0;\\n        for(var v:g){\\n            Arrays.sort(v);\\n        }\\n        for(int c=0;c<g[0].length;c++){\\n            int t=0;\\n            for(int r=0;r<g.length;r++) t=Math.max(t,g[r][c]);\\n            a+=t;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925068,
                "title": "sort-rows",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n * m * log m)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            sort(begin(grid[i]), end(grid[i]));\\n        int sum = 0, top;\\n        for(int j = 0; j < m; j++) {\\n            top = grid[0][j];\\n            for(int i = 0; i < n; i++)\\n                top = max(top, grid[i][j]);\\n            sum += top;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size(), m = grid[0].size();\\n        for(int i = 0; i < n; i++)\\n            sort(begin(grid[i]), end(grid[i]));\\n        int sum = 0, top;\\n        for(int j = 0; j < m; j++) {\\n            top = grid[0][j];\\n            for(int i = 0; i < n; i++)\\n                top = max(top, grid[i][j]);\\n            sum += top;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2910199,
                "title": "c-solution-using-map-and-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(m*n)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        unordered_map<int, priority_queue<int>> mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                mp[i].push(grid[i][j]);\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int maxval=-1;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n            \\n            int temp=mp[j].top();\\n            mp[j].pop();\\n            maxval=max(maxval,temp);\\n            }\\n            sum+=maxval;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        unordered_map<int, priority_queue<int>> mp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                mp[i].push(grid[i][j]);\\n            }\\n        }\\n        int sum=0;\\n        for(int i=0;i<grid[0].size();i++)\\n        {\\n            int maxval=-1;\\n            for(int j=0;j<grid.size();j++)\\n            {\\n            \\n            int temp=mp[j].top();\\n            mp[j].pop();\\n            maxval=max(maxval,temp);\\n            }\\n            sum+=maxval;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900686,
                "title": "java-brute-force-no-extra-space",
                "content": "---\\n# Please Upvote :D\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/6d9d00fd-8586-465e-be0e-d3857910bb3f_1670751226.9091904.png)\\n\\n---\\n\\n``` java []\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for (int[] row : grid) {\\n            Arrays.sort(row);\\n        }\\n\\n        int sum = 0;\\n        for (int i = grid[0].length - 1; i >= 0; i--) {\\n            int max = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                max = Math.max(max, grid[j][i]);\\n                // grid[j][i] = 0;  // delete (not necessary)\\n            }\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```\\n---\\nLet $$m$$ and $$n$$ be be the number of rows and columns respectively.\\n### Time Complexity: $$O(m * n * logn) + O(n * m) => O(m * n * logn)$$\\n### Space Complexity: $$O(1)$$\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for (int[] row : grid) {\\n            Arrays.sort(row);\\n        }\\n\\n        int sum = 0;\\n        for (int i = grid[0].length - 1; i >= 0; i--) {\\n            int max = 0;\\n            for (int j = 0; j < grid.length; j++) {\\n                max = Math.max(max, grid[j][i]);\\n                // grid[j][i] = 0;  // delete (not necessary)\\n            }\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900542,
                "title": "java-100-faster-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for (int[] arr : grid) {\\n            Arrays.sort(arr);\\n        }\\n        int sum = 0;\\n        for (int col = 0; col < grid[0].length; col++) {\\n            int max = 0;\\n            for (int row = 0; row < grid.length; row++) {\\n                if (grid[row][col] > max) {\\n                    max = grid[row][col];\\n                }\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for (int[] arr : grid) {\\n            Arrays.sort(arr);\\n        }\\n        int sum = 0;\\n        for (int col = 0; col < grid[0].length; col++) {\\n            int max = 0;\\n            for (int row = 0; row < grid.length; row++) {\\n                if (grid[row][col] > max) {\\n                    max = grid[row][col];\\n                }\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899734,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, grid))))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, grid))))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899643,
                "title": "easy-and-simple-solution",
                "content": "# Approach\\n1) Sorting each row\\n2) Go through columns and get max value from current column\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n  let sum = 0, idx = 0  \\n  for (let i = 0; i < grid.length; i++) {\\n    grid[i].sort((a,b) => b - a)\\n  }\\n\\n  while (idx < grid[0].length) {\\n    let max = -Infinity\\n    for (let i = 0; i < grid.length; i++) {      \\n        max = Math.max(grid[i][idx], max)\\n    }\\n\\n    idx++\\n    sum+=max\\n  } \\n\\n  return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n  let sum = 0, idx = 0  \\n  for (let i = 0; i < grid.length; i++) {\\n    grid[i].sort((a,b) => b - a)\\n  }\\n\\n  while (idx < grid[0].length) {\\n    let max = -Infinity\\n    for (let i = 0; i < grid.length; i++) {      \\n        max = Math.max(grid[i][idx], max)\\n    }\\n\\n    idx++\\n    sum+=max\\n  } \\n\\n  return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2899584,
                "title": "c-java-python3-sorting",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/8f409c5e220a4a1a1d7fdfbfcc1dcd24eeead232) for solutions of weekly 323. \\n\\n**Intuition**\\nThe problem can be solved by sorting each row and sum the largest of each column. \\n**Implementation**\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for (auto& row : grid) \\n            sort(row.begin(), row.end()); \\n        int ans = 0; \\n        for (int j = 0, n = grid[0].size(); j < n; ++j) {\\n            int val = 0; \\n            for (int i = 0, m = grid.size(); i < m; ++i) \\n                val = max(val, grid[i][j]); \\n            ans += val; \\n        }\\n        return ans; \\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int m = grid.length, n = grid[0].length; \\n        for (int[] row : grid) Arrays.sort(row); \\n        int ans = 0; \\n        for (int j = 0; j < n; ++j) {\\n            int cand = 0; \\n            for (int i = 0; i < m; ++i) \\n                cand = Math.max(cand, grid[i][j]); \\n            ans += cand; \\n        }\\n        return ans; \\n    }\\n}\\n```\\n**Python3**\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid: row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n```\\n**Complexity**\\nTime `O(MNlogN)`\\nSpace `O(1)`",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for (auto& row : grid) \\n            sort(row.begin(), row.end()); \\n        int ans = 0; \\n        for (int j = 0, n = grid[0].size(); j < n; ++j) {\\n            int val = 0; \\n            for (int i = 0, m = grid.size(); i < m; ++i) \\n                val = max(val, grid[i][j]); \\n            ans += val; \\n        }\\n        return ans; \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int m = grid.length, n = grid[0].length; \\n        for (int[] row : grid) Arrays.sort(row); \\n        int ans = 0; \\n        for (int j = 0; j < n; ++j) {\\n            int cand = 0; \\n            for (int i = 0; i < m; ++i) \\n                cand = Math.max(cand, grid[i][j]); \\n            ans += cand; \\n        }\\n        return ans; \\n    }\\n}\\n```\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid: row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899558,
                "title": "simplest-java-solution-100",
                "content": "**One day you will solve all four questions in contest. All the best\\uD83E\\uDD1E**\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n           \\n        }\\n        ArrayList<Integer> list = new ArrayList();\\n        for(int i=grid[0].length-1;i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                max = Math.max(max,grid[j][i]);\\n            }\\n            list.add(max);\\n        }\\n        \\n        int sum=0;\\n        for(int i=0;i<list.size();i++){\\n            sum+=list.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```\\n\\n**Please upvote if you liked..**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n           \\n        }\\n        ArrayList<Integer> list = new ArrayList();\\n        for(int i=grid[0].length-1;i>=0;i--){\\n            int max = Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                max = Math.max(max,grid[j][i]);\\n            }\\n            list.add(max);\\n        }\\n        \\n        int sum=0;\\n        for(int i=0;i<list.size();i++){\\n            sum+=list.get(i);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899541,
                "title": "c-sorting-greedy",
                "content": "\\n# Complexity\\n- Time complexity: O(NLonN) + O(m*n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(auto &v:grid){\\n            sort(v.begin(), v.end());\\n        }\\n        sort(grid.begin(), grid.end());\\n        \\n        for(int j=n-1;j>=0;j--){\\n            int maxi=0;\\n            for(int i=m-1;i>=0;i--){\\n                maxi=max(maxi, grid[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans=0;\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        \\n        for(auto &v:grid){\\n            sort(v.begin(), v.end());\\n        }\\n        sort(grid.begin(), grid.end());\\n        \\n        for(int j=n-1;j>=0;j--){\\n            int maxi=0;\\n            for(int i=m-1;i>=0;i--){\\n                maxi=max(maxi, grid[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899515,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(int a , int b){\\n        return a>b;\\n    }\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        vector<vector<int>> mat = grid;\\n        \\n        \\n        for(int i=0 ; i<grid.size() ; i++){\\n            sort(mat[i].begin() , mat[i].end() , cmp);\\n        }\\n        \\n        for(int j=0 ; j<mat[0].size() ; j++){\\n            vector<int> tmp(mat.size());\\n            for(int i=0 ; i<mat.size() ; i++){\\n               \\n                tmp.push_back(mat[i][j]);\\n            }\\n           \\n            sort(tmp.begin() , tmp.end() , cmp);\\n            \\n            ans = ans + tmp[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(int a , int b){\\n        return a>b;\\n    }\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        \\n        vector<vector<int>> mat = grid;\\n        \\n        \\n        for(int i=0 ; i<grid.size() ; i++){\\n            sort(mat[i].begin() , mat[i].end() , cmp);\\n        }\\n        \\n        for(int j=0 ; j<mat[0].size() ; j++){\\n            vector<int> tmp(mat.size());\\n            for(int i=0 ; i<mat.size() ; i++){\\n               \\n                tmp.push_back(mat[i][j]);\\n            }\\n           \\n            sort(tmp.begin() , tmp.end() , cmp);\\n            \\n            ans = ans + tmp[0];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899427,
                "title": "simple-java-solution-brute-force",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n*m*n) for traversing the loop + O(n logn) for sorting the list\\n\\n- Space complexity: O(n) + O(n) for storing the elements in the list \\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int s=0;\\n        List<Integer> kk=new ArrayList<>();\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            List<Integer> nm=new ArrayList<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                int m=0,p=Integer.MIN_VALUE;\\n                for(int k=0;k<grid[j].length;k++)\\n                {\\n                    if(p<grid[j][k])\\n                    {\\n                        p=grid[j][k];\\n                        m=k;\\n                    }\\n                }\\n                nm.add(p);\\n                grid[j][m]=0;\\n            }\\n            Collections.sort(nm);\\n            kk.add(nm.get(nm.size()-1));\\n        }\\n        for(int i=0;i<kk.size();i++)\\n        {\\n            s+=kk.get(i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int s=0;\\n        List<Integer> kk=new ArrayList<>();\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            List<Integer> nm=new ArrayList<>();\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                int m=0,p=Integer.MIN_VALUE;\\n                for(int k=0;k<grid[j].length;k++)\\n                {\\n                    if(p<grid[j][k])\\n                    {\\n                        p=grid[j][k];\\n                        m=k;\\n                    }\\n                }\\n                nm.add(p);\\n                grid[j][m]=0;\\n            }\\n            Collections.sort(nm);\\n            kk.add(nm.get(nm.size()-1));\\n        }\\n        for(int i=0;i<kk.size();i++)\\n        {\\n            s+=kk.get(i);\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899396,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i = 0; i < grid.length; i++) {\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans = 0;\\n        for(int col = 0; col < grid[0].length; col++) {\\n            int max = 0;\\n            for(int row = 0; row < grid.length; row++) {\\n                max = Math.max(max, grid[row][col]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i = 0; i < grid.length; i++) {\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans = 0;\\n        for(int col = 0; col < grid[0].length; col++) {\\n            int max = 0;\\n            for(int row = 0; row < grid.length; row++) {\\n                max = Math.max(max, grid[row][col]);\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899388,
                "title": "java-easy-solution",
                "content": "**The basic idea is to first sort the matrix \\nThen start comparing last row last column with its upper row last column. Find the max and sum it with answer .**\\n\\n![image](https://assets.leetcode.com/users/images/92d39f6b-acfe-4922-931d-4a3e71917ba9_1670864404.114526.png)\\n\\n\\n```\\n  public int deleteGreatestValue(int[][] grid) {\\n     \\n        int ans = 0;\\n    \\n    //for sorting \\n        \\nfor (int k = 0; k < grid.length; k++) {\\n        for (int i= 0; i < grid[k].length; i++) {\\n            for (int j = 0; j < grid[k].length; j++) {\\n                if (grid[k][i] < grid[k][j]) {\\n                    int temp = grid[k][i];\\n                    grid[k][i] = grid[k][j];\\n                    grid[k][j] = temp;\\n                }\\n            }\\n        }\\n    }\\n        \\n        \\n        for(int i=grid[0].length-1;i>=0;i--){\\n            int max = -10;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[j][i]>max){\\n                    max = grid[j][i];\\n                }  \\n            }\\n           ans+=max;\\n        }\\n    return ans;\\n    }\\n```\\n\\n### PLS UPVOTE IF HELPED",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\n  public int deleteGreatestValue(int[][] grid) {\\n     \\n        int ans = 0;\\n    \\n    //for sorting \\n        \\nfor (int k = 0; k < grid.length; k++) {\\n        for (int i= 0; i < grid[k].length; i++) {\\n            for (int j = 0; j < grid[k].length; j++) {\\n                if (grid[k][i] < grid[k][j]) {\\n                    int temp = grid[k][i];\\n                    grid[k][i] = grid[k][j];\\n                    grid[k][j] = temp;\\n                }\\n            }\\n        }\\n    }\\n        \\n        \\n        for(int i=grid[0].length-1;i>=0;i--){\\n            int max = -10;\\n            for(int j=grid.length-1;j>=0;j--){\\n                if(grid[j][i]>max){\\n                    max = grid[j][i];\\n                }  \\n            }\\n           ans+=max;\\n        }\\n    return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043837,
                "title": "easy-to-understand-and-beginner-friendly-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable \\'sum\\' to 0 to store the final result.\\n2. Iterate through each column of the \\'grid\\' from left to right (represented by \\'k\\', ranging from 0 to the number of columns in the \\'grid\\' minus 1).\\n   a. Initialize \\'maxColumnValue\\' to -1 to keep track of the maximum value in the current column.\\n   b. Initialize \\'rowMaxValue\\' and \\'maxRowIndex\\' to track the maximum value in the current row and its row index.\\n   c. Iterate through each row of the \\'grid\\' (represented by \\'i\\', ranging from 0 to the number of rows in the \\'grid\\' minus 1).\\n      i. Initialize \\'rowMaxValue\\' to -1, indicating no maximum found in the current row.\\n      ii. Iterate through each element in the current row (represented by \\'j\\', ranging from 0 to the number of columns in the \\'grid\\' minus 1).\\n         - If \\'rowMaxValue\\' is less than the current element \\'grid[i][j]\\', update \\'rowMaxValue\\' to \\'grid[i][j]\\' and set \\'maxRowIndex\\' to \\'i\\'.\\n      iii. Update \\'maxColumnValue\\' to be the maximum of its current value and \\'rowMaxValue\\'.\\n      iv. Mark the maximum value found in the current row as deleted by setting it to -1 (\\'grid[maxRowIndex][j] = -1\\').\\n   d. Add \\'maxColumnValue\\' to \\'sum\\'. This represents the maximum value in the current column.\\n3. After completing the iteration through all columns, the \\'sum\\' will contain the sum of the maximum values of each column.\\n4. Return \\'sum\\' as the final result.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int sum = 0; // Initialize the sum to store the final result.\\n\\n        // Iterate through each column of the grid.\\n        for (int k = 0; k < grid[0].size(); k++) {\\n            int maxRowMax = -1; // Initialize the maximum value found in the current column.\\n            int rowMax; // Variable to store the maximum value in the current row.\\n            int columnIndex; // Variable to store the column index of the maximum value.\\n\\n            // Iterate through each row of the grid.\\n            for (int i = 0; i < grid.size(); i++) {\\n                rowMax = -1; // Initialize the maximum value found in the current row.\\n\\n                // Find the maximum value and its column index in the current row.\\n                for (int j = 0; j < grid[i].size(); j++) {\\n                    if (rowMax < grid[i][j]) {\\n                        columnIndex = j; // Store the column index of the maximum value.\\n                        rowMax = grid[i][j]; // Update the maximum value found in the current row.\\n                    }\\n                }\\n\\n                maxRowMax = max(maxRowMax, rowMax); // Update the maximum value found in the current column.\\n\\n                // Mark the maximum value as deleted by setting it to -1.\\n                grid[i][columnIndex] = -1;\\n            }\\n\\n            sum += maxRowMax; // Add the maximum value of the current column to the sum.\\n        }\\n\\n        return sum; // Return the final sum.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int sum = 0; // Initialize the sum to store the final result.\\n\\n        // Iterate through each column of the grid.\\n        for (int k = 0; k < grid[0].size(); k++) {\\n            int maxRowMax = -1; // Initialize the maximum value found in the current column.\\n            int rowMax; // Variable to store the maximum value in the current row.\\n            int columnIndex; // Variable to store the column index of the maximum value.\\n\\n            // Iterate through each row of the grid.\\n            for (int i = 0; i < grid.size(); i++) {\\n                rowMax = -1; // Initialize the maximum value found in the current row.\\n\\n                // Find the maximum value and its column index in the current row.\\n                for (int j = 0; j < grid[i].size(); j++) {\\n                    if (rowMax < grid[i][j]) {\\n                        columnIndex = j; // Store the column index of the maximum value.\\n                        rowMax = grid[i][j]; // Update the maximum value found in the current row.\\n                    }\\n                }\\n\\n                maxRowMax = max(maxRowMax, rowMax); // Update the maximum value found in the current column.\\n\\n                // Mark the maximum value as deleted by setting it to -1.\\n                grid[i][columnIndex] = -1;\\n            }\\n\\n            sum += maxRowMax; // Add the maximum value of the current column to the sum.\\n        }\\n\\n        return sum; // Return the final sum.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976607,
                "title": "memory-details-13-24mb-beats-86-11-of-users-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def deleteGreatestValue(self, grid):\\n        cound = 0\\n        l = len(grid)\\n        if l > 1:\\n            for i in range(len(grid[0])):\\n                new_list = []\\n                for j in range(l):\\n                    a = sorted(grid[j])\\n                    new_list.append(a[i])\\n                cound+=max(new_list)\\n            return cound\\n        else: \\n            return sum(grid[0])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def deleteGreatestValue(self, grid):\\n        cound = 0\\n        l = len(grid)\\n        if l > 1:\\n            for i in range(len(grid[0])):\\n                new_list = []\\n                for j in range(l):\\n                    a = sorted(grid[j])\\n                    new_list.append(a[i])\\n                cound+=max(new_list)\\n            return cound\\n        else: \\n            return sum(grid[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3811490,
                "title": "easiest-c-solution-sortings",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int sum =0;\\n        for(int col=grid[0].size()-1;col>=0;col--){\\n            int mx = INT_MIN;\\n            for(int row = 0;row<grid.size();row++){\\n                mx = max(mx,grid[row][col]);\\n            }\\n            sum+=mx;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int sum =0;\\n        for(int col=grid[0].size()-1;col>=0;col--){\\n            int mx = INT_MIN;\\n            for(int row = 0;row<grid.size();row++){\\n                mx = max(mx,grid[row][col]);\\n            }\\n            sum+=mx;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649751,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction deleteGreatestValue(grid: number[][]): number {\\n  grid.forEach((row)=> row.sort((a,b)=> a-b))\\n  let sum = 0;\\n\\n  while(grid[0].length) {\\n      let arr = []\\n      for(let row of grid) {\\n        arr.push(row.pop())\\n      }\\n      sum += Math.max(...arr)\\n  }\\n  return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction deleteGreatestValue(grid: number[][]): number {\\n  grid.forEach((row)=> row.sort((a,b)=> a-b))\\n  let sum = 0;\\n\\n  while(grid[0].length) {\\n      let arr = []\\n      for(let row of grid) {\\n        arr.push(row.pop())\\n      }\\n      sum += Math.max(...arr)\\n  }\\n  return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3499229,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int arr[] : grid) {\\n            Arrays.sort(arr);\\n        }\\n        int sum = 0;\\n        int max;\\n        for(int i = grid[0].length - 1; i >= 0; i--) {\\n            max = 0;\\n            for(int arr[] : grid) {\\n                max = max > arr[i] ? max : arr[i];\\n            }\\n            sum += max;            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int arr[] : grid) {\\n            Arrays.sort(arr);\\n        }\\n        int sum = 0;\\n        int max;\\n        for(int i = grid[0].length - 1; i >= 0; i--) {\\n            max = 0;\\n            for(int arr[] : grid) {\\n                max = max > arr[i] ? max : arr[i];\\n            }\\n            sum += max;            \\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409957,
                "title": "smallest-space-complexity-solution-with-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int n   = grid[0].length;\\n        int sum = 0;\\n        for(int[] a: grid){\\n            Arrays.sort(a);\\n        }\\n        for(int a = 0; a < n; a++){\\n            int max = 0;\\n            for(int[] b : grid){\\n                max = Math.max(max, b[a]);\\n            }\\n            sum+=max;\\n        }        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int n   = grid[0].length;\\n        int sum = 0;\\n        for(int[] a: grid){\\n            Arrays.sort(a);\\n        }\\n        for(int a = 0; a < n; a++){\\n            int max = 0;\\n            for(int[] b : grid){\\n                max = Math.max(max, b[a]);\\n            }\\n            sum+=max;\\n        }        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359233,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(m*(nlogn))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n\\n    int m=grid.size();\\n    int n=grid[0].size();\\n\\n    for(int i=0;i<m;i++)\\n        sort(grid[i].begin(),grid[i].end());\\n\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        int value=0;\\n        for(int j=0;j<m;j++)\\n            value=max(value,grid[j][i]);\\n        sum+=value;\\n    }\\n    return sum;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n\\n    int m=grid.size();\\n    int n=grid[0].size();\\n\\n    for(int i=0;i<m;i++)\\n        sort(grid[i].begin(),grid[i].end());\\n\\n    int sum=0;\\n    for(int i=0;i<n;i++)\\n    {\\n        int value=0;\\n        for(int j=0;j<m;j++)\\n            value=max(value,grid[j][i]);\\n        sum+=value;\\n    }\\n    return sum;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354343,
                "title": "c-sorting-faster-easy-to-understand",
                "content": "* ***Sorting***\\n\\n* ***Time Complexity :- O(N * M)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // sort all the rows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n        \\n        // traverse over all the columns and find the maximum of all the columns\\n        \\n        int sum = 0;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int maxi = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                maxi = max(maxi, grid[i][j]);\\n            }\\n            \\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        \\n        int n = grid.size();\\n        \\n        int m = grid[0].size();\\n        \\n        // sort all the rows\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n        \\n        // traverse over all the columns and find the maximum of all the columns\\n        \\n        int sum = 0;\\n        \\n        for(int j = 0; j < m; j++)\\n        {\\n            int maxi = 0;\\n            \\n            for(int i = 0; i < n; i++)\\n            {\\n                maxi = max(maxi, grid[i][j]);\\n            }\\n            \\n            sum += maxi;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353562,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        grid.reduce(grid[0].map{$0*0}) {a,r in zip(a,r.sorted()).map { max($0.0, $0.1) }}.reduce(0,+)\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        grid.reduce(Array(repeating: 0, count: grid[0].count)) { result, row in \\n            zip(result, row.sorted()).map { max($0.0, $0.1) }\\n        }\\n        .reduce(0, +) // sum all values in array\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        grid.reduce(grid[0].map{$0*0}) {a,r in zip(a,r.sorted()).map { max($0.0, $0.1) }}.reduce(0,+)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        grid.reduce(Array(repeating: 0, count: grid[0].count)) { result, row in \\n            zip(result, row.sorted()).map { max($0.0, $0.1) }\\n        }\\n        .reduce(0, +) // sum all values in array\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248470,
                "title": "delete-greatest-value-in-each-row-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int i, j, max=0, ans=0;\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n\\n        for(j=grid[0].size()-1 ; j>=0 ; j--)\\n        {\\n            max = 0;\\n            for(i=0 ; i<grid.size() ; i++)\\n            {\\n                if(grid[i][j]>max)\\n                {\\n                    max = grid[i][j];\\n                }\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int i, j, max=0, ans=0;\\n        for(i=0 ; i<grid.size() ; i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n\\n        for(j=grid[0].size()-1 ; j>=0 ; j--)\\n        {\\n            max = 0;\\n            for(i=0 ; i<grid.size() ; i++)\\n            {\\n                if(grid[i][j]>max)\\n                {\\n                    max = grid[i][j];\\n                }\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231313,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i[]:grid){\\n           Arrays.sort(i);\\n       }\\n       int ans = 0;\\n       for(int j=0;j<grid[0].length;j++){\\n           int m = 0;\\n           for(int row[]:grid){\\n               m = Math.max(m,row[j]);\\n           }\\n           ans += m;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i[]:grid){\\n           Arrays.sort(i);\\n       }\\n       int ans = 0;\\n       for(int j=0;j<grid[0].length;j++){\\n           int m = 0;\\n           for(int row[]:grid){\\n               m = Math.max(m,row[j]);\\n           }\\n           ans += m;\\n       }\\n       return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214347,
                "title": "simple-c-solution",
                "content": "# Intuition\\n- Find max of maxs each round\\n- Add to result\\n- Delete max of each column\\n- Do gridColSize roumds\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- `for loop (do gridColSize rounds):`\\n  - initiate variables\\n  - find max of each column\\n  - find max of maxs for this round\\n  - set max of each column to zero (smallest number of all elements)\\n  - result += max of maxs\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\\n  int max = 0;           /* max of each column */\\n  int maxofmaxs = 0;     /* max of maxs */\\n  int jj = 0;            /* index of max of each column */\\n  int result = 0;        /* return value */\\n  for (size_t k = 0; k < *gridColSize; k++)\\n  {\\n    maxofmaxs = 0;\\n    for (size_t i = 0; i < gridSize; i++)\\n    {\\n      max = grid[i][0];\\n      jj = 0;\\n      for (size_t j = 0; j < *gridColSize; j++)\\n      {\\n        if (grid[i][j] > max)\\n        {\\n          max = grid[i][j];\\n          jj = j;\\n        }\\n      }\\n      grid[i][jj] = 0;\\n      if (maxofmaxs < max)\\n      {\\n        maxofmaxs = max;\\n      }\\n    }\\n    result += maxofmaxs;\\n  }\\n  return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint deleteGreatestValue(int** grid, int gridSize, int* gridColSize){\\n  int max = 0;           /* max of each column */\\n  int maxofmaxs = 0;     /* max of maxs */\\n  int jj = 0;            /* index of max of each column */\\n  int result = 0;        /* return value */\\n  for (size_t k = 0; k < *gridColSize; k++)\\n  {\\n    maxofmaxs = 0;\\n    for (size_t i = 0; i < gridSize; i++)\\n    {\\n      max = grid[i][0];\\n      jj = 0;\\n      for (size_t j = 0; j < *gridColSize; j++)\\n      {\\n        if (grid[i][j] > max)\\n        {\\n          max = grid[i][j];\\n          jj = j;\\n        }\\n      }\\n      grid[i][jj] = 0;\\n      if (maxofmaxs < max)\\n      {\\n        maxofmaxs = max;\\n      }\\n    }\\n    result += maxofmaxs;\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3106197,
                "title": "priority-queue-instead-of-sorting",
                "content": "```\\n    public int deleteGreatestValue(int[][] grid) {\\n\\t\\n        int result=0;\\n        List<PriorityQueue<Integer>> list = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < grid.length; i++) {\\n            PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n            for (int j = 0; j <grid[i].length ; j++) {\\n                pQueue.add(grid[i][j]);\\n            }\\n            list.add(pQueue);\\n        }\\n        \\n        for (int i = 0; i <grid[0].length ; i++) {\\n            int localCounter=0;\\n            for (int j = 0; j < list.size(); j++) {\\n                int number =list.get(j).poll();\\n                if(number>localCounter)\\n                    localCounter=number;\\n            }\\n            result+=localCounter;\\n        }\\n        return result;\\n    }\\n\\t",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int deleteGreatestValue(int[][] grid) {\\n\\t\\n        int result=0;\\n        List<PriorityQueue<Integer>> list = new ArrayList<>();\\n\\t\\t\\n        for (int i = 0; i < grid.length; i++) {\\n            PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>(Collections.reverseOrder());\\n            for (int j = 0; j <grid[i].length ; j++) {\\n                pQueue.add(grid[i][j]);\\n            }\\n            list.add(pQueue);\\n        }\\n        \\n        for (int i = 0; i <grid[0].length ; i++) {\\n            int localCounter=0;\\n            for (int j = 0; j < list.size(); j++) {\\n                int number =list.get(j).poll();\\n                if(number>localCounter)\\n                    localCounter=number;\\n            }\\n            result+=localCounter;\\n        }\\n        return result;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 3076927,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0; i<m; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<n; j++ ){\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            res = (res + maxi);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        long long res=0;\\n        for(int i=0; i<n; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0; i<m; i++){\\n            int maxi = INT_MIN;\\n            for(int j=0; j<n; j++ ){\\n                maxi = max(maxi, grid[j][i]);\\n            }\\n            res = (res + maxi);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062971,
                "title": "sort-the-rows-and-you-are-done",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the rows and you are done.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nm*nlogm\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int sum=0;int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                temp=max(temp,grid[j][i]);\\n            }\\n            sum+=temp;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int sum=0;int temp=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            temp=0;\\n            for(int j=0;j<m;j++)\\n            {\\n                temp=max(temp,grid[j][i]);\\n            }\\n            sum+=temp;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037309,
                "title": "easy-c-solution-sorting-comparing",
                "content": "\\n\\n# *Code*\\n```\\nclass Solution\\n {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid)\\n    {\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end(), greater<int>());\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < grid[0].size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < grid.size(); j++)\\n            {\\n                count = max(count, grid[j][i]);\\n            }\\n            temp = temp + count;\\n        }\\n        return temp;\\n    }\\n};\\n```\\nDo Upvote if u find this helpful.\\n",
                "solutionTags": [
                    "C++",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid)\\n    {\\n        for(int i = 0; i < grid.size(); i++)\\n        {\\n            sort(grid[i].begin(), grid[i].end(), greater<int>());\\n        }\\n        int temp = 0;\\n        for(int i = 0; i < grid[0].size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < grid.size(); j++)\\n            {\\n                count = max(count, grid[j][i]);\\n            }\\n            temp = temp + count;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933923,
                "title": "recursive-solution-for-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return self.calculate_answer(grid, 0)\\n\\n    def calculate_answer(self, grid: List[List[int]], answer: int) -> int:\\n        if grid[0] == []:\\n            return answer\\n\\n        current_max = 0\\n        for i in grid:\\n            maximum_int = max(i)\\n            if maximum_int >= current_max:\\n                current_max = maximum_int\\n\\n            i.remove(maximum_int)\\n\\n        answer += current_max\\n        return self.calculate_answer(grid, answer)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return self.calculate_answer(grid, 0)\\n\\n    def calculate_answer(self, grid: List[List[int]], answer: int) -> int:\\n        if grid[0] == []:\\n            return answer\\n\\n        current_max = 0\\n        for i in grid:\\n            maximum_int = max(i)\\n            if maximum_int >= current_max:\\n                current_max = maximum_int\\n\\n            i.remove(maximum_int)\\n\\n        answer += current_max\\n        return self.calculate_answer(grid, answer)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932566,
                "title": "python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        temp=grid.copy()\\n        k=0\\n        s=0\\n        while len(set(temp[0]))!=1 and len(grid[0])>=1 or k<len(temp):\\n            r=[]\\n            for i in range(len(temp)):\\n                x=max(temp[i])\\n                r+=[x]\\n                temp[i][temp[i].index(x)]=0            \\n            s+=max(r)\\n            print(temp)\\n            k+=1        \\n        return s\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        temp=grid.copy()\\n        k=0\\n        s=0\\n        while len(set(temp[0]))!=1 and len(grid[0])>=1 or k<len(temp):\\n            r=[]\\n            for i in range(len(temp)):\\n                x=max(temp[i])\\n                r+=[x]\\n                temp[i][temp[i].index(x)]=0            \\n            s+=max(r)\\n            print(temp)\\n            k+=1        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931204,
                "title": "easy-solution-by-c-brute-force",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int answer=0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<grid.size();j++){\\n                maxi=max(grid[j][i],maxi);\\n            }\\n            answer+=maxi;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int answer=0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int i=0;i<grid[0].size();i++){\\n            int maxi=0;\\n            for(int j=0;j<grid.size();j++){\\n                maxi=max(grid[j][i],maxi);\\n            }\\n            answer+=maxi;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918507,
                "title": "python-beats-79-easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        \\n        res = 0\\n        \\n        n = len(grid[0])\\n        \\n        for i in range(n):\\n            maxi = 0\\n            for j in grid:\\n                new = max(j)\\n                maxi = max(maxi,new)\\n                j.remove(new)\\n            res+=maxi\\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n        return res        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        \\n        res = 0\\n        \\n        n = len(grid[0])\\n        \\n        for i in range(n):\\n            maxi = 0\\n            for j in grid:\\n                new = max(j)\\n                maxi = max(maxi,new)\\n                j.remove(new)\\n            res+=maxi\\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n        return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2912667,
                "title": "rust-solution-0-ms",
                "content": "# Code\\n```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn delete_greatest_value(grid: Vec<Vec<i32>>) -> i32 {\\n        let len = grid[0].len();\\n        let mut sorted_grid = vec![];\\n        let mut result = 0;\\n        for mut row in grid {\\n            row.sort_by(|a, b| b.cmp(a));\\n            sorted_grid.push(row);\\n        }\\n        for i in 0..len {\\n            let mut greatest = i32::MIN;\\n            for row in &sorted_grid {\\n                greatest = max(greatest, row[i]);\\n            }\\n            result += greatest;\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::max;\\n\\nimpl Solution {\\n    pub fn delete_greatest_value(grid: Vec<Vec<i32>>) -> i32 {\\n        let len = grid[0].len();\\n        let mut sorted_grid = vec![];\\n        let mut result = 0;\\n        for mut row in grid {\\n            row.sort_by(|a, b| b.cmp(a));\\n            sorted_grid.push(row);\\n        }\\n        for i in 0..len {\\n            let mut greatest = i32::MIN;\\n            for row in &sorted_grid {\\n                greatest = max(greatest, row[i]);\\n            }\\n            result += greatest;\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2904359,
                "title": "easy-java-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //firstly observe a pattern that each time we take every row maximum which can be achieved by sorting and each time we did comparison from each row\\n       for(int i[]:grid){\\n           //sorting\\n           Arrays.sort(i);\\n       }\\n       //now we did comparsion column no. of times\\n       int ans = 0;\\n       for(int j=0;j<grid[0].length;j++){\\n           int m = -1;\\n           //each row one by one we traverse\\n           for(int row[]:grid){\\n               //we match the pattern while doing comparsion \\n               //in every jth comparsion we take jth element of the row\\n               m = Math.max(m,row[j]);\\n           }\\n           ans += m;\\n       }\\n\\n       return ans;\\n\\n       }\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //firstly observe a pattern that each time we take every row maximum which can be achieved by sorting and each time we did comparison from each row\\n       for(int i[]:grid){\\n           //sorting\\n           Arrays.sort(i);\\n       }\\n       //now we did comparsion column no. of times\\n       int ans = 0;\\n       for(int j=0;j<grid[0].length;j++){\\n           int m = -1;\\n           //each row one by one we traverse\\n           for(int row[]:grid){\\n               //we match the pattern while doing comparsion \\n               //in every jth comparsion we take jth element of the row\\n               m = Math.max(m,row[j]);\\n           }\\n           ans += m;\\n       }\\n\\n       return ans;\\n\\n       }\\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901253,
                "title": "simple-c-code-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& g) {\\n       int  row =g.size();\\n       int col = g[0].size(); \\n       int sum=0;\\n       int max=-1;\\n      for(int i=0; i<row; i++){\\n          sort(g[i].begin(),g[i].end());\\n        }\\n        for(int i=0; i<col; i++){ max=0;\\n        for(int j=0; j<row; j++){\\n         if(max<g[j][i]){\\n             max=g[j][i];}//if\\n    }\\n        sum+=max;\\n    }\\n  return sum;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& g) {\\n       int  row =g.size();\\n       int col = g[0].size(); \\n       int sum=0;\\n       int max=-1;\\n      for(int i=0; i<row; i++){\\n          sort(g[i].begin(),g[i].end());\\n        }\\n        for(int i=0; i<col; i++){ max=0;\\n        for(int j=0; j<row; j++){\\n         if(max<g[j][i]){\\n             max=g[j][i];}//if\\n    }\\n        sum+=max;\\n    }\\n  return sum;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901163,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef delete_greatest_value(grid)\\n  grid.map(&:sort).transpose.sum(&:max)  \\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef delete_greatest_value(grid)\\n  grid.map(&:sort).transpose.sum(&:max)  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2900970,
                "title": "100-faster-simple-clean-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort each row, then find the sum of the largest values.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& g) {\\n        //ios_base::sync_with_stdio(false); //include this to speed up execution time\\n        int n = g.size(), m = g[0].size(), s = 0;\\n        for(int i=0; i<n; i++) sort(g[i].begin(), g[i].end());\\n        for(int i=0; i<m; i++) {\\n            int mx = 0;\\n            for(int j=0; j<n; j++) mx = max(g[j][i],mx);\\n            s+=mx;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& g) {\\n        //ios_base::sync_with_stdio(false); //include this to speed up execution time\\n        int n = g.size(), m = g[0].size(), s = 0;\\n        for(int i=0; i<n; i++) sort(g[i].begin(), g[i].end());\\n        for(int i=0; i<m; i++) {\\n            int mx = 0;\\n            for(int j=0; j<n; j++) mx = max(g[j][i],mx);\\n            s+=mx;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900758,
                "title": "golang-sorting",
                "content": "\\n# Code\\n```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc deleteGreatestValue(grid [][]int) int {\\n    \\n    for _, arr := range grid {\\n        sort.Ints(arr)\\n    }\\n    \\n    answer := 0\\n    for i := 0; i < len(grid[0]); i++ {\\n        tmp := 0\\n        for j := 0; j < len(grid); j++{\\n            tmp = max(tmp, grid[j][i])\\n        }\\n        answer += tmp\\n    }\\n    return answer\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Sort"
                ],
                "code": "```\\nfunc max(a, b int) int {\\n    if a > b {\\n        return a\\n    }\\n    return b\\n}\\nfunc deleteGreatestValue(grid [][]int) int {\\n    \\n    for _, arr := range grid {\\n        sort.Ints(arr)\\n    }\\n    \\n    answer := 0\\n    for i := 0; i < len(grid[0]); i++ {\\n        tmp := 0\\n        for j := 0; j < len(grid); j++{\\n            tmp = max(tmp, grid[j][i])\\n        }\\n        answer += tmp\\n    }\\n    return answer\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2900045,
                "title": "c-simple-easy-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    int mx, n, m;\\n    int getMax(vector<vector<int>>& grid,int col){\\n        int t = INT_MIN;\\n        for(int row=0; row<n; ++row)\\n            t = max(t,grid[row][col]);\\n        return t;\\n    }\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(auto &v: grid) sort(rbegin(v),rend(v));\\n        mx = 0, n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<m; ++i)\\n            mx += getMax(grid,i);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int mx, n, m;\\n    int getMax(vector<vector<int>>& grid,int col){\\n        int t = INT_MIN;\\n        for(int row=0; row<n; ++row)\\n            t = max(t,grid[row][col]);\\n        return t;\\n    }\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(auto &v: grid) sort(rbegin(v),rend(v));\\n        mx = 0, n = grid.size(), m = grid[0].size();\\n        for(int i=0; i<m; ++i)\\n            mx += getMax(grid,i);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899709,
                "title": "c-priority-queue-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse priority_queue to get maximum of each row on top.\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m*n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& v) {\\n        int m = v.size(), n = v[0].size();\\n        vector<priority_queue<int>> p(m);\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++)\\n                p[i].push(v[i][j]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            int res = 0;\\n            for(int j = 0; j < m; j++){\\n                res = max(res, p[j].top());\\n                p[j].pop();\\n            }\\n            ans += res;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& v) {\\n        int m = v.size(), n = v[0].size();\\n        vector<priority_queue<int>> p(m);\\n        \\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++)\\n                p[i].push(v[i][j]);\\n        }\\n        \\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            int res = 0;\\n            for(int j = 0; j < m; j++){\\n                res = max(res, p[j].top());\\n                p[j].pop();\\n            }\\n            ans += res;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899679,
                "title": "simple-python-solution-100-faster-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for i in range(0, len(grid)):\\n            grid[i].sort()\\n        n = len(grid[0])\\n        res = 0\\n        for j in range(0, n):\\n            ans = 0\\n            for i in range(0, len(grid)):\\n                ans = max(ans, grid[i].pop())\\n            res += ans\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899676,
                "title": "easy-c-solution-beats-100-in-runtime-memory",
                "content": "\\n# Approach\\n1. First sort the vector row by row in ascending order\\n2. Then compare the last element of all rows and find the largest between them.\\n3. Create a variable sum & store the largest value in it.\\n4. Delete/pop the last element of all rows\\n5. Repeat Step 2 until we are left with only 1 column in the row.\\n6. Now, when we are left with only one element in each row, find the largest among them and add in the sum variable\\n7. Return the sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size(); int sum=0; int largest;\\n       for(int i=0;i<m;i++)\\n            {\\n                sort(grid[i].begin(), grid[i].end());\\n            }\\n        while(grid[0].size()>1)\\n        {\\n            \\n            largest=grid[0].back();\\n            for(int i=0;i<m;i++)\\n            {\\n                if(largest<grid[i].back())\\n                {\\n                    largest=grid[i].back();\\n                }\\n            }\\n            sum=sum+largest;\\n\\n            for(int i=0;i<m;i++)\\n            {\\n                grid[i].pop_back();\\n            }\\n        }\\n        largest=grid[0].back();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(largest<grid[i].back())\\n                {\\n                    largest=grid[i].back();\\n                }\\n        }\\n        sum=sum+largest;\\n        return sum;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size(); int sum=0; int largest;\\n       for(int i=0;i<m;i++)\\n            {\\n                sort(grid[i].begin(), grid[i].end());\\n            }\\n        while(grid[0].size()>1)\\n        {\\n            \\n            largest=grid[0].back();\\n            for(int i=0;i<m;i++)\\n            {\\n                if(largest<grid[i].back())\\n                {\\n                    largest=grid[i].back();\\n                }\\n            }\\n            sum=sum+largest;\\n\\n            for(int i=0;i<m;i++)\\n            {\\n                grid[i].pop_back();\\n            }\\n        }\\n        largest=grid[0].back();\\n        for(int i=0;i<m;i++)\\n        {\\n            if(largest<grid[i].back())\\n                {\\n                    largest=grid[i].back();\\n                }\\n        }\\n        sum=sum+largest;\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899644,
                "title": "c-sorting-easy-88-time-55-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n      int m = grid.size(), n = grid[0].size(), ans = 0;\\n      for(int i = 0; i < m; i++)\\n        sort(grid[i].begin(), grid[i].end());\\n      for(int i = n - 1; i >= 0; i--){\\n        int t = 0;\\n        for(int j = 0; j < m; j++){\\n          t = max(grid[j][i], t);\\n        } \\n        ans += t;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n      int m = grid.size(), n = grid[0].size(), ans = 0;\\n      for(int i = 0; i < m; i++)\\n        sort(grid[i].begin(), grid[i].end());\\n      for(int i = n - 1; i >= 0; i--){\\n        int t = 0;\\n        for(int j = 0; j < m; j++){\\n          t = max(grid[j][i], t);\\n        } \\n        ans += t;\\n      }\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899633,
                "title": "easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    \\n    public int deleteGreatestValue(int[][] grid) {\\n        int rowMax[] = new int [grid.length];\\n        Arrays.fill(rowMax,Integer.MIN_VALUE);\\n        int ans= 0;\\n        int collength = grid[0].length;\\n\\n        while(collength>0){\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    rowMax[i] = Math.max(grid[i][j],rowMax[i]);\\n                }\\n            }\\n            ans = ans + Arrays.stream(rowMax).max().getAsInt();\\n            for (int i = 0; i <grid.length ; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if(grid[i][j]== rowMax[i]) {\\n                        grid[i][j]= Integer.MIN_VALUE;\\n                        rowMax[i]= Integer.MIN_VALUE;\\n                    }\\n                }\\n            }\\n            collength--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int deleteGreatestValue(int[][] grid) {\\n        int rowMax[] = new int [grid.length];\\n        Arrays.fill(rowMax,Integer.MIN_VALUE);\\n        int ans= 0;\\n        int collength = grid[0].length;\\n\\n        while(collength>0){\\n            for (int i = 0; i < grid.length; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    rowMax[i] = Math.max(grid[i][j],rowMax[i]);\\n                }\\n            }\\n            ans = ans + Arrays.stream(rowMax).max().getAsInt();\\n            for (int i = 0; i <grid.length ; i++) {\\n                for (int j = 0; j < grid[0].length; j++) {\\n                    if(grid[i][j]== rowMax[i]) {\\n                        grid[i][j]= Integer.MIN_VALUE;\\n                        rowMax[i]= Integer.MIN_VALUE;\\n                    }\\n                }\\n            }\\n            collength--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899463,
                "title": "o-n-mlogm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i= 0;i<grid.size();i++){\\n            sort(grid[i].rbegin(),grid[i].rend());\\n        }\\n        for(int j = 0;j<grid[0].size();j++){\\n            int mx = 0;\\n            for(int i= 0;i<grid.size();i++){\\n                mx = max(mx,grid[i][j]);\\n            };\\n            res+=mx;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int res = 0;\\n        for(int i= 0;i<grid.size();i++){\\n            sort(grid[i].rbegin(),grid[i].rend());\\n        }\\n        for(int j = 0;j<grid[0].size();j++){\\n            int mx = 0;\\n            for(int i= 0;i<grid.size();i++){\\n                mx = max(mx,grid[i][j]);\\n            };\\n            res+=mx;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899386,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        boolean[][] picked = new boolean[grid.length][grid[0].length];\\n        int result = 0;\\n        while(!check(picked)) {\\n            int maxValue = Integer.MIN_VALUE;\\n            for (int row = 0; row < grid.length; row++) {\\n                int maxValueForRow = Integer.MIN_VALUE;\\n                int maxColIndexForRow = 0; \\n                for (int col = 0; col < grid[0].length; col++) {\\n                    if (picked[row][col]) {\\n                        continue;\\n                    }\\n                    if (grid[row][col] >= maxValueForRow) {\\n                        maxValueForRow = grid[row][col];\\n                        maxColIndexForRow = col;\\n                    }\\n                }\\n                picked[row][maxColIndexForRow] = true; \\n                maxValue = Math.max(maxValue, maxValueForRow);\\n            }\\n            result = result + maxValue;\\n        }\\n        return result;\\n    }    \\n    public boolean check(boolean[][] picked) {\\n        for (int i = 0; i < picked.length; i++) {\\n            for (int j = 0; j < picked[0].length; j++) {\\n                if (!picked[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        boolean[][] picked = new boolean[grid.length][grid[0].length];\\n        int result = 0;\\n        while(!check(picked)) {\\n            int maxValue = Integer.MIN_VALUE;\\n            for (int row = 0; row < grid.length; row++) {\\n                int maxValueForRow = Integer.MIN_VALUE;\\n                int maxColIndexForRow = 0; \\n                for (int col = 0; col < grid[0].length; col++) {\\n                    if (picked[row][col]) {\\n                        continue;\\n                    }\\n                    if (grid[row][col] >= maxValueForRow) {\\n                        maxValueForRow = grid[row][col];\\n                        maxColIndexForRow = col;\\n                    }\\n                }\\n                picked[row][maxColIndexForRow] = true; \\n                maxValue = Math.max(maxValue, maxValueForRow);\\n            }\\n            result = result + maxValue;\\n        }\\n        return result;\\n    }    \\n    public boolean check(boolean[][] picked) {\\n        for (int i = 0; i < picked.length; i++) {\\n            for (int j = 0; j < picked[0].length; j++) {\\n                if (!picked[i][j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899367,
                "title": "c-simple-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            sort(grid[i].rbegin(), grid[i].rend());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int val = grid[0][i];\\n            // cout<<val<<\" \";\\n            for(int j=1; j<grid.size(); j++){\\n               // cout<<grid[j][i]<<\" \";\\n                val = max(val, grid[j][i]);\\n            }\\n            // cout<<endl;\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        \\n        for(int i=0; i<grid.size(); i++){\\n            sort(grid[i].rbegin(), grid[i].rend());\\n        }\\n        \\n        int ans = 0;\\n        for(int i=0; i<grid[0].size(); i++){\\n            int val = grid[0][i];\\n            // cout<<val<<\" \";\\n            for(int j=1; j<grid.size(); j++){\\n               // cout<<grid[j][i]<<\" \";\\n                val = max(val, grid[j][i]);\\n            }\\n            // cout<<endl;\\n            ans += val;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4097870,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, grid))))      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        return sum(map(max, zip(*map(sorted, grid))))      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095808,
                "title": "simple-easy-beats-88",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        // if(grid.size() == 1 && grid[0].size() == 1){\\n        //     return grid[0][0];\\n        // }\\n\\n        for(int i=0; i<grid.size(); i++){\\n            sort(grid[i].begin(), grid[i].end());\\n            reverse(grid[i].begin(), grid[i].end());\\n        }\\n\\n    \\n\\n        int ans = 0;\\n        int maxI = INT_MIN;\\n        if(grid.size() == 1){\\n            ans = accumulate(grid[0].begin(), grid[0].end(), 0);\\n            return ans;\\n        }\\n        for(int i=0; i<grid[0].size(); i++){\\n            maxI = INT_MIN;\\n            for(int j=0; j<grid.size(); j++){\\n                maxI = max(maxI, grid[j][i]);\\n            }\\n            ans += maxI;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        // if(grid.size() == 1 && grid[0].size() == 1){\\n        //     return grid[0][0];\\n        // }\\n\\n        for(int i=0; i<grid.size(); i++){\\n            sort(grid[i].begin(), grid[i].end());\\n            reverse(grid[i].begin(), grid[i].end());\\n        }\\n\\n    \\n\\n        int ans = 0;\\n        int maxI = INT_MIN;\\n        if(grid.size() == 1){\\n            ans = accumulate(grid[0].begin(), grid[0].end(), 0);\\n            return ans;\\n        }\\n        for(int i=0; i<grid[0].size(); i++){\\n            maxI = INT_MIN;\\n            for(int j=0; j<grid.size(); j++){\\n                maxI = max(maxI, grid[j][i]);\\n            }\\n            ans += maxI;\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093886,
                "title": "solution-with-java-6-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nchecking max number at each column and updating the row max and adding that to the sum requried.don\\'t forget to make the elements zero after finding the column max for futher iterations;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int d =0;\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int rm =0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                int cm =0,idx=-1;\\n                for(int k=0;k<grid[j].length;k++)\\n                {\\n                    if(grid[j][k]>cm)\\n                    {\\n                        cm = grid[j][k];\\n                        idx = k;\\n                    }\\n                }\\n                grid[j][idx] =0;\\n                rm = Math.max(rm,cm);\\n            }\\n            d+=rm;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int d =0;\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int rm =0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                int cm =0,idx=-1;\\n                for(int k=0;k<grid[j].length;k++)\\n                {\\n                    if(grid[j][k]>cm)\\n                    {\\n                        cm = grid[j][k];\\n                        idx = k;\\n                    }\\n                }\\n                grid[j][idx] =0;\\n                rm = Math.max(rm,cm);\\n            }\\n            d+=rm;\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089127,
                "title": "my-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        sum=0\\n        for i in range(len(grid[0])):\\n            k1=[]\\n            for j in range(len(grid)):\\n                k1.append(max(grid[j]))\\n                grid[j].pop(grid[j].index(max(grid[j])))\\n            sum+=max(k1)\\n        return sum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        sum=0\\n        for i in range(len(grid[0])):\\n            k1=[]\\n            for j in range(len(grid)):\\n                k1.append(max(grid[j]))\\n                grid[j].pop(grid[j].index(max(grid[j])))\\n            sum+=max(k1)\\n        return sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085094,
                "title": "c-easiest-solution-beats-100",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int DeleteGreatestValue(int[][] grid) {\\n            int sum = 0;\\n            foreach (var row in grid)\\n            {\\n                Array.Sort(row);\\n            }\\n            for (int i = 0; i < grid[0].Length; i++)\\n            {\\n                int max = grid[0][i];\\n                for (int j = 0; j < grid.Length; j++)\\n                {\\n                    if (max < grid[j][i]) max = grid[j][i];\\n                }\\n                sum += max;\\n            }\\n            return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DeleteGreatestValue(int[][] grid) {\\n            int sum = 0;\\n            foreach (var row in grid)\\n            {\\n                Array.Sort(row);\\n            }\\n            for (int i = 0; i < grid[0].Length; i++)\\n            {\\n                int max = grid[0][i];\\n                for (int j = 0; j < grid.Length; j++)\\n                {\\n                    if (max < grid[j][i]) max = grid[j][i];\\n                }\\n                sum += max;\\n            }\\n            return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4075164,
                "title": "easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        for(int i=0;i<n;i++) {\\n            sort(grid[i].begin(),grid[i].end(),greater<>());\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<m;i++) {\\n            int maxi = -1;\\n\\n            for(int j=0;j<n;j++) {\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n\\n            ans += maxi;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        for(int i=0;i<n;i++) {\\n            sort(grid[i].begin(),grid[i].end(),greater<>());\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i=0;i<m;i++) {\\n            int maxi = -1;\\n\\n            for(int j=0;j<n;j++) {\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n\\n            ans += maxi;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074514,
                "title": "python-solution-using-loops-easy-to-understand-for-beginners",
                "content": "# Complexity\\n![image.png](https://assets.leetcode.com/users/images/5c24588c-e18c-4478-a402-9a0938f4fcab_1695348250.7267997.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        temp=[]\\n        for i in grid :\\n            i.sort(reverse=True)\\n            temp.append(i)\\n        grid=temp.copy()\\n        s=0\\n        for i in range (len(grid[0])):\\n            stack=[]\\n            for j in range(len(grid)):\\n                stack.append(grid[j][i])\\n            s+=max(stack)\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        temp=[]\\n        for i in grid :\\n            i.sort(reverse=True)\\n            temp.append(i)\\n        grid=temp.copy()\\n        s=0\\n        for i in range (len(grid[0])):\\n            stack=[]\\n            for j in range(len(grid)):\\n                stack.append(grid[j][i])\\n            s+=max(stack)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074228,
                "title": "js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n   let answer = 0;\\n\\n  while (grid.length !== 0) {\\n      let temp = 0;\\n      for (let i = 0; i < grid.length; i++) {\\n          let el = Math.max(...grid[i]);\\n\\n          temp = Math.max(temp, el);\\n\\n          grid[i].splice(grid[i].indexOf(el), 1);\\n\\n          if (grid[i].length === 0) {\\n            grid.splice(i, 1);\\n            i--;\\n          }\\n      }\\n\\n      answer += temp;\\n  }\\n\\n  return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n   let answer = 0;\\n\\n  while (grid.length !== 0) {\\n      let temp = 0;\\n      for (let i = 0; i < grid.length; i++) {\\n          let el = Math.max(...grid[i]);\\n\\n          temp = Math.max(temp, el);\\n\\n          grid[i].splice(grid[i].indexOf(el), 1);\\n\\n          if (grid[i].length === 0) {\\n            grid.splice(i, 1);\\n            i--;\\n          }\\n      }\\n\\n      answer += temp;\\n  }\\n\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068736,
                "title": "python-simple-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        #INITIALISE RESULT TO 0\\n        result=0\\n        #ITERATE AND APPEND THE MAX VALUE OF LIST TO ANS.\\n        #DELETE THAT ELEMENT\\n        for k in range(len(grid[0])):\\n            ans=[]\\n            for i in grid:\\n                maxx=max(i)\\n                ans.append(maxx)\\n                i.remove(maxx)\\n            result+=max(ans)\\n        return result\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        #INITIALISE RESULT TO 0\\n        result=0\\n        #ITERATE AND APPEND THE MAX VALUE OF LIST TO ANS.\\n        #DELETE THAT ELEMENT\\n        for k in range(len(grid[0])):\\n            ans=[]\\n            for i in grid:\\n                maxx=max(i)\\n                ans.append(maxx)\\n                i.remove(maxx)\\n            result+=max(ans)\\n        return result\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064663,
                "title": "easy-js-solution",
                "content": "# Intuition\\nThe main idea is to **sort** every array, and then push the last values from them, choose max one and add to the result variable\\n\\n\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n\\n    let sorted = grid.map(item => item.sort((a,b) => a - b))\\n\\n    let result = 0\\n\\n    for (let i = grid[0].length - 1; i >= 0 ; i--) {\\n\\n        let arr = []\\n\\n        for (let k = 0; k < grid.length; k++) {\\n\\n            let val = grid[k].pop()\\n\\n            arr.push(val)\\n\\n        }\\n\\n\\n        result += Math.max(...arr)\\n\\n\\n    }\\n\\n    return result\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n\\n    let sorted = grid.map(item => item.sort((a,b) => a - b))\\n\\n    let result = 0\\n\\n    for (let i = grid[0].length - 1; i >= 0 ; i--) {\\n\\n        let arr = []\\n\\n        for (let k = 0; k < grid.length; k++) {\\n\\n            let val = grid[k].pop()\\n\\n            arr.push(val)\\n\\n        }\\n\\n\\n        result += Math.max(...arr)\\n\\n\\n    }\\n\\n    return result\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062661,
                "title": "easy-c-solution-beginner-freindly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int ans = 0;\\n        for(int j = n-1;j>=0;j--)\\n        {\\n            int lrg = 0;\\n            for(int i = 0;i<m;i++)\\n            {\\n                lrg = max(lrg,grid[i][j]);\\n            }\\n            ans += lrg;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int i = 0;i<m;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        int ans = 0;\\n        for(int j = n-1;j>=0;j--)\\n        {\\n            int lrg = 0;\\n            for(int i = 0;i<m;i++)\\n            {\\n                lrg = max(lrg,grid[i][j]);\\n            }\\n            ans += lrg;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061410,
                "title": "easy-python-solution-python",
                "content": "# EASY PYTHON SOLUTION || PYTHON || \\u270C\\u270C\\n# Runtime\\n- 104ms\\n- Beats 50.62%of users with Python3\\n# Memory\\n- 16.27MB\\n- Beats 95.03%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        m , n = len(grid) , len(grid[0])\\n        #print(m,n)\\n        res = 0\\n        while n>0:\\n            max_num = -float(\\'inf\\')\\n            for i in range(m):\\n                #print(grid[i])\\n                max_arr =  max(grid[i])\\n                max_num = max(max_arr,max_num)\\n                grid[i].remove(max_arr)\\n        \\n            res += max_num\\n            n-=1\\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        m , n = len(grid) , len(grid[0])\\n        #print(m,n)\\n        res = 0\\n        while n>0:\\n            max_num = -float(\\'inf\\')\\n            for i in range(m):\\n                #print(grid[i])\\n                max_arr =  max(grid[i])\\n                max_num = max(max_arr,max_num)\\n                grid[i].remove(max_arr)\\n        \\n            res += max_num\\n            n-=1\\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060372,
                "title": "simple-java-solution",
                "content": "# Intuition\\nPriorityQueue\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        List<PriorityQueue<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<grid.length;i++){\\n            list.add(new PriorityQueue<>());\\n            for(int j=0;j<grid[i].length;j++){\\n                list.get(i).add(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!list.isEmpty()){\\n            boolean queueEmpty = false;\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<grid.length;i++){\\n                int e = list.get(i).poll();\\n                if(e > max){\\n                    max = e;\\n                }\\n                queueEmpty = list.get(i).isEmpty();\\n            }\\n            ans += max;\\n            if(queueEmpty){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        List<PriorityQueue<Integer>> list = new ArrayList<>();\\n        for(int i=0;i<grid.length;i++){\\n            list.add(new PriorityQueue<>());\\n            for(int j=0;j<grid[i].length;j++){\\n                list.get(i).add(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        while(!list.isEmpty()){\\n            boolean queueEmpty = false;\\n            int max = Integer.MIN_VALUE;\\n            for(int i=0;i<grid.length;i++){\\n                int e = list.get(i).poll();\\n                if(e > max){\\n                    max = e;\\n                }\\n                queueEmpty = list.get(i).isEmpty();\\n            }\\n            ans += max;\\n            if(queueEmpty){\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055833,
                "title": "using-heap",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in grid:\\n            for i in range(len(row)):\\n                row[i] = -1 * row[i]\\n        for row in grid:\\n            heapq.heapify(row)\\n        \\n        while len(grid[0]) > 0:\\n            max_column = float(\"inf\")\\n            for i in range(len(grid)):\\n                if grid[i]:\\n                    row_max = heapq.heappop(grid[i])\\n                    if row_max < max_column:\\n                        max_column = row_max\\n                else:\\n                    break\\n            res += max_column\\n        return -res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        res = 0\\n        for row in grid:\\n            for i in range(len(row)):\\n                row[i] = -1 * row[i]\\n        for row in grid:\\n            heapq.heapify(row)\\n        \\n        while len(grid[0]) > 0:\\n            max_column = float(\"inf\")\\n            for i in range(len(grid)):\\n                if grid[i]:\\n                    row_max = heapq.heappop(grid[i])\\n                    if row_max < max_column:\\n                        max_column = row_max\\n                else:\\n                    break\\n            res += max_column\\n        return -res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049912,
                "title": "brute-force-method",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        result = 0\\n        while True:\\n            if len(grid[0]) == 0:\\n                break\\n            current_max = []\\n            for row in range(len(grid)):\\n                max_element = max(grid[row])\\n                grid[row].remove(max_element)\\n                current_max.append(max_element)\\n            result = result + max(current_max)\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        result = 0\\n        while True:\\n            if len(grid[0]) == 0:\\n                break\\n            current_max = []\\n            for row in range(len(grid)):\\n                max_element = max(grid[row])\\n                grid[row].remove(max_element)\\n                current_max.append(max_element)\\n            result = result + max(current_max)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048897,
                "title": "beats-99-java-beginner-friendly-easy-to-understand-solution",
                "content": "# Approach\\n1. Sort each row in the \\'grid\\', which takes O(n * log(n)) time for each row.\\n2. Then, for each column, find the maximum value among the sorted values, which takes O(m) time, where m is the number of rows.\\n\\n# Complexity\\n- Time complexity: O(m * n * log(n))\\n\\n- Space complexity: O(m * n)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        for (int[] ints : grid) {\\n            Arrays.sort(ints);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<grid[0].length; i++){\\n            int max = 0;\\n            for (int[] element : grid) {\\n                if (max <= element[i]) {\\n                    max = element[i];\\n                }\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        for (int[] ints : grid) {\\n            Arrays.sort(ints);\\n        }\\n        int ans = 0;\\n        for(int i=0; i<grid[0].length; i++){\\n            int max = 0;\\n            for (int[] element : grid) {\\n                if (max <= element[i]) {\\n                    max = element[i];\\n                }\\n            }\\n            ans += max;\\n        }\\n        return ans;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4046791,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n    var mat = grid\\n    var sum = 0\\n    \\n    for i in 0..<mat.count {\\n        mat[i].sort(by: >)\\n    }\\n    \\n    for i in 0..<mat[0].count {\\n        var max = [Int]()\\n        for j in 0..<mat.count {\\n            max.append(mat[j][i])\\n        }\\n        sum += max.max()!\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n    var mat = grid\\n    var sum = 0\\n    \\n    for i in 0..<mat.count {\\n        mat[i].sort(by: >)\\n    }\\n    \\n    for i in 0..<mat[0].count {\\n        var max = [Int]()\\n        for j in 0..<mat.count {\\n            max.append(mat[j][i])\\n        }\\n        sum += max.max()!\\n    }\\n    \\n    return sum\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042179,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n    let res = 0\\n    for (let i=0; i < grid.length; i++) {\\n        grid[i].sort((a,b) => b-a)\\n    }\\n    for(let i=0; i < grid[0].length;i++) {\\n        let max = 0\\n         for(let j=0; j < grid.length;j++) {\\n             max = Math.max(max, grid[j][i])\\n        }\\n        res+=max\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @return {number}\\n */\\nvar deleteGreatestValue = function(grid) {\\n    let res = 0\\n    for (let i=0; i < grid.length; i++) {\\n        grid[i].sort((a,b) => b-a)\\n    }\\n    for(let i=0; i < grid[0].length;i++) {\\n        let max = 0\\n         for(let j=0; j < grid.length;j++) {\\n             max = Math.max(max, grid[j][i])\\n        }\\n        res+=max\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040860,
                "title": "cpp-solution-priority-queue",
                "content": "# Intuition\\n\\n\\n# Approach\\nUsed priority queue to get maximum element at the top.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\nO(m\\u2217n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        priority_queue<int>pq[n];\\n        int ans =0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(auto j:grid[i])pq[i].push(j);\\n       }\\n        for(int j =0;j<m;j++){\\n            int tmp=-1;\\n            for(int i =0;i<n;i++){\\n                tmp=max(tmp,pq[i].top());\\n                pq[i].pop();\\n            }\\n            ans+=tmp;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid.size(), m=grid[0].size();\\n        priority_queue<int>pq[n];\\n        int ans =0;\\n       for(int i=0;i<n;i++)\\n       {\\n           for(auto j:grid[i])pq[i].push(j);\\n       }\\n        for(int j =0;j<m;j++){\\n            int tmp=-1;\\n            for(int i =0;i<n;i++){\\n                tmp=max(tmp,pq[i].top());\\n                pq[i].pop();\\n            }\\n            ans+=tmp;\\n        }\\n        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037208,
                "title": "java-easy-solution-with-using-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(mn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n\\n        int ans = 0;\\n\\n        for (int[] ints : grid)\\n            Arrays.sort(ints);\\n\\n        for (int j = 0; j < grid[0].length; j++) {\\n\\n            int max = 0;\\n            for (int[] ints : grid)\\n                max = Math.max(max, ints[j]);\\n\\n            ans += max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n\\n        int ans = 0;\\n\\n        for (int[] ints : grid)\\n            Arrays.sort(ints);\\n\\n        for (int j = 0; j < grid[0].length; j++) {\\n\\n            int max = 0;\\n            for (int[] ints : grid)\\n                max = Math.max(max, ints[j]);\\n\\n            ans += max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037202,
                "title": "easy-explained-ans-specially-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        for(int i=0;i<grid.size();i++){  \\n            sort(grid[i].begin(),grid[i].end());//sorting each row\\n        }\\n        int sum=0\\n        \\n        int ec=n-1;//intitializing last coloumn\\n        while(ec>=0){\\n            int maxi=INT_MIN;//to keep the track of largest\\n            for(int i=0;i<grid.size();i++){\\n                maxi=max(maxi,grid[i][ec]);\\n            }\\n            sum+=maxi;\\n            ec--;//dec last coloumn\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid[0].size();\\n        for(int i=0;i<grid.size();i++){  \\n            sort(grid[i].begin(),grid[i].end());//sorting each row\\n        }\\n        int sum=0\\n        \\n        int ec=n-1;//intitializing last coloumn\\n        while(ec>=0){\\n            int maxi=INT_MIN;//to keep the track of largest\\n            for(int i=0;i<grid.size();i++){\\n                maxi=max(maxi,grid[i][ec]);\\n            }\\n            sum+=maxi;\\n            ec--;//dec last coloumn\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023997,
                "title": "beat-97-easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int MAX=0,sum=0;\\n        int m=grid.size(),n=grid[0].size();\\n\\n        for(int i=0; i<m; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=n-1; j>=0; j--){\\n            for(int i=0; i<m; i++){\\n                MAX = max(MAX,grid[i][j]);\\n            }\\n            sum+=MAX;\\n            MAX=0;\\n        }\\n        return sum;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int MAX=0,sum=0;\\n        int m=grid.size(),n=grid[0].size();\\n\\n        for(int i=0; i<m; i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=n-1; j>=0; j--){\\n            for(int i=0; i<m; i++){\\n                MAX = max(MAX,grid[i][j]);\\n            }\\n            sum+=MAX;\\n            MAX=0;\\n        }\\n        return sum;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021505,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] arr) {\\n\\t\\t// sort all rows\\n\\t\\tfor (int[] is : arr) {\\n\\t\\t\\tArrays.sort(is);\\n\\t\\t}\\n\\t\\t// sum of all max number from all columns\\n\\t\\tint sum = 0;\\n\\t\\tint row = arr.length;\\n\\t\\tint col = arr[0].length;\\n\\t\\tfor (int i = 0; i < col; i++) {\\n\\t\\t\\tint col_max = 0;\\n\\t\\t\\tfor (int j = 0; j < row; j++) {\\n\\t\\t\\t\\tint val = arr[j][i];\\n\\t\\t\\t\\tif(val>col_max) {\\n\\t\\t\\t\\t\\tcol_max = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsum = sum + col_max;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] arr) {\\n\\t\\t// sort all rows\\n\\t\\tfor (int[] is : arr) {\\n\\t\\t\\tArrays.sort(is);\\n\\t\\t}\\n\\t\\t// sum of all max number from all columns\\n\\t\\tint sum = 0;\\n\\t\\tint row = arr.length;\\n\\t\\tint col = arr[0].length;\\n\\t\\tfor (int i = 0; i < col; i++) {\\n\\t\\t\\tint col_max = 0;\\n\\t\\t\\tfor (int j = 0; j < row; j++) {\\n\\t\\t\\t\\tint val = arr[j][i];\\n\\t\\t\\t\\tif(val>col_max) {\\n\\t\\t\\t\\t\\tcol_max = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsum = sum + col_max;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016550,
                "title": "easy-to-understand-o-n-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] arr) {\\n\\t\\t// sort all rows\\n\\t\\tfor (int[] is : arr) {\\n\\t\\t\\tArrays.sort(is);\\n\\t\\t}\\n\\t\\t// sum of all max number from all columns\\n\\t\\tint sum = 0;\\n\\t\\tint row = arr.length;\\n\\t\\tint col = arr[0].length;\\n\\t\\tfor (int i = 0; i < col; i++) {\\n\\t\\t\\tint col_max = 0;\\n\\t\\t\\tfor (int j = 0; j < row; j++) {\\n\\t\\t\\t\\tint val = arr[j][i];\\n\\t\\t\\t\\tif(val>col_max) {\\n\\t\\t\\t\\t\\tcol_max = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsum = sum + col_max;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] arr) {\\n\\t\\t// sort all rows\\n\\t\\tfor (int[] is : arr) {\\n\\t\\t\\tArrays.sort(is);\\n\\t\\t}\\n\\t\\t// sum of all max number from all columns\\n\\t\\tint sum = 0;\\n\\t\\tint row = arr.length;\\n\\t\\tint col = arr[0].length;\\n\\t\\tfor (int i = 0; i < col; i++) {\\n\\t\\t\\tint col_max = 0;\\n\\t\\t\\tfor (int j = 0; j < row; j++) {\\n\\t\\t\\t\\tint val = arr[j][i];\\n\\t\\t\\t\\tif(val>col_max) {\\n\\t\\t\\t\\t\\tcol_max = val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsum = sum + col_max;\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006740,
                "title": "simplest-and-cleanest-approach",
                "content": "# Approach\\nSort the each row of the array(grid), then traverse and find the max element among all the rows and add it to the ans.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int[] i: grid) {\\n            Arrays.sort(i);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i<grid[0].length; i++) {\\n            for(int j=0; j<grid.length; j++) {\\n                max = Math.max(max, grid[j][i]);\\n            }\\n            ans = ans + max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        int ans = 0;\\n\\n        for(int[] i: grid) {\\n            Arrays.sort(i);\\n        }\\n\\n        int max = Integer.MIN_VALUE;\\n        for(int i=0; i<grid[0].length; i++) {\\n            for(int j=0; j<grid.length; j++) {\\n                max = Math.max(max, grid[j][i]);\\n            }\\n            ans = ans + max;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988895,
                "title": "solution-using-priority-queue-in-golang",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need a Max Priority queue for every array in grid, whenever we pop an item, it will give the max of that array. similarly we will loop through the arrays to get max and sum them up.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through the arrays, for every array find and pop max of that array and store it to match it with other max of next arrays.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nfunc deleteGreatestValue(grid [][]int) int {\\n    res := 0\\n   \\n    for len(grid) > 0 {\\n        currMax := math.MinInt\\n        flag := true\\n        for idx,row := range grid {\\n            if len(row) > 0 {\\n            h := make(PQ, len(row))\\n            copy(h,row)\\n            heap.Init(&h)\\n            ele := heap.Pop(&h).(int)\\n            // fmt.Println(\"ele is \", ele)\\n            if ele > currMax {\\n                currMax = ele\\n            }\\n            grid[idx] = h\\n            if len(grid[idx]) == 0 {\\n                flag = false\\n            }\\n            }\\n        }\\n        // fmt.Println(\"curr Max is \", currMax)\\n        res += currMax\\n        if !flag {\\n            break\\n        }\\n    }\\n    return res\\n}\\n\\ntype PQ []int\\n\\nfunc (pq PQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq PQ) Swap(i,j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq PQ) Less(i,j int) bool {\\n    return pq[i] < pq[j]\\n}\\n\\nfunc (pq *PQ) Push(elem interface{}) {\\n    *pq = append(*pq, elem.(int))\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n    old := *pq\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc deleteGreatestValue(grid [][]int) int {\\n    res := 0\\n   \\n    for len(grid) > 0 {\\n        currMax := math.MinInt\\n        flag := true\\n        for idx,row := range grid {\\n            if len(row) > 0 {\\n            h := make(PQ, len(row))\\n            copy(h,row)\\n            heap.Init(&h)\\n            ele := heap.Pop(&h).(int)\\n            // fmt.Println(\"ele is \", ele)\\n            if ele > currMax {\\n                currMax = ele\\n            }\\n            grid[idx] = h\\n            if len(grid[idx]) == 0 {\\n                flag = false\\n            }\\n            }\\n        }\\n        // fmt.Println(\"curr Max is \", currMax)\\n        res += currMax\\n        if !flag {\\n            break\\n        }\\n    }\\n    return res\\n}\\n\\ntype PQ []int\\n\\nfunc (pq PQ) Len() int {\\n    return len(pq)\\n}\\n\\nfunc (pq PQ) Swap(i,j int) {\\n    pq[i], pq[j] = pq[j], pq[i]\\n}\\n\\nfunc (pq PQ) Less(i,j int) bool {\\n    return pq[i] < pq[j]\\n}\\n\\nfunc (pq *PQ) Push(elem interface{}) {\\n    *pq = append(*pq, elem.(int))\\n}\\n\\nfunc (pq *PQ) Pop() interface{} {\\n    old := *pq\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*pq = old[0 : n-1]\\n\\treturn x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985739,
                "title": "c-very-easy-5-lines-code",
                "content": "```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(std::vector<std::vector<int>>& grid) {\\n        // Step 1: Sort each row in ascending order\\n        for (int i = 0; i < grid.size(); i++) {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n\\n        int max = -1;\\n        int sum = 0;\\n\\n        // Step 2: Calculate the sum of maximum values from each column\\n        for (int i = grid[0].size() - 1; i >= 0; i--) {\\n            for (int j = grid.size() - 1; j >= 0; j--) {\\n                if (grid[j][i] > max) {\\n                    max = grid[j][i];\\n                }\\n            }\\n            sum += max;\\n            max = -1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(std::vector<std::vector<int>>& grid) {\\n        // Step 1: Sort each row in ascending order\\n        for (int i = 0; i < grid.size(); i++) {\\n            sort(grid[i].begin(), grid[i].end());\\n        }\\n\\n        int max = -1;\\n        int sum = 0;\\n\\n        // Step 2: Calculate the sum of maximum values from each column\\n        for (int i = grid[0].size() - 1; i >= 0; i--) {\\n            for (int j = grid.size() - 1; j >= 0; j--) {\\n                if (grid[j][i] > max) {\\n                    max = grid[j][i];\\n                }\\n            }\\n            sum += max;\\n            max = -1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3982688,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int DeleteGreatestValue(int[][] grid) {\\n        var arr = new int[grid[0].Length];\\n        for(var i = 0; i < grid.Length; i++){\\n            Array.Sort(grid[i]);\\n            for(var j = 0; j < grid[0].Length; j++){\\n                arr[j] =  Math.Max(arr[j], grid[i][j]);\\n            }\\n        }\\n        return arr.Sum();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DeleteGreatestValue(int[][] grid) {\\n        var arr = new int[grid[0].Length];\\n        for(var i = 0; i < grid.Length; i++){\\n            Array.Sort(grid[i]);\\n            for(var j = 0; j < grid[0].Length; j++){\\n                arr[j] =  Math.Max(arr[j], grid[i][j]);\\n            }\\n        }\\n        return arr.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973496,
                "title": "simple-c-brute-force-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int p=m;\\n\\n        int ans = 0;\\n        while(p--){\\n            vector<int> v;\\n            for(int i=0; i<n; i++){\\n                int maxi = 0, ind = -1;\\n                for(int j=0; j<m; j++){\\n                    if(grid[i][j] >= maxi){\\n                        maxi = grid[i][j];\\n                        ind = j;\\n                    }\\n                }\\n                grid[i][ind] = 0;\\n                //int a = *max_element(grid[i].begin(), grid[i].end());\\n                v.push_back(maxi);\\n            }\\n            int b = *max_element(v.begin(), v.end());\\n            ans += b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int p=m;\\n\\n        int ans = 0;\\n        while(p--){\\n            vector<int> v;\\n            for(int i=0; i<n; i++){\\n                int maxi = 0, ind = -1;\\n                for(int j=0; j<m; j++){\\n                    if(grid[i][j] >= maxi){\\n                        maxi = grid[i][j];\\n                        ind = j;\\n                    }\\n                }\\n                grid[i][ind] = 0;\\n                //int a = *max_element(grid[i].begin(), grid[i].end());\\n                v.push_back(maxi);\\n            }\\n            int b = *max_element(v.begin(), v.end());\\n            ans += b;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961445,
                "title": "simple-java-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int ans=0;\\n        int max=0;\\n        int m=grid[0].length-1;\\n        for(int num[]:grid){\\n            Arrays.sort(num);\\n        }\\n        while(m>=0){\\n        for(int i=0;i<grid.length;i++){\\n            max=Math.max(max,grid[i][m]);\\n        }\\n        ans+=max;\\n        max=0;\\n        m--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int ans=0;\\n        int max=0;\\n        int m=grid[0].length-1;\\n        for(int num[]:grid){\\n            Arrays.sort(num);\\n        }\\n        while(m>=0){\\n        for(int i=0;i<grid.length;i++){\\n            max=Math.max(max,grid[i][m]);\\n        }\\n        ans+=max;\\n        max=0;\\n        m--;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960319,
                "title": "easy-c-solution-o-m-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int j = 0;j<n;j++)\\n        {\\n            set<int> temp;\\n            for(int i=0;i<m;i++)\\n            {\\n                sort(grid[i].begin(),grid[i].end());\\n                temp.insert(*grid[i].rbegin());\\n                grid[i].pop_back();\\n            }\\n            if(!temp.empty())\\n            {\\n                ans += *temp.rbegin();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int ans = 0;\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        for(int j = 0;j<n;j++)\\n        {\\n            set<int> temp;\\n            for(int i=0;i<m;i++)\\n            {\\n                sort(grid[i].begin(),grid[i].end());\\n                temp.insert(*grid[i].rbegin());\\n                grid[i].pop_back();\\n            }\\n            if(!temp.empty())\\n            {\\n                ans += *temp.rbegin();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955464,
                "title": "beats-99-40-of-users-with-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //Sorting 2D Array\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        int sum = 0;\\n        int start = 0;\\n        int end = grid[0].length-1;\\n        while (start<=end){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0;row<grid.length;row++){\\n                if(grid[row][start]>max){\\n                    max = grid[row][start];\\n                }\\n            }\\n            sum+=max;\\n            start++;\\n        }return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //Sorting 2D Array\\n        for(int i = 0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        int sum = 0;\\n        int start = 0;\\n        int end = grid[0].length-1;\\n        while (start<=end){\\n            int max = Integer.MIN_VALUE;\\n            for(int row = 0;row<grid.length;row++){\\n                if(grid[row][start]>max){\\n                    max = grid[row][start];\\n                }\\n            }\\n            sum+=max;\\n            start++;\\n        }return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954045,
                "title": "sorting-logic-with-simple-loops",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor loop to traverse the sorted grid and taking out he maximum elemnent of each column and adding them together for final result.\\n\\n# Complexity\\n- Time complexity: 0(n**2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        hp = []\\n        mx = 0\\n        for i in grid:\\n            i.sort(reverse=True)\\n            hp.append(i)\\n        print(hp)\\n        for i in range(len(hp[0])):\\n            ans = 0\\n            for j in range(len(hp)):\\n                ans = max(ans,hp[j][i])\\n            mx = mx + ans\\n        return mx\\n                          \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        hp = []\\n        mx = 0\\n        for i in grid:\\n            i.sort(reverse=True)\\n            hp.append(i)\\n        print(hp)\\n        for i in range(len(hp[0])):\\n            ans = 0\\n            for j in range(len(hp)):\\n                ans = max(ans,hp[j][i])\\n            mx = mx + ans\\n        return mx\\n                          \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950850,
                "title": "o-n-2-solution-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in range(len(grid)):\\n            grid[row].sort()\\n        ans = 0\\n        for col in range(len(grid[0])):\\n            curr = 0\\n            for row in range(len(grid)):\\n                curr = max(curr, grid[row][col])\\n            ans += curr\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in range(len(grid)):\\n            grid[row].sort()\\n        ans = 0\\n        for col in range(len(grid[0])):\\n            curr = 0\\n            for row in range(len(grid)):\\n                curr = max(curr, grid[row][col])\\n            ans += curr\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949012,
                "title": "beats-100-ruby-easy-to-understand-2500-delete-greatest-value-in-each-row",
                "content": "# Code\\n```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef delete_greatest_value(grid)\\n    for i in (0...grid.length)\\n        grid[i].sort!\\n    end\\n    ans = 0\\n    for i in (0...grid[0].length)\\n        val = grid[0][i]\\n        for j in (1...grid.length)\\n            val = [val, grid[j][i]].max\\n        end\\n        ans += val\\n    end\\n    return ans\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# @param {Integer[][]} grid\\n# @return {Integer}\\ndef delete_greatest_value(grid)\\n    for i in (0...grid.length)\\n        grid[i].sort!\\n    end\\n    ans = 0\\n    for i in (0...grid[0].length)\\n        val = grid[0][i]\\n        for j in (1...grid.length)\\n            val = [val, grid[j][i]].max\\n        end\\n        ans += val\\n    end\\n    return ans\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3948407,
                "title": "2500-delete-greatest-value-in-each-row-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(max<grid[j][i])\\n                    max=grid[j][i];\\n            }\\n            sum+=max;\\n\\n        }\\n        return sum;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n        int sum=0;\\n        for(int i=0;i<grid[0].length;i++)\\n        {\\n            int max=0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                if(max<grid[j][i])\\n                    max=grid[j][i];\\n            }\\n            sum+=max;\\n\\n        }\\n        return sum;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948304,
                "title": "2500-delete-greatest-value-in-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        int ans=0;\\n        for (int i=0;i< grid[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n            for (int r=0;r<row;r++){\\n                int maxIndex=0;\\n                for (int c=0;c<col;c++){\\n                    if(grid[r][c]>grid[r][maxIndex]){\\n                        maxIndex=c;\\n                    }\\n                    if(max<grid[r][c]){\\n                        max=grid[r][c];\\n                    }\\n                }\\n\\n                for (int k=maxIndex;k<col-1;k++){\\n                    grid[r][k]=grid[r][k+1];\\n                }\\n            }\\n            ans= ans+max;\\n            col--;\\n        }\\n        return ans;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        int ans=0;\\n        for (int i=0;i< grid[0].length;i++)\\n        {\\n            int max=Integer.MIN_VALUE;\\n            for (int r=0;r<row;r++){\\n                int maxIndex=0;\\n                for (int c=0;c<col;c++){\\n                    if(grid[r][c]>grid[r][maxIndex]){\\n                        maxIndex=c;\\n                    }\\n                    if(max<grid[r][c]){\\n                        max=grid[r][c];\\n                    }\\n                }\\n\\n                for (int k=maxIndex;k<col-1;k++){\\n                    grid[r][k]=grid[r][k+1];\\n                }\\n            }\\n            ans= ans+max;\\n            col--;\\n        }\\n        return ans;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945191,
                "title": "java-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //max value from row \\n        int maxvalue=0;\\n        //to find all row and column value visited\\n        int zeroflag=0;\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            //to get exact location of max value so we can change with zero(0)\\n            int tempj=0;\\n            //to check if its currentmax value or not from given row\\n            int tempvalue=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]>tempvalue)\\n                {\\n                    tempvalue=grid[i][j];\\n                    tempj=j;\\n                    zeroflag=1;\\n                }\\n            } \\n            //to get max value from all row \\n            maxvalue=Math.max(maxvalue,grid[i][tempj]);\\n            //change visited location as 0\\n            grid[i][tempj]=0;\\n            \\n        }\\n        //if all location visited then return ans\\n        if(zeroflag==0)\\n        {\\n            return 0;\\n        }\\n        return maxvalue+deleteGreatestValue(grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //max value from row \\n        int maxvalue=0;\\n        //to find all row and column value visited\\n        int zeroflag=0;\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            //to get exact location of max value so we can change with zero(0)\\n            int tempj=0;\\n            //to check if its currentmax value or not from given row\\n            int tempvalue=0;\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]>tempvalue)\\n                {\\n                    tempvalue=grid[i][j];\\n                    tempj=j;\\n                    zeroflag=1;\\n                }\\n            } \\n            //to get max value from all row \\n            maxvalue=Math.max(maxvalue,grid[i][tempj]);\\n            //change visited location as 0\\n            grid[i][tempj]=0;\\n            \\n        }\\n        //if all location visited then return ans\\n        if(zeroflag==0)\\n        {\\n            return 0;\\n        }\\n        return maxvalue+deleteGreatestValue(grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939814,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end(),greater<int>());\\n\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ma=INT_MIN;\\n            for(int j=0;j<n;j++)\\n            {\\n                ma=max(ma,grid[j][i]);\\n            }\\n            c+=ma;\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        for(int i=0;i<n;i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end(),greater<int>());\\n\\n        }\\n        int c=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int ma=INT_MIN;\\n            for(int j=0;j<n;j++)\\n            {\\n                ma=max(ma,grid[j][i]);\\n            }\\n            c+=ma;\\n        }\\n        return c;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939330,
                "title": "2500-delete-greatest-value-in-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n          int cols=grid[0].length;\\n        int sum=0;\\n        for(int i = 0; i<grid[0].length;++i)\\n        {\\n            int max=Integer.MIN_VALUE;\\n            for(int r=0;r< grid.length;++r)\\n            {\\n                int max_index=0;\\n                for(int c=0;c<cols;++c)\\n                {\\n                    if(grid[r][c]>grid[r][max_index])\\n                    {\\n                        max_index=c;\\n                    }\\n                    if(max<grid[r][c])\\n                    {\\n                        max=grid[r][c];\\n                    }\\n                }\\n                for(int j=max_index;j<cols-1;++j)\\n                {\\n                    grid[r][j]=grid[r][j+1];\\n                }\\n            }\\n            sum+=max;\\n            cols--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n          int cols=grid[0].length;\\n        int sum=0;\\n        for(int i = 0; i<grid[0].length;++i)\\n        {\\n            int max=Integer.MIN_VALUE;\\n            for(int r=0;r< grid.length;++r)\\n            {\\n                int max_index=0;\\n                for(int c=0;c<cols;++c)\\n                {\\n                    if(grid[r][c]>grid[r][max_index])\\n                    {\\n                        max_index=c;\\n                    }\\n                    if(max<grid[r][c])\\n                    {\\n                        max=grid[r][c];\\n                    }\\n                }\\n                for(int j=max_index;j<cols-1;++j)\\n                {\\n                    grid[r][j]=grid[r][j+1];\\n                }\\n            }\\n            sum+=max;\\n            cols--;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933845,
                "title": "easy-solution-java-beats-99-37",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                if(max<grid[j][i])max=grid[j][i];\\n            }\\n            c+=max;\\n        }\\n        return c;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n        int c=0;\\n        for(int i=0;i<grid[0].length;i++){\\n            int max=Integer.MIN_VALUE;\\n            for(int j=0;j<grid.length;j++){\\n                if(max<grid[j][i])max=grid[j][i];\\n            }\\n            c+=max;\\n        }\\n        return c;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933278,
                "title": "best-java-solution-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] arr) {\\n        \\n        for(var a : arr){\\n            Arrays.sort(a);\\n        }\\n\\n        int ans = 0;\\n        for(int j = 0; j<arr[0].length; j++){\\n            int x = 0;\\n            for(int i=0; i<arr.length; i++){\\n                x = Math.max(x,arr[i][j]);\\n            }\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] arr) {\\n        \\n        for(var a : arr){\\n            Arrays.sort(a);\\n        }\\n\\n        int ans = 0;\\n        for(int j = 0; j<arr[0].length; j++){\\n            int x = 0;\\n            for(int i=0; i<arr.length; i++){\\n                x = Math.max(x,arr[i][j]);\\n            }\\n            ans+=x;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930528,
                "title": "sort-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:OA(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        \\n        for(int[] i: grid) {\\n           Arrays.sort(i);\\n        }\\n        \\n        int ans = 0;\\n      \\n           \\n            for(int j= grid[0].length-1;j>=0;j--) {\\n                 int max = Integer.MIN_VALUE;\\n                  for(int i=0;i<grid.length;i++) {\\n                      max = Math.max(max,grid[i][j]);\\n                  }\\n                   ans += max;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        \\n        for(int[] i: grid) {\\n           Arrays.sort(i);\\n        }\\n        \\n        int ans = 0;\\n      \\n           \\n            for(int j= grid[0].length-1;j>=0;j--) {\\n                 int max = Integer.MIN_VALUE;\\n                  for(int i=0;i<grid.length;i++) {\\n                      max = Math.max(max,grid[i][j]);\\n                  }\\n                   ans += max;\\n            }\\n            return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3921230,
                "title": "easy-to-understand-best-solution-in-c",
                "content": "\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector <priority_queue <int>> v1(m);\\n        for(int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                v1[i].push(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) { // total n times max number will be taken\\n            int res  = 0;\\n            for(int j = 0; j < m; j++) { // m is total number of priority queue\\n                res = max(res, v1[j].top());\\n                v1[j].pop();\\n            }\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector <priority_queue <int>> v1(m);\\n        for(int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                v1[i].push(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n\\n        for(int i = 0; i < n; i++) { // total n times max number will be taken\\n            int res  = 0;\\n            for(int j = 0; j < m; j++) { // m is total number of priority queue\\n                res = max(res, v1[j].top());\\n                v1[j].pop();\\n            }\\n            ans += res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917537,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        k = []\\n        while len(grid[0]) > 0:\\n            s = []\\n            for i in grid:\\n                mx = max(i)\\n                i.remove(mx)\\n                s.append(mx)\\n            k.append(max(s))\\n        return sum(k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        k = []\\n        while len(grid[0]) > 0:\\n            s = []\\n            for i in grid:\\n                mx = max(i)\\n                i.remove(mx)\\n                s.append(mx)\\n            k.append(max(s))\\n        return sum(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916102,
                "title": "c-easy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n            sort(grid[i].begin(),grid[i].end());\\n\\n            int ans =0;\\n            for(int i=0; i<grid[0].size();i++){\\n                int maxi = INT_MIN;\\n                for(int j=0;j<grid.size();j++)\\n                maxi=max(maxi,grid[j][i]);\\n                ans+=maxi;\\n            }\\n            return ans;\\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i=0;i<grid.size();i++)\\n            sort(grid[i].begin(),grid[i].end());\\n\\n            int ans =0;\\n            for(int i=0; i<grid[0].size();i++){\\n                int maxi = INT_MIN;\\n                for(int j=0;j<grid.size();j++)\\n                maxi=max(maxi,grid[j][i]);\\n                ans+=maxi;\\n            }\\n            return ans;\\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915957,
                "title": "easy-java-solution-beats-63",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort each array in the matrix\\nThen traverse row wise for each column and add max value to the sum\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int[] arr:grid){\\n            Arrays.sort(arr);\\n        }\\n        int j=grid[0].length-1;\\n        int sum=0;\\n        int max=Integer.MIN_VALUE;\\n        while(j>=0){\\n            for(int i=0;i<grid.length;i++){\\n            max=Math.max(max,grid[i][j]);\\n        }\\n        sum+=max;\\n        max=Integer.MIN_VALUE;\\n        j--;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int[] arr:grid){\\n            Arrays.sort(arr);\\n        }\\n        int j=grid[0].length-1;\\n        int sum=0;\\n        int max=Integer.MIN_VALUE;\\n        while(j>=0){\\n            for(int i=0;i<grid.length;i++){\\n            max=Math.max(max,grid[i][j]);\\n        }\\n        sum+=max;\\n        max=Integer.MIN_VALUE;\\n        j--;\\n        }\\n        return sum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909952,
                "title": "c-simple-and-efficient-95-35-41-58",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint deleteGreatestValue(std::vector<std::vector<int>>& grid)\\n    {\\n        std::size_t rows{grid.size()}, cols{grid[0].size()};\\n        // sort rows\\n        for (std::size_t r{0}; r<rows; r++) {\\n            std::sort(grid[r].begin(), grid[r].end());\\n        }\\n        int sum{0}, max;\\n        // compute sum\\n        for (std::size_t c{0}; c<cols; c++) {\\n            max = grid[0][c];\\n            for (std::size_t r{1}; r<rows; r++) {\\n                max = std::max(grid[r][c], max);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint deleteGreatestValue(std::vector<std::vector<int>>& grid)\\n    {\\n        std::size_t rows{grid.size()}, cols{grid[0].size()};\\n        // sort rows\\n        for (std::size_t r{0}; r<rows; r++) {\\n            std::sort(grid[r].begin(), grid[r].end());\\n        }\\n        int sum{0}, max;\\n        // compute sum\\n        for (std::size_t c{0}; c<cols; c++) {\\n            max = grid[0][c];\\n            for (std::size_t r{1}; r<rows; r++) {\\n                max = std::max(grid[r][c], max);\\n            }\\n            sum += max;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899990,
                "title": "with-basics-of-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        count=0\\n        k=[[] for _ in range(len(grid))]\\n        while grid:\\n            if grid==k:\\n                break\\n            m=[]\\n            for i in range(len(grid)):\\n                m.append(max(grid[i]))\\n                index=grid[i].index(max(grid[i]))\\n                l=grid[i][:index]+grid[i][index+1:]\\n                grid[i]=l\\n            count+=max(m)\\n        return count\\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        count=0\\n        k=[[] for _ in range(len(grid))]\\n        while grid:\\n            if grid==k:\\n                break\\n            m=[]\\n            for i in range(len(grid)):\\n                m.append(max(grid[i]))\\n                index=grid[i].index(max(grid[i]))\\n                l=grid[i][:index]+grid[i][index+1:]\\n                grid[i]=l\\n            count+=max(m)\\n        return count\\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3898033,
                "title": "brute-force-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis code iterates through the grid, row by row, finding the maximum element in each row, marking the corresponding cell as deleted, and accumulating the maximum values to the answer. The outer loop represents the reduction of columns, which continues until all columns are reduced to zero.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n\\n        int count = 0 ;\\n        int n = grid[0].size();\\n\\n        while(n!=0){\\n            int maxofall = 0;\\n\\n        for(int i = 0 ;i<grid.size();i++){\\n\\n           int maxi = grid[i][0];\\n           int colindex = 0;\\n\\n            for(int j = 1 ; j<grid[0].size();j++){\\n              \\n                if(grid[i][j] > maxi){\\n                   maxi = grid[i][j];\\n                   colindex = j;\\n                }    \\n            }\\n           \\n            grid[i][colindex] = -1;\\n            maxofall = max(maxi, maxofall);\\n\\n        }\\n\\n        count += maxofall;\\n        n--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n\\n        int count = 0 ;\\n        int n = grid[0].size();\\n\\n        while(n!=0){\\n            int maxofall = 0;\\n\\n        for(int i = 0 ;i<grid.size();i++){\\n\\n           int maxi = grid[i][0];\\n           int colindex = 0;\\n\\n            for(int j = 1 ; j<grid[0].size();j++){\\n              \\n                if(grid[i][j] > maxi){\\n                   maxi = grid[i][j];\\n                   colindex = j;\\n                }    \\n            }\\n           \\n            grid[i][colindex] = -1;\\n            maxofall = max(maxi, maxofall);\\n\\n        }\\n\\n        count += maxofall;\\n        n--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894027,
                "title": "brute-force-approach-sorting-98-beats-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=0;\\n        for( int i=0;i<grid.size();i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n        int maxi = -32765;\\n        for(int i=0;i<m;i++){\\n            maxi = max(maxi,grid[i][j]);\\n        }\\n        ans += maxi;\\n        }\\n    return ans;\\n    /*for(int j=n-1;j>=0;j--){\\n            int maxi=0;\\n            for(int i=m-1;i>=0;i--){\\n                maxi=max(maxi, grid[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;*/\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int ans=0;\\n        for( int i=0;i<grid.size();i++)\\n        {\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n        int maxi = -32765;\\n        for(int i=0;i<m;i++){\\n            maxi = max(maxi,grid[i][j]);\\n        }\\n        ans += maxi;\\n        }\\n    return ans;\\n    /*for(int j=n-1;j>=0;j--){\\n            int maxi=0;\\n            for(int i=m-1;i>=0;i--){\\n                maxi=max(maxi, grid[i][j]);\\n            }\\n            ans+=maxi;\\n        }\\n        return ans;*/\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893032,
                "title": "beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i = 0; i < grid.size(); i++){\\n            sort(grid[i].begin() , grid[i].end());\\n        }\\n\\n        int max = -1;\\n        int sum = 0;\\n        for(int i = grid[0].size()-1; i>=0; i--){\\n            for(int j = grid.size() - 1; j>=0; j--){\\n                if(grid[j][i] > max){\\n                    max = grid[j][i];\\n                }\\n            }\\n            sum+=max;\\n            max = -1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        for(int i = 0; i < grid.size(); i++){\\n            sort(grid[i].begin() , grid[i].end());\\n        }\\n\\n        int max = -1;\\n        int sum = 0;\\n        for(int i = grid[0].size()-1; i>=0; i--){\\n            for(int j = grid.size() - 1; j>=0; j--){\\n                if(grid[j][i] > max){\\n                    max = grid[j][i];\\n                }\\n            }\\n            sum+=max;\\n            max = -1;\\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887080,
                "title": "java-solution-easy-beginner-friendly-4ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n           // what if we can sort each row in a 2d matrix ; \\n        for (int[] ints : grid) {\\n            Arrays.sort(ints);\\n        }\\n        // now while the grid the is sorted the maximum lies at the last column.\\n        int ans = 0 ;\\n        for (int i = grid[0].length -1 ; i >= 0   ; i--) {\\n            int max = Integer.MIN_VALUE ;\\n            for (int j = 0; j < grid.length ; j++) {\\n                max = Math.max(max , grid[j][i]) ;\\n\\n            }\\n            ans+= max ;\\n\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n           // what if we can sort each row in a 2d matrix ; \\n        for (int[] ints : grid) {\\n            Arrays.sort(ints);\\n        }\\n        // now while the grid the is sorted the maximum lies at the last column.\\n        int ans = 0 ;\\n        for (int i = grid[0].length -1 ; i >= 0   ; i--) {\\n            int max = Integer.MIN_VALUE ;\\n            for (int j = 0; j < grid.length ; j++) {\\n                max = Math.max(max , grid[j][i]) ;\\n\\n            }\\n            ans+= max ;\\n\\n        }\\n        return ans ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885364,
                "title": "delete-max-value-in-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        num=0\\n        while len(grid[0])!=0:\\n            lst=[]\\n            for i in range(len(grid)):\\n                lst.append(grid[i].pop(grid[i].index(max(grid[i]))))\\n            num+=max(lst)\\n        return num\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Sorting",
                    "Heap (Priority Queue)",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        num=0\\n        while len(grid[0])!=0:\\n            lst=[]\\n            for i in range(len(grid)):\\n                lst.append(grid[i].pop(grid[i].index(max(grid[i]))))\\n            num+=max(lst)\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884646,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum = 0;\\n        int max = 0;\\n        \\n        for(int i = 0; i < grid.length; i++){\\n            Arrays.sort(grid[i]);\\n           \\n        }\\n\\n        for(int i = 0; i < grid[0].length; i++){\\n            max = grid[0][i];\\n            for(int j = 1; j < grid.length; j++){\\n              if(max < grid[j][i]){\\n                  max = grid[j][i];\\n              }\\n            }\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum = 0;\\n        int max = 0;\\n        \\n        for(int i = 0; i < grid.length; i++){\\n            Arrays.sort(grid[i]);\\n           \\n        }\\n\\n        for(int i = 0; i < grid[0].length; i++){\\n            max = grid[0][i];\\n            for(int j = 1; j < grid.length; j++){\\n              if(max < grid[j][i]){\\n                  max = grid[j][i];\\n              }\\n            }\\n            sum += max;\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881104,
                "title": "java-heaps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        List<Heap> heapList = new ArrayList<>();\\n        for (int[] ints : grid) {\\n            Heap heap = new Heap(ints.length);\\n            for (int anInt : ints) {\\n                heap.insert(anInt);\\n            }\\n            heapList.add(heap);\\n        }\\n        int sum = 0;\\n        while (true) {\\n            int sumOfOperation = deleteAndReturnMax(heapList);\\n            if(sumOfOperation==0) {\\n                break;\\n            }\\n            sum+=sumOfOperation;\\n        }\\n        return sum;\\n    }\\n\\n    private static int deleteAndReturnMax(List<Heap> list) {\\n        int max = 0;\\n        for (Heap heap : list) {\\n            if(heap.getSize()<=0) {\\n                break;\\n            }\\n            int removed = heap.remove();\\n            if(max<removed) {\\n                max = removed;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\npublic class Heap {\\n    \\n\\n    private int[] items;\\n    private int size;\\n\\n    public Heap(int size) {\\n        items = new int[size];\\n    }\\n\\n    public void insert(int value) {\\n        validateSizeSmallerThanItemLength();\\n        items[size++] = value;\\n        bubbleUp();\\n    }\\n\\n    public int remove() {\\n        validateSizeNotNull();\\n        int temp = items[0];\\n        items[0] = items[--size];\\n        items[size] = 0;\\n        int index = 0;\\n        while (hasLeftChild(index)) {\\n            int maxChildIndex = indexMaxChild(index);\\n            if (items[index] >= items[maxChildIndex]) {\\n                break; \\n            }\\n            swap(index, maxChildIndex);\\n            index = maxChildIndex;\\n        }\\n        return temp;\\n    }\\n\\n\\n    public void validateSizeNotNull() {\\n        if(size==0) {\\n            throw new IllegalStateException();\\n        }\\n    }\\n\\n    public int getSize() {\\n        return size;\\n    }\\n\\n    private int indexMaxChild(int index) {\\n        if(!hasLeftChild(index)) {\\n            return index;\\n        }\\n        if(!hasRightChild(index)) {\\n            return indexLeftChild(index);\\n        }\\n        return items[indexLeftChild(index)] > items[indexRightChild(index)] ?\\n                indexLeftChild(index) : indexRightChild(index);\\n    }\\n\\n    private boolean hasLeftChild(int index) {\\n        return size>indexLeftChild(index);\\n    }\\n\\n    private boolean hasRightChild(int index) {\\n        return size>indexLeftChild(index);\\n    }\\n\\n    private int indexLeftChild(int index) {\\n        return (index * 2) + 1;\\n    }\\n\\n    private int indexRightChild(int index) {\\n        return (index * 2) + 2;\\n    }\\n\\n    private void bubbleUp() {\\n        int index = size - 1;\\n        while (index>0 && items[index] > items[parent(index)]) {\\n            swap(index, parent(index));\\n            index = parent(index);\\n        }\\n    }\\n\\n    public void validateSizeSmallerThanItemLength() {\\n        if(size>=items.length) {\\n            throw new IllegalStateException();\\n        }\\n    }\\n\\n    private int parent(int index) {\\n        return (index-1)/2;\\n    }\\n    private void swap(int first, int second) {\\n        int temp = items[first];\\n        items[first] = items[second];\\n        items[second] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int deleteGreatestValue(int[][] grid) {\\n        List<Heap> heapList = new ArrayList<>();\\n        for (int[] ints : grid) {\\n            Heap heap = new Heap(ints.length);\\n            for (int anInt : ints) {\\n                heap.insert(anInt);\\n            }\\n            heapList.add(heap);\\n        }\\n        int sum = 0;\\n        while (true) {\\n            int sumOfOperation = deleteAndReturnMax(heapList);\\n            if(sumOfOperation==0) {\\n                break;\\n            }\\n            sum+=sumOfOperation;\\n        }\\n        return sum;\\n    }\\n\\n    private static int deleteAndReturnMax(List<Heap> list) {\\n        int max = 0;\\n        for (Heap heap : list) {\\n            if(heap.getSize()<=0) {\\n                break;\\n            }\\n            int removed = heap.remove();\\n            if(max<removed) {\\n                max = removed;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n\\npublic class Heap {\\n    \\n\\n    private int[] items;\\n    private int size;\\n\\n    public Heap(int size) {\\n        items = new int[size];\\n    }\\n\\n    public void insert(int value) {\\n        validateSizeSmallerThanItemLength();\\n        items[size++] = value;\\n        bubbleUp();\\n    }\\n\\n    public int remove() {\\n        validateSizeNotNull();\\n        int temp = items[0];\\n        items[0] = items[--size];\\n        items[size] = 0;\\n        int index = 0;\\n        while (hasLeftChild(index)) {\\n            int maxChildIndex = indexMaxChild(index);\\n            if (items[index] >= items[maxChildIndex]) {\\n                break; \\n            }\\n            swap(index, maxChildIndex);\\n            index = maxChildIndex;\\n        }\\n        return temp;\\n    }\\n\\n\\n    public void validateSizeNotNull() {\\n        if(size==0) {\\n            throw new IllegalStateException();\\n        }\\n    }\\n\\n    public int getSize() {\\n        return size;\\n    }\\n\\n    private int indexMaxChild(int index) {\\n        if(!hasLeftChild(index)) {\\n            return index;\\n        }\\n        if(!hasRightChild(index)) {\\n            return indexLeftChild(index);\\n        }\\n        return items[indexLeftChild(index)] > items[indexRightChild(index)] ?\\n                indexLeftChild(index) : indexRightChild(index);\\n    }\\n\\n    private boolean hasLeftChild(int index) {\\n        return size>indexLeftChild(index);\\n    }\\n\\n    private boolean hasRightChild(int index) {\\n        return size>indexLeftChild(index);\\n    }\\n\\n    private int indexLeftChild(int index) {\\n        return (index * 2) + 1;\\n    }\\n\\n    private int indexRightChild(int index) {\\n        return (index * 2) + 2;\\n    }\\n\\n    private void bubbleUp() {\\n        int index = size - 1;\\n        while (index>0 && items[index] > items[parent(index)]) {\\n            swap(index, parent(index));\\n            index = parent(index);\\n        }\\n    }\\n\\n    public void validateSizeSmallerThanItemLength() {\\n        if(size>=items.length) {\\n            throw new IllegalStateException();\\n        }\\n    }\\n\\n    private int parent(int index) {\\n        return (index-1)/2;\\n    }\\n    private void swap(int first, int second) {\\n        int temp = items[first];\\n        items[first] = items[second];\\n        items[second] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880630,
                "title": "python-sort-rows-sum-max-of-each-column",
                "content": "What we want is to go through each row, delete and get the maximum value in each row, and then get the overall maximum of all those maximum values.\\n\\nBut, there is no need to delete anything.\\n\\nSuppose, we have grid = [[1,2,4],[3,3,1]]\\n\\nIn first step, we delete value \"4\" from first row and value \"3\" from second row\\nAnd since 4 >= 3, we take \"4\" as the final value after this step\\n\\nThe grid is now [[1,2],[3,1]] \\n\\nIn second step, we delete value \"2\" from first row and value \"3\" from second row\\nAnd since 3 >= 2, we take \"3\" as the final value after this step\\n\\nThe grid is now [[1],[1]] \\n\\nIn second step, we delete value \"1\" from first row and value \"1\" from second row\\nAnd since 1 >= 1, we take \"1\" as the final value after this step\\n\\nAnd finally, we take the sum => 4 + 3 + 1 => 8\\n\\nSince we know that we want the greatest value in each row in each step, we can sort the rows before we even start to do all the steps.\\n\\nSo, grid after sorting rows will be [[4,2,1], [3,3,1]]\\n\\nNow, since the rows are now sorted, it means we don\\'t have to go through each row to search the maximum. We know that the first value in each row is the maximum at any time. \\n\\nIn other words, \\nIn first step, we compare the first value of each row and get the maximum out of those\\nIn second step, we compare the second value of each row and get the maximum out of those\\nand so on....\\n\\nAnd so, there is no need to manually delete anything.\\n\\n\\n```\\ndef deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        \\n        output = 0\\n        \\n        # Sort the rows in decreasing order\\n        for row in grid: row.sort(reverse = True)\\n            \\n        # Now that each row is sorted\\n        # Now, we just want the greatest value in each column\\n        # And add that to the output\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Go through each column\\n        for col in range(n):\\n            # Get the Maximum value in current column\\n            maxColValue = 1\\n            \\n            for row in range(m): maxColValue = max(maxColValue, grid[row][col])\\n            \\n            # Increment output by the maximum value of current column\\n            output += maxColValue\\n        \\n        # Finally, return the output\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\ndef deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        \\n        output = 0\\n        \\n        # Sort the rows in decreasing order\\n        for row in grid: row.sort(reverse = True)\\n            \\n        # Now that each row is sorted\\n        # Now, we just want the greatest value in each column\\n        # And add that to the output\\n        m = len(grid)\\n        n = len(grid[0])\\n        \\n        # Go through each column\\n        for col in range(n):\\n            # Get the Maximum value in current column\\n            maxColValue = 1\\n            \\n            for row in range(m): maxColValue = max(maxColValue, grid[row][col])\\n            \\n            # Increment output by the maximum value of current column\\n            output += maxColValue\\n        \\n        # Finally, return the output\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3880310,
                "title": "easy-peasy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        #grid = [sorted(nums) for nums in grid]\\n        for nums in grid:\\n            nums.sort()\\n        n = len(grid[0])\\n        m = len(grid)\\n        ans = 0\\n\\n        for col in range(n-1, -1, -1):\\n            max_val = -1\\n            for row in range(m):\\n                if grid[row][col] > max_val:\\n                    max_val = grid[row][col]\\n            ans += max_val\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        #grid = [sorted(nums) for nums in grid]\\n        for nums in grid:\\n            nums.sort()\\n        n = len(grid[0])\\n        m = len(grid)\\n        ans = 0\\n\\n        for col in range(n-1, -1, -1):\\n            max_val = -1\\n            for row in range(m):\\n                if grid[row][col] > max_val:\\n                    max_val = grid[row][col]\\n            ans += max_val\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875017,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] a) {\\n        ArrayList<ArrayList<Integer>> l=new ArrayList<ArrayList<Integer>>();\\n        int p=0;\\n        for(int i=0;i<a.length;i++){\\n            ArrayList<Integer> k = new ArrayList<Integer>();\\n            for(int j=0;j<a[0].length;j++)\\n               {\\n               k.add(a[i][j]);\\n                }\\n            Collections.sort(k);    \\n             l.add(k);\\n        }\\n        int s=0;\\n        for(int i=0;i<a[0].length;i++){\\n            int m=0;\\n            for(int j=0;j<a.length;j++)\\n               {\\n                   int g=l.get(j).get(i);\\n                  if(m<g){\\n                      m=g;\\n                  }\\n               }\\n               System.out.println(m);\\n             s+=m;  \\n        }\\n       System.out.print(l);\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] a) {\\n        ArrayList<ArrayList<Integer>> l=new ArrayList<ArrayList<Integer>>();\\n        int p=0;\\n        for(int i=0;i<a.length;i++){\\n            ArrayList<Integer> k = new ArrayList<Integer>();\\n            for(int j=0;j<a[0].length;j++)\\n               {\\n               k.add(a[i][j]);\\n                }\\n            Collections.sort(k);    \\n             l.add(k);\\n        }\\n        int s=0;\\n        for(int i=0;i<a[0].length;i++){\\n            int m=0;\\n            for(int j=0;j<a.length;j++)\\n               {\\n                   int g=l.get(j).get(i);\\n                  if(m<g){\\n                      m=g;\\n                  }\\n               }\\n               System.out.println(m);\\n             s+=m;  \\n        }\\n       System.out.print(l);\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861306,
                "title": "delete-greatest-value-in-each-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum1 = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int k=0;\\n        while(k<n)\\n        {\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 max = Math.max(max,grid[i][j]);\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[i][j]==max)\\n                 {grid[i][j] = 0;\\n                 break;}\\n            }\\n            if(sum<=max)\\n            sum = Math.max(sum,max);\\n        }\\n        sum1=sum1+sum;\\n        k++;\\n        }\\n        return sum1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int sum1 = 0;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int k=0;\\n        while(k<n)\\n        {\\n        int sum=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            int max = 0;\\n            for(int j=0;j<n;j++)\\n            {\\n                 max = Math.max(max,grid[i][j]);\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                 if(grid[i][j]==max)\\n                 {grid[i][j] = 0;\\n                 break;}\\n            }\\n            if(sum<=max)\\n            sum = Math.max(sum,max);\\n        }\\n        sum1=sum1+sum;\\n        k++;\\n        }\\n        return sum1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859725,
                "title": "brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n\\n        int sum = 0;\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        for(int i=grid[0].length-1;i>=0;i--)\\n        {\\n            int max = 0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                    if(grid[j][i] > max)\\n                    {\\n                        max = grid[j][i];\\n                    }\\n            }\\n\\n            sum = sum + max;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n\\n        int sum = 0;\\n\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n\\n        for(int i=grid[0].length-1;i>=0;i--)\\n        {\\n            int max = 0;\\n            for(int j=0;j<grid.length;j++)\\n            {\\n                    if(grid[j][i] > max)\\n                    {\\n                        max = grid[j][i];\\n                    }\\n            }\\n\\n            sum = sum + max;\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852726,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogm+n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int n=grid.length;\\n        for(int i=0;i<n;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans=0,m= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]>max){\\n                    max=grid[j][i];\\n                }\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int n=grid.length;\\n        for(int i=0;i<n;i++){\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans=0,m= grid[0].length;\\n        for(int i=0;i<m;i++){\\n            int max=0;\\n            for(int j=0;j<n;j++){\\n                if(grid[j][i]>max){\\n                    max=grid[j][i];\\n                }\\n            }\\n            ans+=max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851439,
                "title": "time-complexity-100-beats-python",
                "content": "# Complexity\\n- Time complexity: 100% beats \\n\\n# Intuition\\n![Untitled.png](https://assets.leetcode.com/users/images/c32953aa-e320-48c8-b560-dabecf17b676_1690955518.1658604.png)\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: list[list[int]]) -> int:\\n        sm = 0\\n        for i in grid:\\n            i.sort()\\n        for i in zip(*grid):\\n            sm += max(i)\\n        return sm\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: list[list[int]]) -> int:\\n        sm = 0\\n        for i in grid:\\n            i.sort()\\n        for i in zip(*grid):\\n            sm += max(i)\\n        return sm\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850961,
                "title": "list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        int arr[][]=new int[row][col];\\n        ArrayList<Integer> al=new ArrayList<>();\\n        ArrayList<Integer> store=new ArrayList<>();\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                al.add(grid[i][j]);\\n            }\\n            Collections.sort(al);\\n            for(int k=0;k<col;k++){\\n                arr[i][k]=al.get(k);\\n\\n            }\\n            al.clear();\\n\\n        }\\n        int sum=0;\\n        for(int i=col-1;i>=0;i--){\\n            for(int j=0;j<row;j++){\\n                store.add(arr[j][i]);\\n\\n            }\\n            Collections.sort(store);\\n            System.out.println(store);\\n            int remp=store.get(store.size()-1);\\n            sum=sum+remp;\\n            store.clear();\\n\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        int row=grid.length;\\n        int col=grid[0].length;\\n        int arr[][]=new int[row][col];\\n        ArrayList<Integer> al=new ArrayList<>();\\n        ArrayList<Integer> store=new ArrayList<>();\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                al.add(grid[i][j]);\\n            }\\n            Collections.sort(al);\\n            for(int k=0;k<col;k++){\\n                arr[i][k]=al.get(k);\\n\\n            }\\n            al.clear();\\n\\n        }\\n        int sum=0;\\n        for(int i=col-1;i>=0;i--){\\n            for(int j=0;j<row;j++){\\n                store.add(arr[j][i]);\\n\\n            }\\n            Collections.sort(store);\\n            System.out.println(store);\\n            int remp=store.get(store.size()-1);\\n            sum=sum+remp;\\n            store.clear();\\n\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846467,
                "title": "sort-zip-max-sum",
                "content": "# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid:\\n            row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\\n        for row in grid:\\n            row.sort()\\n        return sum(max(col) for col in zip(*grid))\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3846391,
                "title": "swift-two-liner",
                "content": "# Code\\n```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        let sortedRows = grid.map { $0.sorted() }\\n        return sortedRows[0].indices.reduce(0) { sum, column in sum + sortedRows.map { $0[column] }.max()! }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func deleteGreatestValue(_ grid: [[Int]]) -> Int {\\n        let sortedRows = grid.map { $0.sorted() }\\n        return sortedRows[0].indices.reduce(0) { sum, column in sum + sortedRows.map { $0[column] }.max()! }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839174,
                "title": "python-simple-approach",
                "content": "# Complexity\\n- Time complexity: 79ms\\nBeats 89.94% of users with Python\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 13.34mb\\nBeats 62.26% of users with Python\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def deleteGreatestValue(self, grid):\\n        len_of_array = len(grid[0])\\n        answer = 0\\n\\n        for _ in range(len_of_array):\\n            items = []\\n\\n            for array in grid:\\n                max_item = max(array)\\n                items.append(max_item)\\n                array.remove(max_item)\\n\\n            answer += max(items)\\n\\n        return answer\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def deleteGreatestValue(self, grid):\\n        len_of_array = len(grid[0])\\n        answer = 0\\n\\n        for _ in range(len_of_array):\\n            items = []\\n\\n            for array in grid:\\n                max_item = max(array)\\n                items.append(max_item)\\n                array.remove(max_item)\\n\\n            answer += max(items)\\n\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835095,
                "title": "easy-java-solution-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans=0;\\n        for(int i=grid[0].length-1; i>=0; i--)\\n        {\\n            int max=0;\\n            for(int j=0; j<grid.length; j++)\\n            {\\n                max=Integer.max(max,grid[j][i]);\\n                \\n            }\\n            ans=ans+max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        for(int i=0; i<grid.length; i++)\\n        {\\n            Arrays.sort(grid[i]);\\n        }\\n        int ans=0;\\n        for(int i=grid[0].length-1; i>=0; i--)\\n        {\\n            int max=0;\\n            for(int j=0; j<grid.length; j++)\\n            {\\n                max=Integer.max(max,grid[j][i]);\\n                \\n            }\\n            ans=ans+max;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1713332,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1714927,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1714596,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1749769,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1808253,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1948063,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1805466,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1738221,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1722569,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1716902,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1713332,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1714927,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1714596,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1749769,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1808253,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1948063,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1805466,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1738221,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1722569,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            },
            {
                "id": 1716902,
                "content": [
                    {
                        "username": "ChiragSDogra",
                        "content": "Do you really think this was an easy question???"
                    },
                    {
                        "username": "geekyshark",
                        "content": "bruh common its very basic qn"
                    },
                    {
                        "username": "binarycoderz04",
                        "content": "yes you're right , it should be tagged as basic level question\n"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "[@Shiyinq](/Shiyinq) brutal lol"
                    },
                    {
                        "username": "ChiragSDogra",
                        "content": "[@Shiyinq](/Shiyinq)  I was not able to come up with the approach so I think it should be a medium one"
                    },
                    {
                        "username": "Shiyinq",
                        "content": "do you think this is medium or very easy?"
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "Approach is brute force but took me about 15 minutes:\njust sort the 2D array row wise\nadd element to answer by taking maximum in column wise\nand its done!"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "[@rtanishka](/rtanishka)  grid[i][j] not grid[j][i],,, it will works"
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@rtanishka](/rtanishka)  man why are you checking every element, after sorting just check the last element in each row lol"
                    },
                    {
                        "username": "rtanishka",
                        "content": "That\\'s what I did.. But I\\'m getting runtime error.\\nclass Solution {\\npublic:\\n    int deleteGreatestValue(vector<vector<int>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        \\n        int ans =0;\\n        for(int i=0;i<grid.size();i++){\\n            sort(grid[i].begin(),grid[i].end());\\n        }\\n        for(int j=0;j<n;j++){\\n            int maxi = 0;\\n            for(int i=0;m;i++){\\n                maxi = max(maxi,grid[j][i]);\\n            }\\n            ans += maxi;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "eduard92",
                        "content": "Appreciate the tip. I wasn\\'t thinking about sorting but then as I looked at the rows it made a lot of sense."
                    },
                    {
                        "username": "adisinghal1506",
                        "content": "[@ATHBuys](/ATHBuys) will let you know if i could come up:)"
                    },
                    {
                        "username": "ATHBuys",
                        "content": "brute force is simple but is there another way?"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Spent like ~20 mins to find a \\'clever\\' way to solve the problem during the contest but end up doing brute force, LOL"
                    },
                    {
                        "username": "kd_5304",
                        "content": "Please be honest. Was this an easy question? Like really??"
                    },
                    {
                        "username": "rooopkishore1918",
                        "content": "Can we Do it without sorting?"
                    },
                    {
                        "username": "NeerajKumar23",
                        "content": "[@niranjank2022](/niranjank2022)  Yeah, I used priority queue but it is taking more time then brute force(sort each row and select max column wise) "
                    },
                    {
                        "username": "niranjank2022",
                        "content": "How about, Priority Queue?"
                    },
                    {
                        "username": "manojkr6637",
                        "content": "Yes, But little bit complicated using brute force, First take max each row and store in maxvaluearr[] then find max value from maxvaluearr[] then sum it again again, Taken max value store their -1 then check without -1 till last all row value found -1."
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "Idea :\n.\n.\n.\n.\n.\n.\n.\n.\n\nSort each row and add the max in each col to result and return result"
                    },
                    {
                        "username": "nikhilgp07",
                        "content": "class Solution {\\n    public int deleteGreatestValue(int[][] grid) {\\n        //array sorted\\n        for(int k =0; k< grid.length; k++) {\\n            for (int i = 0; i < grid[k].length; i++) {\\n                int j = i;\\n                while (j > 0 && grid[k][j - 1] > grid[k][j]) {\\n                    int temp = grid[k][j - 1];\\n                    grid[k][j - 1] = grid[k][j];\\n                    grid[k][j] = temp;\\n                    j--;\\n                }\\n            }\\n        }\\n           int ans = 0;\\n        for(int p = 0; p<grid[0].length; p++){\\n            int max1 = 0;\\n        for(int r = grid[0].length-p-1; r <= grid[0].length-p-1; r++){\\n                for(int a = 0; a < grid.length; a++){\\n                    if(max1 < grid[a][r]){\\n                        max1 = grid[a][r];\\n                    }\\n                }\\n                ans += max1;\\n                break;\\n            }\\n        }\\n        return ans;\\n}\\n}"
                    },
                    {
                        "username": "devcode961",
                        "content": "Hi guys, could you please have a look at my solution here and provide any improvements/suggestions  :  \\nhttps://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2986377/simple-java-solution-beats-99-25-without-using-nested-loop/"
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "where is total number of test cases.\\nwhere can i find it in new version of the leetcode as the previous version would let us to see how my test cases for the particular problem."
                    },
                    {
                        "username": "balaji_r_v",
                        "content": "[@Keyuan_Huang](/Keyuan_Huang) i couldn\\'t find revert to old version!"
                    },
                    {
                        "username": "Keyuan_Huang",
                        "content": "Click your profile picture at the top right corner, in the drop-down menu there is an option \"revert to old version\"."
                    },
                    {
                        "username": "ATHBuys",
                        "content": "even the top solutions are kinda brute force style? mine uses the same strategy as the top solutions but i thought it was gonna get TLE before i submitted? https://leetcode.com/problems/delete-greatest-value-in-each-row/solutions/2913484/beats-92-with-nested-loops-there-must-be-another-way/"
                    }
                ]
            }
        ]
    }
]