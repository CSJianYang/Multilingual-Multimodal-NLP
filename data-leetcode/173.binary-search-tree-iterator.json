[
    {
        "title": "Set Matrix Zeroes",
        "question_content": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0's.\nYou must do it in place.\n&nbsp;\nExample 1:\n\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[1,0,1],[0,0,0],[1,0,1]]\n\nExample 2:\n\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]\nOutput: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]\n\n&nbsp;\nConstraints:\n\n\tm == matrix.length\n\tn == matrix[0].length\n\t1 <= m, n <= 200\n\t-231 <= matrix[i][j] <= 231 - 1\n\n&nbsp;\nFollow up:\n\n\tA straightforward solution using O(mn) space is probably a bad idea.\n\tA simple improvement uses O(m + n) space, but still not the best solution.\n\tCould you devise a constant space solution?",
        "solutions": [
            {
                "id": 26014,
                "title": "any-shorter-o-1-space-solution",
                "content": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "My idea is simple: store states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"col0\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n    void setZeroes(vector<vector<int> > &matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n    \\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) col0 = 0;\\n            for (int j = 1; j < cols; j++)\\n                if (matrix[i][j] == 0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n    \\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26008,
                "title": "my-ac-java-o-1-solution-easy-to-read",
                "content": "    public class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < matrix.length; i++) {\\n            for(int j = 1; j < matrix[0].length; j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(fr) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        if(fc) {\\n            for(int i = 0; i < matrix.length; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean fr = false,fc = false;\\n        for(int i = 0; i < matrix.length; i++) {\\n            for(int j = 0; j < matrix[0].length; j++) {\\n                if(matrix[i][j] == 0) {\\n                    if(i == 0) fr = true;\\n                    if(j == 0) fc = true;\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3172908,
                "title": "best-c-4-solution-hash-table-matrix-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Four approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Matrix with Extra space.  TC : O((N*M)*(N+M)),  SC : O(N*M).\\n2. Solved using Matrix with Constant space.  TC : O((N*M)*(N+M)),  SC : O(1).\\n3. Solved using Array + Hash Table (Unordered set).  TC : O(N*M),  SC : O(N+M).\\n4. Solved using Matrix with Constant space.  Optimized Approaches.  TC : O(N*M),  SC : O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M) for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(N*M), visited matrix space.\\n\\n    Solved using Matrix with Extra space.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        vector<vector<int>> visited = matrix;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        visited[i][k] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        visited[k][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                matrix[i][j] = visited[i][j];\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O((N*M)*(N+M)), Where N is the number of row and M is number of column of matrix. Here\\n    nested loops creates the time complexity. O(N*M) for traversing through each element and (N+M)for traversing\\n    to row and column of elements having value 0.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<m; k++){\\n                        if(matrix[i][k] != 0){\\n                            matrix[i][k] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    for(int k=0; k<n; k++){\\n                        if(matrix[k][j] != 0){\\n                            matrix[k][j] = -9999;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == -9999){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(N+M), Here Unordered set(setRows and setColumn) creates the space complexity. O(N) for\\n    storing the row indexs and O(M) for storing the column indexs.\\n\\n    Solved using Matrix + Hash Table.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        unordered_set<int> setRows; \\n        unordered_set<int> setColumns; \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    setRows.insert(i);\\n                    setColumns.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(setRows.count(i) > 0 || setColumns.count(j) > 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), Where N is the number of row and M is number of column of matrix. Here two nested \\n    loops creates the time complexity.\\n\\n    Space Complexity : O(1), Constant space.\\n\\n    Solved using Matrix.\\n\\n*/\\n\\n\\n/***************************************** Approach 4 Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        bool flag1 = false, flag2 = false;\\n        for(int i=0; i<n; i++){\\n            if(matrix[i][0] == 0){\\n                flag1 = true;\\n            }\\n        }\\n        for(int j=0; j<m; j++){\\n            if(matrix[0][j] == 0){\\n                flag2 = true;\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(flag1 == true){\\n            for(int i=0; i<n; i++){\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        if(flag2 == true){\\n            for(int j=0; j<m; j++){\\n                matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525398,
                "title": "all-approaches-from-brute-force-to-optimal-with-easy-explanation",
                "content": "**Method 1:** (Brute force)\\n-using another matrix (let\\'s say it matrix2)\\n1. we can copy all the elements of given matrix to matrix2\\n2. while traversing given matrix whenever we encounter 0, we will make the entire row and column of the matrix2 to 0\\n3. finally we can again copy all the elements of matrix2 to given matrix\\n-**Time:** $$O((mn)*(m+n))$$, **Space:** $$O(mn)$$\\n\\n![image](https://assets.leetcode.com/users/images/edb17693-61dd-424b-88e7-f37b79c602f1_1662224098.764936.png)\\n\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\\n\\n\\n**Method 2:** (Better)\\n1. we can use two separate arrays one for rows (rowsArray) and one for columns (colsArray) and initialize them to 1\\n2. while traversing the given matrix whenever we encounter 0 at (i,j), we will set rowsArray[i]=0 and colsArray[j]=0\\n3. After completion of step 2, again iterate through the matrix and for any (i,j), if rowsArray[i] or colsArray[j] is 0 then update matrix[i][j] to 0.\\n-**Time:** $$O(mn)$$, **Space:** $$O(m+n)$$\\n\\n![image](https://assets.leetcode.com/users/images/985c05ee-ba5b-43ec-a7c2-41983d8bdae1_1662224319.5420349.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\\n\\n**Method 3:** (Optimal)\\n-we can use the 0th row and 0th column of the given matrix itself instead of using two separate arrays\\n1. first we will traverse the 0th row and 0th column of the given matrix and if we encounter any 0 then we will set the isRow0/isCol0 variable to true which indicates that the 0th row/0th column of the given matrix will become 0\\n2. next we will traverse the remaining matrix except 0th row and 0th column and if we encounter any 0, we will make the corresponding row no. and column no. equal to 0 in the 0th column and 0th row respectively\\n3. Now we will update the values of the matrix except first row and first column to 0 if matrix[i][0]=0 or matrix[0][j]=0 for any (i,j).\\n4. finally we will traverse the 0th row and 0th column and if we find any 0, we will make the whole row and whole column equal to 0\\n-**Time:** $$O(mn)$$, **Space:** $$O(1)$$\\n\\n![image](https://assets.leetcode.com/users/images/75193089-d14a-4cf9-aacf-5f97cc935f02_1662224420.9994516.png)\\n\\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```\\n\\nDon\\'t forget to upvote if you find it helpful! \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m= matrix.length, n= matrix[0].length;\\n        int matrix2[][]= new int[m][n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix2[i][j]=matrix[i][j];\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    for(int k=0;k<n;k++)\\n                        matrix2[i][k]=0;\\n\\n                    for(int k=0;k<m;k++)\\n                        matrix2[k][j]=0;\\n                }\\n            }\\n        }\\n    \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++)\\n                matrix[i][j]=matrix2[i][j];\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        int rowsArray[]= new int[m];\\n        int colsArray[]= new int[n];\\n        \\n        Arrays.fill(rowsArray,1);\\n        Arrays.fill(colsArray,1);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    rowsArray[i]=0;\\n                    colsArray[j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(rowsArray[i]==0 || colsArray[j]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n    }\\n```\n```\\npublic void setZeroes(int[][] matrix){\\n\\n\\t\\tint m=matrix.length, n=matrix[0].length;\\n        boolean isRow0=false, isCol0=false;\\n        \\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0)\\n                isRow0=true;\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0)\\n                isCol0=true;\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[0][j]==0 || matrix[i][0]==0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n        if(isRow0){\\n            for(int j=0;j<n;j++)\\n                matrix[0][j]=0;\\n        }\\n        \\n        if(isCol0){\\n            for(int i=0;i<m;i++)\\n                matrix[i][0]=0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472518,
                "title": "full-explanation-super-easy-constant-space",
                "content": "# Intuition\\nIn this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the row array. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the col array\\n\\n![image.png](https://assets.leetcode.com/users/images/5e4c94b5-ea1e-4ca5-a166-9a014d49e001_1682924194.5173662.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe steps are as follows:\\n\\nFirst, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n\\nAfter step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n\\nWe will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.\\n\\nFinally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\n\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0. Note that the above approach is provided by Striver on youtube.\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/e3a4d44d-7ade-4acb-8e2e-6cdc257505f3_1682924171.8253722.png)\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/43fc6382-7684-43ad-91e9-cea1908663b6_1682924250.7315671.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\npublic void setZeroes(int[][] matrix) {\\n    boolean fr = false,fc = false;\\n    for(int i = 0; i < matrix.length; i++) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            if(matrix[i][j] == 0) {\\n                if(i == 0) fr = true;\\n                if(j == 0) fc = true;\\n                matrix[0][j] = 0;\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n    for(int i = 1; i < matrix.length; i++) {\\n        for(int j = 1; j < matrix[0].length; j++) {\\n            if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                matrix[i][j] = 0;\\n        }}\\n    }\\n    if(fr) {\\n        for(int j = 0; j < matrix[0].length; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if(fc) {\\n        for(int i = 0; i < matrix.length; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n}}  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657430,
                "title": "python-solution-w-approach-explanation-readable-with-space-progression-from-o-m-n-o-1",
                "content": "Note: m = number of rows, n = number of cols\\n\\n**Brute force using O(m*n) space:** The initial approach is to start with creating another matrix to store the result. From doing that, you\\'ll notice that we want a way to know when each row and col should be changed to zero. We don\\'t want to prematurely change the values in the matrix to zero because as we go through it, we might change a row to 0 because of the new value. \\n\\n**More optimized using O(m + n) space:** To do better, we want O(m + n). How do we go about that? Well, we really just need a way to track if any row or any col has a zero, because then that means the entire row or col has to be zero. Ok, well, then we can use an array to track the zeroes for the row and zeros for the col. Whenever we see a zero, just set that row or col to be True.\\n\\nSpace: O(m + n) for the zeroes_row and zeroes_col array \\n``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\\n\\n**Most optimized using O(1) space:** But, we can do even better, O(1) - initial ask of the problem. What if instead of having a separate array to track the zeroes, we simply use the first row or col to track them and then go back to update the first row and col with zeroes after we\\'re done replacing it? The approach to get constant space is to use first row and first col of the matrix as a tracker. \\n* At each row or col, if you see a zero, then mark the first row or first col as zero with the current row and col. \\n* Then iterate through the array again to see where the first row and col were marked as zero and then set that row/col as 0. \\n* After doing that, you\\'ll need to traverse through the first row and/or first col if there were any zeroes there to begin with and set everything to be equal to 0 in the first row and/or first col. \\n\\nTime complexity for all three progression is O(m * n).\\n\\n\\n\\n**Space:** O(1) for modification in place and using the first row and first col to keep track of zeros instead of zeroes_row and zeroes_col\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` Python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        # input validation\\n        if not matrix:\\n            return []\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n         zeroes_row = [False] * m\\n         zeroes_col = [False] * n\\n         for row in range(m):\\n             for col in range(n):\\n                 if matrix[row][col] == 0:\\n                     zeroes_row[row] = True\\n                     zeroes_col[col] = True\\n\\n         for row in range(m):\\n             for col in range(n):\\n                 if zeroes_row[row] or zeroes_col[col]:\\n                     matrix[row][col] = 0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\t\\t\\n        first_row_has_zero = False\\n        first_col_has_zero = False\\n        \\n        # iterate through matrix to mark the zero row and cols\\n        for row in range(m):\\n            for col in range(n):\\n                if matrix[row][col] == 0:\\n                    if row == 0:\\n                        first_row_has_zero = True\\n                    if col == 0:\\n                        first_col_has_zero = True\\n                    matrix[row][0] = matrix[0][col] = 0\\n    \\n        # iterate through matrix to update the cell to be zero if it\\'s in a zero row or col\\n        for row in range(1, m):\\n            for col in range(1, n):\\n                matrix[row][col] = 0 if matrix[0][col] == 0 or matrix[row][0] == 0 else matrix[row][col]\\n        \\n        # update the first row and col if they\\'re zero\\n        if first_row_has_zero:\\n            for col in range(n):\\n                matrix[0][col] = 0\\n        \\n        if first_col_has_zero:\\n            for row in range(m):\\n                matrix[row][0] = 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 26113,
                "title": "21-lines-concise-and-easy-understand-c-solution-o-1-space-three-steps",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }\\n                }\\n            }\\n            for(int i = 1; i < matrix.size(); i++){\\n                for(int j = 1; j < matrix[0].size(); j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0) matrix[i][j] = 0;\\n                }\\n            }\\n            if(col){\\n                for(int i = 0; i < matrix.size(); i++) matrix[i][0] = 0;\\n            }\\n            if(row){\\n                for(int j = 0; j < matrix[0].size(); j++) matrix[0][j] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            bool row = false, col = false;\\n            for(int i = 0; i < matrix.size(); i++){\\n                for(int j = 0; j < matrix[0].size(); j++){\\n                    if(matrix[i][j] == 0) {\\n                        if(i == 0) row = true;\\n                        if(j == 0) col = true;\\n                        matrix[0][j] = matrix[i][0] = 0;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1400849,
                "title": "set-matrix-zeroes-2-approach-w-explanation-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276330,
                "title": "c-simple-99-faster-o-1-space-upvote",
                "content": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        bool firstRow = false;  // do we need to set first row zero\\n        bool firstCol = false;  // do we need to ser first col zero\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n\\t\\t\\t\\t\\tif(a[i][j] == 0){   // store rows and cols state in first row and col\\n                    if(i==0) firstRow = true;\\n                    if(j==0) firstCol = true;\\n                    a[i][0] = 0;\\n                    a[0][j] = 0;\\n                }\\n            }\\n        }\\n        // cout<<firstRow<<\" \"<<firstCol<<endl;\\n        for(int i=1; i<n; i++){\\n            for(int j=1; j<m; j++){\\n                if(a[i][0] == 0 || a[0][j] == 0){\\n                    a[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(firstRow){\\n            for(int i=0;i<m;i++) a[0][i] = 0;\\n        }\\n        \\n        if(firstCol){\\n            for(int i=0;i<n;i++) a[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 717535,
                "title": "cpp-c-99-23-google-amazon",
                "content": "Approach-First of all create two vectors rowmarker and columnmarker to store the positions of column and row where the element is zero. \\nIf element in either row marker or columnmarker is 0.Then make the element in the whole matrix 0. \\n```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```\\n\\t Please Upvote if you like my solution.Jai Hind.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n void setZeroes(vector<vector<int>>& matrix) {     \\n        int rowsize=matrix.size(); \\n        int columnsize=matrix[0].size(); \\n        vector<int>rowmarker(rowsize,1);\\n        vector<int>columnmarker(columnsize,1); \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    rowmarker[i]=0; \\n                    columnmarker[j]=0;\\n                }\\n            }\\n        } \\n        for(int i=0;i<rowsize;i++)\\n        {\\n            for(int j=0;j<columnsize;j++)\\n            {\\n                if(rowmarker[i]==0 or columnmarker[j]==0)\\n                    matrix[i][j]=0;\\n             }\\n        }\\n        \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 26038,
                "title": "my-c-o-1-yoooooo",
                "content": "I find the last row which has 0, and use it to store the 0-collumns.\\nThen go row by row set them to 0.\\nThen go column by column set them to 0.\\nFinally set the last row which has 0. It's long but hey it's O(1) \\n\\n\\n    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }\\n            if (last_0_row == -1)\\n                return;\\n            \\n            // go row by row\\n            for (int y = 0; y < last_0_row; y++)\\n            {\\n                bool this_is_a_0_row = false;\\n                \\n                for (int x = 0; x < W; x++)\\n                {\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        this_is_a_0_row = true;\\n                        matrix[last_0_row][x] = 0;\\n                    }\\n                }\\n                \\n                if (this_is_a_0_row)\\n                for (int x = 0; x < W; x++)\\n                {\\n                    matrix[y][x] = 0;\\n                }\\n            }\\n            \\n            // set collums to 0\\n            for (int y = 0; y < H; y++)\\n            for (int x = 0; x < W; x++)\\n            {\\n                if (matrix[last_0_row][x] == 0)\\n                    matrix[y][x] = 0;\\n            }\\n            \\n            // set the last 0 row \\n            for (int x = 0; x < W; x++)\\n            {\\n                matrix[last_0_row][x] = 0;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int> > &matrix) {\\n            \\n            int H = matrix.size();\\n            int W = matrix[0].size();\\n            \\n            // find the last 0 row\\n            int last_0_row = -1;\\n            for (int y = H - 1; y >= 0 && last_0_row == -1; y--)\\n                for (int x = 0; x < W; x++)\\n                    if (matrix[y][x] == 0)\\n                    {\\n                        last_0_row = y;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26026,
                "title": "o-1-space-solution-in-python",
                "content": "    class Solution:\\n    # @param {integer[][]} matrix\\n    # @return {void} Do not return anything, modify matrix in-place instead.\\n    def setZeroes(self, matrix):\\n        m = len(matrix)\\n        if m == 0:\\n            return\\n        n = len(matrix[0])\\n        \\n        row_zero = False\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                row_zero = True\\n        col_zero = False\\n        for j in range(n):\\n            if matrix[0][j] == 0:\\n                col_zero = True\\n                \\n        for i in range(1, m):\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = 0\\n                    matrix[0][j] = 0\\n        \\n        for i in range(1, m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n                    \\n        for j in range(1, n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        if col_zero:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n        if row_zero:\\n            for i in range(m):\\n                matrix[i][0] = 0",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {integer[][]}",
                "codeTag": "Java"
            },
            {
                "id": 1400861,
                "title": "python-o-mn-o-1-time-space-solution-explained",
                "content": "The idea is to use first row and first column as indicator, if we need to set the whole corresponding column or row to zeros. We also keep `r1 and `c1` variables: do we need to update first column and/or first row in the end. So, we have the following steps:\\n\\n1. Create `r1` and `c1`.\\n2. Iterate through our matrix and if we see that for if element `M[i][j]` is equal to `0`, we put both elements `M[i][0]` and `M[0][j]` to `0`.\\n3. Now, we updated all elements in first row and column, so we iterate our matrix once again: and if we see that one of elements `M[i][0]` or `M[0][j]` equal to `0`, we make `M[i][j] equal to `0`.\\n4. Finally, we need to update first row and column, so we make them `0`, if we have indicator `r1` for row and `c1` for column.\\n\\n#### Complexity\\nTime complexity is `O(mn)`, space is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```\\n\\t\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, M):\\n        m, n = len(M[0]), len(M)\\n        r1 = any(M[0][j] == 0 for j in range(m))\\n        c1 = any(M[i][0] == 0 for i in range(n))\\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][j] == 0: M[i][0] = M[0][j] = 0\\n                \\n        for i in range(1, n):\\n            for j in range(1, m):\\n                if M[i][0] * M[0][j] == 0: M[i][j] = 0\\n                \\n        if r1:\\n            for i in range(m): M[0][i] = 0\\n                \\n        if c1:\\n            for j in range(n): M[j][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469077,
                "title": "python-from-o-m-n-space-to-o-1-space-with-picture-clean-concise",
                "content": "**Solution 1: Additional Memory Space**\\n- Let `zeroRow[r] = True` denote all the cells in row `r` must have value 0.\\n- Let `zeroCol[c] = True` denote all the cells in column `c` must have value 0.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(M + N)`\\n\\n---\\n**Solution 2: In-space Solution**\\n- We re-use the first row as the meaning of `zeroCol`. It means `matrix[r][0] = 0` is the same meaning with `zeroRow[r] = True`. \\n- We re-use the first column as the meaning of `zeroRow`. It means `matrix[0][c] = 0` is the same meaning with `zeroCol[c] = True`.\\n- While processing to set `matrix[r][0] = 0` or `matrix[0][c] = 0`, we iterate cells with `r` in `[1...m-1]`, `c` in `[1..n-1]`. \\n\\t- We skip cells in the first row `r = 0` and cells in the first column `c = 0`. \\n\\t- Otherwise, we will get WRONG ANSWER, can check following example:\\n\\t![image](https://assets.leetcode.com/users/images/dc1a5e2f-615e-409c-bdb5-a153fe66c955_1631898869.821589.png)\\n- Before, we need to use 2 additional flag:\\n\\t- `zeroFirstRow`: To check if all elements in the first row should be set into zero\\n\\t- `zeroFirstCol`: To check if all elements in the first column should be set into zero.\\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```\\nComplexity:\\n- Time: `O(M * N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns.\\n- Space: `O(1)`\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        zeroRow = [False] * m\\n        zeroCol = [False] * n\\n        for r in range(m):\\n            for c in range(n):\\n                if matrix[r][c] == 0:\\n                    zeroRow[r] = zeroCol[c] = True\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if zeroRow[r] or zeroCol[c]:\\n                    matrix[r][c] = 0\\n```\n```python\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m, n = len(matrix), len(matrix[0])\\n        \\n        zeroFirstRow = any(matrix[0][c] == 0 for c in range(n))\\n        zeroFirstCol = any(matrix[r][0] == 0 for r in range(m))\\n        \\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][c] == 0: matrix[0][c] = matrix[r][0] = 0\\n\\n        for r in range(1, m):\\n            for c in range(1, n):\\n                if matrix[r][0] == 0 or matrix[0][c] == 0: matrix[r][c] = 0\\n                    \\n        if zeroFirstRow:\\n            for c in range(n): matrix[0][c] = 0\\n        \\n        if zeroFirstCol:\\n            for r in range(m): matrix[r][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26115,
                "title": "java-python-o-1-space-11-lines-solution",
                "content": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "**Java**\\n\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length, n = matrix[0].length, k = 0;\\n        // First row has zero?\\n        while (k < n && matrix[0][k] != 0) ++k;\\n        // Use first row/column as marker, scan the matrix\\n        for (int i = 1; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                if (matrix[i][j] == 0)\\n                    matrix[0][j] = matrix[i][0] = 0;\\n        // Set the zeros\\n        for (int i = 1; i < m; ++i)\\n            for (int j = n - 1; j >= 0; --j)\\n                if (matrix[0][j] == 0 || matrix[i][0] == 0)\\n                    matrix[i][j] = 0;\\n        // Set the zeros for the first row\\n        if (k < n) Arrays.fill(matrix[0], 0);\\n    }\\n\\n**Python**\\n\\n    def setZeroes(self, matrix):\\n        # First row has zero?\\n        m, n, firstRowHasZero = len(matrix), len(matrix[0]), not all(matrix[0])\\n        # Use first row/column as marker, scan the matrix\\n        for i in xrange(1, m):\\n            for j in xrange(n):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = matrix[i][0] = 0\\n        # Set the zeros\\n        for i in xrange(1, m):\\n            for j in xrange(n - 1, -1, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n        # Set the zeros for the first row\\n        if firstRowHasZero:\\n            matrix[0] = [0] * n",
                "codeTag": "Python3"
            },
            {
                "id": 26037,
                "title": "o-1-java-straightforward-idea",
                "content": "Use the first column and the first row as marker:\\n1. first scan through the whole matrix, and if one row i has zero, label matrix[i][0] = 0, if column j has zero, then label matrix[0][j] = 0.\\nif we find the first row has zero, then mark a boolean row = true, if the first column has zeros, mark a boolean col = true;\\n\\n2. By the markers on the first row and first col, set the other columns and rows to zeros. (first row and first column already contain zeros)\\n\\n3. According to booleans row and col, decide whether to set first row and column to zeros.\\n\\n        public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }\\n                }\\n            for (int i = 1; i < m; i++){\\n                if (matrix[i][0] == 0){\\n                    for (int j = 1; j < n;j++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            for (int j = 1; j < n; j++){\\n                if (matrix[0][j] == 0){\\n                    for (int i = 1; i < m; i++)\\n                        matrix[i][j] = 0;\\n                }\\n            }\\n            if (row){\\n                for (int j = 0; j < n; j++)\\n                    matrix[0][j] = 0;\\n            }\\n            if (col){\\n                for(int i = 0; i < m; i++)\\n                    matrix[i][0] = 0;\\n            }\\n        }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return;\\n            int m = matrix.length, n = matrix[0].length;\\n            boolean row = false, col = false;\\n            for (int i = 0; i < m; i++)\\n                for (int j = 0; j < n; j++){\\n                    if (matrix[i][j] == 0) {\\n                        matrix[0][j] = 0;\\n                        matrix[i][0] = 0;\\n                        if (i == 0) row = true;\\n                        if (j == 0) col = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 26020,
                "title": "my-java-solution-easy-to-understand",
                "content": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        int[] row = new int[m];\\n        int[] col = new int[n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i]==1||col[j]==1){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 26087,
                "title": "java-easy-to-understand-o-1-space-solution-with-2-passes",
                "content": "    public class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }\\n        \\n        boolean setFirstRowToZeroes = false;\\n        boolean setFirstColumnToZeroes = false;\\n        \\n        //check if first column needs to be set to zero\\n        for(int row=0;row<matrix.length;row++){\\n            if(matrix[row][0] == 0){\\n                setFirstColumnToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //check if first row needs to be set to zero\\n        for(int col=0;col<matrix[0].length;col++){\\n            if(matrix[0][col] == 0){\\n                setFirstRowToZeroes=true;\\n                break;\\n            }\\n        }\\n        \\n        //mark columns and rows to be set to zero\\n        for(int row=1;row<matrix.length;row++){\\n            for(int col=1;col<matrix[0].length;col++){\\n                if(matrix[row][col]==0){\\n                    matrix[row][0]=0;\\n                    matrix[0][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make rows zero\\n        for(int row=1;row<matrix.length;row++){\\n            if(matrix[row][0]==0){\\n                for(int col=1;col<matrix[0].length;col++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // make columns zero\\n        for(int col=1;col<matrix[0].length;col++){\\n            if(matrix[0][col]==0){\\n                for(int row=1;row<matrix.length;row++){\\n                    matrix[row][col]=0;\\n                }\\n            }\\n        }\\n        \\n        // zero out first row (if needed)\\n        if(setFirstRowToZeroes){\\n            for(int col=0;col<matrix[0].length;col++){\\n                matrix[0][col]=0;\\n            }\\n        }\\n        \\n        // zero out first column (if needed)\\n        if(setFirstColumnToZeroes){\\n            for(int row=0;row<matrix.length;row++){\\n                matrix[row][0]=0;\\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null || matrix.length==0){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26166,
                "title": "my-java-o-1-solution-easy-to-understand",
                "content": "    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }\\n            \\n            int m = matrix.length;\\n            int n = matrix[0].length;\\n            \\n            boolean rowHasZero = false;\\n            boolean colHasZero = false;\\n            \\n            for(int i=0; i<n; i++){\\n                if(matrix[0][i]==0){\\n                    rowHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=0; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    colHasZero = true;\\n                    break;\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                for(int j=1; j<n; j++){\\n                    if(matrix[i][j]==0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            \\n    \\n            \\n            for(int j=1;j<n; j++){\\n                if(matrix[0][j]==0){\\n                    nullifyCol(matrix, j, m, n);\\n                }\\n            }\\n            \\n            for(int i=1; i<m; i++){\\n                if(matrix[i][0]==0){\\n                    nullifyRow(matrix, i, m, n);\\n                }\\n            }\\n            \\n            if(rowHasZero){\\n                nullifyRow(matrix, 0, m, n);\\n            }\\n            if(colHasZero){\\n                nullifyCol(matrix, 0, m, n);\\n            }\\n            \\n        }\\n        \\n        public void nullifyRow(int[][] matrix, int i, int m, int n){\\n            for(int col=0; col<n; col++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n        \\n        public void nullifyCol(int[][] matrix, int j, int m, int n){\\n            for(int row=0; row<m; row++){\\n                matrix[row][j] = 0;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            if(matrix==null){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 588969,
                "title": "python-solution-using-set-beats-100",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        row = set()\\n        column = set()\\n        \\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    row.add(i)\\n                    column.add(j)          \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j] = 0\\n        for i in column:\\n            for j in range(len(matrix)):\\n                matrix[j][i] = 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515437,
                "title": "java-tc-o-r-c-sc-o-1-optimized-in-place-solution",
                "content": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```java\\n/**\\n * Optimized In-Place solution\\n *\\n * We can use the first cell of every row and column as a flag. This flag will\\n * determine whether a row or a column has to be set to zero.\\n *\\n * Time Complexity: O(2 * R * C)\\n *\\n * Space Complexity: O(1)\\n *\\n * R = Number of rows. C = Number of columns.\\n */\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\\n            return;\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        if (rows == 1 && cols == 1) {\\n            return;\\n        }\\n\\n        boolean isFirstColZero = false;\\n        for (int i = 0; i < rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                isFirstColZero = true;\\n            }\\n            for (int j = 1; j < cols; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = rows - 1; i >= 0; i--) {\\n            for (int j = cols - 1; j >= 1; j--) {\\n                if (matrix[i][0] == 0 | matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n            if (isFirstColZero) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383492,
                "title": "simple-c-solution-using-extra-space",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<pair<int,int>> cor;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   cor.push_back({i,j});\\n                }\\n            }\\n        }\\n        for(int i=0;i<cor.size();i++)\\n        {\\n            int x=cor[i].first;\\n            int y=cor[i].second;\\n            int row=0;\\n            int col=0;\\n            while(row<m)\\n            {\\n                matrix[row][y]=0;\\n                row++;\\n            }\\n            while(col<n)\\n            {\\n                matrix[x][col]=0;\\n                col++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280740,
                "title": "3-sweet-and-simple-approach-brute-force-optimal-pro-optimal",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }\\n               \\n            }\\n            \\n            \\n        }\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n               if(temp[i][j]==0)\\n                   v[i][j]=temp[i][j];\\n                else\\n                    v[i][j]=v[i][j];\\n            }\\n        }\\n        T.C =O(M*N*(M+N))    S.C=O(MN)\\n    */    \\n        \\n        /*-----------OPTIMAL APPROACH MAKE DUMMY ROW AND COLUMN---------*/\\n     \\n        \\n      /*  \\n        int m=v.size();\\n        int n=v[0].size();\\n        int row[m];\\n        int col[n];\\n        \\n        for(int i=0;i<m;i++)\\n            row[i]=false;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n            col[i]=false;\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n         }\\n        \\n         for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if( row[i]==true  ||  col[j]==true)\\n                {\\n                    v[i][j]=0;\\n                }\\n            }\\n         }\\n        \\n     time complexity   = O(N*M)\\n\\nSpace Complexity: O(M + N), for storing hash tables.\\n\\n*/\\n        \\n        /*--------------------- PRO -OPTIMAL APPROACH-----------------------*/\\n          int col0 = 1, rows = v.size(), cols = v[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (v[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (v[i][j] == 0)\\n                v[i][0] = v[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (v[i][0] == 0 || v[0][j] == 0)\\n                v[i][j] = 0;\\n        if (col0 == 0) v[i][0] = 0;\\n        \\n    }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& v) {\\n        int x,y;\\n        \\n        /*-------------BRUTE FORCE APPROACH-----------------*/\\n/*        \\n        \\n      int m=v.size();\\n        int n=v[0].size();\\n        int temp[m][n];\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                temp[i][j]=1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(v[i][j]==0)\\n                {\\n                for(int k=0;k<m;k++)\\n                    temp[k][j]=0;\\n                    \\n                    for(int k=0;k<n;k++)\\n                        temp[i][k]=0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2170667,
                "title": "c-easy-solution-optimized",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = true;\\n        // int rows = sizeof(matrix)/sizeof(matrix[0]);\\n        int rows = matrix.size();\\n        // int cols = sizeof(matrix[0]/sizeof(matrix[0][0]));\\n        int cols = matrix[0].size();\\n        \\n        \\n        // iterate from forward\\n        for(int i = 0; i < rows; i++)\\n        {\\n            if(matrix[i][0]==0) col0 = false;\\n            for(int j = 1; j < cols; j++)\\n                if(matrix[i][j]==0)\\n                    matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        // iterate from backward\\n        for(int i = rows-1; i >= 0; i--){\\n            for(int j = cols-1; j >= 1; j--)\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if(col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495421,
                "title": "javascript-fast-and-simple",
                "content": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n\\n    var track = []\\n    \\n    // find zeros\\n    for(var i = 0; i < matrix.length; i++){\\n      for(var j = 0; j < matrix[0].length; j++){\\n        if(matrix[i][j] === 0) track.push([i, j])                \\n      }\\n    }\\n\\n    for(var i = 0; i < track.length; i++){\\n      var [x, y] = track[i]\\n      \\n      // update row\\n      for(var j = 0; j < matrix[0].length; j++){\\n        matrix[x][j] = 0\\n      }\\n      \\n      // udpate column\\n      for(var j = 0; j < matrix.length; j++){\\n        matrix[j][y] = 0\\n      }\\n\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519959,
                "title": "c-java-python-javascript-using-matrix-and-array-with-full-explanation",
                "content": "# Intuition:\\nWe need to modify the matrix in-place, so we can\\'t use an auxiliary matrix or hash table. We can instead use the first row and first column of the original matrix as a replacement for the auxiliary array. This way, we can save the extra space required for the auxiliary arrays and also set the values in the first row and column to zero if any element in the corresponding row or column is zero.\\n\\n# Approach:\\n1. First, the code initializes two dummy vectors, `dummyRow` and `dummyCol`, with initial values of -1. These vectors will be used to mark the rows and columns that need to be set to zero.\\n2. The code then iterates through each element of the matrix and checks if it is zero. If an element is zero, it updates the corresponding indices in `dummyRow` and `dummyCol` to 0.\\n3. After marking the rows and columns, the code iterates through the matrix again. For each element, it checks if the corresponding row index or column index in `dummyRow` or `dummyCol` is zero. If either of them is zero, it sets the current element to zero.\\n4. Finally, the matrix will have rows and columns set to zero based on the values in `dummyRow` and `dummyCol`.\\n\\n# Complexity:\\n- Time complexity: O(mn), where m and n are the number of rows and columns in the matrix, respectively. We have to traverse the matrix twice.\\n- Space complexity: O(m+n), where m and n are the number of rows and columns in the matrix, respectively. We are using two auxiliary vectors of size m and n to keep track of the rows and columns that contain zero elements.\\n\\n---\\n# C++\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n---\\n# Java\\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\\n\\n---\\n# Python\\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\\n---\\n# JavaScript\\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        vector <int> dummyRow(row,-1);\\n        vector<int> dummyCol(col,-1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n         for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int row = matrix.length;\\n        int col = matrix[0].length;\\n        int[] dummyRow = new int[row];\\n        int[] dummyCol = new int[col];\\n        Arrays.fill(dummyRow, -1);\\n        Arrays.fill(dummyCol, -1);\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(matrix[i][j]==0){\\n                    dummyRow[i] = 0;\\n                    dummyCol[j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n\\n```\n```py\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        row = len(matrix)\\n        col = len(matrix[0])\\n        dummyRow = [-1] * row\\n        dummyCol = [-1] * col\\n        for i in range(row):\\n            for j in range(col):\\n                if matrix[i][j] == 0:\\n                    dummyRow[i] = 0\\n                    dummyCol[j] = 0\\n        for i in range(row):\\n            for j in range(col):\\n                if dummyRow[i] == 0 or dummyCol[j] == 0:\\n                    matrix[i][j] = 0\\n\\n```\n```js\\nvar setZeroes = function(matrix) {\\n    const row = matrix.length;\\n    const col = matrix[0].length;\\n    const dummyRow = new Array(row).fill(-1);\\n    const dummyCol = new Array(col).fill(-1);\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(matrix[i][j]==0){\\n                dummyRow[i] = 0;\\n                dummyCol[j] = 0;\\n            }\\n        }\\n    }\\n    for(let i=0;i<row;i++){\\n        for(let j=0;j<col;j++){\\n            if(dummyRow[i] == 0 || dummyCol[j] == 0 ){\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26151,
                "title": "constant-space-java-solution",
                "content": " a b b \\n\\n   b c c\\n\\n   b c c\\n\\nStep1: Determine row1 and col1. Need to go through the first col and first row. Use two vars to store that information.\\nStep2: Use \"c\" to determine \"b\". Need to go through the entire matrix. Once \"c\" is zero, set its corresponding two \"b\"s to zero.\\nStep3: Use \"b\" to set \"c\". If \"b\" is zero, its corresponding row or col are set to all zero.\\nStep4: Use previous row1 and col1 information to set col1 and row1.\\n\\n    public class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstColZero = false, firstRowZero = false;\\n            for(int i = 0;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    firstColZero = true;\\n            for(int j = 0;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    firstRowZero = true;\\n            for(int i = 1;i < matrix.length;i++)\\n                for(int j = 1;j < matrix[0].length;j++)\\n                    if(matrix[i][j] == 0)\\n                        matrix[i][0] = matrix[0][j] = 0;\\n            for(int i = 1;i < matrix.length;i++)\\n                if(matrix[i][0] == 0)\\n                    for(int j = 0;j < matrix[0].length;j++)\\n                        matrix[i][j] = 0;\\n            for(int j = 1;j < matrix[0].length;j++)\\n                if(matrix[0][j] == 0)\\n                    for(int i = 0;i < matrix.length;i++)\\n                        matrix[i][j] = 0;\\n            if(firstColZero)\\n                for(int i = 0;i < matrix.length;i++)\\n                    matrix[i][0] = 0;\\n            if(firstRowZero)\\n                for(int j = 0;j < matrix[0].length;j++)\\n                    matrix[0][j] = 0;\\n                    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1477825,
                "title": "javascript-three-solutions-one-is-suggested-transcribed-to-js-100",
                "content": "![image](https://assets.leetcode.com/users/images/45384296-f1fe-4288-9759-058e94dde2c9_1632272059.2179272.png)\\n\\n\\nDoing the Blind 75 and posting all solutions.\\n\\nHere is the \\'Suggested Solution\\' transcribed to JS.  Cool solution if you Have to keep constant space.  A little convoluted otherwise imo.\\n```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we use Sets to track 0\\'s.  A little extra space, but not a ton.  Won\\'t work if interviewer challenges you to constant space though.\\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\\n\\nHere is a version where we just deep copy the array and go to town.  This is the easiest imo and gets solid time complexity (Maybe slight redoing of the recursive calls if 0\\'s overwrite cells more than once.).  It Is the worst on space complexity though.  Just depends what they\\'re looking for and if Constant Space is make or break.\\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let isCol = false, r = matrix.length, c = matrix[0].length;\\n  for (let i = 0; i < r; i++) {\\n    if (!matrix[i][0]) isCol = true;\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][j]) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      };\\n    }\\n  }\\n  for (let i = 1; i < r; i++) {\\n    for (let j = 1; j < c; j++) {\\n      if (!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0;\\n    }\\n  }\\n  if (!matrix[0][0]) {\\n    for (let j = 0; j < c; j++) matrix[0][j] = 0;\\n  }\\n  if (isCol) {\\n    for (let i = 0; i < r; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const rowSet = new Set(), colSet = new Set()\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!matrix[i][j]) {\\n        rowSet.add(i);\\n        colSet.add(j);\\n      };\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (rowSet.has(i) || colSet.has(j)) matrix[i][j] = 0\\n    }\\n  }\\n};\\n```\n```\\nvar setZeroes = function(matrix) {\\n  const copy = JSON.parse(JSON.stringify(matrix));\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (!copy[i][j]) traverse(i, j);\\n    }\\n  }\\n  \\n  function traverse(row, col, dir = \\'all\\') {\\n    matrix[row][col] = 0;\\n    if (row - 1 >= 0 && (dir === \\'all\\' || dir === \\'up\\')) traverse(row - 1, col, \\'up\\');\\n    if (row + 1 <= matrix.length - 1 && (dir === \\'all\\' || dir === \\'down\\')) traverse(row + 1, col, \\'down\\');\\n    if (col - 1 >= 0 && (dir === \\'all\\' || dir === \\'left\\')) traverse(row, col - 1, \\'left\\');\\n    if (col + 1 <= matrix[row].length - 1 && (dir === \\'all\\' || dir === \\'right\\')) traverse(row, col + 1, \\'right\\');\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26047,
                "title": "quiet-simple-answer-u2018hacking-u2019-with-javascript",
                "content": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "solutionTags": [],
                "code": "var setZeroes = function(matrix) {\\n\\n    var r = matrix.length;\\n    var l = matrix[0].length;\\n    for (var i = 0; i < r; i++) {\\n        for (var j = 0; j < l; j++) {\\n            if (matrix[i][j] === 0 && 1 / matrix[i][j] === Infinity) {\\n                for (var x = 0; x < r; x++) {\\n                    matrix[x][j] = matrix[x][j] && -0;\\n                }\\n                for (var y = 0; y < l; y++) {\\n                    matrix[i][y] = matrix[i][y] && -0;\\n                }\\n            }\\n        }\\n    }\\n\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1918838,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func setZeroes(_ matrix: inout [[Int]]) {\\n        let row = matrix.count\\n        let col = matrix[0].count\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] == 0 {\\n                    setMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col {\\n                if matrix[i][j] != 0 {\\n                    resetMax(&matrix, i, j)\\n                }\\n            }\\n        }\\n    }\\n\\n    \\n    func setMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        for i in 0..<matrix.count { \\n            let val = matrix[i][col]\\n            matrix[i][col] = val == 0 ? 0 : Int.max\\n        }\\n        \\n        for j in 0..<matrix[0].count {\\n            let val = matrix[row][j]\\n            matrix[row][j] = val == 0 ? 0 : Int.max\\n        }\\n    }\\n    \\n    \\n    func resetMax(_ matrix: inout [[Int]], _ row: Int, _ col: Int) {\\n        let val = matrix[row][col]\\n        if val == Int.max { matrix[row][col] = 0 }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26176,
                "title": "is-there-a-better-constant-space-solution",
                "content": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "solutionTags": [],
                "code": "My solution is kind of hackish - accpeted. So, I want to know if there is a better constant space solution?\\n\\nI traverse the matrix and if I find a zero, I replace all the elements, except the 0 elements, of the corresponding row and column with -1. Finally I make all the -1 to 0.\\n\\nThis algorithm would fail if the matrix has -1s. \\n\\n        void setZeroes(vector<vector<int> > &matrix) {\\n        \\n        int i,j,k,m,n;\\n        \\n        m = matrix.size();\\n        n = matrix[0].size();\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==0)\\n                {\\n                    for(k=0;k<n;k++)\\n                        if(matrix[i][k]!=0)\\n                            matrix[i][k] = -1;\\n                    for(k=0;k<m;k++)\\n                        if(matrix[k][j]!=0)\\n                            matrix[k][j] = -1;\\n                }\\n        \\n        for(i=0;i<m;i++)\\n            for(j=0;j<n;j++)\\n                if(matrix[i][j]==-1)\\n                   matrix[i][j]=0; \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3513736,
                "title": "python3-o-1-with-reverse-traversal",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        firstRowVal, R, C = 1, len(matrix), len(matrix[0])\\n\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0 # mark column\\n                    if i != 0:       \\n                        matrix[i][0] = 0\\n                    else:\\n                        firstRowVal = 0\\n        \\n        for i in reversed(range(R)):\\n            for j in reversed(range(C)):\\n                if i == 0:\\n                    matrix[i][j] *= firstRowVal\\n                elif matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2367506,
                "title": "easy-c-o-1-faang-optimal-approach",
                "content": "# **Solution 1:**\\n \\n# **Approach: Using brute force**\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# Time Complexity:O((N*M)*(N + M)). O(N*M) for traversing through each element and (N+M)for traversing to row and column of elements having value 0.\\n\\n# Space Complexity:O(1)\\n# **Solution 2: Better approach**\\n\\n**Intuition:** Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n**Approach:** Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\\n# **Time Complexity: O(N*M + N*M)**\\n\\n# **Space Complexity: O(N)**\\n# **Solution 3: Optimizing the better approach.**\\n\\n**Intuition:** Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\n**Approach:** Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```\\n# **Time Complexity: O(2*(N*M)), as we are traversing two times in a matrix.**\\n\\n# **Space Complexity: O(1).**\\n\\nI found This video really useful. \\n[https://www.youtube.com/watch?v=M65xBewcqcI&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=10](http://)\\n\\n# **Please UPVOTE if it helped you !   \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\n\\nusing namespace std;\\n\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout << \"The Final Matrix is \" << endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\nint main() {\\n  vector < vector < int >> arr;\\n  arr = {{0, 1, 2, 0}, {3, 4, 5, 2}, {1, 3, 1, 5}};\\n  setZeroes(arr);\\n  cout<<\"The Final Matrix is \"<<endl;\\n  for (int i = 0; i < arr.size(); i++) {\\n    for (int j = 0; j < arr[0].size(); j++) {\\n      cout << arr[i][j] << \" \";\\n    }\\n    cout << \"\\\\n\";\\n  }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix){\\n        int col0=1, rows=matrix.size(), columns=matrix[0].size();\\n        for(int i=0 ; i<rows ; i++){\\n            if(matrix[i][0]==0) col0=0;\\n            for(int j=1 ; j<columns ; j++){\\n                if(matrix[i][j]==0)\\n                    matrix[i][0]=matrix[0][j]=0;\\n            }\\n        }\\n        for(int i=rows-1 ; i>=0 ; i--){\\n            for(int j=columns-1 ; j>=1 ; j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(col0==0)\\n                matrix[i][0]=0;\\n        }\\n    }\\n};\\n\\n// Total TC: O(2(m*n)) SC: O(1)\\n```",
                "codeTag": "C++"
            },
            {
                "id": 715132,
                "title": "java-best-explained-o-1-space-complexity",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //if we do normal approach whole matrix becomes 0\\n        // Basic explanation:\\n        // we are using the first row and column as a memory to keep track of all the 0\\'s in the entire matrix.\\n        \\n        if(matrix==null || matrix.length==0 || matrix[0].length==0){\\n            return;\\n        }\\n        \\n        \\n        //first we have to check is there any need to make first row and first column\\n        //so that at last we make tham 0\\n        int m=matrix.length;\\n        int n=matrix[0].length;\\n        boolean first_row=false;\\n        boolean first_col=false;\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][0]==0){\\n                first_col=true;\\n                break;\\n            }\\n        }\\n        for(int j=0;j<n;j++){\\n            if(matrix[0][j]==0){\\n                first_row=true;\\n                break;\\n            }\\n        }\\n        //now find 0 inside matrix (except first row and col)\\n        //make 0 at the corresponding pos of first row and first col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //Now it\\'s time to make them 0 based to first row and col\\n        for(int i=1;i<m;i++){\\n            for(int j=1;j<n;j++){\\n                if(matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        //At last convert first row 0 if first_row is true\\n        if(first_row){\\n            for(int j=0;j<n;j++){\\n                matrix[0][j]=0;\\n            }\\n        }\\n        //same for first col\\n        if(first_col){\\n            for(int i=0;i<m;i++){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961783,
                "title": "c-3-approaches-easy-to-understand",
                "content": "It is a frequently asked problem in interviews and a really good example of how to reduce time and space complexity for matrices using certain observations.\\n\\n**1st approach: Brute Force**\\n\\nSo, this approach would cross everyone\\'s mind and goes as following-\\nFirst we\\'ll check for cells with zero and then create a new matrix and traverse the given matrix and reflect all the changes in the new matrix itself.\\n\\n**Code-**\\n\\n```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\\n\\n*Time complexity= O((rowsize * columsize) *  (rowsize+columnsize))\\nSpace Complexity= O(rowsize  columnsize)*\\n\\n**2nd approach: Using Hash Table**\\n\\nNow, we can get rid of the third loop by simply using two hash tables. The intuition to use two hash tables comes from observing the problem and what it requires, and that is we just want to keep track of 0 of any matrix cell and want to change the whole column or whole row accordingly, thus the idea of using hashing generates.\\n\\nIn this approach, we\\'ll use two hash tables-\\n\\n1)For tracking which row will contain 0\\'s\\n2)For tracking which column will contain 0\\'s\\n\\nand will update the row or column index in the matrix to 0. Then we\\'ll iterate through the whole matrix again and check the values in the hash table, so when we\\'ll encounter a 0 in either of the hash tables we\\'ll update 0 in the matrix.\\n\\n**Code-**\\n\\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(rowsize + columnsize)*\\n\\n**3rd approach: Using In-place Hashing**\\n\\nNow this can be done by an amazing observation and using the 2nd approch but with O(1) space complexity, that is we know that we are required to update 0 in place of a particular column or row whenever a zero is encountered, that means ultimately the first/last column and row are going to reflect changes accordingly and can act as suitable hash tables. Voila! You got that right, in this question we can use the first/last column and row as hash tables and thus reduced space complexity.\\n\\nBut!! There is one problem that is if we use the first or last column and row, the first/last cell will result in clashing as it is common to both the dummy hash tables. So, can we resolve this issue? Well, yes this issue can be resolved.\\n\\nHow?\\nWe can reserve the first/last cell for dummy row hash table and whether to reflect changes in the column hash table we can use a separate variable. And this way, we can avoid any sort of clashing.\\n\\n**Code-**\\n\\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```\\n\\n*Time complexity= O(rowsize * columnsize)\\nSpace Complexity= O(1)*\\n\\nIf this helped you, please consider upvoting! \\nHappy coding!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<vector<int>> v( matrix.size(), vector<int>(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){\\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t       for(int k=0; k<matrix.size(); k++){\\n\\t\\t\\t       v[k][j]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor(int k=0; k<matrix[0].size(); k++){\\n\\t\\t\\t       v[i][k]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tv[i][j]=matrix[i][j];\\n\\t\\t}\\n    }\\n```\n```\\nvector<int> rows(matrix.size()), cols(matrix[0].size());\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(matrix[i][j] == 0){\\n\\t\\t      rows[i] = cols[j] = 0;       //updating hash tables\\n\\t\\t\\t }\\n\\t   }\\n}\\n//Now updating the matrix in 2nd traversal\\nfor( int i = 0; i < matrix.size(); i++){                 \\n     for(int j = 0; j< matrix[0].size(); j++){\\n\\t      if(rows[i] == 0 || cols[j] == 0){\\n\\t\\t      matrix[i][j] = 0;       \\n\\t\\t\\t }\\n\\t   }\\n}\\n\\n```\n```\\nint n=matrix.size(), m=matrix[0].size(), col=1; //the col variable is defined so as to avoid the clash on the first cell of the matrix as it is commom to both dummy in-place hash tables \\n        for(int i=0;i<n;i++){\\n            if(matrix[i][0]==0)col=0; //it will only be set to zero when a 0 is encountered corresponding to a column\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        //The first matrix traversal was to create the hash tables and the second one below is to update the values in the matrix according to the hash table\\n        for(int i=n-1;i>=0;i--){\\n            for(int j=m-1;j>=1;j--){\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n            }\\n            if(col==0)matrix[i][0]=0; //clash avoided as column that particular column will only be updated when col is 0 otherwise values will remain intact \\n        }\\n        //the reason we were able to use in-place hashing in this question was because ultimately 0 in a cell will make that particular row or column 0. Hence we could use the first row and column as dummy hash tables and also didn\\'t have to store the values elsewhere\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1009282,
                "title": "with-explanation-0-1-space-0-m-n-space",
                "content": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n//O(m+n) space, O(m+n) time\\n//keep two sets, one for row indexes than should be marked 0, and one for col indexes that should be marked 0\\n//loop through matrix once, populating the sets\\n//loop through a second time, setting items to 0, if their indexes are in either set\\n\\nconst setZeroes = (matrix) => {\\n    let rowsZero = new Set()\\n    let colsZero = new Set()\\n    for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n                rowsZero.add(i)\\n                colsZero.add(j)\\n            }\\n        }\\n    }\\n  for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (rowsZero.has(i) || colsZero.has(j)){\\n                matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\n//O(1) space, O(m+n) time\\n//we do the same as above, except we use the matrix itself to keep track of which rows and cols should be 0, instead of using sets\\n//we go through matrix and if we find a 0, we mark all items in row and all items in col\\n//we can\\'t simply set all items in row and col to zero, because we don\\'t want to change rows and columns with newly formed zeroes...just original zeroes\\n//if our \\'mark\\' function changed all items in selected row and col to be zero, it would mess up future iterations\\n//so we mark them as something else...null...and then we loop through the matrix a second time, making null items 0\\nconst setZeroes = (matrix) =>{\\n      for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === 0){\\n              mark(matrix,i,j)\\n            }\\n        }\\n    }\\n       for (let i = 0;i < matrix.length;i++){\\n        for (let j = 0;j<matrix[0].length;j++){\\n            if (matrix[i][j] === null){\\n              matrix[i][j] = 0\\n            }\\n        }\\n    }\\n}\\n\\nconst mark = (matrix, row, col)=>{\\n    for (let j = 0; j < matrix[0].length; j++){\\n        //preserve original 0, mark items that should zero as null\\n        if (matrix[row][j] !== 0){\\n           matrix[row][j] = null         \\n        }\\n    }\\n    for (let i = 0; i < matrix.length; i++){\\n        //preserve original 0, mark items that should be zero as null\\n        if (matrix[i][col] !== 0){\\n            matrix[i][col] = null\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3689227,
                "title": "java-striver-easy-understanding",
                "content": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\\n\\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n# 1. Brute force Approach\\nComplexity\\nTime complexity:O((NM)(N + M)) + O(N*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(1)\\n\\n# Code\\n\\nclass Solution {\\n    \\n    // making rows negative excluding 0\\'s\\n    public static void makeRow(int matrix[][],int n,int m,int i){\\n        for(int j=0;j<n;j++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n            \\n        }\\n    }\\n    \\n      // making cols negative excluding 0\\'s\\n    public static void makeCol(int matrix[][],int n,int m,int j){\\n        for(int i=0;i<m;i++){\\n            if(matrix[i][j]!=0){\\n                matrix[i][j] = -1;\\n            }\\n        }\\n    }\\n    \\n    // main function\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix[0].length;\\n        int m = matrix.length;\\n       \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    makeRow(matrix,n,m,i);\\n                    makeCol(matrix,n,m,j);\\n                }\\n            }\\n        }\\n        \\n        // itterate through the matrix and mark 0\\'s where negative is present \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]== -1){\\n                    matrix[i][j]=0;\\n                }\\n                \\n            }\\n        }\\n    }\\n}\\n```\n```\\n#2. Better Approach\\nComplexity\\nTime complexity:O(2*(N*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\nSpace complexity:O(N) + O(M)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        int row [] = new int[m];\\n        int col[] = new int[n];\\n\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                   \\n                   row [i] = 1;\\n                   col [j] = 1;\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(row[i]==1 ||col[j]==1){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```\n```\\n\\n#3. Optimal Approach\\nComplexity\\nTime complexity:O(2*(N*M))\\nSpace complexity:O(1)\\n\\nclass Solution {\\n   \\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                if(matrix[i][j]==0){  \\n                    matrix[i][0] = 0;\\n                if(j != 0){\\n                    matrix[0][j] = 0;\\n                }else col0 = 0;\\n                }\\n            }\\n        }\\n\\t\\t\\n        for(int i = 1;i<m;i++){\\n            for(int j = 1;j<n;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[i][0]==0 ||matrix[0][j]==0){\\n                    matrix[i][j] = 0;\\n                }\\n                } \\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            if(matrix[0][0]==0){\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            if(col0 == 0){\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316512,
                "title": "java-solution-for-beginners",
                "content": "*** Please upvote if helpful!**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        int[] row = new int[matrix.length];\\n        int[] col = new int[matrix[0].length];\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    row[i] = -1;\\n                    col[j] = -1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (row[i] == -1 || col[j] == -1) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512927,
                "title": "python-o-1-aux-space-sol-by-bit-masking-72-with-explanation",
                "content": "Python O(1) aux space sol by bit masking\\n\\nLet *m*, *n* denote as the dimension of matrix height and width.\\n\\n---\\n\\n**Hint**:\\nWhat we need to know is **index of row** and **index column** for **zero element**.\\n\\nUsually, first idea pop into our head is to to store those indices in a set, which is up to O( m + n )\\n\\nActually, we can be more memory-space saving by using bit masking, reduce aux space cost to O(1).\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1.\\n\\nScan each element in matrix.\\n**Setup bit masking for zero element**, store them in integer.\\n\\nFor example, if masking row is row_#**0**, row_#**1**, and row_**#3**, then\\n**row_mask** = (1<<**0**) + (1<<**1**) + (1<<**3**) = 2^**0** + 2^**1** + 2^**3**\\n= 0b **1011**\\n\\nSimilarly, masking column is setup in the same way.\\n\\n---\\n\\nStep_#2.\\n\\nIterate each position in matrix,\\n**Clean specified position to 0** by **row mask** and **column mask**.\\n\\n---\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #1252 Cells with Odd Values in a Matrix](https://leetcode.com/problems/cells-with-odd-values-in-a-matrix/)",
                "solutionTags": [
                    "Python",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        h, w = len( matrix), len( matrix[0])\\n        \\n        row_mask, col_mask = 0, 0\\n        \\n        ## Step_#1\\n        #\\n        # Setup masking for zero element\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if matrix[y][x] == 0:\\n                    \\n                    row_mask |= (1<<y)\\n                    col_mask |= (1<<x)\\n        \\n        \\n        ## Step_#2\\n        #\\n        # Clear by row mask and column mask\\n        for y in range(h):\\n            for x in range(w):\\n                \\n                if row_mask & (1<<y) or col_mask & (1<<x):\\n                    matrix[y][x] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597295,
                "title": "3-approaches-from-brute-to-optimal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo traverse through thw whole matrix and if a zero is found then set whole row and column to 0\\n# Approach 1:\\n<!-- Describe your approach to solving the problem. -->\\nTraversing the matrix and if 0 is found then setting it to a negative number cause setting it to zero can hamper values of other row and columns where initially 0 was not present after setting with negative number traversing again through matrix and setting to zero wherever negative number is found. This approach works only if no negative numbers are present in the matrix.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M)*O(N+M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n\\n# Approach 2:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays to keep track of zeroes. Setting that particular row to 0 in dummy row as well as dummy column arrays wherever zero is found in the cell. Again traversing through the matrix and replacing current value by 0 if current cell dummy row index or dummy column index is set to 0.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)+O(M)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\\n# Approach 3:\\n<!-- Describe your approach to solving the problem. -->\\nUsing dummy arrays increases space complexity to O(N) so trying to reduce space complexity.\\nWe use the 1st row and 1st column of given array as dummy array but matrix[0][0] coincides so to resolve this we use dummy column from 1 to n and dummy row from 0 to m. so for keeping track of whether dummy row contains any 0 we use a variable col and set it to 0 if a 0 is found in dummy row.\\nWe again traverse the array apart from dummy row and dummy column i.e from i-> 1 to m and j-> 1 to n to find if matrix cell contains any zero if it does then we check whether dummy column or row is set if it is set then we set the matrix cell to zero.\\nNow we again need to perform similar operation for dummy row as well as dummy column. dummy row depends on matrix [0][0] whereas as dummy column depends on cols variable so we set it accordingly.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*M + N*M)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setRowColumn(vector<vector<int>>& matrix,int m,int n,int r,int c)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            if(matrix[r][i]!=0)\\n                matrix[r][i]=-1;\\n        }\\n        for(int j=0;j<m;j++)\\n        {\\tif(matrix[j][c]!=0)\\n                matrix[j][c]=-1;\\n        }\\n    }\\n    void setZeroes(vector<vector<int>> &matrix)\\n    {\\n        // Write your code here.\\n        int m=matrix.size(), n=matrix[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    setRowColumn(matrix,m,n,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]<0)\\n                    matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size(),n=matrix[0].size();\\n\\tvector<int> rows(m,1),cols(n,1);\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\trows[i]=0;\\n\\t\\t\\t\\tcols[j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(rows[i]==0 || cols[j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n    \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n    bool cols=1;\\n\\tint m=matrix.size(),n=matrix[0].size();\\n\\tfor(int i=0;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=0;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmatrix[i][0]=0;\\n\\t\\t\\t\\tif(j!=0)\\n\\t\\t\\t\\t\\tmatrix[0][j]=0;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tcols=0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i=1;i<m;i++)\\n\\t{\\n\\t\\tfor(int j=1;j<n;j++)\\n\\t\\t{\\n\\t\\t\\tif(matrix[i][j]!=0)\\n\\t\\t\\t{\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) \\n\\t\\t\\t\\t{\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\tif(matrix[0][0]==0)\\n\\t{\\n\\t\\tfor (int i = 0; i < n; i++) \\n\\t\\t{\\n\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n    }\\n\\tif(cols==0)\\n\\t{\\n\\t\\tfor (int j = 0; j < m; j++) \\n\\t\\t{\\n\\t\\t\\tmatrix[j][0] = 0;\\n\\t\\t}\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243163,
                "title": "python-easy-solution",
                "content": "I have initialize the coordinate list for row and col. If we found zero we append its row and col coordinates to respective list....Easy??\\n\\nFor the next steps I\\'m simply adding zero to (0-R, 1-R, 2-R, ...upto no. of rows) indexes. Similarly for the column I\\'m adding zero to (C-0, C-1, C-2, ...upto no of columns) indexes. Easy..!!\\n\\nEasy and Helpful ?? **Make sure to Upvote** \\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```\\n\\n![image](https://assets.leetcode.com/users/images/bcd31b28-9137-4b52-ba0c-3019cb6db3dd_1657052349.8345335.jpeg)\\n",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        row, col = [], []\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c] == 0:\\n                    row.append(r)\\n                    col.append(c)\\n        \\n        for r in row:\\n            for i in range(len(matrix[0])):\\n                matrix[r][i] = 0\\n        \\n        for c in col:\\n            for i in range(len(matrix)):\\n                matrix[i][c] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944059,
                "title": "two-different-approaches",
                "content": "# without Space ---->O(1)\\n# Time complexity ------>O(N^3)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\\n# with space Complexity:O(2*k) \\n# Time Complexity--->O(N^2)\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```\\n  # please upvote me it would encourage me alot\\n\\n\\n            \\n\\n\\n        \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    for row in range(n):\\n                        if matrix[i][row]!=0:\\n                            matrix[i][row]=-2**32\\n                    for col in range(m):\\n                        if matrix[col][j]!=0:\\n                            matrix[col][j]=-2**32\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==(-2**32):\\n                    matrix[i][j]=0\\n```\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        m=len(matrix)\\n        n=len(matrix[0])\\n        arr=[]\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j]==0:\\n                    arr.append([i,j])\\n                \\n        for k,l in arr:\\n            for row in range(n):\\n                matrix[k][row]=0\\n            for col in range(m):\\n                matrix[col][l]=0\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 3155961,
                "title": "simplest-c-solution-using-set-and-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        set<int>r,c;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n\\n            }\\n        }\\n    for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(r.count(i) || c.count(j))\\n                matrix[i][j]=0;\\n                }\\n            \\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\nDo upvote if it helped\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802535,
                "title": "striver-s-solution-upvote-if-you-like",
                "content": "# Intuition\\nusing striver approach\\n\\n# Approach\\nstore states of each row in the first of that row, and store states of each column in the first of that column. Because the state of row0 and the state of column0 would occupy the same cell, I let it be the state of row0, and use another variable \"colm\" for column0. In the first phase, use matrix elements to set states in a top-down way. In the second phase, use states to set matrix elements in a bottom-up way.\\n\\n# Complexity\\nO(m*n)\\n\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1,rows=matrix.size(),col=matrix[0].size();\\n        for(int i=0;i<rows;i++)\\n        {\\n        if(matrix[i][0]==0) colm=0;\\n          for(int j=1;j<col;j++)\\n         {\\n            if(matrix[i][j]==0)\\n                matrix[i][0]=matrix[0][j]=0;\\n            \\n         }\\n        }\\n        for(int i=rows-1;i>=0;i--)\\n        {\\n            for(int j=col-1;j>=1;j--)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0)\\n                    matrix[i][j]=0;\\n                \\n                \\n            }\\n            if(colm==0) matrix[i][0]=0;\\n            \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2628269,
                "title": "set-matrix-zeroes-c-easy-and-clear-cut-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```\\n**Guys Don\\'t forget to upvote me.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Just keep it very simple \\n    //if any row or col containing zeros that means we have to set that row or col to zero.\\n    void setZeroes(vector<vector<int>>& matrix){\\n        bool isrow = false, iscol = false;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j] == 0){\\n                    if(i == 0) isrow = true;\\n                    if(j == 0) iscol = true;\\n                    //for further memorization we set the first element of that col and row to zero.\\n                    matrix[i][0] = matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1;i<matrix.size();i++){\\n            for(int j=1;j<matrix[0].size();j++){\\n                if(matrix[i][0] == 0 or matrix[0][j] == 0){\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        if(iscol) for(int i=0;i<matrix.size();i++) matrix[i][0] = 0;\\n        if(isrow) for(int j=0;j<matrix[0].size();j++) matrix[0][j] = 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968645,
                "title": "o-1-space-easily-explained-faster-than-100",
                "content": "**Code :**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```\\n\\n**Time Complexity : O(m + n)**\\n**Space Complexity : O(1)**\\n\\n**If you find it useful please upvote.\\nIf you have any question feel free to ask in comment section.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) \\n{\\n        int m = matrix.size(), n = matrix[0].size();\\n        bool isRowZero = false, isColZero = false;\\n        \\n\\t\\t// Check the first Column, zero is present or not...\\n        for(int i = 0; i < m; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                isColZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check the First Row, zero is present or not\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                isRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// check all elements except first row & first Column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n\\t\\t// process all elements except first row & first column\\n        for(int i = 1; i < m; i++)\\n        {\\n            for(int j = 1; j < n; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        \\n\\t\\t// process first column\\n        if(isColZero)\\n        {\\n            for(int i = 0; i < m; i++)\\n                matrix[i][0] = 0;\\n        }\\n        \\n\\t\\t// process first row\\n        if(isRowZero)\\n        {\\n            for(int i = 0; i < n; i++)\\n                matrix[0][i] = 0;\\n        }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1443892,
                "title": "m-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }\\n        \\n        for(int i =0; i < m; i++)                        \\n            for(int j = 0; j < n; j++) \\n                if(row[i] == 0 || col[j] == 0) \\n                    A[i][j] = 0;            \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& A) {\\n        const int m = A.size(), n = A[0].size();\\n        vector<int> row(m, 1), col(n,1);\\n        for(int i =0; i < m; i++)\\n            for(int j = 0; j < n; j++)\\n                if(A[i][j] == 0){\\n                    col[j] = 0;\\n                    row[i] = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1400851,
                "title": "2-approach-w-explanation-o-m-n-o-1-c-python-java",
                "content": "**OBSERVATION:**\\nThe time complexity of this problem remains `O(M*N)`, the only improvement we can do is of the space complexity. So we will have 2 approaches here\\n\\n# **APPROACH I:**\\n*Additional Memory Approach-*\\nIf any cell of the matrix has a zero we can record its row and column number. All the cells of this recorded row and column can be marked zero in the next iteration.\\n\\n**Algorithm**\\n* We iterate over the original array and look for zero entries.\\n* If we find that an entry at `[i, j]` is `0`, then we need to record somewhere the row `i` and column `j`.\\n* So, we use two sets, one for the rows and one for the columns.\\n```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\\n*  We iterate over the array once again, and check each cell.\\n\\t*  If the row **Or** column is marked, we set the value of the cell as 0.\\n\\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n`In Python`\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(M+N)**\\n\\n# **APPROACH II**\\nWe handle cases seperately. \\n* Check the first row and column for pre-existing `0`. \\n\\t* If found we mark that row or column as true\\n* Now we work upon the remaining matrix.\\n\\t* First we look for the cell that has `0` in it.\\n\\t* Then proceed with the working i.e. marking the cell as 0. \\n*  Now work upon the checked first row and column and update their values.\\n\\t*  Note: Updating before hand gives WA\\n \\n**Solution**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n**TIME COMPLEXITY- O(M*N)** where M and N are the number of rows and columns respectively.\\n**SPACE COMPLEXITY- O(1)**",
                "solutionTags": [],
                "code": "```\\n if cell[i][j] == 0 \\n {\\n     row.insert(i) \\n     column.insert(j)\\n }\\n ```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int R = matrix.size();\\n        int C = matrix[0].size();\\n        set<int> rows ;\\n        set<int> cols ;\\n        // We mark the rows and columns that are to be made zero\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (matrix[i][j] == 0) \\n            {\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n          }\\n        }\\n        // Iterate over the array once again and using the rows and cols sets, update the elements.\\n        for (int i = 0; i < R; i++) \\n        {\\n          for (int j = 0; j < C; j++) \\n          {\\n            if (rows.count(i) || cols.count(j)) \\n            {\\n              matrix[i][j] = 0;\\n            }\\n          }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n  public void setZeroes(int[][] matrix) {\\n    int R = matrix.length;\\n    int C = matrix[0].length;\\n    Set<Integer> rows = new HashSet<Integer>();\\n    Set<Integer> cols = new HashSet<Integer>();\\n\\n    // We mark the rows and columns that are to be made zero\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (matrix[i][j] == 0) \\n        {\\n          rows.add(i);\\n          cols.add(j);\\n        }\\n      }\\n    }\\n\\n    // Iterate over the array once again and using the rows and cols sets, update the elements.\\n    for (int i = 0; i < R; i++) \\n    {\\n      for (int j = 0; j < C; j++) \\n      {\\n        if (rows.contains(i) || cols.contains(j)) \\n        {\\n          matrix[i][j] = 0;\\n        }\\n      }\\n    }\\n  }\\n}\\n```\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: None Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        R = len(matrix)\\n        C = len(matrix[0])\\n        rows, cols = set(), set()\\n\\n        # We mark the rows and columns that are to be made zero\\n        for i in range(R):\\n            for j in range(C):\\n                if matrix[i][j] == 0:\\n                    rows.add(i)\\n                    cols.add(j)\\n\\n        # Iterate over the array once again and using the rows and cols sets, update the elements\\n        for i in range(R):\\n            for j in range(C):\\n                if i in rows or j in cols:\\n                    matrix[i][j] = 0\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        bool RowZero = false;\\n        bool ColZero = false;\\n        for (int i = 0; i < matrix[0].size(); i++) //check the first row\\n        { \\n            if (matrix[0][i] == 0) \\n            {\\n                RowZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 0; i < matrix.size(); i++) //check the first column\\n        { \\n            if (matrix[i][0] == 0) \\n            {\\n                ColZero = true;\\n                break;\\n            } \\n        }\\n        for (int i = 1; i < matrix.size(); i++) //check except the first row and column\\n        { \\n            for (int j = 1; j < matrix[0].size(); j++) \\n            {    \\n                if (matrix[i][j] == 0) \\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }        \\n            }\\n        }\\n        for (int i = 1; i < matrix.size(); i++) //process except the first row and column \\n        {\\n           for (int j = 1; j < matrix[0].size(); j++)\\n           {\\n               if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n               {\\n                   matrix[i][j] = 0;\\n           \\n               }\\n           }\\n        }\\n        if(RowZero) //handle the first row\\n        { \\n            for (int i = 0; i < matrix[0].size(); i++) \\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n        if (ColZero) //handle the first column\\n        { \\n            for (int i = 0; i < matrix.size(); i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 383088,
                "title": "three-solutions-in-python-3-o-1-o-m-n-and-o-mn-space",
                "content": "_O(1) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\\n_O(M+N) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```\\n_O(MN) space:_\\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, n = len(m), len(m[0]), [list(i) for i in m]\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif n[i][j]: continue\\n    \\t\\tfor k in range(N): m[i][k] = 0\\n    \\t\\tfor k in range(M): m[k][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N = len(m), len(m[0])\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j]: continue\\n    \\t\\tfor k in range(N):\\n    \\t\\t\\tif m[i][k] != 0: m[i][k] = \\' \\'\\n    \\t\\tfor k in range(M):\\n    \\t\\t\\tif m[k][j] != 0: m[k][j] = \\' \\'\\n    \\tfor i,j in itertools.product(range(M),range(N)):\\n    \\t\\tif m[i][j] == \\' \\': m[i][j] = 0\\n\\t\\t\\t\\n\\t\\t\\t\\n```\n```\\nclass Solution:\\n    def setZeroes(self, m: List[List[int]]) -> None:\\n    \\tM, N, = len(m), len(m[0])\\n    \\tR, C = [i for i,j in enumerate(m) if 0 in j], [i for i,j in enumerate(zip(*m)) if 0 in j]\\n    \\tfor i,j in itertools.product(R,range(N)): m[i][j] = 0\\n    \\tfor i,j in itertools.product(C,range(M)): m[j][i] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208830,
                "title": "javascript-o-n-m-time-o-1-space-first-row-col-flags",
                "content": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Time: O(n * m)\\n * Space: O(1)\\n * n - number of rows in matrix\\n * m - number of cols in matrix\\n */\\n\\n/**\\n * @param {number[][]} matrix\\n * @return {void} Do not return anything, modify matrix in-place instead.\\n */\\nfunction setZeroes(matrix) {\\n  let firstColHasZero = false;\\n  let firstRowHasZero = false;\\n\\n  // Check if first col has zero\\n  for (let i = 0; i < matrix.length; i++) {\\n    if (matrix[i][0] === 0) {\\n      firstColHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Check if first row has zero\\n  for (let j = 0; j < matrix[0].length; j++) {\\n    if (matrix[0][j] === 0) {\\n      firstRowHasZero = true;\\n      break;\\n    }\\n  }\\n\\n  // Use first row and col as flags, set matrix[i][0] and matrix[0][j] to 0 if matrix[i][j] is 0\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out cells based on flags in first row and col\\n  for (let i = 1; i < matrix.length; i++) {\\n    for (let j = 1; j < matrix[0].length; j++) {\\n      if (matrix[i][0] === 0 || matrix[0][j] === 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  // Zero out first col\\n  if (firstColHasZero) {\\n    for (let i = 0; i < matrix.length; i++) {\\n      matrix[i][0] = 0;\\n    }\\n  }\\n\\n  // Zero out first row\\n  if (firstRowHasZero) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      matrix[0][j] = 0;\\n    }\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26039,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Set Matrix Zeroes** https://leetcode.com/problems/set-matrix-zeroes/\\n\\n**Algorithm**\\n1. Encode the state of each row in matrix[i,0].\\n2. Encode the state of each col in matrix[0,j].\\n3. During steps 1 and 2, maintain two boolean variables to keep status of row 0 and column 0. Why do we need these variables? Imagine we have matrix[3,4] = 0. We will mark matrix[3,0] and matrix[0,4] as 0. This does not mean we should strike row 0 as zero since no element in row 0 were zero. Hence the two variables.\\n4. While filling, first fill all sections of the matrix except zero row and zero col. Fill zero row and col only if zero_row or zero_col are marked true.\\n\\n```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: void Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n = len(matrix),len(matrix[0])\\n        zero_row, zero_col = False, False\\n\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n                    zero_row = True if i == 0 else zero_row\\n                    zero_col = True if j == 0 else zero_col\\n\\n        for j in range(1,n):\\n            if matrix[0][j] == 0:\\n                for i in range(1, m):\\n                    matrix[i][j] = 0\\n        \\n        for i in range(1,m):\\n            if matrix[i][0] == 0:\\n                for j in range(1, n):\\n                    matrix[i][j] = 0\\n        \\n        if zero_row:\\n            for j in range(n):\\n                matrix[0][j] = 0\\n                \\n        if zero_col:\\n            for i in range(m):\\n                matrix[i][0] = 0\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400855,
                "title": "c-easy-clean-solution-o-1-implementation",
                "content": "**Solution:**\\n\\nApproach\\n1. First check if there is any `0` in the first row or column and set the respective flag(`row, col`) to `1`.\\n2. Now, iterate from `row 2` and `column 2` and check if there is any zero present; fill the first row index `ar[0][j] = 0` and first column index `ar[i][0] = 0`.\\n3. Our first row and first column determine which rows and columns should be fully set to `0`.\\n4. Now, check if flag `row == 1`, means our first row itself should be made `0`.\\n5. Finally, check if flag `col == 1`, means our first column itself should be made `0`.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n**Feel free to share your ideas or any improvements as well.**\\n",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& ar) {\\n        int n = ar.size();\\n        int m = ar[0].size();\\n        int row = 0, col = 0;\\n        for(int i = 0; i < m; i++){\\n            if(ar[0][i] == 0){\\n                row = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 0; i < n; i++){\\n            if(ar[i][0] == 0){\\n                col = 1;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n        }\\n        for(int i = 1; i < n; i++){\\n            for(int j = 1; j < m; j++){\\n                if(ar[i][j] == 0){\\n                    ar[i][0] = 0;\\n                    ar[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i = 1; i < n; i++){\\n            if(ar[i][0] == 0)\\n                for(int j = 0; j < m; j++)\\n                    ar[i][j] = 0;\\n        }\\n        for(int i = 1; i < m; i++){\\n            if(ar[0][i] == 0)\\n                for(int j = 0; j < n; j++)\\n                    ar[j][i] = 0;\\n        }\\n        if(row == 1){\\n            for(int i = 0; i < m; i++)\\n                ar[0][i] = 0;\\n        }\\n        if(col == 1){\\n            for(int i = 0; i < n; i++)\\n                ar[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370007,
                "title": "o-n-space-solution-to-o-1-space-solution-in-c-diagram-included",
                "content": "**We can have a simple trivial solution by maintaining 2 arrays(1 for rows and 1 for columns)**\\n\\nWe traverse the Matrix and if we find a 0 we mark the row and column arrays as 1(in those index), then after traversing the whole array we again traverse the whole array to set the matrix as 0.\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/624d7294-3ebd-4ec4-8987-f8050e3d8ce6_1627550828.8580964.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode : \\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\\n\\n**Optimal solution  (Read the above solution first)**\\n\\nTo Optimize this we use the top row and first column as marked in the diagram, We use top row to store if a column has to be set to 0 and first column to store if we have to set a row to 0\\n\\nTry dry running with this example\\n<img src=\"https://assets.leetcode.com/users/images/cc4db96e-07b1-43f6-bfcc-623f94acb9c6_1627552363.9453866.png\" alt=\"drawing\" width=\"500\"/>\\n\\nCode:\\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```\\n\\nIf you have any doubts hit me in the comments below.\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\tint row[n],col[m]; //This is the matrix where we maintain if 0th row or 3rd column has to be set to 0\\n\\tmemset(row,0,sizeof(row));\\n\\tmemset(col,0,sizeof(col));\\n\\n\\t//if row[index] is set a 1 means we have to set the entire row\\n\\tfor(int i = 0;i<n;i++)\\n\\t{   \\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) row[i] = 1,col[j] = 1;\\n\\t\\t}\\n\\t}\\n\\n\\t//after find which rows and columns have to be set to 0\\n\\t//We just traverse the matrix again and set them as 0;\\n\\tfor(int i = 0;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t\\tif(row[i] == 1 || col[j] == 1)\\n\\t\\t\\t\\tmat[i][j] = 0;\\n\\t}\\n```\n```\\n\\tint n = mat.size(),m = mat[0].size();\\n\\n\\t//Rzero is used to check if the top row has to be set to 0\\n\\tint Rzero = 0,Czero = 0;\\n\\n\\t//Rzero is set to 1 if we have a 0 in the top row\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(mat[i][0] == 0) Rzero = 1;\\n\\n\\t//Same logic is applied for the first column\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(mat[0][i] == 0) Czero = 1;\\n\\n\\t//same the previous solution we store we have to set a row or column to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 0;j<m;j++)\\n\\t\\t{\\n\\t\\t\\tif(mat[i][j]==0) mat[i][0]=mat[0][j]=0;\\n\\t\\t}\\n\\t}\\n\\n\\t//we then actually then set them to 0\\n\\tfor(int i = 1;i<n;i++)\\n\\t{\\n\\t\\tfor(int j = 1;j<m;j++)\\n\\t\\t\\tif(mat[i][0] == 0 || mat[0][j] == 0) mat[i][j] = 0;\\n\\t}\\n\\n\\t//top row and first col are set to 0 \\n\\t//if there was a 0 in them\\n\\tfor(int i = 0;i<n;i++)\\n\\t\\tif(Rzero) mat[i][0] = 0;\\n\\tfor(int i = 0;i<m;i++)\\n\\t\\tif(Czero) mat[0][i] = 0;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1124948,
                "title": "c-clean-o-1-space-sol-detailed-explanation",
                "content": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    \\n    https://leetcode.com/problems/set-matrix-zeroes/solution/\\n    \\n    Idea is to use 1st row and 1st col to save the 0 reset status\\n    for the rows and cols. Now since position [0][0] will overlap\\n    between the row and col status vector, we use 2 separate variables \\n    just to save whether 1st row/col needs a reset or not.\\n    \\n    TC: O(MN)\\n    SC: O(1)\\n*/\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // saves the reset status of row and col resp.\\n        int first_row = matrix[0][0], first_col = matrix[0][0];\\n        // check the first col and row, if either needs a reset to 0\\n        // col check\\n        for(int i = 0; first_col && i < matrix.size(); i++)\\n            if(!matrix[i][0]) \\n                first_col = 0; \\n            \\n        // row check\\n        for(int i = 0; first_row && i < matrix[0].size(); i++)\\n            if(!matrix[0][i]) \\n                first_row = 0; \\n        \\n        // We will use the first row to save all the col status, first \\n        // col to save all the row status\\n        // If some col/row needs a reset, the info will be saved there\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size(); j++) {\\n                if(!matrix[i][j]) \\n                    matrix[0][j] = matrix[i][0] = 0;\\n            }\\n        \\n        // set the 0 values\\n        for(int i = 1; i < matrix.size(); i++)\\n            for(int j = 1; j < matrix[0].size(); j++)\\n                if(!matrix[0][j] || !matrix[i][0])\\n                    matrix[i][j] = 0;\\n        // check if the first row and col needs a reset\\n        if(!first_col) \\n            for(int i = 0; i < matrix.size(); i++)\\n                matrix[i][0] = 0;  \\n        if(!first_row)\\n            for(int i = 0; i < matrix[0].size(); i++)\\n                matrix[0][i] = 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 26040,
                "title": "very-short-python-solution-with-o-1-space-complexity-13-lines-of-code",
                "content": "Idea is as follow:\\nIts only necessary to find out which row and column contains 0. After this step, change all elements in certain row and column to 0. If no 0 exists, do nothing.\\n\\n```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "solutionTags": [],
                "code": "```\\n# Two sets that record which row and column has 0\\nrowSet = set()\\ncolSet = set()\\n# Iterate each element. \\n# If it is 0, record row and column number\\nfor r in range(len(matrix)):\\n    for c in range(len(matrix[0])):\\n        if matrix[r][c] == 0:\\n            rowSet.add(r)\\n            colSet.add(c)\\n# Change all rows containing 0 to 0\\nfor r in rowSet:\\n    for c in range(len(matrix[0])):\\n        matrix[r][c] = 0\\n# Change all columns containing 0 to 0\\nfor c in colSet:\\n    for r in range(len(matrix)):\\n        matrix[r][c] = 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26181,
                "title": "java-constant-space-solution-hint-use-space-inside-the-matrix",
                "content": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "An easy way to solve this problem is to use extra O(m + n) space, storing the zero row and column indices. \\n\\nWe can improve it by not using the extra O(m + n) space, instead, we can use the space inside that input matrix (inspired by **Shangrila**'s solution, which use the first row and column for storage).\\n\\nIn this solution, at the beginning, I find the first zero element, and use that row and column as the temp place for storing the other zero element indices. After we get all the zero indices, then set the corresponding row and columns to zero. Please see the code below.\\n\\n    public void setZeroes(int[][] matrix) {\\n        int rowTemp = -1;   // select a row to store the column indices for the zero element\\n        int colTemp = -1;   // select a column to store the row indices for the zero element\\n        \\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    // find the first zero element\\n                    if (rowTemp == -1) {\\n                        rowTemp = i;\\n                        colTemp = j;\\n                    }\\n                    // update indice in the row and column temp\\n                    else {\\n                        matrix[rowTemp][j] = 0;\\n                        matrix[i][colTemp] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        // no zero in the matrix\\n        if (rowTemp == -1)\\n            return;\\n        // set rows to zero\\n        for (int i = 0; i < matrix.length; i++) {\\n            if (i == rowTemp)   // skip the temp row\\n                continue;\\n            if (matrix[i][colTemp] == 0) {\\n                for (int j = 0; j < matrix[0].length; j++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set columns to zero\\n        for (int j = 0; j < matrix[0].length; j++) {\\n            if (matrix[rowTemp][j] == 0) {\\n                for (int i = 0; i < matrix.length; i++)\\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        // set the final temp row to zero\\n        for (int j = 0; j < matrix[0].length; j++)\\n            matrix[rowTemp][j] = 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3807640,
                "title": "c-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this approach,I have initialsed 2 unordered maps(one for rows and one for columns) for keeping the record weather a row or column contains a zero in it or not.For it I just traversed through the 2D array and once I get a zero, updated the value of that row and column to 1 in map.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversed through the array, if arr[i][j] == 0 then I just set map[i] = 1 and map2[j] = 1.\\nIn second iteration, if any one i and j in matrix is found to be 1, I\\'m updating the value in the original array as 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nFor this code we\\'re just interating the array twice hence the complexity is : O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe\\'re using two maps which are of length N and M.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```\\nYour valuable suggestions and even minor optimizations in the code will be warmly welcomed and greatly appreciated.\\n\\nPlease upvote if you like the solution. :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_map<int,int>ump;\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    ump[i]=1;\\n                    mp[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(ump[i] || mp[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596062,
                "title": "shortest-solution-using-hashset-o-m-n-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Here whenever we find the 0 element in the matrix we add its row and column to the  relative set.\\n- Since its a set data structure , no two same row or column will be added.\\n- Then we iterate through each row and column in the set and fill the matrix with 0\\'s.\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> row = new HashSet<>();\\n        Set<Integer> col = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n        for(int r : row){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[r][i] = 0;\\n            }\\n        }\\n        for(int c : col){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][c] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276573,
                "title": "java-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O ( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O( Math.max( n , m ))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] arr) {\\n        int n = arr.length;\\n        int m = arr[0].length;\\n\\n        int row[] = new int[n];\\n        int col[] = new int[m];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                if( arr[i][j] ==0 )\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            if( row[i]==1 )\\n            {\\n                for (int j = 0; j < m; j++) {\\n                    arr[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if( col[j]==1 )\\n            {\\n                for (int i = 0; i < n; i++) {\\n                    arr[i][j] = 0 ;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840148,
                "title": "c-easy-fast-and-short-9-lines-solution",
                "content": "This solution is very short, simple.\\nThe process is divided into three parts.\\n\\n1. Traverse the matrix and finds 0. If it finds 0, it insert row and column in set `rows`, `cols`.\\n2. Iterate through the row(`rows`) and fill in zeros.\\n3. Iterate through the column(`cols`), fill in zeros.\\n\\n```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// origin - https://github.com/o-oppang/lets-solve-algorithm\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows, cols;\\n        for( auto i = 0; i < matrix.size(); ++i ) // row\\n            for( auto j = 0; j < matrix[0].size(); ++j ) // col\\n                if( matrix[i][j] == 0 )  { rows.insert(i); cols.insert(j); }\\n        \\n        for( auto row : rows ) // fill rows to zero\\n            std::fill(matrix[row].begin(), matrix[row].end(), 0);\\n        \\n        for( auto col : cols ) // fill cols to zero\\n            for( auto row = 0; row < matrix.size(); ++row )\\n                std::fill(matrix[row].begin() + col, matrix[row].begin() + col + 1, 0);\\n    }\\n};\\n// Runtime: 24 ms, faster than 94.25% of C++ online submissions for Set Matrix Zeroes.\\n// Memory Usage: 13.3 MB, less than 49.73% of C++ online submissions for Set Matrix Zeroes.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522715,
                "title": "java-o-1-space-with-explanation",
                "content": "Thinking Processing: \\n1. First, Let\\'s come out O(m+n) Space solution, which is very directly. We need two arrays to store rows and columns status. It looks like a head of a line to check its line\\'s status. When we loop each point, we just need to update its two headers\\' status. If current point\\'s value is 0, we set its headers to true. After finishing all points\\' loop, we loop the matrix again to update the matrix by checking this two arrays\\' info. When we reach a point, we check its x-coordinate and y-coordinate\\'s arrays status, if true, set current point value to 0. \\nHere I draw a picture to show the idea.\\n![image](https://assets.leetcode.com/users/haimei2/image_1582846410.png)\\nHere are the code: \\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\\n2. In order to reduce space, we can apply rows[] and cols[]\\'s role to matrix\\'s first row and first column. When we loop the matrix, we update matrix[i][0] and matrix[0][j] status, like rows and cols array. And then when we need to update the whole matrix, we can udpate point(i,j) value according to matrix[i][0] and matrix[0][j], here i and j are starting from 1!!! So how about the first row and first column point\\'s update? We just need additional two variables to help: two boolean varaibles: firstrow and firstcol. \\n![image](https://assets.leetcode.com/users/haimei2/image_1582847354.png)\\n\\nTest Cases:\\n1. []\\n2. [1]\\n3. [[1,1,1],\\n  [1,0,1],\\n  [1,1,1]]  // without firstrow and firstcol help\\n4. [[0,1,2,0],\\n      [3,4,5,2],\\n      [1,3,1,5]] // with firstrow and firstcol help\\n\\t  \\nTime Complexity is O(m\\\\*n)\\n\\nSpace Complexity is O(1)\\n\\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean[] rows = new boolean[m];\\n        boolean[] cols = new boolean[n];\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]&&cols[j]) continue;\\n                if (matrix[i][j]==0) {\\n                    rows[i] = true;\\n                    cols[j] = true;\\n                }\\n            }\\n        }\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (rows[i]||cols[j]) matrix[i][j] = 0;\\n            }\\n        }\\n    }\\n```\n```java\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        if (m==0) return ;\\n        int n = matrix[0].length;\\n        boolean firstrow = false;\\n        boolean firstcol = false;\\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                    if (i==0) firstrow = true;\\n                    if (j==0) firstcol = true;\\n                }\\n            }\\n        }\\n        for (int i=1; i<m; i++) {\\n            for (int j=1; j<n; j++) {\\n                if (matrix[i][0]==0||matrix[0][j]==0) \\n                    matrix[i][j] = 0;\\n            }\\n        }\\n        if (firstrow) {\\n            for (int j=0; j<n; j++) matrix[0][j] = 0;\\n        }\\n        if (firstcol) {\\n            for (int i=0; i<m; i++) matrix[i][0] = 0;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490917,
                "title": "java-easy-and-short-solution-with-explanation",
                "content": "We plan to use the firstRow and firstCol of the matrix to store the state of entire row and matrix. \\n\\n**BUT**\\n\\nDoing this, we might loose the state of the firstRow and firstCol. So we use two variables isFirstRowZero and isFirstColZero to store the state of irstRow and firstCol and later use it to restore them to their correct state. \\n\\nBelow is the solution is with comments for better understanding :)\\n```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        \\n\\t// The below two vars store the state of first row and first col\\n\\tboolean isFirstRowZero = false , isFirstColZero = false;\\n\\n\\tfor(int i=0; i<matrix.length; i++) \\n\\t\\tfor(int j=0; j<matrix[0].length; j++) \\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tif(i == 0) isFirstRowZero = true;       // Store state of firstRow\\n\\t\\t\\t\\tif(j == 0) isFirstColZero = true;       // Store state of firstCol\\n\\t\\t\\t\\tmatrix[0][j] = 0;                       // Store state of other row in firstRow\\n\\t\\t\\t\\tmatrix[i][0] = 0;                       // Store state of other col in firstCol\\n\\t\\t\\t}\\n\\n\\tfor(int i=1; i<matrix.length; i++) \\n\\t\\tfor(int j=1; j<matrix[0].length; j++)\\n\\t\\t\\tif(matrix[i][0] == 0 || matrix[0][j] == 0)  // If the first cell of row or col is zero \\n\\t\\t\\t\\tmatrix[i][j] = 0;                       // Mark the current cell as 0\\n\\n\\tif(isFirstRowZero)                                  // if entire firstRow is to be zero\\n\\t\\tfor(int i=0; i<matrix[0].length; i++)\\n\\t\\t\\tmatrix[0][i] = 0;                           // make them all zero\\n\\n\\tif(isFirstColZero)                                  // if entire firstCol is to be zero\\n\\t\\tfor(int i=0; i<matrix.length; i++)\\n\\t\\t\\tmatrix[i][0] = 0;                           // make them all zero\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 390800,
                "title": "javascript-solution-memory-usage-beats-90",
                "content": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n  let xs = new Set();\\n  let ys = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j]) {\\n        continue;\\n      } else {\\n        xs.add(i);\\n        ys.add(j);\\n      }\\n    }\\n  }\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (xs.has(i) || ys.has(j)) {\\n        matrix[i][j] = 0;\\n      } else {\\n        continue;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213817,
                "title": "my-4-line-code-for-python",
                "content": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def setZeroes(self, matrix):\\n        points = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[i])) if matrix[i][j] == 0]\\n        for i, a in enumerate(points):\\n            matrix[a[0]] = [0 for k in range(len(matrix[0]))]\\n            for k in range(len(matrix)): matrix[k][a[1]] = 0        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554878,
                "title": "best-o-1-space-solution",
                "content": "# Approach \\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(m * n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void makeRowZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int j = 0; j < col; j++)\\n            matrix[row][j] = 0;    \\n    }  \\n    void makeColZero(vector<vector<int>>& matrix, int row, int col) {\\n        for (int i = 0; i < row; i++)\\n            matrix[i][col] = 0;    \\n    }    \\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int r = matrix.size(), c = matrix[0].size();\\n        int col0 = 1;\\n        for (int i = 0; i < r; i++) {\\n            for (int j = 0; j < c; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    if (j != 0)\\n                        matrix[0][j] = 0;\\n                    else\\n                        col0 = 0;      \\n                }\\n            }\\n        }\\n        for (int j = 1; j < c; j++) {\\n            if (matrix[0][j] == 0) \\n                makeColZero(matrix, r, j);\\n        }\\n        for (int i = 0; i < r; i++) {\\n            if (matrix[i][0] == 0) \\n                makeRowZero(matrix, i, c);\\n        }\\n        if (col0 == 0)\\n            makeColZero(matrix, r, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365254,
                "title": "using-same-matrix-o-m-n-easy-to-understand-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'ll use 0th column and 0th row to set all other rows and column to zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.First we\\'ll traverse thorugh first row and first column of the matrix(0th row and 0th column).\\nWhenever we find 0 in this row we\\'ll set isrow0 to true.\\nSimilarly, whenever we find 0 in this column we\\'ll set iscol0 to true.\\nThis will be used later.\\n2.Now we\\'ll go through the entire matrix(Except the 0th row and 0th column).\\nWhenever 0 is encountered we\\'ll set that row\\'s first column\\'s element to 0.\\nSimilarly, we\\'ll set that column\\'s first row\\'s element to 0.\\n3.After that, we go through the matrix one more time and for any row or column where the first element is zero, we set all of the other elements in that row or column to zero as well.\\n4.lastly, we\\'ll set the entire 0th row and 0th column to zero if isrow0 and iscol0 is true respectively.\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m=matrix.length,n=matrix[0].length;\\n        boolean isrow0=false,iscol0=false;\\n        int i,j;\\n        for(i=0;i<m;i++)\\n        {\\n          if(matrix[i][0]==0)\\n          {\\n            isrow0=true;\\n          }\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n          if(matrix[0][i]==0)\\n          {\\n            iscol0=true;\\n          }\\n        }\\n        for(i=1;i<m;i++)\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][j]==0)\\n            {\\n              matrix[0][j]=0;//0th row of column j\\n              matrix[i][0]=0;//0th column of row i\\n            }\\n          }\\n        }\\n        for(i=1;i<m;i++)//traversing again\\n        {\\n          for(j=1;j<n;j++)\\n          {\\n            if(matrix[i][0]==0 || matrix[0][j]==0)\\n            {\\n              matrix[i][j]=0;\\n            }\\n          }\\n        }\\n        if(isrow0)\\n        {\\n          for(i=0;i<m;i++)\\n          {\\n            matrix[i][0]=0;\\n          }\\n        }\\n        if(iscol0)\\n        {\\n          for(j=0;j<n;j++)\\n          {\\n            matrix[0][j]=0;\\n          }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289339,
                "title": "short-easy-very-clearly-explained-step-by-step-python",
                "content": "# SOLUTION\\n\\n```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```\\n# STEP-BY-STEP EXPLANATION\\n    zero_rows, zero_cols = set(), set()\\nTwo empty sets, zero_rows and zero_cols, are created to store the indices of the rows and columns with a zero value.\\n\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n\\nLoops through the entire matrix and checks each element to see if it is zero. If it is, the index of the row and column are added to their respective sets, zero_rows and zero_cols.\\n\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n\\nNext loop goes through each index in zero_rows and sets the entire row to zero by creating a new list of zeros with the same length as the row and assigning it to the row.\\n\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\nLast loop goes through each index in zero_cols and sets the entire column to zero by looping through each row and setting the value at that column index to zero.\\n\\nThat\\'s it!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def setZeroes(self, matrix):\\n    zero_rows, zero_cols = set(), set()\\n    for i in range(len(matrix)):\\n        for j in range(len(matrix[0])):\\n            if matrix[i][j] == 0:\\n                zero_rows.add(i)\\n                zero_cols.add(j)\\n    for i in zero_rows:\\n        matrix[i] = [0] * len(matrix[0])\\n    for j in zero_cols:\\n        for i in range(len(matrix)):\\n            matrix[i][j] = 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2970925,
                "title": "c-easy-to-understand-using-two-vectors",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n        \\n        int r = arr.size();\\n        int c = arr[0].size();\\n\\n        vector<int> xr,yc;\\n\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j =0;j<c;j++)\\n            {\\n                if(arr[i][j] == 0)\\n                {\\n                    xr.push_back(i);\\n                    yc.push_back(j);\\n                }\\n            }\\n        }\\n\\n        for(auto row : xr)\\n        {\\n            for(int col = 0;col<c;col++)\\n            arr[row][col] = 0;\\n        }\\n\\n        for(auto col : yc)\\n        {\\n            for(int row = 0;row<r;row++)\\n            arr[row][col] = 0;\\n        }\\n        \\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1933016,
                "title": "java-brute-better-optimised-3-approaches-added-explanation-for-3rd",
                "content": "### **1. Naive Approach**\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\\n\\n**TC = O(N^3) in worst case if matrix is of order N x N.**\\n**SC = O(N^2) in worst case if matrix is of order N x N.**\\n**Runtime 3ms, faster than 25%.**\\n\\n### **2. Better Approach**\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\\n**TC = O(M x N), since all set operations used above take O(1) time.**\\n**SC = O(M + N).**\\n**Runtime 4ms, faster than 18%.**\\n\\n### **3. Optimised approach**\\n\\nHere we will consider the dummy row array and dummy column array (as used in approach 2) as row 0 and column 0 of the matrix, for checking whether the particular column or row has the value 0 or not.\\nSince matrix[0][0] are overlapping, therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.\\nNow traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0, else continue.\\n\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```\\n\\n**TC = O(M x N).**\\n**SC = O(1).**\\n**Runtime 1ms, faster than 89%.**\\n\\n**Plz upvote if you find it helpful.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        boolean[][] arr = new boolean[m][n];\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0)\\n                    arr[row][col] = true;\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(arr[row][col] == true){\\n                    helperRow(matrix, row, n);\\n                    helperCol(matrix, col, m);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void helperRow(int[][] matrix, int row, int n){\\n        for(int col = 0; col < n; ++col)\\n            matrix[row][col] = 0;\\n    }\\n    \\n    public void helperCol(int[][] matrix, int col, int m){\\n        for(int row = 0; row < m; ++row)\\n            matrix[row][col] = 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        Set<Integer> rows = new HashSet<>();\\n        Set<Integer> cols = new HashSet<>();\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(matrix[row][col] == 0){\\n                    rows.add(row);\\n                    cols.add(col);\\n                }\\n            }\\n        }\\n        \\n        for(int row = 0; row < m; ++row){\\n            for(int col = 0; col < n; ++col){\\n                if(rows.contains(row) || cols.contains(col))\\n                    matrix[row][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int col0 = 1;\\n        \\n        for(int row = 0; row < m; ++row){\\n            if(matrix[row][0] == 0)\\n                col0 = 0;\\n            \\n            for(int col = 1; col < n; ++col)\\n                if(matrix[row][col] == 0)\\n                    matrix[row][0] = matrix[0][col] = 0;\\n        }\\n        \\n        for(int row = m - 1; row >= 0; --row){\\n            for(int col = n - 1; col >= 1; --col)\\n                if(matrix[row][0] == 0 || matrix[0][col] == 0)\\n                    matrix[row][col] = 0;\\n            \\n            if(col0 == 0)\\n                matrix[row][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790756,
                "title": "c-solution-using-set-easy-fast-simple-91-38-12ms-13-4-mb",
                "content": "![image](https://assets.leetcode.com/users/images/ce857028-f902-4df8-b7c2-f9a4c5b72bde_1645509329.445337.png)\\n\\nSteps involved\\n1. Iterate once to store all rows and columns containing a `0` in two separate sets.\\n2. Iterate through set `rows` to make all elements with given row, making all elements 0\\n3. Iterare through set `cols` to make all element with given column, making all elements 0\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rows;\\n        set<int> cols;\\n        for(int i = 0; i < matrix.size(); i++)\\n            for(int j = 0; j < matrix[0].size();j++)\\n                if(matrix[i][j] == 0) {\\n                    rows.insert(i);\\n                    cols.insert(j);\\n                }\\n\\n        for(auto x: rows) \\n            for(int j = 0; j < matrix[0].size();j++) \\n                    matrix[x][j] = 0;\\n\\n        for(auto x: cols) \\n            for(int i = 0; i < matrix.size(); i++) \\n                matrix[i][x] = 0;\\n  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1205739,
                "title": "java-array-1ms-beats-93-t-c-o-m-n-s-c-o-1",
                "content": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(m*n) O(1)\\n\\tpublic void setZeroes(int[][] matrix) {\\n\\n\\t\\tint m = matrix.length, n = matrix[0].length;\\n\\t\\tboolean row = false, col = false;\\n\\n        for (int i = 0; i < m; i++) {\\n\\t\\t\\tif (matrix[i][0] == 0) {\\n\\t\\t\\t\\tcol = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (matrix[0][i] == 0) {\\n\\t\\t\\t\\trow = true;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < m; i++) {\\n\\t\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\t\\tif (matrix[i][0] == 0 || matrix[0][j] == 0)\\n\\t\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tif (row == true) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tmatrix[0][i] = 0;\\n\\t\\t}\\n\\n\\t\\tif (col == true) {\\n\\t\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t}\\n\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 917943,
                "title": "my-very-simple-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n\\n        def changeRC(r,c):\\n            \\n            for col in range(len(matrix[0])):\\n                matrix[r][col]=\\'X\\' if matrix[r][col]!=0 else 0\\n            for row in range(len(matrix)):\\n                matrix[row][c]=\\'X\\' if matrix[row][c]!=0 else 0\\n\\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==0:\\n                    changeRC(r,c)\\n        \\n        for r in range(len(matrix)):\\n            for c in range(len(matrix[0])):\\n                if matrix[r][c]==\\'X\\':\\n                    matrix[r][c]=0\\n                    \\n        #return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691293,
                "title": "javascript-human-readable-solution",
                "content": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar setZeroes = function(matrix) {\\n    const zeroRow = new Set();\\n    const zeroCol = new Set();\\n    \\n    for(let i = 0; i < matrix.length; i++) {\\n        \\n        for(let j = 0; j < matrix[0].length; j++) {\\n            \\n            if(matrix[i][j] === 0) {\\n                zeroRow.add(i);\\n                zeroCol.add(j);\\n            }\\n        }\\n    }\\n    \\n    for(let r of zeroRow) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            matrix[r][j] = 0;\\n        }\\n    }\\n    \\n    for(let c of zeroCol) {\\n        for(let i = 0; i < matrix.length; i++) {\\n            matrix[i][c] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26056,
                "title": "java-2-solutions-space-o-1-and-o-m-n-with-explaination",
                "content": "space O(1), time O(mn)\\nUse the top row and the left column to record which rows and columns need to be set 0. topZero and leftZero to record whether we need to set  the top row and the left column to zero before finished.\\n```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\\nspace O(m+n), time O(mn)\\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        boolean topZero=false, leftZero=false;\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    if(i==0) topZero = true;\\n                    if(j==0) leftZero = true;\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        for(int i=1; i<M; i++){\\n            if(matrix[i][0]==0){\\n                for(int q=1; q<N; q++) matrix[i][q] = 0;\\n            }\\n        }\\n        for(int j=1; j<N; j++){\\n            if(matrix[0][j]==0){\\n                for(int p=1; p<M; p++)  matrix[p][j] = 0;\\n            }\\n        }\\n        if(topZero){\\n            for(int q=0; q<N; q++) matrix[0][q] = 0;\\n        }\\n        if(leftZero){\\n            for(int p=0; p<M; p++) matrix[p][0] = 0;\\n        }\\n    }\\n```\n```    \\n    public void setZeroes_Set(int[][] matrix) {\\n        if(matrix==null) return;\\n        final int M=matrix.length, N=matrix[0].length;\\n        Set<Integer> rowSet = new HashSet<>();\\n        Set<Integer> colSet = new HashSet<>();\\n        for(int i=0; i<M; i++){\\n            for(int j=0; j<N; j++){\\n                if(matrix[i][j]==0){\\n                    rowSet.add(i);\\n                    colSet.add(j);\\n                }\\n            }\\n        }\\n        for(int row : rowSet)\\n            for(int j=0; j<N; j++)\\n                matrix[row][j] = 0;\\n        for(int col : colSet)\\n            for(int i=0; i<M; i++)\\n                matrix[i][col] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26070,
                "title": "simple-in-place-solution-yet-still-best-submission-in-c",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) \\n        {\\n            if(matrix.empty()) return ;\\n            int rowSize = matrix.size(), colSize = matrix[0].size();\\n            bool firstRow = false, firstCol = false;\\n            for(int c = 0; c < colSize; ++c) if(matrix[0][c] == 0) firstRow = true;\\n            for(int r = 0; r < rowSize; ++r) if(matrix[r][0] == 0) firstCol = true;\\n            for(int r = 1; r < rowSize; ++r)\\n                for(int c = 1; c < colSize; ++c)\\n                    if(matrix[r][c] == 0) matrix[0][c] = matrix[r][0] = 0;\\n            for(int c = 1; c < colSize; ++c) \\n                if(matrix[0][c] == 0)\\n                    for(int r = 1; r < rowSize; ++r)\\n                        matrix[r][c] = 0;\\n            for(int r = 1; r < rowSize; ++r) \\n                if(matrix[r][0] == 0)\\n                    for(int c = 1; c < colSize; ++c)\\n                        matrix[r][c] = 0;\\n            if(firstRow) for(int c = 0; c < colSize; ++c) matrix[0][c] = 0;\\n            if(firstCol) for(int r = 0; r < rowSize; ++r) matrix[r][0] = 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 26111,
                "title": "python-easy-inplace-solution",
                "content": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "solutionTags": [
                    "Python"
                ],
                "code": "Make first row and first column to mark which row and column should be zero before filling them out, then fill the matrix from right to left, and make the first row zero in the last if first row has any zero.\\n\\n    def setZeroes(self, matrix):\\n        firstRowHasZero = not all(matrix[0])\\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j] == 0:\\n                    matrix[0][j] = 0\\n                    matrix[i][0] = 0\\n        \\n        for i in range(1,len(matrix)):\\n            for j in range(len(matrix[0])-1,-1,-1):\\n                if matrix[0][j] == 0 or matrix[i][0] == 0:\\n                    matrix[i][j] = 0\\n        \\n        if firstRowHasZero:\\n            matrix[0] = [0]*len(matrix[0])",
                "codeTag": "Python3"
            },
            {
                "id": 3881749,
                "title": "easy-to-understand-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<pair<int,int>> temp;\\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[i].size();j++){\\n                if(matrix[i][j]==0)\\n                {\\n                    temp.push_back(make_pair(i,j));\\n                }\\n            }\\n        }\\n        for(int i=0; i<temp.size();i++){\\n            int row=temp[i].first;\\n            int col=temp[i].second;\\n            for(int j=0;j<matrix.size();j++){\\n                for(int k=0;k<matrix[j].size();k++){\\n                    if(j==row)\\n                    matrix[j][k]=0;\\n                    if(k==col)\\n                    matrix[j][k]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742996,
                "title": "simple-solution-using-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m+n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```\\n![leetcode.jpeg](https://assets.leetcode.com/users/images/b3c5af72-8a7d-4763-a72c-8a2242a871cd_1688997851.1284735.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        // we will keep the rows and col of 0 value \\n        set<int>r;\\n        set<int>c;\\n        int rows=matrix.size();\\n        int cols=matrix[0].size();\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n\\n        //now comes the part of making rows and col = 0\\n        //for rows\\n        for(auto i:r){\\n            for(int j=0;j<cols;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n\\n        // for cols\\n        for(auto j:c){\\n            for(int i=0;i<rows;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713783,
                "title": "python-easy-solution-with-clear-explanation-with-example",
                "content": "# Intuition\\nHere, our intuition is to make every row and column zero if there is a zero present in that row. To accomplish this, we need to follow these steps:\\n\\n# Approach\\n\\nStep 1: Append the indices to a list where there is a zero.\\nFor example, given the list [[0,1,2,0],[3,4,5,2],[1,3,1,5]], the list of indices would be [0, 3].\\n\\nThis list is created because:\\ni) If there is a zero in a nested list, we make the entire list zero.\\nii) If a zero is not present in a row, but it is present in another row in the same column, we make that column zero for every nested list.\\n\\nTo perform this, we use two separate for loops:\\n- The first loop is used to get the indices of the zeros in the nested list and store them in `zero_cols`.\\n- The second loop is used to update the values to zero based on the conditions mentioned above.\\n\\n![WhatsApp Image 2023-07-05 at 9.36.31 AM.jpeg](https://assets.leetcode.com/users/images/7a38df5b-365f-4c72-b52f-ff7a570791c5_1688530121.9454794.jpeg)\\n\\n# **Kindly do a upvote if you find it usefull and a comment if found any mistake\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83D\\uDE4F\\uD83C\\uDFFB\\uD83E\\uDEC2**\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        l_c = []\\n\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n                if matrix[i][j] == 0:\\n                    l_c.append(j)\\n\\n        for i in range(len(matrix)):\\n            if 0 in matrix[i]:\\n                for ii in range(len(matrix[i])):\\n                    matrix[i][ii] = 0\\n            else:\\n                for _ in l_c:\\n                    matrix[i][_] = 0\\n        return matrix\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663211,
                "title": "c-beats-91-30-runtime-beats-99-23-memory-2-methods-brute-force-optimal-solution",
                "content": "# Code\\n```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n# Code\\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// OPTIMAL SOLUTION\\n/*\\nTC : O(n*m)\\nSC : O(1)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool firstRowZero = false;\\n        bool firstColZero = false;\\n        \\n        // Check if the first row and first column need to be set to zero\\n        for (int j = 0; j < m; j++) { // TC: O(m)\\n            if (matrix[0][j] == 0) {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; i++) { // TC: O(n)\\n            if (matrix[i][0] == 0) {\\n                firstColZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // Mark the corresponding entry in the first row and first column as zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the elements in rows and columns (excluding the first row and first column) to zero\\n        for (int i = 1; i < n; i++) { // TC: O(n*m)\\n            for (int j = 1; j < m; j++) {\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        // Set the first row to zero if necessary\\n        if (firstRowZero) { // TC: O(m)\\n            for (int j = 0; j < m; j++) {\\n                matrix[0][j] = 0;\\n            }\\n        }\\n        \\n        // Set the first column to zero if necessary\\n        if (firstColZero) { // TC: O(n)\\n            for (int i = 0; i < n; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n// BRUTE FORCE\\n/*\\nTC : O(n*m)\\nSC : O(n + m)\\n*/\\nclass Solution {\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n\\n        vector<int> row(n, 0); // SC: O(n)\\n        vector<int> col(m, 0); // SC: O(m)\\n\\n        // mark the row and col corresponding to element 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(matrix[i][j] == 0) {\\n                    row[i] = 1;\\n                    col[j] = 1;\\n                }\\n            }\\n        }\\n\\n        // set all row and col as 0\\n        for(int i = 0; i < n; i++) { // TC: O(n*m)\\n            for(int j = 0; j < m; j++) {\\n                if(row[i] || col[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610821,
                "title": "java-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n## Step 1\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = false\\ncol = true\\n\\n## Step 2\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 3 | 4 | 5 | 2 |\\n| 1 | 3 | 1 | 5 |\\n\\nrow = true\\ncol = true\\n\\n## Step 3 and so on\\n\\n| 0 | 1 | 2 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n| 0 | 0 | 0 | 0 |\\n|---|---|---|---|\\n| 0 | 4 | 5 | 2 |\\n| 0 | 3 | 1 | 5 |\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int n = matrix.length;\\n        int m = matrix[0].length;\\n        boolean row = false;\\n        boolean col = false;\\n\\n        for (int i = 0; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                col = true;\\n                break;\\n            }\\n        }\\n\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                row = true;\\n                break;\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (matrix[i][j] == 0) {\\n                    matrix[0][j] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[i][0] = 0;\\n                    matrix[i][0] = 0; // \\u041E\\u0448\\u0438\\u0431\\u043A\\u0430: \\u0417\\u0434\\u0435\\u0441\\u044C \\u043D\\u0443\\u0436\\u043D\\u043E \\u0438\\u0441\\u043F\\u043E\\u043B\\u044C\\u0437\\u043E\\u0432\\u0430\\u0442\\u044C matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i = 1; i < n; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j = 1; j < m; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[0][j] == 0) {\\n                for (int i = 1; i < n; i++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n\\n        if (col) {\\n            cleanZeroCol(matrix, n);\\n        }\\n\\n        if (row) {\\n            cleanZeroRow(matrix, m);\\n        }\\n    }\\n\\n    private void cleanZeroCol(int[][] matrix, int n) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n    private void cleanZeroRow(int[][] matrix, int m) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554849,
                "title": "most-optimal-solution-using-in-place-or-constant-space-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  void setZeroes(vector<vector<int>> &matrix)\\n  {\\n    int n = matrix.size();\\n    int m = matrix[0].size();\\n    int col0 = 1;\\n    for (int i = 0; i < n; i++)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        if (matrix[i][j] == 0)\\n        {\\n\\n          matrix[i][0] = 0;\\n\\n          if (j != 0)\\n            matrix[0][j] = 0;\\n          else\\n            col0 = 0;\\n        }\\n      }\\n    }\\n\\n    for (int i = 1; i < n; i++)\\n    {\\n      for (int j = 1; j < m; j++)\\n      {\\n        if (matrix[i][j] != 0)\\n        {\\n\\n          if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n          {\\n            matrix[i][j] = 0;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (matrix[0][0] == 0)\\n    {\\n      for (int j = 0; j < m; j++)\\n      {\\n        matrix[0][j] = 0;\\n      }\\n    }\\n    if (col0 == 0)\\n    {\\n      for (int i = 0; i < n; i++)\\n      {\\n        matrix[i][0] = 0;\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306062,
                "title": "optimize-solution-in-constant-space",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean isRow0Zero = false, isCol0Zero =false;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n\\n        // check if first column need to set zero\\n        for(int i =0; i< m; i++) {\\n            if(matrix[i][0] == 0) {\\n                isCol0Zero = true;\\n                break;\\n            }\\n        }\\n\\n      // check if first row need to set zero\\n        for(int i =0; i< n; i++) {\\n            if(matrix[0][i] == 0) {\\n                isRow0Zero = true;\\n                break;\\n            }\\n        }\\n\\n\\n       for(int i=1; i<m; i++) {\\n           for(int j=1;j<n;j++) {\\n               if(matrix[i][j] == 0) {\\n                   matrix[i][0] = 0;\\n                   matrix[0][j] = 0;\\n               }\\n           }\\n       }\\n\\n\\n        for(int i=1; i<m; i++) {\\n            for(int j=1;j<n;j++) {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                  matrix[i][j] = 0;\\n                }\\n           }\\n        }\\n\\n        if(isRow0Zero) {\\n            for(int i=0;i <n; i++) \\n                 matrix[0][i] = 0;\\n        }\\n\\n        if(isCol0Zero) {\\n            for(int i=0;i <m; i++) \\n                 matrix[i][0] = 0;\\n        }\\n    \\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217274,
                "title": "python-easy-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, mat: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        m,n=len(mat),len(mat[0])\\n        r=c=0\\n#Storing the index of 0th element in first row and column\\n        for i in range(m):\\n            for j in range(n):\\n                if mat[i][j]==0:\\n                    if i==0:\\n                        r=1\\n                    if j==0:\\n                        c=1   \\n                    mat[i][0]=mat[0][j]=0\\n        \\n#If first row or column is marked with 0 the then marking all the elements in that row or column as 0\\n        for i in range(1,m):\\n            for j in range(1,n):\\n                if mat[i][0]==0 or mat[0][j]==0:\\n                    mat[i][j]=0\\n#If first row or column as 0 then making all elements in first row or column as 0\\n        if r==1:\\n            for j in range(n):\\n                mat[0][j]=0\\n        if c==1:\\n            for i in range(m):\\n                mat[i][0]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182406,
                "title": "store-indices",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int> r,c;\\n        int i,j,m = matrix.size(),n = matrix[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(!matrix[i][j]){\\n                    r.insert(i);\\n                    c.insert(j);\\n                }\\n            }\\n        }\\n        for(auto &i: r){\\n            for(j = 0; j < n; j++){\\n                matrix[i][j] = 0;\\n            }\\n        }for(auto &i: c){\\n            for(j = 0; j < m; j++){\\n                matrix[j][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3164326,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int c=1;\\n        for(int i=0;i<row;i++){\\n             if(mat[i][0]==0)\\n             c=0;\\n            for(int j=1;j<col;j++){\\n                if(mat[i][j]==0){\\n                    mat[0][j]=0;\\n                    mat[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=row-1;i>=0;i--){\\n            for(int j=col-1;j>0;j--)\\n            if(mat[i][0]==0||mat[0][j]==0)\\n            mat[i][j]=0;\\n            if(c==0)\\n            mat[i][0]=0;\\n        }\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        zeroRowIndexes = set()\\n        zeroColIndexes = set()\\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if matrix[i][j] == 0:\\n                    zeroRowIndexes.add(i)\\n                    zeroColIndexes.add(j)\\n        for i in range(m):\\n            for j in range(n):\\n                if i in zeroRowIndexes or j in zeroColIndexes:\\n                    matrix[i][j] = 0\\n```\n```Java []\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n        \\n        for(int i = 0; i < rows; i++){\\n            if(matrix[i][0] == 0) col0 = 0;\\n            for(int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n        }\\n        \\n        for(int i = rows - 1; i >= 0; i--){\\n            for(int j = cols - 1; j >= 1; j --)\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                    matrix[i][j] = 0;\\n            if (col0 == 0) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091387,
                "title": "1000-views-best-solution-concise-precise-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size();\\n       vector<pair<int,int>> mp;\\n        for(int i=0;i<rows;i++)\\n            for(int j=0;j<cols;j++)\\n                if(matrix[i][j]==0) mp.push_back(make_pair(i,j));\\n\\n        for(auto i:mp){\\n            int j=0;\\n            while(j<cols){\\n                matrix[i.first][j]=0;\\n                j++;\\n            }\\n            j=0;\\n              while(j<rows){\\n                matrix[j][i.second]=0;\\n                j++;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2986079,
                "title": "simple-python-solution-easy",
                "content": "# Approach\\n* Create 2 sets to track which column and row needs to be updated\\n* Update original matrix using the sets\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$\\n\\n- Space complexity:\\n$$O(m+n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n        col = set()\\n        row = set()\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[0])):\\n                if matrix[i][j]==0:\\n                    col.add(j)\\n                    row.add(i)\\n        \\n        for i in row:\\n            for j in range(len(matrix[0])):\\n                matrix[i][j]=0\\n        for i in range(len(matrix)):\\n            for j in col:\\n                matrix[i][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939166,
                "title": "beginner-s-solutions",
                "content": "# Intuition\\nSo, you might think that this question must have some optimized solution but believe me the brute force is the only approach which will give you minimum time complexity ..\\n\\n# Approach\\nWe will declare two vectors if you don\\'t know about vectors you can declare two arrays too. First of all we will traverse entire matrix (using two for loops) and then find which row and column has a 0. We will note that in our arrays/vectors which were keeping track of 0\\'s.\\nThen we will again use two for loops to assign the 0\\'s to respective index with help of our two arrays/vectors which were keeping track of 0\\'s. And yup this is it ..\\n\\n# Complexity\\n- Time complexity:\\nO(2 x n x m) \\nWhere n is number of rows and m is number of columns and we traversed the entire matrix twice hence 2 in multiplication.\\n\\n- Space complexity:\\nO(n+m)\\nWhere n is number of rows and m is number of columns as we declared two arrays/vectors of this size.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int> row(n,0);\\n        vector<int> col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]>0){\\n                    matrix[i][j]=0;\\n                }\\n                if(col[j]>0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2804366,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row;\\n        vector<int> col;\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row.push_back(i);\\n                    col.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<row.size();i++){\\n            for(int j=0;j<n;j++){\\n                matrix[row[i]][j]=0;\\n            }\\n        }\\n        for(int i=0;i<col.size();i++){\\n            for(int j=0;j<m;j++){\\n                matrix[j][col[i]]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596094,
                "title": "python-o-1-space-solution",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        n = len(matrix)\\n        m = len(matrix[0])\\n        col = True\\n        \\n        for i in range(n):\\n            if matrix[i][0] == 0:\\n                col = False\\n            for j in range(1, m):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0  \\n\\t\\t\\t\\t\\t\\n        for i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2320399,
                "title": "all-the-approach-for-this-question",
                "content": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/b97eba51-d299-4817-86b2-fef17ba46fe8_1658557435.2364733.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2310610,
                "title": "c-brutforce-to-optimal",
                "content": "Approach: Using brute force\\n\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nBetter approach\\n\\nIntuition: Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\nApproach:Take two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\\n\\nOptimizing the better approach.\\n\\nIntuition: Instead of taking two dummy arrays we can use the first row and column of the matrix for the same work. This will help to reduce the space complexity of the problem. While traversing for the second time the first row and column will be computed first, which will affect the values of further elements that\\u2019s why we traversing in the reverse direction.\\n\\nApproach:Instead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.Since matrix[0][0] are overlapping.Therefore take separate variable col0(say) to check if the 0th column has 0 or not and use matrix[0][0] to check if the 0th row has 0 or not.Now traverse from last element to the first element and check if matrix[i][0]==0 || matrix[0][j]==0 and if true set matrix[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    //checking if 0 is present in the 0th column or not\\n    if (matrix[i][0] == 0) col0 = 0;\\n    for (int j = 1; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        matrix[i][0] = 0;\\n        matrix[0][j] = 0;\\n      }\\n    }\\n  }\\n  //traversing in the reverse direction and\\n  //checking if the row or col has 0 or not\\n  //and setting values of matrix accordingly.\\n  for (int i = rows - 1; i >= 0; i--) {\\n    for (int j = cols - 1; j >= 1; j--) {\\n      if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n    if (col0 == 0) {\\n      matrix[i][0] = 0;\\n    }\\n\\n  }\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2281086,
                "title": "c-solution-2-approaches-with-explanation",
                "content": "**Approach 1 (using extra space)**\\n\\nThis Approach will use two boolean 1 dimensional matrices, named rowZero and colZero.\\n- rowZero[i] and colZero[j] will indicate if matrix[i][j] == 0. That is, for each column and row we are storing if it contains a 0 or not in the first traversal. If it contains a 0, mark it as true.\\n- In the second traversal, for each matrix[i][j], if rowZero[i] is true OR colZero[j] is true, then we place a 0 at matrix[i][j]. \\n- Else keep matrix[i][j] as it is.\\n- Time Complexity: 2 * O(M*N)\\n- Space Complexity: O(M) + O(N)\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\\n**Approach 2 (O(1) SPACE)**\\nWe will use two bool variables rowZero and colZero to store whether first row or col has a 0 or not. Then we use first row and first col itself to store whether the remaining rows/cols has zero or not. That is, instead of creating two separate arrays like in first approach, we will instead use the first row and first column of the given matrix itself. This will reduce space complexity to constant space **O(1)**. \\n**Time Complexity will remain O(M*N)**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```\\n\\nPLEASE UPVOTE\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        vector<bool> rowZero(rowSize);\\n        vector<bool> colZero(colSize);\\n        \\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(matrix[i][j] == 0) {\\n                    rowZero[i] = true;\\n                    colZero[j] = true;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rowSize;i++){\\n            for(int j=0;j<colSize;j++){\\n                if(rowZero[i] == true || colZero[j] == true) matrix[i][j] = 0;\\n            }\\n        }        \\n    }\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n        \\n        bool rowZero = false, colZero = false;\\n        int rowSize = matrix.size(), colSize = matrix[0].size();\\n        \\n        // check for first col\\n        for(int i=0;i<rowSize;i++){\\n            if(matrix[i][0] == 0){\\n                colZero = true;\\n                break;\\n            }\\n        }\\n        \\n        // check for first row \\n        for(int j=0;j<colSize;j++){\\n            if(matrix[0][j] == 0){\\n                rowZero = true;\\n                break;\\n            }\\n        }\\n        // mark 0 in first row/col where the remaining part of matrix has zero or not.\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        // setting the matrix as 0 wherever required except the first row or col\\n        for(int i=1;i<rowSize;i++){\\n            for(int j=1;j<colSize;j++){\\n                if(matrix[0][j] == 0|| matrix[i][0] == 0) matrix[i][j] = 0;\\n            }\\n        }\\n        \\n        if(rowZero){\\n            for(int j=0;j<colSize;j++) matrix[0][j] = 0;\\n        }\\n        if(colZero){\\n            for(int i=0;i<rowSize;i++) matrix[i][0] = 0;\\n        }\\n               \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2224337,
                "title": "c-solution-easy",
                "content": "Hope this helps : )\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nMake sure to upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<vector<int>> temp = matrix;\\n        for(int i = 0; i<matrix.size();i++){\\n            for(int j = 0;j<matrix[0].size();j++){\\n                if(temp[i][j] == 0){\\n                    for(int row = 0;row<matrix[0].size();row++){\\n                        matrix[i][row] = 0;\\n                    }\\n                    for(int col = 0;col<matrix.size();col++){\\n                        matrix[col][j] = 0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191071,
                "title": "java-solution-using-hashset",
                "content": "**Algorithm**\\n* Make two hashset which will store row index and col index of 0s.\\n* First iterate through row hashset, and make all the elements of that particular row as 0.\\n* Similarly, repeat the process with col hashset for col rows.\\n\\nTime Complexity: O(mn)\\n\\n**Code**\\n```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void setZeroes(int[][] matrix) {\\n        HashSet<Integer> row = new HashSet<>();\\n        HashSet<Integer> col = new HashSet<>();\\n        for(int i=0; i<matrix[0].length; i++){\\n            for(int j=0; j<matrix.length; j++){\\n                if(matrix[j][i] == 0) {\\n                    col.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for(int i=0; i<matrix.length; i++){\\n            for(int j=0; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0) {\\n                    row.add(i);\\n                    break;\\n                }\\n            }\\n        }\\n        for (int ele : row) {\\n            for(int j=0; j<matrix[0].length; j++){\\n                matrix[ele][j] = 0;\\n            }\\n        }\\n        for (int ele : col) {\\n            for(int j=0; j<matrix.length; j++){\\n                matrix[j][ele] = 0;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2189679,
                "title": "c-10ms-using-unordered-sets",
                "content": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "void setZeroes(vector<vector<int>>& matrix) {\\n    unordered_set<int> rows, cols;\\n        \\n    for(int i = 0; i < matrix.size(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            if(!matrix[i][j]){\\n                rows.insert(i);\\n                cols.insert(j);\\n            }\\n        }\\n    }\\n        \\n    for(auto i = rows.begin(); i != rows.end(); i++){\\n        for(int j = 0; j < matrix[0].size(); j++){\\n            matrix[*i][j] = 0;\\n        }\\n    }\\n        \\n    for(auto i = cols.begin(); i != cols.end(); i++){\\n        for(int j = 0; j < matrix.size(); j++){\\n            matrix[j][*i] = 0;\\n        }\\n    }\\n}\\t\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2076696,
                "title": "o-m-n-solution-in-cpp-o-1-space-complexity",
                "content": "Here, instead of using an extra space, we use the first column and first row of corresponding matrix to mark our zeros. Once that is done we will just go through the first row and first column and mark all the elements in their respective columns and row as zero...\\nThis would have a corner case of first row or first column or first element being zero. For that we will use three flags to mark them and adust our matrix after the previous operation is done with...\\n\\n**Pls Upvote this thread if you found the explanation helpful**\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix[0].size(), n=matrix.size();\\n        bool row=false, col=false, first=!(matrix[0][0]);\\n        \\n        //Checking if first row contains any zeros\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                row=true;\\n                break;\\n            }\\n        }\\n        \\n        //Checking if first column contains any zeros\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                col=true;\\n                break;\\n            }\\n        }\\n        \\n        /**Going through the rest of matrix to find 0s,\\n        If 0 exist, we update its first row and first column*/\\n        for(int i=1;i<n;i++) {\\n            for(int j=1;j<m;j++) {\\n                if(matrix[i][j]==0) {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        //Converting a particular column to 0 if the first row correspoding is 0\\n        for(int i=1;i<m;i++) {\\n            if(matrix[0][i]==0) {\\n                for(int j=1;j<n;j++) matrix[j][i]=0;\\n            }\\n        }\\n        \\n        //Converting a particular row to 0 if the first column corresponding is 0\\n        for(int i=1;i<n;i++) {\\n            if(matrix[i][0]==0) {\\n                for(int j=1;j<m;j++) matrix[i][j]=0;\\n            }\\n        }\\n        \\n        //Converting a row or column zero if corresponding flag is zero\\n        if(row || first) for(int i=0;i<m;i++) matrix[0][i]=0;\\n        if(col || first) for(int i=0;i<n;i++) matrix[i][0]=0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031661,
                "title": "3-approaches",
                "content": "1st approach:\\nConsidering non-negative numbers in the matrix, we are changing non-zero elements in rows and columns containg 0 to -1. In next step cahnging those -1 to 0.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n2nd approach:\\nWe are creating 2 dummy arrays where we store whhich row and column contains 0. In next step we chang all elems to 0 according to dummy arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n3rd approach:\\nInstead of creating dummy arrays we consider 0th row and column as the same. But here matrix[0][0]\\ngets overlapped by both row and column. So for 0th column we consider a varaible col . If any elem of 0th column has 0 then we change col\\'s value. Next we traverse from the last of array.\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    //make row elements 0\\n                    for(int k=0;k<cols;k++)\\n                        if(a[i][k]!=0)\\n                            a[i][k]=-1;\\n                    //make col elements 0\\n                    for(int l=0;l<rows;l++)\\n                        if(a[l][j]!=0)\\n                            a[l][j]=-1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for( int j=0;j<cols;j++){\\n                if(a[i][j]==-1)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        vector<int> dummyRow(rows,-1), dummyCol(cols,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(a[i][j]==0){\\n                    dummyRow[i]=0;\\n                    dummyCol[j]=0;\\n                }\\n                \\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummyRow[i]==0 || dummyCol[j] ==0)\\n                    a[i][j]=0;\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& a) {\\n        int col=1;\\n        int rows = a.size();\\n        int cols = a[0].size();\\n        for(int i=0;i<rows;i++){\\n            if(a[i][0]==0)\\n                col=0;\\n            for( int j=1;j<cols;j++){\\n                \\n                if(a[i][j]==0){\\n                    a[0][j]=0;\\n                    a[i][0]=0;\\n                }\\n            }\\n        }\\n        for(int i=rows-1;i>=0;i--){\\n            for(int j=cols-1;j>=1;j--){\\n                if(a[0][j] == 0 || a[i][0]==0)\\n                    a[i][j]=0; \\n            }\\n            if(col==0)\\n                a[i][0]=0;\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005761,
                "title": "go-clear-solution",
                "content": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc setZeroes(matrix [][]int)  {\\n    m, n := len(matrix), len(matrix[0])\\n    zeroColumn, zeroRow := false, false\\n    for r := 0; r < m; r++ {\\n        for c := 0; c < n; c++ {\\n            if matrix[r][c] == 0 {\\n                if c == 0 { zeroColumn = true } else { matrix [0][c] = 0 }\\n                if r == 0 { zeroRow = true } else { matrix [r][0] = 0 }\\n            }\\n        }\\n    }\\n    for r := 1; r < m; r++ {\\n        for c := 1; c < n; c++ {\\n            if matrix[0][c] == 0 || matrix[r][0] == 0 {\\n                matrix[r][c] = 0\\n            }\\n        }\\n    }\\n    if zeroColumn { for r := 0; r < m; r++ { matrix[r][0] = 0 } }\\n    if zeroRow { for c := 0; c < n; c++ { matrix[0][c] = 0 } }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1737433,
                "title": "java-solution-using-two-sets",
                "content": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\n\\nTime Comp:- O(rows*cols)\\nSpace :- O(rows+cols)",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` \\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> rows=new HashSet<>();\\n        Set<Integer> cols=new HashSet<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    rows.add(i);\\n                    cols.add(j);\\n                }\\n            }\\n        }\\n        for(int i : rows){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        for(int j: cols){\\n            for(int i=0;i<matrix.length;i++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683206,
                "title": "python-easy-and-concise-solution-with-hashmap-python",
                "content": "* Store 0 valued indexes in hashmap\\n* Traverse the matrix and update according to hashmap\\n\\n# PYTHON\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        n, m = len(matrix), len(matrix[0])\\n        rows, cols = {}, {}\\n        for i in range(n):\\n            for j in range(m):\\n                if matrix[i][j] == 0:\\n                    rows[i] = 1\\n                    cols[j] = 1\\n        for i in range(n):\\n            for j in range(m):\\n                if i in rows:\\n                    matrix[i][j] = 0\\n                if j in cols:\\n                    matrix[i][j] = 0\\n        return matrix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558946,
                "title": "c-three-levels-of-solution",
                "content": "**1. O(mn) space** \\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\\n**2. O(m+n) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```\\n**3. O(1) space**\\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tbool zeroCol = false;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tif(matrix[i][0] == 0) {\\n\\t\\t\\tzeroCol = true;\\n\\t\\t}\\n\\t\\tfor (int j = 1; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tmatrix[0][j] = 0;\\n\\t\\t\\t\\tmatrix[i][0] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 1; i < m; i++) {\\n\\t\\tfor(int j = 1; j < n; j++) {\\n\\t\\t\\tif(!matrix[i][0] || !matrix[0][j])\\n\\t\\t\\t\\tmatrix[i][j] = 0;\\n\\t\\t}\\n\\t} \\n\\tif(matrix[0][0] == 0) {\\n\\t\\tfor(int j = 0; j < n; j++) matrix[0][j] = 0;\\n\\t}\\n\\tif(zeroCol) {\\n\\t\\tfor(int i = 0; i < m; i++) matrix[i][0] = 0;\\n\\t}\\n}\\n\\t",
                "solutionTags": [],
                "code": "```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<vector<int>>res(m, vector<int>(n, -1));\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) res[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) res[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(res[i][j] == 0) matrix[i][j] = 0;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nvoid setZeroes(vector<vector<int>>& matrix) {\\n\\tint m = matrix.size(), n = matrix[0].size();\\n\\tvector<pair<int,int>>index;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tif(matrix[i][j] == 0) {\\n\\t\\t\\t\\tindex.push_back({i,j});\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\tvector<pair<int,int>>::iterator it;\\n\\tfor(int i = 0; i < m; i++) {\\n\\t\\tfor(int j = 0; j < n; j++) {\\n\\t\\t\\tit = find (index.begin(), index.end(), make_pair(i, j));\\n\\t\\t\\tif(it != index.end()) {\\n\\t\\t\\t\\tfor(int k = 0; k < m; k++) matrix[k][j] = 0;\\n\\t\\t\\t\\tfor(int k = 0; k < n; k++) matrix[i][k] = 0;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1402036,
                "title": "java-easy-solution-o-1-space",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int col0 = 1, rows = matrix.length, cols = matrix[0].length;\\n      for(int i=0;i<rows;i++){\\n        if(matrix[i][0]==0) \\n            col0=0;\\n        for(int j=1;j<cols;j++){\\n          if(matrix[i][j]==0)\\n            matrix[i][0]=matrix[0][j]=0;\\n        }\\n      }\\n      \\n      for(int i=rows-1;i>=0;i--){\\n        for(int j = cols-1;j>=1;j--)\\n          if(matrix[0][j]==0 || matrix[i][0]==0)\\n            matrix[i][j]=0;\\n        \\n        if(col0==0) matrix[i][0]=0;\\n\\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823987,
                "title": "wrong-test-case",
                "content": "The problem statement has a constraint:\\n\\n```-10^9 <= matrix[i][j] <= 10^9```\\n\\nyet one of the test cases that my code failed to process looks like this:\\n\\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```\\n\\nI know how to solve the problem without that constraint, but the problem statement shouldn\\'t have included it in the first place. How do we fix the problem statement?",
                "solutionTags": [],
                "code": "```-10^9 <= matrix[i][j] <= 10^9```\n```[[-4,-2147483648,6,-7,0],[-8,6,-8,-6,0],[2147483647,2,-9,-6,-10]]```",
                "codeTag": "Unknown"
            },
            {
                "id": 744750,
                "title": "3-different-solutions-in-c",
                "content": "Solution 1 using queue\\n\\nIn worst case,\\nTime Complexity : O(nm*(n+m))\\nSpace Complexity : O(n*m)\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\\n\\nSolution 2 with O(1) space:\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\\n\\nSolution 3 with O(1) space :\\n\\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        for(int i=0; i<n; i++)\\n            for(int j=0; j<m; j++)\\n                if(A[i][j] == 0)\\n                    q.push({i,j});\\n        \\n        while(!q.empty())\\n        {\\n            int f = q.front().first;\\n            int s = q.front().second;\\n            q.pop();\\n            \\n            for(int i=0; i<n; i++)\\n                A[i][s] = 0;\\n            \\n            for(int j=0; j<m; j++)\\n                A[f][j] = 0;\\n        }\\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    for(int x=0; x<n; x++)\\n                        if(A[x][j] != 0)\\n                            A[x][j] = -1000000;\\n\\n                    for(int y=0; y<m; y++)\\n                        if(A[i][y] != 0)\\n                            A[i][y] = -1000000;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(A[i][j] == -1000000)\\n                    A[i][j] = 0;\\n            }\\n        }\\n        \\n    }\\n```\n```\\n\\tvoid setZeroes(vector<vector<int>>& A) {\\n        int n = A.size();\\n        if(n == 0)\\n            return;\\n        int m = A[0].size();\\n        bool col = false;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            if(A[i][0] == 0)\\n                col = true;\\n            for(int j=1; j<m; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1; i<n; i++)\\n            for(int j=1; j<m; j++)\\n                if(A[i][0] == 0 || A[0][j] == 0)\\n                    A[i][j] = 0;\\n        \\n        //first row\\n        if(A[0][0] == 0)\\n            for(int j=1; j<m; j++)\\n                A[0][j] = 0;\\n        \\n        //first column\\n        if(col)\\n            for(int i=0; i<n; i++)\\n                A[i][0] = 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 656346,
                "title": "javascript-short-o-1-space-solution",
                "content": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar setZeroes = function(matrix) {\\n    let col0 = 1, row = matrix.length, col = matrix[0].length;\\n    \\n    for(let i = 0; i < row; i++) {\\n        if(matrix[i][0] === 0) col0 = 0;\\n        for(let j = 1; j < col; j++) {\\n            if(matrix[i][j] === 0) {\\n                matrix[i][0] =  matrix[0][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    for(let i = row-1; i >= 0; i--) {\\n        for(let j = col-1; j > 0; j--) {\\n            if(matrix[i][0] === 0 || matrix[0][j] === 0) matrix[i][j] = 0;\\n        }\\n        if(col0 === 0) matrix[i][0] = 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358555,
                "title": "java-solution-o-1-space-beats-100-in-time-with-explanation",
                "content": "We can reduce the space to O(1) by using the first row as a replacement for the row array and the first column as a replacement for the column array.This works as follows:\\n\\n1. Check if the first row and first column have any zeroes, and set variables rowHasZero and columnHasZero.(We\\'ll nullify the first row and first column later, if necessary.)\\n\\n2. Iterate through the rest of matrix, setting A[i][0] and A[0][j] to zero whenever there\\'s a zero in A[i][j].\\n\\n3. Iterate through rest of matrix, nullifying row i if there\\'s a zero in A[i][0].\\n\\n4. Iterate through rest of matrix, nullifying column j if there\\'s a zero in A[0][j].\\n\\n5. Nullify the first row and first column, if necessary(based on values from step 1).\\n\\nThe explanation is taken from the book \"Cracking The Coding Interview\" by Gayle Laakmann Mcdowell.\\n\\n```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void nullifyRow(int[][] A, int r)\\n    {\\n        int col = A[r].length;\\n        for(int i = 0; i < col; i++)\\n            A[r][i] = 0;\\n    }\\n    public void nullifyCol(int[][] A, int c)\\n    {\\n        int row = A.length;\\n        for(int i = 0; i < row; i++)\\n            A[i][c] = 0;\\n    }\\n    public void setZeroes(int[][] A) \\n    {\\n        if(A == null)\\n            return;\\n        \\n        boolean rowHasZero = false;\\n        boolean colHasZero = false;\\n        \\n        int row = A.length;\\n        int col = A[0].length;\\n        \\n        for(int i = 0; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n            {\\n                colHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int j = 0; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n            {\\n                rowHasZero = true;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            for(int j = 1; j < col; j++)\\n            {\\n                if(A[i][j] == 0)\\n                {\\n                    A[i][0] = 0;\\n                    A[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 1; i < row; i++)\\n        {\\n            if(A[i][0] == 0)\\n                nullifyRow(A, i);\\n        }\\n        \\n        for(int j = 1; j < col; j++)\\n        {\\n            if(A[0][j] == 0)\\n                nullifyCol(A, j);\\n        }\\n        \\n        if(colHasZero)\\n        {\\n            nullifyCol(A, 0);\\n        }\\n        \\n        if(rowHasZero)\\n        {\\n            nullifyRow(A, 0);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181671,
                "title": "simple-java-solution",
                "content": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public void setZeroes(int[][] matrix) {\\n        boolean[] zeroRows = new boolean[matrix.length];\\n        boolean[] zeroColumns= new boolean[matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    zeroRows[i] = true;\\n                    zeroColumns[j] = true;\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[0].length; j++) {\\n                if (zeroRows[i] || zeroColumns[j]) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 26141,
                "title": "my-c-solution-use-o-1-space-and-84ms",
                "content": "    class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(row == -1) return;\\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][col] = 0;\\n                        matrix[row][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=0; i<m; i++){\\n                if(i == row) continue;\\n                if(matrix[i][col] == 0){\\n                    for(int j=0; j<n; j++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int j=0; j<n; j++){\\n                if(j == col) continue;\\n                if(matrix[row][j] == 0){\\n                    for(int i=0; i<m; i++) matrix[i][j] = 0;\\n                }\\n            }\\n            for(int i=0; i<m; i++) matrix[i][col] = 0;\\n            for(int j=0; j<n; j++) matrix[row][j] = 0;\\n        }\\n    };`enter code here`",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void setZeroes(vector<vector<int>>& matrix) {\\n            int m = matrix.size();\\n            int n = matrix[0].size();\\n            \\n            if(m==0 || n==0) return;\\n            int row = -1, col = -1;\\n            for(int i=0; i<m; i++){\\n                if(row != -1) break;\\n                for(int j=0; j<n; j++){\\n                    if(matrix[i][j] == 0){\\n                        row = i;\\n                        col = j;\\n                        break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3958297,
                "title": "easy-c-solution-optimal-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n     int m=matrix.size();\\n     int n=matrix[0].size();\\n     bool isRow=false;\\n     bool isCol=false;\\n     for(int i=0;i<m;i++)\\n     {\\n         if(matrix[i][0]==0)\\n         isCol=true;\\n     }\\n     for(int j=0;j<n;j++)\\n     {\\n         if(matrix[0][j]==0)\\n         isRow=true;\\n     } \\n     for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][j]==0)\\n            {\\n                matrix[0][j]=0;\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n    for(int i=1;i<m;i++)\\n    {\\n        for(int j=1;j<n;j++)\\n        {\\n            if(matrix[i][0]==0||matrix[0][j]==0)\\n            {\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }  \\n    if(isRow)\\n    {\\n        for(int i=0;i<n;i++)\\n        {\\n            matrix[0][i]=0;\\n        }\\n    }\\n    if(isCol)\\n    {\\n        for(int i=0;i<m;i++)\\n        {\\n            matrix[i][0]=0;\\n        }\\n    }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697836,
                "title": "easy-cpp-solution-with-stepwise-detailed-explanation",
                "content": "# Intuition\\n To form a vector storing the index of 0 element\\'s row and column.\\n\\n# Approach\\n1. The function `setZeroes` takes a 2D vector `matrix` as input and does not return any value.\\n\\n2. It initializes two empty vectors `x` and `y`. These vectors will store the row and column indices of the cells that contain zeros in the matrix.\\n\\n3. It uses nested loops to iterate through each element of the matrix. If an element is equal to 0, it means we need to set the entire row and column containing that element to zero.\\n\\n4. If an element is found to be zero, its row index (`i`) is appended to the vector `x`, and its column index (`j`) is appended to the vector `y`.\\n\\n5. After iterating through the entire matrix, we have two vectors `x` and `y` that contain the row and column indices of the cells with zeros.\\n\\n6. The next step is to set the rows to zero. It iterates over the vector `x` and takes each index value. For each index, it sets all the elements of that row to zero by iterating through the columns (`m`).\\n\\n7. After setting the rows to zero, it moves on to setting the columns to zero. It iterates over the vector `y` and takes each index value. For each index, it sets all the elements of that column to zero by iterating through the rows (`n`).\\n\\n8. Once both the row and column modifications are completed, the function exits.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n# Please upvote for better reach!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        vector<int>x,y;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0) \\n                {\\n                    x.push_back(i);\\n                    y.push_back(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<x.size();i++)\\n        {\\n            int index=x[i];\\n            for(int j=0;j<m;j++)\\n            {\\n                matrix[index][j]=0;\\n            }\\n        }\\n         for(int i=0;i<y.size();i++)\\n        {\\n            int index=y[i];\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[j][index]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692413,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->https://takeuforward.org/data-structure/set-matrix-zero/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(2(N*M))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int colm=1;\\n        int row=matrix.size();\\n        int col=matrix[0].size();\\n        for(int i=0;i<row;i++ ){\\n            if(matrix[i][0]==0)colm=0;\\n\\n            for(int j=1;j<col;j++ ){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0]=matrix[0][j]=0;\\n                }\\n        }\\n        }\\n\\n        for(int i=row-1;i>=0;i--){\\n\\n            for(int j=col-1;j>=1;j--){\\n                if( matrix[i][0]==0 || matrix[0][j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if(colm==0)matrix[i][0]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648965,
                "title": "java-11-liner-solution-0ms-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```\\n# KINDLY UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n      int m = matrix.length, n = matrix[0].length, k = 0;\\n      // First row has zeroes ?\\n      while(k < n && matrix[0][k] != 0)  ++ k;\\n      // Use first row/column as marker, scan the matrix\\n      for(int i = 1; i < m; i ++) \\n        for(int j = 0; j < n; j ++)\\n         if(matrix[i][j] == 0)\\n          matrix[0][j] = matrix[i][0] = 0;\\n      // Set the zeros\\n      for(int i = 1; i < m; i ++)\\n        for(int j = n - 1; j >=0; j --)\\n         if(matrix[0][j] == 0 || matrix[i][0] == 0)\\n          matrix[i][j] = 0;\\n      // Set the zeros for the first row\\n      if(k < n) Arrays.fill(matrix[0], 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632582,
                "title": "striver-approach-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n\\n        vector<int>row(n,0);\\n        vector<int>col(m,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(row[i]==1|col[j]==1)\\n                {\\n                   matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612506,
                "title": "easiest-approach-brute-better-optimal-o-n-2-no-extra-space-fully-explained-beats-100",
                "content": "# BRUTE FORCE METHOD\\n## Approach:\\nThe steps are the following:\\n1. First, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n2. If any cell (i,j) contains the value 0, we will mark all cells in row i and column j with -1 except those which contain 0.\\n3. We will perform step 2 for every cell containing 0.\\n4. Finally, we will mark all the cells containing -1 with 0.\\n5. Thus the given matrix will be modified according to the question.\\n\\n**Note:** *Here, we are assuming that the matrix does not contain any negative numbers. But if it contains negatives, we need to find some other ways to mark the cells instead of marking them with -1.*\\n\\n## Intuition:\\n\\nThis approach is very straightforward and we are just following the process stated in the question. But the following two questions need to be clarified to understand the algorithm further.\\n\\n## Complexity Analysis\\n**Time Complexity:** O((N\\\\*M)\\\\*(N + M)) + O(N\\\\*M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** Firstly, we are traversing the matrix to find the cells with the value 0. It takes O(N\\\\*M). Now, whenever we find any such cell we mark that row and column with -1. This process takes O(N+M). So, combining this the whole process, finding and marking, takes O((N\\\\*M)\\\\*(N + M)).\\nAnother O(N*M) is taken to mark all the cells with -1 as 0 finally.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# BETTER METHOD\\n## Approach (Using two extra arrays):\\n\\nThe steps are as follows:\\n\\n1. First, we will declare two arrays: a row array of size N and a col array of size M and both are initialized with 0.\\n2. Then, we will use two loops(nested loops) to traverse all the cells of the matrix.\\n3. If any cell (i,j) contains the value 0, we will mark ith index of row array i.e. row[i] and jth index of col array col[j] as 1. It signifies that all the elements in the ith row and jth column will be 0 in the final matrix.\\n4. We will perform step 3 for every cell containing 0.\\n5. Finally, we will again traverse the entire matrix and we will put 0 into all the cells (i, j) for which either row[i] or col[j] is marked as 1.\\n6. Thus we will get our final matrix.\\n\\n## Intuition:\\n\\nIn the previous approach, we were marking the cells with -1 while traversing the matrix. But in this approach, we are not marking the entire row and column instead, we are marking the ith index of **row** array i.e. row[i], and jth index of **col** array i.e. col[j] with 1. These marked indices of the two arrays, row and col will tell us for which rows and columns we need to change the values to 0. For any cell (i, j), if the row[i] or col[j] is marked with 1, we will change the value of cell(i, j) to 0.\\n\\nHere we are marking the cells after traversal whereas in the previous case, we were marking the cells while traversal. That is how the time complexity reduces in this case.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** We are traversing the entire matrix 2 times and each traversal is taking O(N*M) time complexity.\\n\\n**Space Complexity:** O(N) + O(M), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** O(N) is for using the row array and O(M) is for using the col array.\\n\\n# OPTIMAL METHOD\\n## Intuition:\\nIn the previous approach, the time complexity is minimal as the traversal of a matrix takes at least O(N\\\\*M)(*where N = row and M = column*). In this approach, we can just improve the space complexity. So, instead of using two extra matrices row and col, we will use the 1st row and 1st column of the given matrix to keep a track of the cells that need to be marked with 0. But here comes a problem. If we try to use the 1st row and 1st column to serve the purpose, the cell matrix[0][0] is taken twice. To solve this problem we will take an extra variable col0 initialized with 1. Now the entire 1st row of the matrix will serve the purpose of the **row array**. And the 1st column from (0,1) to (0,m-1) with the col0 variable will serve the purpose of the **col array**.\\n\\nIf any cell in the 0th row contains 0, we will mark matrix[0][0] as 0 and if any cell in the 0th column contains 0, we will mark the col0 variable as 0.\\n\\nThus we can optimize the space complexity.\\n\\n## Approach: \\n\\nThe steps are as follows:\\n\\n1. First, we will traverse the matrix and mark the proper cells of 1st row and 1st column with 0 accordingly. The marking will be like this: if cell(i, j) contains 0, we will mark the i-th row i.e. matrix[i][0] with 0 and we will mark j-th column i.e. matrix[0][j] with 0.\\nIf i is 0, we will mark matrix[0][0] with 0 but if j is 0, we will mark the col0 variable with 0 instead of marking matrix[0][0] again.\\n2. After step 1 is completed, we will modify the cells from (1,1) to (n-1, m-1) using the values from the 1st row, 1st column, and col0 variable.\\n*We will not modify the 1st row and 1st column of the matrix here as the modification of the rest of the matrix(i.e. From (1,1) to (n-1, m-1)) is dependent on that row and column.*\\n3. Finally, we will change the 1st row and column using the values from matrix[0][0] and col0 variable. Here also we will change the row first and then the column.\\nIf matrix[0][0] = 0, we will change all the elements from the cell (0,1) to (0, m-1), to 0.\\nIf col0 = 0, we will change all the elements from the cell (0,0) to (n-1, 0), to 0.\\n\\n## Complexity Analysis\\n**Time Complexity:** O(2\\\\*(N\\\\*M)), where N = no. of rows in the matrix and M = no. of columns in the matrix.\\n**Reason:** In this approach, we are also traversing the entire matrix 2 times and each traversal is taking O(N\\\\*M) time complexity.\\n\\n**Space Complexity:** O(1) as we are not using any extra space.\\n\\n# CODE\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/82c15abe-fec8-4e99-bbc1-e59479c122ab_1690651460.5963545.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        std::ios::sync_with_stdio(0); std::cin.tie(0);\\n        int n=matrix.size(), m=matrix[0].size(), col0=1;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(matrix[i][j]==0){\\n                    matrix[i][0] = 0;\\n                    if(j!=0) matrix[0][j] = 0;\\n                    else col0 = 0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                if(matrix[i][j]!=0){\\n                    if(matrix[0][j] == 0 || matrix[i][0] == 0) matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(matrix[0][0]==0){\\n            for(int j=0;j<m;j++) matrix[0][j] = 0;\\n        }\\n        if(col0 == 0){\\n            for(int i=0;i<n;i++) matrix[i][0] = 0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497187,
                "title": "easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        keep track of rows and columns when ever we encounter 0\\n\\n        and then using stored info we will set all rows and col to 0\\n\\n        if set contains i and j we will set all the element to 0\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        //keep track of rows and columns when ever we encounter 0\\n\\n        //and then using stored info we will set all rows and col to 0\\n\\n        HashSet<Integer> row= new HashSet<>();\\n        HashSet<Integer> col= new HashSet<>();\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    row.add(i);\\n                    col.add(j);\\n                }\\n            }\\n        }\\n\\n        // if set contains i and j we will set all the element to 0\\n\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++)\\n                if(row.contains(i) || col.contains(j)) matrix[i][j]=0;\\n        }\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476709,
                "title": "c-better-approach-t-c-o-n-m-striver",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing extra row and col with initializes with 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate through every element in matrix and if 0 found then mark extra row and col equals to 1.\\nNow iterate through matrix and if row and col contains 1 then update matrix[i][j] to 0.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n*m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n+m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int r=matrix.size();\\n        int c=matrix[0].size();\\n        \\n        vector<int> row(r,0);\\n        vector<int> col(c,0);\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]=1;\\n                    col[j]=1;\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(row[i] || col[j])\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463953,
                "title": "java-solution-for-set-matrix-zeros-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given solution aims to set all the elements in a row or column of an input matrix to zero if any element in that row or column is zero. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in this solution is to first check if the first row and the first column have any zeros, as they will be used later to mark the remaining rows and columns that need to be set to zero. The algorithm then iterates over the input matrix, starting from the second row and the second column. For each element, if it is zero, it sets the corresponding elements in the first row and first column to zero. After marking the rows and columns that need to be set to zero, the algorithm then iterates over the input matrix again and sets the elements in marked rows and columns to zero. Finally, the algorithm checks if the first row and the first column need to be set to zero and sets them accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn), where m is the number of rows and n is the number of columns in the input matrix, as the algorithm needs to iterate over all elements in the matrix twice. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n O(1), as the algorithm uses only a constant amount of extra space to store the boolean variables used to track the presence of zeros in the first row and the first column.\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        boolean firstRowZero = false;\\n        boolean firstColumnZero = false;\\n        //set first row and column zero or not\\n        for(int i=0; i<matrix.length; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                firstColumnZero = true;\\n                break;\\n            }\\n        }\\n        for(int i=0; i<matrix[0].length; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                firstRowZero = true;\\n                break;\\n            }\\n        }\\n        //mark zeros on first row and column\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        //use mark to set elements\\n        for(int i=1; i<matrix.length; i++)\\n        {\\n            for(int j=1; j<matrix[0].length; j++)\\n            {\\n                if(matrix[i][0] == 0 || matrix[0][j] == 0)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        //set first column and row\\n        if(firstColumnZero)\\n        {\\n            for(int i=0; i<matrix.length; i++)\\n                matrix[i][0] = 0;\\n        }\\n        if(firstRowZero)\\n        {\\n            for(int i=0; i<matrix[0].length; i++)\\n                matrix[0][i] = 0;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456258,
                "title": "optimal-solution-o-1-space-comp-c-code",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst row and First column is going to be marked to reduce Space complexity.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*m)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```\\n# Upvote if it was helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n=matrix.size();\\n        int m=matrix[0].size();\\n        int col0=1; // To ignore collision of the row and column,\\n                    // we can use this variable to indicate the first coloumn\\n        for (int i = 0; i < n; i++) {\\n        for (int j = 0; j < m; j++) {\\n            if (matrix[i][j] == 0) {\\n                // mark i-th row:\\n                matrix[i][0] = 0;\\n\\n                // mark j-th column:\\n                if (j != 0)\\n                    matrix[0][j] = 0;\\n                else\\n                    col0 = 0;\\n            }\\n        }\\n    }\\n\\n    // Step 2: Mark with 0 from (1,1) to (n-1, m-1):\\n    for (int i = 1; i < n; i++) {\\n        for (int j = 1; j < m; j++) {\\n            if (matrix[i][j] != 0) {\\n                // check for col & row:\\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n    }\\n\\n    //step 3: Finally mark the 1st col & then 1st row:\\n    if (matrix[0][0] == 0) {\\n        for (int j = 0; j < m; j++) {\\n            matrix[0][j] = 0;\\n        }\\n    }\\n    if (col0 == 0) {\\n        for (int i = 0; i < n; i++) {\\n            matrix[i][0] = 0;\\n        }\\n    }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314911,
                "title": "1ms-optimised-java-solution-using-arrays",
                "content": "# Intuition\\n Instead of traversing through each row and column, we can use dummy arrays to check if the particular row or column has an element 0 or not, which will improve the time complexity.\\n\\n# Approach\\n   Take two dummy arrays one of size of the row and the other of size of column. Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n\\n# Complexity\\n- Time complexity:\\nO(N*M + N*M)\\n\\n- Space complexity:\\n O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int rows=matrix.length;\\n        int cols=matrix[0].length;\\n        int []dummy1=new int[rows];\\n        int []dummy2=new int[cols];\\n        Arrays.fill(dummy1,-1);\\n        Arrays.fill(dummy2,-1);\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(matrix[i][j]==0)\\n                    {dummy1[i]=0;\\n                   dummy2[j]=0;\\n            }\\n            }\\n        }\\n        for(int i=0;i<rows;i++){\\n            for(int j=0;j<cols;j++){\\n                if(dummy1[i]==0 || dummy2[j]==0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181635,
                "title": "73-set-matrix-zeroes-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We use the first row and first column to store information about the rest of the matrix.\\n- If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0.\\n- Use a variable called col0 to store information about the first column.\\n- Use the information stored in the first row and first column to set the rest of the matrix to 0s.\\n- We need to traverse the matrix in reverse order, so that we do not overwrite information that we need to use later.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        # Use the first row and first column to store information about the rest of the matrix\\n        # If matrix[i][j] is 0, set matrix[i][0] and matrix[0][j] to 0\\n        # Use a variable called col0 to store information about the first column\\n        m, n = len(matrix), len(matrix[0])\\n        col0 = 1\\n        for i in range(m):\\n            if matrix[i][0] == 0:\\n                col0 = 0\\n            for j in range(1, n):\\n                if matrix[i][j] == 0:\\n                    matrix[i][0] = matrix[0][j] = 0\\n        # Use the information stored in the first row and first column to set the rest of the matrix to 0s\\n        for i in range(m-1, -1, -1):\\n            for j in range(n-1, 0, -1):\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col0 == 0:\\n                matrix[i][0] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902011,
                "title": "set-matrix-zeroes",
                "content": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }\\n            }\\n        for(i=0;i<m;i++)\\n            {\\n  for (j=0;j<n;j++)\\n      {\\n   if(arr[i][j]==0)\\n     func(i,j,matrix); \\n      } \\n    }\\n}\\npublic void func(int a,int b,int[][] matrix)\\n {                   for(int k=0;k<matrix\\n[0].length;k++)\\n     {\\n    matrix[a][k]=0; \\n    }\\nfor(int l=0;l<matrix. length;l++)\\n    {\\n    matrix[l][b]=0;\\n}\\n  }\\n   }                   \\n",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    public void setZeroes(int[][] matrix) {\\n        int i,j;\\nint m=matrix.length;\\n //m indicates row\\nint n=matrix[0].length;\\n //n indicates column \\nint[][] arr=new int[m][n];\\n        for (i=0;i<m;i++)\\n            {\\n            for(j=0;j<n;j++){\\n  /* two loops required one for row traversal one for column traversal  */ \\n  arr[i][j]=matrix[i][j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2821742,
                "title": "my-o-mn-java-code-beats-100-submissions",
                "content": "# Intuition\\nThought of storing that zero in something then change all rows and column to zero accordingly.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(mn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(mn)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n     public void makeRowZero(int[][] matrix, int row) {\\n        for (int i = 0; i < matrix[row].length; i++) {\\n            matrix[row][i] = 0;\\n        }\\n    }\\n\\n    public void makeColumnZero(int[][] matrix, int col) {\\n        for (int i = 0; i < matrix.length; i++) {\\n            matrix[i][col] = 0;\\n        }\\n    }\\n\\n    public void setZeroes(int[][] matrix) {\\n        boolean[][] isZero = new boolean[matrix.length][matrix[0].length];\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (matrix[i][j] == 0) {\\n                    isZero[i][j] = true;\\n                }\\n            }\\n        }\\n        for (int i = 0; i < matrix.length; i++) {\\n            for (int j = 0; j < matrix[i].length; j++) {\\n                if (isZero[i][j]) {\\n                    makeRowZero(matrix, i);\\n                    makeColumnZero(matrix, j);\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818142,
                "title": "easy-java-solution-hashset",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        Set<Integer> setRow = new HashSet<>();\\n        Set<Integer> setCol = new HashSet<>();\\n        for(int i = 0; i < matrix.length; i++){\\n            for(int j = 0; j < matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    setRow.add(i);\\n                    setCol.add(j);\\n                }\\n            }\\n        }\\n        for(int row : setRow){\\n            for(int i = 0; i < matrix[0].length; i++){\\n                matrix[row][i] = 0;\\n            }\\n        }\\n        for(int col: setCol){\\n            for(int i = 0; i < matrix.length; i++){\\n                matrix[i][col] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2807583,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\tint x=q.front().first, y=q.front().second;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tint x1=x, x2=x, x3=x, x4=x, y1=y, y2=y, y3=y, y4=y;\\n\\t\\t\\t\\t//cout<<x<<\" \"<<y<<endl;\\n\\t\\t\\t\\tif(x1>0){\\n\\t\\t\\t\\t\\twhile(x1>0){\\n\\t\\t\\t\\t\\t\\t//v[x1-1][y1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x1-1][y1]=0;\\n\\t\\t\\t\\t\\t\\tx1--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\twhile(x2<matrix.size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x2+1][y]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x2+1][y2]=0;\\n\\t\\t\\t\\t\\t\\tx2++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y3>0){\\n\\t\\t\\t\\t\\twhile(y3>0){\\n\\t\\t\\t\\t\\t\\t//v[x3][y3-1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x3][y3-1]=0;\\n\\t\\t\\t\\t\\t\\ty3--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\twhile(y4<matrix[0].size()-1){\\n\\t\\t\\t\\t\\t\\t//v[x4][y4+1]=1;\\n\\t\\t\\t\\t\\t\\tmatrix[x4][y4+1]=0;\\n\\t\\t\\t\\t\\t\\ty4++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tqueue<pair<int, int>>q;\\n\\t\\t\\t//vector<vector<int>>v(matrix.size(), vector<int>(matrix[0].size(), 0));\\n\\t\\t\\tfor(int i=0; i<matrix.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<matrix[0].size(); j++){\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0){\\n\\t\\t\\t\\t\\t\\t//v[i][j]=1;\\n\\t\\t\\t\\t\\t\\tq.push({i, j}",
                "codeTag": "Java"
            },
            {
                "id": 2689157,
                "title": "1-ms-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n        public void setZeroes(int[][] matrix) {\\n            boolean firstRowZero = false;\\n            boolean firstColumnZero = false;\\n            for(int i=0; i<matrix.length; i++){\\n                if(matrix[i][0] == 0){\\n                    firstColumnZero = true;\\n                    break;\\n                }\\n            }\\n            for(int i=0; i<matrix[0].length; i++){\\n                if(matrix[0][i] == 0){\\n                    firstRowZero = true;\\n                    break;\\n                }\\n\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][j] == 0){\\n                        matrix[i][0] = 0;\\n                        matrix[0][j] = 0;\\n                    }\\n                }\\n            }\\n            for(int i=1; i<matrix.length; i++){\\n                for(int j=1; j<matrix[0].length; j++){\\n                    if(matrix[i][0] == 0 || matrix[0][j] == 0){\\n                        matrix[i][j] = 0;\\n                    }\\n                }\\n            }\\n            if(firstColumnZero){\\n                for(int i=0; i<matrix.length; i++)\\n                    matrix[i][0] = 0;\\n            }\\n            if(firstRowZero){\\n                for(int i=0; i<matrix[0].length; i++)\\n                    matrix[0][i] = 0;\\n            }\\n        }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653405,
                "title": "java-solution-easy",
                "content": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\tArrayList<Integer>l1=new ArrayList<>();\\n        ArrayList<Integer>l2=new ArrayList<>();\\n        \\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[i].length;j++){\\n                if(matrix[i][j]==0){\\n                    l1.add(i);\\n                    l2.add(j);\\n                }\\n            }\\n        }\\n        \\n        for(int i:l1){\\n            for(int j=0;j<matrix[0].length;j++){\\n                matrix[i][j]=0;\\n            }\\n        }\\n        \\n        for(int i:l2){\\n            for(int j=0;j<matrix.length;j++){\\n                matrix[j][i]=0;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2562319,
                "title": "java-solution-brute-force",
                "content": "it is the brute force which is easy to understand \\n\\n\\t\\tclass Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Iterate over the array once again and using the rows and cols sets, update the elements.\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (rows.contains(i) || cols.contains(j)) {\\n\\t\\t\\t\\t  matrix[i][j] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t  }\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t}\\n\\t\\t\\nif its relevant solution then plz upvote it.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\t\\t  public void setZeroes(int[][] matrix) {\\n\\t\\t\\tint R = matrix.length;\\n\\t\\t\\tint C = matrix[0].length;\\n\\t\\t\\tSet<Integer> rows = new HashSet<Integer>();\\n\\t\\t\\tSet<Integer> cols = new HashSet<Integer>();\\n\\n\\t\\t\\t// Essentially, we mark the rows and columns that are to be made zero\\n\\t\\t\\tfor (int i = 0; i < R; i++) {\\n\\t\\t\\t  for (int j = 0; j < C; j++) {\\n\\t\\t\\t\\tif (matrix[i][j] == 0) {\\n\\t\\t\\t\\t  rows.add(i);\\n\\t\\t\\t\\t  cols.add(j);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2437385,
                "title": "o-m-n-m-n-and-o-1-space-solution-using-randomization-approach",
                "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n            \\n        }\\n        \\n             for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==0){\\n                     \\n                     for(int jj=0;jj<arr[0].size();jj++){\\n                          if(arr[i][jj]){\\n                               arr[i][jj]=k; \\n                          }\\n                       \\n                     }\\n                     \\n                     for(int ii=0;ii<arr.size();ii++){\\n                              if(arr[ii][j]){\\n                               arr[ii][j]=k; \\n                          }\\n                     }\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n          for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                    arr[i][j]=0;\\n                      \\n                 }\\n                \\n            }\\n                  \\n          }\\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& arr) {\\n           \\n      int k;\\n        bool ok=true;\\n        while(ok){\\n            \\n            ok=false;\\n            long long int p=(1LL<<32);\\n            \\n            k=(rand()%p)-(1<<31);\\n            \\n              for(int i=0;i<arr.size();i++){\\n            for(int j=0;j<arr[0].size();j++){\\n                  \\n                 if(arr[i][j]==k){\\n                     \\n                     ok=true;\\n                     break;\\n                      \\n                 }",
                "codeTag": "Java"
            },
            {
                "id": 2399205,
                "title": "c-easy-explantion-set-matrix-zero",
                "content": "\\t// Traverse the matrix \\n\\t// Take two vector to mark the rows and column in which the entry is 0\\n\\t// finally mark matrix[i][j] is 0 if either of the row[i] or column[i] is 0  \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(row[i]==0||col[j]==0)\\n\\t\\t\\t\\t\\t\\tmatrix[i][j]=0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid setZeroes(vector<vector<int>>& matrix) {\\n\\t\\t\\tint n=matrix.size();\\n\\t\\t\\tint m=matrix[0].size();\\n\\t\\t\\tvector<int>row(n,-1);\\n\\t\\t\\tvector<int>col(m,-1);\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor(int j=0;j<m;j++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(matrix[i][j]==0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\trow[i]=0; // marking that row in which element is zero\\n\\t\\t\\t\\t\\t\\tcol[j]=0; // marking that col in which element is x=zero\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2315182,
                "title": "c-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        set<int> rowZero;\\n        set<int> colZero;\\n        \\n        for(int i=0;i<matrix.size();i++){\\n            for(int j=0;j<matrix[0].size();j++){\\n                if(matrix[i][j]==0){\\n                    rowZero.insert(i);\\n                    colZero.insert(j);\\n                }\\n            }\\n        }\\n        for(int rowIndex: rowZero){\\n            makeRowZero(matrix, rowIndex);\\n        }\\n        for(int colIndex: colZero){\\n           makeColZero(matrix, colIndex); \\n        }\\n        return;\\n        \\n    }\\n    private: void makeRowZero(vector<vector<int>>& matrix, int rindex){\\n        for(int i=0;i<matrix[0].size();i++){\\n          matrix[rindex][i]= 0;  \\n        }\\n    }\\n    private: void makeColZero(vector<vector<int>>& matrix, int cindex){\\n        for(int j=0;j<matrix.size();j++){\\n            matrix[j][cindex]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250531,
                "title": "python-o-m-n-and-o-1-space-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n            \\n        n,m=len(matrix),len(matrix[0])\\n        col,row=False,False\\n        \\n    #check if first row and col has zero \\n    \\n        for i in range(n):\\n            if matrix[i][0]==0:col=True\\n        for i in range(m):\\n            if matrix[0][i]==0:row=True\\n                \\n    #if position has zero set first col and first row zero for that \\n    \\n        for i in range(1,n):\\n            for j in range(1,m):\\n                if matrix[i][j]==0:\\n                    matrix[0][j]=matrix[i][0]=0\\n                    \\n    #for every zero in first col set zero for every postion on that row\\n    \\n        for i in range(1,n):\\n            if matrix[i][0]==0:\\n                for j in range(1,m):\\n                    matrix[i][j]=0\\n                \\n    #for every zero in first row set zero for every postion on that col\\n    \\n        for j in range(1,m):\\n            if matrix[0][j]==0:\\n                for i in range(1,n):\\n                     matrix[i][j]=0\\n                        \\n    # if any of the check is true change all postions to zero\\n\\n        if col:\\n            for i in range(n):\\n                matrix[i][0]=0\\n\\n        if row:\\n            for j in range(m):\\n                matrix[0][j]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197878,
                "title": "striversdesheet-set-matrix-zero-brute-better-optimal",
                "content": "**Brute Force**\\nT.C = O(n * m) * O(n * m) + O(n*m)\\nS.C = O(1)\\n```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\\n\\n**BETTER**\\nT.C = O(n * m) + 2 * O(n * m)\\nS.C =O(n) + O(m)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\\n\\n**OPTIMAL**\\nT.C = O(n * m) + O(n * m)\\nS.C =O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```\\nDo Upvote if this is helpful.\\nIf you have any query,DM me on this instagram id (usually active there) - \"__asif18  (https://www.instagram.com/__asif18/?hl=en)\"\\n",
                "solutionTags": [
                    "Matrix"
                ],
                "code": "```\\n#define INF 1e9\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            if(matrix[i][j]==0){\\n                for(int k=0;k<cols;k++){\\n                   if(matrix[i][k]!=0){\\n                       matrix[i][k]=INF;\\n                   }\\n                }\\n            }\\n             if(matrix[i][j]==0){\\n                for(int k=0;k<rows;k++){\\n                   if(matrix[k][j]!=0){\\n                       matrix[k][j]=INF;\\n                   }\\n                }\\n            }\\n           \\n        }\\n    }\\n        for (int i = 0; i < rows; i++) {\\n        for(int j=0;j<cols;j++){\\n            \\n            if(matrix[i][j]==INF){\\n                matrix[i][j]=0;\\n            }\\n            \\n        }}\\n        \\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> u;\\n        vector<int> v;\\n        int rowsize=matrix.size();\\n        int colsize=matrix[0].size();\\n        for(int i=0;i<rowsize;i++){\\n            for(int j=0;j<colsize;j++){\\n                if(matrix[i][j]==0){\\n                    u.push_back(i);\\n                    v.push_back(j);\\n                }\\n            }\\n        }\\n        for(int m=0;m<u.size();m++){\\n            for(int p=0;p<colsize;p++){\\n            matrix[u[m]][p]=0;\\n        }\\n        }\\n        for(int n=0;n<v.size();n++){\\n          for(int q=0;q<rowsize;q++){\\n            matrix[q][v[n]]=0;\\n        }\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195609,
                "title": "100-optimal-solution-explained",
                "content": "Easy to understand, detailed solution with step by step explanation with all approaches Brute-Better-Optimal and code in multiple languages:\\n\\nhttps://codewithkartik.com/2022/05/16/set-matrix-zeroes-leetcode-73-solution\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you find the solution useful, means a lot.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2108834,
                "title": "c-solution-faster-than-100-with-o-1-space-complexity",
                "content": "**Please up vote if you like the solution**\\n#### **Brute Force**\\nAssuming all the elements in the matrix are non-negative. Traverse through the matrix and if you find an element with value 0, then change all the elements in its row and column to -1, except when an element is 0. The reason for not changing other elements to 0, but -1, is because that might affect other columns and rows. Now traverse through the matrix again and if an element is -1 change it to 0, which will be the answer.\\n\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\nTime Complexity : O ((N * M) * (N + M))\\nSpace Complexity:O (1)\\n.\\n.\\n.\\n\\n#### **Better Approach**\\nTake two dummy array one of size of row and other of size of column.Now traverse through the array.If matrix[i][j]==0 then set dummy1[i]=0(for row) and dummy2[j]=0(for column).Now traverse through the array again and if dummy1[i]==0  || dummy2[j]==0 then arr[i][j]=0,else continue.\\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\\n\\nTime Complexity: O(N * M + N * M)\\nSpace Complexity: O(N)\\nP.S : Credit for code of brute force and bette approach goes to take you forward now you can see my optimal solution.\\n.\\n.\\n.\\n#### **Optimal Solution**\\nInstead of taking two separate dummy array,take first row and column of the matrix as the array for checking whether the particular column or row has the value 0 or not.\\n\\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```\\nTime Complexity: O(N * M )\\nSpace Complexity: O(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n\\n        int ind = i - 1;\\n        while (ind >= 0) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind--;\\n        }\\n        ind = i + 1;\\n        while (ind < rows) {\\n          if (matrix[ind][j] != 0) {\\n            matrix[ind][j] = -1;\\n          }\\n          ind++;\\n        }\\n        ind = j - 1;\\n        while (ind >= 0) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind--;\\n        }\\n        ind = j + 1;\\n        while (ind < cols) {\\n          if (matrix[i][ind] != 0) {\\n            matrix[i][ind] = -1;\\n\\n          }\\n          ind++;\\n        }\\n      }\\n    }\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] <= 0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nvoid setZeroes(vector < vector < int >> & matrix) {\\n  int rows = matrix.size(), cols = matrix[0].size();\\n  vector < int > dummy1(rows,-1), dummy2(cols,-1);\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (matrix[i][j] == 0) {\\n        dummy1[i] = 0;\\n        dummy2[j] = 0;\\n      }\\n    }\\n\\n  }\\n  for (int i = 0; i < rows; i++) {\\n    for (int j = 0; j < cols; j++) {\\n      if (dummy1[i] == 0 || dummy2[j]==0) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    // use first col and first row as extra array \\n    void setZeroes(vector<vector<int>>& m) {\\n        // make 2 variable for row and collumns\\n        int a = m.size(), b = m[0].size();\\n        // 2 variables to store if we need to mark first row and first column as zero also at the end\\n        int f1 = 1, f2 = 1;\\n        for(int i = 0; i < a; i++)\\n        {\\n            for(int j = 0; j < b; j++)\\n            {\\n                if(m[i][j] == 0)\\n                {\\n                    // if index=0 and it is in first row and first column than f1=0 and f2=0\\n                    if(i == 0) f1 = 0;\\n                    if(j == 0) f2 = 0;\\n                    // if m[i][j]=0 than mark ith index of first col 0 and jth index of first row 0\\n                    if(i != 0 and j != 0)\\n                    {\\n                        m[0][j] = 0;\\n                        m[i][0] = 0;\\n                    }\\n                }\\n            }\\n        }\\n        for(int i = 1; i < a; i++)\\n        {\\n            // check in the first column if any elemnt mark as zero and if yes than mark that full row zero\\n            if(m[i][0] == 0)\\n            {\\n                for(int j = 1; j < b; j++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        for(int j = 1; j < b; j++)\\n        {\\n            // check in the first row if any elemnt mark as zero and if yes than mark that full column zero\\n            if(m[0][j] == 0)\\n            {\\n                for(int i = 1; i < a; i++)\\n                {\\n                    m[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check if first row need to be mark as fully by zeros\\n        if(f1 == 0)\\n        {\\n            for(int j = 0; j < b; j++)\\n                {\\n                    m[0][j] = 0;\\n                }\\n        }\\n        // check if first colmn need to be mark as fully by zeros\\n        if(f2 == 0)\\n        {\\n            for(int j = 0; j < a; j++)\\n                {\\n                    m[j][0] = 0;\\n                }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103145,
                "title": "simple-python-solution",
                "content": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        a,b=len(matrix),len(matrix[0])\\n        first_col,first_row=False,False\\n        for i in range(a):\\n            if matrix[i][0]==0:\\n                first_col=True\\n        for j in range(b):\\n            if matrix[0][j]==0:\\n                first_row=True\\n        for i in range(1,a):\\n            for j in range(1,b):\\n                if matrix[i][j]==0:\\n                    matrix[i][0]=0\\n                    matrix[0][j]=0\\n        for i in range(1,a):\\n            if matrix[i][0]==0:\\n                for j in range(1,b):\\n                    matrix[i][j]=0\\n        for i in range(1,b):\\n            if matrix[0][i]==0:\\n                for j in range(1,a):\\n                    matrix[j][i]=0\\n        if first_col:\\n            for i in range(a):\\n                matrix[i][0]=0\\n        if first_row:\\n            for i in range(b):\\n                matrix[0][i]=0\\n        return matrix\\n                \\n        \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1967511,
                "title": "c-optimized-solution-o-n-x-m-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }\\n\\n    for (int i = rows - 1; i >= 0; i--) {\\n        for (int j = cols - 1; j >= 1; j--)\\n            if (matrix[i][0] == 0 || matrix[0][j] == 0)\\n                matrix[i][j] = 0;\\n        if (col0 == 0) matrix[i][0] = 0;\\n    }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int col0 = 1, rows = matrix.size(), cols = matrix[0].size();\\n\\n    for (int i = 0; i < rows; i++) {\\n        if (matrix[i][0] == 0) col0 = 0;\\n        for (int j = 1; j < cols; j++)\\n            if (matrix[i][j] == 0)\\n                matrix[i][0] = matrix[0][j] = 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1921825,
                "title": "o-n-2-solution-for-absolute-beginners",
                "content": "Here\\'s my solution, which is not the optimal but it will help you build the foundation of the problem statement. \\n\\nSo, in this solution I keep two Sets [rol and col ] this sets stores - **while traversing the entire matrix have I ever encountered a 0 in either the row or the col**. \\nIf yes, then store the index in the SET.\\n\\nNow, iterate again through the matrix and check if either the row or col has ever encountered a 0 in the past: \\n\\t- if yes\\n\\t\\t- Set the [i][j] to 0\\n\\n\\nPretty straight forward right. \\n\\nGetting this result from LC\\n\\nRuntime: 91 ms, faster than 77.97% of JavaScript online submissions for Set Matrix Zeroes.\\nMemory Usage: 44.4 MB, less than 90.74% of JavaScript online submissions for Set Matrix Zeroes.\\n\\nHere\\'s the code.\\n\\n```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```\\n\\nHope you can optimize this on your own and do upvote it helped.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nvar setZeroes = function (matrix) {\\n  const row = new Set();\\n  const col = new Set();\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (matrix[i][j] === 0) {\\n        row.add(i);\\n        col.add(j);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[i].length; j++) {\\n      if (row.has(i) || col.has(j)) {\\n        matrix[i][j] = 0;\\n      }\\n    }\\n  }\\n\\n  return matrix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1893250,
                "title": "an-easy-approach-to-solve-set-matrix-zeroes-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        int row = matrix.size();\\n        int col = matrix[0].size();\\n        \\n        int x=1;\\n        int y=1;\\n        \\n        for(int i=0; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                x=0;\\n        }\\n        \\n        for(int j=0; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                y=0;\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            for(int j=1; j<col; j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++)\\n        {\\n            if(matrix[i][0]==0)\\n                for(int j=0; j<col; j++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        for(int j=1; j<col; j++)\\n        {\\n            if(matrix[0][j]==0)\\n                for(int i=0; i<row; i++)\\n                    matrix[i][j]=0;\\n        }\\n        \\n        if(x==0)\\n        {\\n            for(int i=0; i<row; i++)\\n                matrix[i][0]=0;\\n        }\\n        \\n        if(y==0)\\n        {\\n            for(int j=0; j<col; j++)\\n                matrix[0][j]=0;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860587,
                "title": "c-solution-by-using-o-n-space-to-record-indexes",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& nums) {\\n        int n=nums.size();\\n        int m=nums[0].size();\\n        vector<pair<int,int>> v;\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(nums[i][j]==0){\\n                    v.push_back({i,j});\\n                    \\n                }\\n            }\\n        }\\n        for(auto it: v){\\n            int a=it.first;\\n            int b=it.second;\\n            for(int i=0;i<n;++i){\\n                nums[i][b]=0;\\n            }\\n            for(int i=0;i<m;++i){\\n                nums[a][i]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765705,
                "title": "set-matrix-to-zero-striver-s-sde-sheet-problem-no-1-brute-force",
                "content": "Python Solution \\nThis is a brute force based solution very helpful for beginners to understand\\nBasic Approach : \\n* **First**, checking the positions of zero and saving it in a new list\\n* **Second**, Just multiplying with 0 to update the values\\n\\n```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        l=[]\\n        k=len(matrix)\\n        d=len(matrix[0])\\n        #LOOP FOR CHECKING THE POSITIONS OF ZERO\\n        for i in range(k):\\n            for j in range(d):\\n                if (matrix[i][j]==0):\\n                    l.append([i,j])\\n                    \\n        #LOOP FOR UPDATING THE MATRIX \\n        for h in range(len(l)):\\n            for p in range(d):\\n                matrix[l[h][0]][p]=matrix[l[h][0]][p] * 0 \\n            for g in range(k):\\n                matrix[g][l[h][1]]=matrix[g][l[h][1]]* 0 \\n        return matrix\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727833,
                "title": "c-8ms-o-1-space-o-mn-time",
                "content": "# Gist of the solution\\n* Check if the 1st row and col contain any 0 or not if it does mark them zero.\\n* Iterate from 2nd row and col and mark all the top row/col element 0 if that row/col contains 0.\\n* now iterate over 1st col/row and mark all the elements in that row/col zero accordingly.\\n* now in the 1st step you stored the bool values of if the zero is present or not so according to that make the 1st row/col zero.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int n = matrix.size();\\n        int m = matrix[0].size();\\n        \\n        bool row = false, col = false;\\n        \\n        for(int i=0; i<n; i++)\\n            if(matrix[i][0] == 0)\\n                col = true;\\n        \\n        for(int j=0; j<m; j++)\\n            if(matrix[0][j] == 0)\\n                row = true;\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            for(int j=1; j<m; j++)\\n            {\\n                if(matrix[i][j] == 0)\\n                {\\n                    matrix[i][0] = 0;\\n                    matrix[0][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++)\\n        {\\n            if(matrix[i][0] == 0)\\n            {\\n                //make the row zero\\n                for(int j=1;j<m;j++)\\n                {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        \\n        for(int i=1; i<m; i++)\\n        {\\n            if(matrix[0][i] == 0)\\n            {\\n                for(int j=1; j<n; j++)\\n                {\\n                    matrix[j][i] = 0;\\n                }\\n            }\\n        }\\n        \\n        if(col)\\n        {\\n            for(int i=0; i<n; i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0; i<m; i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699059,
                "title": "easy-to-understand-in-c-matrix",
                "content": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(row[i] || col[j]){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        vector<bool> row(m,false);\\n        vector<bool> col(n,false);\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(matrix[i][j]==0){\\n                    row[i]=true;\\n                    col[j]=true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1668009,
                "title": "brute-better-optimal-java-with-comments-0ms-faster-than-100-striver",
                "content": "1.BRUTE FORCE APPROACH\\nLINEARLY TRAVERSING CHECKING IF THERE IS A ZERO IF YES THEN MARKING WHOLE ROW AND COL ZERO\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\\n2.BETTER APPROACH\\nBY TAKING TWO DUMMY ARRAYS.\\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\\n 3.OPTIMAL APPROACH \\nTHIS APPROACH IS SAME AS BETTER APPROACH BUT INSTEAD OF TAKING TWO DUMMY ARRAYS WE USE FIRST ROW AND COL OF GIVEN MATRIX FOR CALCULATING ANSWER.\\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```\\n  Give it a upvote if you like it :)",
                "solutionTags": [],
                "code": "```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n            int n = arr.length;\\n            int m = arr[0].length;\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == 0) {\\n                              //FOR MARKING WHOLE ROW 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < m; a++) {\\n                                    if (arr[i][a] != 0) {\\n                                          arr[i][a] = Integer.MIN_VALUE;\\n                                    }\\n\\n                              }\\n                              //FOR MARKING WHOLE COLUMN 0 OR Integer.MIN_VALUE\\n                              for (int a = 0; a < n; a++) {\\n                                    if (arr[a][j] != 0) {\\n                                          arr[a][j] = Integer.MIN_VALUE;\\n                                    }\\n                              }\\n                        }\\n                  }\\n            }\\n            //THEN AT LAST MARKING ZERO AT PLACES OF Integer.MIN_VALUE\\n            for (int i = 0; i < n; i++) {\\n                  for (int j = 0; j < m; j++) {\\n                        if (arr[i][j] == Integer.MIN_VALUE) {\\n                              arr[i][j] = 0;\\n                        }\\n                  }\\n            }\\n      }\\n}\\n```\n```\\nclass solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          //making two dummy array\\n          int row[] = new int[n];\\n          int col[] = new int[m];\\n          for(int i=0;i<n;i++)\\n          {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                     row[i]=-1;\\n                     col[j]=-1;\\n                  }\\n              }   \\n          }\\n          //upto this point we filled our dummy array with zero.\\n          //i.e. 2 1D dummay array bnae then traverse kra given array ko ,, then as soon as we encounter 0 then we will mark 0 at i index of dummay array row and mark 0 at jth index of dummay array col->> after traversing the whole array we will know if there is a zero in given row or col or not.\\n      \\n          //again traverse through given array and with help of 1D dummy arrays check for the particular index that if in any one of row or col arrays there is a zero marked if yes then mark that particular index zero in the given array and so on.\\n           for(int i=0;i<n;i++)\\n           {\\n              for(int j=0;j<m;j++)\\n              {\\n                  if(row[i]==-1 || col[j]==-1)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n           }\\n      }\\n  }\\n  ```\n```\\n  class Solution {\\n      public void setZeroes(int[][] arr) {\\n          int n = arr.length;\\n          int m = arr[0].length;\\n          \\n          int colo=1;\\n          //THIS VARIABLE IS FOR ENSURING THAT WE WILL NOT MARK A WHOLE ROW OR COL ZERO BCZ OF PRESENCE OF A ZERO IN DUMMY PART OF ARRAY AS IT WILL RUIN OUR ANSWER SO WE ARE ASSUMING THAT WE HAVE CHECKED FOR FIRST ROW AND COL AND THEN STARTED TRAVERSING FROM  INDEX (1,1).\\n          for(int i=0;i<n;i++)\\n          {\\n              if(arr[i][0]==0)\\n              {\\n                  colo=0;\\n              }\\n              for(int j=1;j<m;j++)\\n              {\\n                  if(arr[i][j]==0)\\n                  {\\n                      //IF FOUND ZERO THEN MARKING 0 IN THE UPPERMOST AND LEFTMOST PART ZERO i.e. MARKING 0 IN DUMMY ARRAY WHICH IS PRESENT IN OUR GIVEN ARRAY.\\n                      arr[i][0]=arr[0][j]=0; \\n                  }\\n              }   \\n          }\\n\\n          //STARTING FROM BACK AS WE WOULD NOT THEN WE WILL UPDATE OUR DUMMY ARRAY FIRST WHICH WHICH RUIN OUR ANSWER\\n          //EVERYTHING ELSE IS SAME LIKE BETTER APPROACH.\\n          //ONLY COLO IS THERE WHICH ENSURES THAT WE WILL NOT MARK OUR A WHOLE ROW ZERO BCZ OF PRESENCE OF A ZERO IN OUR DUMMY ARRAY.\\n          for(int i=n-1;i>=0;i--)\\n          {\\n            //TRAVESING FROM BACK\\n              for(int j=m-1;j>=1;j--)\\n              {\\n                  if(arr[i][0]==0 || arr[0][j]==0)\\n                  {\\n                      arr[i][j]=0;\\n                  }\\n              }\\n              //IF WE FOUNF ZERO IN OU FIRST COL THEN WE WILL WHOLE COL ZERO.\\n              if(colo==0)\\n              {\\n                  arr[i][0]=0;\\n              }\\n          }\\n      }\\n  }\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 1607797,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void setZeroes(int[][] matrix) {\\n        \\n        boolean ispresent = false;\\n        for(int i=0; i<matrix.length; i++){\\n            if (matrix[i][0] == 0) ispresent = true;\\n            for(int j=1; j<matrix[0].length; j++){\\n                if(matrix[i][j] == 0){\\n                    matrix[0][j] = matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n        for(int i=matrix.length-1; i>=0; i--){\\n            for(int j = matrix[0].length-1; j>=1; j--){\\n                if(matrix[0][j] == 0 || matrix[i][0] == 0){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n            if (ispresent) matrix[i][0] = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603669,
                "title": "easy-cpp-solution-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        vector<int> row (matrix.size(), -1) ; \\n        vector<int> col (matrix[0].size(), -1); \\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0; j< matrix[0].size(); j ++){\\n                if(matrix[i][j] == 0){\\n                    row[i] = 0; \\n                    col[j] = 0; \\n                }\\n            }\\n        }\\n        for(int i=0; i< matrix.size() ; i ++){\\n            for(int j=0 ; j < matrix[0].size(); j ++){\\n                if(row[i]  ==0 || col[j] ==0){\\n                      matrix[i][j] = 0 ; \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585200,
                "title": "c-2-approaches-clean-self-explanatory-with-comments",
                "content": "Here I have discussed 2 Different approaches. The first one uses sets instead of maps and the Second one uses Constant Space.\\n___\\n**Approach 1: Two pass algo Using Set\\nTime: O(n^2logn), Space: O(max(n, m))**\\n**Runtime: 16ms\\nMemory: 13.5MB**\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\\n____\\n**Approach 2: Constant space**\\n**Runtime: 4ms\\nMemory: 13.1MB**\\nLogic: Use the first column and first row, as an indicator.\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```\\n____\\nPlease comment down if you find any mistakes/ improvements \\u270C.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return;\\n        int cols = matrix[0].size();\\n        set<int> row; // to keep track of row index with 0\\n        set<int> col; // to keep track of column index with 0\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row.insert(i); // insert row and column index to be set to zero in the respective sets\\n                    col.insert(j);\\n                }\\n            }\\n        }\\n        for(int i=0; i<rows; i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if(row.count(i) || col.count(j)) // if the current index is present in row or column, set it to zero\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }  \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = matrix.size();\\n        if(rows<=0) return ;\\n        int cols = matrix[0].size();\\n        bool FirstRow = false;\\n        bool FirstCol = false;\\n\\n        for(int i=0 ; i<rows; i++)\\n        {\\n            for(int j=0; j<cols; j++)\\n            {\\n                if(matrix[i][j]==0) // set indicators of first row and col to 0\\n                {\\n                    if(i==0) FirstRow = true;\\n                    if(j==0) FirstCol = true;\\n                    matrix[i][0]=0;\\n                    matrix[0][j]=0;\\n                }\\n            }\\n        }\\n\\n        for(int i=1;i<rows; i++)\\n        {\\n            for(int j=1; j<cols; j++)\\n            {\\n                if(matrix[i][0]==0 || matrix[0][j]==0) // if indicator was set to 0, set matrix[i][j] to 0\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        if(FirstRow) // if first row had a zero, reset the first col to 0\\n        {\\n            for(int i=0 ;i<cols;i++)\\n            {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if(FirstCol) // if first column had a zero, reset the first row to 0\\n        {\\n            for(int i=0;i<rows;i++)\\n            {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1538988,
                "title": "c-approach-with-0-n-and0-1-space-complexity",
                "content": "O(N) space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\nO(1) space complexity\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        unordered_map<int,int>row;\\n        unordered_map<int,int>col;\\n        \\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                    row[i]++;\\n                    col[j]++;\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.size();i++)\\n        {\\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(row.count(i)==1||col.count(j)==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        \\n        \\n        bool row=false;\\n        bool col=false;\\n       for(int i=0;i<matrix.size();i++)\\n        {\\n            if(matrix[i][0]==0)\\n            {\\n               col=true;\\n            \\n            }\\n         }   \\n            for(int j=0;j<matrix[0].size();j++)\\n            {\\n                if(matrix[0][j]==0)\\n                {\\n                   \\n                    row=true;\\n                }\\n            }\\n        \\n        \\n        for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][j]==0) \\n               {\\n                   matrix[0][j]=0;\\n                   matrix[i][0]=0;\\n                  \\n                 \\n                   \\n               }\\n            }\\n        }\\n         for(int i=1;i<matrix.size();i++)\\n        {\\n            for(int j=1;j<matrix[0].size();j++)\\n            {\\n               if(matrix[i][0]==0||matrix[0][j]==0)\\n               {\\n                  matrix[i][j]=0;\\n                 \\n               }\\n            }\\n        }\\n        \\n        if(row)\\n        {\\n            for(int i=0;i<matrix[0].size();i++)\\n            {\\n                matrix[0][i]=0;\\n            }\\n        }\\n        if(col)\\n        {\\n         for(int i=0;i<matrix.size();i++)\\n            {\\n                matrix[i][0]=0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443826,
                "title": "python-o-1-space-two-pass-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def setZeroes(self, matrix: List[List[int]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify matrix in-place instead.\\n        \"\"\"\\n        first_row = 0\\n        first_col = 0\\n        \\n        m = len(matrix)\\n        n = len(matrix[0])\\n        for row_i in range(m):\\n            for col_j in range(n):\\n                if matrix[row_i][col_j] == 0:\\n                    if row_i == 0:\\n                        first_row = 1\\n                    if col_j == 0:\\n                        first_col = 1\\n                    if row_i != 0 and col_j != 0:\\n                        # mark col_j has a zero\\n                        matrix[0][col_j] = 0\\n                        # mark row_i has a zero\\n                        matrix[row_i][0] = 0\\n        \\n        # set zero to rows         \\n        for row_i in range(1, m):\\n            if matrix[row_i][0] == 0:\\n                for col_j in range(n):\\n                    matrix[row_i][col_j] = 0\\n                    \\n        # set zero to columns         \\n        for col_j in range(1, n):\\n            if matrix[0][col_j] == 0:\\n                for row_i in range(m):\\n                    matrix[row_i][col_j] = 0\\n\\n        # set zero to first row\\n        if first_row == 1:\\n            for col_j in range(n):\\n                matrix[0][col_j] = 0\\n                \\n        # set zero to first column\\n        if first_col == 1:\\n            for row_i in range(m):\\n                matrix[row_i][0] = 0\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568894,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1568426,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1717997,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1567435,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1910323,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1896295,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 2072155,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1957833,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1723363,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1880578,
                "content": [
                    {
                        "username": "zarahan",
                        "content": "Why the expected output for [[0],[1]] is [[0],[1]]. I think the output should be [[0],[0]] because the first element '0' makes items in first column are set to be 0."
                    },
                    {
                        "username": "sam_heuer",
                        "content": "It might have been too long but master they did it, they corrected their mistake !"
                    },
                    {
                        "username": "xjs1997524",
                        "content": "in description, it says:\\n\\t-10^9 <= matrix[i][j] <= 10^9\\n\\t\\nAnd I am thinking to use Interger.MAX_VALUE to achieve Space O(1)\\nSince Interger.MAX_VALUE = 2^31 -1 > 10^9\\n\\nHowever it return a bad test case which contain\\n\\nInput : [[2147483647],[2],[3]]\\nOutput : [[0],[2],[3]]\\nExpected : [[2147483647],[2],[3]]\\n\\nLeetcode, make sure you modify the constrains in the description if you want to use test case outside the bound! :("
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "i just used -2765"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@garvit_17](/garvit_17) that will be in range of constraints"
                    },
                    {
                        "username": "garvit_17",
                        "content": "use INT_MAX-1 instead"
                    },
                    {
                        "username": "s230306",
                        "content": "Don\\'t Share the code here ."
                    },
                    {
                        "username": "rmglassman",
                        "content": "Then they should have constrained the range of values allowed in the matrix. Given the (lack of) constraints of the problem as written, it is **not possible** to set an integer flag that couldn\\'t also possibly come up as a value in the matrix. That\\'s an hour of my life I\\'ll never get back."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Agreed; this adds an extra layer of annoyance for C/C++\n\nUpdate: if you are taking this approach, you can use the value -423 as an 'invalid value'. I found out by luck that this value is not used by any of the TCs so it is accepted as a solution if using this approach.\n\nIdeally though this constraint should not be so restrictive, as this is not a 'true' solution, but its a workaround C/C++ people can use for a constant space approach"
                    },
                    {
                        "username": "zendemion",
                        "content": "[@reijers](/reijers) How do you go about finding the flag integer without using extra memory? Do you choose blindly and then iterate over entire matrix to see if it\\'s free?"
                    },
                    {
                        "username": "reijers",
                        "content": "It is possible. The matrix is small enough that there\\'s always an available integer. The problem is finding it. The followup question just asks for a constant space solution, so we can just try integers until we find a free one to use as a flag.\\nThis does make the worst case time O((nm)^2) so it seems like a stupid idea. But it\\'s possible."
                    },
                    {
                        "username": "james1995stewart",
                        "content": "Agreed. It also discriminates against C++ when compared, for example, with Python. In Python you can simply use a value outside the range as a flag; in C++ this is not possible. Why not just remove the strict inequalities from the range of permitted values, or restrict matrix entries to being positive values? This corner case is annoying and solving it is besides the point of the question."
                    },
                    {
                        "username": "vanshika29",
                        "content": "how do i solve with extra space ? Unable to create extra matrices\\n\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        int n=matrix[0].size();\\n        int row[n]={0};\\n        int col[m]={0};\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(matrix[i][j]==0)\\n                {\\n                   row[i]=1;\\n                   col[j]=1;\\n            \\n                }\\n            }\\n        }\\n\\n\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(row[i]==1 || col[j]==1)\\n                {\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n\\n        \\n    }\\n}\\n\\nerror:\\nLine 6: Char 17: error: variable-sized object may not be initialized\\n        int row[n]={0};\\n\\n\\nhow do i create a row/col with that size\\n"
                    },
                    {
                        "username": "Aman_Kumar_45",
                        "content": "vector<int> row(m,0),col(n,0);"
                    },
                    {
                        "username": "rohitsingh_mwc",
                        "content": " vector<int> row(n , 0);\\n vector<int> col(m , 0); work this program\\n"
                    },
                    {
                        "username": "Smital",
                        "content": "int* row = new int[m];  // Allocate memory for \\'m\\' integers\\n\\n        // Initialize all elements to 0\\n        for (int i = 0; i < m; i++) {\\n            row[i] = 0;\\n        }\\n\\nUse this instead"
                    },
                    {
                        "username": "TandooriRoti",
                        "content": "Use -> memset(row,0,n)"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The O(1) space solution to this question is actually really intuitive and it can help in many similar questions with larger scopes."
                    },
                    {
                        "username": "sk4142",
                        "content": "[@Ak_15](/Ak_15) lol read the constraints: -2^31 <= matrix[i][j] <= 2^31 - 1. if your code passes, it's only because the test cases were not comprehensive enough. "
                    },
                    {
                        "username": "TERNION2205",
                        "content": "[@Ak_15](/Ak_15) Hey bud, but this might cause a problem as one of the cells may contain -1, this will lead to discrepancies in the solution."
                    },
                    {
                        "username": "JadeEye",
                        "content": "[@Ak_15](/Ak_15) what if there are elements in the row as -1. It would falsely change it"
                    },
                    {
                        "username": "Ak_15",
                        "content": "bro its easy..  if the current position of a matrix is 0 means ... mark all the row and column from the current position to  -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space  "
                    },
                    {
                        "username": "ashu_kr",
                        "content": "can you tell some similar questions"
                    },
                    {
                        "username": "sk4142",
                        "content": "For the O(1) space solution, consider how we can incorporate the extra arrays in the O(m + n) memory solution into the matrix. \\n\\n- Hint: Use the first row and first column and use one extra boolean for when they overlap. "
                    },
                    {
                        "username": "layyy",
                        "content": "try storing the values in the matrix itself for O(1) space solution"
                    },
                    {
                        "username": "aryan_kx",
                        "content": "Runtime Error: what is the issue?\\n `\\nclass Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        int rows = matrix.size();\\n        int cols = matrix[0].size();\\n\\n        int x = 1;\\n        int y = 1;\\n\\n        // check if there is 0 in the horizontal marker\\n        for (int i=0; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                x = 0;\\n                break;\\n            }\\n        }\\n\\n        // check if there is 0 in the vertical marker\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0]==0) {\\n                y = 0;\\n                break;\\n            }\\n        }\\n        \\n        // check for inner matrix\\n        for (int i=1; i<rows; i++) {\\n            for (int j=1; j<cols; j++) {\\n                if (matrix[i][j]==0) {\\n                    matrix[0][j] = 0;\\n                    matrix[i][0] = 0;\\n                }\\n            }\\n        }\\n\\n        for (int i=1; i<cols; i++) {\\n            if (matrix[0][i]==0) {\\n                for (int j=1; j<rows; j++) {\\n                    matrix[i][j] = 0; \\n                }\\n            }\\n        }\\n\\n        for (int i=0; i<rows; i++) {\\n            if (matrix[i][0] == 0) {\\n                for (int j=1; j<cols; j++) {\\n                    matrix[i][j] = 0;\\n                }\\n            }\\n        }\\n        // check for x and y\\n        if (x==0) {\\n            for (int i=0; i<cols; i++) {\\n                matrix[0][i] = 0;\\n            }\\n        }\\n\\n        if (y==0) {\\n            for (int i=0; i<rows; i++) {\\n                matrix[i][0] = 0;\\n            }\\n        }\\n    }\\n};`"
                    },
                    {
                        "username": "mochiball",
                        "content": "The issue is you\\'re posting solutions here "
                    },
                    {
                        "username": "vivekmit06",
                        "content": "Thank you very much"
                    },
                    {
                        "username": "vertigofilip",
                        "content": "I did write this great code, that did turn number to one it one of its neighboring number is zero only to notice, that this in not the assignment. \\n`public class Solution {\\n    public void SetZeroes(int[][] matrix) {\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                Console.Write(i + \" \" + j);\\n                if(matrix[i][j]>0)\\n                {\\n                    Console.Write(\" tak\");\\n                    if(i-1>=0)\\n                    {\\n                        Console.Write(\" \" + matrix[i-1][j]);\\n                        if(matrix[i-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[matrix.Length-1][j]);\\n                        if(matrix[matrix.Length-1][j]==0) \\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j-1>=0) \\n                    {\\n                        Console.Write(\" \" + matrix[i][j-1]);\\n                        if(matrix[i][j-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][matrix[i].Length-1]);\\n                        if(matrix[i][matrix[i].Length-1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(i+1 < matrix.Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i+1][j]);\\n                        if(matrix[i+1][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[0][j]);\\n                        if(matrix[0][j]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    if(j+1 < matrix[i].Length)\\n                    {\\n                        Console.Write(\" \" + matrix[i][j+1]);\\n                        if(matrix[i][j+1]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                    else \\n                    {\\n                        Console.Write(\" \" + matrix[i][0]);\\n                        if(matrix[i][0]==0)\\n                            matrix[i][j]=-1;\\n                    }\\n                }\\n                Console.WriteLine(\" \");\\n            }\\n        }\\n        for(int i = 0; i < matrix.Length; i++)\\n        {\\n            for(int j = 0; j < matrix[i].Length; j++)\\n            {\\n                if(matrix[i][j]==-1) matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}`"
                    },
                    {
                        "username": "subhajitrajak",
                        "content": "indentation exists.. you know that right?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Nobody wants to read this garbage. Get it out of here please "
                    }
                ]
            },
            {
                "id": 1722130,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1751220,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2070767,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2049456,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2048904,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2045278,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2035724,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2022710,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2016559,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 2006780,
                "content": [
                    {
                        "username": "chandancp",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n          int col0=1;\\n          int rows=matrix.size();\\n          int cols=matrix[0].size();\\n          for(int i=0;i<rows;i++)\\n          {\\n              if(matrix[i][0]==0) col0=0;\\n              for(int j=1;j<cols;j++)\\n              if(matrix[i][j]==0)\\n              matrix[i][0]=matrix[0][j]=0;\\n          }\\n          for(int i=rows-1; i>=0;i--)\\n          {\\n              for(int j=cols-1;j>=1;j--)\\n              if(matrix[i][0]==0 or matrix[0][j]==0)\\n                 matrix[i][j]=0;\\n             if(col0==0) matrix[i][0]=0;\\n          }\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "xAdvitya",
                        "content": "try to visualize this problem "
                    },
                    {
                        "username": "ZaidMaraqa",
                        "content": "iterate over the matrix identify and store ] what rows and columns need to be set to zero. Then iterate over therows set them to zero. Then do the same with the columns. "
                    },
                    {
                        "username": "Aditya1647",
                        "content": "i have written for one 0 but, how to write for more than one 0s :("
                    },
                    {
                        "username": "sathwik175",
                        "content": "General Solution java with O(n^2)\\n `class Solution {\\n    public int[][] setZeroes(int[][] matrix) {\\n        HashSet<Integer> a=new HashSet<>();\\n        HashSet<Integer> b=new HashSet<>();\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(matrix[i][j]==0){\\n                    a.add(i);\\n                    b.add(j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<matrix.length;i++){\\n            for(int j=0;j<matrix[0].length;j++){\\n                if(a.contains(i)||b.contains(j)){\\n                    matrix[i][j]=0;\\n                }\\n            }\\n        }\\n        return matrix;\\n\\n    }\\n}`"
                    },
                    {
                        "username": "minhphamduy",
                        "content": "Simplest solution: just loop through with 2 new boolean[m], boolean[n] to mark [i][j] is true then loop one more to assign if boolean[i] or boolean[j] == true then assign its value to true"
                    },
                    {
                        "username": "rudrakshjadhav",
                        "content": "So, I was trying to do it the DFS, which I know is not needed. However, I was failing to code this problem due to the way, I am handling my visited array. Can anyone please help me in what should be corrected? I get an infinite recursion with my current functionality ofc.\n\n ```class Solution {\n    boolean[][] visited;\n    public void setZeroes(int[][] matrix) {\n        int maxR = matrix.length, maxC = matrix[0].length;\n        visited = new boolean[maxR][maxC];\n        for(int i=0;i<maxR;i++)\n        {\n            for(int j=0;j<maxC;j++)\n            {\n                if(matrix[i][j] == 0 && !visited[i][j])\n                {\n                    visited[i][j] = true;\n                    helperRow(matrix, i, j);\n                    helperCol(matrix, i, j);\n                }\n            }\n        }\n    }\n\n    public void helperRow(int[][] mat, int r, int c)\n    {\n        if(c < 0 || c>= mat[0].length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperRow(mat, r, c+ 1);\n        helperRow(mat, r, c -1);\n    }\n    public void helperCol(int[][] mat, int r, int c)\n    {\n        if(r < 0 || r>= mat.length || (mat[r][c] == 0 && !visited[r][c]))return;\n        visited[r][c] = true;\n        mat[r][c] = 0;\n        helperCol(mat, r + 1, c);\n        helperCol(mat, r - 1, c);\n    }\n}```"
                    },
                    {
                        "username": "sergei99",
                        "content": "It definitely shouldn\\'t be solved that way. O(mn) space and O(mn(m+n)) time - no way."
                    },
                    {
                        "username": "sergei99",
                        "content": "With all due respect guys, bashing Scala data structures in place seems to be a quite deficient use of the language. You should restate the interface for functional languages like \"take the source array or list and return the modified one\"."
                    },
                    {
                        "username": "arul96829",
                        "content": "Line 1034: Char 9: runtime error: reference binding to misaligned address 0xbebebebebebebebe for type \\'int\\', which requires 4 byte alignment (stl_vector.h)\\n0xbebebebebebebebe: note: pointer points here\\n<memory cannot be printed>\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h:1043:9\\ni dont know what to do\\ncould anyone help me\\n"
                    },
                    {
                        "username": "Chenbao2021",
                        "content": "Can we create a set in this question with \\'in place\\' constraint? "
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Follow up:\\n\\nA straightforward solution using O(mn) space is probably a bad idea.\\n*A simple improvement uses O(m + n) space, but still not the best solution.* -> you are here\\nCould you devise a constant space solution?"
                    }
                ]
            },
            {
                "id": 1977879,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1973443,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1970018,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968123,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1968121,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1959245,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1941395,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1931791,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1930988,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1878406,
                "content": [
                    {
                        "username": "mihirc0111",
                        "content": "Line 73: Char 7: error: use of undeclared identifier \\'Solution\\'\\n      Solution().setZeroes(param_1);                \\n   (How to solve this error ?)"
                    },
                    {
                        "username": "Ak_15",
                        "content": " Its easy to run in Constant Space .. if the current position of a matrix is 0 means ... mark all the row and column from the current position to -1 ... once you complete assigning to -1 .. traverse the matrix again and replace all the -1 to 0 ...This make the code to run in constant space.. Correct me if it is wrong .. Thanks !"
                    },
                    {
                        "username": "JInu",
                        "content": "-1 can also be an actual value in a matrix cell. So how do you distinguish between the cells that you've modified to -1 in order to flip it to zero and the initial -1 present in the cell. This will only work if the matrix[i][j]>=0, which is not the case."
                    },
                    {
                        "username": "SYDALAANJANEYAPRATAP123",
                        "content": "try to keep track of which col and row will turn in to zeros\\n"
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "this is easy\\n"
                    },
                    {
                        "username": "toktarbekar1",
                        "content": "\\u0434\\u0438 \\u043D\\u0430"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you, now we know it."
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "how to take input"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "[@madhukarbabulal5](/madhukarbabulal5) There is no need to take input in this question.. or in any question on leetcode.\nYou only need to complete the given function. (You may create some more functions according to needs)\nSo , The question is bogus in context of this problem "
                    },
                    {
                        "username": "madhukarbabulal5",
                        "content": "[@Sahil_Lohan](/Sahil_Lohan) python3\\nand i used to code on oj.masaischool.com\\n"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "According to your profile ..\\nYou are using python \\nHave you done DSA and problem solving on other platform before leetcode"
                    },
                    {
                        "username": "Sahil_Lohan",
                        "content": "Tell me two things first :\\nWhich language are you using \\nWhat you want as input"
                    },
                    {
                        "username": "eduard92",
                        "content": "I don\\'t understand the in place statement, like if first row has a 0, the whole row becomes 0 and the column, then I will encounters 0\\'s that are there because I altered the original matrix."
                    },
                    {
                        "username": "oops_moment",
                        "content": "So, By inplace they mean that you should make the final changes in the matrix given in the argument since the return type is void. In such cases you can always use a temporary matrix that is copy of original one. But here yes it can be acheived by taking two extra arrays one for row and other for col, more better can be just in O(1) space as well. Don\\'t wanna tell solution here but i hope it clears your doubt."
                    },
                    {
                        "username": "HARSHJ_04",
                        "content": "int m=matrix.size();\\n        int n=matrix[0].size();\\n        int x=0;\\n        int y=0;\\n        vector<pair<int,int>>mat1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            { \\n                if(matrix[i][j]==0)\\n                {\\n                    x=i;\\n                    y=j;\\n                  \\n                }\\n                mat1.push_back(make_pair(x,y));\\n\\n            }\\n        }\\n        for(auto it:mat1)\\n        {\\n            int x=it.first;\\n            int y=it.second;\\n            for(int i=0;i<m;i++)\\n            {\\n                matrix[i][y]=0;\\n            }\\n            for(int j=0;j<n;j++)\\n            {\\n                matrix[x][j]=0;\\n            }\\n        }\\nIn this approach why i am getting the wrong answer."
                    },
                    {
                        "username": "Tandra_Akash_Sharma",
                        "content": "WHY AM I GETTING THIS ERROR\\njava.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3\\n  at line 23, Solution.setZeroes\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nclass Solution {\\n    int[][] mat(int[][] mat,int r,int c){\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            if(mat[i][c]!=0)\\n            mat[i][c]=-1;\\n        }\\n        for(int i=0;i<mat[0].length;i++)\\n        {\\n            if(mat[r][i]!=0)\\n            mat[r][i]=0;\\n        }\\n        return mat;\\n    }\\n    public void setZeroes(int[][] matrix) {\\n        int rs=matrix.length;\\n        int cs=matrix[0].length;\\n\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\nline 23-----  if(matrix[i][j]==0)\\n                {\\n                    matrix=mat(matrix,i,j);\\n                }\\n            }\\n        }\\n        for(int i=0;i<rs;i++)\\n        {\\n            for(int j=0;i<cs;j++)\\n            {\\n                if(matrix[i][j]==-1)\\n                matrix[i][j]=0;\\n            }\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "Rishabh_Pandey",
                        "content": "==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n\\nany solutions??\\n"
                    },
                    {
                        "username": "arnab_01",
                        "content": "```\nclass Solution {\n    func setZeroes(_ matrix: inout [[Int]]) {\n        var rows: [Int: Int] = [:]\n        var columns: [Int: Int] = [:]\n        var n: Int = matrix.count\n\n        if n == 0 {\n            return\n        }\n\n        var m: Int = matrix[0].count\n\n        for i in 0 ..< n {\n            for j in 0 ..< m {\n                if matrix[i][j] == 0 {\n                    rows[i] = 1\n                    columns[j] = 1\n                }\n            }\n        }\n\n        for (row, flag) in rows {\n            for k in 0 ..< matrix[row].count {\n                matrix[row][k] = 0\n            }\n        }\n\n        for (column, flag) in columns {\n            for k in 0 ..< matrix[column].count {\n                matrix[k][column] = 0\n            }\n        }\n    }\n}\n```\n\nThis is giving me a `process exited with signal SIGILL` error. Can someone help me with whats wrong in the code?"
                    }
                ]
            },
            {
                "id": 1832037,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1832036,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1830790,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1754123,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1753767,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1746384,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1743408,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1724739,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710064,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            },
            {
                "id": 1710042,
                "content": [
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "spjp2003",
                        "content": "How do I give input as 2D array using square brackets in C?"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n    void setZeroes(vector<vector<int>>& matrix) {\\n        unordered_set<int>r,c;\\n        int n = matrix.size() , m =matrix[0].size();\\n        int i , j ;\\n        for( i =0 ; i<n;i++){\\n            for( j =i+1 ; j<n;i++){\\n                if(!matrix[i][j]){\\n                    r.insert[i];\\n                    c.insert[j];\\n                }\\n            }\\n        }\\n        for(auto &i:r){\\n                    for(int j = 0 ; j<m;j++){\\n                        matrix[i][j] ==0; \\n                    }\\n        }\\n        for(auto &i:c){\\n            for(int j = 0 ; j<n;j++){\\n                matrix[i][j] ==0; \\n            }           \\n        }\\n    }\\n};\\n\\n\\ncan your please tell me which step of my code is wrong \\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "tauffiqckeraja",
                        "content": "Best java solution : tc=  O(n*m +n*m)//\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int rows= matrix.length;\n        int cols = matrix[0].length;\n        // making two two dummy arrays and filling -1 value inside it;\n        int []dummy1  = new int[rows];\n        int []dummy2  = new int[cols];\n\n            Arrays.fill(dummy1, -1);\n            Arrays.fill(dummy2, -1);\n // if value of index is 0 then assign the value of  row and column 0;\n        for(int i = 0;i<rows;i++){\n            for(int j = 0;j<cols;j++){\n                if(matrix[i][j]==0){\n                    dummy1[i]=0;\n                    dummy2[j]=0;\n                }\n            }\n        }  \n            // if the given element is already zero then  put zero at every value related to that row and column\n        for(int i =0;i<rows;i++){\n            for(int j=0;j<cols;j++){\n                if(dummy1 [i]== 0 || dummy2 [j] == 0){\n                    matrix[i][j]=0;\n                }\n            }\n        }\n        \n         }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best Leetcode rules.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "svas7246",
                        "content": "what is the one corner case that actually fails"
                    },
                    {
                        "username": "ShashankChaturvedi",
                        "content": "1)-iterate the matrix column wise and if you find a zero, mark all zeros present in that column as None and make rest of the numbers zero.\\n2)-iterate row wise and search for None, if None is present mark the  entire row zero."
                    },
                    {
                        "username": "Ravish01_1980",
                        "content": "what is the problem in this code?\\n\\n\\nclass Solution \\n{\\n    public:\\n    void setZeroes(vector<vector<int>>& matrix) \\n    {\\n        int rows = sizeof matrix / sizeof matrix[0];\\n        int cols = sizeof matrix[0] / sizeof matrix[0][0];\\n        for(int i=0;i<rows;i++)\\n        {\\n            for(int j=0;j<cols;j++)\\n            {\\n                if (matrix[i][j]==0)\\n                {\\n                    for (int k=0;k<rows;k++)\\n                    {\\n                        matrix[i][k]=0;\\n                    }\\n                    for(int k=0;k<cols;k++)\\n                    {\\n                        matrix[k][j]=0;\\n                    }\\n                }\\n            }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "zbr_98",
                        "content": "You\\'re making the elements of next rows to 0 before even going to those rows.\\nMatrix shouldn\\'t be altered before iterating through all rows and columns."
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "```class Solution:\n    def setZeroes(self, matrix: List[List[int]]) -> None:\n        col1=1\n        row=len(matrix)\n        col=len(matrix[0])\n        for i in range(row):\n            if matrix[i][0]==0:\n                col1=0\n            for j in range(1,col):\n                if matrix[i][j]==0:\n                    matrix[i][0]= matrix[0][j]=0\n        for i in range((row-1),-1,-1):\n            for j in range((col-1),-1,-1):\n                if matrix[0][j]==0 or matrix[i][0]==0:\n                    matrix[i][j]=0\n            if col1==0:\n                matrix[i][0]=0\n```"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Csubhdeep",
                        "content": "[@prashantkumarshee](/prashantkumarshee) \\n\\nfor i in range(n-1,-1,-1):\\n            for j in range(1, m):\\n                # print(i,j)\\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\\n                    matrix[i][j] = 0\\n            if col == False:\\n                matrix[i][0] = 0\\n\\njust use this.. "
                    },
                    {
                        "username": "prashantkumarshee",
                        "content": "can anyone find out my mistake??"
                    },
                    {
                        "username": "priyanka2061",
                        "content": "very easy and good for beginners with (m+n) space complexity\n\n\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        int m=matrix.length;\n      int t = matrix[0].length;\n    boolean row[]=new boolean [m];\n     boolean col[]=new boolean [t];\n \n    for(int i=0;i<matrix.length;i++)\n    {\n        for(int j=0;j<t;j++)\n        {\n            if(matrix[i][j]==0)\n            {\n                col[j]=true;\n                row[i]=true;\n            }\n                // col[i]=false;\n                // row[i]=false;\n        }\n    }\n        for(int i=0;i<matrix.length;i++)\n    {     \n        if(row[i])\n        {\n        for(int j=0;j<t;j++)\n        {\n            \n              matrix[i][j]=0;\n        \n        }\n        }\n    }\n    for(int i=0;i<m;i++)\n    {     \n       \n        for(int j=0;j<t;j++)\n        {   if(col[j])\n        {\n              matrix[i][j]=0;\n            }\n        }\n    }\n        \n    \n    }\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Very easy rules and good for beginners with no space complexity.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Search Tree Iterator",
        "question_content": "<p>Implement the <code>BSTIterator</code> class that represents an iterator over the <strong><a href=\"https://en.wikipedia.org/wiki/Tree_traversal#In-order_(LNR)\" target=\"_blank\">in-order traversal</a></strong> of a binary search tree (BST):</p>\n\n<ul>\n\t<li><code>BSTIterator(TreeNode root)</code> Initializes an object of the <code>BSTIterator</code> class. The <code>root</code> of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.</li>\n\t<li><code>boolean hasNext()</code> Returns <code>true</code> if there exists a number in the traversal to the right of the pointer, otherwise returns <code>false</code>.</li>\n\t<li><code>int next()</code> Moves the pointer to the right, then returns the number at the pointer.</li>\n</ul>\n\n<p>Notice that by initializing the pointer to a non-existent smallest number, the first call to <code>next()</code> will return the smallest element in the BST.</p>\n\n<p>You may assume that <code>next()</code> calls will always be valid. That is, there will be at least a next number in the in-order traversal when <code>next()</code> is called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2018/12/25/bst-tree.png\" style=\"width: 189px; height: 178px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;BSTIterator&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;, &quot;next&quot;, &quot;hasNext&quot;]\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\n<strong>Output</strong>\n[null, 3, 7, true, 9, true, 15, true, 20, false]\n\n<strong>Explanation</strong>\nBSTIterator bSTIterator = new BSTIterator([7, 3, 15, null, null, 9, 20]);\nbSTIterator.next();    // return 3\nbSTIterator.next();    // return 7\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 9\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 15\nbSTIterator.hasNext(); // return True\nbSTIterator.next();    // return 20\nbSTIterator.hasNext(); // return False\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>6</sup></code></li>\n\t<li>At most <code>10<sup>5</sup></code> calls will be made to <code>hasNext</code>, and <code>next</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong></p>\n\n<ul>\n\t<li>Could you implement <code>next()</code> and <code>hasNext()</code> to run in average <code>O(1)</code> time and use&nbsp;<code>O(h)</code> memory, where <code>h</code> is the height of the tree?</li>\n</ul>\n",
        "solutions": [
            {
                "id": 52525,
                "title": "my-solutions-in-3-languages-with-stack",
                "content": "I use Stack to store directed left children from root.\\nWhen next() be called, I just pop one element and process its right child as new root.\\nThe code is pretty straightforward.\\n\\nSo this can satisfy O(h) memory, hasNext() in O(1) time,\\nBut next() is O(h) time.\\n\\nI can't find a solution that can satisfy both next() in O(1) time, space in O(h).\\n\\nJava:\\n\\n    public class BSTIterator {\\n        private Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode tmpNode = stack.pop();\\n            pushAll(tmpNode.right);\\n            return tmpNode.val;\\n        }\\n        \\n        private void pushAll(TreeNode node) {\\n            for (; node != null; stack.push(node), node = node.left);\\n        }\\n    }\\n\\nC++:\\n\\n\\n    class BSTIterator {\\n        stack<TreeNode *> myStack;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !myStack.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode *tmpNode = myStack.top();\\n            myStack.pop();\\n            pushAll(tmpNode->right);\\n            return tmpNode->val;\\n        }\\n    \\n    private:\\n        void pushAll(TreeNode *node) {\\n            for (; node != NULL; myStack.push(node), node = node->left);\\n        }\\n    };\\n\\n\\nPython:\\n\\n    class BSTIterator:\\n        # @param root, a binary search tree's root node\\n        def __init__(self, root):\\n            self.stack = list()\\n            self.pushAll(root)\\n    \\n        # @return a boolean, whether we have a next smallest number\\n        def hasNext(self):\\n            return self.stack\\n    \\n        # @return an integer, the next smallest number\\n        def next(self):\\n            tmpNode = self.stack.pop()\\n            self.pushAll(tmpNode.right)\\n            return tmpNode.val\\n            \\n        def pushAll(self, node):\\n            while node is not None:\\n                self.stack.append(node)\\n                node = node.left",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "I use Stack to store directed left children from root.\\nWhen next() be called, I just pop one element and process its right child as new root.\\nThe code is pretty straightforward.\\n\\nSo this can satisfy O(h) memory, hasNext() in O(1) time,\\nBut next() is O(h) time.\\n\\nI can't find a solution that can satisfy both next() in O(1) time, space in O(h).\\n\\nJava:\\n\\n    public class BSTIterator {\\n        private Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        public BSTIterator(TreeNode root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode tmpNode = stack.pop();\\n            pushAll(tmpNode.right);\\n            return tmpNode.val;\\n        }\\n        \\n        private void pushAll(TreeNode node) {\\n            for (; node != null; stack.push(node), node = node.left);\\n        }\\n    }\\n\\nC++:\\n\\n\\n    class BSTIterator {\\n        stack<TreeNode *> myStack;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            pushAll(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !myStack.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode *tmpNode = myStack.top();\\n            myStack.pop();\\n            pushAll(tmpNode->right);\\n            return tmpNode->val;\\n        }\\n    \\n    private:\\n        void pushAll(TreeNode *node) {\\n            for (; node != NULL; myStack.push(node), node = node->left);\\n        }\\n    };\\n\\n\\nPython:\\n\\n    class BSTIterator:\\n        # @param root, a binary search tree's root node\\n        def __init__(self, root):\\n            self.stack = list()\\n            self.pushAll(root)\\n    \\n        # @return a boolean, whether we have a next smallest number\\n        def hasNext(self):\\n            return self.stack\\n    \\n        # @return an integer, the next smallest number\\n        def next(self):\\n            tmpNode = self.stack.pop()\\n            self.pushAll(tmpNode.right)\\n            return tmpNode.val\\n            \\n        def pushAll(self, node):\\n            while node is not None:\\n                self.stack.append(node)\\n                node = node.left",
                "codeTag": "Java"
            },
            {
                "id": 52526,
                "title": "ideal-solution-using-stack-java",
                "content": "My idea comes from this: My first thought was to use inorder traversal to put every node into an array, and then make an index pointer for the next() and hasNext(). That meets the O(1) run time but not the O(h) memory. O(h) is really much more less than O(n) when the tree is huge.\\n\\nThis means I cannot use a lot of memory, which suggests that I need to make use of the tree structure itself. And also, one thing to notice is the \"average O(1) run time\". It's weird to say average O(1), because there's nothing below O(1) in run time, which suggests in most cases, I solve it in O(1), while in some cases, I need to solve it in O(n) or O(h). These two limitations are big hints.\\n\\nBefore I come up with this solution, I really draw a lot binary trees and try inorder traversal on them. We all know that, once you get to a TreeNode, in order to get the smallest, you need to go all the way down its left branch. So our first step is to point to pointer to the left most TreeNode. The problem is how to do back trace. Since the TreeNode doesn't have father pointer, we cannot get a TreeNode's father node in O(1) without store it beforehand. Back to the first step, when we are traversal to the left most TreeNode, we store each TreeNode we met ( They are all father nodes for back trace). \\n\\nAfter that, I try an example, for next(), I directly return where the pointer pointing at, which should be the left most TreeNode I previously found. What to do next? After returning the smallest TreeNode, I need to point the pointer to the next smallest TreeNode. When the current TreeNode has a right branch (It cannot have left branch, remember we traversal to the left most), we need to jump to its right child first and then traversal to its right child's left most TreeNode. When the current TreeNode doesn't have a right branch, it means there cannot be a node with value smaller than itself father node, point the pointer at its father node.\\n\\nThe overall thinking leads to the structure Stack, which fits my requirement so well.\\n\\n    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    \\n    public class BSTIterator {\\n        \\n        private Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n            TreeNode cur = root;\\n            while(cur != null){\\n                stack.push(cur);\\n                if(cur.left != null)\\n                    cur = cur.left;\\n                else\\n                    break;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n            TreeNode cur = node;\\n            // traversal right branch\\n            if(cur.right != null){\\n                cur = cur.right;\\n                while(cur != null){\\n                    stack.push(cur);\\n                    if(cur.left != null)\\n                        cur = cur.left;\\n                    else\\n                        break;\\n                }\\n            }\\n            return node.val;\\n        }\\n    }\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = new BSTIterator(root);\\n     * while (i.hasNext()) v[f()] = i.next();\\n     */",
                "solutionTags": [
                    "Java"
                ],
                "code": "My idea comes from this: My first thought was to use inorder traversal to put every node into an array, and then make an index pointer for the next() and hasNext(). That meets the O(1) run time but not the O(h) memory. O(h) is really much more less than O(n) when the tree is huge.\\n\\nThis means I cannot use a lot of memory, which suggests that I need to make use of the tree structure itself. And also, one thing to notice is the \"average O(1) run time\". It's weird to say average O(1), because there's nothing below O(1) in run time, which suggests in most cases, I solve it in O(1), while in some cases, I need to solve it in O(n) or O(h). These two limitations are big hints.\\n\\nBefore I come up with this solution, I really draw a lot binary trees and try inorder traversal on them. We all know that, once you get to a TreeNode, in order to get the smallest, you need to go all the way down its left branch. So our first step is to point to pointer to the left most TreeNode. The problem is how to do back trace. Since the TreeNode doesn't have father pointer, we cannot get a TreeNode's father node in O(1) without store it beforehand. Back to the first step, when we are traversal to the left most TreeNode, we store each TreeNode we met ( They are all father nodes for back trace). \\n\\nAfter that, I try an example, for next(), I directly return where the pointer pointing at, which should be the left most TreeNode I previously found. What to do next? After returning the smallest TreeNode, I need to point the pointer to the next smallest TreeNode. When the current TreeNode has a right branch (It cannot have left branch, remember we traversal to the left most), we need to jump to its right child first and then traversal to its right child's left most TreeNode. When the current TreeNode doesn't have a right branch, it means there cannot be a node with value smaller than itself father node, point the pointer at its father node.\\n\\nThe overall thinking leads to the structure Stack, which fits my requirement so well.\\n\\n    /**\\n     * Definition for binary tree\\n     * public class TreeNode {\\n     *     int val;\\n     *     TreeNode left;\\n     *     TreeNode right;\\n     *     TreeNode(int x) { val = x; }\\n     * }\\n     */\\n    \\n    public class BSTIterator {\\n        \\n        private Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n            TreeNode cur = root;\\n            while(cur != null){\\n                stack.push(cur);\\n                if(cur.left != null)\\n                    cur = cur.left;\\n                else\\n                    break;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n            TreeNode cur = node;\\n            // traversal right branch\\n            if(cur.right != null){\\n                cur = cur.right;\\n                while(cur != null){\\n                    stack.push(cur);\\n                    if(cur.left != null)\\n                        cur = cur.left;\\n                    else\\n                        break;\\n                }\\n            }\\n            return node.val;\\n        }\\n    }\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = new BSTIterator(root);\\n     * while (i.hasNext()) v[f()] = i.next();\\n     */",
                "codeTag": "Java"
            },
            {
                "id": 52647,
                "title": "nice-comparison-and-short-solution",
                "content": "Compare this typical iterative inorder traversal\\n\\n    1.    TreeNode visit = root;\\n          Stack<TreeNode> stack = new Stack();\\n    2.    while (visit != null || !stack.empty()) {\\n    3.        while (visit != null) {\\n                  stack.push(visit);\\n                  visit = visit.left;\\n              }\\n              TreeNode next = stack.pop();\\n              visit = next.right;\\n              doSomethingWith(next.val);\\n          }\\n\\nwith what we're supposed to support here:\\n\\n    1.    BSTIterator i = new BSTIterator(root);\\n    2.    while (i.hasNext())\\n    3.        doSomethingWith(i.next());\\n\\nYou can see they already have the exact same structure:\\n\\n1. Some **initialization**.\\n2. A while-loop with **a condition that tells whether there is more**.\\n3. The loop body **gets the next value** and does something with it.\\n\\nSo simply put the three parts of that iterative solution into our three iterator methods:\\n\\n    public class BSTIterator {\\n    \\n        private TreeNode visit;\\n        private Stack<TreeNode> stack;\\n        \\n        public BSTIterator(TreeNode root) {\\n            visit = root;\\n            stack = new Stack();\\n        }\\n    \\n        public boolean hasNext() {\\n            return visit != null || !stack.empty();\\n        }\\n    \\n        public int next() {\\n            while (visit != null) {\\n                stack.push(visit);\\n                visit = visit.left;\\n            }\\n            TreeNode next = stack.pop();\\n            visit = next.right;\\n            return next.val;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Compare this typical iterative inorder traversal\\n\\n    1.    TreeNode visit = root;\\n          Stack<TreeNode> stack = new Stack();\\n    2.    while (visit != null || !stack.empty()) {\\n    3.        while (visit != null) {\\n                  stack.push(visit);\\n                  visit = visit.left;\\n              }\\n              TreeNode next = stack.pop();\\n              visit = next.right;\\n              doSomethingWith(next.val);\\n          }\\n\\nwith what we're supposed to support here:\\n\\n    1.    BSTIterator i = new BSTIterator(root);\\n    2.    while (i.hasNext())\\n    3.        doSomethingWith(i.next());\\n\\nYou can see they already have the exact same structure:\\n\\n1. Some **initialization**.\\n2. A while-loop with **a condition that tells whether there is more**.\\n3. The loop body **gets the next value** and does something with it.\\n\\nSo simply put the three parts of that iterative solution into our three iterator methods:\\n\\n    public class BSTIterator {\\n    \\n        private TreeNode visit;\\n        private Stack<TreeNode> stack;\\n        \\n        public BSTIterator(TreeNode root) {\\n            visit = root;\\n            stack = new Stack();\\n        }\\n    \\n        public boolean hasNext() {\\n            return visit != null || !stack.empty();\\n        }\\n    \\n        public int next() {\\n            while (visit != null) {\\n                stack.push(visit);\\n                visit = visit.left;\\n            }\\n            TreeNode next = stack.pop();\\n            visit = next.right;\\n            return next.val;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1430547,
                "title": "c-simple-solution-using-stack-o-h-time-complexity-with-diagrammatic-explanation",
                "content": "We could have easily done this question by using inorder traversal and storing it in a vector after that iterating every index of vector for next() value and if the index is equal to vector size then hasnext() becomes false else it would be true.\\n\\nBut in question, it is given that we have to do it in **0(h) memory, where h is the height of the tree.** So now we will make use of the stack and instead of inorder traversal, we would use partial inorder traversal so that at any instant of time the stack contains elements equal to the height of the tree.\\n\\n**Step 1:** We will push the left part of the tree into a stack which is 7 and then 3 is inserted. Now is **next()** is called 3 is stored as the top and then poped now we will push the right of 3 but it does not contain any so we just return the top->val i.e. 3.\\n\\n**Step 2:** We will now **pop()** 7 from the stack and see if it has the right children yes it has so we push 15 and then 9 into the stack. Observe here you\\'ll see at a time stack contains elements equal to the height of the tree. \\n\\n**Step 3:** Now 9 is poped and 9 does contain any right child so we move on 15. If **hasnext()** is called it would return true as traversal is still left and the stack is also not empty.\\n\\n**Step 4:** Now 15 is poped and checked if it has the right child yes it has i.e. 20 so 20 is pushed inside the stack.\\n\\n**Step 5:** Lastly 20 is poped and returned and after that is **hasnext()** is called it will return false as there are no more elements or children inside the stack.\\n\\n![image](https://assets.leetcode.com/users/images/57090108-e111-4449-b518-a3f2951be06a_1630145672.8967223.png)\\n\\n\\n\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> s;\\n    BSTIterator(TreeNode* root) {\\n        partialInorder(root);\\n    }\\n    \\n    void partialInorder(TreeNode* root){\\n        while(root != NULL){\\n            s.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* top = s.top();\\n        s.pop();\\n        partialInorder(top->right);\\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```\\n\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> s;\\n    BSTIterator(TreeNode* root) {\\n        partialInorder(root);\\n    }\\n    \\n    void partialInorder(TreeNode* root){\\n        while(root != NULL){\\n            s.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* top = s.top();\\n        s.pop();\\n        partialInorder(top->right);\\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52642,
                "title": "two-python-solutions-stack-and-generator",
                "content": "stack solution: \\n\\n\\n    def __init__(self, root):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return len(self.stack) > 0\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        node = self.stack.pop()\\n        x = node.right\\n        while x:\\n            self.stack.append(x)\\n            x = x.left\\n        return node.val\\n\\ngenerator solution:\\n    \\n    def __init__(self, root):\\n        self.last = root\\n        while self.last and self.last.right:\\n            self.last = self.last.right\\n        self.current = None\\n        self.g = self.iterate(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return self.current is not self.last\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        return next(self.g)\\n        \\n    def iterate(self, node):\\n        if node is None:\\n            return\\n        for x in self.iterate(node.left):\\n            yield x\\n        self.current = node\\n        yield node.val\\n        for x in self.iterate(node.right):\\n            yield x",
                "solutionTags": [
                    "Python"
                ],
                "code": "stack solution: \\n\\n\\n    def __init__(self, root):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return len(self.stack) > 0\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        node = self.stack.pop()\\n        x = node.right\\n        while x:\\n            self.stack.append(x)\\n            x = x.left\\n        return node.val\\n\\ngenerator solution:\\n    \\n    def __init__(self, root):\\n        self.last = root\\n        while self.last and self.last.right:\\n            self.last = self.last.right\\n        self.current = None\\n        self.g = self.iterate(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        return self.current is not self.last\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        return next(self.g)\\n        \\n    def iterate(self, node):\\n        if node is None:\\n            return\\n        for x in self.iterate(node.left):\\n            yield x\\n        self.current = node\\n        yield node.val\\n        for x in self.iterate(node.right):\\n            yield x",
                "codeTag": "Python3"
            },
            {
                "id": 52519,
                "title": "my-solution-in-c-in-average-o-1-time-and-uses-o-h-memory",
                "content": "    class BSTIterator {\\n    private:\\n        stack<TreeNode*> st;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            find_left(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            if (st.empty())\\n                return false;\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* top = st.top();\\n            st.pop();\\n            if (top->right != NULL)\\n                find_left(top->right);\\n                \\n            return top->val;\\n        }\\n        \\n        /** put all the left child() of root */\\n        void find_left(TreeNode* root)\\n        {\\n            TreeNode* p = root;\\n            while (p != NULL)\\n            {\\n                st.push(p);\\n                p = p->left;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n    private:\\n        stack<TreeNode*> st;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            find_left(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            if (st.empty())\\n                return false;\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* top = st.top();\\n            st.pop();\\n            if (top->right != NULL)\\n                find_left(top->right);\\n                \\n            return top->val;\\n        }\\n        \\n        /** put all the left child() of root */\\n        void find_left(TreeNode* root)\\n        {\\n            TreeNode* p = root;\\n            while (p != NULL)\\n            {\\n                st.push(p);\\n                p = p->left;\\n            }\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1965120,
                "title": "easy-iterative-using-stack-space-o-h-instead-of-o-n",
                "content": "If you like, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Brute force way - You can do in-order traversal and put each element into an ArrayList (additional space). \\n\\t\\tThen use that to check hasNext() or next() element. However, that approach will use extra space of O(n).\\n\\t2. This approach:\\n\\t\\ta) Here we will use our own Stack (basically do in-order traversal Iteratively, instead of recursively). \\n\\t\\t   Reason, being we have more control here and no need to use extra space of O(n) for ArrayList to store all elements first. \\n\\t\\tb) We get space of O(h) only instead of O(n). [h: is height of tree]\\t\\n\\n## Code:\\n\\n\\t// 15 ms, faster than 82.33% \\n\\tclass BSTIterator {\\n\\t\\tStack<TreeNode> stack;\\n\\t\\tpublic BSTIterator(TreeNode root) {\\n\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\tTreeNode node = root;\\n\\t\\t\\tupdateStack(node);                                      // update stack\\n\\t\\t}\\n\\t\\tpublic int next() {\\n\\t\\t\\tTreeNode toRemove = stack.pop();\\n\\t\\t\\tupdateStack(toRemove.right);                             // before return node, first update stack further        \\n\\t\\t\\treturn toRemove.val;\\n\\t\\t}\\n\\t\\tpublic boolean hasNext() {\\n\\t\\t\\treturn !stack.isEmpty();    \\n\\t\\t}\\n\\t\\t// -------------------\\n\\t\\tpublic void updateStack(TreeNode node){\\n\\t\\t\\twhile(node != null){\\n\\t\\t\\t\\tstack.add(node);\\n\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Iterator"
                ],
                "code": "If you like, pls **Upvote** :)\\n\\n## Approach:\\n\\t1. Brute force way - You can do in-order traversal and put each element into an ArrayList (additional space). \\n\\t\\tThen use that to check hasNext() or next() element. However, that approach will use extra space of O(n).\\n\\t2. This approach:\\n\\t\\ta) Here we will use our own Stack (basically do in-order traversal Iteratively, instead of recursively). \\n\\t\\t   Reason, being we have more control here and no need to use extra space of O(n) for ArrayList to store all elements first. \\n\\t\\tb) We get space of O(h) only instead of O(n). [h: is height of tree]\\t\\n\\n## Code:\\n\\n\\t// 15 ms, faster than 82.33% \\n\\tclass BSTIterator {\\n\\t\\tStack<TreeNode> stack;\\n\\t\\tpublic BSTIterator(TreeNode root) {\\n\\t\\t\\tstack = new Stack<>();\\n\\t\\t\\tTreeNode node = root;\\n\\t\\t\\tupdateStack(node);                                      // update stack\\n\\t\\t}\\n\\t\\tpublic int next() {\\n\\t\\t\\tTreeNode toRemove = stack.pop();\\n\\t\\t\\tupdateStack(toRemove.right);                             // before return node, first update stack further        \\n\\t\\t\\treturn toRemove.val;\\n\\t\\t}\\n\\t\\tpublic boolean hasNext() {\\n\\t\\t\\treturn !stack.isEmpty();    \\n\\t\\t}\\n\\t\\t// -------------------\\n\\t\\tpublic void updateStack(TreeNode node){\\n\\t\\t\\twhile(node != null){\\n\\t\\t\\t\\tstack.add(node);\\n\\t\\t\\t\\tnode = node.left;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\nIf any questions/suggestions, comment down below.\\nIf you liked the explanation/dry run, pls **Upvote** :)",
                "codeTag": "Java"
            },
            {
                "id": 965584,
                "title": "python-stack-clean-concise-time-o-1-space-o-h",
                "content": "**Idea**\\n- We use stack to store elements, the top of element is the next smallest element. The size of stack is up to height of the BST.\\n- This problem is good base to solve following questions in `O(H)` in Space Complexity.\\n\\t- **[653. Two Sum IV - Input is a BST](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/discuss/1420711)**.\\n\\t- **[230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/discuss/642294)**.\\n```python\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.st = []\\n        self.pushLeft(root)\\n        \\n    def pushLeft(self, root):\\n        while root != None:\\n            self.st.append(root)\\n            root = root.left\\n\\n    def next(self):\\n        node = self.st.pop()\\n        self.pushLeft(node.right)\\n        return node.val\\n\\n    def hasNext(self):\\n        return len(self.st) > 0\\n```\\nComplexity:\\n- Time: `O(1)`\\n- Space: `O(H)`, where `H` is the height of the BST.",
                "solutionTags": [],
                "code": "```python\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.st = []\\n        self.pushLeft(root)\\n        \\n    def pushLeft(self, root):\\n        while root != None:\\n            self.st.append(root)\\n            root = root.left\\n\\n    def next(self):\\n        node = self.st.pop()\\n        self.pushLeft(node.right)\\n        return node.val\\n\\n    def hasNext(self):\\n        return len(self.st) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52584,
                "title": "my-java-accepted-solution",
                "content": "the idea is same as using stack to do Binary Tree Inorder Traversal    \\n\\n    public class BSTIterator {\\n        \\n            Stack<TreeNode> stack =  null ;            \\n            TreeNode current = null ;\\n        \\t\\n            public BSTIterator(TreeNode root) {\\n            \\t  current = root;\\t     \\n            \\t  stack = new Stack<> ();\\n        \\t}\\n        \\n        \\t/** @return whether we have a next smallest number */\\n        \\tpublic boolean hasNext() {\\t\\t  \\n        \\t      return !stack.isEmpty() || current != null;  \\n        \\t}\\n        \\n        \\t    /** @return the next smallest number */\\n        \\tpublic int next() {\\n        \\t\\twhile (current != null) {\\n        \\t\\t\\tstack.push(current);\\n        \\t\\t\\tcurrent = current.left ;\\n        \\t\\t}\\t\\t\\n        \\t\\tTreeNode t = stack.pop() ;\\t\\t\\n        \\t\\tcurrent = t.right ;\\t\\t\\n        \\t\\treturn t.val ;\\n        \\t}\\n        }",
                "solutionTags": [],
                "code": "the idea is same as using stack to do Binary Tree Inorder Traversal    \\n\\n    public class BSTIterator {\\n        \\n            Stack<TreeNode> stack =  null ;            \\n            TreeNode current = null ;\\n        \\t\\n            public BSTIterator(TreeNode root) {\\n            \\t  current = root;\\t     \\n            \\t  stack = new Stack<> ();\\n        \\t}\\n        \\n        \\t/** @return whether we have a next smallest number */\\n        \\tpublic boolean hasNext() {\\t\\t  \\n        \\t      return !stack.isEmpty() || current != null;  \\n        \\t}\\n        \\n        \\t    /** @return the next smallest number */\\n        \\tpublic int next() {\\n        \\t\\twhile (current != null) {\\n        \\t\\t\\tstack.push(current);\\n        \\t\\t\\tcurrent = current.left ;\\n        \\t\\t}\\t\\t\\n        \\t\\tTreeNode t = stack.pop() ;\\t\\t\\n        \\t\\tcurrent = t.right ;\\t\\t\\n        \\t\\treturn t.val ;\\n        \\t}\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 52705,
                "title": "morris-traverse-solution",
                "content": "Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.\\nTo implement a iterator means we should traverse the tree step by step, so just split the inorder traversal.\\n\\n    class BSTIterator {\\n    public:\\n    BSTIterator(TreeNode *root) {\\n        p = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return p != NULL;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        TreeNode *tmp;\\n        int ret;\\n        while(p) {\\n            if (p->left == NULL) {  \\n                ret = p->val;\\n                p = p->right;\\n                break;\\n            }  \\n            else {  \\n                tmp = p->left;  \\n                while (tmp->right != NULL && tmp->right != p)  \\n                    tmp = tmp->right;  \\n                if (tmp->right == NULL) {  \\n                    tmp->right = p;  \\n                    p = p->left;  \\n                }  \\n                else {\\n                    ret = p->val;\\n                    tmp->right = NULL;  \\n                    p = p->right;\\n                    break;\\n                }  \\n            }  \\n        }\\n        \\n        return ret;\\n    }\\n    \\n    TreeNode *p;\\n    };",
                "solutionTags": [],
                "code": "Traverse a BST from the smallest to the largest, then i solve this question simply use the inorder traversal.\\nTo implement a iterator means we should traverse the tree step by step, so just split the inorder traversal.\\n\\n    class BSTIterator {\\n    public:\\n    BSTIterator(TreeNode *root) {\\n        p = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return p != NULL;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        TreeNode *tmp;\\n        int ret;\\n        while(p) {\\n            if (p->left == NULL) {  \\n                ret = p->val;\\n                p = p->right;\\n                break;\\n            }  \\n            else {  \\n                tmp = p->left;  \\n                while (tmp->right != NULL && tmp->right != p)  \\n                    tmp = tmp->right;  \\n                if (tmp->right == NULL) {  \\n                    tmp->right = p;  \\n                    p = p->left;  \\n                }  \\n                else {\\n                    ret = p->val;\\n                    tmp->right = NULL;  \\n                    p = p->right;\\n                    break;\\n                }  \\n            }  \\n        }\\n        \\n        return ret;\\n    }\\n    \\n    TreeNode *p;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 1965329,
                "title": "may-be-you-understand",
                "content": "![image](https://assets.leetcode.com/users/images/6e21daf9-a01f-4c72-be97-8d4d2f21080f_1650423956.0233808.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/3aaf9068-6762-403c-b888-786bed02c41d_1650423967.7870433.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/a6943ed3-34a2-499a-8330-e665ff0822f4_1650423988.6830766.jpeg)\\n\\n```\\nclass BSTIterator {\\n    Stack<TreeNode> st;\\n    public BSTIterator(TreeNode root) {\\n        st = new Stack<>();\\n        addAllLeft(root);\\n    }\\n    public void addAllLeft(TreeNode root){\\n        while(root != null){\\n            st.push(root);\\n            root = root.left;\\n        }\\n    }\\n    public int next() {\\n        TreeNode topValue = st.pop();\\n        addAllLeft(topValue.right);\\n        return topValue.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return st.size() != 0;\\n    }\\n}\\n```\\n\\n<hr>\\n<hr>\\n\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N)\\n\\n* **Space Complexity :-** BigO(logN)\\n\\n<hr>\\n<hr>",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    Stack<TreeNode> st;\\n    public BSTIterator(TreeNode root) {\\n        st = new Stack<>();\\n        addAllLeft(root);\\n    }\\n    public void addAllLeft(TreeNode root){\\n        while(root != null){\\n            st.push(root);\\n            root = root.left;\\n        }\\n    }\\n    public int next() {\\n        TreeNode topValue = st.pop();\\n        addAllLeft(topValue.right);\\n        return topValue.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return st.size() != 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965170,
                "title": "c-solution-using-inorder-tc-o-h-instead-of-o-n",
                "content": "```\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode *root) {\\n        Lefttree(root);\\n    }\\n    \\n    bool hasNext() {\\n    return st.empty() ? false : true;\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        if (top->right != NULL)\\n            Lefttree(top->right);  \\n     return top->val;\\n    }\\n    \\n    void Lefttree(TreeNode* root)\\n    {\\n        TreeNode* p = root;\\n        while (p)\\n        {\\n            st.push(p);\\n            p = p->left;\\n        }\\n    }\\n};\\n```\\n**If you like the solution pls upvote**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode *root) {\\n        Lefttree(root);\\n    }\\n    \\n    bool hasNext() {\\n    return st.empty() ? false : true;\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        if (top->right != NULL)\\n            Lefttree(top->right);  \\n     return top->val;\\n    }\\n    \\n    void Lefttree(TreeNode* root)\\n    {\\n        TreeNode* p = root;\\n        while (p)\\n        {\\n            st.push(p);\\n            p = p->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965156,
                "title": "python-tc-o-1-sc-o-h-generator-solution",
                "content": "### Explanation\\n\\nOne way to only use O(h) space is to utilise a generator for our inorder traversal. We can implement it as such:\\n\\n```python\\ndef inorder(node: Optional[TreeNode]) -> Generator[int, None, None]:\\n    \"\"\"\\n    Generator function that takes the root node of a binary tree\\n    and iterates through the nodes of the tree via inorder traversal.\\n    @param node - The root node of the binary tree.\\n    \"\"\"\\n    if node:\\n        yield from inorder(node.left)\\n        yield node.val\\n        yield from inorder(node.right)\\n```\\n\\nSince a generator does not store the entire inorder traversal in memory, the only space used is effectively the implicit stack used when making recursive calls to the function, which has a maximum recursion depth of `h` (where `h` is the maximum height of the tree).\\n\\nHowever, using a generator object alone will not allow us to know whether some nodes in the inorder traversal remain to be traversed (i.e., the `hasNext()` function), since generator objects do not have this functionality. We can overcome this by pre-emptively obtaining and storing the next value in the inorder traversal. Then, `hasNext()` will check whether the next value is valid, whereas `next()` will return the stored value before the *next next* value is obtained.\\n\\n---\\n\\n### Solution\\n\\n```python\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.iter = self._inorder(root)\\n        self.nxt = next(self.iter, None)\\n    \\n    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:\\n        if node:\\n            yield from self._inorder(node.left)\\n            yield node.val\\n            yield from self._inorder(node.right)\\n\\n    def next(self) -> int:\\n        res, self.nxt = self.nxt, next(self.iter, None)\\n        return res\\n\\n    def hasNext(self) -> bool:\\n        return self.nxt is not None\\n```\\n\\n**TC: O(1)**, since the generator object handles everything for us.\\nEDIT: Amortised O(1), see [this comment](https://leetcode.com/problems/binary-search-tree-iterator/discuss/1965156/Python-TC-O(1)-SC-O(h)-Generator-Solution/1358785) for a simple explanation.\\n**SC: O(h)**, due to the implicit recursive call stack used by the generator function.\\n\\n---\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef inorder(node: Optional[TreeNode]) -> Generator[int, None, None]:\\n    \"\"\"\\n    Generator function that takes the root node of a binary tree\\n    and iterates through the nodes of the tree via inorder traversal.\\n    @param node - The root node of the binary tree.\\n    \"\"\"\\n    if node:\\n        yield from inorder(node.left)\\n        yield node.val\\n        yield from inorder(node.right)\\n```\n```python\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.iter = self._inorder(root)\\n        self.nxt = next(self.iter, None)\\n    \\n    def _inorder(self, node: Optional[TreeNode]) -> Generator[int, None, None]:\\n        if node:\\n            yield from self._inorder(node.left)\\n            yield node.val\\n            yield from self._inorder(node.right)\\n\\n    def next(self) -> int:\\n        res, self.nxt = self.nxt, next(self.iter, None)\\n        return res\\n\\n    def hasNext(self) -> bool:\\n        return self.nxt is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52694,
                "title": "javascript-solution",
                "content": "    function BSTIterator(root) {\\n      var stack = [];\\n      return {hasNext, next};\\n    \\n      function hasNext() {\\n        return root || stack.length;\\n      }\\n    \\n      function next() {\\n        while (root) {\\n          stack.push(root);\\n          root = root.left;\\n        }\\n        root = stack.pop();\\n        var result = root.val;\\n        root = root.right;\\n        return result;\\n      }\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function BSTIterator(root) {\\n      var stack = [];\\n      return {hasNext, next};\\n    \\n      function hasNext() {\\n        return root || stack.length;\\n      }\\n    \\n      function next() {\\n        while (root) {\\n          stack.push(root);\\n          root = root.left;\\n        }\\n        root = stack.pop();\\n        var result = root.val;\\n        root = root.right;\\n        return result;\\n      }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 52592,
                "title": "my-solution-with-less-than-10-lines-of-code",
                "content": "\\n\\n public class BSTIterator {\\n\\n\\n    private Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAllNodes(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode minNode = stack.pop();\\n        pushAllNodes(minNode.right);\\n        return minNode.val;\\n    }\\n\\n    private void pushAllNodes(TreeNode node) {\\n        while(node != null)\\n        {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */",
                "solutionTags": [],
                "code": "\\n\\n public class BSTIterator {\\n\\n\\n    private Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAllNodes(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode minNode = stack.pop();\\n        pushAllNodes(minNode.right);\\n        return minNode.val;\\n    }\\n\\n    private void pushAllNodes(TreeNode node) {\\n        while(node != null)\\n        {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 966244,
                "title": "c-simplest-clean-solution-faster-than-99",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return nodes[curr-1];\\n    }\\n    \\n    bool hasNext() {\\n        return curr != nodes.size();\\n    }\\n    \\nprivate:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n    \\n    vector<int> nodes;\\n    int curr = 0;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return nodes[curr-1];\\n    }\\n    \\n    bool hasNext() {\\n        return curr != nodes.size();\\n    }\\n    \\nprivate:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        nodes.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n    \\n    vector<int> nodes;\\n    int curr = 0;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52621,
                "title": "very-concise-solution-by-using-stack-in-java",
                "content": "    public class BSTIterator {\\n        Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<TreeNode>();\\n            setNext(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            if(stack.isEmpty()) return -1;\\n            TreeNode node = stack.pop();\\n            int val = node.val;\\n            setNext(node.right);\\n            return val;\\n        }\\n        \\n        private void setNext(TreeNode root){\\n           while(root != null){\\n               stack.push(root);\\n               root = root.left;\\n           }\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n        Stack<TreeNode> stack;\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<TreeNode>();\\n            setNext(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return !stack.isEmpty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            if(stack.isEmpty()) return -1;\\n            TreeNode node = stack.pop();\\n            int val = node.val;\\n            setNext(node.right);\\n            return val;\\n        }\\n        \\n        private void setNext(TreeNode root){\\n           while(root != null){\\n               stack.push(root);\\n               root = root.left;\\n           }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 52675,
                "title": "my-python-solution",
                "content": "    class BSTIterator:\\n    # @param root, a binary search tree's root node\\n    def __init__(self, root):\\n        self.q=[]\\n        self.allLeftIntoStack(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        if not self.q:return False\\n        return True\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        cur = self.q.pop()\\n        self.allLeftIntoStack(cur.right)\\n        return cur.val\\n\\n    def allLeftIntoStack(self,root):\\n        while root:\\n            self.q.append(root)\\n            root=root.left",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class BSTIterator:\\n    # @param root, a binary search tree's root node\\n    def __init__(self, root):\\n        self.q=[]\\n        self.allLeftIntoStack(root)\\n\\n    # @return a boolean, whether we have a next smallest number\\n    def hasNext(self):\\n        if not self.q:return False\\n        return True\\n\\n    # @return an integer, the next smallest number\\n    def next(self):\\n        cur = self.q.pop()\\n        self.allLeftIntoStack(cur.right)\\n        return cur.val\\n\\n    def allLeftIntoStack(self,root):\\n        while root:\\n            self.q.append(root)\\n            root=root.left",
                "codeTag": "Java"
            },
            {
                "id": 344078,
                "title": "all-iterators-in-order-pre-order-and-post-order-stack-based-pre-cache",
                "content": "If you go with Pre-Cached there are following things\\n1. Its lightening fast, as we don\\'t need to touch the actual tree again\\n2. Its fail safe iterator, means andy modification in actual tree won\\'t affect this [ use in concurent system]\\n3. It consume lot of memory as we need to cache whole tree (O(n))\\n4. next() and hashNext() is constant time. \\n\\n\\nIn-Order\\n\\n\\n```\\n\\nclass BSTIteratorInorder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            if (root != null)\\n                init(root);\\n        }\\n\\n        private void init(TreeNode root) {\\n\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            if (hasNext()) {\\n\\n                TreeNode current = stack.pop();\\n\\n                process(current.right);\\n\\n                return current.val;\\n            }\\n\\n            return 0;\\n        }\\n\\n        private void process(TreeNode root) {\\n            init(root);\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\nclass BSTIteratorInorderPreCache {\\n\\n    class BSTIterator {\\n\\n        private LinkedList<TreeNode> inorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            inorder = new LinkedList<>();\\n\\n            inorder(root);\\n\\n        }\\n\\n        private void inorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            inorder(root.left);\\n            inorder.add(root);\\n            inorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = inorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !inorder.isEmpty();\\n        }\\n    }\\n}\\n```\\n\\n\\nPre-Order\\n\\n```\\nclass BSTIteratorPreOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n\\n            if (root != null)\\n                init(root);\\n\\n\\n        }\\n\\n        private void init(TreeNode root) {\\n            stack.push(root);\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n\\n            if (node.right != null)\\n                init(node.right);\\n\\n            if (node.left != null)\\n                init(node.left);\\n\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPreOrderPreCache {\\n\\n    class BSTIterator {\\n\\n\\n        private LinkedList<TreeNode> preorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            preorder = new LinkedList<>();\\n\\n            preorder(root);\\n\\n        }\\n\\n        private void preorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            preorder.add(root);\\n            preorder(root.left);\\n            preorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = preorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !preorder.isEmpty();\\n        }\\n    }\\n}\\n\\n```\\n\\nAnd Post-Order\\n\\n```\\nclass BSTIteratorPostOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            init(root);\\n\\n        }\\n\\n        /**\\n         * find the first leaf in a tree rooted at cur and store intermediate nodes\\n         */\\n        private void init(TreeNode root) {\\n            while (root != null) {\\n\\n                stack.push(root);\\n\\n                if (root.left != null)\\n                    root = root.left;\\n                else\\n                    root = root.right;\\n            }\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n\\n            TreeNode node = stack.pop();\\n\\n            if (!stack.isEmpty()) {\\n                if (node == stack.peek().left) {\\n                    init(stack.peek().right);  // find next leaf in right sub-tree\\n                }\\n\\n\\n            }\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPostOrderPreCached {\\n\\n    class BSTIterator {\\n        private LinkedList<TreeNode> postOrder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            postOrder = new LinkedList<>();\\n            postOrder(root);\\n\\n        }\\n\\n        private void postOrder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            postOrder.add(root);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = postOrder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !postOrder.isEmpty();\\n        }\\n    }\\n\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass BSTIteratorInorder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            if (root != null)\\n                init(root);\\n        }\\n\\n        private void init(TreeNode root) {\\n\\n            while (root != null) {\\n                stack.push(root);\\n                root = root.left;\\n            }\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            if (hasNext()) {\\n\\n                TreeNode current = stack.pop();\\n\\n                process(current.right);\\n\\n                return current.val;\\n            }\\n\\n            return 0;\\n        }\\n\\n        private void process(TreeNode root) {\\n            init(root);\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\nclass BSTIteratorInorderPreCache {\\n\\n    class BSTIterator {\\n\\n        private LinkedList<TreeNode> inorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            inorder = new LinkedList<>();\\n\\n            inorder(root);\\n\\n        }\\n\\n        private void inorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            inorder(root.left);\\n            inorder.add(root);\\n            inorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = inorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !inorder.isEmpty();\\n        }\\n    }\\n}\\n```\n```\\nclass BSTIteratorPreOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n            stack = new Stack<>();\\n\\n            if (root != null)\\n                init(root);\\n\\n\\n        }\\n\\n        private void init(TreeNode root) {\\n            stack.push(root);\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode node = stack.pop();\\n\\n            if (node.right != null)\\n                init(node.right);\\n\\n            if (node.left != null)\\n                init(node.left);\\n\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPreOrderPreCache {\\n\\n    class BSTIterator {\\n\\n\\n        private LinkedList<TreeNode> preorder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            preorder = new LinkedList<>();\\n\\n            preorder(root);\\n\\n        }\\n\\n        private void preorder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n            preorder.add(root);\\n            preorder(root.left);\\n            preorder(root.right);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = preorder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !preorder.isEmpty();\\n        }\\n    }\\n}\\n\\n```\n```\\nclass BSTIteratorPostOrder {\\n\\n    class BSTIterator {\\n\\n        private Stack<TreeNode> stack;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            stack = new Stack<>();\\n            init(root);\\n\\n        }\\n\\n        /**\\n         * find the first leaf in a tree rooted at cur and store intermediate nodes\\n         */\\n        private void init(TreeNode root) {\\n            while (root != null) {\\n\\n                stack.push(root);\\n\\n                if (root.left != null)\\n                    root = root.left;\\n                else\\n                    root = root.right;\\n            }\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n\\n            TreeNode node = stack.pop();\\n\\n            if (!stack.isEmpty()) {\\n                if (node == stack.peek().left) {\\n                    init(stack.peek().right);  // find next leaf in right sub-tree\\n                }\\n\\n\\n            }\\n            return node.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !stack.isEmpty();\\n        }\\n    }\\n}\\n\\n\\nclass BSTIteratorPostOrderPreCached {\\n\\n    class BSTIterator {\\n        private LinkedList<TreeNode> postOrder;\\n\\n        public BSTIterator(TreeNode root) {\\n\\n            postOrder = new LinkedList<>();\\n            postOrder(root);\\n\\n        }\\n\\n        private void postOrder(TreeNode root) {\\n\\n            if (root == null)\\n                return;\\n\\n\\n            postOrder(root.left);\\n            postOrder(root.right);\\n            postOrder.add(root);\\n\\n\\n        }\\n\\n        /**\\n         * @return the next smallest number\\n         */\\n        public int next() {\\n            TreeNode next = postOrder.pollFirst();\\n            return next.val;\\n        }\\n\\n        /**\\n         * @return whether we have a next smallest number\\n         */\\n        public boolean hasNext() {\\n\\n            return !postOrder.isEmpty();\\n        }\\n    }\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189561,
                "title": "clean-and-fast-java-solution",
                "content": "Each time we keep pushing the left children into the stack until we reach a null node. Then the top node will always have the mininun value. It\\'s kind of like the in-order traveral, except that we keep the \"root\" nodes in the stack for future use (such as adding the right children to the stack).\\n\\nTime complexity:\\nsuppose the binary search tree has height h (if it\\'s a balanced bst, h is O(logn))\\nconstructor: O(h) worst case \\nhasNext(): O(1)\\nnext(): O(h) worst case\\nadd(): O(h) worst case\\n```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<TreeNode>(); // initialize the stack\\n        add(root); //add the current node and all its left child to the stack\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        add(node.right);\\n        return node.val;\\n    }\\n    \\n    /** @add the current node and all its left child to the stack*/\\n    private void add(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<TreeNode>(); // initialize the stack\\n        add(root); //add the current node and all its left child to the stack\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        add(node.right);\\n        return node.val;\\n    }\\n    \\n    /** @add the current node and all its left child to the stack*/\\n    private void add(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965553,
                "title": "c-using-simple-array",
                "content": "**Declare an array ```nums``` and intialise position with  ```pos = -1```.**\\n**By using ```inorder()``` traversal push all elements in array ```nums```.\\nAs mentioned in the problem, ```next()``` is valid, so no need to check for bounding conditions. Just increment the position value and return ```nums[pos]```.\\nEither ```{ pos++; return nums[pos]; }``` or ```{ return nums[++pos]; }```.\\nFor ```hasNext()``` check whether next position is less than the size of the array nums using ```pos+1 < nums.size()```.**\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> nums;\\n    int pos = -1;\\n    \\n    void inorder(TreeNode* root) {\\n        if(root) {\\n            inorder(root -> left);\\n            nums.push_back(root -> val);\\n            inorder(root -> right);\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n\\t\\t// Increments the pos and returns the nums value at pos\\n        return nums[++pos];\\n    }\\n    \\n    bool hasNext() {\\n\\t\\t// Checking for the bounding condition\\n        return pos+1 < nums.size();\\n    }\\n};\\n```\\n********\\n**Upvote if you like.\\nThank you.**",
                "solutionTags": [],
                "code": "```nums```\n```pos = -1```\n```inorder()```\n```nums```\n```next()```\n```nums[pos]```\n```{ pos++; return nums[pos]; }```\n```{ return nums[++pos]; }```\n```hasNext()```\n```pos+1 < nums.size()```\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> nums;\\n    int pos = -1;\\n    \\n    void inorder(TreeNode* root) {\\n        if(root) {\\n            inorder(root -> left);\\n            nums.push_back(root -> val);\\n            inorder(root -> right);\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n\\t\\t// Increments the pos and returns the nums value at pos\\n        return nums[++pos];\\n    }\\n    \\n    bool hasNext() {\\n\\t\\t// Checking for the bounding condition\\n        return pos+1 < nums.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162326,
                "title": "python-solution",
                "content": "In order traversal:\\n```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.trav = root\\n        self.stack = []\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.trav or self.stack\\n        \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while self.trav:\\n            self.stack.append(self.trav)\\n            self.trav = self.trav.left\\n        u = self.stack.pop()\\n        self.trav = u.right\\n        return u.val\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.trav = root\\n        self.stack = []\\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.trav or self.stack\\n        \\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        while self.trav:\\n            self.stack.append(self.trav)\\n            self.trav = self.trav.left\\n        u = self.stack.pop()\\n        self.trav = u.right\\n        return u.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52701,
                "title": "my-java-solution-with-o-1-space-and-o-1-amortized-time-using-morris-tree-traversal",
                "content": "First of all, even with most optimized space and time complexity, I have to say this may be not the best solution, since it changes the tree structure a little bit during constructor period.\\n\\n#Construct Period\\nThe idea is use in-order Morris Tree Traversal (check out [1][2] if you are not familiar with it, otherwise the bellow explanation to you is nonsense) to construct a threaded binary tree in construct function. (This is O(n) time, but we don't care much about it.) Then set a pointer (we call it \"curr\") to the smallest TreeNode, which is easy to do, just find the left-most child from root.\\n\\n#hasNext()\\nFor hasNext() function, simple return \"curr != null\", which is by definition of threaded binary tree.\\n\\n#next()\\nFor next() function, it is a little bit tricky. We call the right child of \"curr\" as \"next\". If \"next\" is not a normal right child of \"curr\", which means the right child relationship is constructed during the threaded binary tree construction period, then the next TreeNode we should iterate is indeed \"next\". However, if \"next\" is a normal right child of \"curr\", then the next TreeNode we should iterate is actually the left-most child of \"next\". \\n\\nSo the problem reduces to how to make clear the situation. Well, it is no hard. If \"next\" is null, then we've done, simply set \"curr\" to null. If \"next\" has no left child, or \"next\"'s left child is strictly larger than \"curr\", that means it is a normal right child of \"curr\", so we should set \"curr\" to left-most child of \"next\". Otherwise, we set \"curr\" to \"next\", and break the right child relationship between \"curr\" and \"next\", to recover the original tree structure. \\n\\n#Complexity analysis\\nThe space complexity is straightforwardly O(1). The time complexity needs some more explanation. Since the only part that is not O(1) is when we search the left-most child of \"next\". However, for all the children along this left path (say, there are N children), we do once search left-most and (N-1) times simply go to right child. So the amortized time complexity is still O(1).\\n\\n#Code:\\n\\n    public class BSTIterator {\\n    \\n    \\tprivate TreeNode curr;\\n        public BSTIterator(TreeNode root) {\\n    \\t\\tTreeNode prev;\\n    \\t\\t//Do a morris in-order traversal, to construct a threaded binary tree\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null){\\n    \\t\\t\\tif(curr.left == null){\\n    \\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tprev = curr.left;\\n    \\t\\t\\t\\twhile(prev.right != null && prev.right != curr)\\n    \\t\\t\\t\\t\\tprev = prev.right;\\n    \\n    \\t\\t\\t\\tif(prev.right == null){\\n    \\t\\t\\t\\t\\tprev.right = curr;\\n    \\t\\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t//get the left-most child of root, i.e. the smallest TreeNode\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null && curr.left != null)\\n    \\t\\t\\tcurr = curr.left;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n    \\t\\treturn curr != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n    \\n    \\t\\t//copy the value we need to return\\n    \\t\\tint result = curr.val;\\n    \\n    \\t\\tTreeNode next = curr.right;\\n    \\t\\tif(next == null)\\n    \\t\\t\\tcurr = next;\\n    \\t\\t//the right child relationship is a normal one, find left-most\\n    \\t\\t//child of \"next\"\\n    \\t\\telse if(next.left == null || next.left.val > curr.val){\\n    \\t\\t\\tcurr = next;\\n    \\t\\t\\twhile(curr.left != null)\\n    \\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t}\\n    \\t\\t//the right child relationship is made when we\\n    \\t\\t//construct the threaded binary tree\\n    \\t\\telse{\\n    \\t\\t\\tcurr.right = null;//we recover the original tree structure\\n    \\t\\t\\tcurr = next;\\n    \\t\\t}\\n    \\n    \\t\\treturn result;\\n        }\\n    }\\n\\n#Reference\\n\\nFor those who are not familiar with Morris Tree Traversal, these two paragraphs are good references.\\n\\n[1]https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n[2]http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/",
                "solutionTags": [
                    "Java"
                ],
                "code": "First of all, even with most optimized space and time complexity, I have to say this may be not the best solution, since it changes the tree structure a little bit during constructor period.\\n\\n#Construct Period\\nThe idea is use in-order Morris Tree Traversal (check out [1][2] if you are not familiar with it, otherwise the bellow explanation to you is nonsense) to construct a threaded binary tree in construct function. (This is O(n) time, but we don't care much about it.) Then set a pointer (we call it \"curr\") to the smallest TreeNode, which is easy to do, just find the left-most child from root.\\n\\n#hasNext()\\nFor hasNext() function, simple return \"curr != null\", which is by definition of threaded binary tree.\\n\\n#next()\\nFor next() function, it is a little bit tricky. We call the right child of \"curr\" as \"next\". If \"next\" is not a normal right child of \"curr\", which means the right child relationship is constructed during the threaded binary tree construction period, then the next TreeNode we should iterate is indeed \"next\". However, if \"next\" is a normal right child of \"curr\", then the next TreeNode we should iterate is actually the left-most child of \"next\". \\n\\nSo the problem reduces to how to make clear the situation. Well, it is no hard. If \"next\" is null, then we've done, simply set \"curr\" to null. If \"next\" has no left child, or \"next\"'s left child is strictly larger than \"curr\", that means it is a normal right child of \"curr\", so we should set \"curr\" to left-most child of \"next\". Otherwise, we set \"curr\" to \"next\", and break the right child relationship between \"curr\" and \"next\", to recover the original tree structure. \\n\\n#Complexity analysis\\nThe space complexity is straightforwardly O(1). The time complexity needs some more explanation. Since the only part that is not O(1) is when we search the left-most child of \"next\". However, for all the children along this left path (say, there are N children), we do once search left-most and (N-1) times simply go to right child. So the amortized time complexity is still O(1).\\n\\n#Code:\\n\\n    public class BSTIterator {\\n    \\n    \\tprivate TreeNode curr;\\n        public BSTIterator(TreeNode root) {\\n    \\t\\tTreeNode prev;\\n    \\t\\t//Do a morris in-order traversal, to construct a threaded binary tree\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null){\\n    \\t\\t\\tif(curr.left == null){\\n    \\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tprev = curr.left;\\n    \\t\\t\\t\\twhile(prev.right != null && prev.right != curr)\\n    \\t\\t\\t\\t\\tprev = prev.right;\\n    \\n    \\t\\t\\t\\tif(prev.right == null){\\n    \\t\\t\\t\\t\\tprev.right = curr;\\n    \\t\\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\tcurr = curr.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\n    \\t\\t//get the left-most child of root, i.e. the smallest TreeNode\\n    \\t\\tcurr = root;\\n    \\t\\twhile(curr != null && curr.left != null)\\n    \\t\\t\\tcurr = curr.left;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n    \\t\\treturn curr != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n    \\n    \\t\\t//copy the value we need to return\\n    \\t\\tint result = curr.val;\\n    \\n    \\t\\tTreeNode next = curr.right;\\n    \\t\\tif(next == null)\\n    \\t\\t\\tcurr = next;\\n    \\t\\t//the right child relationship is a normal one, find left-most\\n    \\t\\t//child of \"next\"\\n    \\t\\telse if(next.left == null || next.left.val > curr.val){\\n    \\t\\t\\tcurr = next;\\n    \\t\\t\\twhile(curr.left != null)\\n    \\t\\t\\t\\tcurr = curr.left;\\n    \\t\\t}\\n    \\t\\t//the right child relationship is made when we\\n    \\t\\t//construct the threaded binary tree\\n    \\t\\telse{\\n    \\t\\t\\tcurr.right = null;//we recover the original tree structure\\n    \\t\\t\\tcurr = next;\\n    \\t\\t}\\n    \\n    \\t\\treturn result;\\n        }\\n    }\\n\\n#Reference\\n\\nFor those who are not familiar with Morris Tree Traversal, these two paragraphs are good references.\\n\\n[1]https://en.wikipedia.org/wiki/Threaded_binary_tree\\n\\n[2]http://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/",
                "codeTag": "Java"
            },
            {
                "id": 965790,
                "title": "c-caching-solution-explained-100-time-96-space",
                "content": "Okay, I opted NOT to go with unnecessary logic and try first of all the simplest approach (compare to the other one I had in mind, to go on with a stack of nodes) - caching all the node values in the constructor and then just referring to that - it worked surprisingly well :)\\n\\nTo do so, I declare 3 class variables:\\n* `curr` is a pointer to which value we will \"pop\" next;\\n* `pos` will keep track of what position in `store` we will push into next and, at the end of the caching part, it will also tell us how big is our store (so basically acting as a measure of its length);\\n* `store`, you guessed it, will store the values of each single node parsed.\\n\\nIn our constructor we are going to call our helper `dfs` that will just:\\n* check if `root` is `NULL`, in which case we return;\\n* call itself on `root->left`;\\n* add `root->val` to `store` in position `pos`;\\n* increment `pos` by `1`;\\n* call itself on `root->right`.\\n\\nThe following methods are somehow trivial:\\n* `next` will just return `store[curr]` and increment it;\\n* `hasNext` will just return if `curr < pos`, meaning we can still pop at least a value.\\n\\nThe code:\\n\\n```cpp\\nclass BSTIterator {\\npublic:\\n    int curr = 0, pos = 0, store[10001];\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        store[pos++] = root->val;\\n        dfs(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root);\\n    }\\n    \\n    int next() {\\n        return store[curr++];\\n    }\\n    \\n    bool hasNext() {\\n        return curr < pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass BSTIterator {\\npublic:\\n    int curr = 0, pos = 0, store[10001];\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        store[pos++] = root->val;\\n        dfs(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root);\\n    }\\n    \\n    int next() {\\n        return store[curr++];\\n    }\\n    \\n    bool hasNext() {\\n        return curr < pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965565,
                "title": "python-stack-solution-follow-up-explained",
                "content": "In this question we are asked to perform Iterator, using inorder traversal, so let us just use inorder traversal, using stack: we will keep two global variables:\\n1. `self.stack`: our explicit stack, where we keep our visited nodes.\\n2. `self.curr`: current node we want to return during our traversal.\\n\\nNext, what we do is perform usual iterative inorder traversal: we go als left as possible until we can and add nodes to stack. Then we remove node from stack and go to right children if it is possible. Also we save our `out` node, because we need to return it as output of `next` function. Finally, howe we can understand if we have next Node or not? If stack is not empty, we have it, also if current node is not `None`, we also have it, in other cases we are done.\\n\\n**Complexity**: amortized time complexity of `next` function is `O(1)`: we spend `O(n)` time to visit all `n` nodes. Note, that amortized time means, that we spend `O(1)` in average, it is exactly what we need in follow-up. Also space complexity for this solution is `O(h)`: our stack will never be longer than height of our tree.\\n\\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr:\\n            self.stack.append(self.curr)\\n            self.curr = self.curr.left\\n        self.curr = self.stack.pop()\\n        out = self.curr.val\\n        self.curr = self.curr.right\\n        return out\\n\\n    def hasNext(self):\\n        return self.stack or self.curr\\n```\\n\\nNote also, that there is Morris Traversal with `O(1)` time in average and `O(1)` space.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr:\\n            self.stack.append(self.curr)\\n            self.curr = self.curr.left\\n        self.curr = self.stack.pop()\\n        out = self.curr.val\\n        self.curr = self.curr.right\\n        return out\\n\\n    def hasNext(self):\\n        return self.stack or self.curr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52713,
                "title": "python-concise-solution-o-lgn-space-and-o-1-time",
                "content": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.stack = []\\n        self.root = root\\n        \\n    def next(self):\\n        while self.root:\\n            self.stack.append(self.root)\\n            self.root = self.root.left\\n        node = self.stack.pop()\\n        res = node.val\\n        self.root = node.right\\n        return res\\n\\n    def hasNext(self):\\n        return len(self.stack) > 0 or self.root != None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass BSTIterator(object):\\n    def __init__(self, root):\\n        self.stack = []\\n        self.root = root\\n        \\n    def next(self):\\n        while self.root:\\n            self.stack.append(self.root)\\n            self.root = self.root.left\\n        node = self.stack.pop()\\n        res = node.val\\n        self.root = node.right\\n        return res\\n\\n    def hasNext(self):\\n        return len(self.stack) > 0 or self.root != None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568327,
                "title": "javascript-depth-first-search-in-order-traversing",
                "content": "The Idea:\\n1. use **Depth First Search** **In Order** traversing \\n```\\n       10\\n   5        13\\n          11  16\\n```\\ndepthFirstSearchInOrderTraversing(): [5, 10, 11, 13, 16]\\n2. **reverse** result of traversing to have sorting from high to low value\\n[5, 10, 11, 13, 16] will become [16, 13, 11, 10, 5]\\n3. use **Array pop()** to be able perform **O(1)** for **next** and **Array lenght** to be able perform **O(1)** for **hasNext** methods\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    if(!root){\\n        this.data = [];\\n        return;\\n    }\\n    \\n    let visited = [];\\n    \\n    function traverse(node){\\n        if(node.left) traverse(node.left);\\n        visited.push(node.val);\\n        if(node.right) traverse(node.right);\\n    }\\n    traverse(root);\\n    \\n    this.data = visited.reverse();\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.data.pop();\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.data.length > 0 ;\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n       10\\n   5        13\\n          11  16\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    if(!root){\\n        this.data = [];\\n        return;\\n    }\\n    \\n    let visited = [];\\n    \\n    function traverse(node){\\n        if(node.left) traverse(node.left);\\n        visited.push(node.val);\\n        if(node.right) traverse(node.right);\\n    }\\n    traverse(root);\\n    \\n    this.data = visited.reverse();\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.data.pop();\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.data.length > 0 ;\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52703,
                "title": "c-using-stack",
                "content": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class BSTIterator {\\n    private:\\n        TreeNode *current = NULL; \\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n             // initialize the current pointer\\n            current = root;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            while(current){\\n                s.push(current);\\n                current = current->left;\\n            }\\n            if(s.empty()){\\n                return false;\\n            }\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* node = s.top();\\n            s.pop();\\n            current = node->right;\\n            return node->val;\\n        }\\n    };\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = BSTIterator(root);\\n     * while (i.hasNext()) cout << i.next();\\n     */\\n\\nThe basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.\\nhasNext() will push all the left elements and check and return accordingly if elements are in the stack.\\nnext() will just pop() the top element from the stack and update the current pointer to right .\\nFor this we are taking a stack and a current pointer.\\nBut maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well.\\n\\nOpen for comments.",
                "solutionTags": [],
                "code": "    /**\\n     * Definition for binary tree\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class BSTIterator {\\n    private:\\n        TreeNode *current = NULL; \\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n             // initialize the current pointer\\n            current = root;\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            while(current){\\n                s.push(current);\\n                current = current->left;\\n            }\\n            if(s.empty()){\\n                return false;\\n            }\\n            return true;\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* node = s.top();\\n            s.pop();\\n            current = node->right;\\n            return node->val;\\n        }\\n    };\\n    \\n    /**\\n     * Your BSTIterator will be called like this:\\n     * BSTIterator i = BSTIterator(root);\\n     * while (i.hasNext()) cout << i.next();\\n     */\\n\\nThe basic idea behind this solution is that we have to implement inorder iteratively but it will gets split into two functions i.e. hasNext and next.\\nhasNext() will push all the left elements and check and return accordingly if elements are in the stack.\\nnext() will just pop() the top element from the stack and update the current pointer to right .\\nFor this we are taking a stack and a current pointer.\\nBut maybe I may be wrong in hasNext as the requirement of question is O(1) for hasNext() as well.\\n\\nOpen for comments.",
                "codeTag": "C++"
            },
            {
                "id": 52718,
                "title": "my-simple-solution-here",
                "content": "    public class BSTIterator {\\n    Stack<TreeNode> stack=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n       while(root!=null){\\n\\t            stack.push(root);\\n\\t            root=root.left;\\n\\t        }\\n\\t    }\\n\\n\\t    /** @return whether we have a next smallest number */\\n\\t    public boolean hasNext() {\\n\\t        if(!stack.isEmpty())\\n\\t            return true;\\n\\t        else\\n\\t        \\t return false;\\n\\t    }\\n\\n\\t    /** @return the next smallest number */\\n\\t    public int next() {\\n\\t        int res=0;\\n\\t        if(!stack.isEmpty()){\\n\\t            TreeNode cur=stack.pop();\\n\\t            res=cur.val;\\n\\t            cur=cur.right;\\n\\t            while(cur!=null){\\n\\t                stack.push(cur);\\n\\t                cur=cur.left;\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\n}",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n    Stack<TreeNode> stack=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n       while(root!=null){\\n\\t            stack.push(root);\\n\\t            root=root.left;\\n\\t        }\\n\\t    }\\n\\n\\t    /** @return whether we have a next smallest number */\\n\\t    public boolean hasNext() {\\n\\t        if(!stack.isEmpty())\\n\\t            return true;\\n\\t        else\\n\\t        \\t return false;\\n\\t    }\\n\\n\\t    /** @return the next smallest number */\\n\\t    public int next() {\\n\\t        int res=0;\\n\\t        if(!stack.isEmpty()){\\n\\t            TreeNode cur=stack.pop();\\n\\t            res=cur.val;\\n\\t            cur=cur.right;\\n\\t            while(cur!=null){\\n\\t                stack.push(cur);\\n\\t                cur=cur.left;\\n\\t            }\\n\\t        }\\n\\t        return res;\\n\\t    }\\n\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3457559,
                "title": "easy-begginer-friendly-sol-c-stack-implementation",
                "content": "# Intuition\\nThe key idea is to use a stack to keep track of the nodes in the tree that still need to be processed.\\n# Approach\\n- The idea is to maintain a stack that stores the nodes of the BST in the order in which they would be visited during an in-order traversal of the tree.\\n- The push method pushes all the left nodes of the input root onto the stack, simulating an in-order traversal starting from root.\\n- The next method pops the top element from the stack and then simulates an in-order traversal starting from the right child of the popped element. \\n- The right child is pushed onto the stack, followed by all its left children (if any). This ensures that the next element returned by the iterator is the next element in the in-order traversal.\\n- The hasNext method simply checks if the stack is empty or not. If the stack is empty, it means that there are no more elements in the in-order traversal of the BST and there is no next element present.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void push(TreeNode* root)\\n    {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        push(root);\\n    }\\n\\n    int next() {\\n        auto temp=st.top();\\n        st.pop();\\n        push(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void push(TreeNode* root)\\n    {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        push(root);\\n    }\\n\\n    int next() {\\n        auto temp=st.top();\\n        st.pop();\\n        push(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3276281,
                "title": "best-o-1-solution",
                "content": "# Approach 1\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i = 0;\\n    vector <int> nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        traversal(root, nodes);\\n    }\\n    \\n    int next() {\\n        return nodes[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return (i != nodes.size());\\n    }\\n    \\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }    \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\n\\n# Approach 2\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack <TreeNode* > nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* nextNode = nodes.top();\\n        nodes.pop();\\n        pushAll(nextNode->right);\\n        return nextNode->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !nodes.empty();\\n    }\\n    \\nprivate:\\n    void pushAll(TreeNode* root) {\\n        while (root != NULL) {\\n            nodes.push(root);\\n            root = root->left;\\n        }   \\n    }     \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i = 0;\\n    vector <int> nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        traversal(root, nodes);\\n    }\\n    \\n    int next() {\\n        return nodes[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return (i != nodes.size());\\n    }\\n    \\nprivate:\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        traversal(root->left, nodes);\\n        nodes.push_back(root->val);\\n        traversal(root->right, nodes);    \\n    }    \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    stack <TreeNode* > nodes;\\n\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* nextNode = nodes.top();\\n        nodes.pop();\\n        pushAll(nextNode->right);\\n        return nextNode->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !nodes.empty();\\n    }\\n    \\nprivate:\\n    void pushAll(TreeNode* root) {\\n        while (root != NULL) {\\n            nodes.push(root);\\n            root = root->left;\\n        }   \\n    }     \\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52751,
                "title": "java-a-solution-of-15-lines",
                "content": "The idea for the solution is composed of the following points.\\n\\n 1. The solution uses a stack to keep track at most the next `\"h\"` (height of tree)\\n    elements for `\"next()\"` calls. \\n 2. The top of the stack is the current\\n    minimum element. \\n 3. At every `\"next()\"` call, we need to refresh the\\n    stack by populating the stack with all the left nodes up to the\\n    leaf, starting from the right node of the current minimum node.\\n\\nThe complexity of the `\"hasNext()\"` is O(1). While the `\"next()\"` needs to refresh the stack, which in the best case (leaf) takes constant time, and in the worst case, it would take up to `\"h\"` steps. The overall cost of `\"next()\"` is then amortized over the number of nodes. I don't have the precise proof, but it seems to be O(1) on average.\\n\\nHere is the code. One trick is that I extract the refreshing into a function which can be used in the constructor as well, so that the code is more concise. \\n\\n\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    \\n    private void refreshStack(TreeNode iter){\\n         while(iter != null){\\n         \\tstack.push(iter);\\n         \\titer = iter.left;\\n         }\\n    }\\n    \\t\\n    public BSTIterator(TreeNode root) {\\n       this.refreshStack(root);\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !(stack.isEmpty());\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        if(node != null){\\n        \\tthis.refreshStack(node.right);\\n        \\treturn node.val;\\n        }\\n        \\n        return -1; // should throw exception here.\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "The idea for the solution is composed of the following points.\\n\\n 1. The solution uses a stack to keep track at most the next `\"h\"` (height of tree)\\n    elements for `\"next()\"` calls. \\n 2. The top of the stack is the current\\n    minimum element. \\n 3. At every `\"next()\"` call, we need to refresh the\\n    stack by populating the stack with all the left nodes up to the\\n    leaf, starting from the right node of the current minimum node.\\n\\nThe complexity of the `\"hasNext()\"` is O(1). While the `\"next()\"` needs to refresh the stack, which in the best case (leaf) takes constant time, and in the worst case, it would take up to `\"h\"` steps. The overall cost of `\"next()\"` is then amortized over the number of nodes. I don't have the precise proof, but it seems to be O(1) on average.\\n\\nHere is the code. One trick is that I extract the refreshing into a function which can be used in the constructor as well, so that the code is more concise. \\n\\n\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    \\n    private void refreshStack(TreeNode iter){\\n         while(iter != null){\\n         \\tstack.push(iter);\\n         \\titer = iter.left;\\n         }\\n    }\\n    \\t\\n    public BSTIterator(TreeNode root) {\\n       this.refreshStack(root);\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !(stack.isEmpty());\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        if(node != null){\\n        \\tthis.refreshStack(node.right);\\n        \\treturn node.val;\\n        }\\n        \\n        return -1; // should throw exception here.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3212805,
                "title": "173-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main idea behind this solution is to implement an iterator that returns the nodes in the in-order traversal of the binary search tree. We can use a stack to keep track of the nodes we need to visit.\\n\\n- In the constructor of the BSTIterator class, we initialize the stack with the leftmost path of the root node. We do this by adding all the left children of the root to the stack.\\n- hasNext() method returns true if the stack is not empty, which means that there are more nodes to be visited.\\n- next() method pops the top node from the stack, and if the popped node has a right child, we add all its left children to the stack.\\n\\n# Complexity\\n- Time complexity:\\nThe constructor will take O(h) time where h is the height of the tree. The hasNext() and next() method will take O(1) time.\\n\\n- Space complexity:\\nThe space required by the stack is O(h).\\n\\n# Code\\n```\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n    \\n    def next(self) -> int:\\n        node = self.stack.pop()\\n        if node.right:\\n            current = node.right\\n            while current:\\n                self.stack.append(current)\\n                current = current.left\\n        return node.val\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Design",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n    \\n    def next(self) -> int:\\n        node = self.stack.pop()\\n        if node.right:\\n            current = node.right\\n            while current:\\n                self.stack.append(current)\\n                current = current.left\\n        return node.val\\n    \\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1966160,
                "title": "o-1-space-3-solutions-python",
                "content": "## Solution 1: Precalculate inorder traversal\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._traversal = []\\n\\t\\t# find the whole traversal\\n        self._inorder(root)\\n\\t\\t# pointer to the node which we should return\\n        self._current = 0\\n\\n    def _inorder(self, node: Optional[TreeNode]) -> None:\\n\\t\\t\\n        if node is None:\\n            return\\n\\n        self._inorder(node.left)\\n        self._traversal.append(node)\\n        self._inorder(node.right)\\n            \\n    def next(self) -> int:\\n        \\n\\t\\t# get the node\\n        node = self._traversal[self._current]\\n\\t\\t# move the pointer\\n        self._current += 1\\n\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n\\t\\t# we have nodes until we reach the end\\n        return self._current < len(self._traversal) \\n```\\n\\n### Solution 2: Using stack\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._stack = []\\n\\t\\t# initial population of the stack\\n\\t\\t# it\\'ll add all the nodes on the path \\n\\t\\t# to the most left node (the smallest)\\n        self._update_stack(root)\\n            \\n    def _update_stack(self, node: Optional[TreeNode]) -> None:\\n        # add the next nodes to the stack\\n        while node:\\n            self._stack.append(node)\\n            node = node.left\\n\\n    def next(self) -> int:\\n        # on top of the stack we have the node \\n\\t\\t# which we need to return\\n        node = self._stack.pop()\\n        # this node doesn\\'t have the left subtree\\n\\t\\t# or we already visited all the nodes in the left subtree\\n\\t\\t# so the next node should be in the right subtree\\n        self._update_stack(node.right)\\n            \\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n        return bool(self._stack)\\n```\\n\\n### Solution 3: Morris Traversal ( O(1) Space)\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n\\t\\t\\t# if left tree exists\\n            if self._current.left:\\n\\t\\t\\t\\t# find inorder predecessor (the most right node the in left subtree)\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\t\\t\\t\\t# if we find this predecessor in the first time\\n\\t\\t\\t\\t# it means that we haven\\'t visited the left subtree of self._current yet,\\n\\t\\t\\t\\t# so set a link from predecessor to self._current to know that\\n\\t\\t\\t\\t# we already visited the left subtree when we\\'ll find it in the second time\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n\\t\\t\\t\\t# we already visited the left subtree\\n                else:\\n\\t\\t\\t\\t\\t# take the value of the node\\n                    val = self._current.val\\n\\t\\t\\t\\t\\t# go to the right subtree\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n\\t\\t\\t# there is no left subtree,\\n\\t\\t\\t# take the value of the node and go to the right subtree\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n```\\n\\n### Bonus: Implement Python Iterator Protocol\\n\\n```\\nclass TreeNode(Iterable):\\n\\n    def __init__(\\n        self, \\n        val: int = 0, \\n        left: Optional[\"TreeNode\"] = None, \\n        right: Optional[\"TreeNode\"] = None\\n    ):\\n\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n    def __iter__(self) -> Iterator:\\n\\n        return BSTIterator(self)\\n\\n    def __str__(self) -> str:\\n        return str(self.val)\\n\\n\\nclass BSTIterator(Iterator):\\n\\n    def __init__(self, root: Optional[TreeNode] = None) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n            if self._current.left:\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n                else:\\n                    val = self._current.val\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n\\n    def __next__(self) -> int:\\n\\n        val = self.next()\\n        if val is None:\\n            raise StopIteration\\n\\n        return val\\n\\nroot = TreeNode(\\n    val=7,\\n    left=TreeNode(val=3),\\n    right=TreeNode(\\n        val=15,\\n        left=TreeNode(val=9),\\n        right=TreeNode(val=20),\\n    )\\n)\\n\\nfor node in root:\\n    print(node)\\n```\\n\\nP.S. Feel free to upvote if you liked it",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._traversal = []\\n\\t\\t# find the whole traversal\\n        self._inorder(root)\\n\\t\\t# pointer to the node which we should return\\n        self._current = 0\\n\\n    def _inorder(self, node: Optional[TreeNode]) -> None:\\n\\t\\t\\n        if node is None:\\n            return\\n\\n        self._inorder(node.left)\\n        self._traversal.append(node)\\n        self._inorder(node.right)\\n            \\n    def next(self) -> int:\\n        \\n\\t\\t# get the node\\n        node = self._traversal[self._current]\\n\\t\\t# move the pointer\\n        self._current += 1\\n\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n\\t\\t# we have nodes until we reach the end\\n        return self._current < len(self._traversal) \\n```\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._stack = []\\n\\t\\t# initial population of the stack\\n\\t\\t# it\\'ll add all the nodes on the path \\n\\t\\t# to the most left node (the smallest)\\n        self._update_stack(root)\\n            \\n    def _update_stack(self, node: Optional[TreeNode]) -> None:\\n        # add the next nodes to the stack\\n        while node:\\n            self._stack.append(node)\\n            node = node.left\\n\\n    def next(self) -> int:\\n        # on top of the stack we have the node \\n\\t\\t# which we need to return\\n        node = self._stack.pop()\\n        # this node doesn\\'t have the left subtree\\n\\t\\t# or we already visited all the nodes in the left subtree\\n\\t\\t# so the next node should be in the right subtree\\n        self._update_stack(node.right)\\n            \\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \\n        return bool(self._stack)\\n```\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n\\t\\t\\t# if left tree exists\\n            if self._current.left:\\n\\t\\t\\t\\t# find inorder predecessor (the most right node the in left subtree)\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\t\\t\\t\\t# if we find this predecessor in the first time\\n\\t\\t\\t\\t# it means that we haven\\'t visited the left subtree of self._current yet,\\n\\t\\t\\t\\t# so set a link from predecessor to self._current to know that\\n\\t\\t\\t\\t# we already visited the left subtree when we\\'ll find it in the second time\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n\\t\\t\\t\\t# we already visited the left subtree\\n                else:\\n\\t\\t\\t\\t\\t# take the value of the node\\n                    val = self._current.val\\n\\t\\t\\t\\t\\t# go to the right subtree\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n\\t\\t\\t# there is no left subtree,\\n\\t\\t\\t# take the value of the node and go to the right subtree\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n```\n```\\nclass TreeNode(Iterable):\\n\\n    def __init__(\\n        self, \\n        val: int = 0, \\n        left: Optional[\"TreeNode\"] = None, \\n        right: Optional[\"TreeNode\"] = None\\n    ):\\n\\n        self.val = val\\n        self.left = left\\n        self.right = right\\n\\n    def __iter__(self) -> Iterator:\\n\\n        return BSTIterator(self)\\n\\n    def __str__(self) -> str:\\n        return str(self.val)\\n\\n\\nclass BSTIterator(Iterator):\\n\\n    def __init__(self, root: Optional[TreeNode] = None) -> None:\\n        self._current = root\\n            \\n    def next(self) -> Optional[int]:\\n        \\n        val = None\\n        while self._current:\\n            if self._current.left:\\n                predecessor = self._current.left\\n                while predecessor.right and predecessor.right != self._current:\\n                    predecessor = predecessor.right\\n\\n                if predecessor.right is None:\\n                    predecessor.right = self._current\\n                    self._current = self._current.left\\n                else:\\n                    val = self._current.val\\n                    predecessor.right = None\\n                    self._current = self._current.right\\n                    break\\n            else:\\n                val = self._current.val\\n                self._current = self._current.right \\n                break\\n            \\n        return val \\n\\n    def hasNext(self) -> bool:\\n        \\n        return self._current is not None \\n\\n    def __next__(self) -> int:\\n\\n        val = self.next()\\n        if val is None:\\n            raise StopIteration\\n\\n        return val\\n\\nroot = TreeNode(\\n    val=7,\\n    left=TreeNode(val=3),\\n    right=TreeNode(\\n        val=15,\\n        left=TreeNode(val=9),\\n        right=TreeNode(val=20),\\n    )\\n)\\n\\nfor node in root:\\n    print(node)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965188,
                "title": "python-6-line-simple-solution-beginner-friendly",
                "content": "The idea is get the sorted tree nodes, and then the problem turns to check the next smallest int number & check if there are any remaining numbers\\n\\n**Please upvote me if you think this is useful :) Much Appreciated!**\\n\\n```\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        # get the in order tree node values\\n        def inorder(root):\\n            if not root:    return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        self.treenodes = inorder(root)\\n        \\n        \\n    def next(self):\\n        # pop out the current smallest int\\n        return self.treenodes.pop(0)\\n        \\n\\n    def hasNext(self):\\n        # check if there are remaining int\\n        return len(self.treenodes) != 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        # get the in order tree node values\\n        def inorder(root):\\n            if not root:    return []\\n            return inorder(root.left) + [root.val] + inorder(root.right)\\n        \\n        self.treenodes = inorder(root)\\n        \\n        \\n    def next(self):\\n        # pop out the current smallest int\\n        return self.treenodes.pop(0)\\n        \\n\\n    def hasNext(self):\\n        # check if there are remaining int\\n        return len(self.treenodes) != 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965154,
                "title": "o-1-space-query-convert-to-linked-list-no-stack-c",
                "content": "We can easily solve the problem in O(1) space by converting the tree to a linked list by inoreder traversal \\nand then just easily answer the queries by saving the head of the linked list.\\n\\n```\\nclass BSTIterator {\\n    \\n    TreeNode* head ;\\n    \\n    void convert(TreeNode* root , TreeNode* &prev , TreeNode* &next)\\n    {\\n        if(root == NULL) return ;\\n        convert(root->left , prev , next) ;\\n        \\n        if(next == NULL){\\n            next = root ;\\n        }\\n        \\n        if(prev!= NULL)\\n        {\\n            prev->right = root ;\\n        }\\n            root->left = NULL ;\\n            prev = root ;\\n        \\n        convert(root->right, prev , next) ;\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = NULL ;\\n        head = new TreeNode(0) ;\\n        \\n        TreeNode* prev = NULL ;\\n        TreeNode* &next = head->right ;\\n        convert(root , prev , next) ;\\n\\n    }\\n    \\n    int next() {\\n        head = head->right ;\\n        return head->val ;\\n    }\\n    \\n    bool hasNext() {\\n        return head->right != NULL ; \\n     }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Tree"
                ],
                "code": "We can easily solve the problem in O(1) space by converting the tree to a linked list by inoreder traversal \\nand then just easily answer the queries by saving the head of the linked list.\\n\\n```\\nclass BSTIterator {\\n    \\n    TreeNode* head ;\\n    \\n    void convert(TreeNode* root , TreeNode* &prev , TreeNode* &next)\\n    {\\n        if(root == NULL) return ;\\n        convert(root->left , prev , next) ;\\n        \\n        if(next == NULL){\\n            next = root ;\\n        }\\n        \\n        if(prev!= NULL)\\n        {\\n            prev->right = root ;\\n        }\\n            root->left = NULL ;\\n            prev = root ;\\n        \\n        convert(root->right, prev , next) ;\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = NULL ;\\n        head = new TreeNode(0) ;\\n        \\n        TreeNode* prev = NULL ;\\n        TreeNode* &next = head->right ;\\n        convert(root , prev , next) ;\\n\\n    }\\n    \\n    int next() {\\n        head = head->right ;\\n        return head->val ;\\n    }\\n    \\n    bool hasNext() {\\n        return head->right != NULL ; \\n     }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 498353,
                "title": "100-00-fast-in-run-time-and-compared-with-other-approaches-iterative-recursive",
                "content": "satisfactory read: Agree? \\n\\n----------------\\n**Note:**\\n**(a).** next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\\n**(b).** You may assume that next() call will always be valid, that is, there will be at least a next smallest number in the BST when next() is called.\\n\\nUsually, an iterator simply goes over each of the elements of the container one by one. For the BST, we want the iterator to return elements in an ascending order.\\n\\n If such an iterator is defined, then the traversal logic can be abstracted out and we can simply make use of the iterator to process the elements in a certain order.\\n** E.G.: **\\n```\\n\\t new_iterator = BSTIterator(root);\\n\\t while (new_iterator.hasNext())\\n\\t    process(new_iterator.next());\\n```\\n\\n----------------------\\nRuntime: 28 ms, faster than **100.00%** of C++ online submissions for Binary Search Tree Iterator.\\nMemory Usage: 24.2 MB, less than **95.65%** of C++ online submissions for Binary Search Tree Iterator.\\n```\\nstatic const auto magic = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  std::cout.tie(nullptr);\\n  return nullptr;\\n}();\\n\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    TreeNode* visit;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        visit = root;\\n    }\\n    int next() {\\n        while(visit){\\n            st.push(visit);\\n            visit = visit->left;\\n        }\\n        TreeNode* next = st.top(); st.pop();\\n        visit = next->right;\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return visit || !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n```\\n\\n------------------------\\n# **controlled recursion**\\nRuntime: 52 ms, faster than 89.84% of C++ online submissions for Binary Search Tree Iterator.\\nMemory Usage: 24.2 MB, less than 89.13% of C++ online submissions for Binary Search Tree Iterator.\\n**average O(1) time and uses O(h) memory**\\nThe average time complexity of next() function is O(1) indeed. As the next function can be called n times at most, and the number of right nodes in **pushLeft(root->right) function is maximal n** in a tree which has n nodes, so the **amortized time complexity is O(1)**.\\n\\n![](https://leetcode.com/articles/Figures/173/approach_2-1.png)\\n\\n# **And then**\\n\\n![](https://leetcode.com/articles/Figures/173/approach_2-2.png)\\n\\n**Time complexity** : The time complexity for this approach is very interesting to analyze. Let\\'s look at the complexities for both the functions in the class:\\n\\nhasNext is the easier of the lot since all we do in this is to return true if there are any elements left in the stack. Otherwise, we return false. So clearly, this is an **O(1)** operation every time. Let\\'s look at the more complicated function now to see if we satisfy all the requirements in the problem statement\\nnext involves two major operations. One is where we pop an element from the stack which becomes the next smallest element to return. This is a **O(1)** operation. However, we then make a call to our helper function pushLeft which iterates over a bunch of nodes. This is clearly a linear time operation i.e. **O(N)** in the worst case. This is true.\\n\\nHowever, the important thing to note here is that we only make such a call for nodes which have a right child. Otherwise, we simply return. Also, even if we end up calling the helper function, it won\\'t always process N nodes. They will be much lesser. Only **if we have a skewed tree** would there be N nodes for the root. But that is the only node for which we would call the helper function.\\nThus,** the amortized (average) time complexity** for this function would still be **O(1)** which is what the question asks for. We don\\'t need to have a solution which gives constant time operations for every call. We need that complexity on average and that is what we get.\\n\\n**Space complexity**: The space complexity is **O(h)** which is occupied by our** custom stack** for simulating the inorder traversal. Again, we satisfy the space requirements as well as specified in the problem statement. \\n\\n```\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pushLeft(root);\\n    }\\n    int next() {\\n        TreeNode* next = st.top(); st.pop();\\n        if(next->right) pushLeft(next->right);\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n```\\n\\n**Flattening the BST**\\n**Algorithm:**\\n**1.** Initialize an empty vector that will contain the nodes of the binary search tree in the sorted order.\\n**2.** We traverse the binary search tree in the inorder fashion and for each node that we process, we add it to our vector nodes. Note that before processing a node, its left subtree has to be processed (or recursed upon) and after processing a node, its right subtree has to be recursed upon.\\n**(3).** Once we have all the nodes in an vector, we simply need a pointer or an index in that array to implement the two functions next and hasNext. Whenever there\\'s a call to hasNext, we simply check if the index has reached the end of the vector or not. For the call to next function, we simply return the element pointed by the index. Also, after a the next function call is made, we have to move the index one step forward to simulate the progress of our iterator.\\n\\n-------------------\\n# **Flattening the BST**\\nRuntime: 64 ms\\nMemory Usage: 25.4 MB\\n**Time complexity:** **O(N)** is the time taken by the **constructor** for the iterator. The problem statement only asks us to analyze the complexity of the two functions, however, when implementing a class, it\\'s important to also note the time it takes to initialize a new object of the class and in this case it would be linear in terms of the number of nodes in the BST. In addition to the space occupied by the new array we initialized, the recursion stack for the inorder traversal also occupies space but that is limited to **O(h)** where h is the height of the tree.\\nnext() would take **O(1)**\\nhasNext() would take **O(1)**\\n**Space complexity :** **O(N)** since we create a new array to contain all the nodes of the BST. This doesn\\'t comply with the requirement specified in the problem statement that the maximum space complexity of either of the functions should be **O(h)** where h is the height of the tree and for a well balanced BST, the height is usually **logN**, So, we get great time complexities but we had to compromise on the space. Note that the new vector is used for both the function calls and hence the **space complexity for both the calls is O(N)**. \\n\\n```\\nclass BSTIterator {\\nprivate: \\n    vector<int> list;\\n    int loc;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        loc = 0;\\n        dfs(root);\\n    }\\n    void dfs(TreeNode* root){\\n        if(!root) return;\\n        dfs(root->left);\\n        list.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    int next() {\\n        return list[loc++];\\n    }\\n    bool hasNext() {\\n        if(loc<list.size()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\t new_iterator = BSTIterator(root);\\n\\t while (new_iterator.hasNext())\\n\\t    process(new_iterator.next());\\n```\n```\\nstatic const auto magic = []() {\\n  std::ios::sync_with_stdio(false);\\n  std::cin.tie(nullptr);\\n  std::cout.tie(nullptr);\\n  return nullptr;\\n}();\\n\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    TreeNode* visit;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        visit = root;\\n    }\\n    int next() {\\n        while(visit){\\n            st.push(visit);\\n            visit = visit->left;\\n        }\\n        TreeNode* next = st.top(); st.pop();\\n        visit = next->right;\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return visit || !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n```\n```\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pushLeft(root);\\n    }\\n    int next() {\\n        TreeNode* next = st.top(); st.pop();\\n        if(next->right) pushLeft(next->right);\\n        return next->val;\\n    }\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushLeft(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\nprivate: \\n    vector<int> list;\\n    int loc;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        loc = 0;\\n        dfs(root);\\n    }\\n    void dfs(TreeNode* root){\\n        if(!root) return;\\n        dfs(root->left);\\n        list.push_back(root->val);\\n        dfs(root->right);\\n    }\\n    int next() {\\n        return list[loc++];\\n    }\\n    bool hasNext() {\\n        if(loc<list.size()) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 52653,
                "title": "java-concise-solution",
                "content": "        \\n    private Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        pushLeft(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    private void pushLeft(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        pushLeft(node.right);\\n        return node.val;\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "        \\n    private Stack<TreeNode> stack;\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        pushLeft(root);\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    private void pushLeft(TreeNode node) {\\n        while (node != null) {\\n            stack.push(node);\\n            node = node.left;\\n        }\\n    }\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode node = stack.pop();\\n        pushLeft(node.right);\\n        return node.val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2130075,
                "title": "simple-cpp-code-using-morris-traversal-no-extra-space-top-90-fast-and-90-memory-use",
                "content": "Simply use Morris traversal and don\\'t make the Thread NULL again Let the right pointer point to next node.\\nStart from node with least value, so go to the very left.\\n\\n**next() Function Explanation**\\nTo change pointer to next move pointer to right and then left until node->left != null (just as traversing for next smallest element in normal BST)\\nbut we have chance that this right can be a thread we created so By checking weather the new pointer points to value lesser than current value then we just go right\\n```\\nint next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n```\\n**Final Code**\\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode* node;\\n    BSTIterator(TreeNode* root) {\\n        node = root;\\n        while(node != NULL){\\n            if(node->left == NULL){\\n                node = node->right;\\n            }else{\\n                TreeNode* temp = node->left;\\n                while(temp->right!=NULL && temp->right != node){\\n                    temp = temp->right;\\n                }\\n                if(temp->right == NULL)temp->right = node, node = node->left;\\n                else if(temp->right == node)node = node->right;\\n            }\\n        }\\n        node = root;\\n        while(node->left!=NULL)node = node->left;\\n    }\\n    \\n    int next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(node!=NULL)return true;\\n        \\n        return false;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nint next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n```\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode* node;\\n    BSTIterator(TreeNode* root) {\\n        node = root;\\n        while(node != NULL){\\n            if(node->left == NULL){\\n                node = node->right;\\n            }else{\\n                TreeNode* temp = node->left;\\n                while(temp->right!=NULL && temp->right != node){\\n                    temp = temp->right;\\n                }\\n                if(temp->right == NULL)temp->right = node, node = node->left;\\n                else if(temp->right == node)node = node->right;\\n            }\\n        }\\n        node = root;\\n        while(node->left!=NULL)node = node->left;\\n    }\\n    \\n    int next() {\\n        if(node!=NULL){\\n            int cur = node->val;\\n            TreeNode* pre = node;\\n            if(node->right == NULL){\\n                node = NULL;\\n                return cur;\\n            }\\n            node = node->right;\\n            while(node->left!=NULL)node = node->left;\\n            \\n            if(node->val <= cur){\\n                node = pre->right;\\n            }\\n            return cur;\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(node!=NULL)return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775226,
                "title": "javascript-clean-stack-solution",
                "content": "```javascript\\nclass BSTIterator {\\n    constructor(root) {\\n        this.root = root;\\n        this.stack = [];\\n    }\\n    \\n    next() {\\n        while(this.root) {\\n            this.stack.push(this.root);\\n            this.root = this.root.left;\\n        }\\n        const res = this.stack.pop();\\n        this.root = res.right;\\n        return res.val;\\n    }\\n    \\n    hasNext() {\\n        return this.root || this.stack.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nclass BSTIterator {\\n    constructor(root) {\\n        this.root = root;\\n        this.stack = [];\\n    }\\n    \\n    next() {\\n        while(this.root) {\\n            this.stack.push(this.root);\\n            this.root = this.root.left;\\n        }\\n        const res = this.stack.pop();\\n        this.root = res.right;\\n        return res.val;\\n    }\\n    \\n    hasNext() {\\n        return this.root || this.stack.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 241072,
                "title": "keep-prompting-runtime-error-on-json-decoding",
                "content": "From yesterday (on Feb. 20th) till now when I tried to run my code using the given test code, the platform keeps prompting that there is a Runtime Error on json decoding. I tried to submit directly but still received an error message:\\n\\n```\\nLine 56: json.decoder.JSONDecodeError: Expecting value: line 1 column 12 (char 11)\\n```\\n\\nThe same (local) error jumped out even when I tried to run the AC code posted in the discuss area. Could anyone kindly help me figure this out? Great thanks\\n\\n(I tried python3, python and Java, all failed)",
                "solutionTags": [],
                "code": "```\\nLine 56: json.decoder.JSONDecodeError: Expecting value: line 1 column 12 (char 11)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52591,
                "title": "c-binary-tree-template-solves-many-bst-problems-dfs",
                "content": "There is a template for solving many BST problems here is the basic idea starting with standard In Order Traversal.  Pay attention to the \"VISIT NODE\" block, depending on the problem you will plug in your custom logic into this part of the template.\\n\\n```\\n    public IList<int> InorderTraversal(TreeNode root) \\n    {\\n        IList<int> list = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                node = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                list.Add(node.val);\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                node = node.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```\\n\\nHere we can adapt this to the BST iterator problem where \"VISIT NODE\" means this is the next value and break here.\\n\\n```\\npublic class BSTIterator {\\n\\n    private TreeNode curr;\\n    private Stack<TreeNode> stack;\\n    \\n    public BSTIterator(TreeNode root) \\n    {\\n        this.curr = root;\\n        this.stack = new Stack<TreeNode>();\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() \\n    {\\n        return this.curr != null || this.stack.Count > 0;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() \\n    {\\n        int val = 0;\\n        while (this.curr != null || this.stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                this.stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                this.curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                val = curr.val;   \\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                this.curr = curr.right;\\n                break;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\\n\\nHere we adaptt it to find the Kth smallest value\\n\\n```\\n    public int KthSmallest(TreeNode root, int k) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (--k == 0) return curr.val;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\\n\\nValidate Binary Search Tree\\n```\\n    public bool IsValidBST(TreeNode root) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (prev != null && prev.val >= curr.val) return false;\\n                prev = curr;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<int> InorderTraversal(TreeNode root) \\n    {\\n        IList<int> list = new List<int>();\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode node = root;\\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                node = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                list.Add(node.val);\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                node = node.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```\n```\\npublic class BSTIterator {\\n\\n    private TreeNode curr;\\n    private Stack<TreeNode> stack;\\n    \\n    public BSTIterator(TreeNode root) \\n    {\\n        this.curr = root;\\n        this.stack = new Stack<TreeNode>();\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() \\n    {\\n        return this.curr != null || this.stack.Count > 0;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() \\n    {\\n        int val = 0;\\n        while (this.curr != null || this.stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                this.stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                this.curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                val = curr.val;   \\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                this.curr = curr.right;\\n                break;\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```\n```\\n    public int KthSmallest(TreeNode root, int k) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (--k == 0) return curr.val;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n```\n```\\n    public bool IsValidBST(TreeNode root) \\n    {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        \\n        while (curr != null || stack.Count > 0)\\n        {\\n            if (curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            else\\n            {\\n                curr = stack.Pop();\\n                \\n                // ---------------------------------------\\n                // VISIT NODE BEGIN\\n                // ---------------------------------------\\n                if (prev != null && prev.val >= curr.val) return false;\\n                prev = curr;\\n                // ---------------------------------------\\n                // VISIT NODE END\\n                // ---------------------------------------\\n                \\n                curr = curr.right;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52716,
                "title": "using-stack-with-explanations",
                "content": "    class BSTIterator {\\n       public:\\n        BSTIterator(TreeNode *root) {\\n            pushAllToTheLeftMost(root);\\n        }\\n    \\n        bool hasNext() {\\n            return !nodes.empty();\\n        }\\n    \\n        /**\\n         * Precondition: the top of the stack is current smallest node (t)\\n         *               whose value will be returned\\n         * \\n         * Postcondition: the top of the stack is the next smallest node.\\n         * \\n         * if the t has right node, the next smallest node will be the left \\n         * most of the right node; otherwise, the next smallest node is t's parent node, \\n         * which has already been pushed on the stack just before the t. \\n         * */\\n        int next() {\\n            TreeNode *t = nodes.top();\\n            nodes.pop();\\n            pushAllToTheLeftMost(t->right);\\n            return t->val;\\n        }\\n        \\n    private:\\n        /** push all the nodes from c to its left most node to the stack */\\n        void pushAllToTheLeftMost(TreeNode *c) {\\n            while (c) {\\n                nodes.push(c);\\n                c = c->left;\\n            }\\n        }\\n        stack<TreeNode*> nodes;\\n    };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n       public:\\n        BSTIterator(TreeNode *root) {\\n            pushAllToTheLeftMost(root);\\n        }\\n    \\n        bool hasNext() {\\n            return !nodes.empty();\\n        }\\n    \\n        /**\\n         * Precondition: the top of the stack is current smallest node (t)\\n         *               whose value will be returned\\n         * \\n         * Postcondition: the top of the stack is the next smallest node.\\n         * \\n         * if the t has right node, the next smallest node will be the left \\n         * most of the right node; otherwise, the next smallest node is t's parent node, \\n         * which has already been pushed on the stack just before the t. \\n         * */\\n        int next() {\\n            TreeNode *t = nodes.top();\\n            nodes.pop();\\n            pushAllToTheLeftMost(t->right);\\n            return t->val;\\n        }\\n        \\n    private:\\n        /** push all the nodes from c to its left most node to the stack */\\n        void pushAllToTheLeftMost(TreeNode *c) {\\n            while (c) {\\n                nodes.push(c);\\n                c = c->left;\\n            }\\n        }\\n        stack<TreeNode*> nodes;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 3574933,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\nThe code implements an iterator for a binary search tree (BST). The iterator is used to traverse the BST in ascending order, providing the next smallest element in each iteration.\\n\\n# Approach\\n- The BSTIterator class uses a stack to keep track of the nodes during traversal.\\n- In the constructor BSTIterator(TreeNode* root), the pushAll function is called to push all the left subtree nodes onto the stack. This ensures that the leftmost node becomes the top of the stack, representing the smallest element in the BST.\\n- The next function returns the value of the top node in the stack (which is the next smallest element) and removes it from the stack. Then, the pushAll function is called on the right child of the popped node to push all the left subtree nodes of the right child onto the stack.\\n- The hasNext function simply checks if the stack is empty or not. If the stack is not empty, it means there are more elements in the BST, and it returns true; otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\n## o(1)\\n\\n- Space complexity:\\n O(h)\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;  // Stack to store tree nodes\\n\\n    // Function to push all left subtree nodes onto the stack\\n    void pushAll(TreeNode* node) {\\n        while (node) {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n\\n    // Constructor that initializes the iterator\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);  // Push all left subtree nodes onto the stack\\n    }\\n\\n    // Function to return the next smallest element in the BST\\n    int next() {\\n        auto temp = st.top();  // Get the top node from the stack\\n        st.pop();  // Pop the node from the stack\\n        pushAll(temp->right);  // Push all left subtree nodes of the right child onto the stack\\n        return temp->val;  // Return the value of the popped node\\n    }\\n\\n    // Function to check if there are any more elements in the BST\\n    bool hasNext() {\\n        return !st.empty();  // Return true if the stack is not empty, indicating there are more elements\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;  // Stack to store tree nodes\\n\\n    // Function to push all left subtree nodes onto the stack\\n    void pushAll(TreeNode* node) {\\n        while (node) {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n\\n    // Constructor that initializes the iterator\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);  // Push all left subtree nodes onto the stack\\n    }\\n\\n    // Function to return the next smallest element in the BST\\n    int next() {\\n        auto temp = st.top();  // Get the top node from the stack\\n        st.pop();  // Pop the node from the stack\\n        pushAll(temp->right);  // Push all left subtree nodes of the right child onto the stack\\n        return temp->val;  // Return the value of the popped node\\n    }\\n\\n    // Function to check if there are any more elements in the BST\\n    bool hasNext() {\\n        return !st.empty();  // Return true if the stack is not empty, indicating there are more elements\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 579552,
                "title": "python-generator-solution-using-python-generator-with-yield",
                "content": "We have already some excellent solutions in this discussion but I wanted to share a Python solution using generator with yield for fun. next is O(1) and hasNext is O(1).\\n\\n```\\ndef inorder_generator(node):\\n    if node:\\n        yield from inorder_generator(node.left)\\n        yield node\\n        yield from inorder_generator(node.right)\\n\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.iterator = iter(inorder_generator(root))\\n        self._next = None\\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self._next:\\n            next_node = self._next\\n            self._next = None\\n            return next_node.val\\n\\n        next_node = next(self.iterator, None)\\n        if next_node:\\n            return next_node.val\\n        else:\\n            return None\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._next:\\n            return True\\n        \\n        try:\\n            self._next = next(self.iterator)\\n        except StopIteration:\\n            return False\\n        \\n        return True\\n```\\n\\nBTW, the idea hasNext on Python was from https://stackoverflow.com/questions/1966591/hasnext-in-python-iterators/1967037#1967037 \\n\\nAlex Martelli is one of the best Python guru and I always appreciate his contribution to Python.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef inorder_generator(node):\\n    if node:\\n        yield from inorder_generator(node.left)\\n        yield node\\n        yield from inorder_generator(node.right)\\n\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.iterator = iter(inorder_generator(root))\\n        self._next = None\\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self._next:\\n            next_node = self._next\\n            self._next = None\\n            return next_node.val\\n\\n        next_node = next(self.iterator, None)\\n        if next_node:\\n            return next_node.val\\n        else:\\n            return None\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._next:\\n            return True\\n        \\n        try:\\n            self._next = next(self.iterator)\\n        except StopIteration:\\n            return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340878,
                "title": "python-stack-solution",
                "content": "The solution of this problem is similar to the iterative solution of \\n[94. Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/332283/Python-recursive-and-iterative-solutions).\\n```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\\n\\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr or self.stack:\\n            if self.curr:\\n                self.stack.append(self.curr)\\n                self.curr = self.curr.left\\n            else:\\n                result = self.stack.pop()\\n                self.curr = result.right\\n                return result.val\\n        \\n    def hasNext(self):\\n        return self.curr or self.stack\\n```",
                "solutionTags": [],
                "code": "```\\n    def inorderTraversal(self, root):\\n        in_order = []\\n        stack, p = [], root\\n        while stack or p:\\n            if p:\\n                stack.append(p)\\n                p = p.left\\n            else:\\n                p = stack.pop()\\n                in_order.append(p.val)\\n                p = p.right\\n        return in_order\\n```\n```\\nclass BSTIterator:\\n    def __init__(self, root):\\n        self.stack = []\\n        self.curr = root\\n        \\n    def next(self):\\n        while self.curr or self.stack:\\n            if self.curr:\\n                self.stack.append(self.curr)\\n                self.curr = self.curr.left\\n            else:\\n                result = self.stack.pop()\\n                self.curr = result.right\\n                return result.val\\n        \\n    def hasNext(self):\\n        return self.curr or self.stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 202370,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for binary tree\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.array = []\\n    dfs(root, this.array)\\n    \\n    function dfs(root, array) {\\n        if(!root) {\\n            return\\n        }\\n        dfs(root.left, array)\\n        array.push(root.val)\\n        dfs(root.right, array)\\n    }\\n};\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.array.length > 0\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    if(this.hasNext()){\\n        return this.array.shift()\\n    }\\n};\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * var i = new BSTIterator(root), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for binary tree\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.array = []\\n    dfs(root, this.array)\\n    \\n    function dfs(root, array) {\\n        if(!root) {\\n            return\\n        }\\n        dfs(root.left, array)\\n        array.push(root.val)\\n        dfs(root.right, array)\\n    }\\n};\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.array.length > 0\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    if(this.hasNext()){\\n        return this.array.shift()\\n    }\\n};\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * var i = new BSTIterator(root), a = [];\\n * while (i.hasNext()) a.push(i.next());\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52690,
                "title": "python-tiny-o-1-time-o-h-space-solution-amortized",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class BSTIterator(object):\\n        def __init__(self, root):\\n            self._branch = []\\n            self._findLeftmost(root)\\n        \\n        def _findLeftmost(self, node):\\n            branch = self._branch\\n            while node is not None:\\n                branch.append(node)\\n                node = node.left\\n    \\n        def hasNext(self):\\n            return bool(self._branch)\\n    \\n        def next(self):\\n            node = self._branch.pop()\\n            self._findLeftmost(node.right)\\n            return node.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class BSTIterator(object):\\n        def __init__(self, root):\\n            self._branch = []\\n            self._findLeftmost(root)\\n        \\n        def _findLeftmost(self, node):\\n            branch = self._branch\\n            while node is not None:\\n                branch.append(node)\\n                node = node.left\\n    \\n        def hasNext(self):\\n            return bool(self._branch)\\n    \\n        def next(self):\\n            node = self._branch.pop()\\n            self._findLeftmost(node.right)\\n            return node.val",
                "codeTag": "Java"
            },
            {
                "id": 52708,
                "title": "elegant-java-solution-using-a-stack",
                "content": "    public class BSTIterator {\\n    private Stack<TreeNode> stack = null; \\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        \\n        TreeNode curr = root;\\n        while(curr!=null){\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        \\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        \\n        if(hasNext()){\\n            int ret = stack.peek().val;\\n            TreeNode curr = stack.pop();\\n            if(curr.right!=null){\\n                curr = curr.right;\\n                \\n                while(curr!=null){\\n                    stack.push(curr);\\n                    curr = curr.left;\\n                }\\n            }\\n            return ret;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "    public class BSTIterator {\\n    private Stack<TreeNode> stack = null; \\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack<>();\\n        \\n        TreeNode curr = root;\\n        while(curr!=null){\\n            stack.push(curr);\\n            curr = curr.left;\\n        }\\n        \\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return !stack.isEmpty();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        \\n        if(hasNext()){\\n            int ret = stack.peek().val;\\n            TreeNode curr = stack.pop();\\n            if(curr.right!=null){\\n                curr = curr.right;\\n                \\n                while(curr!=null){\\n                    stack.push(curr);\\n                    curr = curr.left;\\n                }\\n            }\\n            return ret;\\n        }\\n        return -1;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2945274,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* t1 = st.top();\\n        st.pop();\\n        TreeNode* t = t1->right;\\n        while(t)\\n        {\\n            st.push(t);\\n            t = t->left;\\n        }\\n        return t1->val;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.empty())\\n        return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n     stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode* t1 = st.top();\\n        st.pop();\\n        TreeNode* t = t1->right;\\n        while(t)\\n        {\\n            st.push(t);\\n            t = t->left;\\n        }\\n        return t1->val;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.empty())\\n        return false;\\n        return true;\\n        \\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967410,
                "title": "binary-search-tree-iterator",
                "content": "Easy C++ Solution ----->\\n  **inOrder Traversal**\\n  \\n  \\n  ```\\n  \\n   \\n       vector<int>v;\\n       void inOrder(TreeNode*  root){\\n           if(root==NULL) return;\\n             inOrder(root->left);\\n            int x;\\n         x = root->val;\\n        v.push_back(x);\\n            \\n        inOrder(root->right);\\n           \\n       }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);  \\n       \\n    }\\n    \\n    int next() {\\n         \\n        int temp =  v[0];\\n         v.erase(v.begin());\\n        \\n        return temp;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(v.size()>0) return true;\\n        \\n        else return false;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n  \\n   \\n       vector<int>v;\\n       void inOrder(TreeNode*  root){\\n           if(root==NULL) return;\\n             inOrder(root->left);\\n            int x;\\n         x = root->val;\\n        v.push_back(x);\\n            \\n        inOrder(root->right);\\n           \\n       }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inOrder(root);  \\n       \\n    }\\n    \\n    int next() {\\n         \\n        int temp =  v[0];\\n         v.erase(v.begin());\\n        \\n        return temp;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        if(v.size()>0) return true;\\n        \\n        else return false;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1966539,
                "title": "c-35ms-o-n-time-o-h-space-for-recursion",
                "content": "Run an `inorder` traversal to the tree and make connect them like a single linked-list. Now return answer however we want!\\n\\n```\\nclass BSTIterator {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *pre) {\\n        if (cur == nullptr) return pre;\\n        TreeNode *now = inorder(cur->left, pre);\\n        now->right = cur;\\n\\t\\tnow->left = nullptr;\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root, node);\\n    }\\n    \\n    int next() {\\n        node = node->right;\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return node->right != nullptr;\\n    }\\nprivate:\\n    TreeNode *node = new TreeNode(0);\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Depth-First Search"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    \\n    TreeNode* inorder(TreeNode *cur, TreeNode *pre) {\\n        if (cur == nullptr) return pre;\\n        TreeNode *now = inorder(cur->left, pre);\\n        now->right = cur;\\n\\t\\tnow->left = nullptr;\\n        return inorder(cur->right, now->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root, node);\\n    }\\n    \\n    int next() {\\n        node = node->right;\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return node->right != nullptr;\\n    }\\nprivate:\\n    TreeNode *node = new TreeNode(0);\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924032,
                "title": "java-simple",
                "content": "```\\nclass BSTIterator {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int i=0;\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(i++);\\n    }\\n    \\n    public boolean hasNext() {\\n        if(i<list.size())\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n    ArrayList<Integer> list=new ArrayList<>();\\n    int i=0;\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(i++);\\n    }\\n    \\n    public boolean hasNext() {\\n        if(i<list.size())\\n            return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515644,
                "title": "python-simple-beats-99-both-approach",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\ndef __init__(self, root: TreeNode):\\n        self.btree = []\\n        self.index = -1\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        if not node:\\n            return\\n        self.inorder(node.left)\\n        self.btree.append(node.val)\\n        self.inorder(node.right)\\n        \\n    def next(self) -> int:\\n        self.index+=1\\n        return self.btree[self.index]\\n    \\n\\n    def hasNext(self) -> bool:\\n        if self.index +1 < len(self.btree):\\n            return True\\n        return False\\n\\n# Approach 2\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        while(node):\\n            self.stack.append(node)\\n            node = node.left\\n        \\n    def next(self) -> int:\\n        smallest = self.stack.pop()\\n        if smallest.right:\\n            self.inorder(smallest.right)\\n        return smallest.val\\n        \\n    def hasNext(self) -> bool:\\n        \\n        return len(self.stack) > 0\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\nApproach 2\\nRuntime: 60 ms, faster than 99.69% of Python3 online submissions for Binary Search Tree Iterator.\\nMemory Usage: 20.4 MB, less than 72.63% of Python3 online submissions for Binary Search Tree Iterator.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\ndef __init__(self, root: TreeNode):\\n        self.btree = []\\n        self.index = -1\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        if not node:\\n            return\\n        self.inorder(node.left)\\n        self.btree.append(node.val)\\n        self.inorder(node.right)\\n        \\n    def next(self) -> int:\\n        self.index+=1\\n        return self.btree[self.index]\\n    \\n\\n    def hasNext(self) -> bool:\\n        if self.index +1 < len(self.btree):\\n            return True\\n        return False\\n\\n# Approach 2\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.inorder(root)\\n    \\n    def inorder(self, node):\\n        while(node):\\n            self.stack.append(node)\\n            node = node.left\\n        \\n    def next(self) -> int:\\n        smallest = self.stack.pop()\\n        if smallest.right:\\n            self.inorder(smallest.right)\\n        return smallest.val\\n        \\n    def hasNext(self) -> bool:\\n        \\n        return len(self.stack) > 0\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296969,
                "title": "simple-c-solution-complexity-requirements-satisfied",
                "content": "**Please upvote this post to motivate me in my quest of documenting leetcode solutions.**\\n```\\nclass BSTIterator {\\n    stack<TreeNode*> s;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        push_left_nodes(root);\\n    }\\n    void push_left_nodes(TreeNode* node)\\n    {\\n        while(node)\\n        {\\n            s.push(node);\\n            node = node->left;\\n        }\\n    }\\n    // TC - average O(1) SC - O(h)\\n    int next() {\\n        TreeNode* left = s.top();\\n        s.pop();\\n        push_left_nodes(left->right);\\n        return left->val;\\n    }\\n    // TC - O(1)\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    stack<TreeNode*> s;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        push_left_nodes(root);\\n    }\\n    void push_left_nodes(TreeNode* node)\\n    {\\n        while(node)\\n        {\\n            s.push(node);\\n            node = node->left;\\n        }\\n    }\\n    // TC - average O(1) SC - O(h)\\n    int next() {\\n        TreeNode* left = s.top();\\n        s.pop();\\n        push_left_nodes(left->right);\\n        return left->val;\\n    }\\n    // TC - O(1)\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967024,
                "title": "c-iteration-simple-solution-using-stack",
                "content": "```\\nclass BSTIterator {\\n    stack<TreeNode *> s;\\n    \\n    void leftmost_node(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        //s.clear();\\n        leftmost_node(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* top=s.top();\\n        s.pop();\\n        if(top->right)\\n            leftmost_node(top->right);        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return s.size()>0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\n    stack<TreeNode *> s;\\n    \\n    void leftmost_node(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        //s.clear();\\n        leftmost_node(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* top=s.top();\\n        s.pop();\\n        if(top->right)\\n            leftmost_node(top->right);        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return s.size()>0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966100,
                "title": "php-javascript-swift-stacks-faster-100-o-1-time-o-h-space-explained",
                "content": "I use `parents` array to save stack of active nodes.\\n`Init()` set a smallest element as active (left, left, left,... element).\\nOn call `next()` i get last element from `parents`, delete it, return `val` of it, and change active stack to next element of tree. If deleted element has right childrens, it\\'s new active next elements. Else we do nothing,  because we turn to parent elements in `parents` array yet.\\n`hasNext()` show has stack for new next element or not - it\\'s `parents` length.\\n\\nAnd code..\\n\\n**PHP:**\\n```\\nclass BSTIterator\\n{\\n    private $parents = [];\\n\\n    function __construct($root)\\n    {\\n        while ($root) {\\n            $this->parents[] = $root;\\n            $root = $root->left;\\n        }\\n    }\\n\\n    function next()\\n    {\\n        $cur = array_pop($this->parents);\\n        $val = $cur->val;\\n        if ($cur->right) {\\n            $cur = $cur->right;\\n            while ($cur) {\\n                $this->parents[] = $cur;\\n                $cur = $cur->left;\\n            }\\n        }\\n        return $val;\\n    }\\n\\n    function hasNext()\\n    {\\n        return count($this->parents) > 0;\\n    }\\n}\\n```\\n**JavaScript:**\\n```\\nvar BSTIterator = function (root) {\\n    this.parents = []\\n\\n    while (root) {\\n        this.parents.push(root)\\n        root = root.left\\n    }\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    let cur = this.parents.pop()\\n    const val = cur.val\\n    if (cur.right) {\\n        cur = cur.right\\n        while (cur) {\\n            this.parents.push(cur)\\n            cur = cur.left\\n        }\\n    }\\n    return val\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    return this.parents.length > 0\\n};\\n```\\n**Swift:**\\n```\\nclass BSTIterator {\\n     var parents: [TreeNode?] = []\\n\\n     init(_ root: TreeNode?) {\\n         var root = root\\n\\n         while root != nil {\\n             self.parents.append(root)\\n             root = root?.left\\n         }\\n     }\\n\\n     func next() -> Int {\\n         var cur = self.parents.removeLast()\\n         let val = cur!.val\\n         if (cur?.right != nil) {\\n             cur = cur!.right\\n             while cur != nil {\\n                 self.parents.append(cur)\\n                 cur = cur?.left\\n             }\\n         }\\n         return val\\n     }\\n\\n     func hasNext() -> Bool {\\n         return !self.parents.isEmpty\\n     }\\n }\\n```\\n\\n**Thanks and upvote!**",
                "solutionTags": [
                    "JavaScript",
                    "Swift",
                    "PHP"
                ],
                "code": "```\\nclass BSTIterator\\n{\\n    private $parents = [];\\n\\n    function __construct($root)\\n    {\\n        while ($root) {\\n            $this->parents[] = $root;\\n            $root = $root->left;\\n        }\\n    }\\n\\n    function next()\\n    {\\n        $cur = array_pop($this->parents);\\n        $val = $cur->val;\\n        if ($cur->right) {\\n            $cur = $cur->right;\\n            while ($cur) {\\n                $this->parents[] = $cur;\\n                $cur = $cur->left;\\n            }\\n        }\\n        return $val;\\n    }\\n\\n    function hasNext()\\n    {\\n        return count($this->parents) > 0;\\n    }\\n}\\n```\n```\\nvar BSTIterator = function (root) {\\n    this.parents = []\\n\\n    while (root) {\\n        this.parents.push(root)\\n        root = root.left\\n    }\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    let cur = this.parents.pop()\\n    const val = cur.val\\n    if (cur.right) {\\n        cur = cur.right\\n        while (cur) {\\n            this.parents.push(cur)\\n            cur = cur.left\\n        }\\n    }\\n    return val\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    return this.parents.length > 0\\n};\\n```\n```\\nclass BSTIterator {\\n     var parents: [TreeNode?] = []\\n\\n     init(_ root: TreeNode?) {\\n         var root = root\\n\\n         while root != nil {\\n             self.parents.append(root)\\n             root = root?.left\\n         }\\n     }\\n\\n     func next() -> Int {\\n         var cur = self.parents.removeLast()\\n         let val = cur!.val\\n         if (cur?.right != nil) {\\n             cur = cur!.right\\n             while cur != nil {\\n                 self.parents.append(cur)\\n                 cur = cur?.left\\n             }\\n         }\\n         return val\\n     }\\n\\n     func hasNext() -> Bool {\\n         return !self.parents.isEmpty\\n     }\\n }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965879,
                "title": "c-36-ms-99-8-with-stack",
                "content": "```\\nclass BSTIterator {\\nprivate:\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        move_left(root);\\n    }\\n\\n    bool hasNext() {\\n        if (st.empty()) return false;\\n        return true;\\n    }\\n\\n    int next() {\\n        TreeNode* tmp = st.top();\\n        st.pop();\\n        if (tmp->right) move_left(tmp->right);\\n        return tmp->val;\\n    }\\n    \\n    void move_left(TreeNode* node)\\n    {\\n        TreeNode* tmp = node;\\n        while (tmp) {st.push(tmp);tmp = tmp->left;}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        move_left(root);\\n    }\\n\\n    bool hasNext() {\\n        if (st.empty()) return false;\\n        return true;\\n    }\\n\\n    int next() {\\n        TreeNode* tmp = st.top();\\n        st.pop();\\n        if (tmp->right) move_left(tmp->right);\\n        return tmp->val;\\n    }\\n    \\n    void move_left(TreeNode* node)\\n    {\\n        TreeNode* tmp = node;\\n        while (tmp) {st.push(tmp);tmp = tmp->left;}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 965539,
                "title": "c-99-100-memory-10-liner-crispy-af",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n    \\n    BSTIterator(TreeNode* root) {\\n        v.clear();\\n        \\n        inorder(root);\\n        \\n        i = 0;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < v.size();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```\\n\\nExplanation -\\n\\n1. Inorder traverse tree and add to vector\\n2. Use vector to get next value\\n3. ???\\n4. Profit! \\uD83E\\uDD19\\n\\nAs always,\\n\\uD83E\\uDD19 Stay crispy guys \\uD83E\\uDD19",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    vector<int> v;\\n    int i;\\n    \\n    BSTIterator(TreeNode* root) {\\n        v.clear();\\n        \\n        inorder(root);\\n        \\n        i = 0;\\n    }\\n    \\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    int next() {\\n        return v[i++];\\n    }\\n    \\n    bool hasNext() {\\n        return i < v.size();\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401657,
                "title": "simple-javascript-solution",
                "content": "Runtime: 140 ms, faster than 75.80% of JavaScript online submissions for Binary Search Tree Iterator.\\nMemory Usage: 48.3 MB, less than 100.00% of JavaScript online submissions for Binary Search Tree Iterator.\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    this.cache = []\\n    const traverse = (node) => {\\n        if (node) {\\n            if (node.left) traverse(node.left)\\n            this.cache.push(node.val)\\n            if (node.right) traverse(node.right)\\n        }\\n    }\\n    traverse(root)\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.cache.shift()\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cache.length > 0\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n */\\nvar BSTIterator = function(root) {\\n    this.cache = []\\n    const traverse = (node) => {\\n        if (node) {\\n            if (node.left) traverse(node.left)\\n            this.cache.push(node.val)\\n            if (node.right) traverse(node.right)\\n        }\\n    }\\n    traverse(root)\\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    return this.cache.shift()\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cache.length > 0\\n};\\n\\n/** \\n * Your BSTIterator object will be instantiated and called as such:\\n * var obj = new BSTIterator(root)\\n * var param_1 = obj.next()\\n * var param_2 = obj.hasNext()\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52644,
                "title": "java-with-morris-method-4ms-99-without-stack",
                "content": "Morris method is general used to travel Binary tree, and BST Iterator is just like travel tree.\\n    \\n    /** Morris */\\n    public class BSTIterator {\\n        private TreeNode read = null;\\n        public BSTIterator(TreeNode root) {\\n        read = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return read != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int x = 0;\\n        while ( read != null ){\\n            if ( read.left == null ){\\n                x = read.val;\\n                read = read.right;\\n                break;\\n            }else{\\n                TreeNode tempNode = read.left;\\n                // Find most 'right' child in left subtree\\n                while ( tempNode.right != null && tempNode.right != read ){\\n                    tempNode = tempNode.right;\\n                }\\n                if ( tempNode.right == null ){\\n                    tempNode.right = read;\\n                    read = read.left;\\n                }else{\\n                    x = tempNode.right.val;\\n                    tempNode.right = null;\\n                    read = read.right;\\n                    break;\\n                }\\n            }\\n        }// end_while\\n        return x;\\n    }// end_method\\n}// end_class",
                "solutionTags": [],
                "code": "Morris method is general used to travel Binary tree, and BST Iterator is just like travel tree.\\n    \\n    /** Morris */\\n    public class BSTIterator {\\n        private TreeNode read = null;\\n        public BSTIterator(TreeNode root) {\\n        read = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return read != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int x = 0;\\n        while ( read != null ){\\n            if ( read.left == null ){\\n                x = read.val;\\n                read = read.right;\\n                break;\\n            }else{\\n                TreeNode tempNode = read.left;\\n                // Find most 'right' child in left subtree\\n                while ( tempNode.right != null && tempNode.right != read ){\\n                    tempNode = tempNode.right;\\n                }\\n                if ( tempNode.right == null ){\\n                    tempNode.right = read;\\n                    read = read.left;\\n                }else{\\n                    x = tempNode.right.val;\\n                    tempNode.right = null;\\n                    read = read.right;\\n                    break;\\n                }\\n            }\\n        }// end_while\\n        return x;\\n    }// end_method\\n}// end_class",
                "codeTag": "Java"
            },
            {
                "id": 52673,
                "title": "c-morris-traverse-solution-o-1-space-easy-understanding",
                "content": "\\n\\n    BSTIterator(TreeNode *root) {\\n        cur = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return cur != nullptr;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        int val = 0;\\n        while (cur) {\\n            if (!cur->left) {\\n                val = cur->val;\\n                cur = cur->right;\\n                return val;\\n            } else {\\n                TreeNode *right_m = cur->left;\\n                while(right_m->right && right_m->right != cur) right_m = right_m->right;\\n                if (!right_m->right) {\\n                    right_m->right = cur;\\n                    cur = cur->left;\\n                } else {\\n                    right_m->right = nullptr;\\n                    val = cur->val;\\n                    cur = cur->right;\\n                    return val;\\n                }\\n            }\\n        }\\n    }\\n    private:\\n    TreeNode *cur;",
                "solutionTags": [],
                "code": "\\n\\n    BSTIterator(TreeNode *root) {\\n        cur = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return cur != nullptr;\\n    }\\n\\n    /** @return the next smallest number */\\n    int next() {\\n        int val = 0;\\n        while (cur) {\\n            if (!cur->left) {\\n                val = cur->val;\\n                cur = cur->right;\\n                return val;\\n            } else {\\n                TreeNode *right_m = cur->left;\\n                while(right_m->right && right_m->right != cur) right_m = right_m->right;\\n                if (!right_m->right) {\\n                    right_m->right = cur;\\n                    cur = cur->left;\\n                } else {\\n                    right_m->right = nullptr;\\n                    val = cur->val;\\n                    cur = cur->right;\\n                    return val;\\n                }\\n            }\\n        }\\n    }\\n    private:\\n    TreeNode *cur;",
                "codeTag": "Unknown"
            },
            {
                "id": 52746,
                "title": "28-ms-c-solution-with-stack",
                "content": "    class BSTIterator {\\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            while(root) {\\n                s.push(root);\\n                root =  root->left;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* n = s.top();\\n            s.pop();\\n            TreeNode* r = n->right;\\n            while(r) {\\n                s.push(r);\\n                r = r->left;\\n            }\\n            return n->val;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Tree"
                ],
                "code": "    class BSTIterator {\\n        stack<TreeNode*> s;\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            while(root) {\\n                s.push(root);\\n                root =  root->left;\\n            }\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty();\\n        }\\n    \\n        /** @return the next smallest number */\\n        int next() {\\n            TreeNode* n = s.top();\\n            s.pop();\\n            TreeNode* r = n->right;\\n            while(r) {\\n                s.push(r);\\n                r = r->left;\\n            }\\n            return n->val;\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 4008782,
                "title": "2-simple-c-solutions-beats-99-7-well-explained",
                "content": "![image.png](https://assets.leetcode.com/users/images/eb4fc870-7fb0-460e-8b50-12a2c9c057d3_1693985216.5149693.png)\\n\\n\\n# Approach - 1: Using vector\\n\\n**Logic/Intuition:**\\n\\n- This implementation uses an array to store all the elements of the BST in sorted order upfront. The iterator then simply moves through the array.\\n\\n\\n**Time Complexity:**\\n- The constructor (`BSTIterator`) runs in $$O(n)$$ time, where n is the number of nodes in the BST. It performs a complete in-order traversal to populate the `arr` vector.\\n- The `next()` and `hasNext()` functions each run in $$O(1)$$ time because retrieving an element from an array and checking if the index is within bounds are constant-time operations.\\n\\n**Space Complexity:**\\n- The space complexity of this implementation is $$O(n)$$, where n is the number of nodes in the BST. This space is used to store all elements of the BST in the `arr` vector.\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> arr = {-1}; //dummy element to take care of indexing\\n    int idx;\\n\\n    void dfs (TreeNode* root) { \\n//simple inorder traversal & storing the elements in the array\\n        if (!root) return;\\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        dfs (root);\\n        idx = 0;\\n    }\\n    \\n    int next() {\\n        if (hasNext()) {\\n            idx++;\\n            return arr[idx];\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        return (idx+1 < arr.size());\\n    }\\n};\\n```\\n\\n# Approach - 2: Using stack (Optimal)\\n**Logic/Intuition:**\\n- The key idea is to use a stack to keep track of the nodes to be visited and their respective positions in the in-order traversal.\\n\\n**Time Complexity:**\\n- The `next()` and `hasNext()` functions each run in $$O(1)$$ time on average because popping from the stack and checking if it\\'s empty are constant-time operations. Even in the worst case, when the BST is skewed, the amortised time complexity of `next()` turns out to be $$O(1)$$.\\n- **This is because each element is being pushed or popped from the stack once at max in the overall run.**\\n\\n**Space Complexity:**\\n- The space complexity of the stack used by the `BSTIterator` class is $$O(h)$$, where h is the height of the BST. In the worst case, when the BST is skewed and the height is equal to the number of nodes (n), the space complexity becomes $$O(n)$$.\\n\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void helper (TreeNode* root) {\\n// helper func - push all elements to the left of the node (including the node) into the stack\\n        while (root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        helper(root); //to initialise the stack\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        TreeNode* node = st.top();\\n        st.pop();\\n        helper(node->right);\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\\n\\nPlease upvote if you found this solution post helpful.",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Tree",
                    "Design",
                    "Binary Search Tree",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> arr = {-1}; //dummy element to take care of indexing\\n    int idx;\\n\\n    void dfs (TreeNode* root) { \\n//simple inorder traversal & storing the elements in the array\\n        if (!root) return;\\n        dfs(root->left);\\n        arr.push_back(root->val);\\n        dfs(root->right);\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        dfs (root);\\n        idx = 0;\\n    }\\n    \\n    int next() {\\n        if (hasNext()) {\\n            idx++;\\n            return arr[idx];\\n        }\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        return (idx+1 < arr.size());\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    void helper (TreeNode* root) {\\n// helper func - push all elements to the left of the node (including the node) into the stack\\n        while (root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n\\n    BSTIterator(TreeNode* root) {\\n        helper(root); //to initialise the stack\\n    }\\n    \\n    int next() {\\n        if (st.empty()) return -1;\\n        TreeNode* node = st.top();\\n        st.pop();\\n        helper(node->right);\\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615589,
                "title": "python-94-82-faster-easy-iterative-solution",
                "content": "```\\nclass BSTIterator:\\n    st=[]\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.pushall(root)\\n\\n    def next(self) -> int:\\n        temp=self.st.pop()\\n        self.pushall(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return True if len(self.st)>0 else False\\n\\n    def pushall(self,root):\\n        while root:\\n            self.st.append(root)\\n            root=root.left\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator:\\n    st=[]\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.pushall(root)\\n\\n    def next(self) -> int:\\n        temp=self.st.pop()\\n        self.pushall(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return True if len(self.st)>0 else False\\n\\n    def pushall(self,root):\\n        while root:\\n            self.st.append(root)\\n            root=root.left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524919,
                "title": "very-easy-java-solution-using-arraylist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list=new ArrayList();\\n    int index=0;\\n\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(index++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return index<list.size();\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list=new ArrayList();\\n    int index=0;\\n\\n    public BSTIterator(TreeNode root) {\\n        inorder(root);\\n    }\\n    void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n    \\n    public int next() {\\n        return list.get(index++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return index<list.size();\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012525,
                "title": "easy-c-code-with-sc-tc",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing the concept of inorder traversal.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1) \\nSince we push every element only once. There might be N calls and we are pushing N nodes.\\nSo, avg TC is O(1).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H) where H is the height of tree.\\n\\n# Code\\n```\\n\\nclass BSTIterator {\\npublic:\\nstack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        pushing(root);\\n    }\\n    void pushing(TreeNode *root){\\n        s.push(root);\\n        while(root->left) {root=root->left;s.push(root);}\\n    }\\n    int next() {\\n        TreeNode *temp=s.top();s.pop();\\n        if(temp->right){\\n            pushing(temp->right);\\n        }\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass BSTIterator {\\npublic:\\nstack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        pushing(root);\\n    }\\n    void pushing(TreeNode *root){\\n        s.push(root);\\n        while(root->left) {root=root->left;s.push(root);}\\n    }\\n    int next() {\\n        TreeNode *temp=s.top();s.pop();\\n        if(temp->right){\\n            pushing(temp->right);\\n        }\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672648,
                "title": "simple-solution-with-o-n-memory-and-o-1-time",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    int a[100001] = {0};\\n    int count = 0;\\n    int n = 0;\\n    void traversal(TreeNode *root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        traversal(root);\\n    }\\n    \\n    int next() {\\n        if(n < count) return a[n++];\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(n < count) return true;\\n        return false;\\n    }\\n};\\n```\\n\\nPlz upvote if you like!!",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    int a[100001] = {0};\\n    int count = 0;\\n    int n = 0;\\n    void traversal(TreeNode *root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        traversal(root);\\n    }\\n    \\n    int next() {\\n        if(n < count) return a[n++];\\n        return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(n < count) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967502,
                "title": "c-using-stack-o-h-solution",
                "content": "```\\nclass BSTIterator \\n{\\npublic:\\n    stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) \\n    {\\n        leftTree(root);\\n    }\\n    \\n    int next() \\n    {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        \\n        if(top->right!=NULL)\\n        {\\n            leftTree(top->right);\\n        }\\n        return top->val;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return st.empty() ? false:true;\\n    }\\n    \\n    void leftTree(TreeNode* root)\\n    {\\n        TreeNode* node = root;\\n        \\n        while(node)\\n        {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator \\n{\\npublic:\\n    stack<TreeNode*> st;\\n    BSTIterator(TreeNode* root) \\n    {\\n        leftTree(root);\\n    }\\n    \\n    int next() \\n    {\\n        TreeNode* top = st.top();\\n        st.pop();\\n        \\n        if(top->right!=NULL)\\n        {\\n            leftTree(top->right);\\n        }\\n        return top->val;\\n    }\\n    \\n    bool hasNext() \\n    {\\n        return st.empty() ? false:true;\\n    }\\n    \\n    void leftTree(TreeNode* root)\\n    {\\n        TreeNode* node = root;\\n        \\n        while(node)\\n        {\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965728,
                "title": "c-2-solutions-with-w-o-stack-inorder-easy-clean-code",
                "content": "**1. Using Stack ( Iterative )**\\nTime - O(n) (approx.)\\nSpace - O(h)\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        st.push(root);\\n        \\n        while(root->left)\\n        {\\n            st.push(root->left);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode *root=st.top();\\n        st.pop();\\n        \\n        int ans=root->val;\\n        \\n        if(root->right)\\n        {\\n            root=root->right;\\n            st.push(root);\\n            while(root->left)\\n            {\\n                st.push(root->left);\\n                root=root->left;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\\n\\n**2. Without extra space / Converting tree ( Recursive )**\\nTime - O(n)\\nSpace - O(1)\\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode *head,*t; \\n    \\n    void convert(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        convert(root->left);\\n        \\n        t->right=root;\\n        t=t->right;\\n        \\n        convert(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        \\n        head=new TreeNode(0);\\n        t=head;\\n        convert(root);\\n    }\\n    \\n    int next() {\\n        head=head->right;\\n        return head->val;\\n    }\\n    \\n    bool hasNext() {\\n        return (head->right!=NULL);\\n    }\\n};\\n```\\n\\n**Do share your views & upvote if you like !!!** \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        st.push(root);\\n        \\n        while(root->left)\\n        {\\n            st.push(root->left);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        TreeNode *root=st.top();\\n        st.pop();\\n        \\n        int ans=root->val;\\n        \\n        if(root->right)\\n        {\\n            root=root->right;\\n            st.push(root);\\n            while(root->left)\\n            {\\n                st.push(root->left);\\n                root=root->left;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    TreeNode *head,*t; \\n    \\n    void convert(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        convert(root->left);\\n        \\n        t->right=root;\\n        t=t->right;\\n        \\n        convert(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        \\n        head=new TreeNode(0);\\n        t=head;\\n        convert(root);\\n    }\\n    \\n    int next() {\\n        head=head->right;\\n        return head->val;\\n    }\\n    \\n    bool hasNext() {\\n        return (head->right!=NULL);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265415,
                "title": "my-solution-in-avg-o-1-time-and-o-1-space-using-inorder-morris-traversal",
                "content": "```\\npublic static class BSTIterator {\\n        TreeNode curr = null;\\n\\n        public BSTIterator(TreeNode root) {\\n            this.curr = root;\\n        }\\n\\n        // rmn : right most node\\n        private TreeNode getRightMostNode(TreeNode rmn) {\\n            while (rmn.right != null && rmn.right != this.curr)\\n                rmn = rmn.right;\\n            return rmn;\\n        }\\n\\n        private TreeNode morrisTraversal() {\\n            TreeNode res = null;\\n\\n            while (this.curr != null) {\\n                TreeNode leftNode = this.curr.left;\\n                if (leftNode == null) {\\n                    res = this.curr;\\n                    this.curr = this.curr.right;\\n                    break;\\n                } else {\\n                    TreeNode rightMostNode = getRightMostNode(leftNode);\\n                    if (rightMostNode.right == null) {\\n                        rightMostNode.right = this.curr;// thread creation\\n                        this.curr = this.curr.left;\\n                    } else {\\n                        res = this.curr;\\n                        rightMostNode.right = null; // thread cut down\\n                        this.curr = this.curr.right;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int next() {\\n            TreeNode res = morrisTraversal();\\n            return res.val;\\n        }\\n\\n        public boolean hasNext() {\\n            return this.curr != null;\\n\\n        }\\n    }\\n",
                "solutionTags": [],
                "code": "```\\npublic static class BSTIterator {\\n        TreeNode curr = null;\\n\\n        public BSTIterator(TreeNode root) {\\n            this.curr = root;\\n        }\\n\\n        // rmn : right most node\\n        private TreeNode getRightMostNode(TreeNode rmn) {\\n            while (rmn.right != null && rmn.right != this.curr)\\n                rmn = rmn.right;\\n            return rmn;\\n        }\\n\\n        private TreeNode morrisTraversal() {\\n            TreeNode res = null;\\n\\n            while (this.curr != null) {\\n                TreeNode leftNode = this.curr.left;\\n                if (leftNode == null) {\\n                    res = this.curr;\\n                    this.curr = this.curr.right;\\n                    break;\\n                } else {\\n                    TreeNode rightMostNode = getRightMostNode(leftNode);\\n                    if (rightMostNode.right == null) {\\n                        rightMostNode.right = this.curr;// thread creation\\n                        this.curr = this.curr.left;\\n                    } else {\\n                        res = this.curr;\\n                        rightMostNode.right = null; // thread cut down\\n                        this.curr = this.curr.right;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            return res;\\n        }\\n\\n        public int next() {\\n            TreeNode res = morrisTraversal();\\n            return res.val;\\n        }\\n\\n        public boolean hasNext() {\\n            return this.curr != null;\\n\\n        }\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 1178663,
                "title": "c-easy-solution-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    // stack to maintain next smallest value\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        in(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* curr=st.top();\\n        st.pop();\\n        // push the outer left arm of right subtree\\n        //  as next smallest element will now be the \\n        // left most element of right subtree\\n        in(curr->right);\\n        return curr->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    \\n    // to push outer left arm of root\\n    // like in iterative inorder traversal\\n    void in(TreeNode* root)\\n    {\\n        TreeNode* curr=root;\\n        while(curr)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    // stack to maintain next smallest value\\n    stack<TreeNode*> st;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        in(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* curr=st.top();\\n        st.pop();\\n        // push the outer left arm of right subtree\\n        //  as next smallest element will now be the \\n        // left most element of right subtree\\n        in(curr->right);\\n        return curr->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    \\n    // to push outer left arm of root\\n    // like in iterative inorder traversal\\n    void in(TreeNode* root)\\n    {\\n        TreeNode* curr=root;\\n        while(curr)\\n        {\\n            st.push(curr);\\n            curr=curr->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */",
                "codeTag": "Java"
            },
            {
                "id": 966361,
                "title": "javascript-generator",
                "content": "```\\nvar BSTIterator = function(root) {\\n    function* generator( xxxx ) {\\n        function* recur(node ) {\\n            if ( ! node ) return\\n\\n            if ( node.left ) yield* recur( node.left )\\n            yield node.val\\n            if ( node.right) yield* recur( node.right )\\n        }\\n        yield* recur( xxxx )\\n    }\\n\\n    this.thing = generator( root )\\n    this.node = this.thing.next()\\n}\\n\\nBSTIterator.prototype.next = function() {\\n    const node = this.node\\n    this.node = this.thing.next()\\n    return node.value\\n}\\n\\nBSTIterator.prototype.hasNext = function() {\\n    return undefined !== this.node.value\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar BSTIterator = function(root) {\\n    function* generator( xxxx ) {\\n        function* recur(node ) {\\n            if ( ! node ) return\\n\\n            if ( node.left ) yield* recur( node.left )\\n            yield node.val\\n            if ( node.right) yield* recur( node.right )\\n        }\\n        yield* recur( xxxx )\\n    }\\n\\n    this.thing = generator( root )\\n    this.node = this.thing.next()\\n}\\n\\nBSTIterator.prototype.next = function() {\\n    const node = this.node\\n    this.node = this.thing.next()\\n    return node.value\\n}\\n\\nBSTIterator.prototype.hasNext = function() {\\n    return undefined !== this.node.value\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 966260,
                "title": "python-generator",
                "content": "```python\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if node:\\n                # print(root.val)\\n                yield from inorder(node.left)\\n                yield node.val\\n                yield from inorder(node.right)\\n        self.output_queue = collections.deque()\\n        self.generator = inorder(root)\\n        \\n    def next(self) -> int:\\n        if len(self.output_queue) > 0:\\n            return self.output_queue.popleft()\\n        return next(self.generator)\\n\\n    def hasNext(self) -> bool:\\n        try:\\n            self.output_queue.append(next(self.generator))\\n            return True\\n        except StopIteration:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```python\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if node:\\n                # print(root.val)\\n                yield from inorder(node.left)\\n                yield node.val\\n                yield from inorder(node.right)\\n        self.output_queue = collections.deque()\\n        self.generator = inorder(root)\\n        \\n    def next(self) -> int:\\n        if len(self.output_queue) > 0:\\n            return self.output_queue.popleft()\\n        return next(self.generator)\\n\\n    def hasNext(self) -> bool:\\n        try:\\n            self.output_queue.append(next(self.generator))\\n            return True\\n        except StopIteration:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722865,
                "title": "python-generator-with-yield",
                "content": "```\\n# Python2\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        def inorder(node):\\n            if not node: return\\n            for val in inorder(node.left):\\n                yield val\\n            yield node.val\\n            for val in inorder(node.right):\\n                yield val\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer        \\n \\n    def next(self):\\n        \"\"\"\\n        @return the next smallest number\\n        :rtype: int\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        :rtype: bool\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n#Python3\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if not node: return\\n            yield from inorder(node.left)\\n            yield node.val\\n            yield from inorder(node.right)\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer           \\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None        \\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False        \\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Python2\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        def inorder(node):\\n            if not node: return\\n            for val in inorder(node.left):\\n                yield val\\n            yield node.val\\n            for val in inorder(node.right):\\n                yield val\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer        \\n \\n    def next(self):\\n        \"\"\"\\n        @return the next smallest number\\n        :rtype: int\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None\\n        \\n\\n    def hasNext(self):\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        :rtype: bool\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False\\n\\t\\t\\t\\n#Python3\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(node):\\n            if not node: return\\n            yield from inorder(node.left)\\n            yield node.val\\n            yield from inorder(node.right)\\n        self._iter=inorder(root)\\n        self._buffer=None # peeked buffer           \\n\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        if self.hasNext():\\n            rlt=self._buffer\\n            self._buffer=None\\n            return rlt\\n        else:\\n            return None        \\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        if self._buffer is None:\\n            self._buffer=next(self._iter,None)\\n\\n        if self._buffer!=None:\\n            return True\\n        else:\\n            return False        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 717690,
                "title": "cpp-solution",
                "content": "// Runtime: 160 ms, faster than 5.66% of C++ online submissions for Binary Search Tree Iterator.\\n// Memory Usage: 27.7 MB, less than 66.17% of C++ online submissions for Binary Search Tree Iterator.\\n```\\n//logic : store the left nodes and root of the tree in stack so that the leftmost is at top which is the smallest\\n//when we are removing child nodes eg the smallest one then next smallest  will be its parent node but when we will remove a node which has a right child the we will store again that right child and its left nodes\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    void storeLeftNodes(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root =  root->left;\\n        }\\n    }\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        storeLeftNodes(root);\\n    }\\n    \\n    /** @return the next smallest number */\\n    int next() {\\n        if(st.size() == 0) return -1;\\n        TreeNode* temp = st.top();\\n        st.pop();\\n        storeLeftNodes(temp->right);\\n        return temp->val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return st.size() != 0;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "// Runtime: 160 ms, faster than 5.66% of C++ online submissions for Binary Search Tree Iterator.\\n// Memory Usage: 27.7 MB, less than 66.17% of C++ online submissions for Binary Search Tree Iterator.\\n```\\n//logic : store the left nodes and root of the tree in stack so that the leftmost is at top which is the smallest\\n//when we are removing child nodes eg the smallest one then next smallest  will be its parent node but when we will remove a node which has a right child the we will store again that right child and its left nodes\\nclass BSTIterator {\\n    stack<TreeNode*> st;\\n    void storeLeftNodes(TreeNode* root){\\n        while(root){\\n            st.push(root);\\n            root =  root->left;\\n        }\\n    }\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        storeLeftNodes(root);\\n    }\\n    \\n    /** @return the next smallest number */\\n    int next() {\\n        if(st.size() == 0) return -1;\\n        TreeNode* temp = st.top();\\n        st.pop();\\n        storeLeftNodes(temp->right);\\n        return temp->val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    bool hasNext() {\\n        return st.size() != 0;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 471971,
                "title": "java-o-h-space",
                "content": "```\\nclass BSTIterator {\\n\\n    // A list whose last element is the next smallest\\n    List<TreeNode> path = new ArrayList<>();\\n    \\n    public BSTIterator(TreeNode root) {\\n        DFS(root, path);\\n    }\\n    \\n    // Find the next smallest element, stop when a node doesn\\'t have left child,\\n    // and that node has the next smallest element.\\n    // The length of path is at most the tree height, thus O(h) space.\\n    public void DFS(TreeNode root, List<TreeNode> path) {\\n        if (root == null) return;\\n        \\n        path.add(root);\\n        \\n        DFS(root.left, path);\\n    }\\n    \\n    /** @return the next smallest number */\\n    // remove the last element, then find the next smallest element in the right sub-tree\\n    public int next() {\\n        TreeNode node = path.remove(path.size() - 1);\\n        DFS(node.right, path); \\n        return node.val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return path.size() > 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n\\n    // A list whose last element is the next smallest\\n    List<TreeNode> path = new ArrayList<>();\\n    \\n    public BSTIterator(TreeNode root) {\\n        DFS(root, path);\\n    }\\n    \\n    // Find the next smallest element, stop when a node doesn\\'t have left child,\\n    // and that node has the next smallest element.\\n    // The length of path is at most the tree height, thus O(h) space.\\n    public void DFS(TreeNode root, List<TreeNode> path) {\\n        if (root == null) return;\\n        \\n        path.add(root);\\n        \\n        DFS(root.left, path);\\n    }\\n    \\n    /** @return the next smallest number */\\n    // remove the last element, then find the next smallest element in the right sub-tree\\n    public int next() {\\n        TreeNode node = path.remove(path.size() - 1);\\n        DFS(node.right, path); \\n        return node.val;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return path.size() > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 378074,
                "title": "c-yield-beats-27-time-100-memory",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class BSTIterator {\\n    private bool hasNext;\\n    private IEnumerator<int> iter;\\n    \\n    private static IEnumerable<int> Inorder(TreeNode root) {\\n        if (root == null) {\\n            yield break;\\n        }\\n        \\n        foreach (var x in Inorder(root.left)) {\\n            yield return x;\\n        }\\n\\n        yield return root.val;\\n        \\n        foreach (var x in Inorder(root.right)) {\\n            yield return x;\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.iter = Inorder(root).GetEnumerator();\\n        this.hasNext = this.iter.MoveNext();\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int Next() {\\n        var ret = this.iter.Current;\\n        this.hasNext = this.iter.MoveNext();\\n        return ret;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return this.hasNext;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class BSTIterator {\\n    private bool hasNext;\\n    private IEnumerator<int> iter;\\n    \\n    private static IEnumerable<int> Inorder(TreeNode root) {\\n        if (root == null) {\\n            yield break;\\n        }\\n        \\n        foreach (var x in Inorder(root.left)) {\\n            yield return x;\\n        }\\n\\n        yield return root.val;\\n        \\n        foreach (var x in Inorder(root.right)) {\\n            yield return x;\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.iter = Inorder(root).GetEnumerator();\\n        this.hasNext = this.iter.MoveNext();\\n    }\\n    \\n    /** @return the next smallest number */\\n    public int Next() {\\n        var ret = this.iter.Current;\\n        this.hasNext = this.iter.MoveNext();\\n        return ret;\\n    }\\n    \\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return this.hasNext;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 272515,
                "title": "clear-javascript-answer-solved-3-ways",
                "content": "Edit: Just read this part \"next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree.\" my solution method 2 and 3 aren\\'t valid since it uses more than o(h) memory and does not run in o(1) time. Needs o(n) to set up initial... but I could aregue on average it takes O(n+n-1)/n ~ O(2) or some constant time.\\n\\nmethod 1) inspired by https://leetcode.com/problems/binary-search-tree-iterator/discuss/52694/JavaScript-solution\\nActually solves it in o(h) memory and o(1) average time\\n\\n```\\nvar BSTIterator = function(root) {\\n    this.root = root\\n    this.node = root\\n    this.list =[]\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    \\n    while (this.node!=null){\\n        this.list.push(this.node)\\n        this.node = this.node.left\\n    }\\n    let answernode = this.list.pop()\\n    this.node = answernode.right\\n    return answernode.val\\n  \\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.root === null){\\n        return false\\n    }\\n    else if (this.list.length===0 && this.node === null){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};    \\n```\\nmethod 2) uses push and pop by creating a stack that inputs max value first\\n\\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    \\n};\\nBSTIterator.prototype.next = function() {\\n    if (this.list!=undefined) {\\n        return this.list.pop()\\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        return this.list.pop()\\n    }\\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.right!=null){\\n            track=trackingnode.right\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.left!=null){\\n            track = trackingnode.left\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.list === undefined){\\n      \\n        return true\\n    }\\n    else if (this.list.length===0){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};     \\n```\\n\\n\\nmethod 3) uses list and indexing - built the index inorder \\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    this.count = -1\\n    this.length\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    // console.log(this.list)\\n    if (this.list!=undefined) {\\n        this.count++\\n        return this.list[this.count]  \\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        this.count++\\n        this.length = this.list.length\\n        return this.list[this.count]\\n\\n    }\\n    \\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.left!=null){\\n            track=trackingnode.left\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.right!=null){\\n            track = trackingnode.right\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.length === undefined){\\n        return true\\n    }\\n    else if (this.length-1<=this.count){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};      \\n```",
                "solutionTags": [],
                "code": "```\\nvar BSTIterator = function(root) {\\n    this.root = root\\n    this.node = root\\n    this.list =[]\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    \\n    while (this.node!=null){\\n        this.list.push(this.node)\\n        this.node = this.node.left\\n    }\\n    let answernode = this.list.pop()\\n    this.node = answernode.right\\n    return answernode.val\\n  \\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.root === null){\\n        return false\\n    }\\n    else if (this.list.length===0 && this.node === null){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};    \\n```\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    \\n};\\nBSTIterator.prototype.next = function() {\\n    if (this.list!=undefined) {\\n        return this.list.pop()\\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        return this.list.pop()\\n    }\\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.right!=null){\\n            track=trackingnode.right\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.left!=null){\\n            track = trackingnode.left\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.list === undefined){\\n      \\n        return true\\n    }\\n    else if (this.list.length===0){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};     \\n```\n```\\nvar BSTIterator = function(root) {\\n    this.node = root\\n    this.list \\n    this.count = -1\\n    this.length\\n    \\n};\\n\\n/**\\n * @return the next smallest number\\n * @return {number}\\n */\\nBSTIterator.prototype.next = function() {\\n    // console.log(this.list)\\n    if (this.list!=undefined) {\\n        this.count++\\n        return this.list[this.count]  \\n    }\\n    else {\\n        let trackingnode = this.node\\n        this.list = helper(trackingnode,[ ])\\n        this.count++\\n        this.length = this.list.length\\n        return this.list[this.count]\\n\\n    }\\n    \\n    function helper(trackingnode,list){\\n        var track \\n        if (trackingnode.left!=null){\\n            track=trackingnode.left\\n            helper(track,list)\\n        }\\n        list.push(trackingnode.val)\\n        if (trackingnode.right!=null){\\n            track = trackingnode.right\\n            helper(track,list)\\n        }\\n        return list\\n    }\\n};\\n\\n/**\\n * @return whether we have a next smallest number\\n * @return {boolean}\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    if (this.node ===null){\\n        return false\\n    }\\n    else if (this.length === undefined){\\n        return true\\n    }\\n    else if (this.length-1<=this.count){\\n        return false\\n    }\\n    else {\\n        return true\\n    }\\n};      \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52594,
                "title": "o-1-space-java-solution-using-morris-traverse",
                "content": "Re: [Morris traverse solution](/topic/8154/morris-traverse-solution)\\n\\nAs a follow-up in Lintcode, extra space usage O(1) is required which reminds me of Morris Traverse. For anyone who doesn't know Morris traverse, I really recommend you this magic traversal approach. And also you can try to get to know it by the code and comments in the following.  \\n\\n```java\\n    private TreeNode cur;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.cur = root;\\n    }\\n\\n    public boolean hasNext() {\\n        return cur != null;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = null;\\n        while (cur != null && node == null) {\\n            if (cur.left == null) {         // no left child, then go right (right child or back to root)\\n                node = cur;\\n                cur = cur.right;\\n            } else {\\n                TreeNode rmost = cur.left;\\n                while (rmost.right != null && rmost.right != cur) rmost = rmost.right;\\n                \\n                if (rmost.right == null) {  // 1.link rmost to root (cur) as footprint before go left\\n                    rmost.right = cur;\\n                    cur = cur.left;\\n                } else {                    // 2.We already get back to root by footprint, so restore then go right\\n                    node = cur;\\n                    rmost.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return node.val;\\n    }\\n```\\n\\nNote that the key of the algorithm is: **link right pointer of rightmost child of left subtree before go left**, so that when we complete left subtree we can follow the footprint back to root. Then restore rightmost's right pointer and then go for right subtree.\\n\\nTherefore, as the solution using Stack, the time complexity is O(1) amortized, but we only maintain current node rather than an entire stack.",
                "solutionTags": [],
                "code": "```java\\n    private TreeNode cur;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.cur = root;\\n    }\\n\\n    public boolean hasNext() {\\n        return cur != null;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = null;\\n        while (cur != null && node == null) {\\n            if (cur.left == null) {         // no left child, then go right (right child or back to root)\\n                node = cur;\\n                cur = cur.right;\\n            } else {\\n                TreeNode rmost = cur.left;\\n                while (rmost.right != null && rmost.right != cur) rmost = rmost.right;\\n                \\n                if (rmost.right == null) {  // 1.link rmost to root (cur) as footprint before go left\\n                    rmost.right = cur;\\n                    cur = cur.left;\\n                } else {                    // 2.We already get back to root by footprint, so restore then go right\\n                    node = cur;\\n                    rmost.right = null;\\n                    cur = cur.right;\\n                }\\n            }\\n        }\\n        return node.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52693,
                "title": "my-5ms-java-code-with-explanation-which-beats-95",
                "content": "Basically, my code is trying to modify the structure of the right subtree to make sure the \"next\" node to be the right son of current \"root\", when each time we call function next().\\n\\nLet's consider a tree now. \"root\" is the current node of the tree. \\nIf hasnext()==true, then there are 2 scenarios.(Please draw the tree to better understand.)\\n\\n(1) Its right son doesn't have a left son. This scenario is easy and we can simply return the right son's val and meanwhile set root to the right son.  \\n\\n(2) Its right son has left son. Let's use \"next\" to represent the right son. Then we should do \"next = next.left\" until it doesn't have a left son. Now the \"next.val\" is what we'd like to return. \\nHowever, in this case how can we keep going?\\n\\nMy idea is to modify the structure of the tree, in order to **make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\"(Repeat important things for 3 times)**. Basically, there are two things to consider. \\n\\nFirstly, since we want to move node \"next\", don't forget about the right subtree of it!!! So we need a node called \"parent\" to store the original parent of node \"next\" and then we can set parent.left = next.right.\\n\\nSecondly, we need to have a TreeNode called \"right\" to store the original right son of root. Then we can set root.right = next and next.right = right.\\n\\nThen we get a new right subtree and we just set root = next before we return next.val.\\n\\n    public class BSTIterator {\\n\\tTreeNode root = new TreeNode(0); \\n    public BSTIterator(TreeNode root) {\\n        this.root.right = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return (root.right!=null);\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode next = root.right;\\n        if (next.left==null) {\\n        \\troot = next;\\n        \\treturn next.val; \\n        }\\n        TreeNode right = root.right;\\n        TreeNode parent = root;\\n        while (next.left!=null) {\\n        \\tparent = next;\\n        \\tnext = next.left;\\n        }\\n        parent.left = next.right;\\n        root.right = next;\\n        next.right = right;\\n        root = next;\\n        return next.val;\\n    }\\n}",
                "solutionTags": [],
                "code": "Basically, my code is trying to modify the structure of the right subtree to make sure the \"next\" node to be the right son of current \"root\", when each time we call function next().\\n\\nLet's consider a tree now. \"root\" is the current node of the tree. \\nIf hasnext()==true, then there are 2 scenarios.(Please draw the tree to better understand.)\\n\\n(1) Its right son doesn't have a left son. This scenario is easy and we can simply return the right son's val and meanwhile set root to the right son.  \\n\\n(2) Its right son has left son. Let's use \"next\" to represent the right son. Then we should do \"next = next.left\" until it doesn't have a left son. Now the \"next.val\" is what we'd like to return. \\nHowever, in this case how can we keep going?\\n\\nMy idea is to modify the structure of the tree, in order to **make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\", make the \"next\" node to be the right son of current \"root\"(Repeat important things for 3 times)**. Basically, there are two things to consider. \\n\\nFirstly, since we want to move node \"next\", don't forget about the right subtree of it!!! So we need a node called \"parent\" to store the original parent of node \"next\" and then we can set parent.left = next.right.\\n\\nSecondly, we need to have a TreeNode called \"right\" to store the original right son of root. Then we can set root.right = next and next.right = right.\\n\\nThen we get a new right subtree and we just set root = next before we return next.val.\\n\\n    public class BSTIterator {\\n\\tTreeNode root = new TreeNode(0); \\n    public BSTIterator(TreeNode root) {\\n        this.root.right = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return (root.right!=null);\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        TreeNode next = root.right;\\n        if (next.left==null) {\\n        \\troot = next;\\n        \\treturn next.val; \\n        }\\n        TreeNode right = root.right;\\n        TreeNode parent = root;\\n        while (next.left!=null) {\\n        \\tparent = next;\\n        \\tnext = next.left;\\n        }\\n        parent.left = next.right;\\n        root.right = next;\\n        next.right = right;\\n        root = next;\\n        return next.val;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3911585,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass BSTIterator {\\n    private Stack<TreeNode> st = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode tempNode = st.pop();\\n        pushAll(tempNode.right);\\n        return tempNode.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !st.isEmpty();\\n    }\\n\\n    private void pushAll(TreeNode node) {\\n        while(node != null) {\\n            st.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n    private Stack<TreeNode> st = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode tempNode = st.pop();\\n        pushAll(tempNode.right);\\n        return tempNode.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !st.isEmpty();\\n    }\\n\\n    private void pushAll(TreeNode node) {\\n        while(node != null) {\\n            st.push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3863835,
                "title": "python-3-different-approaches-and-step-by-step-optimisation-faster-than-98-88-less-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we have to do the in-order tranversal and print the next node in in-order. We can do it in 3 different ways\\n1. Create an inorder array inside class constructor recursively and maintain an index to track current element \\n2. Maintain a stack of elements\\n3. [Most efficient] Scroll down and see this one.  \\n\\n# Approach 1 [Accepted] : create array in constructor\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> using recursion + storing in array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.arr = []\\n        self.curr_index = 0\\n        self.in_order(root)\\n        print(self.arr)\\n        \\n    def in_order(self, root):\\n        if not root:\\n            return\\n        self.in_order(root.left)\\n        self.arr.append(root.val)\\n        self.in_order(root.right)\\n\\n    def next(self) -> int:\\n        val = self.arr[self.curr_index]\\n        self.curr_index+=1\\n        return val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr_index<=len(self.arr)-1\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n## problem with above approach\\nWe are creating the whole in-order array in constructor, which is waste of computation and resource. We should do it on demand when methods are called. \\n\\n----\\n# Approach 2 [Accepted]: Use stack + on-the-go push and pop \\nHere instead of creating the whole array in constructor, we use stack to maintain the part we have not traversed yet. As `next` is called, we will keep `poping` from stack. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) -> using stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        node=self.stack.pop()\\n        r = node.right\\n        while r:\\n            self.stack.append(r)\\n            r = r.left\\n        return node.val\\n            \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.stack\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n## Problem/Drawback\\nUsing a stack make space complexity `O(n)`. it would be great if we can get rid of it. \\n\\n# Approach 3: Using Morris Inorder traversal\\nWe all know the [moris in-order traversal](https://www.youtube.com/watch?v=wGXB9OWhPTg&t=632s&ab_channel=TusharRoy-CodingMadeSimple), keep track of right unvisited node by making a tempraroy right pointer to current. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.curr = root\\n\\n    def next(self) -> int:\\n        while self.curr:\\n            if not self.curr.left:\\n                val = self.curr.val\\n                self.curr = self.curr.right\\n                return val\\n            else:\\n                pred = self.curr.left\\n                while pred.right and pred.right!=self.curr:\\n                    pred = pred.right\\n                if pred.right==self.curr:\\n                    pred.right=None\\n                    val = self.curr.val\\n                    self.curr= self.curr.right\\n                    return val\\n                else:\\n                    pred.right = self.curr\\n                    self.curr = self.curr.left\\n\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr is not None\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\\n![image.png](https://assets.leetcode.com/users/images/7b4c9dbe-576d-4e21-8e37-4a3705215399_1691169369.2091012.png)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.arr = []\\n        self.curr_index = 0\\n        self.in_order(root)\\n        print(self.arr)\\n        \\n    def in_order(self, root):\\n        if not root:\\n            return\\n        self.in_order(root.left)\\n        self.arr.append(root.val)\\n        self.in_order(root.right)\\n\\n    def next(self) -> int:\\n        val = self.arr[self.curr_index]\\n        self.curr_index+=1\\n        return val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr_index<=len(self.arr)-1\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator(object):\\n\\n    def __init__(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        \"\"\"\\n        self.stack = []\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n        \\n\\n    def next(self):\\n        \"\"\"\\n        :rtype: int\\n        \"\"\"\\n        node=self.stack.pop()\\n        r = node.right\\n        while r:\\n            self.stack.append(r)\\n            r = r.left\\n        return node.val\\n            \\n\\n    def hasNext(self):\\n        \"\"\"\\n        :rtype: bool\\n        \"\"\"\\n        return self.stack\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.curr = root\\n\\n    def next(self) -> int:\\n        while self.curr:\\n            if not self.curr.left:\\n                val = self.curr.val\\n                self.curr = self.curr.right\\n                return val\\n            else:\\n                pred = self.curr.left\\n                while pred.right and pred.right!=self.curr:\\n                    pred = pred.right\\n                if pred.right==self.curr:\\n                    pred.right=None\\n                    val = self.curr.val\\n                    self.curr= self.curr.right\\n                    return val\\n                else:\\n                    pred.right = self.curr\\n                    self.curr = self.curr.left\\n\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.curr is not None\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3559521,
                "title": "efficient-java-solution-with-explanation",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->All we need to do is to add the values of given binary tree to an ArrayList using DFS algorithm which is the main point of the solution.\\n\\n# Complexity\\n- Time complexity:*O(N)* is the time taken by constructor for storing the values of nodes to ArrayList  \\n    - `next()` would take *O(1)*\\n    - `hasNext()` would take *O(1)*\\n> \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(N)*  -  since we create a new ArrayList to contain the values of nodes\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list;\\n    int next = 0; //initial index;\\n\\n    public BSTIterator(TreeNode root) {\\n        this.list = new ArrayList<>();\\n        \\n        dfs(root); //collect all the values to the given list using in-order traversal of tree\\n    }\\n    \\n    public int next() {\\n        return  list.get(next++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return list.size() > next;\\n    }\\n   \\n    private void dfs(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```\\n# *Please upvote if you like the solution*",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    List<Integer> list;\\n    int next = 0; //initial index;\\n\\n    public BSTIterator(TreeNode root) {\\n        this.list = new ArrayList<>();\\n        \\n        dfs(root); //collect all the values to the given list using in-order traversal of tree\\n    }\\n    \\n    public int next() {\\n        return  list.get(next++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return list.size() > next;\\n    }\\n   \\n    private void dfs(TreeNode root) {\\n        if(root == null) {\\n            return;\\n        }\\n        dfs(root.left);\\n        list.add(root.val);\\n        dfs(root.right);\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435492,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i=0;\\n    //insert in inorder form so that we can iterate through array to give next\\n    vector<int>ans;\\n    TreeNode*temp;\\n    BSTIterator(TreeNode* root) {\\n        //this is function we will insert in inorder form\\n        insertInorder(root);\\n    }\\n    void insertInorder(TreeNode*root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left){\\n            insertInorder(root->left);\\n        }\\n\\n        //insert into vector\\n        ans.push_back(root->val);\\n\\n        //right call\\n        if(root->right){\\n            insertInorder(root->right);\\n        }\\n    }\\n    int next() {\\n        int temp=ans[i];\\n        i++;\\n        return temp;\\n    }\\n    \\n    bool hasNext() {\\n        if(i>=ans.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    int i=0;\\n    //insert in inorder form so that we can iterate through array to give next\\n    vector<int>ans;\\n    TreeNode*temp;\\n    BSTIterator(TreeNode* root) {\\n        //this is function we will insert in inorder form\\n        insertInorder(root);\\n    }\\n    void insertInorder(TreeNode*root){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(root->left){\\n            insertInorder(root->left);\\n        }\\n\\n        //insert into vector\\n        ans.push_back(root->val);\\n\\n        //right call\\n        if(root->right){\\n            insertInorder(root->right);\\n        }\\n    }\\n    int next() {\\n        int temp=ans[i];\\n        i++;\\n        return temp;\\n    }\\n    \\n    bool hasNext() {\\n        if(i>=ans.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340370,
                "title": "java-stack-o-h-space-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to traverse the BST using an inorder traversal algorithm. We can\\'t use recursion as we need to maintain state and report the current position of the iterator when the `next` method is called. So, we can implement the same algorithm using a Stack of our own. At any point of time, the iterator will always point to the node on the top of the stack. This will ensure that we use at max **O(h)** space on the stack.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ on average\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTIterator {\\n  Stack<TreeNode> stack;\\n\\n  public BSTIterator(TreeNode root) {\\n    stack = new Stack<>();\\n\\n    for (var a = root; a != null; a = a.left)\\n      stack.push(a);\\n  }\\n  \\n  public int next() {\\n    var node = stack.pop();\\n\\n    for (var a = node.right; a != null; a = a.left)\\n      stack.push(a);\\n\\n    return node.val;\\n  }\\n  \\n  public boolean hasNext() {\\n    return !stack.empty();  \\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\n  Stack<TreeNode> stack;\\n\\n  public BSTIterator(TreeNode root) {\\n    stack = new Stack<>();\\n\\n    for (var a = root; a != null; a = a.left)\\n      stack.push(a);\\n  }\\n  \\n  public int next() {\\n    var node = stack.pop();\\n\\n    for (var a = node.right; a != null; a = a.left)\\n      stack.push(a);\\n\\n    return node.val;\\n  }\\n  \\n  public boolean hasNext() {\\n    return !stack.empty();  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057260,
                "title": "c-two-solutions-o-n-o-h-space-complexity-dry-run",
                "content": "\\n\\n### Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(N)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass BSTIterator {\\n    vector<int> nodes;\\n    int curr = -1;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        nodes.push_back(root -> val);\\n        inorder(root->right);\\n    }\\n\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        if(curr == nodes.size() - 1) return -1;\\n        curr++;\\n        return nodes[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr == nodes.size() - 1) return false;\\n        return true;\\n    }\\n};\\n```\\n\\n### Complexity\\n- Time complexity: `O(N)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(H)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n### Dry Run\\n\\n***Example : 1***\\ninput : [\"BSTIterator\", \"next\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\", \"next\", \"hasNext\"]\\n[[[7, 3, 15, null, null, 9, 20]], [], [], [], [], [], [], [], [], []]\\n\\n1. `BSTIterator(root)`\\n    - ` back ->` [ 7, 3 ] `<- top`\\n2. `next()` \\n    - `back ->` [ 7 ] `<- top` `pop 3`, `return 3` then push all the element of `right of left` trees,\\n3. `next() `\\n    - `back ->` [ ] `<- top` `pop 7` & `return 7`\\n    - become `back ->` [ 15, 9 ] `<- top` `pop 7`\\n4. `hasNext()` return next element present or not i.e `is stack empty`\\n5. `next()`\\n    - `back ->` [ 15 ] `<- top` `pop 9` & `return 9`\\n6. `hasNext() `\\n7. `next()` \\n    - `back ->` [  ] `<- top` `pop 15` & `return 15`\\n    - become `back ->` [ 20 ] `<- top`\\n8. ` next()`\\n    - `back ->` [  ] `<- top` `pop 20` & `return 20`\\n9. `hasNext()` -> in the last stack is empty so return false;\\n\\n---\\n\\n### Code\\n```\\n\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root -> left;\\n        }\\n    }\\n    \\n    int next() {\\n       if(!st.empty()) {\\n           TreeNode *top = st.top(); st.pop();\\n           TreeNode *next = top -> right;\\n            while(next) {\\n                st.push(next);\\n                next = next -> left;\\n            }\\n           return top -> val;\\n       }\\n       return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!st.empty()) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\n    vector<int> nodes;\\n    int curr = -1;\\n    void inorder(TreeNode* root) {\\n        if(!root) return;\\n        inorder(root->left);\\n        nodes.push_back(root -> val);\\n        inorder(root->right);\\n    }\\n\\npublic:\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        if(curr == nodes.size() - 1) return -1;\\n        curr++;\\n        return nodes[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr == nodes.size() - 1) return false;\\n        return true;\\n    }\\n};\\n```\n```\\n\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> st;\\n\\n    BSTIterator(TreeNode* root) {\\n        while(root) {\\n            st.push(root);\\n            root = root -> left;\\n        }\\n    }\\n    \\n    int next() {\\n       if(!st.empty()) {\\n           TreeNode *top = st.top(); st.pop();\\n           TreeNode *next = top -> right;\\n            while(next) {\\n                st.push(next);\\n                next = next -> left;\\n            }\\n           return top -> val;\\n       }\\n       return -1;\\n    }\\n    \\n    bool hasNext() {\\n        if(!st.empty()) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975103,
                "title": "java-stack-simple-solution",
                "content": "Thid is my simple and intuitive solution on Java.\\n```\\nclass BSTIterator {\\n\\n    Stack<TreeNode> leftNodes = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        this.walkOnLeft(root);\\n    }\\n\\n    private void walkOnLeft(TreeNode root) {\\n        while (root != null) {\\n            leftNodes.push(root);\\n            root = root.left;\\n        }\\n    }\\n    \\n    public int next() {\\n        if (!hasNext()) {\\n            return -1;\\n        }\\n\\n        TreeNode currentNode = this.leftNodes.pop();\\n        this.walkOnLeft(currentNode.right);\\n        \\n        return currentNode.val;    \\n    }\\n    \\n    public boolean hasNext() {\\n        return !this.leftNodes.empty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n\\n    Stack<TreeNode> leftNodes = new Stack<>();\\n\\n    public BSTIterator(TreeNode root) {\\n        this.walkOnLeft(root);\\n    }\\n\\n    private void walkOnLeft(TreeNode root) {\\n        while (root != null) {\\n            leftNodes.push(root);\\n            root = root.left;\\n        }\\n    }\\n    \\n    public int next() {\\n        if (!hasNext()) {\\n            return -1;\\n        }\\n\\n        TreeNode currentNode = this.leftNodes.pop();\\n        this.walkOnLeft(currentNode.right);\\n        \\n        return currentNode.val;    \\n    }\\n    \\n    public boolean hasNext() {\\n        return !this.leftNodes.empty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940527,
                "title": "python-solution-faster-than-91-38-of-python-submissions-queue-approach",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n    def inOrderTraversal(self, root, queue):\\n        if (root is None):\\n            return\\n        self.inOrderTraversal(root.left, queue)\\n        queue.append(root.val)\\n        self.inOrderTraversal(root.right, queue)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.queue = []\\n        self.inOrderTraversal(root, self.queue)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n        \\n    def hasNext(self) -> bool:\\n        return self.queue != []\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n    def inOrderTraversal(self, root, queue):\\n        if (root is None):\\n            return\\n        self.inOrderTraversal(root.left, queue)\\n        queue.append(root.val)\\n        self.inOrderTraversal(root.right, queue)\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.queue = []\\n        self.inOrderTraversal(root, self.queue)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n        \\n    def hasNext(self) -> bool:\\n        return self.queue != []\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821833,
                "title": "python-solution-using-flattned-bst-to-linked-list-using-morris-treversal-o-1-space-o-1-avg-time",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, rt: Optional[TreeNode]):\\n        root=rt\\n        while root:\\n            if root.left:\\n                t=TreeNode(root.val)\\n                t.right=root.right\\n                x=root.left\\n                while x.right:\\n                    x=x.right\\n                x.right=t\\n                root.right=root.left.right\\n                root.val=root.left.val\\n                root.left=root.left.left\\n            else:\\n                root=root.right\\n        self.root=rt\\n    def next(self) -> int:\\n        t=self.root.val\\n        self.root=self.root.right\\n        return t\\n    def hasNext(self) -> bool:\\n        if self.root:\\n            return True\\n        return False",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, rt: Optional[TreeNode]):\\n        root=rt\\n        while root:\\n            if root.left:\\n                t=TreeNode(root.val)\\n                t.right=root.right\\n                x=root.left\\n                while x.right:\\n                    x=x.right\\n                x.right=t\\n                root.right=root.left.right\\n                root.val=root.left.val\\n                root.left=root.left.left\\n            else:\\n                root=root.right\\n        self.root=rt\\n    def next(self) -> int:\\n        t=self.root.val\\n        self.root=self.root.right\\n        return t\\n    def hasNext(self) -> bool:\\n        if self.root:\\n            return True\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 2753279,
                "title": "c-stack-recursive-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass BSTIterator {\\npublic:\\n\\n    stack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        formlft(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* root=s.top();\\n        s.pop();\\n        formlft(root->right);\\n        return root->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n    void formlft(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n \\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass BSTIterator {\\npublic:\\n\\n    stack<TreeNode*>s;\\n    BSTIterator(TreeNode* root) {\\n        formlft(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* root=s.top();\\n        s.pop();\\n        formlft(root->right);\\n        return root->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n    void formlft(TreeNode* root){\\n        while(root){\\n            s.push(root);\\n            root=root->left;\\n        }\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n \\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2682392,
                "title": "c-easy-to-understand-use-of-stack-stl",
                "content": "1. We use Stack for the bst iterator and first store all left nodes first.\\n\\n2.  In function, int next() we simply need to get the top element of stack and pop it from stack , also if it\\'s right exists we push all the left of it\\'s right using pushall() function.\\n\\n3.In function hasNext() , we check if the stack is not empty then there exist next element otherwise don\\'t.\\n\\nHere\\'s the code.\\n\\n```\\n stack <TreeNode* > st;\\n    BSTIterator(TreeNode* root) {\\n        pushall(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* tp=st.top();\\n        st.pop();\\n        pushall(tp->right);\\n        return tp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushall(TreeNode* root){\\n        for(;root!=NULL;st.push(root) , root=root->left);\\n    }\\n```\\n\\nPlease upvote if found helpful !",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n stack <TreeNode* > st;\\n    BSTIterator(TreeNode* root) {\\n        pushall(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* tp=st.top();\\n        st.pop();\\n        pushall(tp->right);\\n        return tp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n    void pushall(TreeNode* root){\\n        for(;root!=NULL;st.push(root) , root=root->left);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2663139,
                "title": "c-highly-commented-code-free-meme",
                "content": "For complexity analysis and other stuff, **please** go [here](https://garmadon.notion.site/Binary-Search-Tree-Iterator-dccea6fb7ece425383963612e07b5964).\\n\\n```\\n//An iterator that iterates over the inorder traversal of the BST\\nclass BSTIterator {\\n\\n//Following principles of OOP lol\\nprivate: \\n    stack<TreeNode*> nodeStack;\\n\\npublic:\\n\\n    //Creates the iterator\\n    BSTIterator(TreeNode* root) {\\n        fillStack(root);\\n    }\\n    \\n    //Returns the next element in inorder traversal\\n    int next() {\\n        TreeNode* nextNode = nodeStack.top();\\n        nodeStack.pop();\\n\\n        fillStack(nextNode->right);\\n\\n        return nextNode->val;\\n    }\\n    \\n    //Returns true if more elements are present in the BST\\n    bool hasNext() {\\n        return !nodeStack.empty();\\n    }\\n\\n    //Helper function to fill the stack\\n    void fillStack(TreeNode* root)\\n    {\\n        TreeNode* currNode = root;\\n\\n        while(currNode)\\n        {\\n            nodeStack.push(currNode);\\n            currNode = currNode->left;\\n        }\\n    }\\n};\\n```\\n\\nFREE MEME\\n![image](https://assets.leetcode.com/users/images/478dcee5-cb00-499a-af9e-839330acfab8_1664954202.8649745.png)\\n\\n*Don\\'t you illiterate people forget to upvote!*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//An iterator that iterates over the inorder traversal of the BST\\nclass BSTIterator {\\n\\n//Following principles of OOP lol\\nprivate: \\n    stack<TreeNode*> nodeStack;\\n\\npublic:\\n\\n    //Creates the iterator\\n    BSTIterator(TreeNode* root) {\\n        fillStack(root);\\n    }\\n    \\n    //Returns the next element in inorder traversal\\n    int next() {\\n        TreeNode* nextNode = nodeStack.top();\\n        nodeStack.pop();\\n\\n        fillStack(nextNode->right);\\n\\n        return nextNode->val;\\n    }\\n    \\n    //Returns true if more elements are present in the BST\\n    bool hasNext() {\\n        return !nodeStack.empty();\\n    }\\n\\n    //Helper function to fill the stack\\n    void fillStack(TreeNode* root)\\n    {\\n        TreeNode* currNode = root;\\n\\n        while(currNode)\\n        {\\n            nodeStack.push(currNode);\\n            currNode = currNode->left;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2229059,
                "title": "c-stack-solution-t-c-o-n-s-c-o-1",
                "content": "# C++ Stack Solution\\n1. It is like inorder traversal just we are using stack in place of recursion call.\\n2. We are pushing left->left->left in stack\\n3. For hasNext we are checking if stack is empty or not\\n4. next will be top element of stack, we are popping it and then call left->left->left of st.top()->right if exist.\\n\\n***Please Upvote if you like it***\\n\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode *>st;\\n    \\n    void pushAll(TreeNode *cur){\\n        TreeNode *node = cur;\\n        while(node){\\n            st.push(node);\\n            node=node->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode *ans = st.top();\\n        st.pop();\\n        if(ans->right){\\n            pushAll(ans->right);\\n        }\\n        return ans->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode *>st;\\n    \\n    void pushAll(TreeNode *cur){\\n        TreeNode *node = cur;\\n        while(node){\\n            st.push(node);\\n            node=node->left;\\n        }\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n    }\\n    \\n    int next() {\\n        TreeNode *ans = st.top();\\n        st.pop();\\n        if(ans->right){\\n            pushAll(ans->right);\\n        }\\n        return ans->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2216739,
                "title": "simple-python",
                "content": "Simple Iterator Inorder Traversal -\\n* Maintain a stack and initially push all the elements left to the root inside it.\\n* Whenever next() is called, pop the element from that stack and return,\\n* After that push all the elements, right to the popped element (if any) inside the stack.\\n* hasnext() can easily be implemented by checking size of stack.\\n\\n```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.stack = []\\n        self.push(root)\\n    \\n    def push(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        self.push(res.right)\\n        return res.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)\\n```\\n\\nComment if you have any doubt.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root = root\\n        self.stack = []\\n        self.push(root)\\n    \\n    def push(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        self.push(res.right)\\n        return res.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967706,
                "title": "c-sc-o-h-tc-o-1",
                "content": "```\\nclass BSTIterator {\\n    private: stack<TreeNode *> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        helper(root);\\n    }\\n\\t// if the stack has elements, obvioulsy hasNext is true else false\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n\\t/** when the elements in the stack are there, while poping them out, you get them in the in-order \\n\\tfashion, but our helper function is adding only the left nodes, so we take the top element, \\n\\tpop it out and then if it has a right node, we call the helper for it \\n\\tand then we return our top node of the stack, which we poped out**/\\n    int next() {\\n        TreeNode *temp = st.top();\\n        st.pop();\\n        helper(temp->right);\\n        return temp->val;\\n    }\\n\\nprivate:\\n    void helper(TreeNode *node) {\\n        while(node != NULL){\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n/** if its hard to understand, just take a pen and paper and dry run this code with a testcase\\ni\\'m pretty sure you\\'ll understand**/\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\n    private: stack<TreeNode *> st;\\npublic:\\n    BSTIterator(TreeNode *root) {\\n        helper(root);\\n    }\\n\\t// if the stack has elements, obvioulsy hasNext is true else false\\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n\\t/** when the elements in the stack are there, while poping them out, you get them in the in-order \\n\\tfashion, but our helper function is adding only the left nodes, so we take the top element, \\n\\tpop it out and then if it has a right node, we call the helper for it \\n\\tand then we return our top node of the stack, which we poped out**/\\n    int next() {\\n        TreeNode *temp = st.top();\\n        st.pop();\\n        helper(temp->right);\\n        return temp->val;\\n    }\\n\\nprivate:\\n    void helper(TreeNode *node) {\\n        while(node != NULL){\\n            st.push(node);\\n            node = node->left;\\n        }\\n    }\\n};\\n/** if its hard to understand, just take a pen and paper and dry run this code with a testcase\\ni\\'m pretty sure you\\'ll understand**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967392,
                "title": "c-efficient-optimal-o-h",
                "content": "***DO UPVOTE IF THIS HELPS!!!***\\n\\n\\tstack<TreeNode*>st;  //stack -- O(h) Memory\\n\\n\\tvoid inorder(TreeNode* root){  //partial inorder i.e. pushing all left elements into stack for a root\\n   \\n\\t   if(root==NULL){\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tst.push(root);\\n\\n\\t\\twhile(root->left!=NULL){  //pushing all left elements\\n\\t\\t\\tst.push(root->left);\\n\\t\\t\\troot=root->left;\\n\\t\\t}\\n\\t}\\n\\n\\tBSTIterator(TreeNode* root) {  //calling inorder\\n\\t\\tinorder(root);\\n\\t}\\n\\n\\tint next() {\\n    \\n\\t\\tTreeNode* top=st.top();  //top stores the topmost index \\n\\t\\tst.pop();\\n\\n\\t\\tif(top->right!=NULL){  //check if top has an element to it\\'s right .. if it has, then call inorder\\n\\t\\t\\tinorder(top->right);  //inorder will push all the left elements of top\\'s right node\\n\\t\\t}\\n    \\n\\t\\treturn top->val;  //return top-> value afterwards\\n\\t}\\n\\n\\tbool hasNext() {\\n\\t\\treturn !st.empty();  //return if it is empty or not in boolean\\n\\t}",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "***DO UPVOTE IF THIS HELPS!!!***\\n\\n\\tstack<TreeNode*>st;  //stack -- O(h) Memory\\n\\n\\tvoid inorder(TreeNode* root){  //partial inorder i.e. pushing all left elements into stack for a root\\n   \\n\\t   if(root==NULL){\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tst.push(root);\\n\\n\\t\\twhile(root->left!=NULL){  //pushing all left elements\\n\\t\\t\\tst.push(root->left);\\n\\t\\t\\troot=root->left;\\n\\t\\t}\\n\\t}\\n\\n\\tBSTIterator(TreeNode* root) {  //calling inorder\\n\\t\\tinorder(root);\\n\\t}\\n\\n\\tint next() {\\n    \\n\\t\\tTreeNode* top=st.top();  //top stores the topmost index \\n\\t\\tst.pop();\\n\\n\\t\\tif(top->right!=NULL){  //check if top has an element to it\\'s right .. if it has, then call inorder\\n\\t\\t\\tinorder(top->right);  //inorder will push all the left elements of top\\'s right node\\n\\t\\t}\\n    \\n\\t\\treturn top->val;  //return top-> value afterwards\\n\\t}\\n\\n\\tbool hasNext() {\\n\\t\\treturn !st.empty();  //return if it is empty or not in boolean\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1966077,
                "title": "c-in-order-traversal-o-1-time-o-h-space",
                "content": "Here we perform simple Iterative Inorder traversal. As we initialize our TreeNode, we push all  the left nodes to a stack. And one by one pop as the next() method is called.\\n```\\nclass BSTIterator {\\nprivate:\\n    TreeNode* pt;\\n    stack<TreeNode*> s;\\n\\t\\n    void pushStack(TreeNode *node){\\n        while(node!=nullptr){\\n            s.push(node);\\n            node=node->left;\\n        }\\n    }\\n\\t// pushed the left subtree to the stack\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pt=root;\\n        pushStack(pt);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=s.top();\\n        s.pop();\\n        pushStack(temp->right);\\n        return temp->val;\\n    }\\n\\t\\n    // We pop the top node return its value \\n\\t// then we push its right subtree to stack to continue inorder traversal\\n\\t\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n\\t// if stack is empty then we have already traversed out tree\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    TreeNode* pt;\\n    stack<TreeNode*> s;\\n\\t\\n    void pushStack(TreeNode *node){\\n        while(node!=nullptr){\\n            s.push(node);\\n            node=node->left;\\n        }\\n    }\\n\\t// pushed the left subtree to the stack\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        pt=root;\\n        pushStack(pt);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=s.top();\\n        s.pop();\\n        pushStack(temp->right);\\n        return temp->val;\\n    }\\n\\t\\n    // We pop the top node return its value \\n\\t// then we push its right subtree to stack to continue inorder traversal\\n\\t\\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n\\t// if stack is empty then we have already traversed out tree\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965391,
                "title": "clean-java-solution-stack",
                "content": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode> stack; \\n\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack() ; \\n        pushLeftArmToStack(root) ;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = stack.pop() ;\\n        pushLeftArmToStack(node.right) ;\\n        return node.val; \\n    }\\n    \\n    public boolean hasNext() {\\n        return !stack.isEmpty() ;\\n    }\\n    \\n    private void pushLeftArmToStack(TreeNode node) {\\n        while(node != null) {\\n            stack.push(node) ;\\n            node = node.left; \\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode> stack; \\n\\n    public BSTIterator(TreeNode root) {\\n        stack = new Stack() ; \\n        pushLeftArmToStack(root) ;\\n    }\\n    \\n    public int next() {\\n        TreeNode node = stack.pop() ;\\n        pushLeftArmToStack(node.right) ;\\n        return node.val; \\n    }\\n    \\n    public boolean hasNext() {\\n        return !stack.isEmpty() ;\\n    }\\n    \\n    private void pushLeftArmToStack(TreeNode node) {\\n        while(node != null) {\\n            stack.push(node) ;\\n            node = node.left; \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965173,
                "title": "easy-to-understand-next-hasnext-o-1-time-o-h-space-average",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        \\n\\t\\t#iterates until it finds the node with the lowest value, takes O(h) time and space\\n        current = root\\n        while current:\\n            self.stack.append(current)\\n            current = current.left\\n          \\n    def next(self) -> int:\\n\\t\\t#gets element with lowest value\\n        lowest = self.stack.pop()\\n        \\n\\t\\t#sucessor of a node A = node with value greater than node A.val, but lower than everyone else\\'s value in the tree.\\n\\t\\t#finds \"lowest\" sucessor if it is not in the stack already\\n        suc = None\\n        if lowest.right:\\n            suc = lowest.right\\n        while suc:\\n            self.stack.append(suc)\\n            suc = suc.left\\n\\n        return lowest.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        \\n\\t\\t#iterates until it finds the node with the lowest value, takes O(h) time and space\\n        current = root\\n        while current:\\n            self.stack.append(current)\\n            current = current.left\\n          \\n    def next(self) -> int:\\n\\t\\t#gets element with lowest value\\n        lowest = self.stack.pop()\\n        \\n\\t\\t#sucessor of a node A = node with value greater than node A.val, but lower than everyone else\\'s value in the tree.\\n\\t\\t#finds \"lowest\" sucessor if it is not in the stack already\\n        suc = None\\n        if lowest.right:\\n            suc = lowest.right\\n        while suc:\\n            self.stack.append(suc)\\n            suc = suc.left\\n\\n        return lowest.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack) > 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895239,
                "title": "python-stack",
                "content": "```\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        self.__populateLeftSubtree(root)\\n\\n        \\n    def next(self) -> int:\\n        next = self.stack.pop()\\n        \\n        self.__populateLeftSubtree(next.right)\\n        return next.val\\n\\n        \\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n    \\n    def __populateLeftSubtree(self, node) -> None:            \\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator:\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        self.__populateLeftSubtree(root)\\n\\n        \\n    def next(self) -> int:\\n        next = self.stack.pop()\\n        \\n        self.__populateLeftSubtree(next.right)\\n        return next.val\\n\\n        \\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n    \\n    def __populateLeftSubtree(self, node) -> None:            \\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n",
                "codeTag": "Java"
            },
            {
                "id": 1612075,
                "title": "c-t-o-1-s-o-n-storing-in-order-traversal-in-vector",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator final {\\npublic:\\n    explicit BSTIterator() noexcept = default;\\n    explicit BSTIterator(const BSTIterator&) noexcept = default;\\n\\n    BSTIterator(const TreeNode* root) {\\n        setInOrderTraversal(root);\\n    }\\n\\n    int next() noexcept { return inOrderTraversal_[iterator_++]; }\\n    bool hasNext() const noexcept { return iterator_ < inOrderTraversal_.size(); }\\n\\nprivate:\\n    std::vector<int> inOrderTraversal_;\\n    int iterator_ = 0;\\n\\n    void setInOrderTraversal(const TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n\\n        setInOrderTraversal(root->left);\\n        inOrderTraversal_.push_back(root->val);\\n        setInOrderTraversal(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator final {\\npublic:\\n    explicit BSTIterator() noexcept = default;\\n    explicit BSTIterator(const BSTIterator&) noexcept = default;\\n\\n    BSTIterator(const TreeNode* root) {\\n        setInOrderTraversal(root);\\n    }\\n\\n    int next() noexcept { return inOrderTraversal_[iterator_++]; }\\n    bool hasNext() const noexcept { return iterator_ < inOrderTraversal_.size(); }\\n\\nprivate:\\n    std::vector<int> inOrderTraversal_;\\n    int iterator_ = 0;\\n\\n    void setInOrderTraversal(const TreeNode* root) {\\n        if (root == nullptr) {\\n            return;\\n        }\\n\\n        setInOrderTraversal(root->left);\\n        inOrderTraversal_.push_back(root->val);\\n        setInOrderTraversal(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1595906,
                "title": "simple-inorder-tree-iterator-using-stack",
                "content": "```\\n    public class BSTIterator\\n    {\\n        Stack<TreeNode> st;\\n        public BSTIterator(TreeNode root)\\n        {\\n            st = new Stack<TreeNode>();\\n            PopulateStack(root);\\n        }\\n\\n        private void PopulateStack(TreeNode root)\\n        {\\n            while (root != null)\\n            {\\n                st.Push(root);\\n                root = root.left;\\n            }\\n        }\\n\\n        public int Next()\\n        {\\n            var root = st.Pop();\\n            var val = root.val;\\n\\n            root = root.right;\\n            PopulateStack(root);\\n            return val;\\n        }\\n\\n        public bool HasNext()\\n        {\\n            return st.Count() > 0;\\n        }\\n    }",
                "solutionTags": [
                    "C#",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\n    public class BSTIterator\\n    {\\n        Stack<TreeNode> st;\\n        public BSTIterator(TreeNode root)\\n        {\\n            st = new Stack<TreeNode>();\\n            PopulateStack(root);\\n        }\\n\\n        private void PopulateStack(TreeNode root)\\n        {\\n            while (root != null)\\n            {\\n                st.Push(root);\\n                root = root.left;\\n            }\\n        }\\n\\n        public int Next()\\n        {\\n            var root = st.Pop();\\n            var val = root.val;\\n\\n            root = root.right;\\n            PopulateStack(root);\\n            return val;\\n        }\\n\\n        public bool HasNext()\\n        {\\n            return st.Count() > 0;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1390883,
                "title": "using-python-generator-time-o-1-space-o-1",
                "content": "We can use **python Generators** to achieve **O(1)** time complexity and **O(1)** space complexity for *next()* & *hasNext()* in best case. In worst case time complexity -> **O(1)** and space complexity will be **O(p)** where **p** is **min(Times *hasNext()* called, Total num of Nodes)**\\n\\nThis is possible because python ***Generators*** have capability to **pause** function execution  untill ***next()*** call is made. This means there is no need to precalculate and store stuff anywhere! Everything is calculated at runtime in **O(1)** time & space complexity.\\n\\nThe only catch here is that it doesn\\'t have ***hasNext()*** functionality inbuilt. So we have to create a ***deque*** to store intermediate result everytime **hasNext()** function is called.\\n\\n# Steps:\\n1.  Build a *generator function *to traverse the ***BST*** in ***inorder*** manner.\\n2.  **In next() function**: Check if **backupQueue**(which we created to store intermediate results) has any elements?\\n\\t* If backupQueue is emply then simple fetch next output from the generator.\\n\\t* Else take the leftmost element form the backupQueue.\\n3. **in hasNext() function**: Simply try to fetch the **next** *generator output* and store it in the **queue** (Because it will be required later in **next() function**) & return **True**.  If there is not next element remaining, generator will throw an **exception**.  In that case return **False**.\\n\\nIt goes something like this,\\n\\n```python\\nfrom collections import deque\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        def bstTraverser(root):\\n            if root:\\n                yield from bstTraverser(root.left)\\n                yield root.val\\n                yield from bstTraverser(root.right)\\n                \\n        self.backupList = deque()\\n        self.gen_obj = bstTraverser(root)    \\n                \\n    def next(self) -> int:\\n        if self.backupList:\\n            return self.backupList.popleft()\\n        return next(self.gen_obj)\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.backupList.append(next(self.gen_obj))\\n            return True\\n        except Exception:\\n            return False\\n\\n```\\n\\nThis is not a fast solution. But it\\'s a fun one!",
                "solutionTags": [],
                "code": "```python\\nfrom collections import deque\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        def bstTraverser(root):\\n            if root:\\n                yield from bstTraverser(root.left)\\n                yield root.val\\n                yield from bstTraverser(root.right)\\n                \\n        self.backupList = deque()\\n        self.gen_obj = bstTraverser(root)    \\n                \\n    def next(self) -> int:\\n        if self.backupList:\\n            return self.backupList.popleft()\\n        return next(self.gen_obj)\\n    \\n    def hasNext(self) -> bool:\\n        try:\\n            self.backupList.append(next(self.gen_obj))\\n            return True\\n        except Exception:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364342,
                "title": "golang-stack-time-o-n-space-o-height",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype BSTIterator struct {\\n    st []*TreeNode\\n}\\n\\n\\nfunc Constructor(root *TreeNode) BSTIterator {\\n    iterator := BSTIterator{}\\n    for root != nil {\\n        iterator.st = append(iterator.st, root)\\n        root = root.Left\\n    }\\n    return iterator\\n}\\n\\n\\nfunc (this *BSTIterator) Next() int {\\n    n := len(this.st)\\n    cur := this.st[n-1]\\n    this.st = this.st[:n-1]\\n    res := cur.Val\\n    cur = cur.Right\\n    for cur != nil {\\n        this.st = append(this.st, cur)\\n        cur = cur.Left\\n    }\\n    return res\\n}\\n\\n\\nfunc (this *BSTIterator) HasNext() bool {\\n    return len(this.st) > 0\\n}\\n\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Next();\\n * param_2 := obj.HasNext();\\n */\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\ntype BSTIterator struct {\\n    st []*TreeNode\\n}\\n\\n\\nfunc Constructor(root *TreeNode) BSTIterator {\\n    iterator := BSTIterator{}\\n    for root != nil {\\n        iterator.st = append(iterator.st, root)\\n        root = root.Left\\n    }\\n    return iterator\\n}\\n\\n\\nfunc (this *BSTIterator) Next() int {\\n    n := len(this.st)\\n    cur := this.st[n-1]\\n    this.st = this.st[:n-1]\\n    res := cur.Val\\n    cur = cur.Right\\n    for cur != nil {\\n        this.st = append(this.st, cur)\\n        cur = cur.Left\\n    }\\n    return res\\n}\\n\\n\\nfunc (this *BSTIterator) HasNext() bool {\\n    return len(this.st) > 0\\n}\\n\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * obj := Constructor(root);\\n * param_1 := obj.Next();\\n * param_2 := obj.HasNext();\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351190,
                "title": "java-easy-approach-with-explanation-o-n-stack",
                "content": "```\\nclass BSTIterator\\n{//iterative inorder traversal (inorder of BST is sorted)\\n    ArrayDeque<TreeNode> stack;//Faster than stack \\n    \\n    private void pushAll(TreeNode temp){\\n        //pushing the left nodes on the stack until we reach the null node \\n        while(temp != null){\\n            stack.addLast(temp);//pushing to the stack \\n            temp= temp.left;//moving the left subtree\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {//parameterised constructor \\n        stack= new ArrayDeque<>();//intializing stack \\n        pushAll(root);\\n    }\\n    \\n    public int next(){\\n        TreeNode pop= stack.removeLast();//smallest element till now \\n        pushAll(pop.right);//pushing all the right node in inorder fashion\\n        return pop.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!stack.isEmpty())//if stack is empty there is no element in the stack, otherwise there is atleast one \\n            return true;\\n        return false;\\n    }\\n}//Please do Upvote, it helps alot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator\\n{//iterative inorder traversal (inorder of BST is sorted)\\n    ArrayDeque<TreeNode> stack;//Faster than stack \\n    \\n    private void pushAll(TreeNode temp){\\n        //pushing the left nodes on the stack until we reach the null node \\n        while(temp != null){\\n            stack.addLast(temp);//pushing to the stack \\n            temp= temp.left;//moving the left subtree\\n        }\\n    }\\n    \\n    public BSTIterator(TreeNode root) {//parameterised constructor \\n        stack= new ArrayDeque<>();//intializing stack \\n        pushAll(root);\\n    }\\n    \\n    public int next(){\\n        TreeNode pop= stack.removeLast();//smallest element till now \\n        pushAll(pop.right);//pushing all the right node in inorder fashion\\n        return pop.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!stack.isEmpty())//if stack is empty there is no element in the stack, otherwise there is atleast one \\n            return true;\\n        return false;\\n    }\\n}//Please do Upvote, it helps alot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342658,
                "title": "python-yield-from",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(root):\\n            if root:\\n                yield from inorder(root.left)\\n                yield root.val\\n                yield from inorder(root.right)\\n        self.iterable = inorder(root)\\n        self._next = next(self.iterable, None)\\n\\n    def next(self) -> int:\\n        _next = self._next\\n        self._next = next(self.iterable, None)\\n        return _next\\n\\n    def hasNext(self) -> bool:\\n        return self._next is not None\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        def inorder(root):\\n            if root:\\n                yield from inorder(root.left)\\n                yield root.val\\n                yield from inorder(root.right)\\n        self.iterable = inorder(root)\\n        self._next = next(self.iterable, None)\\n\\n    def next(self) -> int:\\n        _next = self._next\\n        self._next = next(self.iterable, None)\\n        return _next\\n\\n    def hasNext(self) -> bool:\\n        return self._next is not None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152226,
                "title": "c-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    private:\\n    stack<TreeNode*> st; // this stack will always hold atmost height of the tree\\n    void populateLeftSide(TreeNode* root){ // populate left subtree of the root\\n        while(root){\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        st = stack<TreeNode*>();\\n        populateLeftSide(root); // init with left subtree of the root\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top(); st.pop(); // top element will be returned\\n        if(top->right){ // if there exists a right subtree of the top element, populate in the stack\\n            populateLeftSide(top->right);\\n        }\\n        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty(); // simply return if the stack is non-empty\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\n    private:\\n    stack<TreeNode*> st; // this stack will always hold atmost height of the tree\\n    void populateLeftSide(TreeNode* root){ // populate left subtree of the root\\n        while(root){\\n            st.push(root);\\n            root = root->left;\\n        }\\n    }\\n    \\npublic:\\n    BSTIterator(TreeNode* root) {\\n        st = stack<TreeNode*>();\\n        populateLeftSide(root); // init with left subtree of the root\\n    }\\n    \\n    int next() {\\n        TreeNode* top = st.top(); st.pop(); // top element will be returned\\n        if(top->right){ // if there exists a right subtree of the top element, populate in the stack\\n            populateLeftSide(top->right);\\n        }\\n        \\n        return top->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty(); // simply return if the stack is non-empty\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047309,
                "title": "c-using-stack",
                "content": "\\n\\n    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode* root) {\\n\\t\\t\\tTreeNode* cur = root;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n        }\\n    \\n        int next() {\\n\\t\\t\\tTreeNode* cur = stk.top();\\n\\t\\t\\tint res = cur->val;\\n\\t\\t\\tstk.pop();\\n\\n\\t\\t\\tcur = cur->right;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n    \\n\\t\\tbool hasNext() {\\n\\t\\t\\treturn !stk.empty();\\n\\t\\t}\\n    \\n\\tprivate:\\n\\t\\t\\tstd::stack<TreeNode*> stk;\\n\\t};",
                "solutionTags": [],
                "code": "\\n\\n    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode* root) {\\n\\t\\t\\tTreeNode* cur = root;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n        }\\n    \\n        int next() {\\n\\t\\t\\tTreeNode* cur = stk.top();\\n\\t\\t\\tint res = cur->val;\\n\\t\\t\\tstk.pop();\\n\\n\\t\\t\\tcur = cur->right;\\n\\t\\t\\twhile(cur) {\\n\\t\\t\\t\\tstk.push(cur);\\n\\t\\t\\t\\tcur = cur->left;\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n    \\n\\t\\tbool hasNext() {\\n\\t\\t\\treturn !stk.empty();\\n\\t\\t}\\n    \\n\\tprivate:\\n\\t\\t\\tstd::stack<TreeNode*> stk;\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 979316,
                "title": "c-queue-with-simple-explanation",
                "content": "**Stats:**\\nRuntime: 140 ms, faster than 94.63% of C# online submissions for Binary Search Tree Iterator.\\nMemory Usage: 38.2 MB, less than 71.99% of C# online submissions for Binary Search Tree Iterator.\\n**Algo**\\n* This builds off knowledge of inorder traversal. Since that prev implementation builds on a list - it\\'s easy to see that this one is a similar data structure except that instead of list we use queue (FIFO)\\n* In the constructur, we use the same traversal logic but with a queue\\n* That makes the job of Next and HasNext trivial as we\\'re just going down the queue \\n\\n```\\npublic class BSTIterator {\\n\\n    Queue<int> q = new Queue<int>();\\n    public BSTIterator(TreeNode root) {\\n        Traverse(root, q);\\n    }\\n    \\n    private void Traverse(TreeNode root, Queue<int> q){\\n\\n        if(root!=null){\\n            Traverse(root.left, q);\\n            q.Enqueue(root.val);\\n            Traverse(root.right, q);\\n        }\\n    }\\n    \\n    public int Next() {\\n        \\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n\\n        return q.Any();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n\\n    Queue<int> q = new Queue<int>();\\n    public BSTIterator(TreeNode root) {\\n        Traverse(root, q);\\n    }\\n    \\n    private void Traverse(TreeNode root, Queue<int> q){\\n\\n        if(root!=null){\\n            Traverse(root.left, q);\\n            q.Enqueue(root.val);\\n            Traverse(root.right, q);\\n        }\\n    }\\n    \\n    public int Next() {\\n        \\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n\\n        return q.Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 966733,
                "title": "python-linkedlist-solution-descriptive-code-92-runtime",
                "content": "Code is very readable. If you have any questions feel free.\\n**Idea:** In-order traversal the tree and create a Linked List.\\nThen simply return the values in ascending order on the linked list\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# BSTIterator =========\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.tree: TreeNode = root\\n        self.linked_list = LinkedList.init_from_binarytree(root)\\n        \\n\\n    def next(self) -> int:\\n        self.linked_list.head = self.linked_list.head.next\\n        return self.linked_list.head.val\\n\\n    def hasNext(self) -> bool:\\n        return not self.linked_list.head.next == None\\n    \\n# Linked List Node  =========\\nclass LinkedListNode:\\n    def __init__(self, val, _next = None):\\n        self.val = val\\n        self.next = _next\\n    \\n# Linked List =========\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = LinkedListNode(\"dummy\")\\n        self.tail = self.head\\n        \\n    def add(self, val):\\n        self.tail.next = LinkedListNode(val)\\n        self.tail = self.tail.next\\n        \\n    @staticmethod\\n    def init_from_binarytree(tree_root):\\n        linked_list = LinkedList()\\n        \\n        def in_order_and_set_list(root):\\n            if not root:\\n                return None\\n            \\n            in_order_and_set_list(root.left)\\n            linked_list.add(root.val)\\n            in_order_and_set_list(root.right)\\n        \\n        in_order_and_set_list(tree_root)\\n        return linked_list\\n            \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\n# BSTIterator =========\\nclass BSTIterator:\\n    def __init__(self, root: TreeNode):\\n        self.tree: TreeNode = root\\n        self.linked_list = LinkedList.init_from_binarytree(root)\\n        \\n\\n    def next(self) -> int:\\n        self.linked_list.head = self.linked_list.head.next\\n        return self.linked_list.head.val\\n\\n    def hasNext(self) -> bool:\\n        return not self.linked_list.head.next == None\\n    \\n# Linked List Node  =========\\nclass LinkedListNode:\\n    def __init__(self, val, _next = None):\\n        self.val = val\\n        self.next = _next\\n    \\n# Linked List =========\\nclass LinkedList:\\n    def __init__(self):\\n        self.head = LinkedListNode(\"dummy\")\\n        self.tail = self.head\\n        \\n    def add(self, val):\\n        self.tail.next = LinkedListNode(val)\\n        self.tail = self.tail.next\\n        \\n    @staticmethod\\n    def init_from_binarytree(tree_root):\\n        linked_list = LinkedList()\\n        \\n        def in_order_and_set_list(root):\\n            if not root:\\n                return None\\n            \\n            in_order_and_set_list(root.left)\\n            linked_list.add(root.val)\\n            in_order_and_set_list(root.right)\\n        \\n        in_order_and_set_list(tree_root)\\n        return linked_list\\n            \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886855,
                "title": "python-intuitive-implementaion",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.ans=[]\\n        def helper(root):\\n            if root is None:\\n                return\\n            helper(root.left)\\n            self.ans.append(root.val)\\n            helper(root.right)\\n        helper(root)\\n        self.i=0\\n        self.l=len(self.ans)\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        self.i+=1\\n        return self.ans[self.i-1]\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return self.i!=self.l\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.ans=[]\\n        def helper(root):\\n            if root is None:\\n                return\\n            helper(root.left)\\n            self.ans.append(root.val)\\n            helper(root.right)\\n        helper(root)\\n        self.i=0\\n        self.l=len(self.ans)\\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        self.i+=1\\n        return self.ans[self.i-1]\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return self.i!=self.l\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 546816,
                "title": "python-99",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.put(root)\\n        \\n    def put(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        temp = self.stack.pop()\\n        self.put(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)>0\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.put(root)\\n        \\n    def put(self,root):\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n\\n    def next(self) -> int:\\n        temp = self.stack.pop()\\n        self.put(temp.right)\\n        return temp.val\\n\\n    def hasNext(self) -> bool:\\n        return len(self.stack)>0\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512926,
                "title": "python3-solution-using-queue",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.queue = []\\n        self.get_result(self.root)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return\\n        self.get_result(root.left)\\n        self.queue.append(root.val)\\n        self.get_result(root.right)\\n            \\n        \\n    def hasNext(self) -> bool:\\n        return not len(self.queue)==0\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.queue = []\\n        self.get_result(self.root)\\n\\n    def next(self) -> int:\\n        return self.queue.pop(0)\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return\\n        self.get_result(root.left)\\n        self.queue.append(root.val)\\n        self.get_result(root.right)\\n            \\n        \\n    def hasNext(self) -> bool:\\n        return not len(self.queue)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512925,
                "title": "python3-recursive-solution",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.prev = float(\"-inf\")\\n        self.prev_ = float(\"-inf\")\\n\\n    def next(self) -> int:\\n        if self.prev_>self.prev:\\n            self.prev = self.prev_\\n        else:\\n            self.prev = self.get_result(self.root)\\n        return self.prev\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        x = None\\n        if self.prev<root.val:\\n            x = self.get_result(root.left)\\n        else:\\n            x = self.get_result(root.right)\\n        if x==None and root.val>self.prev:\\n            return root.val\\n        return x \\n            \\n        \\n    def hasNext(self) -> bool:\\n        if self.root==None:\\n            return False\\n        x = self.get_result(self.root)\\n        if x==None:\\n            return False\\n        else:\\n            self.prev_ = x\\n            return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.root = root\\n        self.prev = float(\"-inf\")\\n        self.prev_ = float(\"-inf\")\\n\\n    def next(self) -> int:\\n        if self.prev_>self.prev:\\n            self.prev = self.prev_\\n        else:\\n            self.prev = self.get_result(self.root)\\n        return self.prev\\n            \\n        \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        x = None\\n        if self.prev<root.val:\\n            x = self.get_result(root.left)\\n        else:\\n            x = self.get_result(root.right)\\n        if x==None and root.val>self.prev:\\n            return root.val\\n        return x \\n            \\n        \\n    def hasNext(self) -> bool:\\n        if self.root==None:\\n            return False\\n        x = self.get_result(self.root)\\n        if x==None:\\n            return False\\n        else:\\n            self.prev_ = x\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318432,
                "title": "python3-beats-99",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.push_lefts(root)\\n    \\n    def push_lefts(self,node):\\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n            \\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        node = self.stack.pop()\\n        self.push_lefts(node.right)\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return len(self.stack) > 0\\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: TreeNode):\\n        self.stack = []\\n        self.push_lefts(root)\\n    \\n    def push_lefts(self,node):\\n        while node:\\n            self.stack.append(node)\\n            node = node.left\\n            \\n    def next(self) -> int:\\n        \"\"\"\\n        @return the next smallest number\\n        \"\"\"\\n        node = self.stack.pop()\\n        self.push_lefts(node.right)\\n        return node.val\\n\\n    def hasNext(self) -> bool:\\n        \"\"\"\\n        @return whether we have a next smallest number\\n        \"\"\"\\n        return len(self.stack) > 0\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 293278,
                "title": "c-inorder",
                "content": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        while (root != null) {\\n            stack.Push(root);\\n            root = root.left;\\n        }\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() {\\n        var next = stack.Pop();\\n        if (next.right != null) {\\n            var cur = next.right;\\n            while (cur != null) {\\n                stack.Push(cur);\\n                cur = cur.left;\\n            }\\n        }\\n        return next.val;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return stack.Any();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        while (root != null) {\\n            stack.Push(root);\\n            root = root.left;\\n        }\\n    }\\n\\n    /** @return the next smallest number */\\n    public int Next() {\\n        var next = stack.Pop();\\n        if (next.right != null) {\\n            var cur = next.right;\\n            while (cur != null) {\\n                stack.Push(cur);\\n                cur = cur.left;\\n            }\\n        }\\n        return next.val;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public bool HasNext() {\\n        return stack.Any();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189517,
                "title": "c-solution-using-enumerator-interface",
                "content": "yield return is your friend in writing any kind of iterator type thing in C#:\\n```\\npublic static class BSTIteratorExt {\\n  public static IEnumerable<TreeNode> Flatten(this TreeNode root) {\\n    if (root != null) {\\n      foreach(var node in root.left.Flatten()) yield return node;\\n      yield return root;\\n      foreach(var node in root.right.Flatten()) yield return node;\\n    }\\n  }  \\n}\\n\\npublic class BSTIterator {\\n\\n  private IEnumerator<TreeNode> enumerator;\\n  \\n  public BSTIterator(TreeNode root) {\\n    enumerator = root.Flatten().GetEnumerator();\\n  }\\n\\n  /** @return whether we have a next smallest number */\\n  public bool HasNext() {\\n    return enumerator.MoveNext();\\n  }\\n\\n  /** @return the next smallest number */\\n  public int Next() {\\n    return enumerator.Current.val;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic static class BSTIteratorExt {\\n  public static IEnumerable<TreeNode> Flatten(this TreeNode root) {\\n    if (root != null) {\\n      foreach(var node in root.left.Flatten()) yield return node;\\n      yield return root;\\n      foreach(var node in root.right.Flatten()) yield return node;\\n    }\\n  }  \\n}\\n\\npublic class BSTIterator {\\n\\n  private IEnumerator<TreeNode> enumerator;\\n  \\n  public BSTIterator(TreeNode root) {\\n    enumerator = root.Flatten().GetEnumerator();\\n  }\\n\\n  /** @return whether we have a next smallest number */\\n  public bool HasNext() {\\n    return enumerator.MoveNext();\\n  }\\n\\n  /** @return the next smallest number */\\n  public int Next() {\\n    return enumerator.Current.val;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166768,
                "title": "javascript-o-1-time-o-3h-space-explained-step-by-step",
                "content": "To make this solution `O(h)` space, we\\'re just keeping track of parent nodes on our stack, which will go through later (if they are eventually called by the client executing `next`).\\n\\nThis is how it works for `[10, 5, 15, 1, 6]`\\n\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/1484663199409/image_1536070104.png)\\n\\nThe stack will store both TreeNode and numbers. The number will be the exit point, and the TreeNode will have to be expanded. In an OO language, or if you want to make it cleaner you could actually write a class/prototype that returned you the kind of value it is storing ([just like LeetCode NestedTree in a similar problem](https://leetcode.com/problems/flatten-nested-list-iterator/)).\\n\\nInitially we\\'ll extract the root tree node, we first push the right side, then the value of the current node\\'s and then the left side. I marked numbers as `*number*` for clarity.\\n\\n`[15, *10*, 5]`\\n\\nSince the popped value wasn\\'t a number (and the stack has values left to process) we start once again.\\n\\n`[15, 10, 6, *5*, 1]`\\n\\n5 wasn\\'t a number so we keep going\\n\\n`[15, 10, 6, *5*, *1*]`\\n\\nThe TreeNode containing value 1 didn\\'t have children. Hence the next value is going to be a number.\\n\\n`[15, 10, 6, *5*]`\\n`this.cache = 1`\\n\\nWe\\'re now done until the user requests (`next`) a new number.\\n\\n```\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.root = root;\\n    this.stack = root ? [root] : [];\\n    this.cache;\\n};\\n\\nBSTIterator.prototype.cacheNext = function() {\\n    while (this.cache === undefined && this.stack.length > 0) {\\n        const top = this.stack.pop();\\n        if (!(top instanceof TreeNode)) {\\n            // It\\'s a number\\n            this.cache = top;\\n            continue;\\n        }\\n        \\n        // It\\'s a TreeNode\\n        if (top.right) {\\n            this.stack.push(top.right);\\n        }\\n        this.stack.push(top.val);\\n        if (top.left) {\\n            this.stack.push(top.left);\\n        }\\n    }\\n    return this.cache;\\n}\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cacheNext() !== undefined;\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    const res = this.cacheNext();\\n    this.cache = undefined;\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @constructor\\n * @param {TreeNode} root - root of the binary search tree\\n */\\nvar BSTIterator = function(root) {\\n    this.root = root;\\n    this.stack = root ? [root] : [];\\n    this.cache;\\n};\\n\\nBSTIterator.prototype.cacheNext = function() {\\n    while (this.cache === undefined && this.stack.length > 0) {\\n        const top = this.stack.pop();\\n        if (!(top instanceof TreeNode)) {\\n            // It\\'s a number\\n            this.cache = top;\\n            continue;\\n        }\\n        \\n        // It\\'s a TreeNode\\n        if (top.right) {\\n            this.stack.push(top.right);\\n        }\\n        this.stack.push(top.val);\\n        if (top.left) {\\n            this.stack.push(top.left);\\n        }\\n    }\\n    return this.cache;\\n}\\n\\n\\n/**\\n * @this BSTIterator\\n * @returns {boolean} - whether we have a next smallest number\\n */\\nBSTIterator.prototype.hasNext = function() {\\n    return this.cacheNext() !== undefined;\\n};\\n\\n/**\\n * @this BSTIterator\\n * @returns {number} - the next smallest number\\n */\\nBSTIterator.prototype.next = function() {\\n    const res = this.cacheNext();\\n    this.cache = undefined;\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152762,
                "title": "easiest-arraylist-solution",
                "content": "\\nThe key idea is: **a inorder traverse of a Binary Search Tree should always be sorted.**\\nSo we just put everything in an ArrayList and use ArrayLIst.iterator()! O(1) for each query, and construction of such iterator is O(N).\\n\\n\\n```\\npublic class BSTIterator {\\n    ArrayList<Integer> list;\\n    Iterator<Integer> it;\\n    TreeNode root;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.root = root;\\n        list =  new ArrayList<Integer>();\\n        inorderTraversal(list, root);\\n        it = list.iterator();\\n    }\\n    \\n    private void inorderTraversal(ArrayList<Integer> list, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left != null){\\n            inorderTraversal(list, root.left);\\n        }\\n        list.add(root.val);\\n        if(root.right != null){\\n            inorderTraversal(list, root.right);\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        return it.next();      \\n    }\\n}\\n```\\nHope you enjoy this solution :D",
                "solutionTags": [],
                "code": "```\\npublic class BSTIterator {\\n    ArrayList<Integer> list;\\n    Iterator<Integer> it;\\n    TreeNode root;\\n    \\n    public BSTIterator(TreeNode root) {\\n        this.root = root;\\n        list =  new ArrayList<Integer>();\\n        inorderTraversal(list, root);\\n        it = list.iterator();\\n    }\\n    \\n    private void inorderTraversal(ArrayList<Integer> list, TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        if(root.left != null){\\n            inorderTraversal(list, root.left);\\n        }\\n        list.add(root.val);\\n        if(root.right != null){\\n            inorderTraversal(list, root.right);\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return it.hasNext();\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        return it.next();      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52629,
                "title": "4ms-java-solution-beats-99-83",
                "content": "```\\nprivate TreeNode crt;\\n    public BSTIterator(TreeNode root) {\\n        crt = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return crt != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        while (crt.left != null) {\\n            TreeNode temp = crt.left;\\n            while (temp.right != null && temp.right != crt) temp = temp.right;\\n            if (temp.right == null) {\\n                temp.right = crt;\\n                crt = crt.left;\\n            } else {\\n                temp.right = null;\\n                break;\\n            }\\n        }\\n        int re = crt.val;\\n        crt = crt.right;\\n        return re;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate TreeNode crt;\\n    public BSTIterator(TreeNode root) {\\n        crt = root;\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return crt != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        while (crt.left != null) {\\n            TreeNode temp = crt.left;\\n            while (temp.right != null && temp.right != crt) temp = temp.right;\\n            if (temp.right == null) {\\n                temp.right = crt;\\n                crt = crt.left;\\n            } else {\\n                temp.right = null;\\n                break;\\n            }\\n        }\\n        int re = crt.val;\\n        crt = crt.right;\\n        return re;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 52639,
                "title": "o-1-space-with-same-time-complex-of-stack-solution-morris-traversal-of-tree",
                "content": "The Stack solution seems use O(h) space well the time complex of next() function is more than O(1). \\nI try to use Morris Tree Traversal to solve this issue which saves space. However the time complex of construction of the class BSTIterator is O(n) (instead of O(h) to building  the Stack). Time complex of next() function keep the same, between O(1) and O(h), since we are always have to find the right child node's most left child.\\n```\\n/**\\n * Definition for binary tree\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class BSTIterator {\\n    private TreeNode head = null;\\n    \\n    public BSTIterator(TreeNode root) {\\n        TreeNode pre = null;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                pre = cur.left;\\n                while (pre.right != null && pre.right != cur) {\\n                    pre = pre.right;\\n                }\\n                if (pre.right == null) {\\n                    pre.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    cur = cur.right;\\n                }\\n            } else {\\n                if (head == null) head = cur;\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return head != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int ret = head.val;\\n        TreeNode nextNode = head.right;\\n        if (nextNode != null) {\\n            while (nextNode.left != null && nextNode.left.val > head.val) {\\n                nextNode = nextNode.left;\\n            }\\n        } \\n        head = nextNode;\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for binary tree\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class BSTIterator {\\n    private TreeNode head = null;\\n    \\n    public BSTIterator(TreeNode root) {\\n        TreeNode pre = null;\\n        TreeNode cur = root;\\n        while (cur != null) {\\n            if (cur.left != null) {\\n                pre = cur.left;\\n                while (pre.right != null && pre.right != cur) {\\n                    pre = pre.right;\\n                }\\n                if (pre.right == null) {\\n                    pre.right = cur;\\n                    cur = cur.left;\\n                } else {\\n                    cur = cur.right;\\n                }\\n            } else {\\n                if (head == null) head = cur;\\n                cur = cur.right;\\n            }\\n        }\\n    }\\n\\n    /** @return whether we have a next smallest number */\\n    public boolean hasNext() {\\n        return head != null;\\n    }\\n\\n    /** @return the next smallest number */\\n    public int next() {\\n        int ret = head.val;\\n        TreeNode nextNode = head.right;\\n        if (nextNode != null) {\\n            while (nextNode.left != null && nextNode.left.val > head.val) {\\n                nextNode = nextNode.left;\\n            }\\n        } \\n        head = nextNode;\\n        \\n        return ret;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator will be called like this:\\n * BSTIterator i = new BSTIterator(root);\\n * while (i.hasNext()) v[f()] = i.next();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 52649,
                "title": "java-solution-taking-o-1-space-and-o-1-time-beating-99-submissions",
                "content": " A typical Morris traversal approach.\\n\\n\\n    public class BSTIterator {\\n        \\n        private TreeNode current;\\n        \\n        public BSTIterator(TreeNode root) {\\n            current = threadAllNodesOnLeftMostBranch(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return current != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            int result = current.val;\\n            \\n            current = current.right;\\n            // If thread(current) returns false, it means that the left sub tree of current is visited.\\n            // So there's no need to call threadAllNodesOnLeftMostBranch on current.\\n            if (current != null && current.left != null && thread(current)) {\\n                // current is already threaded in the if statement, skip it.\\n                current = current.left;\\n                current = threadAllNodesOnLeftMostBranch(current);\\n            }\\n            \\n            return result;\\n        }\\n        \\n        // Thread all nodes on TreeNode root's left-most branch until it reaches the last node on the branch,\\n        // and return the last node\\n        private TreeNode threadAllNodesOnLeftMostBranch(TreeNode root) {\\n            while (root != null && root.left != null) {\\n                   thread(root);\\n                   root = root.left;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        // Thread or unthread TreeNode root with its successor\\n        // Return true if the operation turns out as a threading, and false if unthreading.\\n        private boolean thread(TreeNode root) {\\n            TreeNode predecessor  = root.left;\\n            while (predecessor.right != null && predecessor.right != root) {\\n                predecessor = predecessor.right;\\n            }\\n            if (predecessor.right == null) {\\n                predecessor.right = root;\\n                return true;\\n            } else {\\n                predecessor.right = null;\\n                return false;\\n            }\\n        }\\n    }\\n\\n\\n\\nThese solutions also take O(1) space and O(1) time:\\n\\n[The most voted one][1] has an overhead for threading the tree, it's not as fast as other solutions.\\n\\n[A good approach which does not break the tree][2], the implementation not very concise.\\n\\n[Another approach which breaks the tree structure][3]\\n\\n\\n  [1]: https://leetcode.com/discuss/58469/solution-space-amortized-time-using-morris-tree-traversal\\n  [2]: https://leetcode.com/discuss/22075/solution-morris-traversal-method-space-hasnext-amortized\\n  [3]: https://leetcode.com/discuss/63980/o-1-time-o-1-space-in-worst-case-challenge-me-please",
                "solutionTags": [
                    "Java"
                ],
                "code": " A typical Morris traversal approach.\\n\\n\\n    public class BSTIterator {\\n        \\n        private TreeNode current;\\n        \\n        public BSTIterator(TreeNode root) {\\n            current = threadAllNodesOnLeftMostBranch(root);\\n        }\\n    \\n        /** @return whether we have a next smallest number */\\n        public boolean hasNext() {\\n            return current != null;\\n        }\\n    \\n        /** @return the next smallest number */\\n        public int next() {\\n            int result = current.val;\\n            \\n            current = current.right;\\n            // If thread(current) returns false, it means that the left sub tree of current is visited.\\n            // So there's no need to call threadAllNodesOnLeftMostBranch on current.\\n            if (current != null && current.left != null && thread(current)) {\\n                // current is already threaded in the if statement, skip it.\\n                current = current.left;\\n                current = threadAllNodesOnLeftMostBranch(current);\\n            }\\n            \\n            return result;\\n        }\\n        \\n        // Thread all nodes on TreeNode root's left-most branch until it reaches the last node on the branch,\\n        // and return the last node\\n        private TreeNode threadAllNodesOnLeftMostBranch(TreeNode root) {\\n            while (root != null && root.left != null) {\\n                   thread(root);\\n                   root = root.left;\\n            }\\n            \\n            return root;\\n        }\\n        \\n        // Thread or unthread TreeNode root with its successor\\n        // Return true if the operation turns out as a threading, and false if unthreading.\\n        private boolean thread(TreeNode root) {\\n            TreeNode predecessor  = root.left;\\n            while (predecessor.right != null && predecessor.right != root) {\\n                predecessor = predecessor.right;\\n            }\\n            if (predecessor.right == null) {\\n                predecessor.right = root;\\n                return true;\\n            } else {\\n                predecessor.right = null;\\n                return false;\\n            }\\n        }\\n    }\\n\\n\\n\\nThese solutions also take O(1) space and O(1) time:\\n\\n[The most voted one][1] has an overhead for threading the tree, it's not as fast as other solutions.\\n\\n[A good approach which does not break the tree][2], the implementation not very concise.\\n\\n[Another approach which breaks the tree structure][3]\\n\\n\\n  [1]: https://leetcode.com/discuss/58469/solution-space-amortized-time-using-morris-tree-traversal\\n  [2]: https://leetcode.com/discuss/22075/solution-morris-traversal-method-space-hasnext-amortized\\n  [3]: https://leetcode.com/discuss/63980/o-1-time-o-1-space-in-worst-case-challenge-me-please",
                "codeTag": "Java"
            },
            {
                "id": 52729,
                "title": "c-solution-using-iterative-inorder-traversal",
                "content": "    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            p = root;\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n        }\\n\\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty() || p;\\n        }\\n\\n        /** @return the next smallest number */\\n        int next() {\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n            p = s.top();\\n            int val = p->val;\\n        \\n            s.pop();\\n            p = p->right;\\n        \\n            return val;\\n        }\\n        TreeNode *p;\\n        stack<TreeNode*> s;\\n      };",
                "solutionTags": [],
                "code": "    class BSTIterator {\\n    public:\\n        BSTIterator(TreeNode *root) {\\n            p = root;\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n        }\\n\\n        /** @return whether we have a next smallest number */\\n        bool hasNext() {\\n            return !s.empty() || p;\\n        }\\n\\n        /** @return the next smallest number */\\n        int next() {\\n            while (p) {\\n                s.push(p);\\n                p = p->left;\\n            }\\n            p = s.top();\\n            int val = p->val;\\n        \\n            s.pop();\\n            p = p->right;\\n        \\n            return val;\\n        }\\n        TreeNode *p;\\n        stack<TreeNode*> s;\\n      };",
                "codeTag": "Java"
            },
            {
                "id": 52761,
                "title": "accepted-java-solution-using-stack",
                "content": "The idea is to use a stack to store ancestors of a left child.\\n\\n    private TreeNode mCurrent;\\n\\tprivate Stack<TreeNode> mAncestors;\\n\\t\\n\\tpublic BSTIterator(TreeNode root) {\\n        this.mCurrent = root;\\n        this.mAncestors = new Stack<TreeNode>();\\n        while (mCurrent != null) {\\n        \\tmAncestors.push(mCurrent);\\n        \\tmCurrent = mCurrent.left;\\n        }\\n    }\\n\\n    public boolean hasNext() {\\n        return (mCurrent != null && mCurrent.right != null) \\n        \\t\\t|| !mAncestors.isEmpty();\\n    }\\n\\n    public int next() {\\n    \\tif (mCurrent == null) {\\n    \\t\\tmCurrent = mAncestors.pop();\\n    \\t} else if (mCurrent.right != null) {\\n    \\t\\tmCurrent = mCurrent.right;\\n    \\t\\twhile (mCurrent.left != null) {\\n            \\tmAncestors.push(mCurrent);\\n            \\tmCurrent = mCurrent.left;\\n            }\\n        } else {\\n        \\tmCurrent = mAncestors.pop();\\n        }\\n        return mCurrent.val;\\n    }",
                "solutionTags": [],
                "code": "The idea is to use a stack to store ancestors of a left child.\\n\\n    private TreeNode mCurrent;\\n\\tprivate Stack<TreeNode> mAncestors;\\n\\t\\n\\tpublic BSTIterator(TreeNode root) {\\n        this.mCurrent = root;\\n        this.mAncestors = new Stack<TreeNode>();\\n        while (mCurrent != null) {\\n        \\tmAncestors.push(mCurrent);\\n        \\tmCurrent = mCurrent.left;\\n        }\\n    }\\n\\n    public boolean hasNext() {\\n        return (mCurrent != null && mCurrent.right != null) \\n        \\t\\t|| !mAncestors.isEmpty();\\n    }\\n\\n    public int next() {\\n    \\tif (mCurrent == null) {\\n    \\t\\tmCurrent = mAncestors.pop();\\n    \\t} else if (mCurrent.right != null) {\\n    \\t\\tmCurrent = mCurrent.right;\\n    \\t\\twhile (mCurrent.left != null) {\\n            \\tmAncestors.push(mCurrent);\\n            \\tmCurrent = mCurrent.left;\\n            }\\n        } else {\\n        \\tmCurrent = mAncestors.pop();\\n        }\\n        return mCurrent.val;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3557005,
                "title": "simple-solution-using-queue",
                "content": "# Complexity\\n- Time complexity:\\n  O(N) //inorder traversal during recursion\\n\\n- Space complexity:\\n O(N) \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class BSTIterator {\\n    Queue<int> q;\\n    public BSTIterator(TreeNode root) {\\n       q = new Queue<int>();   \\n       helper(root, q);   \\n    }\\n    private void helper(TreeNode root, Queue<int> q){\\n        if(root == null) return;\\n        helper(root.left, q);\\n        q.Enqueue(root.val);\\n        helper(root.right, q);\\n    }\\n    public int Next() {\\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n        return q.Count != 0;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class BSTIterator {\\n    Queue<int> q;\\n    public BSTIterator(TreeNode root) {\\n       q = new Queue<int>();   \\n       helper(root, q);   \\n    }\\n    private void helper(TreeNode root, Queue<int> q){\\n        if(root == null) return;\\n        helper(root.left, q);\\n        q.Enqueue(root.val);\\n        helper(root.right, q);\\n    }\\n    public int Next() {\\n        return q.Dequeue();\\n    }\\n    \\n    public bool HasNext() {\\n        return q.Count != 0;\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.Next();\\n * bool param_2 = obj.HasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294604,
                "title": "optimized-solution-o-h-space-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>s=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=s.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        return !s.isEmpty();\\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233236,
                "title": "173-binary-search-tree-iterator-java",
                "content": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode>  st=new Stack <TreeNode> ();\\n\\n    public BSTIterator(TreeNode root) {\\n        addAll(root);\\n        \\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        addAll(temp.right);\\n        return temp.val;\\n        \\n    }\\n    \\n    public boolean hasNext() {\\n    return !st.isEmpty();    \\n    }\\n    \\n    public void addAll(TreeNode root)\\n    {\\n        for(;root!=null; st.push(root) ,root=root.left);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator {\\n    \\n    Stack<TreeNode>  st=new Stack <TreeNode> ();\\n\\n    public BSTIterator(TreeNode root) {\\n        addAll(root);\\n        \\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        addAll(temp.right);\\n        return temp.val;\\n        \\n    }\\n    \\n    public boolean hasNext() {\\n    return !st.isEmpty();    \\n    }\\n    \\n    public void addAll(TreeNode root)\\n    {\\n        for(;root!=null; st.push(root) ,root=root.left);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204414,
                "title": "100-beats-java-solution",
                "content": "# Code\\n```\\nclass BSTIterator \\n{\\n    List<Integer> li = null ;\\n    Iterator it = null ;\\n    private void traverse( TreeNode root , List li )\\n    {\\n        if(root != null)    \\n        {\\n            traverse(root.left, li);\\n            li.add(root.val);\\n            traverse(root.right, li);\\n        }\\n    }\\n\\n    public BSTIterator(TreeNode root) \\n    {\\n        li = new ArrayList<Integer>() ;\\n        traverse(root, li);\\n        it = li.listIterator();\\n    }\\n    \\n    public int next()\\n    {\\n        return (int)it.next() ;\\n    }\\n    \\n    public boolean hasNext() \\n    {\\n        return it.hasNext();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator \\n{\\n    List<Integer> li = null ;\\n    Iterator it = null ;\\n    private void traverse( TreeNode root , List li )\\n    {\\n        if(root != null)    \\n        {\\n            traverse(root.left, li);\\n            li.add(root.val);\\n            traverse(root.right, li);\\n        }\\n    }\\n\\n    public BSTIterator(TreeNode root) \\n    {\\n        li = new ArrayList<Integer>() ;\\n        traverse(root, li);\\n        it = li.listIterator();\\n    }\\n    \\n    public int next()\\n    {\\n        return (int)it.next() ;\\n    }\\n    \\n    public boolean hasNext() \\n    {\\n        return it.hasNext();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3201425,
                "title": "c-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093329,
                "title": "beats-96-next-hasnext-o-1-time-o-n-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    TreeNode* root;\\n    vector<int>inorder;\\n    int idx;\\n    BSTIterator(TreeNode* root) {\\n        this->root=root;\\n        fill(root);\\n        idx=0;\\n    }\\n    void fill(TreeNode* curr){\\n        if(!curr)return;\\n        fill(curr->left);\\n        inorder.push_back(curr->val);\\n        fill(curr->right);\\n    }\\n    \\n    int next() {\\n        if(idx<inorder.size()){\\n            int val=inorder[idx++];\\n            return val;\\n        }\\n        else{\\n            return INT_MAX;\\n        }\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return idx<=inorder.size()-1?true:false;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    TreeNode* root;\\n    vector<int>inorder;\\n    int idx;\\n    BSTIterator(TreeNode* root) {\\n        this->root=root;\\n        fill(root);\\n        idx=0;\\n    }\\n    void fill(TreeNode* curr){\\n        if(!curr)return;\\n        fill(curr->left);\\n        inorder.push_back(curr->val);\\n        fill(curr->right);\\n    }\\n    \\n    int next() {\\n        if(idx<inorder.size()){\\n            int val=inorder[idx++];\\n            return val;\\n        }\\n        else{\\n            return INT_MAX;\\n        }\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return idx<=inorder.size()-1?true:false;\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085029,
                "title": "java-very-easy-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>st=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!st.isEmpty()) return true;\\n        return false;\\n    }\\n\\n    public void pushAll(TreeNode root){\\n        while(root!=null){\\n            st.push(root);\\n            root=root.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass BSTIterator {\\n    Stack<TreeNode>st=new Stack<TreeNode>();\\n    public BSTIterator(TreeNode root) {\\n        pushAll(root);\\n    }\\n    \\n    public int next() {\\n        TreeNode temp=st.pop();\\n        pushAll(temp.right);\\n        return temp.val;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(!st.isEmpty()) return true;\\n        return false;\\n    }\\n\\n    public void pushAll(TreeNode root){\\n        while(root!=null){\\n            st.push(root);\\n            root=root.left;\\n        }\\n    }\\n}\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator obj = new BSTIterator(root);\\n * int param_1 = obj.next();\\n * boolean param_2 = obj.hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056768,
                "title": "inorder-traversal-using-a-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    /* \\n       - we will do an inorder traversal and store the elements in a queue\\n       - it will allow us to keep the lowest element in the front\\n       - we will fetch from the queue for every next call\\n       - has next will check whether the queue is empty\\n    */\\n    queue<int>inOrder;\\n    BSTIterator(TreeNode* root) {\\n        getInorder(root);\\n    }\\n    \\n    int next() {\\n        if(inOrder.size() != 0){\\n            int res = inOrder.front();\\n            inOrder.pop();\\n            return res;\\n        }\\n        return 0;\\n    }\\n    \\n    bool hasNext() {\\n        return inOrder.size() > 0;\\n    }\\n\\n    void getInorder(TreeNode* root){\\n        if(!root) return;\\n        getInorder(root->left);\\n        inOrder.push(root->val);\\n        getInorder(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass BSTIterator {\\npublic:\\n    /* \\n       - we will do an inorder traversal and store the elements in a queue\\n       - it will allow us to keep the lowest element in the front\\n       - we will fetch from the queue for every next call\\n       - has next will check whether the queue is empty\\n    */\\n    queue<int>inOrder;\\n    BSTIterator(TreeNode* root) {\\n        getInorder(root);\\n    }\\n    \\n    int next() {\\n        if(inOrder.size() != 0){\\n            int res = inOrder.front();\\n            inOrder.pop();\\n            return res;\\n        }\\n        return 0;\\n    }\\n    \\n    bool hasNext() {\\n        return inOrder.size() > 0;\\n    }\\n\\n    void getInorder(TreeNode* root){\\n        if(!root) return;\\n        getInorder(root->left);\\n        inOrder.push(root->val);\\n        getInorder(root->right);\\n    }\\n};\\n\\n/**\\n * Your BSTIterator object will be instantiated and called as such:\\n * BSTIterator* obj = new BSTIterator(root);\\n * int param_1 = obj->next();\\n * bool param_2 = obj->hasNext();\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053519,
                "title": "java-dfs-queue-100-faster",
                "content": "# Approach\\nGo thru tree using DFS and adding values into queue.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n# Code\\n```\\nclass BSTIterator {\\n        Queue<Integer> list;\\n        public BSTIterator(TreeNode root) {\\n            list = new LinkedList<>();\\n            traverseBST(root, list);\\n        }\\n\\n        public int next() {\\n            return list.poll();\\n        }\\n\\n        public boolean hasNext() {\\n            return !list.isEmpty();\\n        }\\n        \\n        private void traverseBST(TreeNode node, Queue<Integer> list) {\\n            if (node == null) return;\\n            \\n            traverseBST(node.left, list);\\n            list.add(node.val);\\n            traverseBST(node.right, list);\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass BSTIterator {\\n        Queue<Integer> list;\\n        public BSTIterator(TreeNode root) {\\n            list = new LinkedList<>();\\n            traverseBST(root, list);\\n        }\\n\\n        public int next() {\\n            return list.poll();\\n        }\\n\\n        public boolean hasNext() {\\n            return !list.isEmpty();\\n        }\\n        \\n        private void traverseBST(TreeNode node, Queue<Integer> list) {\\n            if (node == null) return;\\n            \\n            traverseBST(node.left, list);\\n            list.add(node.val);\\n            traverseBST(node.right, list);\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025698,
                "title": "simple-solution-using-threaded-binary-tree-no-use-of-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to use Threaded Binary Tree concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we check if the tree has any left child if it has we connect the right most node of the left child to the parent. and move to the left of the tree. \\nIf the there is no left child then according to the inorder traversal we return the value of the root and root is changed to root->right;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1) on an average for each operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) as no extra space is used\\n\\n# Code\\nclass BSTIterator {\\nprivate : \\nTreeNode * root;\\npublic:\\n    \\n    BSTIterator(TreeNode* r) {\\n        root = r;\\n    }\\n    \\n    int next() {\\n        while (root->left)\\n        {\\n            TreeNode *tmp = root->left;\\n            while(tmp->right && tmp->right != root) tmp = tmp->right;\\n            if (tmp->right == NULL)\\n            {\\n                tmp->right = root;\\n                root = root->left;\\n            }\\n            else\\n            {\\n                tmp->right = NULL;\\n                int ans = root->val;\\n                root = root->right;\\n                return ans;\\n            }\\n\\n        }\\n        int ans = root->val;\\n        root = root->right;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return root != NULL;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTried to use Threaded Binary Tree concept\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we check if the tree has any left child if it has we connect the right most node of the left child to the parent. and move to the left of the tree. \\nIf the there is no left child then according to the inorder traversal we return the value of the root and root is changed to root->right;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(1) on an average for each operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1) as no extra space is used\\n\\n# Code\\nclass BSTIterator {\\nprivate : \\nTreeNode * root;\\npublic:\\n    \\n    BSTIterator(TreeNode* r) {\\n        root = r;\\n    }\\n    \\n    int next() {\\n        while (root->left)\\n        {\\n            TreeNode *tmp = root->left;\\n            while(tmp->right && tmp->right != root) tmp = tmp->right;\\n            if (tmp->right == NULL)\\n            {\\n                tmp->right = root;\\n                root = root->left;\\n            }\\n            else\\n            {\\n                tmp->right = NULL;\\n                int ans = root->val;\\n                root = root->right;\\n                return ans;\\n            }\\n\\n        }\\n        int ans = root->val;\\n        root = root->right;\\n        return ans;\\n    }\\n    \\n    bool hasNext() {\\n        return root != NULL;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2965908,
                "title": "c-beats-100-explained-using-stack",
                "content": "# Intuition\\nWe know that Inorder Traversal of BST is always in sorted order.\\n\\n    Runtime - 100%\\uD83D\\uDD25 \\n\\n# Approach\\n1. Firstly we will store the preorder traversal of tree in stack.\\n2. Then we will reverse the stack.\\n\\n#  If you like the solution and understand it then Please Upvote.\\u2B06\\uFE0F\\u2764\\uFE0F \\n\\t* PEACE OUT LUV\\u270C\\uFE0F*\\n\\n# Code\\n```\\nclass BSTIterator {\\npublic:\\n    stack<int>st;\\n    stack<int>st1;\\n    void dfs(TreeNode* root, stack<int>&st){\\n        if(root== NULL){\\n            return;\\n        }\\n        dfs(root ->left, st);\\n        st.push(root ->val);\\n        dfs(root ->right, st); \\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root, st1);\\n        while(!st1.empty()){\\n            st.push(st1.top());\\n            st1.pop();\\n        }\\n    }\\n    int next() {\\n        int top = st.top();\\n        st.pop();\\n        return top;\\n    }\\n    bool hasNext() {\\n        if(!st.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Binary Search Tree",
                    "Iterator"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    stack<int>st;\\n    stack<int>st1;\\n    void dfs(TreeNode* root, stack<int>&st){\\n        if(root== NULL){\\n            return;\\n        }\\n        dfs(root ->left, st);\\n        st.push(root ->val);\\n        dfs(root ->right, st); \\n    }\\n    BSTIterator(TreeNode* root) {\\n        dfs(root, st1);\\n        while(!st1.empty()){\\n            st.push(st1.top());\\n            st1.pop();\\n        }\\n    }\\n    int next() {\\n        int top = st.top();\\n        st.pop();\\n        return top;\\n    }\\n    bool hasNext() {\\n        if(!st.empty()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2840678,
                "title": "time-o-n-space-o-h-simple-solution",
                "content": "class BSTIterator {\\npublic:\\n    \\n    stack<TreeNode*>st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        \\n        TreeNode*root=st.top();st.pop();\\n        int result=root->val;\\n        root=root->right;\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.size()==0) return false;\\n        else return true;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class BSTIterator {\\npublic:\\n    \\n    stack<TreeNode*>st;\\n    \\n    BSTIterator(TreeNode* root) {\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n    }\\n    \\n    int next() {\\n        \\n        TreeNode*root=st.top();st.pop();\\n        int result=root->val;\\n        root=root->right;\\n        while(root)\\n        {\\n            st.push(root);\\n            root=root->left;\\n        }\\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        if(st.size()==0) return false;\\n        else return true;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2641612,
                "title": "using-arraylist-java-solution",
                "content": "We create a ArrayList (tree) to store the value of nodes of the tree, in inorder sequence.\\nWhen the BSTIterator is called for the first time, we call normal inorder function that traverses the tree, and we strore the node values in the tree.\\n\\nWe also create a pointer l = 0, that traverses the Arraylist, and keeps track of the posititon in the tree.\\n```\\nclass BSTIterator {\\n\\n    ArrayList<Integer> tree;\\n    int l = 0;\\n    public BSTIterator(TreeNode root) {\\n        tree = new ArrayList<>();\\n        inorder(root);\\n    }\\n    \\n    public int next() {\\n        return tree.get(l++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return l < tree.size();\\n    }\\n    \\n\\t// adds node values to ArrayList (tree)\\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            tree.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass BSTIterator {\\n\\n    ArrayList<Integer> tree;\\n    int l = 0;\\n    public BSTIterator(TreeNode root) {\\n        tree = new ArrayList<>();\\n        inorder(root);\\n    }\\n    \\n    public int next() {\\n        return tree.get(l++);\\n    }\\n    \\n    public boolean hasNext() {\\n        return l < tree.size();\\n    }\\n    \\n\\t// adds node values to ArrayList (tree)\\n    private void inorder(TreeNode root) {\\n        if (root != null) {\\n            inorder(root.left);\\n            tree.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2604737,
                "title": "java-solution-queue",
                "content": "```\\nclass BSTIterator {\\n    Queue<Integer> q = new LinkedList<>();\\n    public BSTIterator(TreeNode root) {\\n        inOrder(root);\\n    }\\n    \\n    public int next() {\\n        return q.poll();\\n    }\\n    \\n    public boolean hasNext() {\\n        return (!q.isEmpty());\\n    }\\n    \\n    public void inOrder(TreeNode root)\\n    {\\n        if(root != null)\\n        {\\n            inOrder(root.left);\\n            q.add(root.val);\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```\\nIf you like the solution, the please UPVOTE  :)",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Queue"
                ],
                "code": "```\\nclass BSTIterator {\\n    Queue<Integer> q = new LinkedList<>();\\n    public BSTIterator(TreeNode root) {\\n        inOrder(root);\\n    }\\n    \\n    public int next() {\\n        return q.poll();\\n    }\\n    \\n    public boolean hasNext() {\\n        return (!q.isEmpty());\\n    }\\n    \\n    public void inOrder(TreeNode root)\\n    {\\n        if(root != null)\\n        {\\n            inOrder(root.left);\\n            q.add(root.val);\\n            inOrder(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513094,
                "title": "python-solution",
                "content": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root=root\\n        self.stack=[root]\\n        curr=root.left\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n    def next(self) -> int:\\n        temp=self.stack.pop()\\n        curr=temp.right\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n        return temp.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.root=root\\n        self.stack=[root]\\n        curr=root.left\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n    def next(self) -> int:\\n        temp=self.stack.pop()\\n        curr=temp.right\\n        while curr:\\n            self.stack.append(curr)\\n            curr=curr.left\\n        return temp.val\\n        \\n\\n    def hasNext(self) -> bool:\\n        return self.stack\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500651,
                "title": "easy-begineer-friendly-c-dfs-alternative-approach",
                "content": "#### Please upvote if find code useful !\\n\\n\\tclass BSTIterator {\\n\\t\\tvector<int> treeSorted;\\n\\t\\tvoid storeTree(TreeNode* root){\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstoreTree(root->left);\\n\\t\\t\\ttreeSorted.push_back(root->val);\\n\\t\\t\\tstoreTree(root->right);\\n\\t\\t}\\n\\n\\tpublic:\\n\\n\\t\\tint index;\\n\\t\\tBSTIterator(TreeNode* root) {\\n\\t\\t\\tstoreTree(root);\\n\\t\\t\\tindex = 0;\\n\\t\\t}\\n\\n\\t\\tint next() {\\n\\t\\t\\tindex++;\\n\\t\\t\\treturn treeSorted[index-1];\\n\\t\\t}\\n\\n\\t\\tbool hasNext() {\\n\\t\\t\\tif(index == treeSorted.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "#### Please upvote if find code useful !\\n\\n\\tclass BSTIterator {\\n\\t\\tvector<int> treeSorted;\\n\\t\\tvoid storeTree(TreeNode* root){\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tstoreTree(root->left);\\n\\t\\t\\ttreeSorted.push_back(root->val);\\n\\t\\t\\tstoreTree(root->right);\\n\\t\\t}\\n\\n\\tpublic:\\n\\n\\t\\tint index;\\n\\t\\tBSTIterator(TreeNode* root) {\\n\\t\\t\\tstoreTree(root);\\n\\t\\t\\tindex = 0;\\n\\t\\t}\\n\\n\\t\\tint next() {\\n\\t\\t\\tindex++;\\n\\t\\t\\treturn treeSorted[index-1];\\n\\t\\t}\\n\\n\\t\\tbool hasNext() {\\n\\t\\t\\tif(index == treeSorted.size())\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2474743,
                "title": "python-96-faster",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        cur = root\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n            \\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        cur = res.right\\n        while cur:\\n            self.stack.append(cur)\\n            cur = cur.left\\n        return res.val\\n\\n    def hasNext(self) -> bool:\\n        return self.stack!=[]\\n        \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.stack = []\\n        cur = root\\n        while root:\\n            self.stack.append(root)\\n            root = root.left\\n            \\n\\n    def next(self) -> int:\\n        res = self.stack.pop()\\n        cur = res.right\\n        while cur:\\n            self.stack.append(cur)\\n            cur = cur.left\\n        return res.val\\n\\n    def hasNext(self) -> bool:\\n        return self.stack!=[]\\n        \\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2353628,
                "title": "o-1-time-o-h-space-solution-explained-cleanly-with-comments-c",
                "content": "**So How come Time is O(1)?**\\n* So see overall we do the inorder traversal but point to be noticed is there are N next calls also.\\n* So Overall TC O(N), But we have N next() calls\\n* So Time for 1 next() is O(N/N) = O(1) amortized.\\n* Space is O(H) as we store left left left only, not all nodes at a time.\\n\\n```\\n//TC O(1) and O(H) Space\\n\\n//MIMIC inorder\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> stk;\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n         // left is done\\n    }\\n    \\n    int next() {\\n        //root handled\\n        TreeNode* node = stk.top();\\n        int ans = node->val;\\n        stk.pop();\\n        \\n        //right handled\\n        pushAll(node->right);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return stk.size() != 0; // stk is empty then no next to show simple\\n    }\\n    \\n    void pushAll(TreeNode* root){\\n        //left part - as inorder is like Left left left, once a root is done then check right\\n        while(root!= NULL){\\n            stk.push(root);\\n            root = root->left;\\n        }\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Binary Search Tree"
                ],
                "code": "```\\n//TC O(1) and O(H) Space\\n\\n//MIMIC inorder\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode*> stk;\\n    BSTIterator(TreeNode* root) {\\n        pushAll(root);\\n         // left is done\\n    }\\n    \\n    int next() {\\n        //root handled\\n        TreeNode* node = stk.top();\\n        int ans = node->val;\\n        stk.pop();\\n        \\n        //right handled\\n        pushAll(node->right);\\n        \\n        return ans;\\n        \\n    }\\n    \\n    bool hasNext() {\\n        return stk.size() != 0; // stk is empty then no next to show simple\\n    }\\n    \\n    void pushAll(TreeNode* root){\\n        //left part - as inorder is like Left left left, once a root is done then check right\\n        while(root!= NULL){\\n            stk.push(root);\\n            root = root->left;\\n        }\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350908,
                "title": "c-2-approaches-inorder-partial-inorder",
                "content": "Straight forward solution, comment below if there\\'re any suggestions or doubts :)\\n\\n***1. Regular Inorder***\\n```\\nclass BSTIterator {\\npublic:\\n    vector<int> ans;\\n    int curr=-1;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return ans[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr+1 < ans.size()) return true;\\n        else return false;\\n    }\\n};\\n```\\n\\n***2. Much more efficient*** (Partial Inorder)\\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> ans;\\n    int curr=-1;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        curr++;\\n        return ans[curr];\\n    }\\n    \\n    bool hasNext() {\\n        if(curr+1 < ans.size()) return true;\\n        else return false;\\n    }\\n};\\n```\n```\\nclass BSTIterator {\\npublic:\\n    stack<TreeNode* > st;\\n    \\n    void inorder(TreeNode* root){\\n        if(root==NULL) return;\\n        st.push(root);\\n        inorder(root->left);\\n    }\\n    \\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    \\n    int next() {\\n        TreeNode* temp=st.top();\\n        st.pop();\\n        inorder(temp->right);\\n        return temp->val;\\n    }\\n    \\n    bool hasNext() {\\n        return !st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2184071,
                "title": "c-using-stack-with-explaination",
                "content": "class BSTIterator {\\npublic:\\n\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {    \\n\\t//To initialize stack\\n        stackFill(root);\\n    }\\n    \\n    int next() {\\n\\t//returns next inorder element and push all left elements which are to the right of the node.\\n        TreeNode* node = st.top();\\n        st.pop();\\n        stackFill(node->right);\\n        \\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n\\t//return true when stack is not empty else false\\n        return !st.empty();\\n    }\\n    \\n\\t//Initialize stack with all elements left to the root, including root\\n    private: \\n        void stackFill(TreeNode* root){\\n            \\n            while(root){\\n                st.push(root);\\n                root = root->left;\\n            }\\n        }\\n};\\n\\nNote: For better understanding and learning, consider dry running code yourself.\\n\\t\\t  For doubts and suggestions comment below.\\n\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class BSTIterator {\\npublic:\\n\\n    stack<TreeNode*> st;\\n    \\n    BSTIterator(TreeNode* root) {    \\n\\t//To initialize stack\\n        stackFill(root);\\n    }\\n    \\n    int next() {\\n\\t//returns next inorder element and push all left elements which are to the right of the node.\\n        TreeNode* node = st.top();\\n        st.pop();\\n        stackFill(node->right);\\n        \\n        return node->val;\\n    }\\n    \\n    bool hasNext() {\\n\\t//return true when stack is not empty else false\\n        return !st.empty();\\n    }\\n    \\n\\t//Initialize stack with all elements left to the root, including root\\n    private: \\n        void stackFill(TreeNode* root){\\n            \\n            while(root){\\n                st.push(root);\\n                root = root->left;\\n            }\\n        }\\n};\\n\\nNote: For better understanding and learning, consider dry running code yourself.\\n\\t\\t  For doubts and suggestions comment below.\\n\\n**PLEASE UPVOTE IF HELPFUL!!!**",
                "codeTag": "Java"
            },
            {
                "id": 1980827,
                "title": "one-template-to-solve-multiple-problems-c-time-o-n-space-o-h",
                "content": "> You could also visit my [blog post](https://manishyadav.dev/blog/binary-tree-traversal) to visually see how we need to make minimal code changes with just one template. Below posted version is copied directly from it\\n\\nOne common interview problem that commonly gets asked by interviewer is to write an in-order binary tree traversal algorithm. This deceptively simple problem in my own opinion is harder than it looks like. Although the recursive version is tidier, it hides the complexity that goes behind it. I, too, ended up memorizing those three lines, only to later realize that sometimes it was much harder to come up with a solution to a problem based on in-order traversal only using recursion.\\n\\n### Inorder Binary Search Tree Traversal\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\\n\\nRecall our good ol\\' recursive in-order traversal.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\\nLike a compiler, we can mechanically [convert our function calls to use an explicit stack](https://www.baeldung.com/cs/convert-recursion-to-iteration), but readibility/memoribility would suffer.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n        }\\n    }\\n};\\n```\\n\\nThe in-order traversal requires that we print the leftmost node first and the right most node at the end. So basically for each node we need to go as far as down and left as possible. So the line `inorder(root->left)` could be replaced with a while loop to have similar effect.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        root = root->right;\\n        }\\n    }\\n};\\n```\\n\\nNow we need to retrieve the top node and store it\\'s right child if it exists\\n\\n\\nAn iterative solution can help us solve multiple tree problems, and the same template could be used for multiple problems.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        \\n        root = root->right;\\n        }\\n    }\\n};\\n```\\n\\nLet\\'s use the same template we created earlier to solve multiple leetcode problem using the same pattern\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        stack<TreeNode*> nodes;\\n        vector<int> result;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        result.push_back(root->val);\\n        \\n        \\n        root = root->right;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\nFor leetcode problem [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal), we need to return a list of node so rather than printing. This could be solved by storing the values in a list and returning it.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) {\\n            return true;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nSimilarly, in order to [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) could be solved by verifying if the in-order traversal is in ascending order\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        k--;\\n        if (k == 0) return root->val;\\n        \\n        \\n        root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nFind [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/) by simply breaking at kth element\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (root->val == val) return root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```\\n\\n[Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/) becomes much simpler and one needs to simply check for `val` you are looking for.\\n\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, int val) {\\n        TreeNode* head = new TreeNode(-1);\\n        TreeNode* prev = head;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        prev->right = root;\\n        prev = prev->right;\\n        root->left = NULL;\\n        \\n        \\n        root = root->right;\\n        }\\n        return head->right;\\n    }\\n};\\n```\\n\\n[Increasing Order Search Tree](https://leetcode.com/problems/increasing-order-search-tree/) has similar intuition. Each time we meet a node, link it like a linked list using the right pointer. To facilitate the linking, create a dummy head\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* head) {\\n        TreeNode* first = NULL;\\n        TreeNode* second = NULL;\\n        TreeNode* root = head;\\n        TreeNode* prev = NULL;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (prev != NULL && prev->val > root->val) {\\n                if (first == NULL) {\\n                    first = prev;\\n                }\\n                second = root;\\n            }\\n            prev = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        swap(first->val, second->val);\\n};\\n```\\n\\nFor [Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/), the question boils down to to find \"2\" elements in a given sorted arrangement , such that both of these elements violate the \"sorted\" order, and swap them back to their original places.\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* convertBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        TreeNode* head = root;\\n        \\n        int sum = 0;\\n        int current_val;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->right;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        current_val = root->val;\\n        root->val = root->val + sum;\\n        sum += current_val;\\n        \\n        \\n        root = root->left;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nFor [Convert BST to Greater Tree](https://leetcode.com/problems/convert-bst-to-greater-tree/), The solution is the modification of inorder travel. Namely, travel right subtree, change the root value, and travel left subtree.\\n\\n```cpp\\nclass BSTIterator {\\n    stack<TreeNode*> nodes;\\n    TreeNode* head;\\n    int result;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = root;\\n        \\n        while(head) {\\n            s.push(head);\\n            head = head->left;\\n        }\\n    }\\n    \\n    int next() {\\n        head = s.top(); s.pop();\\n        result = head->val;\\n        if (head->right) {\\n            head = head->right;\\n            \\n            while(head) {\\n              s.push(head);\\n              head = head->left;  \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```\\n\\nOnce you have realized the pattern, you could see [Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/) problem has the exact same structure\\n 1. Some initialization.\\n 2. A while-loop with a condition that tells whether there is more.\\n 3. The loop body gets the next value and does something with it.\\n\\nThat\\u2019s it! I hope you enjoyed the explanation, not only we managed to understand inorder binary search tree traversal but also managed to solve handful leetcode problems as well and feel free to reach out to me on how I could improve its clarity.\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        //Traverse to the left most node\\n        inorder(root -> left);\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        inorder(root -> right);\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        //Traverse to the left most node\\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        //Go to the right node\\n        root = root->right;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        cout << root -> val << endl;\\n        \\n        root = root->right;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> inorderTraversal(TreeNode* root) {\\n        if (!root) {\\n            return {};\\n        }\\n        stack<TreeNode*> nodes;\\n        vector<int> result;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        result.push_back(root->val);\\n        \\n        \\n        root = root->right;\\n        }\\n        return result;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) {\\n            return true;\\n        }\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        k--;\\n        if (k == 0) return root->val;\\n        \\n        \\n        root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* searchBST(TreeNode* root, int val) {\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (root->val == val) return root;\\n        \\n        \\n        root = root->right;\\n        }\\n        return NULL;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* increasingBST(TreeNode* root, int val) {\\n        TreeNode* head = new TreeNode(-1);\\n        TreeNode* prev = head;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        prev->right = root;\\n        prev = prev->right;\\n        root->left = NULL;\\n        \\n        \\n        root = root->right;\\n        }\\n        return head->right;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void recoverTree(TreeNode* head) {\\n        TreeNode* first = NULL;\\n        TreeNode* second = NULL;\\n        TreeNode* root = head;\\n        TreeNode* prev = NULL;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->left;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        if (prev != NULL && prev->val > root->val) {\\n                if (first == NULL) {\\n                    first = prev;\\n                }\\n                second = root;\\n            }\\n            prev = root;\\n        \\n        \\n        root = root->right;\\n        }\\n        swap(first->val, second->val);\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* convertBST(TreeNode* root, int val) {\\n        if (!root) return NULL;\\n        TreeNode* head = root;\\n        \\n        int sum = 0;\\n        int current_val;\\n\\n        stack<TreeNode*> nodes;\\n        \\n        while(root || !nodes.empty()) {\\n            while(root) {\\n                nodes.push(root);\\n                root = root->right;\\n            }\\n\\n        root = nodes.top(); nodes.pop();\\n        //Magic goes here\\n        current_val = root->val;\\n        root->val = root->val + sum;\\n        sum += current_val;\\n        \\n        \\n        root = root->left;\\n        }\\n        return head;\\n    }\\n};\\n```\n```cpp\\nclass BSTIterator {\\n    stack<TreeNode*> nodes;\\n    TreeNode* head;\\n    int result;\\npublic:\\n    BSTIterator(TreeNode* root) {\\n        head = root;\\n        \\n        while(head) {\\n            s.push(head);\\n            head = head->left;\\n        }\\n    }\\n    \\n    int next() {\\n        head = s.top(); s.pop();\\n        result = head->val;\\n        if (head->right) {\\n            head = head->right;\\n            \\n            while(head) {\\n              s.push(head);\\n              head = head->left;  \\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    bool hasNext() {\\n        return !s.empty();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1967147,
                "title": "js-simple-explained-stack-optimal",
                "content": "# 173. Binary Search Tree Iterator \\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n<!-- ### Index:\\n1. [Explaining the Question](#explaining-the-question)\\n2. [Recommended Knowledge](#what-do-we-know)\\n3. [What do we know](#recommended-knowledge)\\n4. [Solution Explanation](#how-were-going-to-do-it)\\n5. [Big *O* Notation](#big-o-notation)\\n6. [Leetcode Results](#leetcode-results)\\n7. [Solution](#the-solution) -->\\n\\n## Explaining The Question\\nWe have a class based question. Where we need to implement a class that can iterate through a binary search tree. Where it can see if their is a next `node` and to be able to move to the next `node`. All done in a `in-order` way. \\n***\\n\\n##  Recommended Knowledge\\n1. Binary Tree\\n2. Binary Search Trees\\n3. Binary Tree - Depth First Search (Recursive In-Order Traversal)\\n4. Stacks\\n5. Classes / Object Oriented Programming\\n\\n\\n## What do we know?\\n1. We have a Binary Search Tree and we need to implement a Tree Iterator.\\n2. We need to create a `hasNext()` which returns a boolean. This method asks if there is a number that exists to the `right`.\\n3. We also need to implement a `next` method, which moves the pointer to the `right` and returns the value at that pointer.\\n4. Our methods can be done in **O(1)** time. Our space is **O(h)**\\n\\n## How we\\'re going to do it:\\n1. We\\'re going to perform a ***In-Order Traversal*** in reverse so we can get all the right most `nodes` onto of the ***stack***. We do this because otherwise we need to use a Queue, which is very poor in Javascript. ***Stacks*** are just great for performance.\\n2. After performing our traversal, we can now move ahead with the other operations.\\n3. For the `next()` function, all we do is pop off the stack. As that is the next item in the list. Then set it to the current `node`\\n4. For` hasNext()`, we just **ask if the length of the list is > 0**\\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes the tree has | As we will always be traversing the entire tree\\n* Space Complexity: *O(**h**)* | As we will be using a ***Stack*** to store the nodes \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 131 ms faster than ***85.64%*** of JavaScript online submissions for Binary Search Tree Iterator.\\n* Memory Usage: 55.6 MB, less than ***49.86***% of JavaScript online submissions for Binary Search Tree Iterator.\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/684209937/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar BSTIterator = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                      173. Binary Search Tree Iterator                      */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n    /* ----------------------------- Solution Below ----------------------------- */\\n\\n    // Node, this will update whenever we make moves\\n    this.node = root;\\n\\n    // A stack that will be used to get the in-order traversal of the list\\n    this.stack = [];\\n\\n    // Function to get the in-order traversal of the list\\n    const bst_in_order = (node) => {\\n        \\n        // Leaf node? Return up the call stack\\n        if (!node) {\\n            return null;\\n        }\\n\\n        // Go to the right most node\\n        bst_in_order(node.right);\\n\\n        // Once as far right as we can get\\n        // add to the stack\\n        this.stack.push(node);\\n\\n        // Get the left nodes\\n        bst_in_order(node.left);\\n    };\\n\\n    // Populate our stack\\n    bst_in_order(root);\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    // Constant Time: O(1)\\n\\n    // As we already have a stack populated with our\\n    // in-order traversal, all we have to do is take the top\\n    // of the stack and we\\'re all good.\\n    this.node = this.stack.pop();\\n    return this.node.val;\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    // Constant Time: O(1)\\n\\n    // So is their anything in the stack at all?\\n    // What this mean\\'s is. If I am empty, return false, if not\\n    // return true.\\n\\n    return this.stack.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar BSTIterator = function (root) {\\n\\n    /* -------------------------------------------------------------------------- */\\n    /*                      173. Binary Search Tree Iterator                      */\\n    /* -------------------------------------------------------------------------- */\\n\\n    /**\\n\\t * @author  Samuel Hinchliffe\\n\\t * @see    {@link linkedin.com/in/samuel-hinchliffe-\\uD83D\\uDE80-2bb5801a5/ | Author\\'s Linkedin }\\n\\t * @see    {@link github.com/Samuel-Hinchliffe}\\n\\t */\\n\\n    /* ----------------------------- Solution Below ----------------------------- */\\n\\n    // Node, this will update whenever we make moves\\n    this.node = root;\\n\\n    // A stack that will be used to get the in-order traversal of the list\\n    this.stack = [];\\n\\n    // Function to get the in-order traversal of the list\\n    const bst_in_order = (node) => {\\n        \\n        // Leaf node? Return up the call stack\\n        if (!node) {\\n            return null;\\n        }\\n\\n        // Go to the right most node\\n        bst_in_order(node.right);\\n\\n        // Once as far right as we can get\\n        // add to the stack\\n        this.stack.push(node);\\n\\n        // Get the left nodes\\n        bst_in_order(node.left);\\n    };\\n\\n    // Populate our stack\\n    bst_in_order(root);\\n};\\n\\nBSTIterator.prototype.next = function () {\\n    // Constant Time: O(1)\\n\\n    // As we already have a stack populated with our\\n    // in-order traversal, all we have to do is take the top\\n    // of the stack and we\\'re all good.\\n    this.node = this.stack.pop();\\n    return this.node.val;\\n};\\n\\nBSTIterator.prototype.hasNext = function () {\\n    // Constant Time: O(1)\\n\\n    // So is their anything in the stack at all?\\n    // What this mean\\'s is. If I am empty, return false, if not\\n    // return true.\\n\\n    return this.stack.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1967129,
                "title": "c-recursion-inorder-traversal",
                "content": "```\\nclass BSTIterator {\\nprivate:\\n    int k;\\n    vector<int> ans;\\npublic:\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n        k=-1;\\n    }\\n    \\n    int next() {\\n        k++;\\n        return ans[k];\\n    }\\n    \\n    bool hasNext() {\\n        if((k+1)<ans.size()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass BSTIterator {\\nprivate:\\n    int k;\\n    vector<int> ans;\\npublic:\\n    void inorder(TreeNode *root)\\n    {\\n        if(!root){\\n            return;\\n        }\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n        k=-1;\\n    }\\n    \\n    int next() {\\n        k++;\\n        return ans[k];\\n    }\\n    \\n    bool hasNext() {\\n        if((k+1)<ans.size()){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1966981,
                "title": "easy-solution-python",
                "content": "I just made a stack out of a tree and popped elements off the stack as long as possible.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.mystack = []\\n        self.makeStack(root)\\n        self.mystack.reverse()\\n        return None\\n        \\n\\n    def makeStack(self, root):\\n        if root == None:\\n            return root\\n        self.makeStack(root.left)\\n        self.mystack.append(root.val)\\n        self.makeStack(root.right)\\n        \\n    def next(self) -> int:\\n        if self.mystack == None:\\n            return None\\n        return self.mystack.pop(-1)\\n\\n    def hasNext(self) -> bool:\\n        if self.mystack:\\n            return True\\n        else:\\n            return False\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "I just made a stack out of a tree and popped elements off the stack as long as possible.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass BSTIterator:\\n\\n    def __init__(self, root: Optional[TreeNode]):\\n        self.mystack = []\\n        self.makeStack(root)\\n        self.mystack.reverse()\\n        return None\\n        \\n\\n    def makeStack(self, root):\\n        if root == None:\\n            return root\\n        self.makeStack(root.left)\\n        self.mystack.append(root.val)\\n        self.makeStack(root.right)\\n        \\n    def next(self) -> int:\\n        if self.mystack == None:\\n            return None\\n        return self.mystack.pop(-1)\\n\\n    def hasNext(self) -> bool:\\n        if self.mystack:\\n            return True\\n        else:\\n            return False\\n\\n\\n# Your BSTIterator object will be instantiated and called as such:\\n# obj = BSTIterator(root)\\n# param_1 = obj.next()\\n# param_2 = obj.hasNext()",
                "codeTag": "Java"
            },
            {
                "id": 1966715,
                "title": "easy-cpp-inorder",
                "content": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> v; int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    int next() {\\n        int ele =  v[i];\\n        i++;\\n        return ele;\\n    }\\n    bool hasNext() {\\n        if(i>=v.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass BSTIterator {\\npublic:\\n    vector<int> v; int i=0;\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    BSTIterator(TreeNode* root) {\\n        inorder(root);\\n    }\\n    int next() {\\n        int ele =  v[i];\\n        i++;\\n        return ele;\\n    }\\n    bool hasNext() {\\n        if(i>=v.size()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568996,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1566291,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568762,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567900,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567901,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567750,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1677525,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1576643,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571378,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571379,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568996,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1566291,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1568762,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567900,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567901,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1567750,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1677525,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1576643,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571378,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            },
            {
                "id": 1571379,
                "content": [
                    {
                        "username": "hiravi",
                        "content": "Why not simply traverse the bst in-order and add everything to a list?\\nThen for hasNext you get length of list(or keep length counter which is even faster)\\nand for Next you simply pop the first element off the list O(1).\\n\\nThe storage would be O(n) for initialize but next/hasnext don't use extra space."
                    },
                    {
                        "username": "Hritik__k",
                        "content": "To get better space complexity of O(height)"
                    },
                    {
                        "username": "silyows",
                        "content": "I tried deleting my cookie and all my code but my C++ code still does not work. I am using google chrome. This happened to me once for another problem too. That time I fixed it by refreshing my page.\\n\\nError message:\\nExpected JSON [[\"BSTIterator\",\"hasNext\",\"next\",\"hasNext\"]] to be of type JSMN_PRIMITIVE but got JSMN_STRING."
                    },
                    {
                        "username": "__declspec",
                        "content": "Why do we need to optimise code to O(h) \\nO(h) is not better than O(n) in worse case\\nJust like optimising bubble sort to deterministic quicksort, why\\nhar har har\\non99?\\nnvm leetcode \\xAF\\\\\\\\_(\\u30C4)_/\\xAF"
                    },
                    {
                        "username": "Rishabh__A",
                        "content": "[@eigentejas](/eigentejas) nope. h != log(n) in worst case. h = n in worst case. Think of skew tree. However on avg O(h) will be quicker than O(n).\\n"
                    },
                    {
                        "username": "eigentejas",
                        "content": "h = log(n) in worst case. So O(h) = O(log n) is much better than O(n)."
                    },
                    {
                        "username": "butterman1986",
                        "content": "The meaning of next smallest is as follows. Imagine that the input is a valid BST. Traverse the nodes in order that they would be visited in an in-order traversal. See examples below:\\n\\nEx 1:\\n    3(root)\\n2(left of 3)     4(Right of 3)\\n\\n-next should return the nodes in the following order: 2, 3, 4\\n\\nEx 2:\\n   3(root)\\nnull(left of 3)    4(right of 3)\\n-next should return the nodes in the following order: 3, 4"
                    },
                    {
                        "username": "Erudy",
                        "content": "I also used the stack method, but I wander whether it's a O(1) solution for next()."
                    },
                    {
                        "username": "mahesh105",
                        "content": "For next it is O(H) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 20.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/binary-search-tree-iterator/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Flattening the BST\n\n  \n**Approach 2:** Controlled Recursion\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "aarushsharmaa",
                        "content": "I am confused after solving it once 5-6 months back. Can someone explain the intuition behind what this problem requires us to acheive?"
                    },
                    {
                        "username": "shinne",
                        "content": "a BST is basically an sorted Array. [1,2,3,4,5]. Once you do an inorder traversal to add them all to the array. You can do the figure out the next() and hasNext() functions. \\n\\nThe next() would just be an integer value that initialized at 0 because you just want to get the index value when next() is called. \\n\\nhasNext() just needs to check if you\\'re within the range of the array size. "
                    },
                    {
                        "username": "nadirvardar",
                        "content": "My understanding is, BSTIterator gets a Binary Search Tree through its Constructor. and it is asked if the class can expose next() and hasNext() methods to iterate over Binary Search Tree as in-order BST traversal.\\n\\nClient will write code as follows;\\n\\nBSTIterator obj = new BSTIterator(root);\\nwhile (obj,hasNext()) {\\n  // do st with ob.next();\\n}\\n\\nIt is expected to traverse entire BST as in-order BST"
                    },
                    {
                        "username": "01amanporwal",
                        "content": "i also can\\'t understand the meaning of this question"
                    },
                    {
                        "username": "RDXV",
                        "content": "The question said \"boolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false\". Shouldn\\'t it mean for case [7, 3, 15, null, null, 9, 20], hasNext() for 9 must be false because 9 does not have a right child as to the right of the pointer of 9, there is nothing? I understand the solution sees the stack.top() but the question is saying hasNext() sees existence of number to the right of pointer. Can someone explain if I am reading something wrong or the words of question are put in the wrong way?"
                    },
                    {
                        "username": "eveliao",
                        "content": "first i thought it's actually the smallest number, because when i input [5,0,10], the correct result is [0,5,10]. \\nbut if i input [5,0,10,#,#,9,11], expected answer is [0,0,0,5,9,10,11].\\nwhy?"
                    },
                    {
                        "username": "jingfuzhifu",
                        "content": "I really can understand the meaning of \"next smallest number in the BST\". \\n\\nCould anyone throw some explanation. Great thanks."
                    }
                ]
            }
        ]
    }
]