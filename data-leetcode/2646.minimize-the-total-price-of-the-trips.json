[
    {
        "title": "Minimize the Total Price of the Trips",
        "question_content": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n&nbsp;\nExample 1:\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 50\n\tedges.length == n - 1\n\t0 <= ai, bi <= n - 1\n\tedges represents a valid tree.\n\tprice.length == n\n\tprice[i] is an even integer.\n\t1 <= price[i] <= 1000\n\t1 <= trips.length <= 100\n\t0 <= starti, endi&nbsp;<= n - 1",
        "solutions": [
            {
                "id": 3421713,
                "title": "dfs-dp-explained-easy-why-bipartite-set-fails-video-solution",
                "content": "# Intuition\\nWill try to explain the logic in a way I myself came up with the final solution. \\n\\nQ. Can we convert the trips array to some other form such that I could directly compute the answer in a single traversal?\\nA. YES! Let\\u2019s try each trip and note down the number of times a node appears [let\\u2019s call this contribution of that node]\\n\\n\\nQ. Can I make a bipartite graph to solve this problem by using those nodes which would contribute the most? \\nA. No! It is not necessary that for every node which isn\\'t included you are bound to use the child of the same. For example a node P has 2 children A and B, A further has 1 child C. Let\\'s say the optimal solution is to halve B and C. If you use bipartite approach here then the graph is divided into {P,C} and {A,B} so you\\'re gonna halve either P&C or A&B which are not gonna be optimal. \\n\\nQ. What would be the brute way to solve this? \\nA. For each node there would be 2 possibilities i.e. to halve the price of that node vs not halving the price [although this would depend on the value of the parent], asymptotically we can say that trying for all the options would give us a TC of 2^n.\\n\\nQ. can I use DP to reduce the TC? \\nA. YES! Let\\u2019s say we mark any random node R as the root, now from this node R we can try to traverse the tree and we already would know the contribution of each node [from our last question], however now the problem is that a node can either be halved or could remain as it is. Let\\u2019s try for both possibilities! \\nIn the dfs call, I can use a flag for indicating if the value of the parent was set or not. On reaching on a node in this dfs call I could either have the total contribution of this node as [num of times this node appears in trip]\\\\*[score of this node] OR num of times this node appears in trip]\\\\*[score of this node]/2. \\nSince I have already rooted the tree hence for each node I can save the states. It would only require 2 variables to define the state of any node i.e. the node itself and whether it\\u2019s parent was set. Since the number of nodes are <=50. Hence the space at TC would also be limited to 50*2. Which is a small number. \\nThe code is self explanatory and have also provided a video solution for reference! \\nCheck the video solution: https://youtu.be/lHffgybzmWo\\nHappy coding!\\n\\n# Complexity\\n- Time complexity:\\nO(n*t)  where t is the number of trips and n is the number of nodes\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void makeContri(int node,vector<int>& curr,vector<int>& contri,int end,vector<vector<int>>& g,int p){\\n        curr.push_back(node);       //this node is present in the traversal\\n        if(end==node){              //we reached the required end node! \\n            for(auto& i:curr)   contri[i]++;   \\n            curr.pop_back();\\n            return;\\n        }\\n        for(auto& ch:g[node])   if(ch!=p)    makeContri(ch,curr,contri,end,g,node);\\n        curr.pop_back();        // pop the current node. \\n    }\\n    int dp[51][2];      // dp[i][j] for the ith node if it\\'s parent was halved or not! \\n    int dfs(vector<int>& contri,vector<int>& pr,int node,vector<vector<int>>& g,int p=-1,bool parentHalved=false){\\n        int res1=(contri[node]*pr[node])/2,res2=contri[node]*pr[node];\\n        \\n        if(dp[node][parentHalved]!=-1)   return dp[node][parentHalved];\\n        \\n        for(auto& ch:g[node])   if(ch!=p)   res2+=dfs(contri,pr,ch,g,node,0);\\n        if(parentHalved) return dp[node][parentHalved]=res2;      // can\\'t halve this node if parent was halved!\\n        \\n        for(auto& ch:g[node])   if(ch!=p)    res1+=dfs(contri,pr,ch,g,node,1);\\n        return dp[node][parentHalved]=min(res1,res2);\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        memset(dp,-1,sizeof dp);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<int> contri(n,0);        // number of times each node is traversed\\n        for(auto& t:trips){\\n            vector<int> curr;\\n            makeContri(t[0],curr,contri,t[1],g,-1);\\n        }// contribution of each node has been stored! \\n        \\n        return dfs(contri,price,0,g,-1,0);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void makeContri(int node,vector<int>& curr,vector<int>& contri,int end,vector<vector<int>>& g,int p){\\n        curr.push_back(node);       //this node is present in the traversal\\n        if(end==node){              //we reached the required end node! \\n            for(auto& i:curr)   contri[i]++;   \\n            curr.pop_back();\\n            return;\\n        }\\n        for(auto& ch:g[node])   if(ch!=p)    makeContri(ch,curr,contri,end,g,node);\\n        curr.pop_back();        // pop the current node. \\n    }\\n    int dp[51][2];      // dp[i][j] for the ith node if it\\'s parent was halved or not! \\n    int dfs(vector<int>& contri,vector<int>& pr,int node,vector<vector<int>>& g,int p=-1,bool parentHalved=false){\\n        int res1=(contri[node]*pr[node])/2,res2=contri[node]*pr[node];\\n        \\n        if(dp[node][parentHalved]!=-1)   return dp[node][parentHalved];\\n        \\n        for(auto& ch:g[node])   if(ch!=p)   res2+=dfs(contri,pr,ch,g,node,0);\\n        if(parentHalved) return dp[node][parentHalved]=res2;      // can\\'t halve this node if parent was halved!\\n        \\n        for(auto& ch:g[node])   if(ch!=p)    res1+=dfs(contri,pr,ch,g,node,1);\\n        return dp[node][parentHalved]=min(res1,res2);\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        memset(dp,-1,sizeof dp);\\n        for(auto& e:edges){\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector<int> contri(n,0);        // number of times each node is traversed\\n        for(auto& t:trips){\\n            vector<int> curr;\\n            makeContri(t[0],curr,contri,t[1],g,-1);\\n        }// contribution of each node has been stored! \\n        \\n        return dfs(contri,price,0,g,-1,0);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421674,
                "title": "python3-dfs-dp-with-comments",
                "content": "Since it is a tree, there are no cycles, and for any (start, end) pair in trips, there is only one path. So we compute all paths first, and keep counting how many times each single node has been used/visited.\\n\\nTo find the maximum cost we can reduce, we can use dp to check which is the optimal combination of reducing the node cost to half.\\n\\n```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    \\t# Creating the undirected graph\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # Use this counter to count how many time each node are used for all paths.\\n        count = Counter()\\n        # The totalCost if we don\\'t reduce any node cost to half\\n        totalCost = 0\\n        # dfs to find the path from start node to end node.\\n        # Add the cost to total cost for each node on the path.\\n        # Also keep counting how many times each node are used for all paths in trips.\\n        # Since it is an undirected tree, even though there are no cycles, we can still travel back from the parent node. So keep the parent to avoid going backward of the tree.\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n        # For each trip, we compute the path and update the totalCost, and count how many times each node is being used. \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n        # The dp function to find the optimal combination of which node should be reduced.\\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n                \\t# if the cost of the current node can be reduced, we have only one option moving forward => do not reduce\\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n                    # if the cost of the current node can not be reduced, we have two options, either reduce it for the neighbor node or don\\'t reduce it for the neighbor node.\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n        # We find the maximum reduction using the dp function.\\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n        # reduce the total cost\\n        return totalCost - reduce\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    \\t# Creating the undirected graph\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        # Use this counter to count how many time each node are used for all paths.\\n        count = Counter()\\n        # The totalCost if we don\\'t reduce any node cost to half\\n        totalCost = 0\\n        # dfs to find the path from start node to end node.\\n        # Add the cost to total cost for each node on the path.\\n        # Also keep counting how many times each node are used for all paths in trips.\\n        # Since it is an undirected tree, even though there are no cycles, we can still travel back from the parent node. So keep the parent to avoid going backward of the tree.\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n        # For each trip, we compute the path and update the totalCost, and count how many times each node is being used. \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n        # The dp function to find the optimal combination of which node should be reduced.\\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n                \\t# if the cost of the current node can be reduced, we have only one option moving forward => do not reduce\\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n                    # if the cost of the current node can not be reduced, we have two options, either reduce it for the neighbor node or don\\'t reduce it for the neighbor node.\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n        # We find the maximum reduction using the dp function.\\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n        # reduce the total cost\\n        return totalCost - reduce\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421847,
                "title": "c-dfs-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach node is involved in some trip(0 or more times), In order to get minimum sum we need a count of the times a node will be visited in all trips. Halving the price for current node will disable halving of its adjecents. Need to consider these points while finding Minimum Path Sum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nModification of minimum/maximum no-adjecent sum path in Tree\\n\\n# Complexity\\n- Time complexity: \\n$$O(N)$$ (Since number of trips are constant (i.e. 100)) --> 100 * N --> N\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\n// Approach: DFS\\n// Modification of minimum/maximum no-adjecent sum path in Tree\\n\\nclass Solution {\\npublic:\\n    int demand[100];\\n    vector<int> adj[100];\\n\\n    // fill demand in terms of how many times current node will be vistited in all trips\\n    int isInPath(int u,int dest,int p = -1){\\n\\n        if(u == dest) {\\n            demand[dest]++;\\n            return 1;\\n        }\\n        for(auto v: adj[u]) {\\n            if(v == p) continue;\\n\\n            if(isInPath(v,dest,u)) {\\n                demand[u]++;\\n                return 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    // Pair represents: minimum sum with {current Node halved, current node not halved}\\n    // Observations: If you halve the current node then you cannot halve its adjcent)\\n    pair<int,int> minNonAdjecentPath(int u,int p, vector<int>& price) {\\n        int considerCurrent = (price[u]/2) * (demand[u])   ;\\n        int dontConsiderCurrent = price[u] * demand[u];\\n\\n        for(auto v: adj[u]){\\n            if(v == p)continue;\\n\\n            pair<int,int> childAns = minNonAdjecentPath(v,u,price);\\n            // Take minimum of both consider and not consider case of childs\\n            dontConsiderCurrent += min(childAns.first, childAns.second);\\n\\n            // You can only take values where child node is not halved\\n            considerCurrent += childAns.second;\\n        }\\n        // return current answer\\n        return {considerCurrent, dontConsiderCurrent};\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // cleanup\\n        memset(demand,0, sizeof demand);\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n\\n        // graph formation\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        // fill demand for nodes\\n        for(auto trip: trips) {\\n            int u = trip[0];\\n            int v = trip[1];\\n\\n            isInPath(u,v);\\n        }\\n\\n\\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price);\\n\\n        return min(ans.first, ans.second);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Approach: DFS\\n// Modification of minimum/maximum no-adjecent sum path in Tree\\n\\nclass Solution {\\npublic:\\n    int demand[100];\\n    vector<int> adj[100];\\n\\n    // fill demand in terms of how many times current node will be vistited in all trips\\n    int isInPath(int u,int dest,int p = -1){\\n\\n        if(u == dest) {\\n            demand[dest]++;\\n            return 1;\\n        }\\n        for(auto v: adj[u]) {\\n            if(v == p) continue;\\n\\n            if(isInPath(v,dest,u)) {\\n                demand[u]++;\\n                return 1;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    // Pair represents: minimum sum with {current Node halved, current node not halved}\\n    // Observations: If you halve the current node then you cannot halve its adjcent)\\n    pair<int,int> minNonAdjecentPath(int u,int p, vector<int>& price) {\\n        int considerCurrent = (price[u]/2) * (demand[u])   ;\\n        int dontConsiderCurrent = price[u] * demand[u];\\n\\n        for(auto v: adj[u]){\\n            if(v == p)continue;\\n\\n            pair<int,int> childAns = minNonAdjecentPath(v,u,price);\\n            // Take minimum of both consider and not consider case of childs\\n            dontConsiderCurrent += min(childAns.first, childAns.second);\\n\\n            // You can only take values where child node is not halved\\n            considerCurrent += childAns.second;\\n        }\\n        // return current answer\\n        return {considerCurrent, dontConsiderCurrent};\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // cleanup\\n        memset(demand,0, sizeof demand);\\n        for(int i=0;i<n;i++){\\n            adj[i].clear();\\n        }\\n\\n        // graph formation\\n        for(auto edge: edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n\\n        // fill demand for nodes\\n        for(auto trip: trips) {\\n            int u = trip[0];\\n            int v = trip[1];\\n\\n            isInPath(u,v);\\n        }\\n\\n\\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price);\\n\\n        return min(ans.first, ans.second);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422359,
                "title": "c-dfs-dp-with-intuition-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere in this question, doing bipartite algo on the tree will not work because, we are not forced to take alternative nodes means if we have taken the node at level x then at level x + 1 we can not take the node, but at level x + 2 we have two choice whether we take the node and not take the node. (Here take and not take means divide and not divide). \\n\\nBecuase of this many participants solution was failing on some testcase whose expected output was 429 but using bipartite algo on it, it was giving 434. So let\\'s move to the original approach which is dp.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncount how many time each node appears throughout the whole trip arrays and make the global array `cnt` which keeps track of the frequency of all the node in all the trips.\\n\\nExamle: For test case 1 of the question `cnt` array will look like `[1,3,2,2].`\\n\\nNow apply dynamic programming on the tree.\\nFor the dp we have two states, 1. current node, 2. current node\\'s parent was taken or not (means parent\\'s values was divided or not)\\n\\nThere are two cases based on the parent taken or not.\\n1. if parent is taken, then we can not take any child of it.\\n2. if parent is not taken, then we can or can not take any child of it. (because either of it can give the best answer possible)\\n\\nThis is it.. Now what left is the implementation of the problem.\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    bool process(int node, int par, int dst, vector<int> &count, vector<int> adj[])\\n    {\\n        if (node == dst)\\n            return true;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                if (process(i, node, dst, count, adj))\\n                {\\n                    count[i]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int dp[51][2];\\n    int dfs(int node, int par, bool par_taken, vector<int> &cnt, vector<int> &price, vector<int> adj[])\\n    {\\n        if (dp[node][par_taken] != -1)\\n            return dp[node][par_taken];\\n\\n        int childs = 0;\\n        for (auto i : adj[node])\\n            if (i != par)\\n                childs++;\\n\\n        if (childs == 0)\\n        {\\n            if (par_taken)\\n                return dp[node][par_taken] = cnt[node] * (price[node]);\\n            return dp[node][par_taken] = cnt[node] * (price[node] / 2);\\n        }\\n\\n        if (par_taken)\\n        {\\n            int ans = 0;\\n            for (auto i : adj[node])\\n                if (i != par)\\n                    ans += dfs(i, node, false, cnt, price, adj);\\n            ans += cnt[node] * price[node];\\n            return dp[node][par_taken] = ans;\\n        }\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                ans1 += dfs(i, node, false, cnt, price, adj);\\n                ans2 += dfs(i, node, true, cnt, price, adj);\\n            }\\n        }\\n        ans1 += cnt[node] * (price[node]);\\n        ans2 += cnt[node] * (price[node] / 2);\\n        return dp[node][par_taken] = min(ans1, ans2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> adj[n];\\n        for (auto i : edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<int> cnt(n);\\n        for (auto i : trips)\\n        {\\n            cnt[i[0]]++;\\n            process(i[0], -1, i[1], cnt, adj);\\n        }\\n\\n        return dfs(0, -1, false, cnt, price, adj);\\n    }\\n};\\n```\\n\\n### Please upvote if you understood and found it to be helpful.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool process(int node, int par, int dst, vector<int> &count, vector<int> adj[])\\n    {\\n        if (node == dst)\\n            return true;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                if (process(i, node, dst, count, adj))\\n                {\\n                    count[i]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int dp[51][2];\\n    int dfs(int node, int par, bool par_taken, vector<int> &cnt, vector<int> &price, vector<int> adj[])\\n    {\\n        if (dp[node][par_taken] != -1)\\n            return dp[node][par_taken];\\n\\n        int childs = 0;\\n        for (auto i : adj[node])\\n            if (i != par)\\n                childs++;\\n\\n        if (childs == 0)\\n        {\\n            if (par_taken)\\n                return dp[node][par_taken] = cnt[node] * (price[node]);\\n            return dp[node][par_taken] = cnt[node] * (price[node] / 2);\\n        }\\n\\n        if (par_taken)\\n        {\\n            int ans = 0;\\n            for (auto i : adj[node])\\n                if (i != par)\\n                    ans += dfs(i, node, false, cnt, price, adj);\\n            ans += cnt[node] * price[node];\\n            return dp[node][par_taken] = ans;\\n        }\\n\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        for (auto i : adj[node])\\n        {\\n            if (i != par)\\n            {\\n                ans1 += dfs(i, node, false, cnt, price, adj);\\n                ans2 += dfs(i, node, true, cnt, price, adj);\\n            }\\n        }\\n        ans1 += cnt[node] * (price[node]);\\n        ans2 += cnt[node] * (price[node] / 2);\\n        return dp[node][par_taken] = min(ans1, ans2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>> &edges, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        memset(dp, -1, sizeof(dp));\\n        vector<int> adj[n];\\n        for (auto i : edges)\\n        {\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n\\n        vector<int> cnt(n);\\n        for (auto i : trips)\\n        {\\n            cnt[i[0]]++;\\n            process(i[0], -1, i[1], cnt, adj);\\n        }\\n\\n        return dfs(0, -1, false, cnt, price, adj);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421861,
                "title": "python3-dfs",
                "content": "\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        tree = [[] for _ in range(n)] \\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        freq = [0]*n\\n        for s, e in trips: \\n            queue = deque([(s, -1)])\\n            parent = {s : -1}\\n            while queue: \\n                u, p = queue.popleft()\\n                if u == e: break \\n                for v in tree[u]: \\n                    if v != p: \\n                        queue.append((v, u))\\n                        parent[v] = u\\n            u = e \\n            while u >= 0: \\n                freq[u] += 1\\n                u = parent[u]\\n            \\n        def dfs(u, p):\\n            \"\"\"Return \"\"\"\\n            full = half = 0 \\n            for v in tree[u]: \\n                if v != p: \\n                    ff, hh = dfs(v, u)\\n                    full += ff\\n                    half += min(ff, hh)\\n            return price[u]*freq[u] + half, price[u]*freq[u]//2 + full\\n            \\n        return min(dfs(0, -1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        tree = [[] for _ in range(n)] \\n        for u, v in edges: \\n            tree[u].append(v)\\n            tree[v].append(u)\\n        freq = [0]*n\\n        for s, e in trips: \\n            queue = deque([(s, -1)])\\n            parent = {s : -1}\\n            while queue: \\n                u, p = queue.popleft()\\n                if u == e: break \\n                for v in tree[u]: \\n                    if v != p: \\n                        queue.append((v, u))\\n                        parent[v] = u\\n            u = e \\n            while u >= 0: \\n                freq[u] += 1\\n                u = parent[u]\\n            \\n        def dfs(u, p):\\n            \"\"\"Return \"\"\"\\n            full = half = 0 \\n            for v in tree[u]: \\n                if v != p: \\n                    ff, hh = dfs(v, u)\\n                    full += ff\\n                    half += min(ff, hh)\\n            return price[u]*freq[u] + half, price[u]*freq[u]//2 + full\\n            \\n        return min(dfs(0, -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421671,
                "title": "c-bfs-dfs-preprocessing-dp-intuition",
                "content": "\\n**KEY OBSERVATION** For any given tree, there is only ONE PATH from node a to node b. This means the same path will always be used, no matter how we change our node weights.\\n\\nThis allows us to do a preprocessing optimization: For each trip, log all nodes that it passes through. By doing this, we will know how many times each node is used. It is very important to understand this does not change no matter which node weights we reduce.\\nAlso because of this property we don\\'t need to keep track of a visited array for nodes because there are no cycles.\\n\\nApproach: For each trip, do a simple breadth-first-search from node A to node B, incrementing the path count of each node in the path by 1. Now, do a depth-first-search on an arbitrarily rooted tree (the tree can be arbitrarily rooted because we are searching all values anyways). We will have a boolean to keep track of whether we can reduce the weight of our current node. \\nOur DFS will have two cases: First, we will always try NOT reducing the weight of our node, because this is always an option. If reducing the weight of our node is an option, then we can reduce its weight and then search its children with the condition that their weight cannot be reduced. We keep a running sum of the answer; if our weight was not reduced, we add pathCount * price[pos] to our answer, if our weight was reduced, we add pathCount*price[pos]/2 to our answer.\\nWe return the minimum answer, that is, whether it is better to reduce the node weight or not reduce it.\\n\\nCODE:\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2] = {}; // dp optimization to not recalculate values\\n    int mp[51] = {}; // count how many times a node is used in trips\\n    typedef array<int, 2> ai;\\n    void countPaths(vector<vector<int>>& adj, int x, int y){\\n        queue<ai> q;\\n        q.push({x, -1});\\n        int vis[51] = {};\\n        int last[51] = {}; // so we can efficiently backtrack the path from node a to node b\\n        while(!q.empty()){\\n            auto [t, p] = q.front();\\n            q.pop();\\n            if(vis[t]++) continue;\\n            last[t] = p;\\n            if(t == y){\\n                while(t != -1){\\n                    mp[t]++; \\n                    t = last[t];\\n                } \\n                return;\\n            }\\n            for(auto i : adj[t]) q.push({i, t});\\n        }\\n    }\\n    int dfs(vector<vector<int>>& adj, int pos, vector<int>& price, vector<vector<int>>& trips, bool canTake, int last){\\n        if(dp[pos][canTake] != -1) return dp[pos][canTake];\\n        int ans = price[pos] * mp[pos];\\n        int res1 = 0, res2 = 0;\\n        for(auto i : adj[pos]) if(i != last) res1 += dfs(adj, i, price, trips, true, pos);\\n        if(canTake){\\n            for(auto i : adj[pos]) if(i != last) res2 += dfs(adj, i, price, trips, false, pos);\\n            ans = min(ans+res1, ans/2 + res2);\\n        }\\n        else ans = ans+res1;\\n        return dp[pos][canTake] = ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof dp);\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        for(auto& i : trips) countPaths(adj, i[0], i[1]);\\n        return dfs(adj, 0, price, trips, true, -1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[51][2] = {}",
                "codeTag": "Java"
            },
            {
                "id": 3422043,
                "title": "variation-of-house-robber-iii-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem has several steps.\\n1. Find shortest path in each trip using breadth-first search.\\n2. Count how many times each node appears in the trips.\\n2. Similar to [LC.337. House Robber III](https://leetcode.com/problems/house-robber-iii/). But this time, it is not rob or not rob, it is havle or whole (not havle), this step uses depth-first search.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1 is straightforward, and use a parent array to record the parent of current node, then rebuild the path.\\n\\nStep 2 use a hash map or a counter array to record how many times a node appears in all trips, it is computed in step 1.\\n\\nStep 3 is a little tricky. Use (post-order) depth-first search and return two values: One value is current node is computed without halving, and the other value is computed with havling. When current node is halving, because its adjacent nodes must be whole (not havle), so that whole (not havle) contains neighbors whose values are whole. When current node is whole (not havle), its adjacent nodes can be either whole or halved, so that we take the minimum between whole (not havle) and havle.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * numOfTrips).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n).\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());            \\n        }\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int[] trip : trips) {\\n            bfs(tree, trip[0], trip[1], counts);\\n        }\\n        int[] currPrice = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            currPrice[i] = counts.getOrDefault(i, 0) * price[i];\\n        }\\n        int[] result = helper(tree, 0, -1, currPrice);\\n        return Math.min(result[0], result[1]);\\n    }\\n    private int[] helper(List<List<Integer>> tree, int curr, int parent, int[] currPrice) {\\n        List<Integer> neighbors = tree.get(curr);\\n        int whole = 0;\\n        int halved = 0;\\n        for (int nei : neighbors) {\\n            if (nei == parent) {\\n                continue;\\n            }\\n            int[] neiResult = helper(tree, nei, curr, currPrice);\\n            whole += neiResult[0];\\n            halved += Math.min(neiResult[0], neiResult[1]);\\n        }\\n        return new int[] {currPrice[curr] + halved, currPrice[curr] / 2 + whole};\\n    }\\n    private void bfs(List<List<Integer>> tree, int src, int dst, Map<Integer, Integer> counts) {\\n        int n = tree.size();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        queue.offer(src);\\n        visited[src] = true;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (curr == dst) {\\n                break;\\n            }\\n            for (int nei : tree.get(curr)) {\\n                if (!visited[nei]) {\\n                    visited[nei] = true;\\n                    parent[nei] = curr;\\n                    queue.offer(nei);\\n                }\\n            }\\n        }\\n        int curr = dst;\\n        while (curr != -1) {\\n            counts.put(curr, counts.getOrDefault(curr, 0) + 1);\\n            curr  = parent[curr];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> tree = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            tree.add(new ArrayList<>());            \\n        }\\n        for (int[] edge : edges) {\\n            tree.get(edge[0]).add(edge[1]);\\n            tree.get(edge[1]).add(edge[0]);\\n        }\\n        Map<Integer, Integer> counts = new HashMap<>();\\n        for (int[] trip : trips) {\\n            bfs(tree, trip[0], trip[1], counts);\\n        }\\n        int[] currPrice = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            currPrice[i] = counts.getOrDefault(i, 0) * price[i];\\n        }\\n        int[] result = helper(tree, 0, -1, currPrice);\\n        return Math.min(result[0], result[1]);\\n    }\\n    private int[] helper(List<List<Integer>> tree, int curr, int parent, int[] currPrice) {\\n        List<Integer> neighbors = tree.get(curr);\\n        int whole = 0;\\n        int halved = 0;\\n        for (int nei : neighbors) {\\n            if (nei == parent) {\\n                continue;\\n            }\\n            int[] neiResult = helper(tree, nei, curr, currPrice);\\n            whole += neiResult[0];\\n            halved += Math.min(neiResult[0], neiResult[1]);\\n        }\\n        return new int[] {currPrice[curr] + halved, currPrice[curr] / 2 + whole};\\n    }\\n    private void bfs(List<List<Integer>> tree, int src, int dst, Map<Integer, Integer> counts) {\\n        int n = tree.size();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        queue.offer(src);\\n        visited[src] = true;\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            if (curr == dst) {\\n                break;\\n            }\\n            for (int nei : tree.get(curr)) {\\n                if (!visited[nei]) {\\n                    visited[nei] = true;\\n                    parent[nei] = curr;\\n                    queue.offer(nei);\\n                }\\n            }\\n        }\\n        int curr = dst;\\n        while (curr != -1) {\\n            counts.put(curr, counts.getOrDefault(curr, 0) + 1);\\n            curr  = parent[curr];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422763,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int count[100];\\n    vector<int>graph[100];\\n    int path(int node1,int node2,int p=-1)\\n    {\\n        if(node1==node2)\\n        {\\n            count[node1]++;\\n            return 1;\\n        }\\n        for(auto &it:graph[node1])\\n        {\\n            if(it!=p)\\n            {\\n                if(path(it,node2,node1))\\n                {\\n                    count[node1]++;\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    pair<int,int>find(int node,vector<int>&price,int parent=-1)\\n    {\\n        pair<int,int>p={count[node]*price[node],count[node]*price[node]/2};\\n        for(auto &it:graph[node])\\n        {\\n            if(it!=parent)\\n            {\\n                pair<int,int>current=find(it,price,node);\\n                p.first+=min(current.first,current.second);\\n                p.second+=current.first;\\n            }\\n        }\\n        return p;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto &it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto it:trips)\\n        {\\n            path(it[0],it[1]);\\n        }\\n        pair<int,int>p=find(0,price);\\n        return min(p.first,p.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int count[100];\\n    vector<int>graph[100];\\n    int path(int node1,int node2,int p=-1)\\n    {\\n        if(node1==node2)\\n        {\\n            count[node1]++;\\n            return 1;\\n        }\\n        for(auto &it:graph[node1])\\n        {\\n            if(it!=p)\\n            {\\n                if(path(it,node2,node1))\\n                {\\n                    count[node1]++;\\n                    return 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n    pair<int,int>find(int node,vector<int>&price,int parent=-1)\\n    {\\n        pair<int,int>p={count[node]*price[node],count[node]*price[node]/2};\\n        for(auto &it:graph[node])\\n        {\\n            if(it!=parent)\\n            {\\n                pair<int,int>current=find(it,price,node);\\n                p.first+=min(current.first,current.second);\\n                p.second+=current.first;\\n            }\\n        }\\n        return p;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto &it:edges)\\n        {\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        for(auto it:trips)\\n        {\\n            path(it[0],it[1]);\\n        }\\n        pair<int,int>p=find(0,price);\\n        return min(p.first,p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422052,
                "title": "dfs-dp-easiest-approach-similiar-to-house-robber",
                "content": "**Step1:**\\nFirst Calculate the new price of each node by multiply the price of a node to the the number of times you are visiting that node through all the trips.\\n\\nThe new price for a node for example1 \\nn = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\\n is **[2,6,20,12]** \\nAs **node 0** is being visited one time, **node 1** is being visited 3 times, **node 2** is being visited 2 times and **node 3** is being visited 2 times.\\n \\n I have stored the update price in total array.\\n \\n **Step2: dp+dfs**\\n\\t Apply dp+dfs similar to house robber **if you half a value then you cannot half its adjacent value so you take a jump of 2 and move to neighbour of neighbour of a node.**\\n   \\n        \\n    class Solution {\\n\\tpublic:\\n\\t// performing step1 as mentioned above\\n\\tbool dfs(vector<int>adj[], int s, int e, vector<int>&price, vector<int>&total, int par)\\n    {\\n        if(s==e)\\n        {\\n            total[e]+=price[e];\\n            return true;\\n        }\\n\\t\\tfor(auto i: adj[s])\\n        {\\n            if(i!=par)\\n            {\\n                bool b1 = dfs(adj,i,e,price,total,s);\\n                if(b1 == true)\\n                {\\n                    total[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n\\t// performing step2 as mentioned above\\n    int fn(vector<int>adj[], int node, vector<int>&vis, vector<int>&total, vector<int>&dp)\\n    {\\n        if(dp[node]!=-1) return dp[node];\\n        vis[node]=1;\\n        \\n        //take;\\n        int val = total[node]/2;\\n        for(auto i: adj[node])\\n        {\\n            if(vis[i]==0)\\n            {\\n                vis[i] =1;\\n                val+=total[i];\\n                for(auto j: adj[i])\\n                {\\n                    if(vis[j]==0)\\n                    {\\n                        val+= fn(adj,j,vis,total,dp);\\n                    }\\n                }\\n                vis[i]=0;\\n            }\\n        }\\n        // not take\\n        \\n        int nt = total[node];\\n        for(auto i: adj[node])\\n        {\\n            if(vis[i]==0) nt += fn(adj,i,vis,total,dp);\\n        }\\n        vis[node] = 0;\\n        return dp[node]= min(val,nt);\\n    }\\n    \\n\\t// main function\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        vector<int> adj[n];\\n        for(auto i: edges)\\n        {\\n            int a = i[0], b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        \\n        vector<int>total(n,0);\\n        for(auto i:trips)\\n        {\\n            int node1 = i[0], node2 = i[1];\\n            dfs(adj,node1, node2, price,total, -1);\\n        }\\n\\t\\t// step2 = dp+dfs;\\n        vector<int>vis(n,0);\\n        vector<int>dp(n,-1);\\n        int ans = fn(adj,0,vis,total,dp);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t// performing step1 as mentioned above\\n\\tbool dfs(vector<int>adj[], int s, int e, vector<int>&price, vector<int>&total, int par)\\n    {\\n        if(s==e)\\n        {\\n            total[e]+=price[e];\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3423598,
                "title": "python-3-detailed-explanation-with-approach-and-comments",
                "content": "Please upvote if you find it useful. It took a lot of time to make this post. \\uD83D\\uDE01\\uD83D\\uDE01\\n# Approach\\nThe solution uses dynamic programming and DFS traversal of the graph to compute the minimum total price. Here\\'s how it works:\\n\\n1. The input is the number of nodes n, the list of edges connecting nodes edges, the prices of the nodes price, and the list of trips trips.\\n\\n2. The edges are stored in a defaultdict of lists, adj, which represents an adjacency list for the graph. The adjacency list stores the neighbors of each node.\\n\\n3. The function makeContri is defined to compute the contributions of each node in the graph to the trips. It takes as input the starting node ***start***, the destination node ***end***, and a ***path*** list to store the path from start to end. The function adds start to the path and marks it as visited. If start is equal to end, it adds 1 to the contribution of each node in the path and returns True. Otherwise, it recursively explores the neighbors of start that have not been visited, adding them to the path and marking them as visited, until it reaches end or exhausts all neighbors. If it reaches end, it returns True. If it exhausts all neighbors, it removes start from the path and returns False.\\n\\n4. The contributions of each node are computed by iterating over the ***trips***, calling ***makeContri*** for each trip, and passing the start and end nodes of the trip. This updates the ***contri*** list, which stores the contributions of each node.\\n\\n5. The function dfs is defined to compute the minimum total price to reach the destination. It takes as input the current node node, the parent node parent, and a boolean used to indicate whether the current node\\'s parent has been halved in the previous step. The function checks if the current node and halve state have been visited before, and returns the stored result if they have. Otherwise, it computes two possible minimum total prices:\\n\\n    - res1 is the minimum total price if the current node\\'s parent is not halve, and is computed by summing up the prices of the nodes in the current connected component, divided by 2 and multiplied by their contributions, and recursively calling dfs on the neighbors of the current node that have not been visited.\\n\\n    - res2 is the minimum total price if the current node\\'s parent is halved, and is computed by summing up the prices of the nodes in the current connected component, multiplied by their contributions, and recursively calling dfs on the neighbors of the current node that have not been visited.\\n\\n    The minimum of res1 and res2 is stored in the dp dictionary and returned.\\n\\n6. Finally, dfs is called with the starting node 0, a dummy parent node -1, and the halve state False, and the minimum total price is returned.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # Part 1: Creating an adjacency list to traverse the graph\\n\\n        # Default dictionary with list as its default value.\\n        adj = defaultdict(list)\\n        \\n        # Traversing to each edge and adding it to its respective node\\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        # For Example 1, adjacency list will be:\\n        # adj = {0: [1], 1: [0, 2, 3], 2: [1], 3: [1]}\\n\\n        # <!--- Part 1 End ---!>\\n\\n\\n        # Part 2: Counting the contribution of each node\\n\\n        contri = [0] * n\\n\\n        # start -> Trip starting node\\n        # end -> Destination of trip\\n        # path -> Path from start to end\\n        def makeContri(start, end, path):\\n            # Add node to the path and visited\\n            path.add(start)\\n            visited.add(start)\\n\\n            # If this condition is True, we reached our end point\\n            if start == end:\\n                # We will increment contri of each node present in the path\\n                for node in path:\\n                    contri[node] += 1\\n                # Return True to stop further recursive searches\\n                return True\\n            \\n            # Else we will traverse recursively through the neighbours\\n            # until we reach the end node\\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            # If we don\\'t find the end node, then remove the node from\\n            # path and return False. \\n            path.remove(start)\\n            return False\\n        \\n        # Calling makeContri for each trip to find the contribution \\n        # of each node\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, set())\\n        \\n        # This updates the contri list, which stores the contributions \\n        # of each node\\n        # For Example 1, contri list will be\\n        # contri = [1, 3, 2, 2]\\n        # node :    0, 1, 2, 3\\n        # Now we know that \\'node 0\\' contributes 1 time\\n        #                  \\'node 1\\' contributes 3 times\\n        #                   and so on .....\\n\\n        # <!--- Part 2 End ---!>\\n\\n\\n        # Part 3: Dynamically execute all possibilities\\n\\n        # For a node, there are 2 possibilities\\n        # 1. If the price of the current node\\'s parent had been halved:\\n        #       In this case, we cannot halve the price of the current node.\\n        #       So, we recursively calculate the price without halving.\\n        # 2. or the price of the current node\\'s parent remains was not halved:\\n        #       Here, we can halve the price of current node or exclude it and \\n        #       calculate without halving it.\\n\\n        # Caching the result\\n        dp = {}\\n        \\n        # node -> current node\\n        # parent -> parent of current node\\n        # halve -> whether the parent node was halved or not\\n        def dfs(node, parent, halve):\\n            # if result in dp, return the result\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            # res1 -> result when halved\\n            # res2 -> result when not halved\\n            # Initialising it to infinity since the \\'if\\' statement \\n            # below may not get executed.\\n            res1 = float(\"inf\")\\n\\n            # if parent is not halved\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            # if parent is halved or we want to exclude halving\\n            # of current node. (Same for both possibilities)\\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            # Storing the minimum of both the result in dp\\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        # Calling dfs on node \\'0\\', fake parent as \\'-1\\', halved as \\'False\\'\\n        return dfs(0, -1, False)\\n```\\n\\n# Code without comments\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        def makeContri(start, end, path):\\n            path.append(start)\\n            visited.add(start)\\n\\n            if start == end:\\n                for node in path:\\n                    contri[node] += 1\\n                return True\\n            \\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            path.pop()\\n            return False\\n        \\n        contri = [0] * n\\n\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, [])\\n        \\n        dp = {}\\n        \\n        def dfs(node, parent, halve):\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            res1 = float(\"inf\")\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        return dfs(0, -1, False)\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # Part 1: Creating an adjacency list to traverse the graph\\n\\n        # Default dictionary with list as its default value.\\n        adj = defaultdict(list)\\n        \\n        # Traversing to each edge and adding it to its respective node\\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        # For Example 1, adjacency list will be:\\n        # adj = {0: [1], 1: [0, 2, 3], 2: [1], 3: [1]}\\n\\n        # <!--- Part 1 End ---!>\\n\\n\\n        # Part 2: Counting the contribution of each node\\n\\n        contri = [0] * n\\n\\n        # start -> Trip starting node\\n        # end -> Destination of trip\\n        # path -> Path from start to end\\n        def makeContri(start, end, path):\\n            # Add node to the path and visited\\n            path.add(start)\\n            visited.add(start)\\n\\n            # If this condition is True, we reached our end point\\n            if start == end:\\n                # We will increment contri of each node present in the path\\n                for node in path:\\n                    contri[node] += 1\\n                # Return True to stop further recursive searches\\n                return True\\n            \\n            # Else we will traverse recursively through the neighbours\\n            # until we reach the end node\\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            # If we don\\'t find the end node, then remove the node from\\n            # path and return False. \\n            path.remove(start)\\n            return False\\n        \\n        # Calling makeContri for each trip to find the contribution \\n        # of each node\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, set())\\n        \\n        # This updates the contri list, which stores the contributions \\n        # of each node\\n        # For Example 1, contri list will be\\n        # contri = [1, 3, 2, 2]\\n        # node :    0, 1, 2, 3\\n        # Now we know that \\'node 0\\' contributes 1 time\\n        #                  \\'node 1\\' contributes 3 times\\n        #                   and so on .....\\n\\n        # <!--- Part 2 End ---!>\\n\\n\\n        # Part 3: Dynamically execute all possibilities\\n\\n        # For a node, there are 2 possibilities\\n        # 1. If the price of the current node\\'s parent had been halved:\\n        #       In this case, we cannot halve the price of the current node.\\n        #       So, we recursively calculate the price without halving.\\n        # 2. or the price of the current node\\'s parent remains was not halved:\\n        #       Here, we can halve the price of current node or exclude it and \\n        #       calculate without halving it.\\n\\n        # Caching the result\\n        dp = {}\\n        \\n        # node -> current node\\n        # parent -> parent of current node\\n        # halve -> whether the parent node was halved or not\\n        def dfs(node, parent, halve):\\n            # if result in dp, return the result\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            # res1 -> result when halved\\n            # res2 -> result when not halved\\n            # Initialising it to infinity since the \\'if\\' statement \\n            # below may not get executed.\\n            res1 = float(\"inf\")\\n\\n            # if parent is not halved\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            # if parent is halved or we want to exclude halving\\n            # of current node. (Same for both possibilities)\\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            # Storing the minimum of both the result in dp\\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        # Calling dfs on node \\'0\\', fake parent as \\'-1\\', halved as \\'False\\'\\n        return dfs(0, -1, False)\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = defaultdict(list)\\n        \\n        for src, dst in edges:\\n            adj[src].append(dst)\\n            adj[dst].append(src)\\n        \\n        def makeContri(start, end, path):\\n            path.append(start)\\n            visited.add(start)\\n\\n            if start == end:\\n                for node in path:\\n                    contri[node] += 1\\n                return True\\n            \\n            for nei in adj[start]:\\n                if nei not in visited and makeContri(nei, end, path):\\n                    return True\\n            path.pop()\\n            return False\\n        \\n        contri = [0] * n\\n\\n        for start, end in trips:\\n            visited = set()\\n            makeContri(start, end, [])\\n        \\n        dp = {}\\n        \\n        def dfs(node, parent, halve):\\n            if (node, halve) in dp:\\n                return dp[(node, halve)]\\n\\n            res1 = float(\"inf\")\\n            if not halve:\\n                res1 = price[node] // 2 * contri[node] \\n\\n                for nei in adj[node]:\\n                    if nei != parent:\\n                        res1 += dfs(nei, node, True)\\n            \\n            res2 = price[node] * contri[node]\\n\\n            for nei in adj[node]:\\n                    if nei != parent:\\n                        res2 += dfs(nei, node, False)\\n            \\n            dp[(node, halve)] = min(res1, res2)\\n\\n            return dp[(node, halve)]\\n        \\n        return dfs(0, -1, False)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423346,
                "title": "minimize-the-total-price-of-the-trips-easy-c-solution-dfs-dp-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **DFS** to find the **path of every trip**.\\nFrom these path calculate the **occurance of every node in the final answer**\\nEvery node has two possibilities either reduce its price to half or not. With a constraint that two adjacent cannot be selected. \\nUse **DP** to find the best set of node whose price reduction to half will minimize the total cost.\\n\\n# Time Complexity\\n**O(N*T)** where N is number of nodes and T is number of trips\\n\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    // Used DFS to find path of every trip \\n    void dfs(int vertex, int target, int p, vector<vector<int>> &edges, vector<int> &vis, stack<int> ans, vector<int> &v)\\n    {\\n        // Start from source vertex\\n        for (auto it : edges[vertex])\\n        {\\n            if (it != p)\\n            {\\n                if (it == target)\\n                { \\n                    // Insert the path in ans vector on reaching target\\n                    ans.push(it);\\n                    while (ans.size() > 0)\\n                    {\\n                        int x = ans.top();\\n                        ans.pop();\\n                        v.push_back(x);\\n                    }\\n                    reverse(v.begin(), v.end());\\n                    return;\\n                }\\n                else\\n                {\\n                    ans.push(it);\\n                    dfs(it, target, vertex, edges, vis, ans, v);\\n                    // Backtrack\\n                    ans.pop();\\n                }\\n            }\\n        }\\n    }\\n    int dp[51][2];\\n    // Use dynamic programming to select set nodes in order to minimize the total cost\\n    int rec(map<int, int> cnt, vector<int> price, vector<vector<int>> edges, int node, int parent, bool prev = false)\\n    {\\n        int res1 = cnt[node] * price[node] / 2;\\n        int res2 = cnt[node] * price[node];\\n\\n        if (dp[node][prev] != -1)\\n            return dp[node][prev];\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res2 += rec(cnt, price, edges, child, node, 0);\\n        if (prev)\\n            return dp[node][prev] = res2;\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res1 += rec(cnt, price, edges, child, node, 1);\\n\\n        return dp[node][prev] = min(res1, res2);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>> &ed, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        vector<vector<int>> path;\\n        vector<vector<int>> edges(n);\\n        for (auto it : ed)\\n        {\\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        for (auto it : trips)\\n        {\\n            if (it[0] == it[1])\\n            {\\n                path.push_back({it[0]});\\n                continue;\\n            }\\n            vector<int> v;\\n            vector<int> vis(n, 0);\\n            stack<int> ans;\\n            ans.push(it[0]);\\n            dfs(it[0], it[1], -1, edges, vis, ans, v);\\n            path.push_back(v);\\n        }\\n        // for (auto it : path)\\n        // {\\n        //     for (auto i : it)\\n        //     {\\n        //         cout << i << \\' \\';\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        \\n        // Calculate the contribution of every node in the total answer\\n        map<int, int> cnt;\\n        for (auto it : path)\\n        {\\n            for (auto i : it)\\n                cnt[i]++;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n\\n        return rec(cnt, price, edges, 0, -1, 0);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    // Used DFS to find path of every trip \\n    void dfs(int vertex, int target, int p, vector<vector<int>> &edges, vector<int> &vis, stack<int> ans, vector<int> &v)\\n    {\\n        // Start from source vertex\\n        for (auto it : edges[vertex])\\n        {\\n            if (it != p)\\n            {\\n                if (it == target)\\n                { \\n                    // Insert the path in ans vector on reaching target\\n                    ans.push(it);\\n                    while (ans.size() > 0)\\n                    {\\n                        int x = ans.top();\\n                        ans.pop();\\n                        v.push_back(x);\\n                    }\\n                    reverse(v.begin(), v.end());\\n                    return;\\n                }\\n                else\\n                {\\n                    ans.push(it);\\n                    dfs(it, target, vertex, edges, vis, ans, v);\\n                    // Backtrack\\n                    ans.pop();\\n                }\\n            }\\n        }\\n    }\\n    int dp[51][2];\\n    // Use dynamic programming to select set nodes in order to minimize the total cost\\n    int rec(map<int, int> cnt, vector<int> price, vector<vector<int>> edges, int node, int parent, bool prev = false)\\n    {\\n        int res1 = cnt[node] * price[node] / 2;\\n        int res2 = cnt[node] * price[node];\\n\\n        if (dp[node][prev] != -1)\\n            return dp[node][prev];\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res2 += rec(cnt, price, edges, child, node, 0);\\n        if (prev)\\n            return dp[node][prev] = res2;\\n\\n        for (auto child : edges[node])\\n            if (child != parent)\\n                res1 += rec(cnt, price, edges, child, node, 1);\\n\\n        return dp[node][prev] = min(res1, res2);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>> &ed, vector<int> &price, vector<vector<int>> &trips)\\n    {\\n        vector<vector<int>> path;\\n        vector<vector<int>> edges(n);\\n        for (auto it : ed)\\n        {\\n            edges[it[0]].push_back(it[1]);\\n            edges[it[1]].push_back(it[0]);\\n        }\\n        for (auto it : trips)\\n        {\\n            if (it[0] == it[1])\\n            {\\n                path.push_back({it[0]});\\n                continue;\\n            }\\n            vector<int> v;\\n            vector<int> vis(n, 0);\\n            stack<int> ans;\\n            ans.push(it[0]);\\n            dfs(it[0], it[1], -1, edges, vis, ans, v);\\n            path.push_back(v);\\n        }\\n        // for (auto it : path)\\n        // {\\n        //     for (auto i : it)\\n        //     {\\n        //         cout << i << \\' \\';\\n        //     }\\n        //     cout << \\'\\\\n\\';\\n        // }\\n        \\n        // Calculate the contribution of every node in the total answer\\n        map<int, int> cnt;\\n        for (auto it : path)\\n        {\\n            for (auto i : it)\\n                cnt[i]++;\\n        }\\n        memset(dp, -1, sizeof(dp));\\n\\n        return rec(cnt, price, edges, 0, -1, 0);\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3422215,
                "title": "ez-python-sol-full-shitty",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        cnt=defaultdict(int)\\n        g=defaultdict(list)\\n        for x,y in edges:\\n            # print(x,y)\\n            g[x].append(y)\\n            g[y].append(x)\\n        def bfs(to,fro):\\n            q=deque([to])\\n            par=[None]*n\\n            par[to]=-1\\n            while q:\\n                t=q.popleft()\\n                for i in g[t]:\\n                    if par[i]==None:\\n                        par[i]=t\\n                        q.append(i)\\n            tt=fro\\n            while tt!=-1:\\n                cnt[tt]+=1\\n                tt=par[tt]\\n        for x,y in trips:\\n            bfs(x,y)\\n        for i in range(n):\\n            price[i]=cnt[i]*price[i]\\n        # print(price)\\n        def dfs(node,par):\\n            ans=[price[node]//2,price[node]] #cur half , not half\\n            for i in g[node]:\\n                if i!=par:\\n                    hlf,nhlf=dfs(i,node)\\n                    ans[0]+=nhlf\\n                    ans[1]=min(ans[1]+hlf,ans[1]+nhlf)\\n            return ans\\n        return min(dfs(0,-1))\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        cnt=defaultdict(int)\\n        g=defaultdict(list)\\n        for x,y in edges:\\n            # print(x,y)\\n            g[x].append(y)\\n            g[y].append(x)\\n        def bfs(to,fro):\\n            q=deque([to])\\n            par=[None]*n\\n            par[to]=-1\\n            while q:\\n                t=q.popleft()\\n                for i in g[t]:\\n                    if par[i]==None:\\n                        par[i]=t\\n                        q.append(i)\\n            tt=fro\\n            while tt!=-1:\\n                cnt[tt]+=1\\n                tt=par[tt]\\n        for x,y in trips:\\n            bfs(x,y)\\n        for i in range(n):\\n            price[i]=cnt[i]*price[i]\\n        # print(price)\\n        def dfs(node,par):\\n            ans=[price[node]//2,price[node]] #cur half , not half\\n            for i in g[node]:\\n                if i!=par:\\n                    hlf,nhlf=dfs(i,node)\\n                    ans[0]+=nhlf\\n                    ans[1]=min(ans[1]+hlf,ans[1]+nhlf)\\n            return ans\\n        return min(dfs(0,-1))\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421871,
                "title": "java-postorder-dfs-easy-and-readable-count-the-nodes-on-all-paths-then-do-post-order-dfs",
                "content": "```Java\\nclass Solution {\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Integer, Integer> pathCount;\\n    private int n;\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        this.price = price;\\n        this.n = n;\\n        \\n        this.tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n\\t\\t// pathCount <nodeId, the number of node on the path>\\n        this.pathCount = new HashMap<>();\\n        for (int[] t : trips) {\\n            ArrayList<Integer> path = new ArrayList<>();\\n            dfsForPath(-1, t[0], t[1], path);\\n            for (int p : path) {\\n                pathCount.put(p, 1 + pathCount.getOrDefault(p, 0));\\n            }\\n        }\\n        \\n        int[] res = dfs(-1, 0);\\n        return Math.min(res[0], res[1]);\\n    }\\n    \\n    // post order dfs\\n    // return int[]{cost1, cost2}, cost1: halve current node, cost2: don\\'t halve current node.\\n    private int[] dfs(int parent, int node) {\\n        // System.out.println(\"node: \"  + node);\\n        int[] ret = new int[2];\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            int[] sub = dfs(node, child);\\n\\t\\t\\t// if halve the current node, then the child cann\\'t halve the price.\\n            ret[0] += sub[1];\\n\\t\\t\\t// if doesn\\'t halve current node, then the child can halve the price or not, we choose the min one.\\n            ret[1] += Math.min(sub[0], sub[1]);\\n        }\\n        if (pathCount.containsKey(node)) {\\n            ret[0] += pathCount.get(node) * price[node] / 2;\\n            ret[1] += pathCount.get(node) * price[node];\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean dfsForPath(int parent, int node, int dest, ArrayList<Integer> path)  {\\n        path.add(node);\\n        if (dest == node) return true;\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            if (dfsForPath(node, child, dest, path)) {\\n                return true;\\n            }\\n        }\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    private ArrayList<Integer>[] tree;\\n    private int[] price;\\n    private HashMap<Integer, Integer> pathCount;\\n    private int n;\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        this.price = price;\\n        this.n = n;\\n        \\n        this.tree = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            tree[e[0]].add(e[1]);\\n            tree[e[1]].add(e[0]);\\n        }\\n        \\n\\t\\t// pathCount <nodeId, the number of node on the path>\\n        this.pathCount = new HashMap<>();\\n        for (int[] t : trips) {\\n            ArrayList<Integer> path = new ArrayList<>();\\n            dfsForPath(-1, t[0], t[1], path);\\n            for (int p : path) {\\n                pathCount.put(p, 1 + pathCount.getOrDefault(p, 0));\\n            }\\n        }\\n        \\n        int[] res = dfs(-1, 0);\\n        return Math.min(res[0], res[1]);\\n    }\\n    \\n    // post order dfs\\n    // return int[]{cost1, cost2}, cost1: halve current node, cost2: don\\'t halve current node.\\n    private int[] dfs(int parent, int node) {\\n        // System.out.println(\"node: \"  + node);\\n        int[] ret = new int[2];\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            int[] sub = dfs(node, child);\\n\\t\\t\\t// if halve the current node, then the child cann\\'t halve the price.\\n            ret[0] += sub[1];\\n\\t\\t\\t// if doesn\\'t halve current node, then the child can halve the price or not, we choose the min one.\\n            ret[1] += Math.min(sub[0], sub[1]);\\n        }\\n        if (pathCount.containsKey(node)) {\\n            ret[0] += pathCount.get(node) * price[node] / 2;\\n            ret[1] += pathCount.get(node) * price[node];\\n        }\\n        return ret;\\n    }\\n    \\n    private boolean dfsForPath(int parent, int node, int dest, ArrayList<Integer> path)  {\\n        path.add(node);\\n        if (dest == node) return true;\\n        \\n        for (int child : tree[node]) {\\n            if (child == parent) continue;\\n            if (dfsForPath(node, child, dest, path)) {\\n                return true;\\n            }\\n        }\\n        path.remove(path.size() - 1);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421923,
                "title": "dp-o-n-trips-c-explained",
                "content": "# Intuition\\nThe key here is to see that the ways in which you can halve the value or the nodes that depends on the trips and each node will have its own independent weight in the final sum so we have a situation where we have to choose whether to halve or not to halve some node which is a typical DP task.\\n\\n# Approach\\n- Step 1. Condence the trips\\n    Let\\'s see that we do a precalc in order to condense all trips in some information in the nodes, let\\'s make the halves after.\\n\\n    The statement says:\\n    > Additionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\\n\\n    But all we know that for a three a path betwen the node $u$ and $v$ is unique so, each path is defined and we can know in how many paths some node will be part let\\'s calc this in some array call $contribution$ , for make this array let\\'s see that the limits of nodes and trips are very small so for each trip we can simply run a dfs and mark all nodes that was visited in the path and each one of the marked nodes check the code to understand.\\n\\n    Now with this information we can get the final sum with one extra pass and will be $\\\\Sigma_i^n contribution_i \\\\times price_i$  now it\\'s time to decide who will be halved \\n\\n- Step 2: Decide which will be halved \\n    Now We need to select some nodes to halve, let\\'s see that the condition is that no adjacent nodes can be halved at same time , so it says that the number of valid halvings could be huge, but is cleat that it will be repeated subproblems. \\nLet\\'s see at first that root the tree is indiferent you chan chose whatever root that you want , now let\\'s define the way to traverse the tree, and that will be just the same as DFS order now we can define the next DP.\\n\\n$$DP[u][pH]$$ Where $u$ is the current node and $pH$ (parentHalved) is a boolean value that say if we choose that our parent halve their price, and the transitions are: \\n$$DP[u][pH] =\\n  \\\\begin{cases}\\n    \\\\sum_{c_u} DP[c_u][0]  + contribution_u \\\\times price_u     & \\\\quad \\\\text{if } pH \\\\text{ is true}\\\\\\\\\\n    min(\\\\sum_{c_u} DP[c_u][0] ,\\\\sum_{c_u} DP[c_u][1]) +contribution_u \\\\times price_u  & \\\\quad \\\\text{if } pH \\\\text{ is false}\\n  \\\\end{cases}\\n$$\\n\\nThat is because if our parent was halved we cannot halved, and in other way we can choose if halve our price or not.\\n# Complexity\\n- Time complexity:\\n- Condence the tips cost $$O(M \\\\times n)$$ where $M$ is the number of trips and the DP costs $$O(2 \\\\times n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> graph[57];\\n    vector<int> G[57];\\n    vector<int> cont;\\n\\n    void dfs(int u,int p = -1){\\n        if(p !=-1)\\n            G[p].push_back(u);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs(v,u);\\n        }\\n    }\\n    vector<int> d;\\n    void dfs2(int u,int t,int p = -1){\\n        \\n        if(u == t)d[u] = 1;\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs2(v,t,u);\\n            d[u]+=d[v];\\n        }\\n        \\n        cont[u]+=d[u];\\n    }\\n    \\n    \\n    int dp[57][2];\\n    vector<int> P;\\n    \\n    int solve(int u,int p){\\n        int &x = dp[u][p];\\n        if(x!=-1)return x;\\n        \\n        if(p){\\n            int ans = cont[u]*P[u];\\n            for(auto v:G[u]){\\n                ans+=solve(v,0);\\n            }\\n            return x = ans;\\n                        \\n        }\\n        else{\\n            int ans1 = cont[u]*(P[u]/2);\\n            int ans2 = cont[u]*P[u];\\n            \\n            for(auto v:G[u]){\\n                ans1+=solve(v,1);\\n                ans2+=solve(v,0);\\n            }\\n            return x = min(ans1,ans2);\\n        }\\n        \\n        return 0;\\n    }    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0);\\n        P = price;\\n        cont.resize(n);\\n        for(auto c:trips){\\n            int u = c[0];\\n            int v = c[1];\\n            d.assign(n,0);\\n            dfs2(u,v);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans1 = solve(0,0);\\n        int ans2 = solve(0,1);\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> graph[57];\\n    vector<int> G[57];\\n    vector<int> cont;\\n\\n    void dfs(int u,int p = -1){\\n        if(p !=-1)\\n            G[p].push_back(u);\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs(v,u);\\n        }\\n    }\\n    vector<int> d;\\n    void dfs2(int u,int t,int p = -1){\\n        \\n        if(u == t)d[u] = 1;\\n        \\n        for(auto v:graph[u]){\\n            if(v == p)continue;\\n            dfs2(v,t,u);\\n            d[u]+=d[v];\\n        }\\n        \\n        cont[u]+=d[u];\\n    }\\n    \\n    \\n    int dp[57][2];\\n    vector<int> P;\\n    \\n    int solve(int u,int p){\\n        int &x = dp[u][p];\\n        if(x!=-1)return x;\\n        \\n        if(p){\\n            int ans = cont[u]*P[u];\\n            for(auto v:G[u]){\\n                ans+=solve(v,0);\\n            }\\n            return x = ans;\\n                        \\n        }\\n        else{\\n            int ans1 = cont[u]*(P[u]/2);\\n            int ans2 = cont[u]*P[u];\\n            \\n            for(auto v:G[u]){\\n                ans1+=solve(v,1);\\n                ans2+=solve(v,0);\\n            }\\n            return x = min(ans1,ans2);\\n        }\\n        \\n        return 0;\\n    }    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto c:edges){\\n            int u = c[0];\\n            int v = c[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        dfs(0);\\n        P = price;\\n        cont.resize(n);\\n        for(auto c:trips){\\n            int u = c[0];\\n            int v = c[1];\\n            d.assign(n,0);\\n            dfs2(u,v);\\n        }\\n        memset(dp,-1,sizeof dp);\\n        int ans1 = solve(0,0);\\n        int ans2 = solve(0,1);\\n        return min(ans1,ans2);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421855,
                "title": "c-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we need to find out the nodes which are contrinuting maximum to the trip cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo calculate the trip cost (sum variable in code) and also store the contribution of each node in the final sum (the cost array in code)\\nAfter that find the maximum sum of non adjacent nodes according to the cost array (done using function named find in the code).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<vector<int>>dp;\\n    int find(vector<vector<int>>&g, vector<int>&cost, int s,int p, bool k=true)\\n    {\\n        if(dp[k][s]!=-1)\\n            return dp[k][s];\\n        int ans1=0,ans2=0;\\n        if(k)\\n            ans1+=cost[s];\\n        for(auto i:g[s])\\n        {\\n            if(i!=p)\\n            {\\n                ans1+=find(g,cost,i,s,!k);\\n                ans2+=find(g,cost,i,s,k);\\n            }\\n        }\\n        return dp[k][s]=max(ans1,ans2);\\n    }\\n    bool helper(vector<vector<int>>&g, int s, int e, int p, vector<int>&cost, vector<int>&price)\\n    {\\n        if(s==e)\\n        {\\n            sum+=price[e];\\n            cost[e]+=price[e];\\n            return true;\\n        }\\n        for(auto i:g[s])\\n        {\\n            if(i!=p && helper(g,i,e,s,cost,price))\\n            {\\n                sum+=price[s];\\n                cost[s]+=price[s];\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& e, vector<int>& price, vector<vector<int>>& t) \\n    {\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>cost(n,0);\\n        for(int i=0;i<t.size();i++)\\n        {\\n            helper(g,t[i][0],t[i][1],-1,cost,price);\\n        }\\n        \\n        int sum1=0,sum2=0;\\n        \\n        dp.resize(2,vector<int>(n,-1));\\n        sum1=find(g,cost,0,-1);       \\n        \\n        sum-=(sum1/2);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sum=0;\\n    vector<vector<int>>dp;\\n    int find(vector<vector<int>>&g, vector<int>&cost, int s,int p, bool k=true)\\n    {\\n        if(dp[k][s]!=-1)\\n            return dp[k][s];\\n        int ans1=0,ans2=0;\\n        if(k)\\n            ans1+=cost[s];\\n        for(auto i:g[s])\\n        {\\n            if(i!=p)\\n            {\\n                ans1+=find(g,cost,i,s,!k);\\n                ans2+=find(g,cost,i,s,k);\\n            }\\n        }\\n        return dp[k][s]=max(ans1,ans2);\\n    }\\n    bool helper(vector<vector<int>>&g, int s, int e, int p, vector<int>&cost, vector<int>&price)\\n    {\\n        if(s==e)\\n        {\\n            sum+=price[e];\\n            cost[e]+=price[e];\\n            return true;\\n        }\\n        for(auto i:g[s])\\n        {\\n            if(i!=p && helper(g,i,e,s,cost,price))\\n            {\\n                sum+=price[s];\\n                cost[s]+=price[s];\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& e, vector<int>& price, vector<vector<int>>& t) \\n    {\\n        vector<vector<int>>g(n);\\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<int>cost(n,0);\\n        for(int i=0;i<t.size();i++)\\n        {\\n            helper(g,t[i][0],t[i][1],-1,cost,price);\\n        }\\n        \\n        int sum1=0,sum2=0;\\n        \\n        dp.resize(2,vector<int>(n,-1));\\n        sum1=find(g,cost,0,-1);       \\n        \\n        sum-=(sum1/2);\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421853,
                "title": "dp-lca",
                "content": "# Intuition\\nDP + LCA\\n\\n\\n# Code\\n```\\nclass Solution {\\n    void dfs(const vector<vector<int>> &con, int x, int p, int dep, vector<int> &d, vector<int> &f) {\\n        d[x] = dep;\\n        f[x] = p;\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(con, y, x, dep + 1, d, f);\\n            }\\n        }\\n        \\n    }\\n    \\n    int dfs(const vector<vector<int>> &con, const vector<int> &c, int x, int p, int v, vector<vector<int>> &dp) {\\n        if (dp[x][v] >= 0) {\\n            return dp[x][v];\\n        }\\n        if (dp[x][1] < 0) {\\n            dp[x][1] = 0;\\n            for (int y : con[x]) {\\n                if (y != p) {\\n                    dp[x][1] += dfs(con, c, y, x, 0, dp);\\n                }\\n            }\\n        }\\n        if (v == 1) {\\n            return dp[x][1];\\n        }\\n        dp[x][0] = c[x];\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dp[x][0] += dfs(con, c, y, x, 1, dp);\\n            }            \\n        }\\n        return dp[x][0] = max(dp[x][0], dp[x][1]);\\n        \\n        \\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);  \\n        }\\n        vector<int> d(n), f(n);\\n        dfs(con, 0, -1, 0, d, f);\\n        vector<int> t(n);\\n        for (const auto & v : trips) {\\n            int x = v[0], y = v[1];\\n            while (d[x] > d[y]) {\\n                ++t[x];\\n                x = f[x]; \\n            }\\n            while (d[x] < d[y]) {\\n                ++t[y];\\n                y = f[y]; \\n            }\\n            while (x != y) {\\n                ++t[x];\\n                x = f[x]; \\n                ++t[y];\\n                y = f[y]; \\n            }\\n            ++t[x];\\n        }\\n        int r = 0;\\n        for (int  i = 0; i < n; ++i) {\\n            t[i] *= price[i];\\n            r += t[i];\\n            t[i] >>= 1;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return r - dfs(con, t, 0, -1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(const vector<vector<int>> &con, int x, int p, int dep, vector<int> &d, vector<int> &f) {\\n        d[x] = dep;\\n        f[x] = p;\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dfs(con, y, x, dep + 1, d, f);\\n            }\\n        }\\n        \\n    }\\n    \\n    int dfs(const vector<vector<int>> &con, const vector<int> &c, int x, int p, int v, vector<vector<int>> &dp) {\\n        if (dp[x][v] >= 0) {\\n            return dp[x][v];\\n        }\\n        if (dp[x][1] < 0) {\\n            dp[x][1] = 0;\\n            for (int y : con[x]) {\\n                if (y != p) {\\n                    dp[x][1] += dfs(con, c, y, x, 0, dp);\\n                }\\n            }\\n        }\\n        if (v == 1) {\\n            return dp[x][1];\\n        }\\n        dp[x][0] = c[x];\\n        for (int y : con[x]) {\\n            if (y != p) {\\n                dp[x][0] += dfs(con, c, y, x, 1, dp);\\n            }            \\n        }\\n        return dp[x][0] = max(dp[x][0], dp[x][1]);\\n        \\n        \\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> con(n);\\n        for (const auto& e : edges) {\\n            con[e[0]].push_back(e[1]);\\n            con[e[1]].push_back(e[0]);  \\n        }\\n        vector<int> d(n), f(n);\\n        dfs(con, 0, -1, 0, d, f);\\n        vector<int> t(n);\\n        for (const auto & v : trips) {\\n            int x = v[0], y = v[1];\\n            while (d[x] > d[y]) {\\n                ++t[x];\\n                x = f[x]; \\n            }\\n            while (d[x] < d[y]) {\\n                ++t[y];\\n                y = f[y]; \\n            }\\n            while (x != y) {\\n                ++t[x];\\n                x = f[x]; \\n                ++t[y];\\n                y = f[y]; \\n            }\\n            ++t[x];\\n        }\\n        int r = 0;\\n        for (int  i = 0; i < n; ++i) {\\n            t[i] *= price[i];\\n            r += t[i];\\n            t[i] >>= 1;\\n        }\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return r - dfs(con, t, 0, -1, 0, dp);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673455,
                "title": "c-graph-pruning",
                "content": "# Intuition\\nIf we forget about reducing cost of alernate nodes. Problem asks for sum of cost of trips. Now we need to find how many times each node in graph has to be visited for making all trips. \\n\\nWe can also remove the nodes that are never visited during any of the trips.\\n\\nThen we can easily calculate the cost using recursion and memoize it later.\\n\\n# Approach\\nCreate an adjency matrix to represent the graph. Note here we create a `vector<unordered_set<int>>` which makes it easy to prune unvisted nodes later.\\n\\nFor each trip\\'s starting point try to find a path to the end. During recursion we keep track of nodes that we need to visit.\\n\\nExample \\n```\\nInput: n = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,3],[2,1],[2,3]]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/9b85d138-7da8-4641-a504-37cbcebdc2ce_1687519466.264249.png)\\n\\n```\\nnode  number of visits\\n0     1\\n1     3\\n2     2\\n3     2\\n\\nnode  total cost\\n0     2\\n1     6\\n2     20\\n3     12\\n```\\n\\nNow suppose we had another node `4` connected with `3` but it was not included in any trips. We would want to prune such nodes from our graph (note this process can create a disjoint graph)\\n\\nAt last we iterate over all trip\\'s starting points and get min cost for them.\\n\\n##### If a node is selected for cost reduction\\n- It\\'s children may not be selected\\n\\n##### If a node is not selected for cost reduction\\n- It\\'s children may or may not be selected \\n\\nIf this is the cost path `20 - 4 - 6 - 100` then it makes more sense to half 20 and 100 instead of following a bipartite graph approach.\\n\\n\\nDP state -`dp[node][selected]`represents min cost of node when it is selected and not\\n\\n# Complexity\\n>$$n$$ - number of nodes\\n$$e$$ - number of edges\\n$$trips$$ - number of trips\\n\\n#### Time complexity:\\n>Getting visit count for each node - $$O(trips * (n + e))$$\\nPruning the graph - $$O(n)$$\\nCalculating the optimal cost - $$O(2(n + e))$$\\n\\n#### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>Storing graph - $$O(n + e)$$\\nDP cache - $$O(2 * n)$$\\n\\n\\n#### Code\\n```\\nclass Solution {\\n    // function to count what nodes are visited during a \\n    // trip from start to end\\n    bool getPaths(int start, int end, vector<unordered_set<int>>& graph, vector<int>& vis, vector<int>& visited) {\\n        vis[start] = 1;\\n\\n        if (start == end) \\n            return true;\\n\\n        for (int i : graph[start]) {\\n            // current dfs path is only valid if we encounter end\\n            // down the line\\n            if (!vis[i] and getPaths(i, end, graph, vis, visited)) {\\n                ++visited[i];\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int reduce(vector<unordered_set<int>>& graph, vector<int>& cost, int curr, bool half, vector<vector<int>>& dp, int parent = -1) {   \\n        if (dp[curr][half] != -1)\\n            return dp[curr][half];\\n\\n        int sub = 0;\\n        int total = half == true ? cost[curr] / 2 : cost[curr];\\n\\n        for (int i : graph[curr]) {\\n            // ignore the node we just came from\\n            if (i == parent) continue;\\n\\n            // get min cost of child w.r.t current node selection\\n            sub = reduce(graph, cost, i, !half, dp, curr);\\n            \\n            // if current node is not selected\\n            // also get cost of its child not getting selected\\n            if (!half) \\n                sub = min(reduce(graph, cost, i, half, dp, curr), sub);\\n\\n            total += sub;\\n        }\\n\\n        return dp[curr][half] = total;\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<unordered_set<int>> graph(n, unordered_set<int>());\\n\\n        for (auto& i : edges) {\\n            graph[i[0]].insert(i[1]);\\n            graph[i[1]].insert(i[0]);\\n        }\\n\\n        // store number of times a node is visited\\n        vector<int> cost(n, 0);\\n\\n        for (auto& i : trips) {\\n            vector<int> vis(n, 0);\\n\\n            getPaths(i[0], i[1], graph, vis, cost);\\n            ++cost[i[0]]; // start is missed in the count\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // total cost for visiting a node\\n            cost[i] *= price[i];\\n            \\n            // if cost is zero means this node has \\n            // not been visited and we can remove\\n            // it from the graph\\n            if (cost[i] == 0) {   \\n                // remove it from its children \\n                for (auto j : graph[i]) \\n                    graph[j].erase(i);\\n\\n                // remove the node itself\\n                graph[i].clear();\\n            }\\n        }\\n        \\n        // dp[i][j] will store min cost of\\n        // i th node when it has a cost reduction (j = 1)\\n        // i th node does not have a cost reduction (j = 0)\\n\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        // only need for this loop is in case of disjoint graph\\n        for (auto& i : trips) {\\n            int start = i[0];\\n\\n            if (dp[start][0] + dp[start][1] == -2) {\\n                // mark the node for cost reduction\\n                reduce(graph, cost, start, true, dp);\\n\\n                // unmark the node for cost reduction\\n                reduce(graph, cost, start, false, dp);\\n\\n                ans += min(dp[start][0], dp[start][1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n<img src=https://assets.leetcode.com/users/images/1605128e-56b2-4510-884d-36c69ff02613_1684842163.263651.png alt=\"drawing\" width=\"250\"/>\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nInput: n = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,3],[2,1],[2,3]]\\n```\n```\\nnode  number of visits\\n0     1\\n1     3\\n2     2\\n3     2\\n\\nnode  total cost\\n0     2\\n1     6\\n2     20\\n3     12\\n```\n```\\nclass Solution {\\n    // function to count what nodes are visited during a \\n    // trip from start to end\\n    bool getPaths(int start, int end, vector<unordered_set<int>>& graph, vector<int>& vis, vector<int>& visited) {\\n        vis[start] = 1;\\n\\n        if (start == end) \\n            return true;\\n\\n        for (int i : graph[start]) {\\n            // current dfs path is only valid if we encounter end\\n            // down the line\\n            if (!vis[i] and getPaths(i, end, graph, vis, visited)) {\\n                ++visited[i];\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    int reduce(vector<unordered_set<int>>& graph, vector<int>& cost, int curr, bool half, vector<vector<int>>& dp, int parent = -1) {   \\n        if (dp[curr][half] != -1)\\n            return dp[curr][half];\\n\\n        int sub = 0;\\n        int total = half == true ? cost[curr] / 2 : cost[curr];\\n\\n        for (int i : graph[curr]) {\\n            // ignore the node we just came from\\n            if (i == parent) continue;\\n\\n            // get min cost of child w.r.t current node selection\\n            sub = reduce(graph, cost, i, !half, dp, curr);\\n            \\n            // if current node is not selected\\n            // also get cost of its child not getting selected\\n            if (!half) \\n                sub = min(reduce(graph, cost, i, half, dp, curr), sub);\\n\\n            total += sub;\\n        }\\n\\n        return dp[curr][half] = total;\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<unordered_set<int>> graph(n, unordered_set<int>());\\n\\n        for (auto& i : edges) {\\n            graph[i[0]].insert(i[1]);\\n            graph[i[1]].insert(i[0]);\\n        }\\n\\n        // store number of times a node is visited\\n        vector<int> cost(n, 0);\\n\\n        for (auto& i : trips) {\\n            vector<int> vis(n, 0);\\n\\n            getPaths(i[0], i[1], graph, vis, cost);\\n            ++cost[i[0]]; // start is missed in the count\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            // total cost for visiting a node\\n            cost[i] *= price[i];\\n            \\n            // if cost is zero means this node has \\n            // not been visited and we can remove\\n            // it from the graph\\n            if (cost[i] == 0) {   \\n                // remove it from its children \\n                for (auto j : graph[i]) \\n                    graph[j].erase(i);\\n\\n                // remove the node itself\\n                graph[i].clear();\\n            }\\n        }\\n        \\n        // dp[i][j] will store min cost of\\n        // i th node when it has a cost reduction (j = 1)\\n        // i th node does not have a cost reduction (j = 0)\\n\\n        int ans = 0;\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n\\n        // only need for this loop is in case of disjoint graph\\n        for (auto& i : trips) {\\n            int start = i[0];\\n\\n            if (dp[start][0] + dp[start][1] == -2) {\\n                // mark the node for cost reduction\\n                reduce(graph, cost, start, true, dp);\\n\\n                // unmark the node for cost reduction\\n                reduce(graph, cost, start, false, dp);\\n\\n                ans += min(dp[start][0], dp[start][1]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429427,
                "title": "easy-c-intuitive-solution",
                "content": "# Intuition\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We want to choose which nodes need to be halved we find out the frequency of nodes in all the paths of the trips.\\n- If the parent is halved we can\\'t half the total cost of current node, otherwise we have choice to half it or not.\\n\\n\\n\\nUPVOTE IF HELPFUL !\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2]; // node and whether its parent halved or not\\n    int dphelp(int node, int par, vector<int> &price, vector<int> &contribution, int parHalved, vector<vector<int>> &adj){\\n        int full=contribution[node]*price[node];\\n        int half=contribution[node]*price[node]/2;\\n\\n        if(dp[node][parHalved]!=-1)return dp[node][parHalved];\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                full+=dphelp(it,node, price,contribution, 0, adj);\\n            }\\n        }\\n\\n        if(parHalved==true)return dp[node][parHalved]=full;\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                half+=dphelp(it, node, price, contribution, 1, adj);\\n            }\\n        }\\n\\n        return dp[node][parHalved]=min(full, half);\\n    }\\n\\n\\n    void makeContributions(int node, int e, vector<vector<int>> &adj, vector<int> &tmp,vector<int> &contribution, int par){\\n        tmp.push_back(node);\\n        if(node==e){\\n            for(auto &it: tmp){\\n                contribution[it]++;\\n            }\\n            tmp.pop_back();\\n            return;\\n        }\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                makeContributions(it,e,adj,tmp,contribution,node);\\n            }\\n        }\\n        tmp.pop_back();\\n        return;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof(dp));\\n\\n        //adjacency matrix;\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n\\n        // creating a contribution vector\\n        vector<int> contribution(n,0);\\n        for(auto &it: trips){\\n            vector<int> tmp;\\n            makeContributions(it[0], it[1], adj,tmp,contribution, -1);\\n        }\\n\\n        // dp on the basis of (node, parent was taken or not)\\n        return dphelp(0,-1,price, contribution, 0, adj);\\n\\n    }\\n};\\n```\\n# \\nUPVOTE IF HELPFUL !\\n![1647845206317.jpeg](https://assets.leetcode.com/users/images/56e8558c-59b1-4684-9c21-34427ea19354_1681795048.2268593.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2]; // node and whether its parent halved or not\\n    int dphelp(int node, int par, vector<int> &price, vector<int> &contribution, int parHalved, vector<vector<int>> &adj){\\n        int full=contribution[node]*price[node];\\n        int half=contribution[node]*price[node]/2;\\n\\n        if(dp[node][parHalved]!=-1)return dp[node][parHalved];\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                full+=dphelp(it,node, price,contribution, 0, adj);\\n            }\\n        }\\n\\n        if(parHalved==true)return dp[node][parHalved]=full;\\n\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                half+=dphelp(it, node, price, contribution, 1, adj);\\n            }\\n        }\\n\\n        return dp[node][parHalved]=min(full, half);\\n    }\\n\\n\\n    void makeContributions(int node, int e, vector<vector<int>> &adj, vector<int> &tmp,vector<int> &contribution, int par){\\n        tmp.push_back(node);\\n        if(node==e){\\n            for(auto &it: tmp){\\n                contribution[it]++;\\n            }\\n            tmp.pop_back();\\n            return;\\n        }\\n        for(auto &it: adj[node]){\\n            if(it!=par){\\n                makeContributions(it,e,adj,tmp,contribution,node);\\n            }\\n        }\\n        tmp.pop_back();\\n        return;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        memset(dp, -1, sizeof(dp));\\n\\n        //adjacency matrix;\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n\\n        // creating a contribution vector\\n        vector<int> contribution(n,0);\\n        for(auto &it: trips){\\n            vector<int> tmp;\\n            makeContributions(it[0], it[1], adj,tmp,contribution, -1);\\n        }\\n\\n        // dp on the basis of (node, parent was taken or not)\\n        return dphelp(0,-1,price, contribution, 0, adj);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423587,
                "title": "java-dp-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n     int con[] ;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> al[] = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n        }\\n        con = new int[n];\\n        for(int i=0;i<trips.length;i++){\\n            int aa = trips[i][0];\\n            int bb = trips[i][1];\\n            ArrayList<Integer> all = new ArrayList<>();\\n             con[aa]++;\\n            dfs(aa,bb,al,-1);\\n            \\n        }\\n    \\n        dp = new int[n][2];\\n           for(int i=0;i<n;i++){\\n               Arrays.fill(dp[i],-1);\\n           }\\n      \\n        return solve(0,-1,0,al,price);\\n        \\n    }\\n    \\n    public int solve(int node,int par,int use, ArrayList<Integer> al[],int pr[]){\\n        \\n        int u = con[node]*pr[node]/2;\\n        int uu = con[node]*pr[node];\\n        if(dp[node][use]!=-1) return dp[node][use];\\n        for(int v:al[node]){\\n            if(v!=par){\\n                uu += solve(v,node,0,al,pr);\\n            }\\n        }\\n        if(use==1) return dp[node][use] = uu;\\n        \\n        for(int v:al[node]){\\n            if(v!=par){\\n                u += solve(v,node,1,al,pr);\\n            }\\n        }\\n        return dp[node][use] = Math.min(u,uu);\\n    }\\n    \\n    int dp[][];\\n    public boolean dfs(int s,int d,ArrayList<Integer> al[],int par){\\n        \\n        if(s==d){\\n            return true;\\n        }\\n        \\n        for(int v:al[s]){\\n            if(v!=par){\\n                if(dfs(v,d,al,s)){\\n                    con[v]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n     int con[] ;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> al[] = new ArrayList[n];\\n        for(int i=0;i<n;i++) al[i] = new ArrayList<>();\\n        for(int i=0;i<edges.length;i++){\\n            al[edges[i][0]].add(edges[i][1]);\\n            al[edges[i][1]].add(edges[i][0]);\\n        }\\n        con = new int[n];\\n        for(int i=0;i<trips.length;i++){\\n            int aa = trips[i][0];\\n            int bb = trips[i][1];\\n            ArrayList<Integer> all = new ArrayList<>();\\n             con[aa]++;\\n            dfs(aa,bb,al,-1);\\n            \\n        }\\n    \\n        dp = new int[n][2];\\n           for(int i=0;i<n;i++){\\n               Arrays.fill(dp[i],-1);\\n           }\\n      \\n        return solve(0,-1,0,al,price);\\n        \\n    }\\n    \\n    public int solve(int node,int par,int use, ArrayList<Integer> al[],int pr[]){\\n        \\n        int u = con[node]*pr[node]/2;\\n        int uu = con[node]*pr[node];\\n        if(dp[node][use]!=-1) return dp[node][use];\\n        for(int v:al[node]){\\n            if(v!=par){\\n                uu += solve(v,node,0,al,pr);\\n            }\\n        }\\n        if(use==1) return dp[node][use] = uu;\\n        \\n        for(int v:al[node]){\\n            if(v!=par){\\n                u += solve(v,node,1,al,pr);\\n            }\\n        }\\n        return dp[node][use] = Math.min(u,uu);\\n    }\\n    \\n    int dp[][];\\n    public boolean dfs(int s,int d,ArrayList<Integer> al[],int par){\\n        \\n        if(s==d){\\n            return true;\\n        }\\n        \\n        for(int v:al[s]){\\n            if(v!=par){\\n                if(dfs(v,d,al,s)){\\n                    con[v]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n    \\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422336,
                "title": "c-dp-on-trees",
                "content": "Here for every trip we compute a path between start to end.\\nAll this nodes will contribute their prices to the ans by a factor of 1.\\nSo we will create a freq array which will store how many time this node comes in the path\\n\\nAfter computing the freq array, all we need to do is pick non-adjacent nodes and decrease the prices by half\\nSo for this we will use dp.\\n\\nif we can half the price\\n\\tnewPrice = price / 2\\n\\tcost = freq[node] * newPrice\\n\\t(as freq is the no. of times it will contribute the price\\nelse \\n\\tcost = freq[node] * orgPrice\\n\\n**C++ Implementation:**\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> freq;\\n    vector<vector<int>> adj;\\n    vector<int> path;\\n    vector<int> price;\\n    \\n    bool dfs(int curr, int par, int end) {\\n        path.push_back(curr);\\n        if(curr == end) return true;\\n        \\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            if(dfs(it, curr, end)) {\\n                return true;\\n            }\\n        }\\n        \\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    vvi dp;\\n    \\n    int helper(int curr, int par, bool canHalf) {\\n        if(dp[curr][canHalf] != -1) \\n            return dp[curr][canHalf];\\n        \\n        int pick = INT_MAX;\\n        \\n        if(canHalf) {\\n            pick = 0;\\n            int p = price[curr] / 2;\\n            pick += p * freq[curr];\\n            for(auto it: adj[curr]) {\\n                if(it == par) continue;\\n                pick += helper(it, curr, false);\\n            }\\n        }\\n        \\n        int not_pick = price[curr] * freq[curr];\\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            not_pick += helper(it, curr, true);\\n        }\\n        \\n        return dp[curr][canHalf] = min(pick, not_pick);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        this->price = price;\\n        freq = vector<int>(n, 0);\\n        adj = vector<vector<int>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for(auto &trip: trips) {\\n            int start = trip[0], end = trip[1];\\n            dfs(start, -1, end);\\n            \\n            for(auto it: path)\\n                freq[it]++;\\n    \\n            path.clear();\\n        }\\n        \\n        dp = vvi(n, vi(2, -1));\\n        return helper(0, -1, true);\\n    }\\n};\\n```\\n\\nTime Complexity = O(trips * n) + O(2n)\\n\\nI am not good with writing so please bear with that ;)\\nIf it helped please upvote :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> freq;\\n    vector<vector<int>> adj;\\n    vector<int> path;\\n    vector<int> price;\\n    \\n    bool dfs(int curr, int par, int end) {\\n        path.push_back(curr);\\n        if(curr == end) return true;\\n        \\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            if(dfs(it, curr, end)) {\\n                return true;\\n            }\\n        }\\n        \\n        path.pop_back();\\n        return false;\\n    }\\n    \\n    #define vi vector<int>\\n    #define vvi vector<vi>\\n    \\n    vvi dp;\\n    \\n    int helper(int curr, int par, bool canHalf) {\\n        if(dp[curr][canHalf] != -1) \\n            return dp[curr][canHalf];\\n        \\n        int pick = INT_MAX;\\n        \\n        if(canHalf) {\\n            pick = 0;\\n            int p = price[curr] / 2;\\n            pick += p * freq[curr];\\n            for(auto it: adj[curr]) {\\n                if(it == par) continue;\\n                pick += helper(it, curr, false);\\n            }\\n        }\\n        \\n        int not_pick = price[curr] * freq[curr];\\n        for(auto it: adj[curr]) {\\n            if(it == par) continue;\\n            not_pick += helper(it, curr, true);\\n        }\\n        \\n        return dp[curr][canHalf] = min(pick, not_pick);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        this->price = price;\\n        freq = vector<int>(n, 0);\\n        adj = vector<vector<int>>(n);\\n        for(auto &edge: edges) {\\n            int u = edge[0], v = edge[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        \\n        for(auto &trip: trips) {\\n            int start = trip[0], end = trip[1];\\n            dfs(start, -1, end);\\n            \\n            for(auto it: path)\\n                freq[it]++;\\n    \\n            path.clear();\\n        }\\n        \\n        dp = vvi(n, vi(2, -1));\\n        return helper(0, -1, true);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422244,
                "title": "dfs-dp-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe have to find the min cost in this problem, so we have to try out all possible cases. DP is the answer for that. \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst I have counted the number of times a node is visited during all the trips. Since, it\\'s a tree so there is only one possible path between two nodes i.e, unique path for each trip. \\n\\nWe have calculated frequency, so that we don\\'t have to find the cost for all trips each time. \\n\\nNow, all the nodes that are not visited during any trip has frequency = 0 so they, will not afftect our answer. \\n\\nRun a DFS with variable lastPicked, which represents we have halved the price in previous iteration or not. \\nWe need the parent node, to take care of visted nodes. \\nSo our DP has 3 states -> node, parent, lastPicked.\\n\\nWe will switch states using the variable lastPicked. If lastPicked is 0, we can half the current node\\'s price. Else we have don\\'t have option to half the price for current level.  \\n\\nNote : I have passed n as the parent of first node because we can\\'t access the -1 index in DP.\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool countFrequecy(int node, int dest,vector<int> adj[],vector<int>&freq, int par)\\n    {\\n        if(node==dest)  // reached the destination\\n            return 1;\\n        bool ans =0;\\n        for(auto x:adj[node])\\n        {\\n            if(x!=par)\\n            {\\n                if(countFrequecy(x,dest,adj,freq,node)) // If destination is in current path\\n                {\\n                    freq[x]++; //incrementing the freq of nodes in the path\\n                    ans=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minCost(int node, int par, int lastPicked,vector<int>& price,vector<int> adj[],vector<int>&freq,vector<vector<vector<int>>>&dp)\\n    {\\n        int ans = 1e9,res=0;\\n        if(dp[node][par][lastPicked]!=-1)\\n            return dp[node][par][lastPicked];\\n        if(lastPicked) // if we picked the last i.e, node then price = price/2\\n            res = freq[node]*(price[node]/2);\\n        else\\n            res = freq[node]*(price[node]);\\n        \\n        for(auto x:adj[node])\\n        {\\n            if(x!=par) \\n            {\\n                ans=minCost(x,node,0,price,adj,freq,dp);\\n                if(lastPicked==0)  \\n                    ans = min(ans,minCost(x,node,1,price,adj,freq,dp));\\n                res+=ans;\\n            }\\n        }\\n        return dp[node][par][lastPicked] = res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(auto x:trips)\\n        {   countFrequecy(x[0],x[1],adj,freq,-1);\\n            freq[x[0]]++;\\n        }\\n       \\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));\\n        return min(minCost(0,n,0,price,adj,freq,dp),minCost(0,n,1,price,adj,freq,dp));\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool countFrequecy(int node, int dest,vector<int> adj[],vector<int>&freq, int par)\\n    {\\n        if(node==dest)  // reached the destination\\n            return 1;\\n        bool ans =0;\\n        for(auto x:adj[node])\\n        {\\n            if(x!=par)\\n            {\\n                if(countFrequecy(x,dest,adj,freq,node)) // If destination is in current path\\n                {\\n                    freq[x]++; //incrementing the freq of nodes in the path\\n                    ans=1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int minCost(int node, int par, int lastPicked,vector<int>& price,vector<int> adj[],vector<int>&freq,vector<vector<vector<int>>>&dp)\\n    {\\n        int ans = 1e9,res=0;\\n        if(dp[node][par][lastPicked]!=-1)\\n            return dp[node][par][lastPicked];\\n        if(lastPicked) // if we picked the last i.e, node then price = price/2\\n            res = freq[node]*(price[node]/2);\\n        else\\n            res = freq[node]*(price[node]);\\n        \\n        for(auto x:adj[node])\\n        {\\n            if(x!=par) \\n            {\\n                ans=minCost(x,node,0,price,adj,freq,dp);\\n                if(lastPicked==0)  \\n                    ans = min(ans,minCost(x,node,1,price,adj,freq,dp));\\n                res+=ans;\\n            }\\n        }\\n        return dp[node][par][lastPicked] = res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n-1;i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(auto x:trips)\\n        {   countFrequecy(x[0],x[1],adj,freq,-1);\\n            freq[x[0]]++;\\n        }\\n       \\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>>(n+1,vector<int>(2,-1)));\\n        return min(minCost(0,n,0,price,adj,freq,dp),minCost(0,n,1,price,adj,freq,dp));\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422222,
                "title": "c-solution-used-lambdas",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf we half the price of this current node, we can not half for its children.\\nIf we don\\'t hlaf the price of this current node, we can or can not half for its children. ( 2 choices , take min of those)\\n\\n## Complexity\\n- Time complexity:\\n- O(N^2)   \\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector <vector<int>> g(n);\\n        for (auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <int> cnt(n);\\n\\n        auto bfs = [&](int s, int t) -> void {\\n            vector <int> par(n, -1);\\n            queue <int> Q;\\n            Q.push(s);\\n            while (!Q.empty()) {\\n                int x = Q.front();\\n                Q.pop();\\n                for (auto &v: g[x]) {\\n                    if (par[v] == -1 and v != s) {\\n                        par[v] = x;\\n                        Q.push(v);\\n                    }\\n                }\\n            } \\n            int cur = t;\\n            while (par[cur] != -1) {\\n                cnt[cur]++;\\n                cur = par[cur];\\n            }\\n            cnt[s]++;\\n        };\\n\\n        for (auto trip: trips) {\\n            int x = trip[0];\\n            int y = trip[1];\\n            bfs(x, y);\\n        }\\n        \\n        int cached[n][2];\\n        memset(cached, -1, sizeof cached);\\n\\n        function<int(int, int, int)> go = [&](int node, int p, int is) -> int {\\n            if (cached[node][is] != -1) return cached[node][is];\\n            int new_p = price[node] / (is ? 2 : 1);\\n            int res = cnt[node] * new_p;\\n            for (auto &v: g[node]) {\\n                if (v != p) {\\n                    if (is) {\\n                        res += go(v, node, 0);\\n                    } else {\\n                        res += min(go(v, node, 0), go(v, node, 1));\\n                    }\\n                }\\n            }\\n            return cached[node][is] = res;\\n        };\\n\\n        return min(go(0, -1, 0), go(0, -1, 1));\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector <vector<int>> g(n);\\n        for (auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        vector <int> cnt(n);\\n\\n        auto bfs = [&](int s, int t) -> void {\\n            vector <int> par(n, -1);\\n            queue <int> Q;\\n            Q.push(s);\\n            while (!Q.empty()) {\\n                int x = Q.front();\\n                Q.pop();\\n                for (auto &v: g[x]) {\\n                    if (par[v] == -1 and v != s) {\\n                        par[v] = x;\\n                        Q.push(v);\\n                    }\\n                }\\n            } \\n            int cur = t;\\n            while (par[cur] != -1) {\\n                cnt[cur]++;\\n                cur = par[cur];\\n            }\\n            cnt[s]++;\\n        };\\n\\n        for (auto trip: trips) {\\n            int x = trip[0];\\n            int y = trip[1];\\n            bfs(x, y);\\n        }\\n        \\n        int cached[n][2];\\n        memset(cached, -1, sizeof cached);\\n\\n        function<int(int, int, int)> go = [&](int node, int p, int is) -> int {\\n            if (cached[node][is] != -1) return cached[node][is];\\n            int new_p = price[node] / (is ? 2 : 1);\\n            int res = cnt[node] * new_p;\\n            for (auto &v: g[node]) {\\n                if (v != p) {\\n                    if (is) {\\n                        res += go(v, node, 0);\\n                    } else {\\n                        res += min(go(v, node, 0), go(v, node, 1));\\n                    }\\n                }\\n            }\\n            return cached[node][is] = res;\\n        };\\n\\n        return min(go(0, -1, 0), go(0, -1, 1));\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421754,
                "title": "java-solution-using-dfs-memoisation-for-better-run-time",
                "content": "# Intuition\\nThe main idean here is that you can not decide the nodes to half the cost without knowing the number of times a node is visited.\\nSo first run a simple BFS or DFS and count the number of times a node will be visited. I personally prefer DFS for this situation because of simplicity of code.\\n\\nOnce you have this number, you can find the total cost a node will contribute towards final cost after taking all the trips.\\nNow we need to half the price of few of the nodes. The key here is that they are not suppose to be neighbours but that doesn\\'t mean you can alternate between the nodes.\\neg: a -> b -> c -> d\\nin this case it might be possible that best value will come if you half the price of `a and d` instead of `a and c`; or it can also happen that you must choose `b`\\n\\nSo you need to find the minimum from all these options.\\nYou can again use DFS here and use memoisation to improve the runtime\\n\\n# Approach\\nDFS + Memoisation\\n\\n# Complexity\\n- Time complexity:\\nO(N * N)\\n\\n- Space complexity:\\nO(E + N) = O(N)\\nsince it\\'s a tree, number of edges == number of nodes - 1\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<Integer>[] tree = buildTree(n, edges);\\n        \\n        int[] visitCount = new int[n];\\n        for(int[] trip : trips) {\\n            travel(trip[0], -1, trip[1], tree, visitCount);\\n        }\\n        \\n        int[] cost = new int[n];\\n        int[][] calcualted = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(calcualted[i], -1);\\n            cost[i] = price[i] * visitCount[i];\\n        }\\n        \\n        return minPrice(trips[0][0], -1, tree, 1, cost, calcualted);\\n    }\\n    \\n    private int minPrice(int node, int parent, List<Integer>[] tree, int canHalf, int[] cost, int[][] calculated) {\\n        if (calculated[node][canHalf] != -1) {\\n            return calculated[node][canHalf];\\n        }\\n        \\n        int minPrice;\\n        \\n        int noHalfCurrentNodePrice = cost[node];\\n        for(int next : tree[node]) {\\n            if (next != parent) {\\n                noHalfCurrentNodePrice += minPrice(next, node, tree, 1, cost, calculated);\\n            }\\n        }\\n        \\n        int halfCurrentNodePrice = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            halfCurrentNodePrice = cost[node] / 2;\\n            \\n            for(int next : tree[node]) {\\n                if (next != parent) {\\n                    halfCurrentNodePrice += minPrice(next, node, tree, 0, cost, calculated);\\n                }\\n            }\\n        }\\n        \\n        calculated[node][canHalf] = Math.min(noHalfCurrentNodePrice, halfCurrentNodePrice);\\n        \\n        return calculated[node][canHalf];\\n    }\\n    \\n    private boolean travel(int node, int parent, int target, List<Integer>[] tree, int[] visitCount) {\\n        if (node == target) {\\n            visitCount[node]++;\\n            return true;\\n        }\\n\\n        boolean found = false;\\n        for(int next : tree[node]) {\\n            if (parent != next) {\\n                found |= travel(next, node, target, tree, visitCount);\\n            }\\n            \\n            if (found) {\\n                break;\\n            }\\n        }\\n        \\n        if (found) {\\n            visitCount[node]++;\\n        }\\n        \\n        return found;\\n    }\\n    \\n    private List<Integer>[] buildTree(int n, int[][] edges) {\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            tree[edge[0]].add(edge[1]);\\n            tree[edge[1]].add(edge[0]);\\n        }\\n        \\n        return tree;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<Integer>[] tree = buildTree(n, edges);\\n        \\n        int[] visitCount = new int[n];\\n        for(int[] trip : trips) {\\n            travel(trip[0], -1, trip[1], tree, visitCount);\\n        }\\n        \\n        int[] cost = new int[n];\\n        int[][] calcualted = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(calcualted[i], -1);\\n            cost[i] = price[i] * visitCount[i];\\n        }\\n        \\n        return minPrice(trips[0][0], -1, tree, 1, cost, calcualted);\\n    }\\n    \\n    private int minPrice(int node, int parent, List<Integer>[] tree, int canHalf, int[] cost, int[][] calculated) {\\n        if (calculated[node][canHalf] != -1) {\\n            return calculated[node][canHalf];\\n        }\\n        \\n        int minPrice;\\n        \\n        int noHalfCurrentNodePrice = cost[node];\\n        for(int next : tree[node]) {\\n            if (next != parent) {\\n                noHalfCurrentNodePrice += minPrice(next, node, tree, 1, cost, calculated);\\n            }\\n        }\\n        \\n        int halfCurrentNodePrice = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            halfCurrentNodePrice = cost[node] / 2;\\n            \\n            for(int next : tree[node]) {\\n                if (next != parent) {\\n                    halfCurrentNodePrice += minPrice(next, node, tree, 0, cost, calculated);\\n                }\\n            }\\n        }\\n        \\n        calculated[node][canHalf] = Math.min(noHalfCurrentNodePrice, halfCurrentNodePrice);\\n        \\n        return calculated[node][canHalf];\\n    }\\n    \\n    private boolean travel(int node, int parent, int target, List<Integer>[] tree, int[] visitCount) {\\n        if (node == target) {\\n            visitCount[node]++;\\n            return true;\\n        }\\n\\n        boolean found = false;\\n        for(int next : tree[node]) {\\n            if (parent != next) {\\n                found |= travel(next, node, target, tree, visitCount);\\n            }\\n            \\n            if (found) {\\n                break;\\n            }\\n        }\\n        \\n        if (found) {\\n            visitCount[node]++;\\n        }\\n        \\n        return found;\\n    }\\n    \\n    private List<Integer>[] buildTree(int n, int[][] edges) {\\n        List<Integer>[] tree = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            tree[i] = new ArrayList<Integer>();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            tree[edge[0]].add(edge[1]);\\n            tree[edge[1]].add(edge[0]);\\n        }\\n        \\n        return tree;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421669,
                "title": "javascript-bfs-dfs",
                "content": "**Solution: BFS & DFS**\\n\\nSince it\\'s a tree, there is only one path between each pair of nodes.\\n\\n1. For each trip, use BFS to find the path from the start node to the end node.\\n  Keep track of totalPrice, where `totalPrice[i] = the total price from node i across all trips`.\\n  \\n2. Use DFS with memoization to find the minimum score from taking half price on non-alternate nodes.\\n  Memoize each `dfs(node, parentIsHalfPrice, parent)`.\\n  If the parent is half price, then this node cannot be half price.\\n  If the parent is not half price, we have two choices: either take half price or don\\'t take half price.\\n  Return the minimum price.\\n\\n`n = number of nodes`, `m = number of trips`\\nTime Complexity: `O(m * n^2 + n^2)`\\nSpace Complexity: `O(n)`\\n```\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { // dfs with memoization to find the lowest price  \\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) { // bfs to find the path from start to end\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) { // dfs with memoization to find the lowest price  \\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) { // bfs to find the path from start to end\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964325,
                "title": "c-tree-pruning-recursion-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool rec(int src,int dest,vector<vector<int>> &adj,vector<int> &freq,int parent){\\n        if(src==dest){\\n            freq[dest]++;\\n            return true;\\n        }\\n        \\n        for(auto neg:adj[src]){\\n            if(neg != parent){\\n                bool w = rec(neg,dest,adj,freq,src);\\n                if(w){\\n                   freq[src]++;\\n                   return w;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\nint helper(int src,int prev,int parent,vector<vector<int>> &adj,vector<vector<vector<int>>> &dp,vector<int> &price,vector<int> &vis){\\n     \\n        vis[src] =0;\\n        if(adj[src].size()==0)  return price[src]/2;\\n\\n        if(adj[src].size() == 1){\\n            if(adj[src][0] == parent){\\n                if(prev != parent) return price[src]/2;\\n                else  return price[src];\\n            }\\n        }\\n        if(prev!=-1 && parent !=-2 && dp[src][prev+1][parent+2]!=-1) return dp[src][prev+1][parent+2];\\n        bool w=true;\\n        if(prev==parent) w =false;\\n        int  ans =0;\\n        if(w){\\n            int ans1=0,ans2=0;\\n            for(auto neg:adj[src]){\\n                if(neg!=parent){    \\n                 ans1 +=  helper(neg,src,src,adj,dp,price,vis);\\n                 ans2 +=  helper(neg,prev,src,adj,dp,price,vis);\\n                }\\n            }\\n            ans = min(ans1+price[src]/2,ans2+price[src]);\\n        }\\n        else{\\n            int ans3=0;\\n            for(auto neg:adj[src])\\n                if(neg!=parent)  ans3 +=helper(neg,prev,src,adj,dp,price,vis); \\n\\n            ans = ans3+price[src];\\n        }\\n        return dp[src][prev+1][parent+2] =ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // return 0;\\n        vector<vector<int>> adj1(n);\\n        int m =edges.size();\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj1[u].push_back(v);\\n            adj1[v].push_back(u);\\n        }\\n        vector<int> freq(n,0);\\n        for(int i=0;i<trips.size();i++)\\n           rec(trips[i][0],trips[i][1],adj1,freq,-1);\\n        vector<vector<int>> adj2(n);\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(freq[u] != 0 && freq[v] != 0){\\n                adj2[u].push_back(v);\\n                adj2[v].push_back(u);\\n            }\\n        }\\n\\n        int mxi=-1,mx=1e9;\\n        for(int i=0;i<n;i++){\\n            price[i]= price[i]*freq[i];\\n            if(freq[i]<mx && freq[i]>0){\\n                mx=freq[i];\\n                mxi=i;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (n+2,vector<int>(n+3,-1)));\\n        int ans = helper(mxi,-1,-2,adj2,dp,price,freq);\\n        for(int i=0;i<n;i++){\\n            if(freq[i]>0){\\n                ans+=helper(i,-1,-2,adj2,dp,price,freq);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool rec(int src,int dest,vector<vector<int>> &adj,vector<int> &freq,int parent){\\n        if(src==dest){\\n            freq[dest]++;\\n            return true;\\n        }\\n        \\n        for(auto neg:adj[src]){\\n            if(neg != parent){\\n                bool w = rec(neg,dest,adj,freq,src);\\n                if(w){\\n                   freq[src]++;\\n                   return w;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n\\nint helper(int src,int prev,int parent,vector<vector<int>> &adj,vector<vector<vector<int>>> &dp,vector<int> &price,vector<int> &vis){\\n     \\n        vis[src] =0;\\n        if(adj[src].size()==0)  return price[src]/2;\\n\\n        if(adj[src].size() == 1){\\n            if(adj[src][0] == parent){\\n                if(prev != parent) return price[src]/2;\\n                else  return price[src];\\n            }\\n        }\\n        if(prev!=-1 && parent !=-2 && dp[src][prev+1][parent+2]!=-1) return dp[src][prev+1][parent+2];\\n        bool w=true;\\n        if(prev==parent) w =false;\\n        int  ans =0;\\n        if(w){\\n            int ans1=0,ans2=0;\\n            for(auto neg:adj[src]){\\n                if(neg!=parent){    \\n                 ans1 +=  helper(neg,src,src,adj,dp,price,vis);\\n                 ans2 +=  helper(neg,prev,src,adj,dp,price,vis);\\n                }\\n            }\\n            ans = min(ans1+price[src]/2,ans2+price[src]);\\n        }\\n        else{\\n            int ans3=0;\\n            for(auto neg:adj[src])\\n                if(neg!=parent)  ans3 +=helper(neg,prev,src,adj,dp,price,vis); \\n\\n            ans = ans3+price[src];\\n        }\\n        return dp[src][prev+1][parent+2] =ans;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // return 0;\\n        vector<vector<int>> adj1(n);\\n        int m =edges.size();\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj1[u].push_back(v);\\n            adj1[v].push_back(u);\\n        }\\n        vector<int> freq(n,0);\\n        for(int i=0;i<trips.size();i++)\\n           rec(trips[i][0],trips[i][1],adj1,freq,-1);\\n        vector<vector<int>> adj2(n);\\n        for(int i=0;i<m;i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            if(freq[u] != 0 && freq[v] != 0){\\n                adj2[u].push_back(v);\\n                adj2[v].push_back(u);\\n            }\\n        }\\n\\n        int mxi=-1,mx=1e9;\\n        for(int i=0;i<n;i++){\\n            price[i]= price[i]*freq[i];\\n            if(freq[i]<mx && freq[i]>0){\\n                mx=freq[i];\\n                mxi=i;\\n            }\\n        }\\n        vector<vector<vector<int>>> dp(n+1,vector<vector<int>> (n+2,vector<int>(n+3,-1)));\\n        int ans = helper(mxi,-1,-2,adj2,dp,price,freq);\\n        for(int i=0;i<n;i++){\\n            if(freq[i]>0){\\n                ans+=helper(i,-1,-2,adj2,dp,price,freq);\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953219,
                "title": "java-beats-100-clean-no-memo-one-pass-for-discount-calculation",
                "content": "# Code\\n```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int[] count;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        //build graph\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        // array to count how many times each vertex is used\\n        count = new int[n];\\n        for (int[] t : trips) {\\n            // simple dfs to find path for every trip\\n            getPath(t[0], -1, t[1]);\\n        }\\n        // calculate max sum we can get with no adjacent vertices\\n        int[] maxSum = getMax(0, -1, price);\\n        // deduct half from the final result\\n        int res = -Math.max(maxSum[0], maxSum[1])/2;\\n        for (int i = 0; i < n; i++) {\\n            // get sum of all vertices in use\\n            res += count[i]*price[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    // return int[2]\\n    // 0 => max sum if current vertex taken\\n    // 1 => max sum if current vertex is not taken\\n    public int[] getMax(int current, int prev, int[] price) {\\n        \\n        int[] res = new int[]{price[current]*count[current], 0};\\n\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            int[] curr = getMax(v, current, price);\\n            res[0] += curr[1];\\n            res[1] += Math.max(curr[0], curr[1]);\\n        }\\n        return res;\\n    }\\n\\n    // simple dfs to count vertices in the path\\n    public boolean getPath(int current, int prev, int search) {\\n        if (current == search) {\\n            count[current]++;\\n            return true;\\n        }\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            if (getPath(v, current, search)) {\\n                count[current]++;\\n                return true;    \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer>[] graph;\\n    int[] count;\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        //build graph\\n        graph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        // array to count how many times each vertex is used\\n        count = new int[n];\\n        for (int[] t : trips) {\\n            // simple dfs to find path for every trip\\n            getPath(t[0], -1, t[1]);\\n        }\\n        // calculate max sum we can get with no adjacent vertices\\n        int[] maxSum = getMax(0, -1, price);\\n        // deduct half from the final result\\n        int res = -Math.max(maxSum[0], maxSum[1])/2;\\n        for (int i = 0; i < n; i++) {\\n            // get sum of all vertices in use\\n            res += count[i]*price[i];\\n        }\\n\\n        return res;\\n    }\\n\\n    // return int[2]\\n    // 0 => max sum if current vertex taken\\n    // 1 => max sum if current vertex is not taken\\n    public int[] getMax(int current, int prev, int[] price) {\\n        \\n        int[] res = new int[]{price[current]*count[current], 0};\\n\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            int[] curr = getMax(v, current, price);\\n            res[0] += curr[1];\\n            res[1] += Math.max(curr[0], curr[1]);\\n        }\\n        return res;\\n    }\\n\\n    // simple dfs to count vertices in the path\\n    public boolean getPath(int current, int prev, int search) {\\n        if (current == search) {\\n            count[current]++;\\n            return true;\\n        }\\n        for (int v : graph[current]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            if (getPath(v, current, search)) {\\n                count[current]++;\\n                return true;    \\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492511,
                "title": "c-brute-force-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(2*n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, int p, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                par[it]=i;\\n                lvl[it]=lvl[i]+1;\\n                dfs(it, i, lvl, par, adj);\\n            }\\n        }\\n    }\\n    vector<int>cnt(int i, int j, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        int mini, maxi;\\n        vector<int>ans;\\n        if(lvl[i]<=lvl[j]){\\n            mini=i, maxi=j;\\n        }\\n        else{\\n            mini=j;\\n            maxi=i;\\n        }\\n        while(lvl[maxi]!=lvl[mini]){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n        }\\n        while(maxi!=mini){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n            ans.push_back(mini);\\n            mini=par[mini];\\n        }\\n        ans.push_back(mini);\\n        return ans;\\n    }\\n    void chk(int i, int p, vector<vector<int>>&cost, vector<int>&price, vector<int>&v1, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                chk(it, i, cost, price, v1, adj);\\n            }\\n        }\\n        cost[0][i]=price[i]*v1[i]/2;\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[0][i]+=cost[1][it];\\n            }\\n        }\\n        cost[1][i]=price[i]*v1[i];\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[1][i]+=min(cost[1][it], cost[0][it]);\\n            }\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>lvl(n, 0), par(n, -1), v1(n, 0);\\n        dfs(0, -1, lvl, par, adj);\\n        for(int i=0; i<trips.size(); i++){\\n            vector<int>v=cnt(trips[i][0], trips[i][1], lvl, par, adj);\\n            for(int i=0; i<v.size(); i++){\\n                v1[v[i]]++;\\n            }\\n        }\\n        vector<vector<int>>cost(2, vector<int>(n, 0));\\n        chk(0, -1, cost, price, v1, adj);\\n        return min(cost[0][0], cost[1][0]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int p, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                par[it]=i;\\n                lvl[it]=lvl[i]+1;\\n                dfs(it, i, lvl, par, adj);\\n            }\\n        }\\n    }\\n    vector<int>cnt(int i, int j, vector<int>&lvl, vector<int>&par, vector<int>adj[]){\\n        int mini, maxi;\\n        vector<int>ans;\\n        if(lvl[i]<=lvl[j]){\\n            mini=i, maxi=j;\\n        }\\n        else{\\n            mini=j;\\n            maxi=i;\\n        }\\n        while(lvl[maxi]!=lvl[mini]){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n        }\\n        while(maxi!=mini){\\n            ans.push_back(maxi);\\n            maxi=par[maxi];\\n            ans.push_back(mini);\\n            mini=par[mini];\\n        }\\n        ans.push_back(mini);\\n        return ans;\\n    }\\n    void chk(int i, int p, vector<vector<int>>&cost, vector<int>&price, vector<int>&v1, vector<int>adj[]){\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                chk(it, i, cost, price, v1, adj);\\n            }\\n        }\\n        cost[0][i]=price[i]*v1[i]/2;\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[0][i]+=cost[1][it];\\n            }\\n        }\\n        cost[1][i]=price[i]*v1[i];\\n        for(auto it: adj[i]){\\n            if(it!=p){\\n                cost[1][i]+=min(cost[1][it], cost[0][it]);\\n            }\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>lvl(n, 0), par(n, -1), v1(n, 0);\\n        dfs(0, -1, lvl, par, adj);\\n        for(int i=0; i<trips.size(); i++){\\n            vector<int>v=cnt(trips[i][0], trips[i][1], lvl, par, adj);\\n            for(int i=0; i<v.size(); i++){\\n                v1[v[i]]++;\\n            }\\n        }\\n        vector<vector<int>>cost(2, vector<int>(n, 0));\\n        chk(0, -1, cost, price, v1, adj);\\n        return min(cost[0][0], cost[1][0]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486238,
                "title": "2646-minimize-the-total-price-of-the-trips-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2 * log(N))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) {\\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) {\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function(n, edges, price, trips) {\\n  let graph = Array(n).fill(0).map(() => []);\\n  for (let [a, b] of edges) {\\n    graph[a].push(b);\\n    graph[b].push(a);\\n  }\\n  let totalPrice = Array(n).fill(0);\\n  for (let [start, end] of trips) {\\n    let path = makeTrip(start, end);\\n    for (let node of path) {\\n      totalPrice[node] += price[node];\\n    }\\n  }\\n  let memo = new Map();\\n  return dfs(0, false, -1);\\n  \\n  function dfs(node, parentIsHalfPrice, parent) {\\n    let key = `${node},${parentIsHalfPrice},${parent}`;\\n    if (memo.has(key)) return memo.get(key);\\n\\n    if (parentIsHalfPrice) {\\n      let ans = totalPrice[node];\\n      for (let nei of graph[node]) {\\n        if (nei === parent) continue;\\n        ans += dfs(nei, false, node);\\n      }\\n      memo.set(key, ans);\\n      return ans;\\n    }\\n    \\n    let takeHalfPrice = totalPrice[node] / 2, noHalfPrice = totalPrice[node];\\n    for (let nei of graph[node]) {\\n      if (nei === parent) continue;\\n      takeHalfPrice += dfs(nei, true, node);\\n      noHalfPrice += dfs(nei, false, node);\\n    }\\n    let ans = Math.min(takeHalfPrice, noHalfPrice);\\n    memo.set(key, ans);\\n    return ans;\\n  }\\n  \\n  function makeTrip(start, end) {\\n    let queue = [[start, [start]]], seen = Array(n).fill(0);\\n    seen[start] = 1;\\n    while (queue.length) {\\n      let [node, path] = queue.shift();\\n      if (node === end) return path;\\n      for (let nei of graph[node]) {\\n        if (seen[nei]) continue;\\n        seen[nei] = 1;\\n        queue.push([nei, [...path, nei]]);\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3444706,
                "title": "java-dfs-dp-with-comments",
                "content": "```\\nclass Solution {\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    int[] freq;\\n    int[] price;\\n    int[][] dp;\\n    \\n\\t// dfs to find the frequency of all nodes in trips\\n    boolean dfs(int src, int dest, int parent) {\\n        if(src == dest){\\n            freq[src]++;\\n            return true;\\n        }\\n        boolean found = false;\\n        if(graph.containsKey(src)) {\\n            for(int nei: graph.get(src)) {\\n                if(nei != parent) {\\n                    found |= dfs(nei, dest, src);\\n                }\\n                if(found) break;\\n            }\\n        }\\n        if(found) freq[src]++;\\n        return found;\\n    }\\n    \\n\\t// to find th minimum value of price using recursion and memoization\\n    int recursion(int node, int parent, int half) {\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int res1 = (price[node] * freq[node]) / 2, res2 = price[node] * freq[node];\\n        if(graph.containsKey(node)) {\\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res2 += recursion(i, node, 0);\\n                }\\n            }\\n            \\n            if(half == 1){\\n                dp[node][half] = res2;\\n                return res2;\\n            }\\n            \\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res1 += recursion(i, node, 1);\\n                }\\n            }\\n        } \\n        return dp[node][half] = Math.min(res1, res2);\\n    }\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\t\\t// creating graph\\n        graph = new HashMap<>();\\n        for(int[] edge: edges) {\\n            if(!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if(!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n\\t\\t// creating frequency array\\n        freq = new int[n];\\n        for(int[] trip: trips) {\\n            dfs(trip[0], trip[1], -1);\\n        }\\n        \\n\\t\\t// finding minimum price\\n        dp = new int[n][2];\\n        for(int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\\n        this.price = price;\\n        return recursion(0, -1, 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer, ArrayList<Integer>> graph;\\n    int[] freq;\\n    int[] price;\\n    int[][] dp;\\n    \\n\\t// dfs to find the frequency of all nodes in trips\\n    boolean dfs(int src, int dest, int parent) {\\n        if(src == dest){\\n            freq[src]++;\\n            return true;\\n        }\\n        boolean found = false;\\n        if(graph.containsKey(src)) {\\n            for(int nei: graph.get(src)) {\\n                if(nei != parent) {\\n                    found |= dfs(nei, dest, src);\\n                }\\n                if(found) break;\\n            }\\n        }\\n        if(found) freq[src]++;\\n        return found;\\n    }\\n    \\n\\t// to find th minimum value of price using recursion and memoization\\n    int recursion(int node, int parent, int half) {\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int res1 = (price[node] * freq[node]) / 2, res2 = price[node] * freq[node];\\n        if(graph.containsKey(node)) {\\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res2 += recursion(i, node, 0);\\n                }\\n            }\\n            \\n            if(half == 1){\\n                dp[node][half] = res2;\\n                return res2;\\n            }\\n            \\n            for(int i : graph.get(node)) {\\n                if(i != parent) {\\n                    res1 += recursion(i, node, 1);\\n                }\\n            }\\n        } \\n        return dp[node][half] = Math.min(res1, res2);\\n    }\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\t\\t// creating graph\\n        graph = new HashMap<>();\\n        for(int[] edge: edges) {\\n            if(!graph.containsKey(edge[0])) graph.put(edge[0], new ArrayList<>());\\n            if(!graph.containsKey(edge[1])) graph.put(edge[1], new ArrayList<>());\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n\\t\\t// creating frequency array\\n        freq = new int[n];\\n        for(int[] trip: trips) {\\n            dfs(trip[0], trip[1], -1);\\n        }\\n        \\n\\t\\t// finding minimum price\\n        dp = new int[n][2];\\n        for(int i = 0; i < n; i++) Arrays.fill(dp[i], -1);\\n        this.price = price;\\n        return recursion(0, -1, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439456,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n1. Perform DFS to track the count `cnt` of nodes traversed for the input `trips`\\n2. Use DP to create a 0-1 knapsack to optimally `include` xor `exclude` non-adjacent nodes for half-price discount\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minimumTotalPrice(N: Int, E: Array<IntArray>, price: IntArray, trips: Array<IntArray>, INF: Int = 1e9.toInt() + 7): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); (0 until N).forEach{ adj[it] = mutableSetOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var cnt = IntArray(N){ 0 }\\n        fun go(u: Int, target: Int, seen: MutableSet<Int>): Boolean {\\n            if (u == target) {\\n                seen.forEach{ ++cnt[it] }\\n                return true\\n            }\\n            for (v in adj[u]!!) {\\n                if (!seen.contains(v)) {\\n                    seen.add(v)\\n                    if (go(v, target, seen))\\n                        return true\\n                    seen.remove(v)\\n                }\\n            }\\n            return false\\n        }\\n        for ((u, v) in trips)\\n            go(u, v, mutableSetOf<Int>(u))\\n        var cost = (price zip cnt).map{ (x, y) -> x * y }\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { u: Int, last: Int, last_discount: Boolean -> \"$u,$last,$last_discount\" })\\n        fun dp(u: Int = 0, last: Int = 0, last_discount: Boolean = false): Int {\\n            var k = key(u, last, last_discount)\\n            if (!m.contains(k)) {\\n                var include = if (last_discount) INF else cost[u] / 2\\n                var exclude = cost[u]\\n                for (v in adj[u]!!) {\\n                    if (v != last) {\\n                        include += dp(v, u, true)\\n                        exclude += dp(v, u, false)    \\n                    }\\n                }\\n                m[k] = Math.min(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return dp()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minimumTotalPrice = (N, E, price, trips, cnt = Array(N).fill(0), m = new Map(), INF = Number(1e9 + 7)) => {\\n    let adj = new Map([...Array(N).keys()].map(v => [v, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let go = (u, target, seen) => {\\n        if (u == target) {\\n            seen.forEach(v => ++cnt[v]);\\n            return true;\\n        }\\n        for (let v of adj.get(u)) {\\n            if (!seen.has(v)) {\\n                seen.add(v);\\n                if (go(v, target, seen))\\n                    return true;\\n                seen.delete(v);\\n            }\\n        }\\n        return false;\\n    };\\n    for (let [u, v] of trips)\\n        go(u, v, new Set([u]));\\n    let cost = _.zip(price, cnt).map(([x, y]) => x * y);\\n    let key = (u, last, last_discount) => `${u},${last},${last_discount}`;\\n    let dp = (u = 0, last = 0, last_discount = false) => {\\n        let k = key(u, last, last_discount);\\n        if (!m.has(k)) {\\n            let include = last_discount ? INF : Math.floor(cost[u] / 2),\\n                exclude = cost[u];\\n            for (let v of adj.get(u)) {\\n                if (v != last) {\\n                    include += dp(v, u, true);\\n                    exclude += dp(v, u, false);\\n                }\\n            }\\n            m.set(k, Math.min(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return dp();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, E: List[List[int]], price: List[int], trips: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        cnt = [0] * N\\n        def go(u, target, seen):\\n            if u == target:\\n                for i in seen:\\n                    cnt[i] += 1\\n                return True\\n            for v in adj[u]:\\n                if v not in seen:\\n                    seen.add(v)\\n                    if go(v, target, seen):\\n                        return True\\n                    seen.remove(v)\\n            return False\\n        for u, v in trips:\\n            go(u, v, set([u]))\\n        cost = [x * y for x, y in zip(price, cnt)]\\n        @cache\\n        def dp(u = 0, last = -1, last_discount = False):\\n            include = cost[u] // 2 if not last_discount else INF\\n            exclude = cost[u]\\n            for v in adj[u]:\\n                if v != last:\\n                    include += dp(v, u, True)\\n                    exclude += dp(v, u, False)\\n            return min(include, exclude)\\n        return dp()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using Cnt = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun1 = function<bool(int, int, Set&&)>;\\n    using fun2 = function<int(int, int, bool)>;\\n    using Memo = unordered_map<string, int>;\\n    int minimumTotalPrice(int N, VVI& E, VI& price, VVI& T, Adj adj = {}, Cnt cnt = {}, VI cost = {}, Memo m = {}, int INF = 1e9 + 7) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        fun1 go = [&](auto u, auto target, auto&& seen) {\\n            if (u == target) {\\n                for (auto& v: seen)\\n                    ++cnt[v];\\n                return true;\\n            }\\n            for (auto v: adj[u]) {\\n                if (seen.insert(v).second) {\\n                    if (go(v, target, move(seen)))\\n                        return true;\\n                    seen.erase(v);\\n                }\\n            }\\n            return false;\\n        };\\n        for (auto& trip: T)\\n            go(trip[0], trip[1], {trip[0]});\\n        for (auto i{ 0 }; i < N; ++i)\\n            cost.push_back(price[i] * cnt[i]);\\n        auto key = [](auto u, auto last, auto last_discount) {\\n            stringstream ss; ss << u << \",\" << last << \",\" << last_discount;\\n            return ss.str();\\n        };\\n        fun2 dp = [&](auto u, auto last, auto last_discount) {\\n            auto k = key(u, last, last_discount);\\n            if (m.find(k) == m.end()) {\\n                auto include = last_discount ? INF : cost[u] / 2,\\n                     exclude = cost[u];\\n                for (auto v: adj[u]) {\\n                    if (v != last) {\\n                        include += dp(v, u, true);\\n                        exclude += dp(v, u, false);\\n                    }\\n                }\\n                m[k] = min(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return dp(0, 0, false);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumTotalPrice(N: Int, E: Array<IntArray>, price: IntArray, trips: Array<IntArray>, INF: Int = 1e9.toInt() + 7): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>(); (0 until N).forEach{ adj[it] = mutableSetOf<Int>() }\\n        for ((u, v) in E) {\\n            adj[u]!!.add(v)\\n            adj[v]!!.add(u)\\n        }\\n        var cnt = IntArray(N){ 0 }\\n        fun go(u: Int, target: Int, seen: MutableSet<Int>): Boolean {\\n            if (u == target) {\\n                seen.forEach{ ++cnt[it] }\\n                return true\\n            }\\n            for (v in adj[u]!!) {\\n                if (!seen.contains(v)) {\\n                    seen.add(v)\\n                    if (go(v, target, seen))\\n                        return true\\n                    seen.remove(v)\\n                }\\n            }\\n            return false\\n        }\\n        for ((u, v) in trips)\\n            go(u, v, mutableSetOf<Int>(u))\\n        var cost = (price zip cnt).map{ (x, y) -> x * y }\\n        var (m, key) = Pair(mutableMapOf<String, Int>(), { u: Int, last: Int, last_discount: Boolean -> \"$u,$last,$last_discount\" })\\n        fun dp(u: Int = 0, last: Int = 0, last_discount: Boolean = false): Int {\\n            var k = key(u, last, last_discount)\\n            if (!m.contains(k)) {\\n                var include = if (last_discount) INF else cost[u] / 2\\n                var exclude = cost[u]\\n                for (v in adj[u]!!) {\\n                    if (v != last) {\\n                        include += dp(v, u, true)\\n                        exclude += dp(v, u, false)    \\n                    }\\n                }\\n                m[k] = Math.min(include, exclude)\\n            }\\n            return m[k]!!\\n        }\\n        return dp()\\n    }\\n}\\n```\n```\\nlet minimumTotalPrice = (N, E, price, trips, cnt = Array(N).fill(0), m = new Map(), INF = Number(1e9 + 7)) => {\\n    let adj = new Map([...Array(N).keys()].map(v => [v, []]));\\n    for (let [u, v] of E) {\\n        adj.get(u).push(v);\\n        adj.get(v).push(u);\\n    }\\n    let go = (u, target, seen) => {\\n        if (u == target) {\\n            seen.forEach(v => ++cnt[v]);\\n            return true;\\n        }\\n        for (let v of adj.get(u)) {\\n            if (!seen.has(v)) {\\n                seen.add(v);\\n                if (go(v, target, seen))\\n                    return true;\\n                seen.delete(v);\\n            }\\n        }\\n        return false;\\n    };\\n    for (let [u, v] of trips)\\n        go(u, v, new Set([u]));\\n    let cost = _.zip(price, cnt).map(([x, y]) => x * y);\\n    let key = (u, last, last_discount) => `${u},${last},${last_discount}`;\\n    let dp = (u = 0, last = 0, last_discount = false) => {\\n        let k = key(u, last, last_discount);\\n        if (!m.has(k)) {\\n            let include = last_discount ? INF : Math.floor(cost[u] / 2),\\n                exclude = cost[u];\\n            for (let v of adj.get(u)) {\\n                if (v != last) {\\n                    include += dp(v, u, true);\\n                    exclude += dp(v, u, false);\\n                }\\n            }\\n            m.set(k, Math.min(include, exclude));\\n        }\\n        return m.get(k);\\n    };\\n    return dp();\\n};\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, E: List[List[int]], price: List[int], trips: List[List[int]], INF = int(1e9 + 7)) -> int:\\n        adj = defaultdict(list)\\n        for u, v in E:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        cnt = [0] * N\\n        def go(u, target, seen):\\n            if u == target:\\n                for i in seen:\\n                    cnt[i] += 1\\n                return True\\n            for v in adj[u]:\\n                if v not in seen:\\n                    seen.add(v)\\n                    if go(v, target, seen):\\n                        return True\\n                    seen.remove(v)\\n            return False\\n        for u, v in trips:\\n            go(u, v, set([u]))\\n        cost = [x * y for x, y in zip(price, cnt)]\\n        @cache\\n        def dp(u = 0, last = -1, last_discount = False):\\n            include = cost[u] // 2 if not last_discount else INF\\n            exclude = cost[u]\\n            for v in adj[u]:\\n                if v != last:\\n                    include += dp(v, u, True)\\n                    exclude += dp(v, u, False)\\n            return min(include, exclude)\\n        return dp()\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Adj = unordered_map<int, VI>;\\n    using Cnt = unordered_map<int, int>;\\n    using Set = unordered_set<int>;\\n    using fun1 = function<bool(int, int, Set&&)>;\\n    using fun2 = function<int(int, int, bool)>;\\n    using Memo = unordered_map<string, int>;\\n    int minimumTotalPrice(int N, VVI& E, VI& price, VVI& T, Adj adj = {}, Cnt cnt = {}, VI cost = {}, Memo m = {}, int INF = 1e9 + 7) {\\n        for (auto& edge: E) {\\n            auto [u, v] = tie(edge[0], edge[1]);\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        fun1 go = [&](auto u, auto target, auto&& seen) {\\n            if (u == target) {\\n                for (auto& v: seen)\\n                    ++cnt[v];\\n                return true;\\n            }\\n            for (auto v: adj[u]) {\\n                if (seen.insert(v).second) {\\n                    if (go(v, target, move(seen)))\\n                        return true;\\n                    seen.erase(v);\\n                }\\n            }\\n            return false;\\n        };\\n        for (auto& trip: T)\\n            go(trip[0], trip[1], {trip[0]});\\n        for (auto i{ 0 }; i < N; ++i)\\n            cost.push_back(price[i] * cnt[i]);\\n        auto key = [](auto u, auto last, auto last_discount) {\\n            stringstream ss; ss << u << \",\" << last << \",\" << last_discount;\\n            return ss.str();\\n        };\\n        fun2 dp = [&](auto u, auto last, auto last_discount) {\\n            auto k = key(u, last, last_discount);\\n            if (m.find(k) == m.end()) {\\n                auto include = last_discount ? INF : cost[u] / 2,\\n                     exclude = cost[u];\\n                for (auto v: adj[u]) {\\n                    if (v != last) {\\n                        include += dp(v, u, true);\\n                        exclude += dp(v, u, false);\\n                    }\\n                }\\n                m[k] = min(include, exclude);\\n            }\\n            return m[k];\\n        };\\n        return dp(0, 0, false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434290,
                "title": "swift-solution-two-times-using-dfs",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    func minimumTotalPrice(_ n: Int, _ edges: [[Int]], _ price: [Int], _ trips: [[Int]]) -> Int {\\n        var visited: Set<Int> = []\\n        var graph: [Int: [Int]] = [:]\\n        var count: [Int: Int] = [:]\\n\\n        for edge in edges {\\n            graph[edge[0], default: []].append(edge[1])\\n            graph[edge[1], default: []].append(edge[0])\\n        }\\n\\n        for trip in trips {\\n            visited = []\\n            for c in dfs(start: trip[0], end: trip[1], visited: &visited, graph: graph) {\\n                count[c, default: 0] += 1\\n            }\\n        }\\n        visited = []\\n        let res = dfs(0, &visited, graph, price, count)\\n        return min(res.0, res.1)\\n    }\\n\\n    private func dfs(start: Int, end: Int, visited: inout Set<Int>, graph: [Int: [Int]]) -> [Int] {\\n\\n        guard start != end else { return [start] }\\n\\n        visited.insert(start)\\n        for n in graph[start, default: []] where !visited.contains(n) {\\n            if n == end {\\n                return [start, end]\\n            } else {\\n                let res = dfs(start: n, end: end, visited: &visited, graph: graph)\\n                if res != [] {\\n                    return [start] + res\\n                }\\n            }\\n        }\\n\\n        return []\\n    }\\n\\n    private func dfs(_ i: Int, _ visited: inout Set<Int>, _ graph: [Int: [Int]], _ price: [Int], _ count: [Int: Int]) -> (Int, Int) {\\n        visited.insert(i)\\n        guard let notVisitedNeighbours = graph[i]?.filter({ !visited.contains($0) }) else {\\n            return (count[i, default: 0] * (price[i] / 2), count[i, default: 0] * price[i])\\n        }\\n\\n        let notVisitedPrices = notVisitedNeighbours.map { dfs($0, &visited, graph, price, count) }\\n        let halve = count[i, default: 0] * (price[i] / 2) + notVisitedPrices.map(\\\\.1).reduce(0, +)\\n        let notHalve = count[i, default: 0] * price[i] + notVisitedPrices.map { min($0.0, $0.1) }.reduce(0, +)\\n\\n        return (halve, notHalve)\\n    }\\n}\\n```\\nSimilar problem: https://leetcode.com/problems/house-robber-iii/description/",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func minimumTotalPrice(_ n: Int, _ edges: [[Int]], _ price: [Int], _ trips: [[Int]]) -> Int {\\n        var visited: Set<Int> = []\\n        var graph: [Int: [Int]] = [:]\\n        var count: [Int: Int] = [:]\\n\\n        for edge in edges {\\n            graph[edge[0], default: []].append(edge[1])\\n            graph[edge[1], default: []].append(edge[0])\\n        }\\n\\n        for trip in trips {\\n            visited = []\\n            for c in dfs(start: trip[0], end: trip[1], visited: &visited, graph: graph) {\\n                count[c, default: 0] += 1\\n            }\\n        }\\n        visited = []\\n        let res = dfs(0, &visited, graph, price, count)\\n        return min(res.0, res.1)\\n    }\\n\\n    private func dfs(start: Int, end: Int, visited: inout Set<Int>, graph: [Int: [Int]]) -> [Int] {\\n\\n        guard start != end else { return [start] }\\n\\n        visited.insert(start)\\n        for n in graph[start, default: []] where !visited.contains(n) {\\n            if n == end {\\n                return [start, end]\\n            } else {\\n                let res = dfs(start: n, end: end, visited: &visited, graph: graph)\\n                if res != [] {\\n                    return [start] + res\\n                }\\n            }\\n        }\\n\\n        return []\\n    }\\n\\n    private func dfs(_ i: Int, _ visited: inout Set<Int>, _ graph: [Int: [Int]], _ price: [Int], _ count: [Int: Int]) -> (Int, Int) {\\n        visited.insert(i)\\n        guard let notVisitedNeighbours = graph[i]?.filter({ !visited.contains($0) }) else {\\n            return (count[i, default: 0] * (price[i] / 2), count[i, default: 0] * price[i])\\n        }\\n\\n        let notVisitedPrices = notVisitedNeighbours.map { dfs($0, &visited, graph, price, count) }\\n        let halve = count[i, default: 0] * (price[i] / 2) + notVisitedPrices.map(\\\\.1).reduce(0, +)\\n        let notHalve = count[i, default: 0] * price[i] + notVisitedPrices.map { min($0.0, $0.1) }.reduce(0, +)\\n\\n        return (halve, notHalve)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424029,
                "title": "easy-c-using-dfs-backtracking-dp",
                "content": "# Approach\\nFirstly I counted the number of nodes that will be in all trips using DFS + Backtracking.\\nThen again I did a dfs traversal where for every node I have 2 choices either to half the price or not. If I half the price of current node then its children won\\'t have any option of halving but if I decide not to half then its children will have option to be halved. Similarly do it for all nodes and then you can easily memoise it using a 2d vector as there will be 2 states of dp: First is the node and second is whether to half or not. One may argue to maintain a third state of parent as well but as it is a tree so all nodes have unique parents therefore no need to maintain a third state of dp.\\n\\n# Complexity\\n- Time complexity:O(T*N)  where T= no of trips\\n\\n\\n- Space complexity:\\nO(N+E) + O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs1(int node , int dest , vector<int> adj[] , int par , vector<int> & path , vector<int> & cnt){\\n        if(node == dest){\\n            for(auto & i  : path){\\n                cnt[i]++;\\n            }\\n            cnt[dest]++;\\n            return;\\n        }\\n        path.push_back(node);\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                dfs1(child , dest , adj , node , path , cnt);\\n            }\\n        }\\n        path.pop_back();\\n    }\\n    int help(vector<int> adj[] , int node , int par , int half , vector<int> & price , vector<vector<int>>& dp){\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int will_do_half = price[node]/2;\\n        int not_do_half = price[node];\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                will_do_half += help(adj , child , node , 0 , price , dp);\\n                not_do_half += help(adj , child , node , 1 , price , dp);\\n            }\\n        }\\n        if(half) return dp[node][half] = min(will_do_half , not_do_half);\\n        return dp[node][half] = not_do_half;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto & i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int> path , cnt(n , 0);\\n        for(auto & i : trips){\\n            dfs1(i[0] , i[1] , adj , -1 , path , cnt);\\n        }\\n        for(int i = 0 ;  i < n ; i++){\\n            price[i] *= cnt[i];\\n        }\\n        vector<vector<int>> dp(n , vector<int>(2,-1));\\n        return help(adj , 0 , -1 , 1 , price , dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs1(int node , int dest , vector<int> adj[] , int par , vector<int> & path , vector<int> & cnt){\\n        if(node == dest){\\n            for(auto & i  : path){\\n                cnt[i]++;\\n            }\\n            cnt[dest]++;\\n            return;\\n        }\\n        path.push_back(node);\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                dfs1(child , dest , adj , node , path , cnt);\\n            }\\n        }\\n        path.pop_back();\\n    }\\n    int help(vector<int> adj[] , int node , int par , int half , vector<int> & price , vector<vector<int>>& dp){\\n        if(dp[node][half] != -1) return dp[node][half];\\n        int will_do_half = price[node]/2;\\n        int not_do_half = price[node];\\n        for(auto & child : adj[node]){\\n            if(child != par){\\n                will_do_half += help(adj , child , node , 0 , price , dp);\\n                not_do_half += help(adj , child , node , 1 , price , dp);\\n            }\\n        }\\n        if(half) return dp[node][half] = min(will_do_half , not_do_half);\\n        return dp[node][half] = not_do_half;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto & i : edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        vector<int> path , cnt(n , 0);\\n        for(auto & i : trips){\\n            dfs1(i[0] , i[1] , adj , -1 , path , cnt);\\n        }\\n        for(int i = 0 ;  i < n ; i++){\\n            price[i] *= cnt[i];\\n        }\\n        vector<vector<int>> dp(n , vector<int>(2,-1));\\n        return help(adj , 0 , -1 , 1 , price , dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423623,
                "title": "bfs-dfs-dp-detailed-explanation-multiple-languages-well-commented",
                "content": "# Intuition & Approach\\nGiven a undirected and unrooted tree with n nodes indexed from 0 to n - 1. Each node has an associated price. And we need to find the minimum price for each of the trip. Also, we can choose some non-adjacent nodes in the shortest paths for each trip, and half its price.\\n\\nLets divide the problem into 3 parts:\\n1. For Each trip find the shortest path using BFS.\\n2. Create a contribution map, that stores the count of contribution of the nodes for the shortest path across all the trips.\\n3. Now use DFS to calculate the minimum price. At each step in the recursion we have the option to either half the current vertex or leave it as it is. If we are havling the current vextex then its neighbours can\\'t be halved, but if we are not halving the current vertex, for its neighbour we can either half it or not. We will try both combination and choose the minimum. To calculate the minimum price, we use two variable one for halved and other for non-halved. Since we can only choose non-adjacent nodes, we can\\'t half parent and child at the same time. We can only half parent or child. We will use dp to eliminate recalculation.\\n\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n        // Create Adjacency List\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        Map<Integer, Integer> contributionMap = new HashMap<>();\\n        for (int[] t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        int[][] dp = new int[n][2];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n\\n    }\\n\\n    private int dfs(Map<Integer, Integer> contributionMap, Map<Integer, List<Integer>> adjList, int[] price, int curr, int[][] dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap.getOrDefault(curr, 0) * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap.getOrDefault(curr, 0) * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = Math.min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    private void bfs(int n, Map<Integer, List<Integer>> adjList, Map<Integer, Integer> contibutionMap, int start, int end) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int temp = q.poll();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList.get(temp)) {\\n                if (!visited[neighbour]) {\\n                    q.offer(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap.put(start, contibutionMap.getOrDefault(start, 0) + 1);\\n            start = parent[start];\\n        }\\n    }\\n}\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Create Adjacency List\\n        unordered_map<int, vector<int>> adjList;\\n        for (const auto& edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        unordered_map<int, int> contributionMap;\\n        for (const auto& t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(unordered_map<int, int>& contributionMap, unordered_map<int, vector<int>>& adjList, vector<int>& price, int curr, vector<vector<int>>& dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap[curr] * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap[curr] * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    void bfs(int n, unordered_map<int, vector<int>>& adjList, unordered_map<int, int>& contibutionMap, int start, int end) {\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        vector<int> parent(n, -1);\\n        q.push(start);\\n        visited[start] = true;\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList[temp]) {\\n                if (!visited[neighbour]) {\\n                    q.push(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap[start]++;\\n            start = parent[start];\\n        }\\n    }\\n};\\n```\\n```python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        # Create Adjacency List\\n        adjList = defaultdict(list)\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        # For all the trips, find the shortest path and update the contribution map.\\n        contributionMap = {}\\n        for t in trips:\\n            self.bfs(n, adjList, contributionMap, t[0], t[1])\\n\\n        # Calculate the minimum price using dfs with DP.\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        ans = self.dfs(contributionMap, adjList, price, 0, dp, 0, -1)\\n        return ans\\n\\n    def dfs(self, contributionMap, adjList, price, curr, dp, isParentHalved, parent):\\n        if dp[curr][isParentHalved] != -1:\\n            return dp[curr][isParentHalved]\\n\\n        # For the current node, store the price with the price[current] halved.\\n        halved = contributionMap.get(curr, 0) * (price[curr] // 2)\\n\\n        # For the current node, store the price with the price[current] not halved.\\n        notHalved = contributionMap.get(curr, 0) * price[curr]\\n\\n        # if parent is halved, then current will be not halved\\n        # if parent is not halved, we can either half or not half it\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                notHalved += self.dfs(contributionMap, adjList, price, neighbour, dp, 0, curr)\\n        if isParentHalved == 1:\\n            dp[curr][isParentHalved] = notHalved  # return the notHalved value since parent is halved and current can\\'t be halved\\n            return dp[curr][isParentHalved]\\n\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                halved += self.dfs(contributionMap, adjList, price, neighbour, dp, 1, curr)\\n        dp[curr][isParentHalved] = min(halved, notHalved)  # return the min of halved and non-halved when parent is not halved.\\n        return dp[curr][isParentHalved]\\n\\n    def bfs(self, n, adjList, contributionMap, start, end):\\n        q = deque()\\n        visited = [False] * n\\n        parent = [-1] * n\\n        q.append(start)\\n        visited[start] = True\\n        while q:\\n            temp = q.popleft()\\n            if temp == end:\\n                break\\n\\n            for neighbour in adjList[temp]:\\n                if not visited[neighbour]:\\n                    q.append(neighbour)\\n                    visited[neighbour] = True\\n                    parent[neighbour] = temp\\n\\n        while start != -1:\\n            contributionMap[start] = contributionMap.get(start, 0) + 1\\n            start = parent[start]\\n```\\n```javascript []\\nfunction minimumTotalPrice(n, edges, price, trips) {\\n\\n    // Create Adjacency List\\n    let adjList = new Map();\\n    for (let i = 0; i < n; i++) adjList.set(i, []);\\n    for (let edge of edges) {\\n        adjList.get(edge[0]).push(edge[1]);\\n        adjList.get(edge[1]).push(edge[0]);\\n    }\\n\\n    // For all the trips, find the shortest path and update the contribution map.\\n    let contributionMap = new Map();\\n    for (let t of trips) {\\n        bfs(n, adjList, contributionMap, t[0], t[1]);\\n    }\\n\\n    // Calculate the minimum price using dfs with DP.\\n    let dp = new Array(n).fill(null).map(() => new Array(2).fill(-1));\\n    let ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n    return ans;\\n}\\n\\nfunction dfs(contributionMap, adjList, price, curr, dp, isParentHalved, parent) {\\n    if (dp[curr][isParentHalved] !== -1) return dp[curr][isParentHalved];\\n\\n    // For the current node, store the price with the price[current] halved.\\n    let halved = contributionMap.get(curr) ? contributionMap.get(curr) * Math.floor(price[curr] / 2) : 0;\\n\\n    // For the current node, store the price with the price[current] not halved.\\n    let notHalved = contributionMap.get(curr) ? contributionMap.get(curr) * price[curr] : 0;\\n\\n    // if parent is halved, then current will be not halved\\n    // if parent is not halved, we can either half or not half it\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n        }\\n    }\\n    if (isParentHalved === 1) {\\n        return dp[curr][isParentHalved] = notHalved; // return the notHalved value since parent is halved and current can\\'t be halved\\n    }\\n\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n        }\\n    }\\n    return dp[curr][isParentHalved] = Math.min(halved, notHalved); // return the min of halved and non-halved when parent is not halved.\\n}\\n\\nfunction bfs(n, adjList, contibutionMap, start, end) {\\n    let q = [];\\n    let visited = new Array(n).fill(false);\\n    let parent = new Array(n).fill(-1);\\n    q.push(start);\\n    visited[start] = true;\\n    while (q.length > 0) {\\n        let temp = q.shift();\\n        if (temp === end) break;\\n\\n        for (let neighbour of adjList.get(temp)) {\\n            if (!visited[neighbour]) {\\n                q.push(neighbour);\\n                visited[neighbour] = true;\\n                parent[neighbour] = temp;\\n            }\\n        }\\n    }\\n    start = end;\\n    while (start !== -1) {\\n        contibutionMap.set(start, (contibutionMap.get(start) || 0) + 1);\\n        start = parent[start];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n        // Create Adjacency List\\n        Map<Integer, List<Integer>> adjList = new HashMap<>();\\n        for (int i = 0; i < n; i++) adjList.put(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            adjList.get(edge[0]).add(edge[1]);\\n            adjList.get(edge[1]).add(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        Map<Integer, Integer> contributionMap = new HashMap<>();\\n        for (int[] t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        int[][] dp = new int[n][2];\\n        for (int[] row : dp) Arrays.fill(row, -1);\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n\\n    }\\n\\n    private int dfs(Map<Integer, Integer> contributionMap, Map<Integer, List<Integer>> adjList, int[] price, int curr, int[][] dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap.getOrDefault(curr, 0) * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap.getOrDefault(curr, 0) * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList.get(curr)) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = Math.min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    private void bfs(int n, Map<Integer, List<Integer>> adjList, Map<Integer, Integer> contibutionMap, int start, int end) {\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[n];\\n        int[] parent = new int[n];\\n        Arrays.fill(parent, -1);\\n        q.offer(start);\\n        visited[start] = true;\\n        while (!q.isEmpty()) {\\n            int temp = q.poll();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList.get(temp)) {\\n                if (!visited[neighbour]) {\\n                    q.offer(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap.put(start, contibutionMap.getOrDefault(start, 0) + 1);\\n            start = parent[start];\\n        }\\n    }\\n}\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Create Adjacency List\\n        unordered_map<int, vector<int>> adjList;\\n        for (const auto& edge : edges) {\\n            adjList[edge[0]].push_back(edge[1]);\\n            adjList[edge[1]].push_back(edge[0]);\\n        }\\n\\n        // For all the trips, find the shortest path and update the contribution map.\\n        unordered_map<int, int> contributionMap;\\n        for (const auto& t : trips) {\\n            bfs(n, adjList, contributionMap, t[0], t[1]);\\n        }\\n\\n        // Calculate the minimum price using dfs with DP.\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        int ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n        return ans;\\n    }\\n\\nprivate:\\n    int dfs(unordered_map<int, int>& contributionMap, unordered_map<int, vector<int>>& adjList, vector<int>& price, int curr, vector<vector<int>>& dp, int isParentHalved, int parent) {\\n        if (dp[curr][isParentHalved] != -1) return dp[curr][isParentHalved];\\n\\n        // For the current node, store the price with the price[current] halved.\\n        int halved = contributionMap[curr] * (price[curr] / 2);\\n\\n        // For the current node, store the price with the price[current] not halved.\\n        int notHalved = contributionMap[curr] * price[curr];\\n\\n        // if parent is halved, then current will be not halved\\n        // if parent is not halved, we can either half or not half it\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n            }\\n        }\\n        if (isParentHalved == 1) {\\n            return dp[curr][isParentHalved] = notHalved;  // return the notHalved value since parent is halved and current can\\'t be halved\\n        }\\n\\n        for (int neighbour : adjList[curr]) {\\n            if (neighbour != parent) {\\n                halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n            }\\n        }\\n        return dp[curr][isParentHalved] = min(halved, notHalved);  // return the min of halved and non-halved when parent is not halved.\\n    }\\n\\n    void bfs(int n, unordered_map<int, vector<int>>& adjList, unordered_map<int, int>& contibutionMap, int start, int end) {\\n        queue<int> q;\\n        vector<bool> visited(n, false);\\n        vector<int> parent(n, -1);\\n        q.push(start);\\n        visited[start] = true;\\n        while (!q.empty()) {\\n            int temp = q.front();\\n            q.pop();\\n            if (temp == end) break;\\n\\n            for (int neighbour : adjList[temp]) {\\n                if (!visited[neighbour]) {\\n                    q.push(neighbour);\\n                    visited[neighbour] = true;\\n                    parent[neighbour] = temp;\\n                }\\n            }\\n        }\\n        start = end;\\n        while (start != -1) {\\n            contibutionMap[start]++;\\n            start = parent[start];\\n        }\\n    }\\n};\\n```\n```python []\\nfrom collections import defaultdict, deque\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        # Create Adjacency List\\n        adjList = defaultdict(list)\\n        for edge in edges:\\n            adjList[edge[0]].append(edge[1])\\n            adjList[edge[1]].append(edge[0])\\n\\n        # For all the trips, find the shortest path and update the contribution map.\\n        contributionMap = {}\\n        for t in trips:\\n            self.bfs(n, adjList, contributionMap, t[0], t[1])\\n\\n        # Calculate the minimum price using dfs with DP.\\n        dp = [[-1 for _ in range(2)] for _ in range(n)]\\n        ans = self.dfs(contributionMap, adjList, price, 0, dp, 0, -1)\\n        return ans\\n\\n    def dfs(self, contributionMap, adjList, price, curr, dp, isParentHalved, parent):\\n        if dp[curr][isParentHalved] != -1:\\n            return dp[curr][isParentHalved]\\n\\n        # For the current node, store the price with the price[current] halved.\\n        halved = contributionMap.get(curr, 0) * (price[curr] // 2)\\n\\n        # For the current node, store the price with the price[current] not halved.\\n        notHalved = contributionMap.get(curr, 0) * price[curr]\\n\\n        # if parent is halved, then current will be not halved\\n        # if parent is not halved, we can either half or not half it\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                notHalved += self.dfs(contributionMap, adjList, price, neighbour, dp, 0, curr)\\n        if isParentHalved == 1:\\n            dp[curr][isParentHalved] = notHalved  # return the notHalved value since parent is halved and current can\\'t be halved\\n            return dp[curr][isParentHalved]\\n\\n        for neighbour in adjList[curr]:\\n            if neighbour != parent:\\n                halved += self.dfs(contributionMap, adjList, price, neighbour, dp, 1, curr)\\n        dp[curr][isParentHalved] = min(halved, notHalved)  # return the min of halved and non-halved when parent is not halved.\\n        return dp[curr][isParentHalved]\\n\\n    def bfs(self, n, adjList, contributionMap, start, end):\\n        q = deque()\\n        visited = [False] * n\\n        parent = [-1] * n\\n        q.append(start)\\n        visited[start] = True\\n        while q:\\n            temp = q.popleft()\\n            if temp == end:\\n                break\\n\\n            for neighbour in adjList[temp]:\\n                if not visited[neighbour]:\\n                    q.append(neighbour)\\n                    visited[neighbour] = True\\n                    parent[neighbour] = temp\\n\\n        while start != -1:\\n            contributionMap[start] = contributionMap.get(start, 0) + 1\\n            start = parent[start]\\n```\n```javascript []\\nfunction minimumTotalPrice(n, edges, price, trips) {\\n\\n    // Create Adjacency List\\n    let adjList = new Map();\\n    for (let i = 0; i < n; i++) adjList.set(i, []);\\n    for (let edge of edges) {\\n        adjList.get(edge[0]).push(edge[1]);\\n        adjList.get(edge[1]).push(edge[0]);\\n    }\\n\\n    // For all the trips, find the shortest path and update the contribution map.\\n    let contributionMap = new Map();\\n    for (let t of trips) {\\n        bfs(n, adjList, contributionMap, t[0], t[1]);\\n    }\\n\\n    // Calculate the minimum price using dfs with DP.\\n    let dp = new Array(n).fill(null).map(() => new Array(2).fill(-1));\\n    let ans = dfs(contributionMap, adjList, price, 0, dp, 0, -1);\\n    return ans;\\n}\\n\\nfunction dfs(contributionMap, adjList, price, curr, dp, isParentHalved, parent) {\\n    if (dp[curr][isParentHalved] !== -1) return dp[curr][isParentHalved];\\n\\n    // For the current node, store the price with the price[current] halved.\\n    let halved = contributionMap.get(curr) ? contributionMap.get(curr) * Math.floor(price[curr] / 2) : 0;\\n\\n    // For the current node, store the price with the price[current] not halved.\\n    let notHalved = contributionMap.get(curr) ? contributionMap.get(curr) * price[curr] : 0;\\n\\n    // if parent is halved, then current will be not halved\\n    // if parent is not halved, we can either half or not half it\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            notHalved += dfs(contributionMap, adjList, price, neighbour, dp, 0, curr);\\n        }\\n    }\\n    if (isParentHalved === 1) {\\n        return dp[curr][isParentHalved] = notHalved; // return the notHalved value since parent is halved and current can\\'t be halved\\n    }\\n\\n    for (let neighbour of adjList.get(curr)) {\\n        if (neighbour !== parent) {\\n            halved += dfs(contributionMap, adjList, price, neighbour, dp, 1, curr);\\n        }\\n    }\\n    return dp[curr][isParentHalved] = Math.min(halved, notHalved); // return the min of halved and non-halved when parent is not halved.\\n}\\n\\nfunction bfs(n, adjList, contibutionMap, start, end) {\\n    let q = [];\\n    let visited = new Array(n).fill(false);\\n    let parent = new Array(n).fill(-1);\\n    q.push(start);\\n    visited[start] = true;\\n    while (q.length > 0) {\\n        let temp = q.shift();\\n        if (temp === end) break;\\n\\n        for (let neighbour of adjList.get(temp)) {\\n            if (!visited[neighbour]) {\\n                q.push(neighbour);\\n                visited[neighbour] = true;\\n                parent[neighbour] = temp;\\n            }\\n        }\\n    }\\n    start = end;\\n    while (start !== -1) {\\n        contibutionMap.set(start, (contibutionMap.get(start) || 0) + 1);\\n        start = parent[start];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422858,
                "title": "python-dijkstra-s-algorithm-dynamic-programming",
                "content": "# Intuition\\nHow to know what nodes are better to halve? Maybe we need to find all required paths first. And then we can optimize our existing paths. \\n\\n# Approach\\nUse Dijkstra\\'s algorithm to find shortest paths. \\nThen Use Dynamic programming with memoization to optimize paths.\\n\\nTo optimize paths we can recursively try to select each node to halve or leave it as is. And find the best option. \\n\\n# Complexity\\n- Time complexity: $$O((V+E)logV + V*logV)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(E*V)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adjancency_list = [[] for _ in range(n)]\\n        for edge1, edge2 in edges:\\n            adjancency_list[edge1].append(edge2)\\n            adjancency_list[edge2].append(edge1)\\n\\n        s = 0\\n        used_nodes_count = {}\\n        for from_trip, to_trip in trips:\\n            path, _price = self.findShortestPath(adjancency_list, price, from_trip, to_trip)\\n            s += _price\\n            for node in path:\\n                used_nodes_count[node] = used_nodes_count.get(node, 0) + 1\\n\\n        cache = {}\\n        mx1 = self.findMinPrice(None, 0, True, adjancency_list, used_nodes_count, price, cache)\\n        mx2 = self.findMinPrice(None, 0, False, adjancency_list, used_nodes_count, price, cache)\\n        return min(mx1, mx2)\\n\\n    def findMinPrice(self, parent, node, selected, adjancency_list, used_nodes_count, price, cache):\\n        if (node, selected) in cache:\\n            return cache[(node, selected)]\\n\\n        if selected:\\n            cost = (price[node] // 2) * used_nodes_count.get(node, 0)\\n        else:\\n            cost = price[node] * used_nodes_count.get(node, 0)\\n\\n        mins = []\\n        for child in adjancency_list[node]:\\n            if child == parent:\\n                continue\\n\\n            options = []\\n            if not selected:\\n                mx = self.findMinPrice(node, child, True, adjancency_list, used_nodes_count, price, cache)\\n                options.append(mx)\\n            mx = self.findMinPrice(node, child, False, adjancency_list, used_nodes_count, price, cache)\\n            options.append(mx)\\n            mins.append(min(options))\\n\\n        cache[(node, selected)] = cost + sum(mins)\\n        return cost + sum(mins)\\n\\n    def findShortestPath(self, adjancency_list, price, from_trip, to_trip):\\n        dist = [-1] * len(adjancency_list)\\n        parents = {}\\n\\n        dist[from_trip] = price[from_trip]\\n        visited = set()\\n        queued = {from_trip}\\n\\n        while queued:\\n            node = queued.pop()\\n            if node in visited:\\n                continue\\n\\n            visited.add(node)\\n\\n            for to_node in adjancency_list[node]:\\n                current_dist = dist[node] + price[to_node]\\n                if dist[to_node] != -1 and dist[to_node] < current_dist:\\n                    continue\\n                dist[to_node] = current_dist\\n                parents[to_node] = node\\n                queued.add(to_node)\\n                if to_node in visited:\\n                    visited.remove(to_node)\\n\\n        path = [to_trip]\\n        cur_node = to_trip\\n        while cur_node != from_trip:\\n            cur_node = parents[cur_node]\\n            path.append(cur_node)\\n\\n        return path, dist[to_trip]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adjancency_list = [[] for _ in range(n)]\\n        for edge1, edge2 in edges:\\n            adjancency_list[edge1].append(edge2)\\n            adjancency_list[edge2].append(edge1)\\n\\n        s = 0\\n        used_nodes_count = {}\\n        for from_trip, to_trip in trips:\\n            path, _price = self.findShortestPath(adjancency_list, price, from_trip, to_trip)\\n            s += _price\\n            for node in path:\\n                used_nodes_count[node] = used_nodes_count.get(node, 0) + 1\\n\\n        cache = {}\\n        mx1 = self.findMinPrice(None, 0, True, adjancency_list, used_nodes_count, price, cache)\\n        mx2 = self.findMinPrice(None, 0, False, adjancency_list, used_nodes_count, price, cache)\\n        return min(mx1, mx2)\\n\\n    def findMinPrice(self, parent, node, selected, adjancency_list, used_nodes_count, price, cache):\\n        if (node, selected) in cache:\\n            return cache[(node, selected)]\\n\\n        if selected:\\n            cost = (price[node] // 2) * used_nodes_count.get(node, 0)\\n        else:\\n            cost = price[node] * used_nodes_count.get(node, 0)\\n\\n        mins = []\\n        for child in adjancency_list[node]:\\n            if child == parent:\\n                continue\\n\\n            options = []\\n            if not selected:\\n                mx = self.findMinPrice(node, child, True, adjancency_list, used_nodes_count, price, cache)\\n                options.append(mx)\\n            mx = self.findMinPrice(node, child, False, adjancency_list, used_nodes_count, price, cache)\\n            options.append(mx)\\n            mins.append(min(options))\\n\\n        cache[(node, selected)] = cost + sum(mins)\\n        return cost + sum(mins)\\n\\n    def findShortestPath(self, adjancency_list, price, from_trip, to_trip):\\n        dist = [-1] * len(adjancency_list)\\n        parents = {}\\n\\n        dist[from_trip] = price[from_trip]\\n        visited = set()\\n        queued = {from_trip}\\n\\n        while queued:\\n            node = queued.pop()\\n            if node in visited:\\n                continue\\n\\n            visited.add(node)\\n\\n            for to_node in adjancency_list[node]:\\n                current_dist = dist[node] + price[to_node]\\n                if dist[to_node] != -1 and dist[to_node] < current_dist:\\n                    continue\\n                dist[to_node] = current_dist\\n                parents[to_node] = node\\n                queued.add(to_node)\\n                if to_node in visited:\\n                    visited.remove(to_node)\\n\\n        path = [to_trip]\\n        cur_node = to_trip\\n        while cur_node != from_trip:\\n            cur_node = parents[cur_node]\\n            path.append(cur_node)\\n\\n        return path, dist[to_trip]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422716,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n       \\n        count = Counter()\\n    \\n        totalCost = 0\\n\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n       \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n      \\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n               \\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n    \\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n    \\n        return totalCost - reduce\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for a,b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n       \\n        count = Counter()\\n    \\n        totalCost = 0\\n\\n        def dfs(node,par,end):\\n            nonlocal count\\n            nonlocal totalCost\\n            if node == end:\\n                return True\\n            \\n            for nei in graph[node]:\\n                if nei != par:\\n                    if dfs(nei, node, end):\\n                        count[nei] += 1\\n                        totalCost += price[nei]\\n                        return True\\n            return False\\n\\n       \\n        for start,end in trips:\\n            count[start] += 1\\n            totalCost += price[start]\\n            dfs(start,None,end)\\n        \\n      \\n        @cache\\n        def dp(node, par, canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*count[node]\\n            else:\\n                res = 0\\n            red = 0\\n            for nei in graph[node]:\\n                if nei != par:\\n               \\n                    if canReduce:\\n                        cur = dp(nei, node, False)\\n\\n                    else:\\n                        cur = max(dp(nei, node, False), dp(nei, node, True))\\n                    red += cur\\n            return res + red\\n        \\n    \\n        reduce = 0\\n        for i in range(n):\\n            reduce = max( reduce, dp(i, None, True), dp(i, None, False) )\\n        \\n    \\n        return totalCost - reduce\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421862,
                "title": "bfs-dfs-dp",
                "content": "# Intuition\\nBFS + DFS + DP\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<list<int>> g(n);\\n        for (auto& edge: edges) {\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> cnts(n, 0);\\n        for (auto& trip: trips) {\\n            BFS(g, cnts, trip[0], trip[1]);\\n        }\\n        vector<int> weights(n);\\n        for (int i=0; i<n; i++) {\\n            weights[i] = cnts[i]*price[i];\\n        }\\n        auto [half, noHalf] = DFS(g, weights, 0, -1);\\n        return min(half, noHalf);\\n    }\\n    pair<int, int> DFS(vector<list<int>>& g, vector<int>& weights, int root, int prev) {\\n        int rootHalf = weights[root]/2;\\n        int rootNoHalf = weights[root];\\n        for (int adj: g[root]) {\\n            if (adj == prev) continue;\\n            auto [half, noHalf] = DFS(g, weights, adj, root);\\n            rootHalf += noHalf;\\n            rootNoHalf += min(half, noHalf);\\n        }\\n        return {rootHalf, rootNoHalf};\\n    }\\n    void BFS(vector<list<int>>& g, vector<int>& cnts, int start, int end) {\\n        int n = g.size();\\n        vector<bool> visited(n, false);\\n        vector<int> prev(n, -1);\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            if (node == end) break;\\n            if (visited[node]) continue;\\n            visited[node] = true;\\n            for (int adj: g[node]) {\\n                if (visited[adj]) continue;\\n                prev[adj] = node;\\n                q.push(adj);\\n            }\\n        }\\n        int x = end;\\n        while (x != -1) {\\n            cnts[x]++;\\n            x = prev[x];\\n        }\\n    }\\n};\\n```\\n# Similar Question\\n[337. House Robber III](https://leetcode.com/problems/house-robber-iii/)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<list<int>> g(n);\\n        for (auto& edge: edges) {\\n            g[edge[0]].push_back(edge[1]);\\n            g[edge[1]].push_back(edge[0]);\\n        }\\n        vector<int> cnts(n, 0);\\n        for (auto& trip: trips) {\\n            BFS(g, cnts, trip[0], trip[1]);\\n        }\\n        vector<int> weights(n);\\n        for (int i=0; i<n; i++) {\\n            weights[i] = cnts[i]*price[i];\\n        }\\n        auto [half, noHalf] = DFS(g, weights, 0, -1);\\n        return min(half, noHalf);\\n    }\\n    pair<int, int> DFS(vector<list<int>>& g, vector<int>& weights, int root, int prev) {\\n        int rootHalf = weights[root]/2;\\n        int rootNoHalf = weights[root];\\n        for (int adj: g[root]) {\\n            if (adj == prev) continue;\\n            auto [half, noHalf] = DFS(g, weights, adj, root);\\n            rootHalf += noHalf;\\n            rootNoHalf += min(half, noHalf);\\n        }\\n        return {rootHalf, rootNoHalf};\\n    }\\n    void BFS(vector<list<int>>& g, vector<int>& cnts, int start, int end) {\\n        int n = g.size();\\n        vector<bool> visited(n, false);\\n        vector<int> prev(n, -1);\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            if (node == end) break;\\n            if (visited[node]) continue;\\n            visited[node] = true;\\n            for (int adj: g[node]) {\\n                if (visited[adj]) continue;\\n                prev[adj] = node;\\n                q.push(adj);\\n            }\\n        }\\n        int x = end;\\n        while (x != -1) {\\n            cnts[x]++;\\n            x = prev[x];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421678,
                "title": "python-lowest-common-ancestor",
                "content": "We use lowest common ancestor to find path for each trip. Let `freq` be the frequencies for each node. `dp(i, p)` returns the maximum price we can save without or with choosing node `i`.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g = [[] for _ in range(n)]\\n        for i, j in edges:\\n            g[i].append(j)\\n            g[j].append(i)\\n            \\n        freq = [0] * n\\n        level = [0] * n\\n        parent = [0] * n\\n        \\n        def dfs(i, l, p):\\n            level[i] = l\\n            parent[i] = p\\n            for j in g[i]:\\n                if j != p:\\n                    dfs(j, l + 1, i)\\n        \\n        def LCA(a, b):\\n            if level[a] > level[b]:\\n                a, b = b, a\\n            d = level[b] - level[a]\\n            while d:\\n                b = parent[b]\\n                d -= 1\\n            if a == b:\\n                return a\\n            while a != b:\\n                a = parent[a]\\n                b = parent[b]\\n            return a\\n        \\n        dfs(0, 0, -1)\\n        for i, j in trips:\\n            lca = LCA(i, j)\\n            path = []\\n            while i != lca:\\n                freq[i] += 1\\n                i = parent[i]\\n            freq[i] += 1\\n            while j != lca:\\n                freq[j] += 1\\n                j = parent[j]\\n        \\n        def dp(i, p):\\n            res0 = 0\\n            res1 = price[i] // 2 * freq[i]\\n            for j in g[i]:\\n                if j != p:\\n                    curr = dp(j, i)\\n                    res0 += max(curr)\\n                    res1 += curr[0]\\n            return [res0, res1]\\n        ans = 0\\n        for i in range(n):\\n            ans += freq[i] * price[i]\\n        return ans - max(dp(0, -1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093839,
                "title": "java-94-w-explanation",
                "content": "# Intuition\\nThe fundamental idea arises from the understanding that if certain nodes are traveled more frequently during the trips, then reducing the price of these nodes will have a more significant impact on decreasing the overall cost. To solve this problem, we need to first identify how many trips pass through each node, and then dynamically decide whether to halve the price of that node based on its impact on the total price.\\n\\n# Approach\\n1. Construct an adjacency list representation of the tree using the provided edges to facilitate easy traversal.\\n2. For each trip, use Depth-First Search (DFS) to traverse from the start to the end node, incrementing a counter for every node visited. This helps in determining how frequently each node is visited during all trips.\\n3. With the frequency of visits to each node determined, employ a dynamic programming approach to calculate the minimum cost for each node. Two scenarios are explored recursively:\\n   - The cost of the node when its price is halved.\\n   - The cost when the node\\'s price is not halved.\\n   \\n   By storing already computed results in a memoization table, redundant calculations are avoided, and the solution is reached more efficiently.\\n4. The minimum cost for all trips is determined by the cumulative decision of whether to halve the node prices or not, based on the results of the recursive calculations.\\n\\n# Complexity\\n- Time complexity:\\nThe main contributors to time complexity are the DFS for each trip and the dynamic programming approach. For each trip, in the worst case, the DFS may traverse all nodes, making it \\\\(O(n)\\\\) per trip. If there are \\\\(m\\\\) trips, this becomes \\\\(O(m \\\\times n)\\\\). The dynamic programming approach can potentially explore each node twice (one for halved, one for not halved), making it \\\\(O(2n)\\\\). Combining the two, the time complexity is \\\\(O(m \\\\times n + 2n)\\\\), which can be simplified to \\\\(O(m \\\\times n)\\\\).\\n\\n- Space complexity:\\nThe main space overheads are the adjacency list representation of the tree, which takes \\\\(O(n)\\\\) space, and the memoization table which also takes \\\\(O(2n)\\\\) space, resulting in \\\\(O(3n)\\\\). Simplifying, we get a space complexity of \\\\(O(n)\\\\).\\n\\n# Code\\n```\\nclass Solution {\\n    int nodeVisitCount[]; // To store the number of times each node is visited\\n    int memo[][];  // Memoization table to store computed results\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> adjacencyList[] = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            adjacencyList[i] = new ArrayList<>();\\n        }\\n        \\n        // Create adjacency list from edges\\n        for(int i = 0; i < edges.length; i++) {\\n            adjacencyList[edges[i][0]].add(edges[i][1]);\\n            adjacencyList[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        nodeVisitCount = new int[n];\\n        \\n        // For each trip, traverse the path and update node visit count\\n        for(int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int destination = trips[i][1];\\n            nodeVisitCount[start]++;\\n            traversePath(start, destination, adjacencyList, -1);\\n        }\\n    \\n        memo = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n      \\n        return findMinPrice(0, -1, 0, adjacencyList, price);  \\n    }\\n    \\n    public int findMinPrice(int node, int parent, int halved, ArrayList<Integer> adjacencyList[], int price[]) {\\n        \\n        int priceIfHalved = nodeVisitCount[node] * price[node] / 2;\\n        int priceIfNotHalved = nodeVisitCount[node] * price[node];\\n        \\n        // If the result is already computed, return from memoization\\n        if(memo[node][halved] != -1) {\\n            return memo[node][halved];\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfNotHalved += findMinPrice(adjacentNode, node, 0, adjacencyList, price);\\n            }\\n        }\\n        \\n        if(halved == 1) {\\n            return memo[node][halved] = priceIfNotHalved;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfHalved += findMinPrice(adjacentNode, node, 1, adjacencyList, price);\\n            }\\n        }\\n        \\n        // Return the minimum of the two prices\\n        return memo[node][halved] = Math.min(priceIfHalved, priceIfNotHalved);\\n    }\\n    \\n    // Method to traverse path for a trip and update node visit count\\n    public boolean traversePath(int source, int destination, ArrayList<Integer> adjacencyList[], int parent) {\\n        \\n        if(source == destination) {\\n            return true;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[source]) {\\n            if(adjacentNode != parent) {\\n                if(traversePath(adjacentNode, destination, adjacencyList, source)) {\\n                    nodeVisitCount[adjacentNode]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int nodeVisitCount[]; // To store the number of times each node is visited\\n    int memo[][];  // Memoization table to store computed results\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n       \\n        ArrayList<Integer> adjacencyList[] = new ArrayList[n];\\n        for(int i = 0; i < n; i++) {\\n            adjacencyList[i] = new ArrayList<>();\\n        }\\n        \\n        // Create adjacency list from edges\\n        for(int i = 0; i < edges.length; i++) {\\n            adjacencyList[edges[i][0]].add(edges[i][1]);\\n            adjacencyList[edges[i][1]].add(edges[i][0]);\\n        }\\n        \\n        nodeVisitCount = new int[n];\\n        \\n        // For each trip, traverse the path and update node visit count\\n        for(int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int destination = trips[i][1];\\n            nodeVisitCount[start]++;\\n            traversePath(start, destination, adjacencyList, -1);\\n        }\\n    \\n        memo = new int[n][2];\\n        for(int i = 0; i < n; i++) {\\n            Arrays.fill(memo[i], -1);\\n        }\\n      \\n        return findMinPrice(0, -1, 0, adjacencyList, price);  \\n    }\\n    \\n    public int findMinPrice(int node, int parent, int halved, ArrayList<Integer> adjacencyList[], int price[]) {\\n        \\n        int priceIfHalved = nodeVisitCount[node] * price[node] / 2;\\n        int priceIfNotHalved = nodeVisitCount[node] * price[node];\\n        \\n        // If the result is already computed, return from memoization\\n        if(memo[node][halved] != -1) {\\n            return memo[node][halved];\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfNotHalved += findMinPrice(adjacentNode, node, 0, adjacencyList, price);\\n            }\\n        }\\n        \\n        if(halved == 1) {\\n            return memo[node][halved] = priceIfNotHalved;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[node]) {\\n            if(adjacentNode != parent) {\\n                priceIfHalved += findMinPrice(adjacentNode, node, 1, adjacencyList, price);\\n            }\\n        }\\n        \\n        // Return the minimum of the two prices\\n        return memo[node][halved] = Math.min(priceIfHalved, priceIfNotHalved);\\n    }\\n    \\n    // Method to traverse path for a trip and update node visit count\\n    public boolean traversePath(int source, int destination, ArrayList<Integer> adjacencyList[], int parent) {\\n        \\n        if(source == destination) {\\n            return true;\\n        }\\n        \\n        for(int adjacentNode : adjacencyList[source]) {\\n            if(adjacentNode != parent) {\\n                if(traversePath(adjacentNode, destination, adjacencyList, source)) {\\n                    nodeVisitCount[adjacentNode]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051401,
                "title": "c-dfs-dp-beats-100-114ms",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        List<int>[] tree = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            tree[i] = new();\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n        }\\n\\n        int[] nodesVisitedCount = new int[n];\\n        HashSet<int> tempPath = new();\\n\\n        void ComputeNodesVisitedCount(int start, int end)\\n        {\\n            tempPath.Add(start);\\n            if (start == end)\\n                foreach (var node in tempPath)\\n                    nodesVisitedCount[node]++;\\n            else\\n                foreach (var node in tree[start])\\n                {\\n                    if (tempPath.Contains(node))\\n                        continue;\\n\\n                    ComputeNodesVisitedCount(node, end);\\n                }\\n            tempPath.Remove(start);\\n        }\\n\\n        foreach (var trip in trips)\\n            ComputeNodesVisitedCount(trip[0], trip[1]);\\n\\n        int[] ComputeMinPrices(int parentNode, int node)\\n        {\\n            int whole = 0, halved = 0;\\n            foreach (var nodeToVisit in tree[node])\\n            {\\n                if (nodeToVisit == parentNode) continue;\\n                var childPrices = ComputeMinPrices(node, nodeToVisit);\\n                halved += childPrices[1];\\n                whole += Math.Min(childPrices[0], childPrices[1]);\\n            }\\n            return new[] {\\n                price[node] * nodesVisitedCount[node] /2 + halved,\\n                price[node] * nodesVisitedCount[node] + whole\\n                };\\n        }\\n\\n        var minPrices = ComputeMinPrices(-1, 0);\\n        return Math.Min(minPrices[0], minPrices[1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        List<int>[] tree = new List<int>[n];\\n        for (int i = 0; i < n; i++)\\n            tree[i] = new();\\n        foreach (var edge in edges)\\n        {\\n            tree[edge[0]].Add(edge[1]);\\n            tree[edge[1]].Add(edge[0]);\\n        }\\n\\n        int[] nodesVisitedCount = new int[n];\\n        HashSet<int> tempPath = new();\\n\\n        void ComputeNodesVisitedCount(int start, int end)\\n        {\\n            tempPath.Add(start);\\n            if (start == end)\\n                foreach (var node in tempPath)\\n                    nodesVisitedCount[node]++;\\n            else\\n                foreach (var node in tree[start])\\n                {\\n                    if (tempPath.Contains(node))\\n                        continue;\\n\\n                    ComputeNodesVisitedCount(node, end);\\n                }\\n            tempPath.Remove(start);\\n        }\\n\\n        foreach (var trip in trips)\\n            ComputeNodesVisitedCount(trip[0], trip[1]);\\n\\n        int[] ComputeMinPrices(int parentNode, int node)\\n        {\\n            int whole = 0, halved = 0;\\n            foreach (var nodeToVisit in tree[node])\\n            {\\n                if (nodeToVisit == parentNode) continue;\\n                var childPrices = ComputeMinPrices(node, nodeToVisit);\\n                halved += childPrices[1];\\n                whole += Math.Min(childPrices[0], childPrices[1]);\\n            }\\n            return new[] {\\n                price[node] * nodesVisitedCount[node] /2 + halved,\\n                price[node] * nodesVisitedCount[node] + whole\\n                };\\n        }\\n\\n        var minPrices = ComputeMinPrices(-1, 0);\\n        return Math.Min(minPrices[0], minPrices[1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037135,
                "title": "c-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cntmap;\\n    unordered_map<string, int> memo;\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        unordered_map<int, vector<int>> g;\\n        int res  = 0;\\n        for(auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        unordered_set<int> visited;\\n        for(auto t:  trips) { \\n            dfs(t[0], t[1], g, visited);\\n            visited.clear();\\n        }\\n        visited.clear();\\n\\n        int reduceroot   = reduce(0, g, visited, price, 1);\\n        visited.clear();\\n        int noreduceroot = reduce(0, g, visited, price, 0);\\n        return min(reduceroot,  noreduceroot);\\n    }\\n\\n    int reduce(int s, unordered_map<int, vector<int>> &g, unordered_set<int> &visited, vector<int>& price, bool canreduce) {\\n        int res = 0;\\n        string key = to_string(s) + \"_\" + to_string(canreduce);\\n        if(memo.count(key)) return memo[key];\\n        if(canreduce) {\\n            res += (price[s] / 2) * cntmap[s];\\n        }\\n        else res += price[s] * cntmap[s];\\n        visited.insert(s);\\n        for(auto next: g[s]) {\\n            if(visited.count(next)) continue;\\n            if(canreduce) {\\n                res += reduce(next, g, visited, price, 0);\\n            }\\n            else res += min(reduce(next, g, visited, price, 0), reduce(next, g, visited, price, 1));\\n        }\\n        visited.erase(s);\\n        memo[key] = res;\\n        return res;\\n\\n    }\\n\\n    bool dfs(int s, int t, unordered_map<int, vector<int>> &g, unordered_set<int> &visited) {\\n        if(s == t)   {\\n            cntmap[t]++;\\n            return 1;\\n        }\\n        visited.insert(s);\\n        for(auto next: g[s])  {\\n            if(!visited.count(next) and dfs(next,t,g, visited)) {\\n                cntmap[s]++;\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> cntmap;\\n    unordered_map<string, int> memo;\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        unordered_map<int, vector<int>> g;\\n        int res  = 0;\\n        for(auto e: edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        unordered_set<int> visited;\\n        for(auto t:  trips) { \\n            dfs(t[0], t[1], g, visited);\\n            visited.clear();\\n        }\\n        visited.clear();\\n\\n        int reduceroot   = reduce(0, g, visited, price, 1);\\n        visited.clear();\\n        int noreduceroot = reduce(0, g, visited, price, 0);\\n        return min(reduceroot,  noreduceroot);\\n    }\\n\\n    int reduce(int s, unordered_map<int, vector<int>> &g, unordered_set<int> &visited, vector<int>& price, bool canreduce) {\\n        int res = 0;\\n        string key = to_string(s) + \"_\" + to_string(canreduce);\\n        if(memo.count(key)) return memo[key];\\n        if(canreduce) {\\n            res += (price[s] / 2) * cntmap[s];\\n        }\\n        else res += price[s] * cntmap[s];\\n        visited.insert(s);\\n        for(auto next: g[s]) {\\n            if(visited.count(next)) continue;\\n            if(canreduce) {\\n                res += reduce(next, g, visited, price, 0);\\n            }\\n            else res += min(reduce(next, g, visited, price, 0), reduce(next, g, visited, price, 1));\\n        }\\n        visited.erase(s);\\n        memo[key] = res;\\n        return res;\\n\\n    }\\n\\n    bool dfs(int s, int t, unordered_map<int, vector<int>> &g, unordered_set<int> &visited) {\\n        if(s == t)   {\\n            cntmap[t]++;\\n            return 1;\\n        }\\n        visited.insert(s);\\n        for(auto next: g[s])  {\\n            if(!visited.count(next) and dfs(next,t,g, visited)) {\\n                cntmap[s]++;\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032691,
                "title": "c-dfs-dp-with-intuition-and-approach",
                "content": "\\n# Author: Jayesh Badgujar\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int src,int end,vector<int>& fre,map<int,vector<int>>& mp,int par){\\n        if(src==end){\\n            return true;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                fre[it]++;\\n                if(dfs(it,end,fre,mp,src)){\\n                    return true;\\n                }\\n                fre[it]--;\\n            }\\n        }\\n        return false;\\n    }\\n    int find(int src,map<int,vector<int>>& mp,vector<vector<int>>& dp,int last,int par,vector<int>& fre, vector<int>& price){\\n        if(dp[src][last]!=-1){\\n            return dp[src][last];\\n        }\\n        bool flag=false;\\n        int take_mini=(((fre[src])*(price[src]/2))),not_take_mini=(((fre[src])*(price[src])));\\n        for(auto it:mp[src]){\\n            if(it!=par){                \\n                if(last){                    \\n                    int take=find(it,mp,dp,0,src,fre,price);\\n                    if(take!=INT_MAX){\\n                        take_mini+=take;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                int not_take=find(it,mp,dp,1,src,fre,price);\\n                if(not_take!=INT_MAX){\\n                    not_take_mini+=not_take;\\n                }\\n            }\\n        }\\n       \\n        if(last==0){\\n            return not_take_mini;\\n        }\\n        return dp[src][last]=min(take_mini,not_take_mini);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        map<int,vector<int>> mp;\\n        vector<int> fre(n,0);\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            fre[trips[i][0]]++;\\n            dfs(trips[i][0],trips[i][1],fre,mp,-1);\\n        }\\n        return find(0,mp,dp,1,-1,fre,price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int src,int end,vector<int>& fre,map<int,vector<int>>& mp,int par){\\n        if(src==end){\\n            return true;\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                fre[it]++;\\n                if(dfs(it,end,fre,mp,src)){\\n                    return true;\\n                }\\n                fre[it]--;\\n            }\\n        }\\n        return false;\\n    }\\n    int find(int src,map<int,vector<int>>& mp,vector<vector<int>>& dp,int last,int par,vector<int>& fre, vector<int>& price){\\n        if(dp[src][last]!=-1){\\n            return dp[src][last];\\n        }\\n        bool flag=false;\\n        int take_mini=(((fre[src])*(price[src]/2))),not_take_mini=(((fre[src])*(price[src])));\\n        for(auto it:mp[src]){\\n            if(it!=par){                \\n                if(last){                    \\n                    int take=find(it,mp,dp,0,src,fre,price);\\n                    if(take!=INT_MAX){\\n                        take_mini+=take;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        for(auto it:mp[src]){\\n            if(it!=par){\\n                int not_take=find(it,mp,dp,1,src,fre,price);\\n                if(not_take!=INT_MAX){\\n                    not_take_mini+=not_take;\\n                }\\n            }\\n        }\\n       \\n        if(last==0){\\n            return not_take_mini;\\n        }\\n        return dp[src][last]=min(take_mini,not_take_mini);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        map<int,vector<int>> mp;\\n        vector<int> fre(n,0);\\n        vector<vector<int>> dp(n,vector<int>(2,-1));\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            fre[trips[i][0]]++;\\n            dfs(trips[i][0],trips[i][1],fre,mp,-1);\\n        }\\n        return find(0,mp,dp,1,-1,fre,price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020182,
                "title": "ruby-solution-with-detailed-explanation-100-100",
                "content": "# Intuition\\nMap the trips, find how often each node gets hit in total, and use dynamic programming to find the minimum total price from halving nodes.\\n\\n# Approach\\n1. Convert edges to connections hash\\n    - Create a hash to hold connections.\\n    - Iterate through the edge.  For each edge, add the two endpoints to each other\\'s connections hash.\\n2. Convert each trip into a list of nodes I will hit (using DFS)\\n    - Map the trips to a sequence of nodes they hit using a DFS helper function.  (Since this is a tree and has no cycles, there\\'s only one possible path between any two nodes.)\\n3. Combine all paths into array and count frequency of each node\\n    - Create a hash to keep track of the frequency of each node.\\n    - Iterate through all the trips and increment the node count for each node.\\n4. Change each node\\'s price to its price times its frequency\\n    - The effective price of a node is the starting price times the number of trips it\\'s a part of.  It\\'s easier to work with if we change the prices array.\\n5. Delete backwards adjacencies so path only goes forward from 0\\n    - Iterate through nodes using BFS, starting at 0.  For each node, remove the path from next_node to current node.  (This is basically making 0 the root of the tree.  Any node could be the root -- 0 is arbitrary -- but it\\'s helpful to have a root.)\\n6. Starting from zero, find minimum sum with memoization\\n    - Create a memo and turn prices and connections into class variables so they can be accessed in a helper function.\\n    - Call a helper function starting at index 0 and 2 choices.\\n\\n**Helper function (min_price)**:\\nThis function finds the minimum price of a branch, taking in the node and the number of options.  (One option means that node\\'s price can\\'t be cut in half because an adjacent node\\'s was; two options means it could be.)\\n1. Return a stored value in memo if it exists\\n2. Create an options array.\\n3. Create option 1 (do not half this node)\\n    - Start option 1 as the price at node.\\n    - Iterate through each branch from node and add the min prices of each branch to option 1 (with two options, because we could half that node).\\n    - Push into options array.\\n4. Create option 2 if num_options = 2\\n    - Initialize option 2 as *half* the price of node (DO half this node).\\n    - Iterate through each branch from node and add the min prices of each branch to option 2 (with one option, because we *can\\'t* half these nodes).\\n    - Push into options array.\\n5. Choose the minimum option, memoize, and return\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * t)$$, where *t* is the number of trips.\\n\\n- Space complexity:\\n$$O(n * t)$$\\n\\n# Code\\n```\\ndef minimum_total_price(n, edges, prices, trips)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    trips.map! { |trip| path(trip[0], trip[1], connections, Set[]) }\\n\\n    node_count = Hash.new(0)\\n    trips.flatten.each { |node| node_count[node] += 1 }\\n\\n    prices.each_with_index do |price,i|\\n        prices[i] = price * node_count[i]\\n    end\\n\\n    queue = [0]\\n    until queue.empty?\\n        node = queue.shift\\n        adjacent_nodes = connections[node]\\n        adjacent_nodes.each do |next_node|\\n            connections[next_node].delete(node)\\n            queue << next_node\\n        end\\n    end\\n\\n    @memo = Array.new(n) { [nil,nil] }\\n    @prices = prices\\n    @connections = connections\\n    min_price(0,2)\\nend\\n\\n\\ndef min_price(node,num_choices)\\n    return @memo[node][num_choices] if @memo[node][num_choices]\\n\\n    options = []\\n\\n    option1 = @prices[node]\\n    next_nodes = @connections[node]\\n    next_nodes.each do |branch|\\n        option1 += min_price(branch,2)\\n    end\\n    options << option1\\n\\n    if num_choices == 2\\n        option2 = @prices[node] / 2\\n        next_nodes.each do |branch|\\n            option2 += min_price(branch,1)\\n        end\\n        options << option2\\n    end\\n\\n    @memo[node][num_choices] = options.min\\nend\\n\\n\\ndef path(start, finish, connections, checked)\\n    return [start] if start == finish\\n    checked.add(start)\\n\\n    next_nodes = connections[start]\\n    next_nodes.each do |node|\\n        next if checked.include?(node)\\n\\n        res = path(node, finish, connections, checked)\\n        return [start] + res if res\\n    end\\n\\n    nil\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\ndef minimum_total_price(n, edges, prices, trips)\\n    connections = Hash.new { |h,k| h[k] = Set[] }\\n    edges.each do |edge|\\n        a,b = edge\\n        connections[a].add(b)\\n        connections[b].add(a)\\n    end\\n\\n    trips.map! { |trip| path(trip[0], trip[1], connections, Set[]) }\\n\\n    node_count = Hash.new(0)\\n    trips.flatten.each { |node| node_count[node] += 1 }\\n\\n    prices.each_with_index do |price,i|\\n        prices[i] = price * node_count[i]\\n    end\\n\\n    queue = [0]\\n    until queue.empty?\\n        node = queue.shift\\n        adjacent_nodes = connections[node]\\n        adjacent_nodes.each do |next_node|\\n            connections[next_node].delete(node)\\n            queue << next_node\\n        end\\n    end\\n\\n    @memo = Array.new(n) { [nil,nil] }\\n    @prices = prices\\n    @connections = connections\\n    min_price(0,2)\\nend\\n\\n\\ndef min_price(node,num_choices)\\n    return @memo[node][num_choices] if @memo[node][num_choices]\\n\\n    options = []\\n\\n    option1 = @prices[node]\\n    next_nodes = @connections[node]\\n    next_nodes.each do |branch|\\n        option1 += min_price(branch,2)\\n    end\\n    options << option1\\n\\n    if num_choices == 2\\n        option2 = @prices[node] / 2\\n        next_nodes.each do |branch|\\n            option2 += min_price(branch,1)\\n        end\\n        options << option2\\n    end\\n\\n    @memo[node][num_choices] = options.min\\nend\\n\\n\\ndef path(start, finish, connections, checked)\\n    return [start] if start == finish\\n    checked.add(start)\\n\\n    next_nodes = connections[start]\\n    next_nodes.each do |node|\\n        next if checked.include?(node)\\n\\n        res = path(node, finish, connections, checked)\\n        return [start] + res if res\\n    end\\n\\n    nil\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3987505,
                "title": "node-contribution-technique-dfs-dp-memo",
                "content": "# Intuition\\n\\n\\n# Approach\\nSince its a tree we know that moving from node a to b has only one path. so we will calculate while moving on \\'trip\\' how many times we visited each node. calculating this will give us the total sum of paths while covering each \\'trip\\'(We will save this in a \\'contri\\' array). But since we can decrease non adjacent nodes by half this is not the answer.\\nNow for deciding which nodes to select to make them half, we will us dp. We basically have to calculate maxsum while travelling through the tree such that no two adjacent nodes are taken (let say this value comes as maxi). \\nOur final answer would be sum of all the value of contribution -(maxi/2). because we will decrease every node value which contribute to maxi by half.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // ***Node Contribution Technique\\n    vector<int>g[51];\\n    int dp[51][2];\\n    void dfs(int node,vector<int>&vis,vector<int>&contri,int target,vector<int>tmp)\\n    {\\n        vis[node]=1;\\n        if(node==target){\\n            //contri[target]++;\\n            for(int i=0;i<tmp.size();i++){\\n                contri[tmp[i]]++;\\n            }\\n            return;\\n        }\\n        for(auto v:g[node]){\\n            if(!vis[v]){\\n                tmp.push_back(v);\\n                dfs(v,vis,contri,target,tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    int rec(int node,int take,int par,vector<int>&contri)\\n    {\\n        if(dp[node][take]!=-1) return dp[node][take];\\n        if(take==0){\\n            int ans1=0;\\n            //take\\n            ans1=contri[node];\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans1+=rec(v,1,node,contri);\\n                }\\n            }\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]= max(ans1,ans2);\\n        }\\n        else{\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]=ans2;\\n        }\\n        return dp[node][take]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        int sz=trips.size();\\n        for(int i=0;i<sz;i++){\\n            vector<int>vis(n,0);\\n            int u=trips[i][0];\\n            int v= trips[i][1];\\n            vector<int>tmp;\\n            tmp.push_back(u);\\n            dfs(u,vis,contri,v,tmp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<contri[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            contri[i]*=price[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int maxi = rec(0,0,-1,contri);\\n        for(int i=0;i<n;i++){\\n            ans+=contri[i];\\n        }\\n        return ans-(maxi/2);\\n        //return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // ***Node Contribution Technique\\n    vector<int>g[51];\\n    int dp[51][2];\\n    void dfs(int node,vector<int>&vis,vector<int>&contri,int target,vector<int>tmp)\\n    {\\n        vis[node]=1;\\n        if(node==target){\\n            //contri[target]++;\\n            for(int i=0;i<tmp.size();i++){\\n                contri[tmp[i]]++;\\n            }\\n            return;\\n        }\\n        for(auto v:g[node]){\\n            if(!vis[v]){\\n                tmp.push_back(v);\\n                dfs(v,vis,contri,target,tmp);\\n                tmp.pop_back();\\n            }\\n        }\\n    }\\n    int rec(int node,int take,int par,vector<int>&contri)\\n    {\\n        if(dp[node][take]!=-1) return dp[node][take];\\n        if(take==0){\\n            int ans1=0;\\n            //take\\n            ans1=contri[node];\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans1+=rec(v,1,node,contri);\\n                }\\n            }\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]= max(ans1,ans2);\\n        }\\n        else{\\n            //don\\'t take\\n            int ans2=0;\\n            for(auto v:g[node]){\\n                if(v!=par){\\n                    ans2+=rec(v,0,node,contri);\\n                }\\n            }\\n            return dp[node][take]=ans2;\\n        }\\n        return dp[node][take]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int m=edges.size();\\n        for(int i=0;i<m;i++){\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        int sz=trips.size();\\n        for(int i=0;i<sz;i++){\\n            vector<int>vis(n,0);\\n            int u=trips[i][0];\\n            int v= trips[i][1];\\n            vector<int>tmp;\\n            tmp.push_back(u);\\n            dfs(u,vis,contri,v,tmp);\\n        }\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            cout<<contri[i]<<\" \";\\n        }\\n        cout<<endl;\\n        for(int i=0;i<n;i++){\\n            contri[i]*=price[i];\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int maxi = rec(0,0,-1,contri);\\n        for(int i=0;i<n;i++){\\n            ans+=contri[i];\\n        }\\n        return ans-(maxi/2);\\n        //return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3927181,
                "title": "frequency-transform-of-space-o-t-v-e-log-e-t-o-t-v-v-2-e-log-e-s-commented-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition for this is based on a few key findings from the problem description. \\n\\nFirst is that we are concerned with the minimal cost of ALL trips. This means that since all trips need to be taken, we can assume the space can be reduced to a signal problem. Since it can be reduced to a signal problem, we can use frequency analysis. This lets us utilize the frequency of a node occurrence within a repeated traversral of a graph space to determine actual costs. If you\\'ve done networking, this should be a familiar problem statement from that point forward. \\n\\nFrom there, the next realization is that when calculating the costs, you are faced with a form of backtracking, either to discount or not to discount. This lets you know to track two costs as you move through the frequency aligned space. With this in line, we can then focus on finding the minimum costs of the minimum costs for all trips. \\n\\nFinally, as with any graphical approach, we need to be careful of self-loops. To prevent these, it is important that our traversal methods include a way to check against looping over the same space again. This can be used to prevent infinite cycles. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo set up a graph, we can use the edges to build our adjacency list in O(E) time and in O(V^2) space (We store each vertex, and for each vertex we store each neighbor of it) \\n\\nWe then want to know the frequency of each node in each trip in trips, so we set up a frequency tracker. \\n\\n- For each src and dst node in trips\\n    - conduct dfs freq with src and a next node of src to start\\n    - the src is off the map as it were, which is there to indicate against self loops \\n    - in depth first search frequency, if you have reached dst for src in the current trip at the current node \\n        - update frequency of the current node and return True \\n    - otherwise \\n        - search each neighbor for graph at current node that is not next node and who\\'s dfs_freq comes out to True \\n            - the first found that is such a case causes current nodes frequency to increment and to return True \\n        - if you never find a way to reach destination, return False \\n\\nThe above loop takes O(T) time to loop over all trips, and in the process conducts a dfs taking O(V) time to loop over all vertices for all trips. This takes a total of O(T * V). T is not limited based on E, and as such can cover a much wider range of options. \\n\\nWe then set up a cost memo \\nWe then set up dfs over the frequency linked paths as follows \\nGiven a current node and next node \\n- if (current node, next node) in cost memo, return its findings \\n- otherwise \\n    - set current fare as price at current node * frequency at current node \\n    - discounted fare is half that \\n    - for neighbor of current node \\n        - if neighbor is not next node \\n            - current neighbor fare, current neighbor discount are from dfs of neighbor and current node \\n            - increment current fare by min of the above two \\n            - discounted fare always goes up by current neighbor fare since you chose to discount THIS current node \\n    - at end, memoize in cost memo at current node and next node the values of [current_fare, discounted_fare]\\n    - return those values \\n\\nThe above is called on 0 and 0 to start and stored in a fare list \\nThe min of the min of the fare list is your answer. \\nThe dfs process takes at least O(V) to process each vertex. \\nAs it does we must track O(E) costs by processing neighbors. \\nAs it does we then update and store this, reaching a log E reduction. \\nThis gives us V * E log E. In a non-sparse graph, E is much greater than V, so we can have E log E. We also store O(T) trip costs. Since this is recursive, we store this space as well for the E log E unfortunately. \\n\\nNote the use of self loop prevention here, it comes up often in these problems! \\n\\n# Complexity\\n- Time complexity : O(T * V + E log E)\\n    - Takes O(T * V) to do the trip based frequency finding \\n    - Takes O(E log E) to do the cost memoization findings \\n    - Takes O(E to build graph) \\n    - E log E subsumes O(E) \\n    - Total is O(T * V + E log E)  \\n\\n- Space complexity : \\n    - Takes O(T * V) to do the dfs_freq timewise, but as it is recursive, takes similar space as well \\n    - Takes O(V^2) to store graph in adjacency list format \\n    - Takes E log E timewise to do frequency cost find recursively, so similar cost \\n    - We store T trip costs worth in our cost memo, but this is subsumed by T * V \\n    - Total is O(T*V + V^2 + E log E) where T is size of Trips, V is number of nodes, and E is number of Edges  \\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # build adjacency list graph \\n        graph = [[] for _ in range(n)]\\n        for src, dst in edges : \\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        # since we have to take all trips, it\\'s easier to reduce the node space from a repeated loop over the tree \\n        # to a frequency based node space so that we can consider all the trips from a singular point of view \\n        # to do this, we need to process the frequency of each node reaching to a destination based on the neighbors \\n        # this can be done regardless of cost, since we will factor in cost based on the frequency at the later point of the algorithm \\n        # find frequency of each node \\n        frequency = [0] * n\\n        # by looping over trips \\n        for src, dst in trips : \\n            # dfs frequency loops each node in consideration to a next node \\n            def dfs_freq(current_node, next_node) : \\n                # where if current is now dst from outside looping \\n                if current_node == dst : \\n                    # update frequency of the current node in the search and return True \\n                    frequency[current_node] += 1 \\n                    return True \\n                else : \\n                    # otherwise, if not yet at destination, consider neighbors off of here \\n                    for neighbor in graph[current_node] : \\n                        # if the neighbor is not the next node we\\'d reach anyways,\\n                        # and the neighbor is able to eventually reach the destination without incurring a loop \\n                        if neighbor != next_node and dfs_freq(neighbor, current_node) : \\n                            # then we can increment the current nodes frequency and return true \\n                            frequency[current_node] += 1 \\n                            return True \\n                    # if we can never make it from this current node, we should return False \\n                    # we still need to get to this point, since along the way there may be other updates that occur \\n                    return False \\n            # and for each trip start, conducting dfs freq to find frequency of related node and sub nodes \\n            dfs_freq(src, src)\\n\\n        # memoize costs so to avoid repeat calculations \\n        cost_memo = dict() \\n        # this depth first search conducts based on fares. \\n        # the above loop set up the frequency interpretation, allowing us to skip multiple loops of cost accumulation otherwise \\n        # this is a transform of the problem space to a frequency based form, thus lowering overall complexity \\n        # this also allows us to now consider the costs based on the frequency that they might occur, allowing us to determine best choices for halving the price \\n        def dfs(current_node, next_node) : \\n            # check memo to avoid repeated calculations \\n            if (current_node, next_node) in cost_memo : \\n                return cost_memo[(current_node, next_node)][0], cost_memo[(current_node, next_node)][1] \\n            else : \\n                # here again, the next node serves as a check against self-loops \\n                # we start by calculating the current fare as a cost of price * frequency of occurrence on other trips \\n                current_fare = price[current_node] * frequency[current_node]\\n                # we then calculate the discounted price to allow for one way trip \\n                discounted_fare = current_fare//2\\n                # check local neighborhood \\n                for neighbor in graph[current_node] : \\n                    # and avoid self loops \\n                    if neighbor != next_node :\\n                        # set current neighbor fare and current neighbor discount as result of dfs on fare prices \\n                        current_neighbor_fare, current_neighbor_discount = dfs(neighbor, current_node)\\n                        # update current fare to track the minimum of the two (since you might discount this neighbor, or might not) \\n                        current_fare += min(current_neighbor_fare, current_neighbor_discount)\\n                        # discounted fare always gets the current neighbor fare since it was already discounted \\n                        discounted_fare += current_neighbor_fare\\n                # memoize your findings to avoid repeated calculations based on similar set ups \\n                cost_memo[(current_node, next_node)] = [current_fare, discounted_fare]\\n                # return your findings \\n                return current_fare, discounted_fare\\n                \\n        # build fare list \\n        fare_list = [dfs(0, 0)]\\n        # take the min of the min of the fare list (as you\\'ll get a tuple of items from dfs, so min of the final tuple)\\n        return min(min(fare_list))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # build adjacency list graph \\n        graph = [[] for _ in range(n)]\\n        for src, dst in edges : \\n            graph[src].append(dst)\\n            graph[dst].append(src)\\n        # since we have to take all trips, it\\'s easier to reduce the node space from a repeated loop over the tree \\n        # to a frequency based node space so that we can consider all the trips from a singular point of view \\n        # to do this, we need to process the frequency of each node reaching to a destination based on the neighbors \\n        # this can be done regardless of cost, since we will factor in cost based on the frequency at the later point of the algorithm \\n        # find frequency of each node \\n        frequency = [0] * n\\n        # by looping over trips \\n        for src, dst in trips : \\n            # dfs frequency loops each node in consideration to a next node \\n            def dfs_freq(current_node, next_node) : \\n                # where if current is now dst from outside looping \\n                if current_node == dst : \\n                    # update frequency of the current node in the search and return True \\n                    frequency[current_node] += 1 \\n                    return True \\n                else : \\n                    # otherwise, if not yet at destination, consider neighbors off of here \\n                    for neighbor in graph[current_node] : \\n                        # if the neighbor is not the next node we\\'d reach anyways,\\n                        # and the neighbor is able to eventually reach the destination without incurring a loop \\n                        if neighbor != next_node and dfs_freq(neighbor, current_node) : \\n                            # then we can increment the current nodes frequency and return true \\n                            frequency[current_node] += 1 \\n                            return True \\n                    # if we can never make it from this current node, we should return False \\n                    # we still need to get to this point, since along the way there may be other updates that occur \\n                    return False \\n            # and for each trip start, conducting dfs freq to find frequency of related node and sub nodes \\n            dfs_freq(src, src)\\n\\n        # memoize costs so to avoid repeat calculations \\n        cost_memo = dict() \\n        # this depth first search conducts based on fares. \\n        # the above loop set up the frequency interpretation, allowing us to skip multiple loops of cost accumulation otherwise \\n        # this is a transform of the problem space to a frequency based form, thus lowering overall complexity \\n        # this also allows us to now consider the costs based on the frequency that they might occur, allowing us to determine best choices for halving the price \\n        def dfs(current_node, next_node) : \\n            # check memo to avoid repeated calculations \\n            if (current_node, next_node) in cost_memo : \\n                return cost_memo[(current_node, next_node)][0], cost_memo[(current_node, next_node)][1] \\n            else : \\n                # here again, the next node serves as a check against self-loops \\n                # we start by calculating the current fare as a cost of price * frequency of occurrence on other trips \\n                current_fare = price[current_node] * frequency[current_node]\\n                # we then calculate the discounted price to allow for one way trip \\n                discounted_fare = current_fare//2\\n                # check local neighborhood \\n                for neighbor in graph[current_node] : \\n                    # and avoid self loops \\n                    if neighbor != next_node :\\n                        # set current neighbor fare and current neighbor discount as result of dfs on fare prices \\n                        current_neighbor_fare, current_neighbor_discount = dfs(neighbor, current_node)\\n                        # update current fare to track the minimum of the two (since you might discount this neighbor, or might not) \\n                        current_fare += min(current_neighbor_fare, current_neighbor_discount)\\n                        # discounted fare always gets the current neighbor fare since it was already discounted \\n                        discounted_fare += current_neighbor_fare\\n                # memoize your findings to avoid repeated calculations based on similar set ups \\n                cost_memo[(current_node, next_node)] = [current_fare, discounted_fare]\\n                # return your findings \\n                return current_fare, discounted_fare\\n                \\n        # build fare list \\n        fare_list = [dfs(0, 0)]\\n        # take the min of the min of the fare list (as you\\'ll get a tuple of items from dfs, so min of the final tuple)\\n        return min(min(fare_list))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926970,
                "title": "best-detailed-sol-dfs-dp-on-trees-c-easy",
                "content": "since it was a tree therefore we have only one path from any node to any node so we can run a dfs to find a path from one node to another and that would be the shortest path too since only one path exist between them but if it would have been a graph then more than one path would be possible just for knowledge\\n\\nnow coming to the code i called dfs for each node to store the path and then increased there freq after that we moved to dp on trees to check which node to half to get minimum price\\n\\ndp[node][1] denotes i halfed this node what would be the min cost\\ndp[node][0] denotes if i dont halfed this node what would be min cost\\n\\nnow if i hafled a particular node then i would have strict condtion that i have to take all the childs as non half means dp[child][0]\\n\\nnow if i dont half this node then i can take min of both dp[child][1]and dp[child][0] \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void dfs(int node,int par,int des,vector<int> &path,vector<int> adj[]){\\n        path.push_back(node);\\n        if(node==des){\\n            return ;\\n        }    \\n        for(int child:adj[node]){\\n            if(child!=par){\\n                dfs(child,node,des,path,adj);\\n            }\\n        }\\n        if(path.back()==des){\\n            return;\\n        }\\n        path.pop_back();\\n  }\\n\\n  void solve(int node,int par,vector<int> adj[],vector<vector<int>> &dp,vector<int> &freq,vector<int> &price){\\n     \\n    bool leaf=1; \\n    int nhalf=freq[node]*price[node];\\n    int half=freq[node]*(price[node]/2);\\n     int mini=0;\\n     int mini2=0;\\n     for(int child:adj[node]){\\n         if(child!=par){\\n             leaf=0; \\n             solve(child,node,adj,dp,freq,price);\\n             mini+=dp[child][0];\\n             mini2+=min(dp[child][1],dp[child][0]);\\n         }\\n     }\\n\\n     if(leaf){\\n         dp[node][1]=half;\\n         dp[node][0]=nhalf;\\n         return;\\n     }\\n     \\n     dp[node][1]=half+mini;\\n     dp[node][0]=nhalf+mini2;\\n\\n  } \\n\\n\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        // making the adjcency list\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        // now counting freq of each node on path\\n        for(int i=0; i<trips.size(); i++){\\n            int x=trips[i][0];\\n            int y=trips[i][1];\\n            vector<int> path;\\n            dfs(x,-1,y,path,adj);\\n            for(auto it:path){\\n                freq[it]++;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n,vector<int> (2,0));\\n        solve(0,-1,adj,dp,freq,price); \\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(int node,int par,int des,vector<int> &path,vector<int> adj[]){\\n        path.push_back(node);\\n        if(node==des){\\n            return ;\\n        }    \\n        for(int child:adj[node]){\\n            if(child!=par){\\n                dfs(child,node,des,path,adj);\\n            }\\n        }\\n        if(path.back()==des){\\n            return;\\n        }\\n        path.pop_back();\\n  }\\n\\n  void solve(int node,int par,vector<int> adj[],vector<vector<int>> &dp,vector<int> &freq,vector<int> &price){\\n     \\n    bool leaf=1; \\n    int nhalf=freq[node]*price[node];\\n    int half=freq[node]*(price[node]/2);\\n     int mini=0;\\n     int mini2=0;\\n     for(int child:adj[node]){\\n         if(child!=par){\\n             leaf=0; \\n             solve(child,node,adj,dp,freq,price);\\n             mini+=dp[child][0];\\n             mini2+=min(dp[child][1],dp[child][0]);\\n         }\\n     }\\n\\n     if(leaf){\\n         dp[node][1]=half;\\n         dp[node][0]=nhalf;\\n         return;\\n     }\\n     \\n     dp[node][1]=half+mini;\\n     dp[node][0]=nhalf+mini2;\\n\\n  } \\n\\n\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n,0);\\n        // making the adjcency list\\n        vector<int> adj[n];\\n        for(int i=0; i<edges.size(); i++){\\n            int x=edges[i][0];\\n            int y=edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        // now counting freq of each node on path\\n        for(int i=0; i<trips.size(); i++){\\n            int x=trips[i][0];\\n            int y=trips[i][1];\\n            vector<int> path;\\n            dfs(x,-1,y,path,adj);\\n            for(auto it:path){\\n                freq[it]++;\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n,vector<int> (2,0));\\n        solve(0,-1,adj,dp,freq,price); \\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904165,
                "title": "beats-97-15-hld-memoisation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep-1:Calculating total no.of times each vertice is repeated (using heavy light decomposition(hld)).\\n\\nStep-2:Performing DP(I did memoisation) from any assumed root.\\n# Complexity\\n- Time complexity:O(m * log(n) * log(n) + n * log(n)).Where m is no.of trips and n is no.of vertices\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:O(m + n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\ntemplate<class T>\\nstruct graph{\\n\\tstruct E{\\n\\t\\tint from, to;\\n\\t\\tT cost;\\n\\t};\\n\\tint n;\\n\\tvector<E> edge;\\n\\tvector<vector<int>> adj;\\n\\tfunction<bool(int)> ignore;\\n\\tgraph(int n = 1): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t}\\n\\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);\\n\\t}\\n\\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);\\n\\t}\\n\\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);\\n\\t}\\n\\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);\\n\\t}\\n\\tint operator()(int u, int id) const{\\n\\t\\t#ifdef LOCAL\\n\\t\\tassert(0 <= id && id < (int)edge.size());\\n\\t\\tassert(edge[id].from == u || edge[id].to == u);\\n\\t\\t#endif\\n\\t\\treturn u ^ edge[id].from ^ edge[id].to;\\n\\t}\\n\\tint link(int u, int v, T w = {}){ // insert an undirected edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tint orient(int u, int v, T w = {}){ // insert a directed edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tvoid clear(){\\n\\t\\tfor(auto [u, v, w]: edge){\\n\\t\\t\\tadj[u].clear();\\n\\t\\t\\tadj[v].clear();\\n\\t\\t}\\n\\t\\tedge.clear();\\n\\t\\tignore = {};\\n\\t}\\n\\tgraph transposed() const{ // the transpose of the directed graph\\n\\t\\tgraph res(n);\\n\\t\\tfor(auto &e: edge) res.orient(e.to, e.from, e.cost);\\n\\t\\tres.ignore = ignore;\\n\\t\\treturn res;\\n\\t}\\n\\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)\\n\\t\\treturn (int)adj[u].size();\\n\\t}\\n\\t// The adjacency list is sorted for each vertex.\\n\\tvector<vector<int>> get_adjacency_list() const{\\n\\t\\tvector<vector<int>> res(n);\\n\\t\\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){\\n\\t\\t\\tif(ignore && ignore(id)) continue;\\n\\t\\t\\tres[(*this)(u, id)].push_back(u);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tvoid set_ignoration_rule(const function<bool(int)> &f){\\n\\t\\tignore = f;\\n\\t}\\n\\tvoid reset_ignoration_rule(){\\n\\t\\tignore = nullptr;\\n\\t}\\n\\tfriend ostream &operator<<(ostream &out, const graph &g){\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\nstruct heavy_light_decomposition{\\n\\tint n;\\n\\tvector<vector<int>> adj; // stores edge ids\\n\\tvector<int> roots; // root of the component\\n\\tvector<int> pv;\\n\\tvector<int> pe;\\n\\tvector<int> size;\\n\\tvector<int> depth;\\n\\tvector<int> next; // highest point of the heavy path\\n\\tvector<int> prev; // lowest point of the heavy path\\n\\tvector<int> pos;\\n\\tvector<int> end;\\n\\tvector<int> order;\\n\\ttemplate<class T>\\n\\theavy_light_decomposition(const graph<T> &g, const vector<int> &roots): n(g.n), roots(roots), adj(n), pv(n, -1), pe(n, -1), size(n, 1), depth(n), next(n), prev(n), pos(n), end(n){\\n\\t\\tiota(prev.begin(), prev.end(), 0);\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tadj[e.from].push_back(id), adj[e.to].push_back(id);\\n\\t\\t}\\n\\t\\tauto dfs_init = [&](auto self, int u, int root)->void{\\n\\t\\t\\tnext[u] = root;\\n\\t\\t\\tif(~pe[u]) adj[u].erase(find(adj[u].begin(), adj[u].end(), pe[u]));\\n\\t\\t\\tfor(auto &id: adj[u]){\\n\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\tpv[v] = u, pe[v] = id, depth[v] = depth[u] + 1;\\n\\t\\t\\t\\tself(self, v, u);\\n\\t\\t\\t\\tsize[u] += size[v];\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tif(size[v] > size[u ^ f.from ^ f.to]) swap(id, adj[u][0]);\\n\\t\\t\\t}\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &e = g.edge[adj[u][0]];\\n\\t\\t\\t\\tprev[u] = prev[u ^ e.from ^ e.to];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tint timer = 0;\\n\\t\\tauto dfs_hld = [&](auto self, int u)->void{\\n\\t\\t\\tpos[u] = timer ++;\\n\\t\\t\\torder.push_back(u);\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tint hv = u ^ f.from ^ f.to;\\n\\t\\t\\t\\tfor(auto id: adj[u]){\\n\\t\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\t\\tnext[v] = (v == hv ? next[u] : v);\\n\\t\\t\\t\\t\\tself(self, v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend[u] = timer;\\n\\t\\t};\\n\\t\\tfor(auto r: roots) assert(!~pv[r]), dfs_init(dfs_init, r, r), dfs_hld(dfs_hld, r);\\n\\t}\\n\\t// O(1)\\n\\tbool ancestor_of(int u, int v) const{\\n\\t\\treturn pos[u] <= pos[v] && end[v] <= end[u];\\n\\t}\\n\\tint lca(int u, int v) const{\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]) if(depth[next[u]] > depth[next[v]]) swap(u, v);\\n\\t\\treturn depth[u] < depth[v] ? u : v;\\n\\t}\\n\\tint steps(int u, int v, int w = -1) const{\\n\\t\\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];\\n\\t}\\n\\t// f reads the position in the data structure\\n\\t// One application of f\\n\\tvoid access_node(int u, auto f) const{\\n\\t\\tf(pos[u]);\\n\\t}\\n\\t// One application of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_subtree(int u, auto f) const{\\n\\t\\tf(pos[u] + VALS_IN_EDGES, end[u]);\\n\\t}\\n\\t// f(left, right, (left->right ?))\\n\\t// O(log n) applications of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_path(int u, int v, auto f) const{\\n\\t\\tbool dir = true;\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]){\\n\\t\\t\\tif(depth[next[u]] > depth[next[v]]) swap(u, v), dir = !dir;\\n\\t\\t\\tf(pos[next[v]], pos[v] + 1, dir);\\n\\t\\t}\\n\\t\\tif(depth[u] > depth[v]) swap(u, v), dir = !dir;\\n\\t\\tf(pos[u] + VALS_IN_EDGES, pos[v] + 1, dir);\\n\\t}\\n\\t// Pair of indices {l, r} in the data structure. resr is reversed(v->next[v], pv[next[v]]-> ...)\\n\\t// O(log n)\\n\\tauto get_path(int u, int v) const{\\n\\t\\tvector<pair<int, int>> resl, resr;\\n\\t\\taccess_path(u, v, [&](int l, int r, bool dir){ (dir ? resl : resr).push_back({l, r}); });\\n\\t\\treturn pair{resl, resr};\\n\\t}\\n};\\ntemplate<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph<int>g(n);\\n        for(auto x:edges){\\n            g.link(x[0],x[1],1);\\n        }\\n        heavy_light_decomposition hld(g,{0});\\n        range_add_range_sum_query_solver rar(n,0);\\n        for(auto &x:trips){\\n            hld.access_path(x[0],x[1],[&](int l,int r,bool){\\n                rar.update(l,r,1);\\n            });\\n        }\\n        vector<vector<int>> dp(n,vector<int>(2,0)),vis(n,vector<int>(2,0));\\n        function<int(int,int)> dfs=[&](int node,int taken){\\n            if(vis[node][taken]) return dp[node][taken];\\n            vis[node][taken]=1;\\n            int ret=rar.query(hld.pos[node],hld.pos[node]+1)*price[node];\\n\\t\\t\\t\\t\\t\\tint curr=0,_curr=0;\\n            for(auto x:g.adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(hld.pe[node]==x) continue;\\n                curr+=dfs(g(node,x),0);\\n                if(!taken)\\n                    _curr+=dfs(g(node,x),1);\\n            }\\n\\t\\t\\t\\t\\t\\tif(taken) return dp[node][taken]=ret+curr;\\n\\t\\t\\t\\t\\t\\treturn dp[node][taken]=min(ret/2+_curr,ret+curr);\\n        };\\n        dfs(0,0);\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\ntemplate<class T>\\nstruct graph{\\n\\tstruct E{\\n\\t\\tint from, to;\\n\\t\\tT cost;\\n\\t};\\n\\tint n;\\n\\tvector<E> edge;\\n\\tvector<vector<int>> adj;\\n\\tfunction<bool(int)> ignore;\\n\\tgraph(int n = 1): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t}\\n\\tgraph(const vector<vector<int>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto v: adj[u]) if(u < v) link(u, v);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto v: adj[u]) orient(u, v);\\n\\t}\\n\\tgraph(const vector<vector<pair<int, T>>> &adj, bool undirected = true): n((int)adj.size()), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tif(undirected){\\n\\t\\t\\tfor(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) if(u < v) link(u, v, w);\\n\\t\\t}\\n\\t\\telse for(auto u = 0; u < n; ++ u) for(auto [v, w]: adj[u]) orient(u, v, w);\\n\\t}\\n\\tgraph(int n, vector<array<int, 2>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v]: edge) undirected ? link(u, v) : orient(u, v);\\n\\t}\\n\\tgraph(int n, vector<tuple<int, int, T>> &edge, bool undirected = true): n(n), adj(n){\\n\\t\\tassert(n >= 1);\\n\\t\\tfor(auto [u, v, w]: edge) undirected ? link(u, v, w) : orient(u, v, w);\\n\\t}\\n\\tint operator()(int u, int id) const{\\n\\t\\t#ifdef LOCAL\\n\\t\\tassert(0 <= id && id < (int)edge.size());\\n\\t\\tassert(edge[id].from == u || edge[id].to == u);\\n\\t\\t#endif\\n\\t\\treturn u ^ edge[id].from ^ edge[id].to;\\n\\t}\\n\\tint link(int u, int v, T w = {}){ // insert an undirected edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), adj[v].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tint orient(int u, int v, T w = {}){ // insert a directed edge\\n\\t\\tint id = (int)edge.size();\\n\\t\\tadj[u].push_back(id), edge.push_back({u, v, w});\\n\\t\\treturn id;\\n\\t}\\n\\tvoid clear(){\\n\\t\\tfor(auto [u, v, w]: edge){\\n\\t\\t\\tadj[u].clear();\\n\\t\\t\\tadj[v].clear();\\n\\t\\t}\\n\\t\\tedge.clear();\\n\\t\\tignore = {};\\n\\t}\\n\\tgraph transposed() const{ // the transpose of the directed graph\\n\\t\\tgraph res(n);\\n\\t\\tfor(auto &e: edge) res.orient(e.to, e.from, e.cost);\\n\\t\\tres.ignore = ignore;\\n\\t\\treturn res;\\n\\t}\\n\\tint degree(int u) const{ // the degree (outdegree if directed) of u (without the ignoration rule)\\n\\t\\treturn (int)adj[u].size();\\n\\t}\\n\\t// The adjacency list is sorted for each vertex.\\n\\tvector<vector<int>> get_adjacency_list() const{\\n\\t\\tvector<vector<int>> res(n);\\n\\t\\tfor(auto u = 0; u < n; ++ u) for(auto id: adj[u]){\\n\\t\\t\\tif(ignore && ignore(id)) continue;\\n\\t\\t\\tres[(*this)(u, id)].push_back(u);\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\tvoid set_ignoration_rule(const function<bool(int)> &f){\\n\\t\\tignore = f;\\n\\t}\\n\\tvoid reset_ignoration_rule(){\\n\\t\\tignore = nullptr;\\n\\t}\\n\\tfriend ostream &operator<<(ostream &out, const graph &g){\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tout << \"{\" << e.from << \", \" << e.to << \", \" << e.cost << \"}\\\\n\";\\n\\t\\t}\\n\\t\\treturn out;\\n\\t}\\n};\\nstruct heavy_light_decomposition{\\n\\tint n;\\n\\tvector<vector<int>> adj; // stores edge ids\\n\\tvector<int> roots; // root of the component\\n\\tvector<int> pv;\\n\\tvector<int> pe;\\n\\tvector<int> size;\\n\\tvector<int> depth;\\n\\tvector<int> next; // highest point of the heavy path\\n\\tvector<int> prev; // lowest point of the heavy path\\n\\tvector<int> pos;\\n\\tvector<int> end;\\n\\tvector<int> order;\\n\\ttemplate<class T>\\n\\theavy_light_decomposition(const graph<T> &g, const vector<int> &roots): n(g.n), roots(roots), adj(n), pv(n, -1), pe(n, -1), size(n, 1), depth(n), next(n), prev(n), pos(n), end(n){\\n\\t\\tiota(prev.begin(), prev.end(), 0);\\n\\t\\tfor(auto id = 0; id < (int)g.edge.size(); ++ id){\\n\\t\\t\\tif(g.ignore && g.ignore(id)) continue;\\n\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\tadj[e.from].push_back(id), adj[e.to].push_back(id);\\n\\t\\t}\\n\\t\\tauto dfs_init = [&](auto self, int u, int root)->void{\\n\\t\\t\\tnext[u] = root;\\n\\t\\t\\tif(~pe[u]) adj[u].erase(find(adj[u].begin(), adj[u].end(), pe[u]));\\n\\t\\t\\tfor(auto &id: adj[u]){\\n\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\tpv[v] = u, pe[v] = id, depth[v] = depth[u] + 1;\\n\\t\\t\\t\\tself(self, v, u);\\n\\t\\t\\t\\tsize[u] += size[v];\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tif(size[v] > size[u ^ f.from ^ f.to]) swap(id, adj[u][0]);\\n\\t\\t\\t}\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &e = g.edge[adj[u][0]];\\n\\t\\t\\t\\tprev[u] = prev[u ^ e.from ^ e.to];\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tint timer = 0;\\n\\t\\tauto dfs_hld = [&](auto self, int u)->void{\\n\\t\\t\\tpos[u] = timer ++;\\n\\t\\t\\torder.push_back(u);\\n\\t\\t\\tif(!adj[u].empty()){\\n\\t\\t\\t\\tauto &f = g.edge[adj[u][0]];\\n\\t\\t\\t\\tint hv = u ^ f.from ^ f.to;\\n\\t\\t\\t\\tfor(auto id: adj[u]){\\n\\t\\t\\t\\t\\tauto &e = g.edge[id];\\n\\t\\t\\t\\t\\tint v = u ^ e.from ^ e.to;\\n\\t\\t\\t\\t\\tnext[v] = (v == hv ? next[u] : v);\\n\\t\\t\\t\\t\\tself(self, v);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tend[u] = timer;\\n\\t\\t};\\n\\t\\tfor(auto r: roots) assert(!~pv[r]), dfs_init(dfs_init, r, r), dfs_hld(dfs_hld, r);\\n\\t}\\n\\t// O(1)\\n\\tbool ancestor_of(int u, int v) const{\\n\\t\\treturn pos[u] <= pos[v] && end[v] <= end[u];\\n\\t}\\n\\tint lca(int u, int v) const{\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]) if(depth[next[u]] > depth[next[v]]) swap(u, v);\\n\\t\\treturn depth[u] < depth[v] ? u : v;\\n\\t}\\n\\tint steps(int u, int v, int w = -1) const{\\n\\t\\treturn depth[u] + depth[v] - 2 * depth[~w ? w : lca(u, v)];\\n\\t}\\n\\t// f reads the position in the data structure\\n\\t// One application of f\\n\\tvoid access_node(int u, auto f) const{\\n\\t\\tf(pos[u]);\\n\\t}\\n\\t// One application of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_subtree(int u, auto f) const{\\n\\t\\tf(pos[u] + VALS_IN_EDGES, end[u]);\\n\\t}\\n\\t// f(left, right, (left->right ?))\\n\\t// O(log n) applications of f\\n\\ttemplate<int VALS_IN_EDGES = 0>\\n\\tvoid access_path(int u, int v, auto f) const{\\n\\t\\tbool dir = true;\\n\\t\\tfor(; next[u] != next[v]; v = pv[next[v]]){\\n\\t\\t\\tif(depth[next[u]] > depth[next[v]]) swap(u, v), dir = !dir;\\n\\t\\t\\tf(pos[next[v]], pos[v] + 1, dir);\\n\\t\\t}\\n\\t\\tif(depth[u] > depth[v]) swap(u, v), dir = !dir;\\n\\t\\tf(pos[u] + VALS_IN_EDGES, pos[v] + 1, dir);\\n\\t}\\n\\t// Pair of indices {l, r} in the data structure. resr is reversed(v->next[v], pv[next[v]]-> ...)\\n\\t// O(log n)\\n\\tauto get_path(int u, int v) const{\\n\\t\\tvector<pair<int, int>> resl, resr;\\n\\t\\taccess_path(u, v, [&](int l, int r, bool dir){ (dir ? resl : resr).push_back({l, r}); });\\n\\t\\treturn pair{resl, resr};\\n\\t}\\n};\\ntemplate<class T>\\nstruct range_add_range_sum_query_solver{\\n\\tint n;\\n\\tvector<T> data0, data1;\\n\\trange_add_range_sum_query_solver(){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n): n(n), data0(n), data1(n){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(int n, T init): range_add_range_sum_query_solver(vector<T>(n, init)){ }\\n\\t// O(n)\\n\\trange_add_range_sum_query_solver(const vector<T> &v): n((int)v.size()), data0(n), data1(v){\\n\\t\\tfor(auto i = 1; i <= n; ++ i) if(i + (i & -i) <= n) data1[i + (i & -i) - 1] += data1[i - 1];\\n\\t}\\n\\tvoid update(int ql, int qr, T x){\\n\\t\\tassert(0 <= ql && ql <= qr && qr <= n);\\n\\t\\tif(ql == qr) return;\\n\\t\\tfor(auto l = ql + 1; l <= n; l += l & -l) data0[l - 1] += x, data1[l - 1] -= ql * x;\\n\\t\\tfor(auto r = qr + 1; r <= n; r += r & -r) data0[r - 1] -= x, data1[r - 1] += qr * x;\\n\\t}\\n\\tT pref(int qr) const{\\n\\t\\tassert(0 <= qr && qr <= n);\\n\\t\\tT sum0 = {}, sum1 = {};\\n\\t\\tfor(auto r = qr; r > 0; r -= r & -r) sum0 += data0[r - 1], sum1 += data1[r - 1];\\n\\t\\treturn qr * sum0 + sum1;\\n\\t}\\n\\tT query(int l, int r) const{\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\treturn pref(r) - pref(l);\\n\\t}\\n\\ttemplate<class output_stream>\\n\\tfriend output_stream &operator<<(output_stream &out, const range_add_range_sum_query_solver<T> &solver){\\n\\t\\tout << \"[\";\\n\\t\\tfor(auto i = 0; i < solver.n; ++ i){\\n\\t\\t\\tout << solver.query(i, i + 1);\\n\\t\\t\\tif(i != solver.n - 1) out << \", \";\\n\\t\\t}\\n\\t\\treturn out << \\']\\';\\n\\t}\\n};\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph<int>g(n);\\n        for(auto x:edges){\\n            g.link(x[0],x[1],1);\\n        }\\n        heavy_light_decomposition hld(g,{0});\\n        range_add_range_sum_query_solver rar(n,0);\\n        for(auto &x:trips){\\n            hld.access_path(x[0],x[1],[&](int l,int r,bool){\\n                rar.update(l,r,1);\\n            });\\n        }\\n        vector<vector<int>> dp(n,vector<int>(2,0)),vis(n,vector<int>(2,0));\\n        function<int(int,int)> dfs=[&](int node,int taken){\\n            if(vis[node][taken]) return dp[node][taken];\\n            vis[node][taken]=1;\\n            int ret=rar.query(hld.pos[node],hld.pos[node]+1)*price[node];\\n\\t\\t\\t\\t\\t\\tint curr=0,_curr=0;\\n            for(auto x:g.adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\tif(hld.pe[node]==x) continue;\\n                curr+=dfs(g(node,x),0);\\n                if(!taken)\\n                    _curr+=dfs(g(node,x),1);\\n            }\\n\\t\\t\\t\\t\\t\\tif(taken) return dp[node][taken]=ret+curr;\\n\\t\\t\\t\\t\\t\\treturn dp[node][taken]=min(ret/2+_curr,ret+curr);\\n        };\\n        dfs(0,0);\\n\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897402,
                "title": "python-implementation-using-backtracking-dp",
                "content": "# Intuition\\nThe Idea here is to select those nodes which are involved in the trips and discard other nodes as they are not involved. Then run dfs again to find the solution.\\n\\n# Approach\\n***n = len(price)***: The number of nodes is determined by the length of the price list, which is equivalent to **n**.\\n\\n***Constructing the Graph:***\\n\\nThe given edges are used to construct an undirected graph **g** using an adjacency list.\\nFor each edge $$(u, v)$$, nodes u and v are connected by adding each other to their respective adjacency lists in g.\\n\\n***DFS to Find Paths:***\\n\\nA DFS (Depth-First Search) traversal is used to find paths between nodes in the graph.\\nThe dfs function performs a recursive DFS traversal to find a path from the **source** node to the **target** node.\\nDuring the traversal, nodes are added to the **result** list. If the **target** node is reached, the path is complete, and the **count** array is updated to track the number of times each node is traversed.\\nThe dfs function returns True when the **target** node is reached.\\n\\n***Dynamic Programming with Memorization:***\\n\\nThe **calc** function is used for dynamic programming to calculate the minimum cost for each node considering whether it\\'s halved or not.\\nMemorization is applied using the$$ @lru_cache(None)$$ decorator to store previously calculated results and avoid recomputation.\\nFor each node, two possibilities are considered: halving the node\\'s price **(h = True)** or not halving it **(h = False)**.\\nThe **res1** variable calculates the total cost of the node and its adjacent nodes, while **res2** calculates the cost with the node\\'s price halved.\\nThe dynamic programming function returns the minimum cost between **res1** and **res2**.\\n\\n***Processing Trips:***\\n\\nFor each trip $$[u, v]$$ in the trips list, the dfs function is called to find the path from node $$u$$ to node $$v$$.\\nDuring this process, the count array is updated to keep track of the nodes traversed in each path.\\n\\n***Return Minimum Total Price:***\\n\\nThe **calc** function is called with the default arguments to calculate the minimum total price for all trips.\\nThe final result is the minimum total price required to perform all the given trips.\\nThis solution utilizes DFS to find paths and dynamic programming to calculate the minimum cost for each node considering different scenarios of halving prices. Memorization helps to optimize the computation by storing previously calculated results.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nConstructing the graph from the edges takes $$O(n-1)$$, where $$n$$ is the number of nodes.\\nThe DFS traversal performed for each trip takes $$O(n)$$ in the worst case since it can traverse through all nodes.\\nThe dynamic programming function calc is memoized using $$@lru_cache$$, which stores and reuses previously calculated results. As a result, the time complexity for each unique function call is constant time.\\nOverall, the time complexity can be approximated as $$O(n * m)$$, where $$n$$ is the number of nodes and $$m$$ is the number of trips.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space required for storing the graph\\'s adjacency list is$$ O(n + n-1)$$, where $$n$$ is the number of nodes and $$n-1$$ is the number of edges.\\nThe result list is used to store the path during DFS and its maximum size can be n, resulting in $$O(n)$$ space.\\nThe count array is used to track the number of times each node is traversed, taking $$O(n)$$ space.\\nThe $$@lru_cache$$ decorator uses space proportional to the number of unique function calls.\\nOverall, the space complexity is $$O(n + n-1 + n + m)$$, where $$n$$ is the number of nodes and m is the number of trips.\\nIn summary, the time complexity is primarily dependent on the number of nodes and trips, while the space complexity is influenced by the graph\\'s adjacency list, path storage, and memoization.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        n = len(price)\\n        \\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n            \\n        result = []\\n        count = [0] * n\\n        def dfs(node, target, parent):\\n            result.append(node)\\n            \\n            if node == target:\\n                while result: count[result.pop()] += 1\\n                return True\\n            \\n            for neighbor in g[node]:\\n                if neighbor != parent:\\n                    if dfs(neighbor, target, node): return True\\n            \\n            result.pop()\\n            return False\\n\\n        @lru_cache(None)\\n        def calc(node = 0, p = -1, h = False):\\n            res1 = count[node] * price[node]\\n            res2 = res1 // 2\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res1 += calc(adj, node, False)\\n            if h: return res1\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res2 += calc(adj, node, True)\\n            return min(res1, res2)\\n\\n\\n        for u, v in trips:\\n            dfs(u, v, -1)\\n\\n        return calc()\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        n = len(price)\\n        \\n        for e in edges:\\n            g[e[0]].append(e[1])\\n            g[e[1]].append(e[0])\\n            \\n        result = []\\n        count = [0] * n\\n        def dfs(node, target, parent):\\n            result.append(node)\\n            \\n            if node == target:\\n                while result: count[result.pop()] += 1\\n                return True\\n            \\n            for neighbor in g[node]:\\n                if neighbor != parent:\\n                    if dfs(neighbor, target, node): return True\\n            \\n            result.pop()\\n            return False\\n\\n        @lru_cache(None)\\n        def calc(node = 0, p = -1, h = False):\\n            res1 = count[node] * price[node]\\n            res2 = res1 // 2\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res1 += calc(adj, node, False)\\n            if h: return res1\\n\\n            for adj in g[node]:\\n                if adj != p:\\n                    res2 += calc(adj, node, True)\\n            return min(res1, res2)\\n\\n\\n        for u, v in trips:\\n            dfs(u, v, -1)\\n\\n        return calc()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879859,
                "title": "o-kn-dp",
                "content": "# Intuition\\nDFS + DP\\n\\n# Approach\\nStep 1. Loop through edges to generate the graph\\nStep 2. Loop through trips to get the weight of each node\\nStep 3. Use DFS to generate tree based on graph\\nStep 4. DP\\n\\n# Complexity\\n- Time complexity:\\nO(n) + O(kn) + O(n) + O(2n) = O(kn) where k is # of trips and n is # of nodes\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        cnt_table = dict(zip([i for i in range(n)], [0 for i in range(n)]))\\n        visited = {}\\n        def DFS(start, end):\\n            visited[start] = True\\n            if start == end:\\n                return [start]\\n            res = []\\n            children = graph[start]\\n            for child in children:\\n                if child not in visited:\\n                    tmp = DFS(child,end)\\n                    if tmp != []:\\n                        res += tmp\\n            if res == []:\\n                return []\\n            return [start] + res\\n\\n        \\n        for trip in trips:\\n            visited = {}\\n            nodes = DFS(trip[0], trip[1])\\n            for node in nodes:\\n                cnt_table[node] += 1 \\n        print(cnt_table)\\n        \\n        \\n        new_graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        stack = [0]\\n        i = 0\\n        visited = {0:True}\\n        print(graph)\\n        while stack != []:\\n            curr = stack.pop()\\n            for child in graph[curr]:\\n                if child not in visited:\\n                    new_graph[curr].append(child)\\n                    visited[child] = True\\n                    stack.append(child)\\n        graph = new_graph\\n        print(graph)\\n\\n        record = {}\\n        def help(node, flag):\\n            if (node, flag) in record:\\n                return record[(node, flag)]\\n            res = 0\\n            if flag == False:\\n                for child in graph[node]:\\n                    res += price[child]*cnt_table[child]+help(child,True)\\n            else:\\n                for child in graph[node]:\\n                    res1 = price[child]*cnt_table[child] + help(child,True)\\n                    res2 = price[child]*cnt_table[child]//2 + help(child,False)\\n                    res += min(res1, res2)\\n            record[(node,flag)] = res\\n            return res\\n        return min(price[0]*cnt_table[0]//2+help(0,False), price[0]*cnt_table[0]+help(0,True))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        for edge in edges:\\n            graph[edge[0]].append(edge[1])\\n            graph[edge[1]].append(edge[0])\\n        cnt_table = dict(zip([i for i in range(n)], [0 for i in range(n)]))\\n        visited = {}\\n        def DFS(start, end):\\n            visited[start] = True\\n            if start == end:\\n                return [start]\\n            res = []\\n            children = graph[start]\\n            for child in children:\\n                if child not in visited:\\n                    tmp = DFS(child,end)\\n                    if tmp != []:\\n                        res += tmp\\n            if res == []:\\n                return []\\n            return [start] + res\\n\\n        \\n        for trip in trips:\\n            visited = {}\\n            nodes = DFS(trip[0], trip[1])\\n            for node in nodes:\\n                cnt_table[node] += 1 \\n        print(cnt_table)\\n        \\n        \\n        new_graph = dict(zip([i for i in range(n)], [[] for i in range(n)]))\\n        stack = [0]\\n        i = 0\\n        visited = {0:True}\\n        print(graph)\\n        while stack != []:\\n            curr = stack.pop()\\n            for child in graph[curr]:\\n                if child not in visited:\\n                    new_graph[curr].append(child)\\n                    visited[child] = True\\n                    stack.append(child)\\n        graph = new_graph\\n        print(graph)\\n\\n        record = {}\\n        def help(node, flag):\\n            if (node, flag) in record:\\n                return record[(node, flag)]\\n            res = 0\\n            if flag == False:\\n                for child in graph[node]:\\n                    res += price[child]*cnt_table[child]+help(child,True)\\n            else:\\n                for child in graph[node]:\\n                    res1 = price[child]*cnt_table[child] + help(child,True)\\n                    res2 = price[child]*cnt_table[child]//2 + help(child,False)\\n                    res += min(res1, res2)\\n            record[(node,flag)] = res\\n            return res\\n        return min(price[0]*cnt_table[0]//2+help(0,False), price[0]*cnt_table[0]+help(0,True))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864889,
                "title": "java-solution-dfs-top-down-memoization",
                "content": "# Intuition\\n1. Build a graph\\n2. Use dfs to find the count of every node in the path of all th routes.\\n3. Use top down memoization to find the minimum cost of covering all path.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    HashMap<String, Integer> hm = new HashMap<>();\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashMap<Integer, List<Integer>> graph = buildGraph(edges, n);\\n        HashMap<Integer, Integer> visitCount = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            visitCount.put(i, 0);\\n        }\\n        \\n        for(int[] trip : trips) {\\n            dfs(trip[0], trip[1], visitCount, graph, new boolean[n]);\\n        }\\n\\n        int[] cost = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            cost[i] = price[i] * visitCount.get(i);\\n        }\\n\\n        return minPrice(trips[0][0], new boolean[n], graph, 1, cost, calculated);\\n    }\\n\\n    public int minPrice(int start, boolean[] visited, HashMap<Integer, List<Integer>> graph, int canHalf, int[] cost) {\\n        if(hm.containsKey(start +\"-\"+canHalf)) {\\n            return hm.get(start +\"-\"+canHalf);\\n        }\\n        visited[start] = true;\\n\\n        int half = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            half = cost[start] / 2;\\n            for(int m: graph.get(start)) {\\n                if(!visited[m]) {\\n                    half += minPrice(m, visited, graph, 0, cost);\\n                }\\n            }\\n        }\\n        \\n        int noHalf = cost[start];\\n        for(int m: graph.get(start)) {\\n            if(!visited[m]) {\\n                noHalf += minPrice(m, visited, graph, 1, cost);\\n            }\\n        }\\n        visited[start] = false;\\n        \\n        hm.put(start + \"-\" + canHalf, Math.min(half, noHalf));\\n        return Math.min(half, noHalf);\\n    }\\n\\n    public boolean dfs(int a, int b, HashMap<Integer, Integer> visitCount, HashMap<Integer, List<Integer>> graph, boolean[] visited) {\\n        if(a == b) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n            return true;\\n        }\\n        visited[a] = true;\\n        boolean found = false;\\n        for(int m: graph.get(a)) {\\n            if(!visited[m]) {\\n                found |= dfs(m, b, visitCount, graph, visited);\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        if(found) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n        }\\n        visited[a] = false;\\n        return found;\\n    }\\n\\n    public HashMap<Integer, List<Integer>> buildGraph(int[][] edges, int n) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge:edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<String, Integer> hm = new HashMap<>();\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashMap<Integer, List<Integer>> graph = buildGraph(edges, n);\\n        HashMap<Integer, Integer> visitCount = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            visitCount.put(i, 0);\\n        }\\n        \\n        for(int[] trip : trips) {\\n            dfs(trip[0], trip[1], visitCount, graph, new boolean[n]);\\n        }\\n\\n        int[] cost = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            cost[i] = price[i] * visitCount.get(i);\\n        }\\n\\n        return minPrice(trips[0][0], new boolean[n], graph, 1, cost, calculated);\\n    }\\n\\n    public int minPrice(int start, boolean[] visited, HashMap<Integer, List<Integer>> graph, int canHalf, int[] cost) {\\n        if(hm.containsKey(start +\"-\"+canHalf)) {\\n            return hm.get(start +\"-\"+canHalf);\\n        }\\n        visited[start] = true;\\n\\n        int half = Integer.MAX_VALUE;\\n        if (canHalf == 1) {\\n            half = cost[start] / 2;\\n            for(int m: graph.get(start)) {\\n                if(!visited[m]) {\\n                    half += minPrice(m, visited, graph, 0, cost);\\n                }\\n            }\\n        }\\n        \\n        int noHalf = cost[start];\\n        for(int m: graph.get(start)) {\\n            if(!visited[m]) {\\n                noHalf += minPrice(m, visited, graph, 1, cost);\\n            }\\n        }\\n        visited[start] = false;\\n        \\n        hm.put(start + \"-\" + canHalf, Math.min(half, noHalf));\\n        return Math.min(half, noHalf);\\n    }\\n\\n    public boolean dfs(int a, int b, HashMap<Integer, Integer> visitCount, HashMap<Integer, List<Integer>> graph, boolean[] visited) {\\n        if(a == b) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n            return true;\\n        }\\n        visited[a] = true;\\n        boolean found = false;\\n        for(int m: graph.get(a)) {\\n            if(!visited[m]) {\\n                found |= dfs(m, b, visitCount, graph, visited);\\n            }\\n            if(found) {\\n                break;\\n            }\\n        }\\n        if(found) {\\n            visitCount.put(a, visitCount.get(a) + 1);\\n        }\\n        visited[a] = false;\\n        return found;\\n    }\\n\\n    public HashMap<Integer, List<Integer>> buildGraph(int[][] edges, int n) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            graph.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge:edges) {\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838529,
                "title": "java-solution-dfs-time-complexity-o-m-n",
                "content": "n = Number of Elements in Tree.\\nm = Number of Trips\\nTime Complexity O(m*n);\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashSet<Integer> [] adList = getAdList(n, edges);\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int totalSum = getTotalSum(adList, price, trips, count);\\n        int [] res = getReduction(0, adList, price, count, -1);\\n        return totalSum - Math.max(res[0], res[1]);\\n    }\\n    \\n    private static HashSet<Integer> [] getAdList(int n, int [][] edges){\\n        HashSet<Integer> [] adList = new HashSet [n];\\n        for(int i =0; i<adList.length; i++)\\n            adList[i] = new HashSet();\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            adList[s].add(d);\\n            adList[d].add(s);\\n        }\\n        return adList;\\n    }\\n    \\n    private static int getTotalSum(HashSet<Integer> [] adList, int []price, int [][] trips, HashMap<Integer, Integer> count){\\n        int sum = 0;\\n        for(int []trip : trips){\\n            sum += dfs(adList, price, trip[0], trip[1], count, -1);\\n        }\\n        return sum;\\n    }\\n    \\n    private static int dfs(HashSet<Integer> [] adList, int []price, int s, int d, HashMap<Integer, Integer> count, int prev){\\n        if(s == d){\\n            count.put(s, count.getOrDefault(s, 0)+1);\\n            return price[s];\\n        }\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int currPrice = dfs(adList, price, child, d, count, s);\\n            if(currPrice > 0){\\n                count.put(s, count.getOrDefault(s, 0)+1);\\n                return price[s] + currPrice;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private static int [] getReduction(int s, HashSet<Integer> [] adList, int []price, HashMap<Integer, Integer> count, int prev){\\n        int with = ((price[s]*count.getOrDefault(s, 0)) >> 1);\\n        int without = 0;\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int [] curr = getReduction(child, adList, price, count, s);\\n            with += curr[1];\\n            without += Math.max(curr[0], curr[1]);\\n        }\\n        return new int []{with, without};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        HashSet<Integer> [] adList = getAdList(n, edges);\\n        HashMap<Integer, Integer> count = new HashMap();\\n        int totalSum = getTotalSum(adList, price, trips, count);\\n        int [] res = getReduction(0, adList, price, count, -1);\\n        return totalSum - Math.max(res[0], res[1]);\\n    }\\n    \\n    private static HashSet<Integer> [] getAdList(int n, int [][] edges){\\n        HashSet<Integer> [] adList = new HashSet [n];\\n        for(int i =0; i<adList.length; i++)\\n            adList[i] = new HashSet();\\n        for(int [] edge : edges){\\n            int s = edge[0];\\n            int d = edge[1];\\n            adList[s].add(d);\\n            adList[d].add(s);\\n        }\\n        return adList;\\n    }\\n    \\n    private static int getTotalSum(HashSet<Integer> [] adList, int []price, int [][] trips, HashMap<Integer, Integer> count){\\n        int sum = 0;\\n        for(int []trip : trips){\\n            sum += dfs(adList, price, trip[0], trip[1], count, -1);\\n        }\\n        return sum;\\n    }\\n    \\n    private static int dfs(HashSet<Integer> [] adList, int []price, int s, int d, HashMap<Integer, Integer> count, int prev){\\n        if(s == d){\\n            count.put(s, count.getOrDefault(s, 0)+1);\\n            return price[s];\\n        }\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int currPrice = dfs(adList, price, child, d, count, s);\\n            if(currPrice > 0){\\n                count.put(s, count.getOrDefault(s, 0)+1);\\n                return price[s] + currPrice;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private static int [] getReduction(int s, HashSet<Integer> [] adList, int []price, HashMap<Integer, Integer> count, int prev){\\n        int with = ((price[s]*count.getOrDefault(s, 0)) >> 1);\\n        int without = 0;\\n        for(int child : adList[s]){\\n            if(child == prev)\\n                continue;\\n            int [] curr = getReduction(child, adList, price, count, s);\\n            with += curr[1];\\n            without += Math.max(curr[0], curr[1]);\\n        }\\n        return new int []{with, without};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819172,
                "title": "path-finding-house-robber-lll",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate an array cost that has total price of each node for all trips.\\nThen we have to minimise sum of this cost array by reducing some costs to half.It is same as dp leetcode problem House Robber 3.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int s,int e,vector<vector<int>>&adj,int parent,vector<int>&cost,vector<int>& price){\\n        if(s==e){\\n            cost[s]+=price[s];\\n            return true;\\n        }\\n        for(auto neigh:adj[s]){\\n            if(neigh!=parent){\\n                if(dfs(neigh,e,adj,s,cost,price)){\\n                    cost[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimiseCost(vector<int>&cost,vector<vector<int>>&adj,int parent,bool canhalf,int start,vector<vector<int>>&dp){\\n        if(dp[canhalf][start]!=-1){\\n            return dp[canhalf][start];\\n        }\\n        int c = cost[start];\\n        int withoutHalf = c,half = c/2;\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            withoutHalf += minimiseCost(cost,adj,start,true,neigh,dp);\\n        }\\n        if(!canhalf){\\n            dp[canhalf][start] = withoutHalf;\\n            return dp[canhalf][start];\\n        }\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            half += minimiseCost(cost,adj,start,false,neigh,dp);\\n            \\n        }\\n        dp[canhalf][start] = min(half,withoutHalf);\\n        return dp[canhalf][start];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>adj(n);\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int>cost(n,0);\\n        for(auto trip:trips){\\n            int s = trip[0];\\n            int e = trip[1];\\n            // vector<bool>visited(n,false);no need of visited as trees have no cycle\\n            dfs(s,e,adj,-1,cost,price);\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n,-1));\\n        return minimiseCost(cost,adj,-1,true,0,dp);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int s,int e,vector<vector<int>>&adj,int parent,vector<int>&cost,vector<int>& price){\\n        if(s==e){\\n            cost[s]+=price[s];\\n            return true;\\n        }\\n        for(auto neigh:adj[s]){\\n            if(neigh!=parent){\\n                if(dfs(neigh,e,adj,s,cost,price)){\\n                    cost[s]+=price[s];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int minimiseCost(vector<int>&cost,vector<vector<int>>&adj,int parent,bool canhalf,int start,vector<vector<int>>&dp){\\n        if(dp[canhalf][start]!=-1){\\n            return dp[canhalf][start];\\n        }\\n        int c = cost[start];\\n        int withoutHalf = c,half = c/2;\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            withoutHalf += minimiseCost(cost,adj,start,true,neigh,dp);\\n        }\\n        if(!canhalf){\\n            dp[canhalf][start] = withoutHalf;\\n            return dp[canhalf][start];\\n        }\\n        for(auto neigh:adj[start]){\\n            if(neigh==parent){\\n                continue;\\n            }\\n            half += minimiseCost(cost,adj,start,false,neigh,dp);\\n            \\n        }\\n        dp[canhalf][start] = min(half,withoutHalf);\\n        return dp[canhalf][start];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>adj(n);\\n        for(auto edge:edges){\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        vector<int>cost(n,0);\\n        for(auto trip:trips){\\n            int s = trip[0];\\n            int e = trip[1];\\n            // vector<bool>visited(n,false);no need of visited as trees have no cycle\\n            dfs(s,e,adj,-1,cost,price);\\n        }\\n        vector<vector<int>>dp(2,vector<int>(n,-1));\\n        return minimiseCost(cost,adj,-1,true,0,dp);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795552,
                "title": "simple-than-ever-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void help(int s,int d,vector<int>&freq,vector<int>adj[],vector<int>&vis){\\n        vis[s]=1;\\n        if(s==d){\\n            for(int i=0;i<vis.size();i++)   if(vis[i])  freq[i]++;\\n        }\\n        for(auto neg:adj[s]){\\n            if(vis[neg]==0) help(neg,d,freq,adj,vis);\\n        }\\n        vis[s]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto t:edges){\\n            adj[t[0]].push_back(t[1]);\\n            adj[t[1]].push_back(t[0]);\\n        }\\n        vector<int> freq(n,0);\\n        for(auto t:trips){\\n            vector<int> vis(n,0);\\n            help(t[0],t[1],freq,adj,vis);\\n            \\n        }\\n        dp.resize(n,vector<int>(2,-1));\\n        return help(0,-1,1,freq,price,adj);\\n    }\\n    vector<vector<int>> dp;\\n    int help(int i,int parent,int half,vector<int>&freq,vector<int>&price,vector<int>adj[]){\\n        if(dp[i][half]!=-1)   return dp[i][half];\\n\\n        int nothalfed=0,halfed=0;\\n        //dont half\\n        for(auto neg:adj[i]){\\n            if(neg==parent) continue;\\n            nothalfed+=help(neg,i,false,freq,price,adj);\\n        }\\n        nothalfed+=price[i]*freq[i];\\n\\n        //half only if previous is not half or first \\n        if(half==0 || parent==-1){\\n            for(auto neg:adj[i]){\\n                if(neg==parent) continue;\\n                halfed+=help(neg,i,true,freq,price,adj);\\n            }\\n            halfed+=(price[i]*freq[i])/2;\\n        }\\n        else halfed=1e9;   //no choice to half\\n\\n        return dp[i][half]=min(nothalfed,halfed);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(int s,int d,vector<int>&freq,vector<int>adj[],vector<int>&vis){\\n        vis[s]=1;\\n        if(s==d){\\n            for(int i=0;i<vis.size();i++)   if(vis[i])  freq[i]++;\\n        }\\n        for(auto neg:adj[s]){\\n            if(vis[neg]==0) help(neg,d,freq,adj,vis);\\n        }\\n        vis[s]=0;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> adj[n];\\n        for(auto t:edges){\\n            adj[t[0]].push_back(t[1]);\\n            adj[t[1]].push_back(t[0]);\\n        }\\n        vector<int> freq(n,0);\\n        for(auto t:trips){\\n            vector<int> vis(n,0);\\n            help(t[0],t[1],freq,adj,vis);\\n            \\n        }\\n        dp.resize(n,vector<int>(2,-1));\\n        return help(0,-1,1,freq,price,adj);\\n    }\\n    vector<vector<int>> dp;\\n    int help(int i,int parent,int half,vector<int>&freq,vector<int>&price,vector<int>adj[]){\\n        if(dp[i][half]!=-1)   return dp[i][half];\\n\\n        int nothalfed=0,halfed=0;\\n        //dont half\\n        for(auto neg:adj[i]){\\n            if(neg==parent) continue;\\n            nothalfed+=help(neg,i,false,freq,price,adj);\\n        }\\n        nothalfed+=price[i]*freq[i];\\n\\n        //half only if previous is not half or first \\n        if(half==0 || parent==-1){\\n            for(auto neg:adj[i]){\\n                if(neg==parent) continue;\\n                halfed+=help(neg,i,true,freq,price,adj);\\n            }\\n            halfed+=(price[i]*freq[i])/2;\\n        }\\n        else halfed=1e9;   //no choice to half\\n\\n        return dp[i][half]=min(nothalfed,halfed);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755965,
                "title": "c-dp-on-tree-intuitive-step-wise-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    vector<int> freq;\\n    vector<vector<int>> t;\\n\\n    bool applyDFS(vector<int> *gr, int cur, int parent, int dest) {\\n        if(cur == dest) {\\n            return true;\\n        }\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                freq[nbr]++;\\n                if(applyDFS(gr, nbr, cur, dest)) {\\n                    return true;\\n                }\\n                freq[nbr]--;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int findMin(int cur, vector<int> *gr, bool parentDone, int parent, vector<int> &price) {\\n        if(t[cur][parentDone] != -1) {\\n            return t[cur][parentDone];\\n        }\\n\\n        int res = INT_MAX;\\n        if(!parentDone) {\\n            res = freq[cur] * price[cur] / 2;\\n            for(int &nbr: gr[cur]) {\\n                if(nbr != parent) {\\n                    res += findMin(nbr, gr, true, cur, price);\\n                }\\n            }\\n        }\\n        int res2 = freq[cur] * price[cur];\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                res2 += findMin(nbr, gr, false, cur, price);\\n            }\\n        }\\n        return t[cur][parentDone] = min(res, res2);\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        if(n==1) {\\n            return trips.size() * price[0] / 2;\\n        }\\n        vector<int> gr[n];\\n        freq.resize(n, 0);\\n\\n        for(auto &edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n\\n        for(auto &trip: trips) {\\n            freq[trip[0]]++;\\n            applyDFS(gr, trip[0], -1, trip[1]);      \\n        }\\n\\n        t.resize(n, vector<int>(2, -1));\\n        return findMin(1, gr, false, -1, price);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> freq;\\n    vector<vector<int>> t;\\n\\n    bool applyDFS(vector<int> *gr, int cur, int parent, int dest) {\\n        if(cur == dest) {\\n            return true;\\n        }\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                freq[nbr]++;\\n                if(applyDFS(gr, nbr, cur, dest)) {\\n                    return true;\\n                }\\n                freq[nbr]--;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int findMin(int cur, vector<int> *gr, bool parentDone, int parent, vector<int> &price) {\\n        if(t[cur][parentDone] != -1) {\\n            return t[cur][parentDone];\\n        }\\n\\n        int res = INT_MAX;\\n        if(!parentDone) {\\n            res = freq[cur] * price[cur] / 2;\\n            for(int &nbr: gr[cur]) {\\n                if(nbr != parent) {\\n                    res += findMin(nbr, gr, true, cur, price);\\n                }\\n            }\\n        }\\n        int res2 = freq[cur] * price[cur];\\n        for(int &nbr: gr[cur]) {\\n            if(nbr != parent) {\\n                res2 += findMin(nbr, gr, false, cur, price);\\n            }\\n        }\\n        return t[cur][parentDone] = min(res, res2);\\n    }\\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        if(n==1) {\\n            return trips.size() * price[0] / 2;\\n        }\\n        vector<int> gr[n];\\n        freq.resize(n, 0);\\n\\n        for(auto &edge: edges) {\\n            gr[edge[0]].push_back(edge[1]);\\n            gr[edge[1]].push_back(edge[0]);\\n        }\\n\\n        for(auto &trip: trips) {\\n            freq[trip[0]]++;\\n            applyDFS(gr, trip[0], -1, trip[1]);      \\n        }\\n\\n        t.resize(n, vector<int>(2, -1));\\n        return findMin(1, gr, false, -1, price);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719313,
                "title": "when-your-code-works-but-you-have-no-idea-how",
                "content": "\\n![ac8134df5d4372a6d13f3686cdde9115e5497e4c7da9ecd5995dcad1646b5c39_1.jpg](https://assets.leetcode.com/users/images/3e351881-9320-498c-acd4-2207dd4ccc77_1688506228.8726444.jpeg)\\n\\n\\n# Approach\\n```\\nprepare an adjacent list, adj\\nfnd the nodes you need to cross for all the trips, theset\\nincrease the price according to how often you cross it, new_price\\ngo check out house robber question, you need to find the maximum sum you can achieve;non-adjacent, maxsum\\nyou need to find maxsum of the nodes which are together\\nthen return sum(new_price)-thesum//2\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n\\n        adj=[[] for i in range(n)]\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n\\n        alist=[]\\n        def dfs(i,j,s):\\n            s.add(i)\\n            if i==j:\\n                alist.append(s.copy())\\n                return \\n            for a in adj[i]:\\n                if a not in s:\\n                    dfs(a,j,s)\\n            s.remove(i)\\n            return \\n        for t in trips:\\n            dfs(t[0],t[1],set())\\n\\n        new_price=[0]*n\\n        theset=set()\\n        for s in alist:\\n            for el in s:\\n                new_price[el]+=price[el]\\n                theset.add(el)\\n        price=new_price\\n\\n        @cache\\n        def maxsum(i,p):\\n            ans1=0\\n            ans2=0\\n            for x in adj[i]:\\n                if x!=i and x!=p and x in theset:\\n                    ans1+=maxsum(x,i)\\n                    for y in adj[x]:\\n                        if y!=i and y!=x and y in theset:\\n                            ans2+=maxsum(y,x)\\n            return max(ans1,ans2+price[i])\\n        \\n        def findthefam(i,s):\\n            s.add(i)\\n            for x in adj[i]:\\n                if x in theset and x not in s:\\n                    findthefam(x,s)\\n            return\\n\\n        thesum=0\\n        while theset:\\n            for z in theset:\\n                zero=z\\n                break\\n            thesum+=maxsum(z,z)\\n            s=set()\\n            findthefam(z,s)\\n            theset=theset-s\\n        \\n        return sum(new_price)-thesum//2\\n\\n        #MADARCHOD\\n\\n            #IT WORKED\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nprepare an adjacent list, adj\\nfnd the nodes you need to cross for all the trips, theset\\nincrease the price according to how often you cross it, new_price\\ngo check out house robber question, you need to find the maximum sum you can achieve;non-adjacent, maxsum\\nyou need to find maxsum of the nodes which are together\\nthen return sum(new_price)-thesum//2\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n\\n        adj=[[] for i in range(n)]\\n        for edge in edges:\\n            adj[edge[0]].append(edge[1])\\n            adj[edge[1]].append(edge[0])\\n\\n        alist=[]\\n        def dfs(i,j,s):\\n            s.add(i)\\n            if i==j:\\n                alist.append(s.copy())\\n                return \\n            for a in adj[i]:\\n                if a not in s:\\n                    dfs(a,j,s)\\n            s.remove(i)\\n            return \\n        for t in trips:\\n            dfs(t[0],t[1],set())\\n\\n        new_price=[0]*n\\n        theset=set()\\n        for s in alist:\\n            for el in s:\\n                new_price[el]+=price[el]\\n                theset.add(el)\\n        price=new_price\\n\\n        @cache\\n        def maxsum(i,p):\\n            ans1=0\\n            ans2=0\\n            for x in adj[i]:\\n                if x!=i and x!=p and x in theset:\\n                    ans1+=maxsum(x,i)\\n                    for y in adj[x]:\\n                        if y!=i and y!=x and y in theset:\\n                            ans2+=maxsum(y,x)\\n            return max(ans1,ans2+price[i])\\n        \\n        def findthefam(i,s):\\n            s.add(i)\\n            for x in adj[i]:\\n                if x in theset and x not in s:\\n                    findthefam(x,s)\\n            return\\n\\n        thesum=0\\n        while theset:\\n            for z in theset:\\n                zero=z\\n                break\\n            thesum+=maxsum(z,z)\\n            s=set()\\n            findthefam(z,s)\\n            theset=theset-s\\n        \\n        return sum(new_price)-thesum//2\\n\\n        #MADARCHOD\\n\\n            #IT WORKED\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628361,
                "title": "simple-c-solution-dynamic-programming-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int index,vector<int>sides[],vector<int>&curr,int p,int &end,int &flag){\\n    if(index==end){\\n        curr.push_back(index);\\n        flag=1;\\n        return;\\n    }\\n    curr.push_back(index);\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            dfs(sides[index][i],sides,curr,index,end,flag);\\n            if(flag==1){\\n                break;\\n            }\\n                curr.pop_back();\\n            \\n        }\\n    }\\n    if(flag==1)return;\\n}\\nvoid hope(int index,vector<int>&price,vector<vector<int>>&dp,vector<int>sides[],int p,vector<int>&freq){\\n    dp[index][0]=freq[index]*price[index];\\n    dp[index][1]=freq[index]*price[index]/2;\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            hope(sides[index][i],price,dp,sides,index,freq);\\n        dp[index][0]=dp[index][0]+min(dp[sides[index][i]][0],dp[sides[index][i]][1]);\\n        dp[index][1]=dp[index][1]+dp[sides[index][i]][0];\\n        }\\n    }\\n}\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>sides[n];\\n          vector<vector<int>>dp(n,vector<int>(2,0));\\n                  vector<int>freq(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            vector<int>curr;\\n            int flag=0;\\n            dfs(trips[i][0],sides,curr,-1,trips[i][1],flag);\\n            for(int i=0;i<curr.size();i++){\\n                freq[curr[i]]=freq[curr[i]]+1;\\n            }\\n        }\\n        hope(0,price,dp,sides,-1,freq);\\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n/*\\n\\n*/\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int index,vector<int>sides[],vector<int>&curr,int p,int &end,int &flag){\\n    if(index==end){\\n        curr.push_back(index);\\n        flag=1;\\n        return;\\n    }\\n    curr.push_back(index);\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            dfs(sides[index][i],sides,curr,index,end,flag);\\n            if(flag==1){\\n                break;\\n            }\\n                curr.pop_back();\\n            \\n        }\\n    }\\n    if(flag==1)return;\\n}\\nvoid hope(int index,vector<int>&price,vector<vector<int>>&dp,vector<int>sides[],int p,vector<int>&freq){\\n    dp[index][0]=freq[index]*price[index];\\n    dp[index][1]=freq[index]*price[index]/2;\\n    for(int i=0;i<sides[index].size();i++){\\n        if(sides[index][i]!=p){\\n            hope(sides[index][i],price,dp,sides,index,freq);\\n        dp[index][0]=dp[index][0]+min(dp[sides[index][i]][0],dp[sides[index][i]][1]);\\n        dp[index][1]=dp[index][1]+dp[sides[index][i]][0];\\n        }\\n    }\\n}\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>sides[n];\\n          vector<vector<int>>dp(n,vector<int>(2,0));\\n                  vector<int>freq(n,0);\\n        for(int i=0;i<edges.size();i++){\\n            sides[edges[i][0]].push_back(edges[i][1]);\\n            sides[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        for(int i=0;i<trips.size();i++){\\n            vector<int>curr;\\n            int flag=0;\\n            dfs(trips[i][0],sides,curr,-1,trips[i][1],flag);\\n            for(int i=0;i<curr.size();i++){\\n                freq[curr[i]]=freq[curr[i]]+1;\\n            }\\n        }\\n        hope(0,price,dp,sides,-1,freq);\\n        return min(dp[0][0],dp[0][1]);\\n    }\\n};\\n/*\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628122,
                "title": "c-dp-memoization-frequency-array-with-explanation",
                "content": "# Intuition\\nThe answer without half will be the number of times each node is present in all the trips multiplied by the price of node.\\n\\nWe can use DP to find the maximum value that needs to be subtracted from initial answer.\\n\\nPlease UPVOTE if you liked the solution :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(auto& it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        // DFS to find the frequenct of each node in trips\\n        for(auto& it : trips){\\n            vector<int> nodes;\\n            nodes.push_back(it[0]);\\n            dfs(adj, freq, it[0], it[1], -1, nodes);\\n            nodes.pop_back();\\n        }\\n\\n        // The initial answer\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum += (freq[i]*price[i]);\\n        }\\n\\n        //Use DP to choose half and notHalf\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return sum-max(solve(adj, dp, 0, 0, price, freq, -1), solve(adj, dp, 0, 1, price, freq, -1));\\n    }\\n\\n    int solve(vector<vector<int>>& adj, vector<vector<int>>& dp, int node, int prev, vector<int>& price, vector<int>& freq, int parent){\\n        if(dp[node][prev] != -1)    return dp[node][prev];\\n\\n        // If previous node was halved, so this node cannot be halved\\n        int half = prev == 0 ? price[node]*freq[node]/2 : 0, notHalf=0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                if(prev == 0)\\n                    half += solve(adj, dp, it, 1, price, freq, node);\\n                notHalf += solve(adj, dp, it, 0, price, freq, node);\\n            }\\n        }\\n\\n        return dp[node][prev] = max(half, notHalf);\\n    }\\n\\n    void dfs(vector<vector<int>>& adj, vector<int>& freq, int src, int dst, int par, vector<int>& nodes){\\n        if(src == dst){\\n            for(auto it : nodes)    freq[it]++;\\n            return;\\n        }\\n\\n        for(auto it : adj[src]){\\n            if(it != par){\\n                nodes.push_back(it);\\n                dfs(adj, freq, it, dst, src, nodes);\\n                nodes.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> freq(n, 0);\\n        vector<vector<int>> adj(n);\\n        for(auto& it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n\\n        // DFS to find the frequenct of each node in trips\\n        for(auto& it : trips){\\n            vector<int> nodes;\\n            nodes.push_back(it[0]);\\n            dfs(adj, freq, it[0], it[1], -1, nodes);\\n            nodes.pop_back();\\n        }\\n\\n        // The initial answer\\n        int sum = 0;\\n        for(int i = 0 ; i < n ; i++){\\n            sum += (freq[i]*price[i]);\\n        }\\n\\n        //Use DP to choose half and notHalf\\n        vector<vector<int>> dp(n, vector<int>(2, -1));\\n        return sum-max(solve(adj, dp, 0, 0, price, freq, -1), solve(adj, dp, 0, 1, price, freq, -1));\\n    }\\n\\n    int solve(vector<vector<int>>& adj, vector<vector<int>>& dp, int node, int prev, vector<int>& price, vector<int>& freq, int parent){\\n        if(dp[node][prev] != -1)    return dp[node][prev];\\n\\n        // If previous node was halved, so this node cannot be halved\\n        int half = prev == 0 ? price[node]*freq[node]/2 : 0, notHalf=0;\\n        for(auto it : adj[node]){\\n            if(it != parent){\\n                if(prev == 0)\\n                    half += solve(adj, dp, it, 1, price, freq, node);\\n                notHalf += solve(adj, dp, it, 0, price, freq, node);\\n            }\\n        }\\n\\n        return dp[node][prev] = max(half, notHalf);\\n    }\\n\\n    void dfs(vector<vector<int>>& adj, vector<int>& freq, int src, int dst, int par, vector<int>& nodes){\\n        if(src == dst){\\n            for(auto it : nodes)    freq[it]++;\\n            return;\\n        }\\n\\n        for(auto it : adj[src]){\\n            if(it != par){\\n                nodes.push_back(it);\\n                dfs(adj, freq, it, dst, src, nodes);\\n                nodes.pop_back();\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616330,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>next(n) ;\\n        vector<int>plan0(n, -1) ;\\n        vector<int>plan1(n, -1) ;\\n        vector<int>count(n) ;\\n        vector<int>val(n) ;\\n        for(auto& e : edges){\\n            int u = e[0], v = e[1] ;\\n            next[u].push_back(v) ;\\n            next[v].push_back(u) ;\\n        }\\n        for(auto& trip : trips)\\n            dfs(trip[0], -1, trip[1], count, next) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            val[i] = price[i] * count[i] ;\\n        \\n        return DFS(0, -1, 1, plan0, plan1, val, next) ;\\n        \\n    }\\n    bool dfs(int cur, int parent, int target, vector<int>&count, vector<vector<int>>&next){\\n        if(cur == target){\\n            count[cur]++ ;\\n            return true;\\n        }\\n        for(auto& x : next[cur]){\\n            if(x == parent) continue ;\\n            if(dfs(x, cur, target, count, next)){\\n                count[cur]++ ;\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n    //flag : 1 can choose ; 0 can\\'t choose\\n    int DFS(int cur, int parent, int flag, vector<int>&plan0, vector<int>&plan1, vector<int>&val, vector<vector<int>>&next){\\n        if(flag == 0 && plan0[cur] != -1) return plan0[cur] ;  \\n        if(flag == 1 && plan1[cur] != -1) return plan1[cur] ;  \\n        \\n        if(flag == 0){\\n            int ret = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                ret += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }  \\n            plan0[cur] = ret ;\\n            return ret ;\\n        }\\n        else{\\n            int option1 = val[cur] / 2 ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option1 += DFS(x, cur, 0, plan0, plan1, val, next) ;\\n            }\\n            int option2 = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option2 += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }\\n            plan1[cur] = min(option1, option2) ;\\n            return plan1[cur] ;    \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>>next(n) ;\\n        vector<int>plan0(n, -1) ;\\n        vector<int>plan1(n, -1) ;\\n        vector<int>count(n) ;\\n        vector<int>val(n) ;\\n        for(auto& e : edges){\\n            int u = e[0], v = e[1] ;\\n            next[u].push_back(v) ;\\n            next[v].push_back(u) ;\\n        }\\n        for(auto& trip : trips)\\n            dfs(trip[0], -1, trip[1], count, next) ;\\n        \\n        for(int i = 0; i < n; i++)\\n            val[i] = price[i] * count[i] ;\\n        \\n        return DFS(0, -1, 1, plan0, plan1, val, next) ;\\n        \\n    }\\n    bool dfs(int cur, int parent, int target, vector<int>&count, vector<vector<int>>&next){\\n        if(cur == target){\\n            count[cur]++ ;\\n            return true;\\n        }\\n        for(auto& x : next[cur]){\\n            if(x == parent) continue ;\\n            if(dfs(x, cur, target, count, next)){\\n                count[cur]++ ;\\n                return true ;\\n            }\\n        }\\n        return false ;\\n    }\\n    //flag : 1 can choose ; 0 can\\'t choose\\n    int DFS(int cur, int parent, int flag, vector<int>&plan0, vector<int>&plan1, vector<int>&val, vector<vector<int>>&next){\\n        if(flag == 0 && plan0[cur] != -1) return plan0[cur] ;  \\n        if(flag == 1 && plan1[cur] != -1) return plan1[cur] ;  \\n        \\n        if(flag == 0){\\n            int ret = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                ret += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }  \\n            plan0[cur] = ret ;\\n            return ret ;\\n        }\\n        else{\\n            int option1 = val[cur] / 2 ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option1 += DFS(x, cur, 0, plan0, plan1, val, next) ;\\n            }\\n            int option2 = val[cur] ;\\n            for(auto x : next[cur]){\\n                if(x == parent) continue ;\\n                option2 += DFS(x, cur, 1, plan0, plan1, val, next) ;\\n            }\\n            plan1[cur] = min(option1, option2) ;\\n            return plan1[cur] ;    \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580010,
                "title": "java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount how many times each node is visited. Then use the same concept as we have used in House Robber III based on DP.\\n\\n\\n# Code\\n```\\n//RITIK PATEL\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        int [] counts= new int[n];\\n        List<List<Integer>> Adj = new ArrayList();\\n        for(int i=0; i<n; i++) Adj.add(new ArrayList());\\n        for(int edge[]:edges){\\n            Adj.get(edge[0]).add(edge[1]);\\n            Adj.get(edge[1]).add(edge[0]);\\n        }\\n        for(int trip[]: trips){\\n            boolean vis[] = new boolean[n];\\n            DFSTraverse(trip[0], trip[1], counts, Adj, vis);\\n        }\\n        // for(int count: counts){\\n        //     System.out.print(count+\" \");\\n        // }\\n        int DP[] = new int[n];\\n        for(int i=0; i<DP.length; i++){\\n            DP[i] = -1;\\n        }\\n        boolean pathvis[] = new boolean[n];\\n        return DPDFS(n-1,DP,Adj,pathvis,price, counts);\\n    }\\n    boolean DFSTraverse(int start ,int tgt, int[] counts, List<List<Integer>> Adj, boolean vis[]){\\n        if(vis[start]) return false;\\n        vis[start] = true;\\n        if(start==tgt){\\n            counts[start]++;\\n            return true;\\n        }\\n        boolean ans = false;\\n        for(int adjacent: Adj.get(start)){\\n            ans = ans | DFSTraverse(adjacent, tgt, counts, Adj, vis);\\n        }\\n        if(ans){\\n            counts[start]++;\\n        }\\n        return ans;\\n    }\\n    int DPDFS(int node, int[] DP, List<List<Integer>> Adj, boolean pathvis[], int[] prices, int [] counts){\\n        if(pathvis[node]) return 0;\\n        // System.out.print(node+\" \");\\n        if(DP[node]!=-1) return DP[node];\\n        \\n        //child of child calculate\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int childval = 0;\\n        pathvis[node] = true;\\n        for(int child1: Adj.get(node)){\\n            if(pathvis[child1]) continue;\\n            pathvis[child1] = true;\\n            for(int child2: Adj.get(child1)){\\n                int val = DPDFS(child2, DP, Adj, pathvis,prices, counts);\\n                ans2 += val;\\n            }\\n            pathvis[child1] = false;\\n            childval+= counts[child1]*prices[child1];\\n            ans1 += DPDFS(child1, DP, Adj, pathvis,prices, counts);\\n        }\\n        int Ans = Math.min(ans2+childval+(prices[node]*counts[node])/2, ans1+prices[node]*counts[node]);\\n        pathvis[node] = false;\\n        // System.out.println(node+\"--->\"+Ans);\\n        return DP[node] = Ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n//RITIK PATEL\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        int [] counts= new int[n];\\n        List<List<Integer>> Adj = new ArrayList();\\n        for(int i=0; i<n; i++) Adj.add(new ArrayList());\\n        for(int edge[]:edges){\\n            Adj.get(edge[0]).add(edge[1]);\\n            Adj.get(edge[1]).add(edge[0]);\\n        }\\n        for(int trip[]: trips){\\n            boolean vis[] = new boolean[n];\\n            DFSTraverse(trip[0], trip[1], counts, Adj, vis);\\n        }\\n        // for(int count: counts){\\n        //     System.out.print(count+\" \");\\n        // }\\n        int DP[] = new int[n];\\n        for(int i=0; i<DP.length; i++){\\n            DP[i] = -1;\\n        }\\n        boolean pathvis[] = new boolean[n];\\n        return DPDFS(n-1,DP,Adj,pathvis,price, counts);\\n    }\\n    boolean DFSTraverse(int start ,int tgt, int[] counts, List<List<Integer>> Adj, boolean vis[]){\\n        if(vis[start]) return false;\\n        vis[start] = true;\\n        if(start==tgt){\\n            counts[start]++;\\n            return true;\\n        }\\n        boolean ans = false;\\n        for(int adjacent: Adj.get(start)){\\n            ans = ans | DFSTraverse(adjacent, tgt, counts, Adj, vis);\\n        }\\n        if(ans){\\n            counts[start]++;\\n        }\\n        return ans;\\n    }\\n    int DPDFS(int node, int[] DP, List<List<Integer>> Adj, boolean pathvis[], int[] prices, int [] counts){\\n        if(pathvis[node]) return 0;\\n        // System.out.print(node+\" \");\\n        if(DP[node]!=-1) return DP[node];\\n        \\n        //child of child calculate\\n        int ans1 = 0;\\n        int ans2 = 0;\\n        int childval = 0;\\n        pathvis[node] = true;\\n        for(int child1: Adj.get(node)){\\n            if(pathvis[child1]) continue;\\n            pathvis[child1] = true;\\n            for(int child2: Adj.get(child1)){\\n                int val = DPDFS(child2, DP, Adj, pathvis,prices, counts);\\n                ans2 += val;\\n            }\\n            pathvis[child1] = false;\\n            childval+= counts[child1]*prices[child1];\\n            ans1 += DPDFS(child1, DP, Adj, pathvis,prices, counts);\\n        }\\n        int Ans = Math.min(ans2+childval+(prices[node]*counts[node])/2, ans1+prices[node]*counts[node]);\\n        pathvis[node] = false;\\n        // System.out.println(node+\"--->\"+Ans);\\n        return DP[node] = Ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576639,
                "title": "c-dfs-dp-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2]; \\n\\n    void calc(int node, int end, int parent, vector<int>& path, vector<int>& contri, vector<vector<int>>& graph){\\n        path.push_back(node);\\n\\n        if(end == node){ \\n            for(auto& i : path){\\n                contri[i]++; \\n            }\\n            path.pop_back();\\n            return;\\n        }\\n\\n        for(auto& child : graph[node]){ \\n            if(child != parent) {\\n                calc(child, end, node, path, contri, graph);   \\n            }\\n        }   \\n\\n        path.pop_back();\\n    }\\n\\n    int dfs(int node, int parent, bool parentHalved, vector<int>& contri, vector<int>& price, vector<vector<int>>& graph){\\n        if(dp[node][parentHalved] != -1)  return dp[node][parentHalved];\\n\\n        int res1 = contri[node] * (price[node] / 2);\\n        int res2 = contri[node] * price[node];\\n        \\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res2 += dfs(child, node, false, contri, price, graph);\\n        }\\n        if(parentHalved) return dp[node][parentHalved] = res2;\\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res1 += dfs(child, node, true, contri, price, graph);\\n        }\\n\\n        return dp[node][parentHalved] = min(res1, res2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof dp);\\n\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> contri(n, 0);\\n        for(auto& t : trips){\\n            vector<int> path;\\n            calc(t[0], t[1], -1, path, contri, graph);\\n        }\\n        \\n        return dfs(0, -1, false, contri, price, graph);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2]; \\n\\n    void calc(int node, int end, int parent, vector<int>& path, vector<int>& contri, vector<vector<int>>& graph){\\n        path.push_back(node);\\n\\n        if(end == node){ \\n            for(auto& i : path){\\n                contri[i]++; \\n            }\\n            path.pop_back();\\n            return;\\n        }\\n\\n        for(auto& child : graph[node]){ \\n            if(child != parent) {\\n                calc(child, end, node, path, contri, graph);   \\n            }\\n        }   \\n\\n        path.pop_back();\\n    }\\n\\n    int dfs(int node, int parent, bool parentHalved, vector<int>& contri, vector<int>& price, vector<vector<int>>& graph){\\n        if(dp[node][parentHalved] != -1)  return dp[node][parentHalved];\\n\\n        int res1 = contri[node] * (price[node] / 2);\\n        int res2 = contri[node] * price[node];\\n        \\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res2 += dfs(child, node, false, contri, price, graph);\\n        }\\n        if(parentHalved) return dp[node][parentHalved] = res2;\\n        \\n        for(auto& child : graph[node]){\\n            if(child != parent)   res1 += dfs(child, node, true, contri, price, graph);\\n        }\\n\\n        return dp[node][parentHalved] = min(res1, res2);\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof dp);\\n\\n        vector<vector<int>> graph(n);\\n        for(auto& e:edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> contri(n, 0);\\n        for(auto& t : trips){\\n            vector<int> path;\\n            calc(t[0], t[1], -1, path, contri, graph);\\n        }\\n        \\n        return dfs(0, -1, false, contri, price, graph);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3556526,
                "title": "concise-solution-with-dfs-memoization-in-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy aggregating all trips, the final priceof node `v` can be determined by `price[v] * weight[v]` where `weight[v]` is the times `v` visited in all the trips. So, we can perform the depth first search (or BFS) for every trip and obtain the final price of each node. \\nThe next phase is to determine the color of each node. Dynamic programming is used to find the optimal color assignment. For the tree structure, top-down dynamic programming (memoization) will be much easier to implement, in particular in Python. `@cache` is your friend. \\n\\n# Complexity\\n- Time complexity: $$O(nm)$$ where $n$ is the number of nodes and $m$ is the number of trips. \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        weight = Counter()\\n        \\n        def dfs(s, t, parent=-1):\\n            if s == t: \\n                weight[s] += 1\\n                return True\\n            for v in graph[s]:\\n                if v != parent:\\n                    if dfs(v, t, s):\\n                        weight[s] += 1\\n                        return True\\n            return False\\n\\n        @cache\\n        def dp(v, parent=-1, parent_half=False):\\n            ans = sum(dp(u, v, False) for u in graph[v] if u != parent) + price[v]\\n            if not parent_half:\\n                ans = min(ans, sum(dp(u, v, True) for u in graph[v] if u != parent) + price[v] // 2)\\n            return ans\\n\\n        for s, t in trips:\\n            dfs(s, t)\\n        price = [price[i] * weight[i] for i in range(n)]\\n\\n        return dp(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        weight = Counter()\\n        \\n        def dfs(s, t, parent=-1):\\n            if s == t: \\n                weight[s] += 1\\n                return True\\n            for v in graph[s]:\\n                if v != parent:\\n                    if dfs(v, t, s):\\n                        weight[s] += 1\\n                        return True\\n            return False\\n\\n        @cache\\n        def dp(v, parent=-1, parent_half=False):\\n            ans = sum(dp(u, v, False) for u in graph[v] if u != parent) + price[v]\\n            if not parent_half:\\n                ans = min(ans, sum(dp(u, v, True) for u in graph[v] if u != parent) + price[v] // 2)\\n            return ans\\n\\n        for s, t in trips:\\n            dfs(s, t)\\n        price = [price[i] * weight[i] for i in range(n)]\\n\\n        return dp(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525042,
                "title": "c-soluton-easy-to-understand",
                "content": "# Intuition\\nThis is based on the hints ... first find how many times you need to visit a particular node and then do the DP step to minimize the total price.\\n\\n# Approach\\nPre-step is to build the adjacency table. First step (visiting nodes) is just a normal dfs and keep track of how many times we passed on that node. DP array reprensents the minimal cost if we halve the price at that node or not. We keep track of both numbers. Leaf node is the smallest subproblem we can have so we start by saving 2 costs : if we halve the node or not. Then to solve biggest problems we need to have the minimum cost if we halve the current node or not. If we halve the node the only possibility is to not halve all the children because of the restriction on adjacent nodes. If we don\\'t have the node we have to take the most optimal subproblem wich would be the minimal cost for each children.    \\n\\n# Complexity\\n- Time complexity:\\no(m * n), m is num of trips\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> adjacency(n);\\n        for(int i = 0; i < edges.size(); ++i)\\n        {\\n            adjacency[edges[i][0]].push_back(edges[i][1]);\\n            adjacency[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> res(n);\\n        for(int i = 0; i < trips.size(); ++i)\\n        {\\n            dfs(adjacency, res, trips[i][0], -1, trips[i][1]);\\n        }\\n\\n        vector<pair<int, int>> dp(n);\\n        dfsDp(adjacency, res, price, dp, 0, -1);\\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n\\n    void dfsDp(vector<vector<int>>& adjacency, vector<int>& res, vector<int>& price, vector<pair<int, int>>& dp,  int current, int parent)\\n    {\\n        if(adjacency[current].size() == 1 && adjacency[current][0] == parent)\\n        {\\n            int cost = res[current]  * price[current];\\n            int halfCost = cost / 2; \\n            dp[current] = {halfCost, cost};\\n            return;\\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            dfsDp(adjacency, res, price, dp, child, current);\\n        }\\n\\n        int cost = res[current]  * price[current];\\n        int halfCost = cost / 2;\\n\\n        int priceNotCut = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceNotCut += p.second; \\n        }\\n\\n        halfCost += priceNotCut;\\n        int priceChildrens = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceChildrens += min(p.first, p.second); \\n        }\\n        cost += priceChildrens; \\n        dp[current] = {halfCost, cost};\\n    }\\n\\n    bool dfs(vector<vector<int>>& adjacency, vector<int>& res, int current, int parent, int destination)\\n    {\\n        if(current == destination) \\n        {\\n            ++res[current];\\n            return true; \\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            bool b = dfs(adjacency, res, child, current, destination);\\n            if(b)\\n            {\\n                ++res[current];\\n                return true; \\n            }\\n        }\\n        return false; \\n    }\\n\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> adjacency(n);\\n        for(int i = 0; i < edges.size(); ++i)\\n        {\\n            adjacency[edges[i][0]].push_back(edges[i][1]);\\n            adjacency[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        vector<int> res(n);\\n        for(int i = 0; i < trips.size(); ++i)\\n        {\\n            dfs(adjacency, res, trips[i][0], -1, trips[i][1]);\\n        }\\n\\n        vector<pair<int, int>> dp(n);\\n        dfsDp(adjacency, res, price, dp, 0, -1);\\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n\\n    void dfsDp(vector<vector<int>>& adjacency, vector<int>& res, vector<int>& price, vector<pair<int, int>>& dp,  int current, int parent)\\n    {\\n        if(adjacency[current].size() == 1 && adjacency[current][0] == parent)\\n        {\\n            int cost = res[current]  * price[current];\\n            int halfCost = cost / 2; \\n            dp[current] = {halfCost, cost};\\n            return;\\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            dfsDp(adjacency, res, price, dp, child, current);\\n        }\\n\\n        int cost = res[current]  * price[current];\\n        int halfCost = cost / 2;\\n\\n        int priceNotCut = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceNotCut += p.second; \\n        }\\n\\n        halfCost += priceNotCut;\\n        int priceChildrens = 0;\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            auto p = dp[child];\\n            priceChildrens += min(p.first, p.second); \\n        }\\n        cost += priceChildrens; \\n        dp[current] = {halfCost, cost};\\n    }\\n\\n    bool dfs(vector<vector<int>>& adjacency, vector<int>& res, int current, int parent, int destination)\\n    {\\n        if(current == destination) \\n        {\\n            ++res[current];\\n            return true; \\n        }\\n\\n        for(int child : adjacency[current])\\n        {\\n            if(child == parent) continue; \\n            bool b = dfs(adjacency, res, child, current, destination);\\n            if(b)\\n            {\\n                ++res[current];\\n                return true; \\n            }\\n        }\\n        return false; \\n    }\\n\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3524286,
                "title": "rust-dfs-backtracking-dp-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFinish all trips & get the the tatal counts on the number of visits of each node, using DFS & Backtracking.\\n\\nGet the total price without any adjustment.\\n\\nUsing DP to calculate the saving with adjustment.  \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        // build the graph\\n        let n = price.len();\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        // count the frequency of each node after finishing all trips \\n        let mut count = vec![0; n];\\n        for t in trips {\\n            let (u, v) = (t[0] as usize, t[1] as usize);\\n\\n            let mut visited = vec![0; n];\\n            count[u] += 1; \\n            if (u != v) { Self::backtracking(&graph, &mut count, u, v, &mut visited); }\\n        }\\n\\n        // the total price if no adjustment will be made \\n        let mut ret = 0;\\n        for i in 0 .. n { ret += price[i] * count[i]; }\\n\\n        // dp[u][flag]: the optimal saving with/without adjustment at each node\\n        let mut dp = vec![vec![-1; 2]; n];\\n        for flag in 0 .. 2 { Self::dfs(&graph, &price, &count, 0, n, flag, &mut dp); }\\n\\n        ret - dp[0][0].max(dp[0][1])\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, count: &Vec<i32>, u: usize, parent: usize, flag: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if dp[u][flag] != -1 { return dp[u][flag] }\\n        dp[u][flag] = if flag == 0 { 0 } else { count[u] * price[u] / 2 };\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if v == parent { continue }\\n\\n            Self::dfs(graph, price, count, v, u, 0, dp);\\n            Self::dfs(graph, price, count, v, u, 1, dp);\\n            dp[u][flag] += if flag == 0 { dp[v][0].max(dp[v][1]) } else { dp[v][0] }; \\n        }\\n        dp[u][flag]\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, count: &mut Vec<i32>, u: usize, dest: usize, visited: &mut Vec<i32>) -> bool {\\n        visited[u] = 1;\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if visited[v] == 1 { continue }\\n\\n            count[v] += 1;\\n            if v == dest { return true }\\n            if Self::backtracking(graph, count, v, dest, visited) { return true }\\n            count[v] -= 1;\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        // build the graph\\n        let n = price.len();\\n        let mut graph = vec![vec![]; n];\\n\\n        for e in edges {\\n            let (u, v) = (e[0] as usize, e[1] as usize);\\n            graph[u].push(v);\\n            graph[v].push(u);\\n        }\\n\\n        // count the frequency of each node after finishing all trips \\n        let mut count = vec![0; n];\\n        for t in trips {\\n            let (u, v) = (t[0] as usize, t[1] as usize);\\n\\n            let mut visited = vec![0; n];\\n            count[u] += 1; \\n            if (u != v) { Self::backtracking(&graph, &mut count, u, v, &mut visited); }\\n        }\\n\\n        // the total price if no adjustment will be made \\n        let mut ret = 0;\\n        for i in 0 .. n { ret += price[i] * count[i]; }\\n\\n        // dp[u][flag]: the optimal saving with/without adjustment at each node\\n        let mut dp = vec![vec![-1; 2]; n];\\n        for flag in 0 .. 2 { Self::dfs(&graph, &price, &count, 0, n, flag, &mut dp); }\\n\\n        ret - dp[0][0].max(dp[0][1])\\n    }\\n\\n    fn dfs(graph: &Vec<Vec<usize>>, price: &Vec<i32>, count: &Vec<i32>, u: usize, parent: usize, flag: usize, dp: &mut Vec<Vec<i32>>) -> i32 {\\n        if dp[u][flag] != -1 { return dp[u][flag] }\\n        dp[u][flag] = if flag == 0 { 0 } else { count[u] * price[u] / 2 };\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if v == parent { continue }\\n\\n            Self::dfs(graph, price, count, v, u, 0, dp);\\n            Self::dfs(graph, price, count, v, u, 1, dp);\\n            dp[u][flag] += if flag == 0 { dp[v][0].max(dp[v][1]) } else { dp[v][0] }; \\n        }\\n        dp[u][flag]\\n    }\\n\\n    fn backtracking(graph: &Vec<Vec<usize>>, count: &mut Vec<i32>, u: usize, dest: usize, visited: &mut Vec<i32>) -> bool {\\n        visited[u] = 1;\\n\\n        for v in &graph[u] {\\n            let v = *v;\\n            if visited[v] == 1 { continue }\\n\\n            count[v] += 1;\\n            if v == dest { return true }\\n            if Self::backtracking(graph, count, v, dest, visited) { return true }\\n            count[v] -= 1;\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484391,
                "title": "c-binary-lifting-lca-dp-minimize-the-total-price-of-the-trips",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[100][2];\\n    vector<vector<int>> g;\\n    int cost[101];\\n\\n    int rec(int node, int prev, int par){\\n        if(dp[node][prev] != -1) return dp[node][prev];\\n        int ans = 0;\\n        for(auto x: g[node]){\\n            if(x!=par){\\n                if(prev==0){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += min(rec(x,1,node)+cost[x]/2,rec(x,0,node)+cost[x]);\\n                    }\\n                }else if(prev==1){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += (rec(x,0,node)+cost[x]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[node][prev]=ans;\\n    }\\n\\nint up[101][20];\\nint lvl[101];\\n \\nvoid binary_lift(int node, int par){\\n    up[node][0] = par;\\n    for(int i=1; i<20; i++){\\n        if(up[node][i-1]!=-1){\\n            up[node][i]=up[up[node][i-1]][i-1];\\n        }else{\\n            up[node][i]=-1;\\n        }\\n    }\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            binary_lift(x,node);\\n        }\\n    }\\n}\\n \\nvoid dfs(int node, int par, int dep){\\n    lvl[node]=dep;\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            dfs(x,node,dep+1);\\n        }\\n    }\\n}\\n \\nint jump_node(int node, int jump){\\n    for(int i=19; i>=0; i--){\\n        if(jump==0 || node==-1) break;\\n        if(jump>=(1LL<<i)){\\n            node = up[node][i];\\n            jump-=(1LL<<i);\\n        }\\n        // cout<<jump<<\" \"<<node<<endl;\\n    }\\n    return node;\\n}\\n \\nint LCA(int nodeA, int nodeB){\\n    if(lvl[nodeB]>lvl[nodeA]) swap(nodeA,nodeB);\\n    // cout<<up[nodeA][2]<<endl;\\n    nodeA = jump_node(nodeA,lvl[nodeA]-lvl[nodeB]);\\n    // cout<<nodeA<<\"*\\\\n\";\\n    if(nodeA==nodeB) return nodeA;\\n    for(int i=19; i>=0; i--){\\n        if(up[nodeA][i] != up[nodeB][i]){\\n            nodeA = up[nodeA][i];\\n            nodeB = up[nodeB][i];\\n        }\\n    }\\n    return jump_node(nodeA,1);\\n}\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        g.clear();\\n        g.resize(n+1);\\n        for(auto x: edges){\\n            g[x[0]+1].push_back(x[1]+1);\\n            g[x[1]+1].push_back(x[0]+1);\\n        }\\n\\n        dfs(1,-1,0);\\n        binary_lift(1,-1);\\n        vector<int> cnt(n+1,0);\\n        for(auto x: trips){\\n            int a = x[0]+1, b = x[1]+1;\\n            int lca = LCA(a,b);\\n            while(a != lca){\\n                cnt[a]++;\\n                a = up[a][0];\\n            }\\n            while(b != lca){\\n                cnt[b]++;\\n                b = up[b][0];\\n            }\\n            cnt[lca]++;\\n        }        \\n        for(int i=1; i<=n; i++){\\n            cost[i] = cnt[i]*price[i-1];\\n        }\\n\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=-1;\\n            dp[i][1]=-1;\\n        }\\n        int ans = min(cost[1]+rec(1,0,-1),cost[1]/2+rec(1,1,-1));\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[100][2];\\n    vector<vector<int>> g;\\n    int cost[101];\\n\\n    int rec(int node, int prev, int par){\\n        if(dp[node][prev] != -1) return dp[node][prev];\\n        int ans = 0;\\n        for(auto x: g[node]){\\n            if(x!=par){\\n                if(prev==0){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += min(rec(x,1,node)+cost[x]/2,rec(x,0,node)+cost[x]);\\n                    }\\n                }else if(prev==1){\\n                    if(cost[x]==0){\\n                        ans += rec(x,0,node);\\n                    }else{\\n                        ans += (rec(x,0,node)+cost[x]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[node][prev]=ans;\\n    }\\n\\nint up[101][20];\\nint lvl[101];\\n \\nvoid binary_lift(int node, int par){\\n    up[node][0] = par;\\n    for(int i=1; i<20; i++){\\n        if(up[node][i-1]!=-1){\\n            up[node][i]=up[up[node][i-1]][i-1];\\n        }else{\\n            up[node][i]=-1;\\n        }\\n    }\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            binary_lift(x,node);\\n        }\\n    }\\n}\\n \\nvoid dfs(int node, int par, int dep){\\n    lvl[node]=dep;\\n    for(auto x: g[node]){\\n        if(x!=par){\\n            dfs(x,node,dep+1);\\n        }\\n    }\\n}\\n \\nint jump_node(int node, int jump){\\n    for(int i=19; i>=0; i--){\\n        if(jump==0 || node==-1) break;\\n        if(jump>=(1LL<<i)){\\n            node = up[node][i];\\n            jump-=(1LL<<i);\\n        }\\n        // cout<<jump<<\" \"<<node<<endl;\\n    }\\n    return node;\\n}\\n \\nint LCA(int nodeA, int nodeB){\\n    if(lvl[nodeB]>lvl[nodeA]) swap(nodeA,nodeB);\\n    // cout<<up[nodeA][2]<<endl;\\n    nodeA = jump_node(nodeA,lvl[nodeA]-lvl[nodeB]);\\n    // cout<<nodeA<<\"*\\\\n\";\\n    if(nodeA==nodeB) return nodeA;\\n    for(int i=19; i>=0; i--){\\n        if(up[nodeA][i] != up[nodeB][i]){\\n            nodeA = up[nodeA][i];\\n            nodeB = up[nodeB][i];\\n        }\\n    }\\n    return jump_node(nodeA,1);\\n}\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        g.clear();\\n        g.resize(n+1);\\n        for(auto x: edges){\\n            g[x[0]+1].push_back(x[1]+1);\\n            g[x[1]+1].push_back(x[0]+1);\\n        }\\n\\n        dfs(1,-1,0);\\n        binary_lift(1,-1);\\n        vector<int> cnt(n+1,0);\\n        for(auto x: trips){\\n            int a = x[0]+1, b = x[1]+1;\\n            int lca = LCA(a,b);\\n            while(a != lca){\\n                cnt[a]++;\\n                a = up[a][0];\\n            }\\n            while(b != lca){\\n                cnt[b]++;\\n                b = up[b][0];\\n            }\\n            cnt[lca]++;\\n        }        \\n        for(int i=1; i<=n; i++){\\n            cost[i] = cnt[i]*price[i-1];\\n        }\\n\\n        for(int i=0; i<=n; i++){\\n            dp[i][0]=-1;\\n            dp[i][1]=-1;\\n        }\\n        int ans = min(cost[1]+rec(1,0,-1),cost[1]/2+rec(1,1,-1));\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3467244,
                "title": "c-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> p1 = price, p2= price;\\n        unordered_map<int, vector<int>> mp;\\n        for (auto e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        vector<int> path;\\n        function<void(int, int, int, vector<int>)> dfs = [&](int start, int end, int prev, vector<int> v) {\\n            if (start == end) {\\n                path = v;\\n                return;\\n            }\\n            for (auto a : mp[start]) {\\n                if (a == prev or path.size() > 0) continue; \\n                v.push_back(a);\\n                dfs(a, end, start, v);\\n                v.pop_back();\\n            }\\n        };\\n        for (auto t : trips) {\\n            vector<int> v;\\n            v.push_back(t[0]);\\n            dfs(t[0], t[1], -1, v);\\n            for (int a : path) {\\n                freq[a]++;\\n            }\\n            path.clear();\\n        }\\n        function<pair<int, int>(int, int)> dp = [&](int v, int p) -> pair<int, int> {\\n            int cost1 = price[v] * freq[v];\\n            int cost2 = price[v] / 2 * freq[v];\\n            for (auto u : mp[v]) {\\n                if (u == p) continue;\\n                auto res = dp(u, v);\\n                cost1 += min(res.first, res.second);\\n                cost2 += res.first;\\n            }\\n            return {cost1, cost2};\\n        };\\n        auto ans = dp(0, -1);\\n        return min(ans.first, ans.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> p1 = price, p2= price;\\n        unordered_map<int, vector<int>> mp;\\n        for (auto e : edges) {\\n            mp[e[0]].push_back(e[1]);\\n            mp[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        vector<int> path;\\n        function<void(int, int, int, vector<int>)> dfs = [&](int start, int end, int prev, vector<int> v) {\\n            if (start == end) {\\n                path = v;\\n                return;\\n            }\\n            for (auto a : mp[start]) {\\n                if (a == prev or path.size() > 0) continue; \\n                v.push_back(a);\\n                dfs(a, end, start, v);\\n                v.pop_back();\\n            }\\n        };\\n        for (auto t : trips) {\\n            vector<int> v;\\n            v.push_back(t[0]);\\n            dfs(t[0], t[1], -1, v);\\n            for (int a : path) {\\n                freq[a]++;\\n            }\\n            path.clear();\\n        }\\n        function<pair<int, int>(int, int)> dp = [&](int v, int p) -> pair<int, int> {\\n            int cost1 = price[v] * freq[v];\\n            int cost2 = price[v] / 2 * freq[v];\\n            for (auto u : mp[v]) {\\n                if (u == p) continue;\\n                auto res = dp(u, v);\\n                cost1 += min(res.first, res.second);\\n                cost2 += res.first;\\n            }\\n            return {cost1, cost2};\\n        };\\n        auto ans = dp(0, -1);\\n        return min(ans.first, ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461676,
                "title": "dfs-dp-solution-with-explanation",
                "content": "There are 2 steps in the solution:\\n1. Finding the route for each trip and after finishing all trips, we must have data of which node occurred how many times in all trips combined. Note that the graph has a tree structure, so we can be sure that there is a unique route for each trip. Let us call this data as `contrib` which is array of size `n` and stores contributions of each node to the trips (combined).\\n2. Finding the minimum price for all these trips keeping the halving rule in mind.\\n\\nStep 1 is pretty straightforward. For each trip, you just run DFS starting from source with appending current node in an array and if you meet the destination you have found the route.\\n\\nIn step 2, we run DFS again from node 0. Note that at any point during the DFS, if the parent node price was halved, then we have no choice but to return current node price without halving. But if the parent node price was not halved, we can either choose to halve or not halve the current node price and so we return the minimum of both choices. We maintain a 2-D array of size `(n,2)` to memoize results. Since, we are assuming node 0 has no parent and in the final answer price of node 0 may or may not be halved so we return `dfs(cur=0, par=-1, parHalved=false)`.\\n\\n```\\nvoid getContrib(vector<vector<int>>&G, vector<int>&contrib, vector<int>path, int cur, int dest, int par)\\n{\\n    path.push_back(cur);\\n    if (cur==dest)\\n    {\\n        for (int node: path) contrib[node]++;\\n        return;\\n    }\\n    for (int nbd: G[cur])\\n    {\\n        if (nbd==par) continue;\\n        getContrib(G, contrib, path, nbd, dest, cur);\\n    }\\n    path.pop_back();\\n}\\n\\nint dfs(vector<vector<int>>&G, vector<vector<int>>&memo, vector<int>&contrib, vector<int>& prices, int cur, int par, bool parHalved)\\n{\\n    if (memo[cur][parHalved]!=-1) return memo[cur][parHalved];\\n    int resCurNotHalved = prices[cur]*contrib[cur];\\n    for (int nbd: G[cur]) if(nbd!=par) \\n        resCurNotHalved += dfs(G, memo, contrib, prices, nbd, cur, false);\\n    if (parHalved) return memo[cur][true] = resCurNotHalved;\\n    int resCurHalved = prices[cur]*contrib[cur]/2;\\n    for (int nbd: G[cur]) if(nbd!=par)\\n        resCurHalved += dfs(G, memo, contrib, prices, nbd, cur, true);\\n    return memo[cur][false] = min(resCurNotHalved, resCurHalved);\\n}\\n\\nint minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n{\\n    vector<vector<int>> G(n, vector<int>{});\\n    for (auto &edge: edges)\\n    {\\n        int u=edge[0], v=edge[1];\\n        G[u].push_back(v);\\n        G[v].push_back(u);\\n    }\\n    vector<int> contrib(n, 0);\\n    for (auto &trip: trips)\\n    {\\n        int src=trip[0], dest=trip[1];\\n        vector<int> path;\\n        getContrib(G, contrib, path, src, dest, -1);\\n    }\\n    vector<vector<int>> memo(n, vector<int>(2, -1));\\n    return dfs(G, memo, contrib, price, 0, -1, false);\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nvoid getContrib(vector<vector<int>>&G, vector<int>&contrib, vector<int>path, int cur, int dest, int par)\\n{\\n    path.push_back(cur);\\n    if (cur==dest)\\n    {\\n        for (int node: path) contrib[node]++;\\n        return;\\n    }\\n    for (int nbd: G[cur])\\n    {\\n        if (nbd==par) continue;\\n        getContrib(G, contrib, path, nbd, dest, cur);\\n    }\\n    path.pop_back();\\n}\\n\\nint dfs(vector<vector<int>>&G, vector<vector<int>>&memo, vector<int>&contrib, vector<int>& prices, int cur, int par, bool parHalved)\\n{\\n    if (memo[cur][parHalved]!=-1) return memo[cur][parHalved];\\n    int resCurNotHalved = prices[cur]*contrib[cur];\\n    for (int nbd: G[cur]) if(nbd!=par) \\n        resCurNotHalved += dfs(G, memo, contrib, prices, nbd, cur, false);\\n    if (parHalved) return memo[cur][true] = resCurNotHalved;\\n    int resCurHalved = prices[cur]*contrib[cur]/2;\\n    for (int nbd: G[cur]) if(nbd!=par)\\n        resCurHalved += dfs(G, memo, contrib, prices, nbd, cur, true);\\n    return memo[cur][false] = min(resCurNotHalved, resCurHalved);\\n}\\n\\nint minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n{\\n    vector<vector<int>> G(n, vector<int>{});\\n    for (auto &edge: edges)\\n    {\\n        int u=edge[0], v=edge[1];\\n        G[u].push_back(v);\\n        G[v].push_back(u);\\n    }\\n    vector<int> contrib(n, 0);\\n    for (auto &trip: trips)\\n    {\\n        int src=trip[0], dest=trip[1];\\n        vector<int> path;\\n        getContrib(G, contrib, path, src, dest, -1);\\n    }\\n    vector<vector<int>> memo(n, vector<int>(2, -1));\\n    return dfs(G, memo, contrib, price, 0, -1, false);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3459827,
                "title": "c-solution-divide-it-into-two-problems",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cric(vector<bool> &ans,vector<vector<int>> &paths,int target,int curr){\\n        if(ans[curr]){\\n            vector<int> temp;\\n            return temp;\\n        }\\n        ans[curr] = true;\\n        if(curr == target){\\n            return vector<int> {target};\\n        }\\n        for(int i = 0;i<paths[curr].size();i++){\\n            vector<int> temp = cric(ans,paths,target,paths[curr][i]);\\n            if(temp.size() != 0){\\n                temp.push_back(curr);\\n                return temp;\\n            }\\n        }\\n        vector<int> temp;\\n        return temp;\\n    }\\n    int flow(vector<vector<int>> &paths,int curr,vector<vector<int>> &ans,bool ok,vector<int> &count){\\n        // cout<<curr<<endl;\\n        // for(int i = 0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\\n        // }\\n        // cout<<endl;\\n        if(ans[curr][0] == -2){\\n            return 0;\\n        }\\n        if(ans[curr][0] != -1){\\n            if(ok){\\n                return ans[curr][0];\\n            }\\n            return ans[curr][1];\\n        }\\n        ans[curr][0] = -2;\\n        int a = 0,b = 0;\\n        for(int i = 0;i<paths[curr].size();i++){\\n            a += flow(paths,paths[curr][i],ans,false,count);\\n            b += flow(paths,paths[curr][i],ans,true,count);\\n        }\\n        ans[curr][0] = a + (count[curr]/2);\\n        ans[curr][1] = b + count[curr];\\n        ans[curr][0] = min(ans[curr][0],ans[curr][1]);\\n        if(ok){\\n            return ans[curr][0];\\n        }\\n        return ans[curr][1];\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> paths(n);\\n        for(int i = 0;i<edges.size();i++){\\n            paths[edges[i][0]].push_back(edges[i][1]);\\n            paths[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> count(n,0);\\n        for(int i = 0;i<trips.size();i++){\\n            vector<bool> ans(n,false);\\n            vector<int> temp = cric(ans,paths,trips[i][1],trips[i][0]);\\n            for(int j = 0;j<temp.size();j++){\\n                count[temp[j]]++;\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            count[i] *= price[i];\\n        }\\n        // for(int i = 0;i<count.size();i++){\\n        //     cout<<count[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        vector<vector<int>> ans(n,vector<int> (2,-1));\\n        return flow(paths,0,ans,true,count);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cric(vector<bool> &ans,vector<vector<int>> &paths,int target,int curr){\\n        if(ans[curr]){\\n            vector<int> temp;\\n            return temp;\\n        }\\n        ans[curr] = true;\\n        if(curr == target){\\n            return vector<int> {target};\\n        }\\n        for(int i = 0;i<paths[curr].size();i++){\\n            vector<int> temp = cric(ans,paths,target,paths[curr][i]);\\n            if(temp.size() != 0){\\n                temp.push_back(curr);\\n                return temp;\\n            }\\n        }\\n        vector<int> temp;\\n        return temp;\\n    }\\n    int flow(vector<vector<int>> &paths,int curr,vector<vector<int>> &ans,bool ok,vector<int> &count){\\n        // cout<<curr<<endl;\\n        // for(int i = 0;i<ans.size();i++){\\n        //     cout<<ans[i][0]<<\" \"<<ans[i][1]<<endl;\\n        // }\\n        // cout<<endl;\\n        if(ans[curr][0] == -2){\\n            return 0;\\n        }\\n        if(ans[curr][0] != -1){\\n            if(ok){\\n                return ans[curr][0];\\n            }\\n            return ans[curr][1];\\n        }\\n        ans[curr][0] = -2;\\n        int a = 0,b = 0;\\n        for(int i = 0;i<paths[curr].size();i++){\\n            a += flow(paths,paths[curr][i],ans,false,count);\\n            b += flow(paths,paths[curr][i],ans,true,count);\\n        }\\n        ans[curr][0] = a + (count[curr]/2);\\n        ans[curr][1] = b + count[curr];\\n        ans[curr][0] = min(ans[curr][0],ans[curr][1]);\\n        if(ok){\\n            return ans[curr][0];\\n        }\\n        return ans[curr][1];\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> paths(n);\\n        for(int i = 0;i<edges.size();i++){\\n            paths[edges[i][0]].push_back(edges[i][1]);\\n            paths[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int> count(n,0);\\n        for(int i = 0;i<trips.size();i++){\\n            vector<bool> ans(n,false);\\n            vector<int> temp = cric(ans,paths,trips[i][1],trips[i][0]);\\n            for(int j = 0;j<temp.size();j++){\\n                count[temp[j]]++;\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            count[i] *= price[i];\\n        }\\n        // for(int i = 0;i<count.size();i++){\\n        //     cout<<count[i]<<\" \";\\n        // }\\n        // cout<<endl;\\n        vector<vector<int>> ans(n,vector<int> (2,-1));\\n        return flow(paths,0,ans,true,count);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3458266,
                "title": "simple-java-dfs-impl",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        boolean adj[][] = new boolean[n][n];\\n        for (int[] e : edges) {\\n            adj[e[0]][e[1]] = true;\\n            adj[e[1]][e[0]] = true;\\n        }\\n        int cnt[] = new int[n];\\n        for (int[] t : trips) {\\n            find(n, adj, t[0], t[1], -1, cnt);\\n        }\\n        int[] res = dfs(n, adj, price, cnt, 0, -1);\\n        return Math.min(res[0], res[1]);\\n    }\\n\\n    boolean find(int n, boolean[][] adj, int u, int dst, int p, int[] cnt) {\\n        if (u == dst) {\\n            cnt[dst]++;\\n            return true;\\n        }\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                if (find(n, adj, v, dst, u, cnt)) {\\n                    cnt[u]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // half & same price of node u\\n    int[] dfs(int n, boolean[][] adj, int[] price, int[] cnt, int u, int p) {\\n        int half = cnt[u] * price[u] / 2;\\n        int same = cnt[u] * price[u];\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                int[] res = dfs(n, adj, price, cnt, v, u);\\n                half += res[1];\\n                same += Math.min(res[0], res[1]);\\n            }\\n        }\\n        return new int[] { half, same };\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        boolean adj[][] = new boolean[n][n];\\n        for (int[] e : edges) {\\n            adj[e[0]][e[1]] = true;\\n            adj[e[1]][e[0]] = true;\\n        }\\n        int cnt[] = new int[n];\\n        for (int[] t : trips) {\\n            find(n, adj, t[0], t[1], -1, cnt);\\n        }\\n        int[] res = dfs(n, adj, price, cnt, 0, -1);\\n        return Math.min(res[0], res[1]);\\n    }\\n\\n    boolean find(int n, boolean[][] adj, int u, int dst, int p, int[] cnt) {\\n        if (u == dst) {\\n            cnt[dst]++;\\n            return true;\\n        }\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                if (find(n, adj, v, dst, u, cnt)) {\\n                    cnt[u]++;\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n\\n    // half & same price of node u\\n    int[] dfs(int n, boolean[][] adj, int[] price, int[] cnt, int u, int p) {\\n        int half = cnt[u] * price[u] / 2;\\n        int same = cnt[u] * price[u];\\n        for (int v = 0; v < n; v++) {\\n            if (adj[u][v] && v != p) {\\n                int[] res = dfs(n, adj, price, cnt, v, u);\\n                half += res[1];\\n                same += Math.min(res[0], res[1]);\\n            }\\n        }\\n        return new int[] { half, same };\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444464,
                "title": "c-clean-code-easy-to-understand-dfs-dp-new-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nClean Code - self Explanatory\\n# Complexity\\n- Time complexity: O(n*t)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int dest, vector<int> &path, int par, int curr, vector<vector<int>> &tree) {\\n        \\n        path.push_back(curr);\\n        \\n        if(curr == dest)\\n            return 1;\\n        \\n        for(auto child: tree[curr]) {\\n            \\n            if(child == par)\\n                continue;\\n            \\n            if(dfs(dest, path, curr, child, tree))\\n                return 1;\\n            \\n        }\\n        \\n        path.pop_back();\\n        return 0;\\n    }\\n    \\n    pair<int,int> dfs2(vector<vector<int>> &tree, int curr, vector<int> &price, int par, vector<pair<int,int>> &dp) {\\n        \\n        int fullSum = 0;\\n        int minSum = 0;\\n        \\n        for(auto child: tree[curr]) {\\n            if(child == par)\\n                continue;\\n            \\n            pair<int,int> childValue = dfs2(tree, child, price, curr, dp);\\n            \\n            minSum += min(childValue.first, childValue.second);\\n            fullSum += childValue.second;\\n        \\n        }\\n        \\n        dp[curr].first = price[curr]/2 + fullSum;\\n        dp[curr].second = price[curr] + minSum;\\n        \\n        return dp[curr];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> tree(n);\\n        \\n        for(auto c: edges)\\n        {\\n            tree[c[0]].push_back(c[1]);\\n            tree[c[1]].push_back(c[0]);\\n        }\\n        \\n        vector<int> times(n, 0);\\n        \\n        for(auto s: trips)\\n        {\\n            int source = s[0];\\n            int dest = s[1];\\n            \\n            vector<int> path;\\n            dfs(s[1], path, -1, s[0], tree);\\n            \\n            for(auto c: path)\\n                times[c]++;\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            price[i] *= times[i];\\n        \\n        vector<pair<int,int>> dp(n, {0,0});\\n        \\n        dfs2(tree, 0, price, -1, dp);\\n        \\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool dfs(int dest, vector<int> &path, int par, int curr, vector<vector<int>> &tree) {\\n        \\n        path.push_back(curr);\\n        \\n        if(curr == dest)\\n            return 1;\\n        \\n        for(auto child: tree[curr]) {\\n            \\n            if(child == par)\\n                continue;\\n            \\n            if(dfs(dest, path, curr, child, tree))\\n                return 1;\\n            \\n        }\\n        \\n        path.pop_back();\\n        return 0;\\n    }\\n    \\n    pair<int,int> dfs2(vector<vector<int>> &tree, int curr, vector<int> &price, int par, vector<pair<int,int>> &dp) {\\n        \\n        int fullSum = 0;\\n        int minSum = 0;\\n        \\n        for(auto child: tree[curr]) {\\n            if(child == par)\\n                continue;\\n            \\n            pair<int,int> childValue = dfs2(tree, child, price, curr, dp);\\n            \\n            minSum += min(childValue.first, childValue.second);\\n            fullSum += childValue.second;\\n        \\n        }\\n        \\n        dp[curr].first = price[curr]/2 + fullSum;\\n        dp[curr].second = price[curr] + minSum;\\n        \\n        return dp[curr];\\n        \\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        \\n        vector<vector<int>> tree(n);\\n        \\n        for(auto c: edges)\\n        {\\n            tree[c[0]].push_back(c[1]);\\n            tree[c[1]].push_back(c[0]);\\n        }\\n        \\n        vector<int> times(n, 0);\\n        \\n        for(auto s: trips)\\n        {\\n            int source = s[0];\\n            int dest = s[1];\\n            \\n            vector<int> path;\\n            dfs(s[1], path, -1, s[0], tree);\\n            \\n            for(auto c: path)\\n                times[c]++;\\n            \\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n            price[i] *= times[i];\\n        \\n        vector<pair<int,int>> dp(n, {0,0});\\n        \\n        dfs2(tree, 0, price, -1, dp);\\n        \\n        return min(dp[0].first, dp[0].second);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3438772,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int par,vector<int>&cur,vector<vector<int>>&adj,vector<int>&contri,int & target)\\n    {\\n        cur.push_back(node);\\n        if (target==node)\\n        {\\n            for (auto it: cur) contri[it]++;\\n            cur.pop_back();\\n            return;\\n        }\\n        for (auto it:adj[node])\\n        {\\n            if (par!=it)\\n            {\\n                dfs(it,node,cur,adj,contri,target);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    int rec(int node,int par,vector<int>&contri,vector<int>&price,vector<vector<int>>&adj,int take,vector<vector<int>>&dp)\\n    {\\n       if (dp[node][take]!=-1) return dp[node][take];\\n       int price1=contri[node]*price[node];\\n       int price2=contri[node]*(price[node]/2);\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price1+=rec(it,node,contri,price,adj,1,dp);\\n           }\\n       }\\n       if (take==0) return dp[node][take]=price1;\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price2+=rec(it,node,contri,price,adj,0,dp);\\n           }\\n       }\\n       return dp[node][take]=min(price1,price2);\\n    }\\n        \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int ans=0;\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>dp(51,vector<int>(2,-1));\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        vector<int>cur;\\n       for (auto it:trips)\\n       {\\n           dfs(it[0],-1,cur,adj,contri,it[1]);\\n       }\\n       return rec(0,-1,contri,price,adj,1,dp);\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int node,int par,vector<int>&cur,vector<vector<int>>&adj,vector<int>&contri,int & target)\\n    {\\n        cur.push_back(node);\\n        if (target==node)\\n        {\\n            for (auto it: cur) contri[it]++;\\n            cur.pop_back();\\n            return;\\n        }\\n        for (auto it:adj[node])\\n        {\\n            if (par!=it)\\n            {\\n                dfs(it,node,cur,adj,contri,target);\\n            }\\n        }\\n        cur.pop_back();\\n    }\\n    int rec(int node,int par,vector<int>&contri,vector<int>&price,vector<vector<int>>&adj,int take,vector<vector<int>>&dp)\\n    {\\n       if (dp[node][take]!=-1) return dp[node][take];\\n       int price1=contri[node]*price[node];\\n       int price2=contri[node]*(price[node]/2);\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price1+=rec(it,node,contri,price,adj,1,dp);\\n           }\\n       }\\n       if (take==0) return dp[node][take]=price1;\\n       for (auto it:adj[node])\\n       {\\n           if (it!=par)\\n           {\\n               price2+=rec(it,node,contri,price,adj,0,dp);\\n           }\\n       }\\n       return dp[node][take]=min(price1,price2);\\n    }\\n        \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int ans=0;\\n        vector<vector<int>>adj(n);\\n        vector<vector<int>>dp(51,vector<int>(2,-1));\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n             adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<int>contri(n,0);\\n        vector<int>cur;\\n       for (auto it:trips)\\n       {\\n           dfs(it[0],-1,cur,adj,contri,it[1]);\\n       }\\n       return rec(0,-1,contri,price,adj,1,dp);\\n        \\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432861,
                "title": "dfc-top-down-dp-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nConstruct an adjacency list:\\nConstruct an adjacency list to represent the graph. This will make it easy to traverse the graph and perform operations on each node.\\n\\nPerform DFS to record frequency of passes:\\nFor each trip, perform a Depth-First Search (DFS) on the graph to record the frequency of times each node is passed. Since the graph is a tree, it will not have cycles, and there will be only one path from Node A to Node B.\\n\\nChoose a starting node and use Dynamic Programming:\\nChoose an arbitrary starting node and perform Dynamic Programming (DP) to find the smallest possible sum. For each node in the graph, there are only two possible options: either halve it or not. Therefore, the problem can be reduced to finding the optimal solution for each subproblem, which can be done using DP.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adjList;\\n    int dp[51][2];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto e:edges){\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        \\n\\n        for(auto trip:trips){\\n            vector<int> curr;\\n            freqDFS(freq, curr, -1, trip[0], trip[1]);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return DFS(price, freq, -1, 0, 0);\\n    }\\n\\n    int DFS(vector<int>& prices, vector<int>& freq, int parent, int curr, int parentHalved){\\n        int ret1 = freq[curr]*prices[curr]/2, ret2 =freq[curr]*prices[curr];\\n        if(dp[curr][parentHalved]!=-1)\\n            return dp[curr][parentHalved];\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret2+= DFS(prices, freq, curr, nxt, 0);\\n        }\\n        if(parentHalved){\\n            return dp[curr][parentHalved] = ret2;\\n        }\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret1+=DFS(prices, freq, curr, nxt, 1);\\n        }\\n\\n        return dp[curr][parentHalved] = min(ret1, ret2);\\n\\n        \\n\\n\\n    }\\n\\n\\n    void freqDFS(vector<int>& freq, vector<int>& curr, int parent, int src, int dst){\\n        //basecase\\n        curr.push_back(src);\\n        if(src==dst){\\n            for(auto& iter:curr){\\n                freq[iter]++;\\n            }      \\n            return;\\n        }\\n\\n        for(auto& nxt:adjList[src]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            freqDFS(freq, curr, src, nxt, dst);\\n        }\\n        curr.pop_back();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> adjList;\\n    int dp[51][2];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(auto e:edges){\\n            adjList[e[0]].push_back(e[1]);\\n            adjList[e[1]].push_back(e[0]);\\n        }\\n        vector<int> freq(n, 0);\\n        \\n\\n        for(auto trip:trips){\\n            vector<int> curr;\\n            freqDFS(freq, curr, -1, trip[0], trip[1]);\\n        }\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return DFS(price, freq, -1, 0, 0);\\n    }\\n\\n    int DFS(vector<int>& prices, vector<int>& freq, int parent, int curr, int parentHalved){\\n        int ret1 = freq[curr]*prices[curr]/2, ret2 =freq[curr]*prices[curr];\\n        if(dp[curr][parentHalved]!=-1)\\n            return dp[curr][parentHalved];\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret2+= DFS(prices, freq, curr, nxt, 0);\\n        }\\n        if(parentHalved){\\n            return dp[curr][parentHalved] = ret2;\\n        }\\n\\n        for(auto nxt:adjList[curr]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            ret1+=DFS(prices, freq, curr, nxt, 1);\\n        }\\n\\n        return dp[curr][parentHalved] = min(ret1, ret2);\\n\\n        \\n\\n\\n    }\\n\\n\\n    void freqDFS(vector<int>& freq, vector<int>& curr, int parent, int src, int dst){\\n        //basecase\\n        curr.push_back(src);\\n        if(src==dst){\\n            for(auto& iter:curr){\\n                freq[iter]++;\\n            }      \\n            return;\\n        }\\n\\n        for(auto& nxt:adjList[src]){\\n            if(nxt==parent){\\n                continue;\\n            }\\n            freqDFS(freq, curr, src, nxt, dst);\\n        }\\n        curr.pop_back();\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432789,
                "title": "iterative-stack-dp-with-comments",
                "content": "# Intuition\\nIt looked like House Robber problems family, so we need to find a way to build dp\\n\\n# Approach\\n1. First traverse all trips to know possible inputs of each node into final cost\\n2. Don\\'t forget to consider odd cases of disconnected subgraphs or disconnected nodes and trips with same start and end\\n3. Selected any node as root and traverse tree with stack. \\n- If node with children met for the first time, leave the node on stack and put children of stack. \\n- If node with children met for the second time or node doesn\\'t have children - calculate dp for it, since children are already processed\\n4. For each node we have 2 dp values:\\n- if node is *not taken* into discount (full price, dp[i][0]), then we are free to select min value from child *both cases* - when child is taken into discount and when it\\'s not   \\n- if node is *taken* into discount (half price, dp[i][1]), then we can only use child value for child *non-taken* case\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Max(edges, trips))\\n\\n# Code\\n```\\nfunction minimumTotalPrice(n: number, edges: number[][], prices: number[], trips: number[][]): number {\\n  const graph = new Map<number, number[]>();\\n  \\n  // consider disconnected nodes\\n  for (let i = 0; i < n; i++) {\\n    graph.set(i, []);\\n  }\\n\\n  for (let [start, end] of edges) {\\n    graph.get(start).push(end);\\n    graph.get(end).push(start);\\n  }\\n\\n  const stops = Array(n).fill(0)\\n  for (let i = 0; i < trips.length; i++) {\\n    const [start, end] = trips[i];\\n    const path = start === end ? [start] : traverse(start, end, graph);\\n    for (let stop of path) {\\n      stops[stop]++;\\n    }\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Array(2).fill(0));\\n  const visited = new Set<number>();\\n  \\n  let res = 0;\\n  // consider disconnected graph - try to start from each non-visited node\\n  for(let i=0; i<n; i++) {\\n    if (!visited.has(i)) {\\n      const stack: [number, number][] = [[i, Number.MAX_VALUE]];\\n      while(stack.length > 0) {\\n        const [curr, parent] = stack[stack.length - 1]; // peek\\n        const connections = graph.get(curr);\\n        \\n        // not visited yet and has connection other then parent (leaf node)\\n        if (!visited.has(curr) && (connections.length > 1 || connections[0] !== parent)) {\\n          for(let connection of connections) {\\n            if (connection !== parent) {\\n              stack.push([connection, curr]);\\n            }\\n          }\\n        } else {\\n          // remove from stack once visited for the second time or is leaf\\n          stack.pop();\\n          \\n          let noTake = 0; // children cost if node is not taken into discount\\n          let take = 0; // chilren cost if node is taken into discount\\n          \\n          for(let connection of connections) {\\n            take += dp[connection][0]; // only non-taken child case    \\n            noTake += Math.min(dp[connection][0], dp[connection][1]); \\n          }\\n\\n          dp[curr][0] = prices[curr] * stops[curr] + noTake;\\n          dp[curr][1] = prices[curr] * stops[curr] / 2 + take;\\n        }\\n\\n        visited.add(curr);\\n       }\\n\\n      res += Math.min(dp[i][0], dp[i][1]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\nfunction traverse(start: number, end: number, graph: Map<number, number[]>): number[] {\\n  let queue: [number, number[]][] = [[start, [start]]];\\n\\n  const visited = new Set<number>();\\n\\n  while (queue.length > 0) {\\n    const [curr, currPath] = queue.shift();\\n    visited.add(curr);\\n\\n    if (curr === end) {\\n      return currPath;\\n    }\\n\\n    for (let node of graph.get(curr)) {\\n      if (!visited.has(node)) {\\n        queue.push([node, [...currPath, node]]);\\n      }\\n    }\\n  }\\n\\n  throw Error(\\'Invalid graph\\');\\n}\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Dynamic Programming",
                    "Stack"
                ],
                "code": "```\\nfunction minimumTotalPrice(n: number, edges: number[][], prices: number[], trips: number[][]): number {\\n  const graph = new Map<number, number[]>();\\n  \\n  // consider disconnected nodes\\n  for (let i = 0; i < n; i++) {\\n    graph.set(i, []);\\n  }\\n\\n  for (let [start, end] of edges) {\\n    graph.get(start).push(end);\\n    graph.get(end).push(start);\\n  }\\n\\n  const stops = Array(n).fill(0)\\n  for (let i = 0; i < trips.length; i++) {\\n    const [start, end] = trips[i];\\n    const path = start === end ? [start] : traverse(start, end, graph);\\n    for (let stop of path) {\\n      stops[stop]++;\\n    }\\n  }\\n\\n  const dp = Array.from({ length: n }, () => Array(2).fill(0));\\n  const visited = new Set<number>();\\n  \\n  let res = 0;\\n  // consider disconnected graph - try to start from each non-visited node\\n  for(let i=0; i<n; i++) {\\n    if (!visited.has(i)) {\\n      const stack: [number, number][] = [[i, Number.MAX_VALUE]];\\n      while(stack.length > 0) {\\n        const [curr, parent] = stack[stack.length - 1]; // peek\\n        const connections = graph.get(curr);\\n        \\n        // not visited yet and has connection other then parent (leaf node)\\n        if (!visited.has(curr) && (connections.length > 1 || connections[0] !== parent)) {\\n          for(let connection of connections) {\\n            if (connection !== parent) {\\n              stack.push([connection, curr]);\\n            }\\n          }\\n        } else {\\n          // remove from stack once visited for the second time or is leaf\\n          stack.pop();\\n          \\n          let noTake = 0; // children cost if node is not taken into discount\\n          let take = 0; // chilren cost if node is taken into discount\\n          \\n          for(let connection of connections) {\\n            take += dp[connection][0]; // only non-taken child case    \\n            noTake += Math.min(dp[connection][0], dp[connection][1]); \\n          }\\n\\n          dp[curr][0] = prices[curr] * stops[curr] + noTake;\\n          dp[curr][1] = prices[curr] * stops[curr] / 2 + take;\\n        }\\n\\n        visited.add(curr);\\n       }\\n\\n      res += Math.min(dp[i][0], dp[i][1]);\\n    }\\n  }\\n\\n  return res;\\n}\\n\\nfunction traverse(start: number, end: number, graph: Map<number, number[]>): number[] {\\n  let queue: [number, number[]][] = [[start, [start]]];\\n\\n  const visited = new Set<number>();\\n\\n  while (queue.length > 0) {\\n    const [curr, currPath] = queue.shift();\\n    visited.add(curr);\\n\\n    if (curr === end) {\\n      return currPath;\\n    }\\n\\n    for (let node of graph.get(curr)) {\\n      if (!visited.has(node)) {\\n        queue.push([node, [...currPath, node]]);\\n      }\\n    }\\n  }\\n\\n  throw Error(\\'Invalid graph\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432750,
                "title": "get-node-visit-count-and-run-a-dp-on-the-tree",
                "content": "# Code\\n```\\ndef minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    neigh = [[] for _ in range(n)]\\n    for a, b in edges:\\n        neigh[a].append(b)\\n        neigh[b].append(a)\\n    \\n    visitCount = [0] * n\\n    def dfs(parent, node, target):\\n        visitCount[node] += 1\\n        if node == target:\\n            return True # reached target\\n        for v in neigh[node]:\\n            if v == parent:\\n                continue\\n            if dfs(node, v, target):\\n                return True\\n        visitCount[node] -= 1\\n\\n    for a, b in trips:\\n        dfs(-1, a, b)\\n    \\n    @cache\\n    def dp(parent: int, node: int, parentHalved: int) -> int:\\n        ret = 0\\n        if parentHalved:\\n            ret = price[node] * visitCount[node]\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                ret += dp(node, v, False)\\n            return ret\\n        else: # parent not halved, we have two options\\n            a = price[node] * visitCount[node]  # not halving it\\n            b = price[node] * visitCount[node] // 2  # halving it\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                a += dp(node, v, False)\\n                b += dp(node, v, True)\\n            return min(a, b)\\n\\n    return dp(-1, 0, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n    neigh = [[] for _ in range(n)]\\n    for a, b in edges:\\n        neigh[a].append(b)\\n        neigh[b].append(a)\\n    \\n    visitCount = [0] * n\\n    def dfs(parent, node, target):\\n        visitCount[node] += 1\\n        if node == target:\\n            return True # reached target\\n        for v in neigh[node]:\\n            if v == parent:\\n                continue\\n            if dfs(node, v, target):\\n                return True\\n        visitCount[node] -= 1\\n\\n    for a, b in trips:\\n        dfs(-1, a, b)\\n    \\n    @cache\\n    def dp(parent: int, node: int, parentHalved: int) -> int:\\n        ret = 0\\n        if parentHalved:\\n            ret = price[node] * visitCount[node]\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                ret += dp(node, v, False)\\n            return ret\\n        else: # parent not halved, we have two options\\n            a = price[node] * visitCount[node]  # not halving it\\n            b = price[node] * visitCount[node] // 2  # halving it\\n            for v in neigh[node]:\\n                if v == parent:\\n                    continue\\n                a += dp(node, v, False)\\n                b += dp(node, v, True)\\n            return min(a, b)\\n\\n    return dp(-1, 0, False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3432255,
                "title": "java-bfs-dfs-memo-solution-with-thinking-progress",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem provides an unrooted tree and 2D integer array trips, ask for the minimun total price to perform all trips.\\nSince it is unrooted tree, we could first count all the nodes the trip will use and then arrange the price without caring the path.\\nThe tricky part is we only care about the nodes int the trips, but we could iterate the whole tree and for the nodes not in the path we just add zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build the graph and use BFS to calculate the nodes in the path.\\n    ```\\n    public Map<Integer, Set<Integer>> buildMap(int[][] edges){\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge: edges){\\n            map.putIfAbsent(edge[0], new HashSet<>());\\n            map.putIfAbsent(edge[1], new HashSet<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        return map;\\n    }\\n\\n    public int[] getNodeCounts(int n, Map<Integer, Set<Integer>> map, int[][] trips){\\n        int[] res = new int[n];\\n        for(int[] trip: trips){\\n            bfs(n, map, trip[0], trip[1], res);\\n        }\\n        return res;\\n    }\\n    //We use parent array to track the path.\\n    //Once get the end, we add all the path to counts array.\\n    public void bfs(int n, Map<Integer, Set<Integer>> map, int start, int end, int[] counts){\\n        counts[start]++;\\n        if(end == start){\\n            return;\\n        }\\n        int[] parent = new int[n];\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(start);\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; ++i){\\n                int current = queue.poll();\\n                if(current == end){\\n                    while(current != start){\\n                        counts[current]++;\\n                        current = parent[current];\\n                    }\\n                    return;\\n                }\\n                for(int child: map.get(current)){\\n                    if(!visited.add(child)) continue;\\n                    parent[child] = current;\\n                    queue.offer(child);\\n                }\\n            }\\n        }\\n    }\\n    ```\\n2. Use dfs to iterate the whole tree and calculate the sum, as we discuss before, the sum will not be affected even we traverse the whole tree. There are two state for each node, if the previous node is halved, the current node can not be halved, or it could be halved or unhalved, we compare the halfCurrent notHalfCurrent and return the minimum one.\\n    ```\\n    public int dfs(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf){\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfs(map, next, visited, counts, price, false);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfs(map, next, visited, counts, price, true);\\n                notHalfCurrentSum += dfs(map, next, visited, counts, price, false);\\n            }\\n        }\\n        visited[current] = false;\\n        return parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n    }\\n    ```\\n3. We get TLE with regular dfs, we find we calculate the same state many times, so we try to memo the result we calculated before. \\n    ```\\n    public int dfsWithMemo(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf, Integer[][] memo){\\n        if(parentHalf && memo[current][0] != null){\\n            return memo[current][0];\\n        }else if(!parentHalf && memo[current][1] != null){\\n            return memo[current][1];\\n        }\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfsWithMemo(map, next, visited, counts, price, false, memo);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfsWithMemo(map, next, visited, counts, price, true, memo);\\n                notHalfCurrentSum += dfsWithMemo(map, next, visited, counts, price, false, memo);\\n            }\\n        }\\n        visited[current] = false;\\n        int res = parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n        int state = parentHalf ? 0 : 1;\\n        memo[current][state] = res;\\n        return res;\\n    }\\n    ```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n $$O(V + E) * tripSize$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g.  -->\\n$$O(V)$$\\n# Code\\nA edge case is that there is only one point and no edge, if n is one we should return price[0]/2.\\n```\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        // [0,1,3,2,1,2,1,3]\\n        // price[0] + 3 * price[1] + 2 * price[2] + price[3];\\n        if(n == 1) return price[0] / 2;\\n        Map<Integer, Set<Integer>> map = buildMap(edges);\\n        int[] counts = getNodeCounts(n, map, trips);\\n        return dfsWithMemo(map, 0, new boolean[n], counts, price, false, new Integer[n][2]);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Memoization"
                ],
                "code": "```\\n    public Map<Integer, Set<Integer>> buildMap(int[][] edges){\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for(int[] edge: edges){\\n            map.putIfAbsent(edge[0], new HashSet<>());\\n            map.putIfAbsent(edge[1], new HashSet<>());\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        return map;\\n    }\\n\\n    public int[] getNodeCounts(int n, Map<Integer, Set<Integer>> map, int[][] trips){\\n        int[] res = new int[n];\\n        for(int[] trip: trips){\\n            bfs(n, map, trip[0], trip[1], res);\\n        }\\n        return res;\\n    }\\n    //We use parent array to track the path.\\n    //Once get the end, we add all the path to counts array.\\n    public void bfs(int n, Map<Integer, Set<Integer>> map, int start, int end, int[] counts){\\n        counts[start]++;\\n        if(end == start){\\n            return;\\n        }\\n        int[] parent = new int[n];\\n        Deque<Integer> queue = new ArrayDeque<>();\\n        Set<Integer> visited = new HashSet<>();\\n        queue.offer(start);\\n        visited.add(start);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; ++i){\\n                int current = queue.poll();\\n                if(current == end){\\n                    while(current != start){\\n                        counts[current]++;\\n                        current = parent[current];\\n                    }\\n                    return;\\n                }\\n                for(int child: map.get(current)){\\n                    if(!visited.add(child)) continue;\\n                    parent[child] = current;\\n                    queue.offer(child);\\n                }\\n            }\\n        }\\n    }\\n    ```\n```\\n    public int dfs(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf){\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfs(map, next, visited, counts, price, false);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfs(map, next, visited, counts, price, true);\\n                notHalfCurrentSum += dfs(map, next, visited, counts, price, false);\\n            }\\n        }\\n        visited[current] = false;\\n        return parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n    }\\n    ```\n```\\n    public int dfsWithMemo(Map<Integer, Set<Integer>> map, int current, boolean[] visited, int[] counts, int[] price, boolean parentHalf, Integer[][] memo){\\n        if(parentHalf && memo[current][0] != null){\\n            return memo[current][0];\\n        }else if(!parentHalf && memo[current][1] != null){\\n            return memo[current][1];\\n        }\\n        visited[current] = true;\\n        int halfCurrentSum = 0, notHalfCurrentSum = 0, val = counts[current] * price[current], halfVal = val / 2;\\n        for(int next: map.get(current)){\\n            if(visited[next]) continue;\\n            if(parentHalf){\\n                int v = dfsWithMemo(map, next, visited, counts, price, false, memo);\\n                halfCurrentSum += v;\\n                notHalfCurrentSum += v;\\n            }else{\\n                halfCurrentSum += dfsWithMemo(map, next, visited, counts, price, true, memo);\\n                notHalfCurrentSum += dfsWithMemo(map, next, visited, counts, price, false, memo);\\n            }\\n        }\\n        visited[current] = false;\\n        int res = parentHalf ? (notHalfCurrentSum + val) : Math.min(halfCurrentSum + halfVal, notHalfCurrentSum + val);\\n        int state = parentHalf ? 0 : 1;\\n        memo[current][state] = res;\\n        return res;\\n    }\\n    ```\n```\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        // [0,1,3,2,1,2,1,3]\\n        // price[0] + 3 * price[1] + 2 * price[2] + price[3];\\n        if(n == 1) return price[0] / 2;\\n        Map<Integer, Set<Integer>> map = buildMap(edges);\\n        int[] counts = getNodeCounts(n, map, trips);\\n        return dfsWithMemo(map, 0, new boolean[n], counts, price, false, new Integer[n][2]);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3431921,
                "title": "c-dfs-memoization-recursion-backtracking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    void dfs(int st,int en,vector<vector<int>>& adj,vector<int> tmp,int parent,vector<int> &fre)\\n    {\\n        tmp[st]++;\\n        if(st==en)\\n        {\\n            for(int i=0;i<tmp.size();i++)\\n            {\\n                fre[i]+=tmp[i];\\n            }\\n            return;\\n        }\\n        for(auto &i:adj[st])\\n        {\\n            if(i!=parent)\\n            {\\n                dfs(i,en,adj,tmp,st,fre);\\n            }\\n        }\\n    }\\n    int dfs1(int x,vector<vector<int>>& adj,vector<int>& fre,vector<int>& price,int parent,int canHalf)\\n    {\\n        if(dp[x][canHalf]!=-1)\\n        return dp[x][canHalf];\\n        int ans = INT_MAX;\\n        if(canHalf)\\n        {\\n            int tak1 = (fre[x]*price[x])/2,tak2 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,0);\\n                    tak2+=dfs1(i,adj,fre,price,x,canHalf);\\n                }\\n            }\\n            ans = min(tak1,tak2);\\n            return dp[x][canHalf] = ans;\\n        }\\n        else\\n        {\\n            int tak1 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,1);\\n                }\\n            }\\n            return dp[x][canHalf] = tak1;\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> fre(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for(int i=0;i<trips.size();i++)\\n        {\\n            int st = trips[i][0];\\n            int en = trips[i][1];\\n            vector<int> tmp(n);\\n            dfs(st,en,adj,tmp,-1,fre);\\n        }\\n        \\n        return dfs1(0,adj,fre,price,-1,1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[51][2];\\n    void dfs(int st,int en,vector<vector<int>>& adj,vector<int> tmp,int parent,vector<int> &fre)\\n    {\\n        tmp[st]++;\\n        if(st==en)\\n        {\\n            for(int i=0;i<tmp.size();i++)\\n            {\\n                fre[i]+=tmp[i];\\n            }\\n            return;\\n        }\\n        for(auto &i:adj[st])\\n        {\\n            if(i!=parent)\\n            {\\n                dfs(i,en,adj,tmp,st,fre);\\n            }\\n        }\\n    }\\n    int dfs1(int x,vector<vector<int>>& adj,vector<int>& fre,vector<int>& price,int parent,int canHalf)\\n    {\\n        if(dp[x][canHalf]!=-1)\\n        return dp[x][canHalf];\\n        int ans = INT_MAX;\\n        if(canHalf)\\n        {\\n            int tak1 = (fre[x]*price[x])/2,tak2 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,0);\\n                    tak2+=dfs1(i,adj,fre,price,x,canHalf);\\n                }\\n            }\\n            ans = min(tak1,tak2);\\n            return dp[x][canHalf] = ans;\\n        }\\n        else\\n        {\\n            int tak1 = fre[x]*price[x];\\n            for(auto &i:adj[x])\\n            {\\n                if(i!=parent)\\n                {\\n                    tak1+=dfs1(i,adj,fre,price,x,1);\\n                }\\n            }\\n            return dp[x][canHalf] = tak1;\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        memset(dp,-1,sizeof(dp));\\n        vector<int> fre(n,0);\\n        vector<vector<int>> adj(n);\\n        for(auto &i:edges)\\n        {\\n            int a = i[0];\\n            int b = i[1];\\n            adj[a].push_back(b);\\n            adj[b].push_back(a);\\n        }\\n        for(int i=0;i<trips.size();i++)\\n        {\\n            int st = trips[i][0];\\n            int en = trips[i][1];\\n            vector<int> tmp(n);\\n            dfs(st,en,adj,tmp,-1,fre);\\n        }\\n        \\n        return dfs1(0,adj,fre,price,-1,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431012,
                "title": "java-easy-to-understand-dp-dfs",
                "content": "```\\nclass Solution {\\n    int[] freq;\\n    Integer[][] dp;\\n    private int solve(List<List<Integer>> graph, int cur, boolean flag, int[] price, int parent){\\n        int index = flag ? 0 : 1;\\n        if(dp[cur][index] != null) return dp[cur][index];\\n        List<Integer> neighbors = graph.get(cur);\\n        int res = flag ? (price[cur] * freq[cur]) : ((price[cur] / 2) * freq[cur]);\\n        for(int neighbor: neighbors){\\n            if(neighbor != parent){\\n                if(flag)\\n                    res += Math.min(solve(graph, neighbor, true, price, cur), solve(graph, neighbor, false, price, cur));\\n                else\\n                    res += solve(graph, neighbor, true, price, cur);\\n            }\\n        }\\n        return dp[cur][index] = res;\\n    }\\n    private boolean dfs(List<List<Integer>> graph, int cur, int end, boolean[] visited){\\n        if(cur == end){\\n            visited[cur] = true;\\n            freq[cur] ++;\\n            return true;\\n        }\\n        visited[cur] = true;\\n        boolean res = false;\\n        List<Integer> neighbors = graph.get(cur);\\n        for(int neighbor: neighbors){\\n            if(visited[neighbor]) continue;\\n            res = res || dfs(graph, neighbor, end, visited);\\n        }\\n        if(res) freq[cur] ++;\\n        return res;\\n    }\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        dp = new Integer[n][2];\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        freq = new int[n];\\n        for(int[] trip: trips){\\n            dfs(graph, trip[0], trip[1], new boolean[n]);\\n        }\\n        return Math.min(solve(graph, 0, true, price, -1), solve(graph, 0, false, price, -1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] freq;\\n    Integer[][] dp;\\n    private int solve(List<List<Integer>> graph, int cur, boolean flag, int[] price, int parent){\\n        int index = flag ? 0 : 1;\\n        if(dp[cur][index] != null) return dp[cur][index];\\n        List<Integer> neighbors = graph.get(cur);\\n        int res = flag ? (price[cur] * freq[cur]) : ((price[cur] / 2) * freq[cur]);\\n        for(int neighbor: neighbors){\\n            if(neighbor != parent){\\n                if(flag)\\n                    res += Math.min(solve(graph, neighbor, true, price, cur), solve(graph, neighbor, false, price, cur));\\n                else\\n                    res += solve(graph, neighbor, true, price, cur);\\n            }\\n        }\\n        return dp[cur][index] = res;\\n    }\\n    private boolean dfs(List<List<Integer>> graph, int cur, int end, boolean[] visited){\\n        if(cur == end){\\n            visited[cur] = true;\\n            freq[cur] ++;\\n            return true;\\n        }\\n        visited[cur] = true;\\n        boolean res = false;\\n        List<Integer> neighbors = graph.get(cur);\\n        for(int neighbor: neighbors){\\n            if(visited[neighbor]) continue;\\n            res = res || dfs(graph, neighbor, end, visited);\\n        }\\n        if(res) freq[cur] ++;\\n        return res;\\n    }\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        dp = new Integer[n][2];\\n        for(int i = 0; i < n; i++) graph.add(new ArrayList<>());\\n        for(int[] edge: edges){\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        freq = new int[n];\\n        for(int[] trip: trips){\\n            dfs(graph, trip[0], trip[1], new boolean[n]);\\n        }\\n        return Math.min(solve(graph, 0, true, price, -1), solve(graph, 0, false, price, -1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430155,
                "title": "house-robber-o-m-n-python3-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe\\'d like to choose some non-adjacent node to minimize the total cost. First, we count the use time of each node. Second, choose some non-adjacent node to halve. We want to maximize the halve parts. So the answer will be `sum(use_time[node]*price[time] for all nodes) - sum(use_time[node]*price[time] // 2 for chosen nodes)`. So how to choose the nodes? It\\'s similar to the problem [house-robber](https://leetcode.com/problems/house-robber/) which wants to maximize the the sum of non-adjacent array element. We choose a node as root. Build the topological sort order and trans the undirected and unrooted tree to the directed and rooted tree. And start from the root bulid the dp top down. Let\\'s define `dp[node][0]` means we halve the node and include its valid solution of children, `dp[node][1]` means we don\\'t halve the current node, so for its children we could choose do or do not halve its children.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse count_use function to build the use_time of all nodes.\\nTo build a directed and rooted tree. Set node 0 as root. Use topological_sort function to find the children of all nodes.\\nUse build_dp from root to build the dp.\\nSum the total cost and minus the max of dp[root][0], dp[root][1].\\n# Complexity\\n$$n$$ = number of nodes.\\n$$m$$ = number of trips.\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def count_use(current, target, use_time, visited, adjs):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            if current == target:\\n                use_time[current] += 1\\n                return 1\\n            for adj in adjs[current]:\\n                if count_use(adj, target, use_time, visited, adjs):\\n                    use_time[current] += 1\\n                    return 1\\n            return 0\\n\\n        def topological_sort(current, visited, adjs, children):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            for adj in adjs[current]:\\n                if topological_sort(adj, visited, adjs, children):\\n                    children[current].append(adj)\\n            return 1\\n        \\n        def build_dp(current, visited, adjs, children, price, use_time, dp):\\n            # dp[i][0] choose node i to halve dp[i][1] not choose node i\\n            if visited[current]:\\n                return dp[current]\\n            visited[current] = 1\\n            dp[current][0] = price[current]*use_time[current]//2\\n            dp[current][1] = 0\\n            for child in children[current]:\\n                build_dp(child, visited, adjs, children, price, use_time, dp)\\n                dp[current][0] += dp[child][1]\\n                dp[current][1] += max(dp[child][1], dp[child][0])\\n            return dp[current]\\n        \\n        use_time = [0]*n\\n        adjs = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adjs[edge[0]].append(edge[1])\\n            adjs[edge[1]].append(edge[0])\\n        for trip in trips:\\n            visited = [0]*n\\n            count_use(trip[0], trip[1], use_time, visited, adjs)\\n\\n        root = 0\\n        visited = [0]*n\\n        children = [[] for _ in range(n)]\\n        topological_sort(root, visited, adjs, children)\\n\\n        visited = [0]*n\\n        dp = [[0,0] for _ in range(n)]\\n        build_dp(root, visited, adjs, children, price, use_time, dp)\\n\\n        total = 0\\n        for i in range(n):\\n            total += use_time[i]*price[i]\\n        total -= max(dp[root])\\n\\n        return total\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def count_use(current, target, use_time, visited, adjs):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            if current == target:\\n                use_time[current] += 1\\n                return 1\\n            for adj in adjs[current]:\\n                if count_use(adj, target, use_time, visited, adjs):\\n                    use_time[current] += 1\\n                    return 1\\n            return 0\\n\\n        def topological_sort(current, visited, adjs, children):\\n            if visited[current]:\\n                return 0\\n            visited[current] = 1\\n            for adj in adjs[current]:\\n                if topological_sort(adj, visited, adjs, children):\\n                    children[current].append(adj)\\n            return 1\\n        \\n        def build_dp(current, visited, adjs, children, price, use_time, dp):\\n            # dp[i][0] choose node i to halve dp[i][1] not choose node i\\n            if visited[current]:\\n                return dp[current]\\n            visited[current] = 1\\n            dp[current][0] = price[current]*use_time[current]//2\\n            dp[current][1] = 0\\n            for child in children[current]:\\n                build_dp(child, visited, adjs, children, price, use_time, dp)\\n                dp[current][0] += dp[child][1]\\n                dp[current][1] += max(dp[child][1], dp[child][0])\\n            return dp[current]\\n        \\n        use_time = [0]*n\\n        adjs = [[] for _ in range(n)]\\n        \\n        for edge in edges:\\n            adjs[edge[0]].append(edge[1])\\n            adjs[edge[1]].append(edge[0])\\n        for trip in trips:\\n            visited = [0]*n\\n            count_use(trip[0], trip[1], use_time, visited, adjs)\\n\\n        root = 0\\n        visited = [0]*n\\n        children = [[] for _ in range(n)]\\n        topological_sort(root, visited, adjs, children)\\n\\n        visited = [0]*n\\n        dp = [[0,0] for _ in range(n)]\\n        build_dp(root, visited, adjs, children, price, use_time, dp)\\n\\n        total = 0\\n        for i in range(n):\\n            total += use_time[i]*price[i]\\n        total -= max(dp[root])\\n\\n        return total\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430085,
                "title": "tree-dp",
                "content": "We first calculate what nodes would be visited in all the trips and how many times, and store the inflated price of every node in infPrice vector where infPrice[i] = number of times node \\'i\\' was visited * price[i].\\n(It can easily be achieved by bfs or dfs from start point of every trip)\\nSo, if any node was not visited, its infPrice would be 0.\\nNow, take any random node and calculate the price of trips after it being **halved(H)** and also **not being halved(F)** recursively as :\\nH[i] = infPrice[i]/2 + Sum(F[j]))\\nF[i] = infPrice[i] + Sum(min(H[j], F[j]))\\nwhere j are all the neighbours of i that have not yet been encountered while doing this computation.\\n\\nThe logic here being that if ith node is Halved then all its neighbours should be computed at full value.\\nBut if the ith node is calculated at full value we can chose to compute each neighbour one by one at their full value as well as their halved value. **But, since it is a tree we do not need to worry about side effects of halving the node \\'j\\' which is neighbour of \\'i\\', on an another node \\'k\\' which is also neighbour of \\'i\\' as \\'j\\' and \\'k\\' are disjointed by \\'i\\' and can be computed independently as sub-problems(joined at i).**\\n```\\nclass Solution {\\n    pair<int, int> engine(int i, vector<int> &infPrice, vector<vector<int> > &adj, vector<int> &visited){\\n        pair<int, int> x = {infPrice[i]/2, infPrice[i]};\\n        visited[i] = 1;\\n        for(int y: adj[i]){\\n            if(!visited[y]){\\n                pair<int, int> z = engine(y, infPrice, adj, visited);\\n                x.first += z.second;\\n                x.second += min(z.first, z.second);\\n            }\\n        }\\n        return x;\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> infPrice(n, 0);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int d;\\n        for(vector<int> x: trips){\\n            vector<int> visited(n, 0);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n            q.push(x[0]);\\n            visited[x[0]] = 1;\\n            parent[x[0]] = x[0];\\n            while(!q.empty()){\\n                d = q.front();\\n                q.pop();\\n                if(d == x[1]) break;\\n                for(int y: adj[d]){\\n                    if(!visited[y]){\\n                        q.push(y);\\n                        visited[y] = 1;\\n                        parent[y] = d;\\n                    }\\n                }\\n            }\\n            while(d != x[0]){\\n                infPrice[d] += price[d];\\n                d = parent[d];\\n            }\\n            infPrice[d] += price[d];\\n        }\\n        vector<int> visited(n, 0);\\n        pair<int, int> x = engine(trips[0][0], infPrice, adj, visited);\\n        return min(x.first, x.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    pair<int, int> engine(int i, vector<int> &infPrice, vector<vector<int> > &adj, vector<int> &visited){\\n        pair<int, int> x = {infPrice[i]/2, infPrice[i]};\\n        visited[i] = 1;\\n        for(int y: adj[i]){\\n            if(!visited[y]){\\n                pair<int, int> z = engine(y, infPrice, adj, visited);\\n                x.first += z.second;\\n                x.second += min(z.first, z.second);\\n            }\\n        }\\n        return x;\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> infPrice(n, 0);\\n        vector<vector<int> > adj(n, vector<int>());\\n        for(vector<int> x: edges){\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        int d;\\n        for(vector<int> x: trips){\\n            vector<int> visited(n, 0);\\n            vector<int> parent(n, -1);\\n            queue<int> q;\\n            q.push(x[0]);\\n            visited[x[0]] = 1;\\n            parent[x[0]] = x[0];\\n            while(!q.empty()){\\n                d = q.front();\\n                q.pop();\\n                if(d == x[1]) break;\\n                for(int y: adj[d]){\\n                    if(!visited[y]){\\n                        q.push(y);\\n                        visited[y] = 1;\\n                        parent[y] = d;\\n                    }\\n                }\\n            }\\n            while(d != x[0]){\\n                infPrice[d] += price[d];\\n                d = parent[d];\\n            }\\n            infPrice[d] += price[d];\\n        }\\n        vector<int> visited(n, 0);\\n        pair<int, int> x = engine(trips[0][0], infPrice, adj, visited);\\n        return min(x.first, x.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428562,
                "title": "python-beats-100-231ms-cache-d-dfs-solution-w-explanation-the-importance-of-decomposition",
                "content": "# Approach\\n- Root the tree at the node with the most neighbors. This is a heuristic to get a flatter tree.\\n- In a tree, there is only one path between pairs of nodes.\\n- The path from a to b is found by first finding the path from a to root and the path from b to root. Next, we use these two root paths to find the deepest common ancestor of a and b, cal it DCA(a, b). Finally, the path from a to b is the concatenation of the path from a to the DCA(a, b) and the path from DCA(a, b) to b, each being a subset of the path from a/b to root.\\n- Now that we know how to compute paths between pairs of nodes, we compute all trip paths and tally which nodes are visited and how many times.\\n- This allows us to compute both `cost`, the cost without halving any prices, and `maxDiscount` (via `@cache`d DFS), the maximum discount possible by havling prices subject to the non-adjacent halvings restriction.\\n\\n# Problem decomposition\\nThis problem/solution highlights\\n- the importance of problem decomposition: the problem is only tractable if we break it down into several subproblems\\n- how choosing the correct data structure is vital to solving a problem efficiently. In this case, the data structures that allowed us to solve this problem efficiently was the tree and the visitCounter we constructed. Also, `@cache`d was used so that we don\\'t compute `getMaxDiscount(node, halfable)` at most once per `(node, halfable)` pair.\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = {root}\\n        while nodes0:\\n            nodes1 = set()\\n            for node0 in nodes0:\\n                nodes1 |= children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            nodes0 = nodes1\\n        def getPathToRoot(a):\\n            path = [None, a] # the None is a kludge to simplify the common ancestor logic in getPath(trip)\\n            while a != root:\\n                a = parent[a]\\n                path.append(a)\\n            # a == root\\n            return path\\n        \\n        def getPath(trip):\\n            a, b = trip\\n            if a == b:\\n                return [a]\\n            if a == root or b == root:\\n                if a == root:\\n                    a = b\\n                # a is the non-root node\\n                return getPathToRoot(a)[1:] # the 1 is to exclude the None (see first line of getPath)\\n            \\n            aRootPath = getPathToRoot(a)\\n            bRootPath = getPathToRoot(b)\\n            \\n            i = -2 # i=-1 not necessary since we know aRootPath[-1] == bRootPath[-1] == root\\n            while aRootPath[i] == bRootPath[i]:\\n                i -= 1\\n            # aRootPath[i] != bRootPath[i]\\n            # aRootPath[i+1] == bRootPath[i+1] is the deepest common ancestor of a and b\\n            \\n            # Alt 1\\n            path = aRootPath[1:i+1] + [aRootPath[i+1]] + bRootPath[1:i+1]\\n            # the 1 is to exclude the None (see first line of getPath)\\n            # the i+2, i+1 is to include the deepest common ancestor == aRootPath[i+1] == bRootPath[i+1] only once\\n            # the returned path is not in order, but that\\'s fine for our purposes\\n            # for completeness, the path in order is actually aRootPath[1:i+2] + list(reversed(bRootPath[1:i+1])) which is the the path from a to the deepest common ancestor of a and b, then to b\\n\\n            # # Alt 2\\n            # if i == -2: # i+2 == 0\\n            #     N = len(aRootPath)\\n            #     path = aRootPath[1:N] + bRootPath[1:i+1]\\n            # else:\\n            #     path = aRootPath[1:i+2] + bRootPath[1:i+1]\\n\\n            return path\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            visitCounter.update(getPath(trip))\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```\\n\\n---\\n\\n# Slightly different solution\\n\\nThis one integrates finding the path from a to b and updating the visit counter into one funciton saving us some operations and memory compared to the above.\\n\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        level = [None] * N\\n        lvl = 0\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = [root]\\n        while nodes0:\\n            nodes1 = []\\n            for node0 in nodes0:\\n                level[node0] = lvl\\n                nodes1 += children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            lvl += 1\\n            nodes0 = nodes1\\n        \\n        def updateVisitCounter(trip):\\n            a, b = trip\\n            if level[a] < level[b]:\\n                a, b = b, a\\n            # level[a] >= level[b], i.e. a is deeper than b\\n            d = level[a] - level[b]\\n            for _ in range(d):\\n                visitCounter[a] += 1\\n                a = parent[a]\\n            while a != b:\\n                visitCounter[a] += 1\\n                visitCounter[b] += 1\\n                a = parent[a]\\n                b = parent[b]\\n            # a == b == the deepest common ancestor of inputVal(a) and inputVal(b)\\n            visitCounter[a] += 1\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            updateVisitCounter(trip)\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = {root}\\n        while nodes0:\\n            nodes1 = set()\\n            for node0 in nodes0:\\n                nodes1 |= children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            nodes0 = nodes1\\n        def getPathToRoot(a):\\n            path = [None, a] # the None is a kludge to simplify the common ancestor logic in getPath(trip)\\n            while a != root:\\n                a = parent[a]\\n                path.append(a)\\n            # a == root\\n            return path\\n        \\n        def getPath(trip):\\n            a, b = trip\\n            if a == b:\\n                return [a]\\n            if a == root or b == root:\\n                if a == root:\\n                    a = b\\n                # a is the non-root node\\n                return getPathToRoot(a)[1:] # the 1 is to exclude the None (see first line of getPath)\\n            \\n            aRootPath = getPathToRoot(a)\\n            bRootPath = getPathToRoot(b)\\n            \\n            i = -2 # i=-1 not necessary since we know aRootPath[-1] == bRootPath[-1] == root\\n            while aRootPath[i] == bRootPath[i]:\\n                i -= 1\\n            # aRootPath[i] != bRootPath[i]\\n            # aRootPath[i+1] == bRootPath[i+1] is the deepest common ancestor of a and b\\n            \\n            # Alt 1\\n            path = aRootPath[1:i+1] + [aRootPath[i+1]] + bRootPath[1:i+1]\\n            # the 1 is to exclude the None (see first line of getPath)\\n            # the i+2, i+1 is to include the deepest common ancestor == aRootPath[i+1] == bRootPath[i+1] only once\\n            # the returned path is not in order, but that\\'s fine for our purposes\\n            # for completeness, the path in order is actually aRootPath[1:i+2] + list(reversed(bRootPath[1:i+1])) which is the the path from a to the deepest common ancestor of a and b, then to b\\n\\n            # # Alt 2\\n            # if i == -2: # i+2 == 0\\n            #     N = len(aRootPath)\\n            #     path = aRootPath[1:N] + bRootPath[1:i+1]\\n            # else:\\n            #     path = aRootPath[1:i+2] + bRootPath[1:i+1]\\n\\n            return path\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            visitCounter.update(getPath(trip))\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```\n```\\nclass Solution:\\n    def minimumTotalPrice(self, N: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [set() for _ in range(N)]\\n        for a, b in edges:\\n            adj[a].add(b)\\n            adj[b].add(a)\\n            \\n        # Tree\\n        # Efficiency heuristic: let the root be the node with the most neighbors as that might lead to a flatter tree\\n        root = max(range(N), key=lambda i: len(adj[i]))\\n        level = [None] * N\\n        lvl = 0\\n        parent = [None] * N\\n        children = adj\\n        nodes0 = [root]\\n        while nodes0:\\n            nodes1 = []\\n            for node0 in nodes0:\\n                level[node0] = lvl\\n                nodes1 += children[node0]\\n                for child in children[node0]:\\n                    children[child].remove(node0)\\n                    parent[child] = node0\\n            lvl += 1\\n            nodes0 = nodes1\\n        \\n        def updateVisitCounter(trip):\\n            a, b = trip\\n            if level[a] < level[b]:\\n                a, b = b, a\\n            # level[a] >= level[b], i.e. a is deeper than b\\n            d = level[a] - level[b]\\n            for _ in range(d):\\n                visitCounter[a] += 1\\n                a = parent[a]\\n            while a != b:\\n                visitCounter[a] += 1\\n                visitCounter[b] += 1\\n                a = parent[a]\\n                b = parent[b]\\n            # a == b == the deepest common ancestor of inputVal(a) and inputVal(b)\\n            visitCounter[a] += 1\\n        \\n        # Which nodes are visited across all the trips? And how many times?\\n        visitCounter = Counter()\\n        for trip in trips:\\n            updateVisitCounter(trip)\\n        \\n        # Without halving any prices, the total cost is\\n        cost = sum(price[node] * nodeVisitCnt for node, nodeVisitCnt in visitCounter.items())\\n        \\n        @cache\\n        def getMaxDiscount(node=root, halfable=True):\\n            discountIfNotHalved = sum(getMaxDiscount(child, halfable=True) for child in children[node])\\n            if not halfable or node not in visitCounter:\\n                return discountIfNotHalved\\n            # halfable and node in visitCounter\\n            discountIfHalved = (price[node] >> 1) * visitCounter[node] + sum(getMaxDiscount(child, halfable=False) for child in children[node])\\n            return max(discountIfNotHalved, discountIfHalved)\\n        \\n        return cost - getMaxDiscount()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428549,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.path=[]\\n        self.dp=[]\\n        for i in range(51):\\n            self.dp+=[[-1]*2]\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj=[]\\n        c1=[]\\n        for i in range(n):\\n            adj+=[[]]\\n            c1+=[[0]*n]\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n            c1[i[0]][i[1]]+=1\\n            c1[i[1]][i[0]]+=1\\n        c=[0]*n\\n        h={}\\n        for i in trips:\\n            v=[-1]*n\\n            self.solve(trips,adj,i[0],i[1],[i[0]],v)\\n            for i in self.path:\\n                c[i]+=1\\n            self.path=[]\\n        v=[-1]*n\\n        for i in range(n):\\n            c[i]*=price[i]\\n        l2=[]\\n        for i in range(n):\\n            l1=[]\\n            for j in range(n):\\n                if c1[i][j]==0:\\n                    l1+=[j]\\n            l2+=[l1]\\n        print(c)\\n        totpri=sum(c)\\n        a=self.maximum(adj,c,v,0,0)\\n        return totpri-a\\n    def maximum(self,adj,c,v,i,cur):\\n        v[cur]=1\\n        if self.dp[cur][i]!=-1:\\n            return self.dp[cur][i]\\n        if i==0:\\n            s=c[cur]//2\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s+=self.maximum(adj,c,v,1,j)\\n                    v[j]=-1\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            s=max(s,s1)\\n            self.dp[cur][i]=s\\n            return s\\n        else:\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            self.dp[cur][i]=s1\\n            return s1\\n    def solve(self,l,adj,i1,i2,l1,v):\\n        v[i1]=1\\n        if i1==i2:\\n            self.path=l1\\n        for i in adj[i1]:\\n            if v[i]==-1:\\n                self.solve(l,adj,i,i2,l1+[i],v)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.path=[]\\n        self.dp=[]\\n        for i in range(51):\\n            self.dp+=[[-1]*2]\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj=[]\\n        c1=[]\\n        for i in range(n):\\n            adj+=[[]]\\n            c1+=[[0]*n]\\n        for i in edges:\\n            adj[i[0]]+=[i[1]]\\n            adj[i[1]]+=[i[0]]\\n            c1[i[0]][i[1]]+=1\\n            c1[i[1]][i[0]]+=1\\n        c=[0]*n\\n        h={}\\n        for i in trips:\\n            v=[-1]*n\\n            self.solve(trips,adj,i[0],i[1],[i[0]],v)\\n            for i in self.path:\\n                c[i]+=1\\n            self.path=[]\\n        v=[-1]*n\\n        for i in range(n):\\n            c[i]*=price[i]\\n        l2=[]\\n        for i in range(n):\\n            l1=[]\\n            for j in range(n):\\n                if c1[i][j]==0:\\n                    l1+=[j]\\n            l2+=[l1]\\n        print(c)\\n        totpri=sum(c)\\n        a=self.maximum(adj,c,v,0,0)\\n        return totpri-a\\n    def maximum(self,adj,c,v,i,cur):\\n        v[cur]=1\\n        if self.dp[cur][i]!=-1:\\n            return self.dp[cur][i]\\n        if i==0:\\n            s=c[cur]//2\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s+=self.maximum(adj,c,v,1,j)\\n                    v[j]=-1\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            s=max(s,s1)\\n            self.dp[cur][i]=s\\n            return s\\n        else:\\n            s1=0\\n            for j in adj[cur]:\\n                if v[j]==-1:\\n                    s1+=self.maximum(adj,c,v,0,j)\\n                    v[j]=-1\\n            self.dp[cur][i]=s1\\n            return s1\\n    def solve(self,l,adj,i1,i2,l1,v):\\n        v[i1]=1\\n        if i1==i2:\\n            self.path=l1\\n        for i in adj[i1]:\\n            if v[i]==-1:\\n                self.solve(l,adj,i,i2,l1+[i],v)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428445,
                "title": "intuition-dfs-dp-memoization-detailed-explanation-c-o-n",
                "content": "# Intuition\\nWell, before approaching any question I would highly recommend you to ```always look at the constraints``` of the question.   \\n \\nAfter analysing it, you will realize that this **question is pretty Straight Forward to Implement**. You just need to code as the question demands. Hence I consider this question as one of the ```EASIEST question tagged Hard on LeetCode```\\n\\n# Analyzing Constraints & Framing of Solution\\n1. So let\\'s start by thinking about the time complexity to find out the route for each trip. Well, ```DFS``` is what comes in mind whenever we need to ```find out any route in Graphs or Trees```. Hence, for each trip, it\\'s time complexity would be ```O(N) where N is the number of Nodes.```\\n2. As the ```number of trips can be at max 100``` and ```number of nodes can be 50``` their ```product comes out to be 5000```. So a **basic DFS function to find out cost of each trip would work find.**\\n3. To find out ```which node we have to reduce and which not``` we can code a``` recursive function``` which can generate 2 possibilities, either the node value can be reduced by half or not.\\n4. **So, let\\'s analyse the time complexity of the recursive function.** As we have ```50 nodes each having 2 possibilities``` i.e. either to reduce the price or not, ```time complexity for recursive functions comes out to be 2^50``` which is quite high and would ```hence result in TLE.```\\n5. **What we can do to reduce it\\'s complexity then??** Pause for a second and give a thought. **I know you can find out the solution to this problem!!**\\n6. Well if you thought about ```something like DP or more specifically Memoization``` then yes, it will work fine. Hence, we will be using ```memoization technique to reduce it\\'s time complexity!!.``` \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n## 1) DFS Function\\nAs discussed above in point 2, we will be using DFS function to find out the cost for each trip. ```Along with it, we will be counting the nodes which are traversed in a trip.```\\nIf you thinking **why are we doing this??** Then a brief answer to your question is ```to figure out which node\\'s value we have to reduce.```\\n\\nBelow is the code of the same.\\n\\n```\\nint tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--; // This condition states that\\n        // the current node is not the part of our route to the \\n        // destination.\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n``` \\n**```used``` --> unordered_map which counts the frequency of the node used in trip.**\\n\\n\\n## 2.1) Recursive Function\\n**As discussed above in point 3**, we will be using recursive function to find out the nodes whose reducing the price will give us the minimum total cost of the trip.\\n\\n**I would first recommend you to have a look at the code below** then go for it\\'s explanation which I wrote below the code. Because ```I think the code is quite intuitive for all the readers who are trying LeetCode hard problems. ```\\n\\n```\\nint reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n          nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n\\n            for(auto it:adj[node]) if(it!=parent) \\n              rvalue+=reduceCost(it,node,prices);\\n            \\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n```\\n\\n**For those who have doubts regarding the code above,** I have used 2 variables ```rvalue and nvalue```. \\n```rvalue stores the total reduction cost when reduction of the current node is possible``` which can only be ```possible if the current node is atleast used once in any of the trips and parent of it is not being reduced.```\\n```nvalue on other hand calculates the cost when the current node\\'s value is not reduced by half.```\\n**And in the end to maximize the reduction we return the maximum of nvalue and rvalue.**\\n\\n## 2.2) Memoized version\\n**So here\\'s the memoized version of the same recursive code. Have a look first. Below the code I have discussed the main points of the function.**\\n\\n```\\nint reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            // we will pass true in canReduce each time as the \\n            // current node is not being reduced hence all the \\n            // neighbours can be reduced \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n```\\n**1. ```if(dp[node][canReduce]!=-1)```--> It means the for particular node the value is already being calculated.\\n2. ```dp[node][1]=max(rvalue,nvalue)```--> dp[node][1] means that the node can be reduced. In this scenrio we can either take the possibility of reducing the current node or we can continue without reducing the price of it. Hence ```max of both nvalue and rvalue``` is taken into consideration.\\n3.```dp[node][0]=nvalue```-->dp[node][0] means that the node cannot be reduced. Hence the only case is to continue without reducing it\\'s price to half.\\n4.```return dp[node][canReduce]```--> returning the value demanded**\\n\\n# Complexity\\n- Time complexity:\\n1. DFS Function: O(N)\\n2. Memoized version: O(N)\\n**Overall: O (N * Trip_Length)**\\n\\n# Code\\n## 1. Memoized Version\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<vector<int>>dp;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        dp.resize(n,vector<int>(2,-1));\\n        int res=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n    \\n        for(auto it:trips) res+=tripCost(it[0],it[1],-1,0,price);\\n        \\n        reduceCost(0,0,true,price);\\n        res-=max(dp[0][0],dp[0][1]);\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n## 2. Recursive Version\\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<bool>reduced;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) rvalue+=reduceCost(it,node,prices);\\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        reduced.resize(n,false);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int res=0;\\n        for(auto it:trips){\\n            res+=tripCost(it[0],it[1],-1,0,price);\\n        }\\n\\n        res-=reduceCost(0,0,price);\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**IF YOU HAVE ANY DOUBTS REGARDING THE CODE OR EXPLANATION REACH OUT COMMENT SECTION.**\\n**KINDLY UPVOTE IF YOU LIKED MY CODING AND EXPLANATION.** \\n**THANKS!! \\u2764\\uFE0F**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```always look at the constraints```\n```EASIEST question tagged Hard on LeetCode```\n```DFS```\n```find out any route in Graphs or Trees```\n```O(N) where N is the number of Nodes.```\n```number of trips can be at max 100```\n```number of nodes can be 50```\n```product comes out to be 5000```\n```which node we have to reduce and which not```\n``` recursive function```\n```50 nodes each having 2 possibilities```\n```time complexity for recursive functions comes out to be 2^50```\n```hence result in TLE.```\n```something like DP or more specifically Memoization```\n```memoization technique to reduce it\\'s time complexity!!.```\n```Along with it, we will be counting the nodes which are traversed in a trip.```\n```to figure out which node\\'s value we have to reduce.```\n```\\nint tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--; // This condition states that\\n        // the current node is not the part of our route to the \\n        // destination.\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n```\n```used```\n```I think the code is quite intuitive for all the readers who are trying LeetCode hard problems. ```\n```\\nint reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n          nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n\\n            for(auto it:adj[node]) if(it!=parent) \\n              rvalue+=reduceCost(it,node,prices);\\n            \\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n```\n```rvalue and nvalue```\n```rvalue stores the total reduction cost when reduction of the current node is possible```\n```possible if the current node is atleast used once in any of the trips and parent of it is not being reduced.```\n```nvalue on other hand calculates the cost when the current node\\'s value is not reduced by half.```\n```\\nint reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            // we will pass true in canReduce each time as the \\n            // current node is not being reduced hence all the \\n            // neighbours can be reduced \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n```\n```if(dp[node][canReduce]!=-1)```\n```dp[node][1]=max(rvalue,nvalue)```\n```max of both nvalue and rvalue```\n```dp[node][0]=nvalue```\n```return dp[node][canReduce]```\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<vector<int>>dp;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) \\n            val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,bool canReduce,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n\\n        if(dp[node][canReduce]!=-1) return dp[node][canReduce];\\n            \\n        for(auto it:adj[node]) if(it!=parent) \\n            nvalue+=reduceCost(it,node,true,prices);\\n\\n        if(canReduce and used.count(node)){\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) \\n                rvalue+=reduceCost(it,node,!canReduce,prices);\\n        }\\n\\n        dp[node][1]=max(rvalue,nvalue),dp[node][0]=nvalue;\\n        return dp[node][canReduce];\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        dp.resize(n,vector<int>(2,-1));\\n        int res=0;\\n        \\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n    \\n        for(auto it:trips) res+=tripCost(it[0],it[1],-1,0,price);\\n        \\n        reduceCost(0,0,true,price);\\n        res-=max(dp[0][0],dp[0][1]);\\n        return res;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<int,vector<int>>adj;\\n    unordered_map<int,int>used;\\n    vector<bool>reduced;\\n    \\n    int tripCost(int start,int end,int parent,int sum,vector<int>&prices){\\n        used[start]++;\\n        if(start==end) return sum+prices[start];\\n        \\n        int val=1e7;\\n        for(auto it:adj[start]){\\n            if(it!=parent) val = min(val,tripCost(it,end,start,sum+prices[start],prices));\\n        }\\n        \\n        if(val>=1e7) used[start]--;\\n        if(!used[start]) used.erase(start);\\n        return val;\\n    }\\n    \\n    int reduceCost(int node,int parent,vector<int>&prices){\\n        int nvalue=0,rvalue=0;\\n            \\n        for(auto it:adj[node]) if(it!=parent) nvalue+=reduceCost(it,node,prices);\\n\\n        if(!reduced[parent] and used.count(node)){\\n            reduced[node]=true;\\n            rvalue=used[node]*(prices[node]/2);\\n            for(auto it:adj[node]) if(it!=parent) rvalue+=reduceCost(it,node,prices);\\n            reduced[node]=false;\\n        }\\n\\n        return max(nvalue,rvalue);\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        reduced.resize(n,false);\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        int res=0;\\n        for(auto it:trips){\\n            res+=tripCost(it[0],it[1],-1,0,price);\\n        }\\n\\n        res-=reduceCost(0,0,price);\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427814,
                "title": "tag-easy-double-dfs-pre-computation-node-decision-to-color-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Pre-computation\\n2. DFS\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Pre-compute all nodes cost visited in every path.\\n2. Put 0 cost for non visited nodes.\\n3. Apply dfs from any node (say 0).\\n4. Decide whether to color current node or not on the go.\\n5. If you decide to color current node, then select all non-colored values from child nodes.\\n6. If you decide to not color current node, then select minimum value from colored and non-colored value for each child nodes.\\n7. Finally return the minimum value from calculate pair.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*N)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(int start, int end, vector<vector<int>> &edge, vector<int> &par, vector<int> &vis) {\\n        vis[start] = 1;\\n        for (auto x:edge[start]) {\\n            if (!vis[x]) {\\n                dfs(x, end, edge, par, vis);\\n                par[x] = start;\\n            }\\n        }\\n    }\\n\\n    pair<int, int> dfs_ans(int curr, int par, vector<vector<int>> &edge, vector<int> &price) {\\n        vector<int> colored;\\n        vector<int> non_colored;\\n        for (auto x:edge[curr]) {\\n            if (x!=par) {\\n                pair<int, int> p = dfs_ans(x, curr, edge, price);\\n                colored.push_back(p.first);\\n                non_colored.push_back(p.second);\\n            }\\n        }\\n        pair<int, int> p;\\n        // if current node is colored.\\n        p.first = price[curr]/2;\\n        for (auto x:non_colored) p.first += x;\\n\\n        // if current node is not colored.\\n        p.second = price[curr];\\n        for (int i=0;i<colored.size(); ++i) {\\n            p.second += min(colored[i], non_colored[i]);\\n        }\\n        return p;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> newPrice(n, 0);\\n        vector<vector<int>> v(n, vector<int>());\\n        for (auto x: edges) {\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n        }\\n        for (auto trip:trips) {\\n            vector<int> par(n, -1), vis(n, 0);\\n            dfs(trip[0], trip[1], v, par, vis);\\n            int c = trip[1];\\n            while(c!=-1) {\\n                newPrice[c]+=price[c];\\n                c = par[c];\\n            }\\n        }\\n        pair<int, int> p = dfs_ans(0, -1, v, newPrice);\\n        return min(p.first, p.second);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int start, int end, vector<vector<int>> &edge, vector<int> &par, vector<int> &vis) {\\n        vis[start] = 1;\\n        for (auto x:edge[start]) {\\n            if (!vis[x]) {\\n                dfs(x, end, edge, par, vis);\\n                par[x] = start;\\n            }\\n        }\\n    }\\n\\n    pair<int, int> dfs_ans(int curr, int par, vector<vector<int>> &edge, vector<int> &price) {\\n        vector<int> colored;\\n        vector<int> non_colored;\\n        for (auto x:edge[curr]) {\\n            if (x!=par) {\\n                pair<int, int> p = dfs_ans(x, curr, edge, price);\\n                colored.push_back(p.first);\\n                non_colored.push_back(p.second);\\n            }\\n        }\\n        pair<int, int> p;\\n        // if current node is colored.\\n        p.first = price[curr]/2;\\n        for (auto x:non_colored) p.first += x;\\n\\n        // if current node is not colored.\\n        p.second = price[curr];\\n        for (int i=0;i<colored.size(); ++i) {\\n            p.second += min(colored[i], non_colored[i]);\\n        }\\n        return p;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int> newPrice(n, 0);\\n        vector<vector<int>> v(n, vector<int>());\\n        for (auto x: edges) {\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n        }\\n        for (auto trip:trips) {\\n            vector<int> par(n, -1), vis(n, 0);\\n            dfs(trip[0], trip[1], v, par, vis);\\n            int c = trip[1];\\n            while(c!=-1) {\\n                newPrice[c]+=price[c];\\n                c = par[c];\\n            }\\n        }\\n        pair<int, int> p = dfs_ans(0, -1, v, newPrice);\\n        return min(p.first, p.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427637,
                "title": "python3-variant-of-robber-problem",
                "content": "# Explanation\\n\\nIgnoring the addition of trips, this problem is identical [House Robber iii](https://leetcode.com/problems/house-robber-iii/description/), except that we want to minimize the total cost and that \"robbing\" involves taking half of a node\\'s cost vs \"not robbing\" involves taking the entire node\\'s cost.\\n\\nIn order to account for the `trips` given, we can adopt a greedy approach; simply count the number of times each node is used among all trips and factor in this frequency in the robber calculation. Note that for each given trip, there\\'s exactly one path between the nodes because the graph is a tree.\\n\\n# Code\\n```\\nclass Solution:\\n    class TreeNode:\\n        def __init__(self, node_id, val):\\n            self._id = node_id\\n            self._val = val\\n            self._children = []\\n            self._parent = None\\n\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        self.setup(n, edges, price, trips)\\n        root_robbed, root_not_robbed = self.robber(self._root)\\n        return root_robbed\\n\\n    def robber(self, root):\\n        \"\"\"\\n        Returns [max_result_if_root_is_robbed, max_result_if_root_is_not_robbed]\\n        \"\"\"\\n        frq = self._node_counts[root] # contribution of this node is determined based on the number of times it\\'s visited over all trips\\n        amt_robbed = root._val // 2 * frq # suppose we rob; robbing in this case is halving the price and wanting to minimize the total price\\n        amt_not_robbed = root._val * frq # suppose we don\\'t rob; take the full amount\\n        for child in root._children:\\n            amt_if_child_robbed, amt_if_child_not_robbed = self.robber(child)\\n            amt_robbed += amt_if_child_not_robbed\\n            amt_not_robbed += amt_if_child_robbed\\n\\n        amt_robbed = min(amt_robbed, amt_not_robbed) # if we do rob, can send the lesser up anyways\\n        # print(f\"At node {root._id}, have rob: {amt_robbed}, not robbed: {amt_not_robbed}\")\\n        return (amt_robbed, amt_not_robbed)\\n\\n    def setup(self, n, edges, price, trips):\\n        \"\"\"\\n        Set up tree + initialize built-in members\\n        \"\"\"\\n        adj_list = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v = edge[0], edge[1]\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n\\n        seen = set([0])\\n        self._id_to_node = {}\\n        self._root = self.build(0, adj_list, seen, price)\\n        self._node_counts = Counter() # node_counts[node] = # times node appears in all trips\\n        for trip in trips:\\n            u, v = trip[0], trip[1]\\n            self.mark(self._id_to_node[u], self._id_to_node[v])\\n\\n    def build(self, root_id, adj_list, seen, price):\\n        root = self.TreeNode(root_id, price[root_id])\\n        self._id_to_node[root_id] = root\\n        for nb_id in adj_list[root_id]:\\n            if nb_id not in seen:\\n                seen.add(nb_id)\\n                nb = self.build(nb_id, adj_list, seen, price)\\n                nb._parent = root\\n                root._children.append(nb)\\n\\n        return root\\n\\n    def mark(self, node1, node2):\\n        \"\"\"\\n        Update frequency of nodes seen in path from node1 to node2.\\n        Because it\\'s a tree we can do this by manually walking up to the LCA and\\n        can guarantee that an LCA is found (at worst it\\'s the root)\\n        \"\"\"\\n        # Find LCA by looking at the depths of both targets\\n        node1_depth = self.get_level(self._root, node1, 0)\\n        node2_depth = self.get_level(self._root, node2, 0)\\n        d1, c1 = node1_depth, node1\\n        d2, c2 = node2_depth, node2\\n        while d1 > d2: # get c1 to align with c2\\n            self._node_counts[c1] += 1\\n            c1 = c1._parent\\n            d1 -= 1\\n        while d2 > d1 and c1 is not None: # otherwise get c2 to align with c1\\n            self._node_counts[c2] += 1\\n            c2 = c2._parent\\n            d2 -= 1\\n        while c1 != c2: # walk together until they both match\\n            self._node_counts[c1] += 1\\n            self._node_counts[c2] += 1\\n            c1 = c1._parent\\n            c2 = c2._parent\\n\\n        self._node_counts[c1] += 1 # c1 == c2 == LCA; note we increment LCA only once to not double count.\\n\\n    def get_level(self, root, target, depth):\\n        if root == target:\\n            return depth\\n\\n        for child in root._children:\\n            found_depth = self.get_level(child, target, depth + 1)\\n            if found_depth != -1:\\n                return found_depth\\n\\n        return -1\\n```\\n\\n# Implementation\\nThe code is a bit long, but this is mainly because I ended up explicitly creating a `TreeNode` object to represent the input graph. This can be avoided through the use of a few hashmaps but I found it easier to follow the logic this way.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    class TreeNode:\\n        def __init__(self, node_id, val):\\n            self._id = node_id\\n            self._val = val\\n            self._children = []\\n            self._parent = None\\n\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        self.setup(n, edges, price, trips)\\n        root_robbed, root_not_robbed = self.robber(self._root)\\n        return root_robbed\\n\\n    def robber(self, root):\\n        \"\"\"\\n        Returns [max_result_if_root_is_robbed, max_result_if_root_is_not_robbed]\\n        \"\"\"\\n        frq = self._node_counts[root] # contribution of this node is determined based on the number of times it\\'s visited over all trips\\n        amt_robbed = root._val // 2 * frq # suppose we rob; robbing in this case is halving the price and wanting to minimize the total price\\n        amt_not_robbed = root._val * frq # suppose we don\\'t rob; take the full amount\\n        for child in root._children:\\n            amt_if_child_robbed, amt_if_child_not_robbed = self.robber(child)\\n            amt_robbed += amt_if_child_not_robbed\\n            amt_not_robbed += amt_if_child_robbed\\n\\n        amt_robbed = min(amt_robbed, amt_not_robbed) # if we do rob, can send the lesser up anyways\\n        # print(f\"At node {root._id}, have rob: {amt_robbed}, not robbed: {amt_not_robbed}\")\\n        return (amt_robbed, amt_not_robbed)\\n\\n    def setup(self, n, edges, price, trips):\\n        \"\"\"\\n        Set up tree + initialize built-in members\\n        \"\"\"\\n        adj_list = [[] for _ in range(n)]\\n        for edge in edges:\\n            u, v = edge[0], edge[1]\\n            adj_list[u].append(v)\\n            adj_list[v].append(u)\\n\\n        seen = set([0])\\n        self._id_to_node = {}\\n        self._root = self.build(0, adj_list, seen, price)\\n        self._node_counts = Counter() # node_counts[node] = # times node appears in all trips\\n        for trip in trips:\\n            u, v = trip[0], trip[1]\\n            self.mark(self._id_to_node[u], self._id_to_node[v])\\n\\n    def build(self, root_id, adj_list, seen, price):\\n        root = self.TreeNode(root_id, price[root_id])\\n        self._id_to_node[root_id] = root\\n        for nb_id in adj_list[root_id]:\\n            if nb_id not in seen:\\n                seen.add(nb_id)\\n                nb = self.build(nb_id, adj_list, seen, price)\\n                nb._parent = root\\n                root._children.append(nb)\\n\\n        return root\\n\\n    def mark(self, node1, node2):\\n        \"\"\"\\n        Update frequency of nodes seen in path from node1 to node2.\\n        Because it\\'s a tree we can do this by manually walking up to the LCA and\\n        can guarantee that an LCA is found (at worst it\\'s the root)\\n        \"\"\"\\n        # Find LCA by looking at the depths of both targets\\n        node1_depth = self.get_level(self._root, node1, 0)\\n        node2_depth = self.get_level(self._root, node2, 0)\\n        d1, c1 = node1_depth, node1\\n        d2, c2 = node2_depth, node2\\n        while d1 > d2: # get c1 to align with c2\\n            self._node_counts[c1] += 1\\n            c1 = c1._parent\\n            d1 -= 1\\n        while d2 > d1 and c1 is not None: # otherwise get c2 to align with c1\\n            self._node_counts[c2] += 1\\n            c2 = c2._parent\\n            d2 -= 1\\n        while c1 != c2: # walk together until they both match\\n            self._node_counts[c1] += 1\\n            self._node_counts[c2] += 1\\n            c1 = c1._parent\\n            c2 = c2._parent\\n\\n        self._node_counts[c1] += 1 # c1 == c2 == LCA; note we increment LCA only once to not double count.\\n\\n    def get_level(self, root, target, depth):\\n        if root == target:\\n            return depth\\n\\n        for child in root._children:\\n            found_depth = self.get_level(child, target, depth + 1)\\n            if found_depth != -1:\\n                return found_depth\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427453,
                "title": "self-explanatory-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int>>mp;\\n    map<int, int>parent, level, actualPrice;\\n    vector<int>makeHalf, notHalf;\\n    void AssignLevelAndParent(int root, \\n    int currentLevel, \\n    int parentNode)\\n    {\\n        level[root] = currentLevel;\\n        parent[root] = parentNode;\\n        for(auto &child : mp[root])\\n        {\\n            if(child == parentNode)continue;\\n            AssignLevelAndParent(child, currentLevel + 1, root);\\n        }\\n\\n    }\\n    void ModifyPrice(vector<int>&price, int u, int v)\\n    {\\n        while(level[u] > level[v])\\n        {\\n            //u is down to v\\n            actualPrice[u] += price[u];\\n            u = parent[u];\\n        }\\n        while(level[v] > level[u])\\n        {\\n            //v is down to u\\n            actualPrice[v] += price[v];\\n            v = parent[v];\\n        }\\n        while(u != v)\\n        {\\n            actualPrice[u] += price[u];\\n            actualPrice[v] += price[v];\\n            u = parent[u]; v = parent[v];\\n        }\\n        actualPrice[u] += price[u];\\n\\n    }\\n    int FindMinSum(int root, int parentNode, bool half)\\n    {\\n        if(half)\\n        {\\n            if(makeHalf[root] != -1)return makeHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root] / 2;\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += FindMinSum(child, root, false);\\n            }\\n            return makeHalf[root] = answer;\\n            \\n        }\\n        else{\\n            if(notHalf[root] != -1)return notHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root];\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += min(FindMinSum(child, root, false),\\n                FindMinSum(child, root, true));\\n            }\\n            return notHalf[root] = answer;\\n        }\\n    }\\n    int minimumTotalPrice(int n, \\n    vector<vector<int>>& edges, \\n    vector<int>& price, \\n    vector<vector<int>>& trips) {\\n        for(auto &edge : edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        AssignLevelAndParent(0, 0, -1);\\n        for(auto &trip : trips)\\n        {\\n            int u = trip[0], v = trip[1];\\n            ModifyPrice(price, u, v);\\n        }\\n        makeHalf.resize(n, -1);\\n        notHalf.resize(n, -1);\\n        return min(FindMinSum(0, -1, true), FindMinSum(0, -1 , false));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int>>mp;\\n    map<int, int>parent, level, actualPrice;\\n    vector<int>makeHalf, notHalf;\\n    void AssignLevelAndParent(int root, \\n    int currentLevel, \\n    int parentNode)\\n    {\\n        level[root] = currentLevel;\\n        parent[root] = parentNode;\\n        for(auto &child : mp[root])\\n        {\\n            if(child == parentNode)continue;\\n            AssignLevelAndParent(child, currentLevel + 1, root);\\n        }\\n\\n    }\\n    void ModifyPrice(vector<int>&price, int u, int v)\\n    {\\n        while(level[u] > level[v])\\n        {\\n            //u is down to v\\n            actualPrice[u] += price[u];\\n            u = parent[u];\\n        }\\n        while(level[v] > level[u])\\n        {\\n            //v is down to u\\n            actualPrice[v] += price[v];\\n            v = parent[v];\\n        }\\n        while(u != v)\\n        {\\n            actualPrice[u] += price[u];\\n            actualPrice[v] += price[v];\\n            u = parent[u]; v = parent[v];\\n        }\\n        actualPrice[u] += price[u];\\n\\n    }\\n    int FindMinSum(int root, int parentNode, bool half)\\n    {\\n        if(half)\\n        {\\n            if(makeHalf[root] != -1)return makeHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root] / 2;\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += FindMinSum(child, root, false);\\n            }\\n            return makeHalf[root] = answer;\\n            \\n        }\\n        else{\\n            if(notHalf[root] != -1)return notHalf[root];\\n            int answer = 0;\\n            answer += actualPrice[root];\\n            for(auto &child : mp[root])\\n            {\\n                if(child == parentNode)continue;\\n                answer += min(FindMinSum(child, root, false),\\n                FindMinSum(child, root, true));\\n            }\\n            return notHalf[root] = answer;\\n        }\\n    }\\n    int minimumTotalPrice(int n, \\n    vector<vector<int>>& edges, \\n    vector<int>& price, \\n    vector<vector<int>>& trips) {\\n        for(auto &edge : edges)\\n        {\\n            int u = edge[0], v = edge[1];\\n            mp[u].push_back(v);\\n            mp[v].push_back(u);\\n        }\\n        AssignLevelAndParent(0, 0, -1);\\n        for(auto &trip : trips)\\n        {\\n            int u = trip[0], v = trip[1];\\n            ModifyPrice(price, u, v);\\n        }\\n        makeHalf.resize(n, -1);\\n        notHalf.resize(n, -1);\\n        return min(FindMinSum(0, -1, true), FindMinSum(0, -1 , false));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427334,
                "title": "python-dfs-dp",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        counter = Counter()\\n        def dfs(v, target, visited, pred):\\n            if v == target: return True\\n            if v in visited: return False\\n            visited.add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    pred[w] = v\\n                    if dfs(w, target, visited, pred): return True\\n            return False\\n        for v, w in trips:\\n            pred = defaultdict(lambda:-1)\\n            dfs(v, w, set(), pred)\\n            counter[w] += 1\\n            while pred[w] != -1:\\n                w = pred[w]\\n                counter[w] += 1\\n        @cache\\n        def DFS(u, v, isParentReduced):\\n            if isParentReduced:\\n                res = counter[v]*price[v]\\n                for w in G[v]:\\n                    if w == u: continue\\n                    res += DFS(v, w, False)\\n                return res\\n            res1 = counter[v]*price[v]//2\\n            for w in G[v]:\\n                if w == u: continue\\n                res1 += DFS(v, w, True)\\n            res2 = counter[v]*price[v]\\n            for w in G[v]:\\n                if w == u: continue\\n                res2 += DFS(v, w, False)\\n            return min(res1, res2)\\n        return DFS(-1, 0, False)\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom functools import cache\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        G = defaultdict(list)\\n        for v,w in edges:\\n            G[v].append(w)\\n            G[w].append(v)\\n        counter = Counter()\\n        def dfs(v, target, visited, pred):\\n            if v == target: return True\\n            if v in visited: return False\\n            visited.add(v)\\n            for w in G[v]:\\n                if w not in visited:\\n                    pred[w] = v\\n                    if dfs(w, target, visited, pred): return True\\n            return False\\n        for v, w in trips:\\n            pred = defaultdict(lambda:-1)\\n            dfs(v, w, set(), pred)\\n            counter[w] += 1\\n            while pred[w] != -1:\\n                w = pred[w]\\n                counter[w] += 1\\n        @cache\\n        def DFS(u, v, isParentReduced):\\n            if isParentReduced:\\n                res = counter[v]*price[v]\\n                for w in G[v]:\\n                    if w == u: continue\\n                    res += DFS(v, w, False)\\n                return res\\n            res1 = counter[v]*price[v]//2\\n            for w in G[v]:\\n                if w == u: continue\\n                res1 += DFS(v, w, True)\\n            res2 = counter[v]*price[v]\\n            for w in G[v]:\\n                if w == u: continue\\n                res2 += DFS(v, w, False)\\n            return min(res1, res2)\\n        return DFS(-1, 0, False)\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427204,
                "title": "easy-readable-dp-dfs-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading ques the first thing that click was i will have to try all ways . Hints to use recursion . \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nQ1 : Do I have to calculate trip cost at every traversal ?\\nAns :- I came up with solution why not calculate total trip cost and calculated every node in total trip . \\nNow tries to find max cost that i can reduce . \\n\\nQ2 : How to write recursion ?\\n   \\nAt every node i can pick it or not pick it . If i picked then price cut will be updated . \\nAlso have to maintain pick variable to find out parent is picked or not . \\n\\nQ3 : Reduce Tc ? \\nOnce the recursive code is working just memoize it . \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n\\n    int solve(int ind  , int pick , vector<vector<int>> &adj ,  vector<int>&visited , vector<int>& price , vector<int>&freq , vector<vector<int>>&dp){\\n             \\n             if(visited[ind]) return 0 ; \\n             if(dp[ind][pick] != -1) return dp[ind][pick] ; \\n             if(pick){\\n                int a = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp ) ; \\n                    }\\n                    \\n                }\\n                visited[ind] = 0 ; \\n                return dp[ind][pick] =  a ; \\n             }\\n             else{\\n\\n                int a = 0  , b = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp  ) ; \\n                    }\\n                }\\n               \\n               b += price[ind]*freq[ind]*0.5 ; \\n                for(auto x : adj[ind]){\\n                   if(!visited[x]){\\n                        b += solve(x , 1 , adj , visited , price , freq , dp ) ; \\n                    }\\n                }\\n                visited[ind] = 0 ; \\n\\n                 return dp[ind][pick] =  max(a , b ) ; \\n\\n             }\\n\\n             return 0 ; \\n    }\\n\\n\\n    bool dfs(int src , int dest , vector<vector<int>> &adj ,vector<int>& price , vector<int>&freq  ,  int par , int &temp   ){\\n         \\n         if(src == dest){\\n             freq[src]++; \\n             temp += price[dest] ; \\n             return true ;  \\n         }\\n\\n        \\n         temp  += price[src]  ;\\n         freq[src]++; \\n\\n         for(auto node : adj[src]){\\n             if(node != par){\\n                 bool check   = dfs(node , dest , adj , price , freq  , src , temp ) ; \\n                 if(check) return true ; \\n             }\\n         }\\n\\n         temp -= price[src] ; \\n         freq[src]-- ; \\n\\n\\n         return false  ; \\n     }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n\\n          vector<vector<int>> adj(n) ; \\n          vector<int>freq(n, 0 ) ; \\n          vector<int>visited(n , 0 ) ; \\n          vector<vector<int>>dp(n , vector<int>(2 , -1 )) ; \\n          for(int i = 0 ; i < edges.size() ; i++){\\n              int  u = edges[i][0] ; \\n              int v = edges[i][1] ; \\n\\n              adj[u].push_back(v) ; \\n              adj[v].push_back(u) ; \\n          } \\n\\n          int cost = 0 ; \\n\\n          for(int i = 0 ; i < trips.size() ; i++){\\n              int src = trips[i][0] ; \\n              int dest = trips[i][1] ; \\n              int temp = 0 ; \\n              int par = -1 ; \\n              bool a =  dfs(src ,dest , adj ,price , freq ,  par , temp  ) ; \\n              cost += temp ; \\n          }\\n          \\n\\n         \\n          int  cut = solve( 0 , 0 , adj , visited , price , freq , dp ) ; \\n\\n          return cost - cut ; \\n       \\n       }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\n    int solve(int ind  , int pick , vector<vector<int>> &adj ,  vector<int>&visited , vector<int>& price , vector<int>&freq , vector<vector<int>>&dp){\\n             \\n             if(visited[ind]) return 0 ; \\n             if(dp[ind][pick] != -1) return dp[ind][pick] ; \\n             if(pick){\\n                int a = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp ) ; \\n                    }\\n                    \\n                }\\n                visited[ind] = 0 ; \\n                return dp[ind][pick] =  a ; \\n             }\\n             else{\\n\\n                int a = 0  , b = 0 ; \\n                visited[ind] =1 ; \\n                for(auto x : adj[ind]){\\n                    if(!visited[x]){\\n                        a += solve(x , 0 , adj , visited , price , freq , dp  ) ; \\n                    }\\n                }\\n               \\n               b += price[ind]*freq[ind]*0.5 ; \\n                for(auto x : adj[ind]){\\n                   if(!visited[x]){\\n                        b += solve(x , 1 , adj , visited , price , freq , dp ) ; \\n                    }\\n                }\\n                visited[ind] = 0 ; \\n\\n                 return dp[ind][pick] =  max(a , b ) ; \\n\\n             }\\n\\n             return 0 ; \\n    }\\n\\n\\n    bool dfs(int src , int dest , vector<vector<int>> &adj ,vector<int>& price , vector<int>&freq  ,  int par , int &temp   ){\\n         \\n         if(src == dest){\\n             freq[src]++; \\n             temp += price[dest] ; \\n             return true ;  \\n         }\\n\\n        \\n         temp  += price[src]  ;\\n         freq[src]++; \\n\\n         for(auto node : adj[src]){\\n             if(node != par){\\n                 bool check   = dfs(node , dest , adj , price , freq  , src , temp ) ; \\n                 if(check) return true ; \\n             }\\n         }\\n\\n         temp -= price[src] ; \\n         freq[src]-- ; \\n\\n\\n         return false  ; \\n     }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n\\n          vector<vector<int>> adj(n) ; \\n          vector<int>freq(n, 0 ) ; \\n          vector<int>visited(n , 0 ) ; \\n          vector<vector<int>>dp(n , vector<int>(2 , -1 )) ; \\n          for(int i = 0 ; i < edges.size() ; i++){\\n              int  u = edges[i][0] ; \\n              int v = edges[i][1] ; \\n\\n              adj[u].push_back(v) ; \\n              adj[v].push_back(u) ; \\n          } \\n\\n          int cost = 0 ; \\n\\n          for(int i = 0 ; i < trips.size() ; i++){\\n              int src = trips[i][0] ; \\n              int dest = trips[i][1] ; \\n              int temp = 0 ; \\n              int par = -1 ; \\n              bool a =  dfs(src ,dest , adj ,price , freq ,  par , temp  ) ; \\n              cost += temp ; \\n          }\\n          \\n\\n         \\n          int  cut = solve( 0 , 0 , adj , visited , price , freq , dp ) ; \\n\\n          return cost - cut ; \\n       \\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426658,
                "title": "c-dfs-dp-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>list[50];\\n    int cnt[50];\\n    \\n    int f_visit(int cur, int end, int par) {\\n        ++cnt[cur];\\n        if(cur == end) return end;\\n        int e = -1;\\n        for(int next : list[cur]){\\n            if(next == par) continue;\\n            e = f_visit(next, end, cur);\\n            if(e == end) return e;\\n            if(e != end) --cnt[next];\\n        }\\n        return e;\\n    }\\n    \\n    int f_min(int a, int b) {\\n        if(a < b) return a;\\n        return b;\\n    }\\n    \\n    int dp[50][2];\\n    void f_get_min(int cur, int par, vector<int>& price) {                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            f_get_min(next, cur, price);\\n        }\\n                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            dp[cur][0] += f_min(dp[next][0] , dp[next][1]);\\n            dp[cur][1] += dp[next][0];\\n        }\\n        \\n        dp[cur][0] += price[cur] * cnt[cur];\\n        dp[cur][1] += (price[cur] / 2) * cnt[cur];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(vector<int> &cur : edges) {\\n            list[cur[0]].push_back(cur[1]);\\n            list[cur[1]].push_back(cur[0]);\\n        }\\n        \\n        for(vector<int> &cur : trips) f_visit(cur[0], cur[1], -1);\\n\\n        // total_sum\\n        int tot_sum = 0;\\n        for (int i = 0; i < n; ++i) tot_sum += price[i] * cnt[i];\\n        \\n        f_get_min(0, -1, price);\\n        \\n        return f_min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>list[50];\\n    int cnt[50];\\n    \\n    int f_visit(int cur, int end, int par) {\\n        ++cnt[cur];\\n        if(cur == end) return end;\\n        int e = -1;\\n        for(int next : list[cur]){\\n            if(next == par) continue;\\n            e = f_visit(next, end, cur);\\n            if(e == end) return e;\\n            if(e != end) --cnt[next];\\n        }\\n        return e;\\n    }\\n    \\n    int f_min(int a, int b) {\\n        if(a < b) return a;\\n        return b;\\n    }\\n    \\n    int dp[50][2];\\n    void f_get_min(int cur, int par, vector<int>& price) {                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            f_get_min(next, cur, price);\\n        }\\n                \\n        for(int next : list[cur]) {\\n            if(next == par) continue;\\n            dp[cur][0] += f_min(dp[next][0] , dp[next][1]);\\n            dp[cur][1] += dp[next][0];\\n        }\\n        \\n        dp[cur][0] += price[cur] * cnt[cur];\\n        dp[cur][1] += (price[cur] / 2) * cnt[cur];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        for(vector<int> &cur : edges) {\\n            list[cur[0]].push_back(cur[1]);\\n            list[cur[1]].push_back(cur[0]);\\n        }\\n        \\n        for(vector<int> &cur : trips) f_visit(cur[0], cur[1], -1);\\n\\n        // total_sum\\n        int tot_sum = 0;\\n        for (int i = 0; i < n; ++i) tot_sum += price[i] * cnt[i];\\n        \\n        f_get_min(0, -1, price);\\n        \\n        return f_min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426389,
                "title": "complete-easy-explanation-dfs-x-dp-c",
                "content": "**Intuition**\\nThe questions asks for **minimum** total price sum and the contraint on n given is also small which gives us a direct hint that the question can be of ***Dynamic Programming***.\\n\\nNow DP usually goes with choices ie we can either have it or not have it. In this question we can either reduce the price of a particular node by half or we can keep it unchanged. Thus it will be suitable to have a 2d dp with the first state being the current node and the second state indicating whether the price of the current node is halfed or not. Initally every value of the 2d matrix will be -1.\\n\\nAnother good observation which we can make is with the trips matrix. Instead of calling dfs again and again for calculating the cost of the whole trip given a particular node is halfed (or not) will be very time consuming. Instead we can make use of the ***frequency array*** and add to the cost the value of price[u] * freq[u] or price[u]/2 * freq[u] and store it in our 2d dp matrix.\\n\\nThe frequency array can be calculated easily using a single ***dfs*** and checking at each step whether a particular child is able to reach destination via some path or not.\\n\\n***Code:***\\n\\n```class Solution {\\npublic:\\n    vector< vector < int>> adj, dp;\\n    vector < int> freq;\\n    \\n    bool dfs(int u, int p, int desti)\\n    {\\n        if (u == desti)\\n        {\\n            freq[u]++;\\n            return true;\\n        }\\n        \\n        for (auto v: adj[u])\\n        {\\n            if (v == p)\\n                continue;\\n            //Checking if child is able to reach destination\\n            if (dfs(v, u, desti))\\n            {\\n                freq[u]++;\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    \\n    int getMin (int u, bool isHalved, int parent, vector <int>& price)\\n    {\\n\\t\\t//Memoization\\n        if (dp[u][isHalved] != -1)\\n            return dp[u][isHalved];\\n        \\n        int cost = 0;\\n        for (auto v: adj[u])\\n        {\\n            if (v == parent)\\n                continue;\\n            if (isHalved)\\n                cost += getMin(v, false, u, price);\\n            else\\n                cost += min(getMin(v, false, u, price), getMin(v, true, u, price));\\n        }\\n        \\n        if (isHalved)\\n            dp[u][isHalved] = (price[u]/2 * freq[u]) + cost;\\n        else\\n            dp[u][isHalved] = (price[u] * freq[u]) + cost;\\n        \\n        return dp[u][isHalved];\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n           \\n        adj = vector < vector < int>> (n);\\n        dp = vector < vector < int>> (n, vector < int> (2, -1));\\n        freq = vector < int> (n, 0);\\n        for (auto x:edges)\\n        {\\n            adj[x[0]].push_back(x[1]);\\n            adj[x[1]].push_back(x[0]);\\n        }\\n        \\n        for (auto x: trips)\\n            dfs(x[0], -1, x[1]);\\n        \\n        \\n        return min(getMin(0, true, -1, price), getMin(0, false, -1, price));\\n        \\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector< vector < int>> adj, dp;\\n    vector < int> freq;\\n    \\n    bool dfs(int u, int p, int desti)\\n    {\\n        if (u == desti)\\n        {\\n            freq[u]++;\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3426079,
                "title": "dfs-dp-easy-expalination-good-question-stucked-part-too-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAccording to question :\\n- I am finding out from teh path function the contribution of every node(helper vector) and what will be the sum of of the trips which will be visited by the trips (in ans ).\\n- Adjacent element can take ( more of hoyse robber problem I )\\n- I am finding the sum of highest contri which can be visited by the trips \\n- We need to count the contri of every node because if we only take that i have visited this elemnt(Then may be it is giving you the larger sum but the one which is contributng to smaller path sum have occured multiple time and increase the net sum )// I have stucked here only I was firstly taking out the vector which give me maxium sum and the n doing half the prices and checking for contri that is hectic for sure ... so if you too then comment now will never make this mistake .\\n- Now if i send the contri in the dp and according to it find out the what the maximum score till that particular node .\\n- Then we can simply take that value do the half of it and will delete from the net answer of trips  .\\n- ans -val(came from dp)/2 ;\\n- it amy occur to have the trips totally not connected with each other so you have to make that last loop so that you will not leave any trip .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n   I have expalined the approach above You can refer to it .\\n  Thanks for reading it \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    adj - matrix  =O(n) (As there are at max n-1 edges)\\n    trip-loop = O(n*t) ;// trips \\n    trip loop inside memoization & Dp array = O(n*2) ;\\n    //AT max will search for every node  ;\\n    Overall O(n*t) ;\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    adj - matrix  =O(n+N) (As there are at max n-1 edges)\\n    contribution matrix(repetation) = O(n);\\n    dp = O(n*2) ;\\n    Overall: =O(n);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool path(vector<vector<int>>& adj ,vector<int>& help , vector<int> & prices, int i ,  int end , int prev , int & ans  )\\n    {\\n        if(i==end)\\n        {\\n            help[i]++;\\n            ans+= prices[i] ;// total trip contri \\n            return true;\\n        }\\n        bool hey =false ;\\n        for( int j = 0 ;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev)\\n            {\\n                bool is =path(adj ,help, prices , adj[i][j]  , end , i ,ans); \\n                hey =hey|is ;\\n            }\\n        }\\n        if(hey )\\n        {\\n            help[i]++;\\n            ans += prices[i] ;\\n        }\\n        return hey ;\\n    }\\n\\n    int maximum_path(vector<vector<int>>& adj ,vector<int>& helper , vector<int>& prices , int i , bool me,int prev ,vector<vector<int>>& dp  )\\n    {\\n        if(dp[i][me]!=-1)\\n        {\\n            return dp[i][me] ;\\n        }\\n        int right =0 , left =0 ;\\n        for( int j=0;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev && helper[adj[i][j]]>0 )\\n            {\\n                if(me== false)\\n                {\\n                    left+=  maximum_path(adj , helper , prices ,adj[i][j] ,true , i ,dp);\\n                }\\n                right+=   maximum_path(adj , helper , prices, adj[i][j] , false , i,dp) ;\\n            }\\n         }  \\n         int k =left+(helper[i]*prices[i]);\\n         cout<<k<<\" \"<<right<<endl;\\n         if(k>right && me ==false )\\n         {\\n             dp[i][0] =k ; \\n             return dp[i][0] ;\\n         }\\n         else{\\n            dp[i][1]= right ;\\n            return dp[i][1];\\n         }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj (n);\\n        for(auto p :edges)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> repetation(n,0);\\n        int ans =0 ;\\n        for(auto trip:trips)\\n        {\\n            bool is= path(adj ,repetation, price, trip[0] , trip[1] , -1, ans  );\\n        }\\n        vector<vector<int>> dp(n ,vector<int>(2,-1));\\n        for(auto trip: trips)\\n        {\\n            if(dp[trip[0]][0]==-1 && dp[trip[0]][1]==-1)\\n            {\\n                int val = maximum_path(adj , repetation , price , trip[0] , false , -1 ,dp);\\n                cout<<val<<endl;\\n                ans= ans-val/2;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool path(vector<vector<int>>& adj ,vector<int>& help , vector<int> & prices, int i ,  int end , int prev , int & ans  )\\n    {\\n        if(i==end)\\n        {\\n            help[i]++;\\n            ans+= prices[i] ;// total trip contri \\n            return true;\\n        }\\n        bool hey =false ;\\n        for( int j = 0 ;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev)\\n            {\\n                bool is =path(adj ,help, prices , adj[i][j]  , end , i ,ans); \\n                hey =hey|is ;\\n            }\\n        }\\n        if(hey )\\n        {\\n            help[i]++;\\n            ans += prices[i] ;\\n        }\\n        return hey ;\\n    }\\n\\n    int maximum_path(vector<vector<int>>& adj ,vector<int>& helper , vector<int>& prices , int i , bool me,int prev ,vector<vector<int>>& dp  )\\n    {\\n        if(dp[i][me]!=-1)\\n        {\\n            return dp[i][me] ;\\n        }\\n        int right =0 , left =0 ;\\n        for( int j=0;j<adj[i].size() ;j++)\\n        {\\n            if(adj[i][j]!=prev && helper[adj[i][j]]>0 )\\n            {\\n                if(me== false)\\n                {\\n                    left+=  maximum_path(adj , helper , prices ,adj[i][j] ,true , i ,dp);\\n                }\\n                right+=   maximum_path(adj , helper , prices, adj[i][j] , false , i,dp) ;\\n            }\\n         }  \\n         int k =left+(helper[i]*prices[i]);\\n         cout<<k<<\" \"<<right<<endl;\\n         if(k>right && me ==false )\\n         {\\n             dp[i][0] =k ; \\n             return dp[i][0] ;\\n         }\\n         else{\\n            dp[i][1]= right ;\\n            return dp[i][1];\\n         }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj (n);\\n        for(auto p :edges)\\n        {\\n            adj[p[0]].push_back(p[1]);\\n            adj[p[1]].push_back(p[0]);\\n        }\\n        vector<int> repetation(n,0);\\n        int ans =0 ;\\n        for(auto trip:trips)\\n        {\\n            bool is= path(adj ,repetation, price, trip[0] , trip[1] , -1, ans  );\\n        }\\n        vector<vector<int>> dp(n ,vector<int>(2,-1));\\n        for(auto trip: trips)\\n        {\\n            if(dp[trip[0]][0]==-1 && dp[trip[0]][1]==-1)\\n            {\\n                int val = maximum_path(adj , repetation , price , trip[0] , false , -1 ,dp);\\n                cout<<val<<endl;\\n                ans= ans-val/2;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3425378,
                "title": "dfs-each-trip-to-count-visits-dp-maximise-nodes-selected-on-savings-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for (auto & e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> c(n);\\n        for (auto & t : trips) {\\n            vector<bool> seen(n);\\n            stack<pair<int, vector<int>>> s;\\n            s.emplace(t[0], vector<int>());\\n            while (!s.empty()) {\\n                auto [cur, path] = s.top(); s.pop();\\n                if (seen[cur]) continue;\\n                seen[cur] = 1;\\n                vector<int> newpath(path);\\n                newpath.push_back(cur);\\n                if (cur == t[1]) {\\n                    for (int x : newpath) {\\n                        ++c[x];                        \\n                    }\\n                    break;\\n                }\\n                for (int x : adj[cur]) s.emplace(x, newpath);\\n            }\\n        }\\n        int cost = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cost += price[i] * c[i];\\n        }\\n        Node* root = new Node(0, price[0] * c[0] / 2, 0);\\n        queue<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            auto cur = s.front(); s.pop();\\n            for (int j : adj[cur->id]) {\\n                if (cur->par == 0 || j != cur->par->id) {\\n                    Node* neW = new Node(j, price[j] * c[j] / 2, cur);\\n                    cur->child.push_back(neW);\\n                    s.push(neW);\\n                }\\n            }\\n        }\\n        int S = save(root);\\n        return cost - S;\\n    }\\n    struct Node {\\n        int id, val;\\n        vector<Node*> child;\\n        Node* par;\\n        Node(int i, int x, Node* p) : id(i), val(x), child(), par(p) {}\\n    };\\n    unordered_map<int, int> mem;\\n    int save(Node* u) {\\n        if (mem.count(u->id)) return mem[u->id];\\n        int donttake = 0, grand = 0;\\n        for (auto x : u->child) {\\n            donttake += save(x);\\n            for (auto y : x->child) {\\n                grand += save(y);\\n            }\\n        }\\n        mem[u->id] = max(u->val+grand, donttake);\\n        return mem[u->id];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for (auto & e : edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        vector<int> c(n);\\n        for (auto & t : trips) {\\n            vector<bool> seen(n);\\n            stack<pair<int, vector<int>>> s;\\n            s.emplace(t[0], vector<int>());\\n            while (!s.empty()) {\\n                auto [cur, path] = s.top(); s.pop();\\n                if (seen[cur]) continue;\\n                seen[cur] = 1;\\n                vector<int> newpath(path);\\n                newpath.push_back(cur);\\n                if (cur == t[1]) {\\n                    for (int x : newpath) {\\n                        ++c[x];                        \\n                    }\\n                    break;\\n                }\\n                for (int x : adj[cur]) s.emplace(x, newpath);\\n            }\\n        }\\n        int cost = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cost += price[i] * c[i];\\n        }\\n        Node* root = new Node(0, price[0] * c[0] / 2, 0);\\n        queue<Node*> s;\\n        s.push(root);\\n        while (!s.empty()) {\\n            auto cur = s.front(); s.pop();\\n            for (int j : adj[cur->id]) {\\n                if (cur->par == 0 || j != cur->par->id) {\\n                    Node* neW = new Node(j, price[j] * c[j] / 2, cur);\\n                    cur->child.push_back(neW);\\n                    s.push(neW);\\n                }\\n            }\\n        }\\n        int S = save(root);\\n        return cost - S;\\n    }\\n    struct Node {\\n        int id, val;\\n        vector<Node*> child;\\n        Node* par;\\n        Node(int i, int x, Node* p) : id(i), val(x), child(), par(p) {}\\n    };\\n    unordered_map<int, int> mem;\\n    int save(Node* u) {\\n        if (mem.count(u->id)) return mem[u->id];\\n        int donttake = 0, grand = 0;\\n        for (auto x : u->child) {\\n            donttake += save(x);\\n            for (auto y : x->child) {\\n                grand += save(y);\\n            }\\n        }\\n        mem[u->id] = max(u->val+grand, donttake);\\n        return mem[u->id];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425374,
                "title": "c-dfs-dp",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  // All the solution info.\\n  int n = -1;\\n  vector<int> price;\\n  vector<unordered_set<int>> tree;\\n  unordered_map<int, int> freq;\\n  \\n  \\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& prc, vector<vector<int>>& trips) {\\n    // Record all info.\\n    this->n = n;\\n    tree.resize(n);\\n    price = move(prc);\\n    for (auto& edge : edges) {\\n      tree[edge[0]].insert(edge[1]);\\n      tree[edge[1]].insert(edge[0]);\\n    }\\n    \\n    // Find how many times each node is visited\\n    // for all the paths through DFS.\\n    for (auto& trip : trips) {\\n      // trip[0] can be the root of the tree with\\n      // -1 as parent since it doesn\\'t matter.\\n      dfs(trip[0], trip[1], -1);\\n    }\\n    \\n    // Get any leaf node with children <= 1 as root.\\n    int root = getAnyLeaf();\\n    \\n    // Initialize the caches for DP.\\n    withHalving = vector<int>(n, -1);\\n    withoutHalving = vector<int>(n, -1);\\n    \\n    // Get the optimal halving strategy.\\n    return min(getMin(root, true, -1),\\n               getMin(root, false, -1));\\n  }\\n  \\n  bool dfs(int idx, int dst, int parent) {\\n    // We have reached the destination.\\n    if (idx == dst) {\\n      freq[idx]++;\\n      return true;\\n    }\\n    \\n    for (int child : tree[idx]) {\\n      if (child == parent)\\n        continue;\\n      // Check if child is able to reach the destination.\\n      if (dfs(child, dst, idx)) {\\n        freq[idx]++;\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /*\\n  Use DP to get the best halving strategy.\\n  For each node, we can either halve it or not.\\n  If we halve it, we cannot halve the child.\\n  If we don\\'t halve it, then we have a choice for\\n  the child.\\n  We can cache the result based on whether we halve\\n  it or not.\\n  */ \\n  vector<int> withHalving, withoutHalving;\\n  int getMin(int idx, bool with, int parent) {\\n    if (with && withHalving[idx] != -1) {\\n      return withHalving[idx];\\n    }\\n    if (!with && withoutHalving[idx] != -1) {\\n      return withoutHalving[idx];\\n    }\\n    int childCost = 0;\\n    for (int child : tree[idx]) {\\n      if (child == parent) continue;\\n      if (with) {\\n        childCost += getMin(child, false, idx);\\n      } else {\\n        childCost += min(getMin(child, true, idx),\\n                         getMin(child, false, idx));\\n      }\\n    }\\n    if (with) {\\n      int cost = (0.5 * price[idx] * freq[idx]) + childCost;\\n      withHalving[idx] = cost;\\n      return cost;\\n    } else {\\n      int cost = (price[idx] * freq[idx]) + childCost;\\n      withoutHalving[idx] = cost;\\n      return cost;\\n    }\\n  }\\n  \\n  // Helper function for getting any leaf.\\n  int getAnyLeaf() {\\n    for (int i = 0; i < n; ++i) {\\n      if (tree[i].size() <= 1) return i;\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  // All the solution info.\\n  int n = -1;\\n  vector<int> price;\\n  vector<unordered_set<int>> tree;\\n  unordered_map<int, int> freq;\\n  \\n  \\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& prc, vector<vector<int>>& trips) {\\n    // Record all info.\\n    this->n = n;\\n    tree.resize(n);\\n    price = move(prc);\\n    for (auto& edge : edges) {\\n      tree[edge[0]].insert(edge[1]);\\n      tree[edge[1]].insert(edge[0]);\\n    }\\n    \\n    // Find how many times each node is visited\\n    // for all the paths through DFS.\\n    for (auto& trip : trips) {\\n      // trip[0] can be the root of the tree with\\n      // -1 as parent since it doesn\\'t matter.\\n      dfs(trip[0], trip[1], -1);\\n    }\\n    \\n    // Get any leaf node with children <= 1 as root.\\n    int root = getAnyLeaf();\\n    \\n    // Initialize the caches for DP.\\n    withHalving = vector<int>(n, -1);\\n    withoutHalving = vector<int>(n, -1);\\n    \\n    // Get the optimal halving strategy.\\n    return min(getMin(root, true, -1),\\n               getMin(root, false, -1));\\n  }\\n  \\n  bool dfs(int idx, int dst, int parent) {\\n    // We have reached the destination.\\n    if (idx == dst) {\\n      freq[idx]++;\\n      return true;\\n    }\\n    \\n    for (int child : tree[idx]) {\\n      if (child == parent)\\n        continue;\\n      // Check if child is able to reach the destination.\\n      if (dfs(child, dst, idx)) {\\n        freq[idx]++;\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /*\\n  Use DP to get the best halving strategy.\\n  For each node, we can either halve it or not.\\n  If we halve it, we cannot halve the child.\\n  If we don\\'t halve it, then we have a choice for\\n  the child.\\n  We can cache the result based on whether we halve\\n  it or not.\\n  */ \\n  vector<int> withHalving, withoutHalving;\\n  int getMin(int idx, bool with, int parent) {\\n    if (with && withHalving[idx] != -1) {\\n      return withHalving[idx];\\n    }\\n    if (!with && withoutHalving[idx] != -1) {\\n      return withoutHalving[idx];\\n    }\\n    int childCost = 0;\\n    for (int child : tree[idx]) {\\n      if (child == parent) continue;\\n      if (with) {\\n        childCost += getMin(child, false, idx);\\n      } else {\\n        childCost += min(getMin(child, true, idx),\\n                         getMin(child, false, idx));\\n      }\\n    }\\n    if (with) {\\n      int cost = (0.5 * price[idx] * freq[idx]) + childCost;\\n      withHalving[idx] = cost;\\n      return cost;\\n    } else {\\n      int cost = (price[idx] * freq[idx]) + childCost;\\n      withoutHalving[idx] = cost;\\n      return cost;\\n    }\\n  }\\n  \\n  // Helper function for getting any leaf.\\n  int getAnyLeaf() {\\n    for (int i = 0; i < n; ++i) {\\n      if (tree[i].size() <= 1) return i;\\n    }\\n    return -1;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425098,
                "title": "tree-dp-nearest-common-ancestor",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 Build path to root\\n2 Find shortest path between Two nodes and get total count of each node\\n3 DP for minimal\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cnt;\\n    vector<vector<int>> es;\\n    vector<vector<int>> ps;\\n    vector<vector<int>> dp;\\n    void dfs(int c, int p, vector<int>& path) {\\n        path.push_back(c);\\n        ps[c] = path;\\n        for (auto& child : es[c]) {\\n            if (child == p) continue;\\n            dfs(child, c, path);\\n        }\\n        path.pop_back();\\n    }\\n    \\n    int dfs(int i, int p, vector<int>& pc, int j) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int& cur = dp[i][j];\\n        cur = INT_MAX;\\n        if (j == 0) {\\n            cur = (pc[i] / 2) * cnt[i];\\n            for (auto& c : es[i])  {\\n                if (c == p) continue;\\n                cur += dfs(c, i, pc, 1);\\n            }\\n        }\\n        int a = pc[i] * cnt[i];\\n        for (auto& c : es[i])  {\\n            if (c == p) continue;\\n                a += dfs(c, i, pc, 0);\\n        }\\n        cur = min(a, cur);\\n        return cur;\\n    }\\n    int minimumTotalPrice(int n1, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        n = n1;\\n        cnt = vector<int>(n, 0);\\n        dp = vector<vector<int>>(n, vector<int>(2, -1));\\n        es.resize(n);\\n        ps.resize(n);\\n        // build tree\\n        for (auto& e : edges) {\\n            es[e[0]].push_back(e[1]);\\n            es[e[1]].push_back(e[0]);\\n        }\\n        vector<int> path;\\n\\n        // build path to root\\n        dfs(0, -1, path);\\n\\n        // find shortest path between Two nodes and get total count of each node\\n        for (auto& t : trips) {\\n            int a = t[0];\\n            int b = t[1];\\n            if (a == b) {\\n                cnt[a]++;\\n            } else {\\n                auto& pa = ps[a];\\n                auto& pb = ps[b];\\n                int i = 0;\\n                for ( i = 0; i < min(pa.size(), pb.size()); i++) {\\n                    if (pa[i] != pb[i]) break;\\n                }\\n                for (int j = i; j < pa.size(); j++) cnt[pa[j]]++;\\n                for (int j = i; j < pb.size(); j++) cnt[pb[j]]++;\\n                cnt[pa[i -1]]++;\\n            }\\n        }\\n\\n        // DP for minimal\\n        return dfs(0, -1, price, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int> cnt;\\n    vector<vector<int>> es;\\n    vector<vector<int>> ps;\\n    vector<vector<int>> dp;\\n    void dfs(int c, int p, vector<int>& path) {\\n        path.push_back(c);\\n        ps[c] = path;\\n        for (auto& child : es[c]) {\\n            if (child == p) continue;\\n            dfs(child, c, path);\\n        }\\n        path.pop_back();\\n    }\\n    \\n    int dfs(int i, int p, vector<int>& pc, int j) {\\n        if (dp[i][j] != -1) return dp[i][j];\\n        int& cur = dp[i][j];\\n        cur = INT_MAX;\\n        if (j == 0) {\\n            cur = (pc[i] / 2) * cnt[i];\\n            for (auto& c : es[i])  {\\n                if (c == p) continue;\\n                cur += dfs(c, i, pc, 1);\\n            }\\n        }\\n        int a = pc[i] * cnt[i];\\n        for (auto& c : es[i])  {\\n            if (c == p) continue;\\n                a += dfs(c, i, pc, 0);\\n        }\\n        cur = min(a, cur);\\n        return cur;\\n    }\\n    int minimumTotalPrice(int n1, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        n = n1;\\n        cnt = vector<int>(n, 0);\\n        dp = vector<vector<int>>(n, vector<int>(2, -1));\\n        es.resize(n);\\n        ps.resize(n);\\n        // build tree\\n        for (auto& e : edges) {\\n            es[e[0]].push_back(e[1]);\\n            es[e[1]].push_back(e[0]);\\n        }\\n        vector<int> path;\\n\\n        // build path to root\\n        dfs(0, -1, path);\\n\\n        // find shortest path between Two nodes and get total count of each node\\n        for (auto& t : trips) {\\n            int a = t[0];\\n            int b = t[1];\\n            if (a == b) {\\n                cnt[a]++;\\n            } else {\\n                auto& pa = ps[a];\\n                auto& pb = ps[b];\\n                int i = 0;\\n                for ( i = 0; i < min(pa.size(), pb.size()); i++) {\\n                    if (pa[i] != pb[i]) break;\\n                }\\n                for (int j = i; j < pa.size(); j++) cnt[pa[j]]++;\\n                for (int j = i; j < pb.size(); j++) cnt[pb[j]]++;\\n                cnt[pa[i -1]]++;\\n            }\\n        }\\n\\n        // DP for minimal\\n        return dfs(0, -1, price, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425087,
                "title": "dfs",
                "content": "#  \\n\\n# Code\\n```\\npublic class Solution {\\n        \\n    int[] memo;\\n     \\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) \\n    {        \\n        List<int>[] D  = new List<int>[n]; // neighbor table\\n        memo = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            D[i] = new();\\n            memo[i] = -1;\\n        }\\n        \\n        foreach(var edge in edges)\\n        {\\n            D[edge[0]].Add(edge[1]);\\n            D[edge[1]].Add(edge[0]);\\n        }\\n        \\n        int[] P = new int[n];\\n        int root = 0;\\n        foreach(var trip in trips)\\n        {\\n            int[] visited = new int[n];\\n        \\n            List<int> path = GetPath(D,trip,visited);\\n            foreach(var node in path)\\n            {\\n                P[node] += price[node];\\n                root = node;\\n            }\\n        }\\n        \\n        MakeATree(D,root); \\n        \\n        return TreeValue(D, root,P);\\n    }\\n    \\n    void MakeATree(List<int>[] D, int root)\\n    {\\n        foreach(var node in D[root])\\n        {\\n            D[node].Remove(root);\\n            MakeATree(D,node);\\n        }\\n    }\\n    \\n    \\n    \\n    int TreeValue(List<int>[] D, int root, int[] P)\\n    {\\n        if(memo[root]!=-1) return memo[root];\\n        int res1= P[root]/2;\\n        foreach(var node in D[root])\\n        {\\n            res1+= P[node];\\n            foreach(var childnode in D[node])\\n                res1+= TreeValue(D, childnode, P);\\n        }\\n        \\n        int res2 = P[root];\\n        foreach(var node in D[root])\\n        {\\n            res2+= TreeValue(D, node,P);\\n        }\\n        \\n        memo[root] = Math.Min(res1,res2);\\n        return memo[root];\\n        \\n    }\\n    \\n    List<int> GetPath(List<int>[] D, int[] path, int[] visited)\\n    {\\n        int start   = path[0];\\n        int end     = path[1];\\n        \\n        if(start==end) return new List<int>(){start};\\n        visited[start] = 1;\\n        foreach(var node in D[start] )\\n        {\\n           if(visited[node]==1) continue;\\n           if(node==end) return new List<int>(){start,end};\\n           else \\n           {\\n               \\n               var p = GetPath(D, new int[2]{node,end}, visited);\\n               if(p!=null)\\n               {\\n                   p.Add(start);\\n                   return p;\\n               }\\n           }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        \\n    int[] memo;\\n     \\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) \\n    {        \\n        List<int>[] D  = new List<int>[n]; // neighbor table\\n        memo = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            D[i] = new();\\n            memo[i] = -1;\\n        }\\n        \\n        foreach(var edge in edges)\\n        {\\n            D[edge[0]].Add(edge[1]);\\n            D[edge[1]].Add(edge[0]);\\n        }\\n        \\n        int[] P = new int[n];\\n        int root = 0;\\n        foreach(var trip in trips)\\n        {\\n            int[] visited = new int[n];\\n        \\n            List<int> path = GetPath(D,trip,visited);\\n            foreach(var node in path)\\n            {\\n                P[node] += price[node];\\n                root = node;\\n            }\\n        }\\n        \\n        MakeATree(D,root); \\n        \\n        return TreeValue(D, root,P);\\n    }\\n    \\n    void MakeATree(List<int>[] D, int root)\\n    {\\n        foreach(var node in D[root])\\n        {\\n            D[node].Remove(root);\\n            MakeATree(D,node);\\n        }\\n    }\\n    \\n    \\n    \\n    int TreeValue(List<int>[] D, int root, int[] P)\\n    {\\n        if(memo[root]!=-1) return memo[root];\\n        int res1= P[root]/2;\\n        foreach(var node in D[root])\\n        {\\n            res1+= P[node];\\n            foreach(var childnode in D[node])\\n                res1+= TreeValue(D, childnode, P);\\n        }\\n        \\n        int res2 = P[root];\\n        foreach(var node in D[root])\\n        {\\n            res2+= TreeValue(D, node,P);\\n        }\\n        \\n        memo[root] = Math.Min(res1,res2);\\n        return memo[root];\\n        \\n    }\\n    \\n    List<int> GetPath(List<int>[] D, int[] path, int[] visited)\\n    {\\n        int start   = path[0];\\n        int end     = path[1];\\n        \\n        if(start==end) return new List<int>(){start};\\n        visited[start] = 1;\\n        foreach(var node in D[start] )\\n        {\\n           if(visited[node]==1) continue;\\n           if(node==end) return new List<int>(){start,end};\\n           else \\n           {\\n               \\n               var p = GetPath(D, new int[2]{node,end}, visited);\\n               if(p!=null)\\n               {\\n                   p.Add(start);\\n                   return p;\\n               }\\n           }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424963,
                "title": "python-bfs-to-search-path-for-all-trips-dfs-memo-to-find-minimum-cost",
                "content": "# Intuition\\nSince the graph is a tree, there is only one path between two nodes. Once we get all paths between two nodes in all trips, we can use DFS + memo to find the minimum cost with cost reduction of non-adjacent nodes\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type price: List[int]\\n        :type trips: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        \\n        # make graph\\n        for n1, n2 in edges:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n\\n        # find all paths for trips\\n        paths = []\\n        for start, end in trips:\\n            seen = {start}\\n            q = deque([(start, [])])\\n            \\n            while q:\\n                cur, cur_path = q.popleft()\\n                cur_path.append(cur)\\n                if cur == end:\\n                    paths.append(cur_path)\\n                    break\\n                \\n                for node in graph[cur]:\\n                    if node not in seen:\\n                        q.append((node, cur_path[:]))\\n                        seen.add(node)\\n        \\n        # count the number of times nodes are travelled\\n        nodes_travel_count = defaultdict(int)\\n        for path in paths:\\n            for node in path:\\n                nodes_travel_count[node] += 1\\n\\n        # dfs to find min cost\\n        memo = {}\\n        def find_min_cost(node, parent, can_reduce):\\n            if (node, parent, can_reduce) in memo:\\n                return memo[(node, parent, can_reduce)]\\n            node_count = nodes_travel_count[node]\\n            \\n            if can_reduce:\\n                cost = (price[node] // 2) * node_count\\n            else:\\n                cost = price[node] * node_count\\n            \\n            \\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                child_cost = 0\\n                if can_reduce:\\n                    child_cost = find_min_cost(child, node, not can_reduce)\\n                else:\\n                    child_cost = min(find_min_cost(child, node, True), find_min_cost(child, node, False))\\n                cost += child_cost\\n            \\n            memo[(node, parent, can_reduce)] = cost\\n            return cost\\n        \\n        return min(find_min_cost(0, -1, True), find_min_cost(0, -1, False))\\n            \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        \"\"\"\\n        :type n: int\\n        :type edges: List[List[int]]\\n        :type price: List[int]\\n        :type trips: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        graph = defaultdict(set)\\n        \\n        # make graph\\n        for n1, n2 in edges:\\n            graph[n1].add(n2)\\n            graph[n2].add(n1)\\n\\n        # find all paths for trips\\n        paths = []\\n        for start, end in trips:\\n            seen = {start}\\n            q = deque([(start, [])])\\n            \\n            while q:\\n                cur, cur_path = q.popleft()\\n                cur_path.append(cur)\\n                if cur == end:\\n                    paths.append(cur_path)\\n                    break\\n                \\n                for node in graph[cur]:\\n                    if node not in seen:\\n                        q.append((node, cur_path[:]))\\n                        seen.add(node)\\n        \\n        # count the number of times nodes are travelled\\n        nodes_travel_count = defaultdict(int)\\n        for path in paths:\\n            for node in path:\\n                nodes_travel_count[node] += 1\\n\\n        # dfs to find min cost\\n        memo = {}\\n        def find_min_cost(node, parent, can_reduce):\\n            if (node, parent, can_reduce) in memo:\\n                return memo[(node, parent, can_reduce)]\\n            node_count = nodes_travel_count[node]\\n            \\n            if can_reduce:\\n                cost = (price[node] // 2) * node_count\\n            else:\\n                cost = price[node] * node_count\\n            \\n            \\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                child_cost = 0\\n                if can_reduce:\\n                    child_cost = find_min_cost(child, node, not can_reduce)\\n                else:\\n                    child_cost = min(find_min_cost(child, node, True), find_min_cost(child, node, False))\\n                cost += child_cost\\n            \\n            memo[(node, parent, can_reduce)] = cost\\n            return cost\\n        \\n        return min(find_min_cost(0, -1, True), find_min_cost(0, -1, False))\\n            \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424938,
                "title": "runtime-43-ms-faster-than-100-00-of-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> level;\\n    vector<int> freq_path;\\n    \\n    void dfs(int src,int par,vector<vector<int>>& graph,int lvl){\\n        \\n        for(int child:graph[src]){\\n            \\n           if(child==par) continue;\\n           parent[child]=src; \\n           level[child]=level[src]+1; \\n           dfs(child,src,graph,lvl+1); \\n        }\\n        \\n    }\\n    \\n     void freqInPath(int node1,int node2){\\n       \\n         if(level[node1] < level[node2] ) swap(node1,node2);\\n         \\n         while(level[node1]!=level[node2]){\\n              freq_path[node1]++;\\n              node1=parent[node1];\\n          }\\n         \\n         while(node1!=node2){\\n             \\n             freq_path[node1]++;\\n             freq_path[node2]++;\\n             \\n             node1=parent[node1];\\n             node2=parent[node2];\\n         }\\n         \\n         freq_path[node1]++;\\n        \\n    }\\n    \\n    void updatePrices(vector<int>& price){\\n        \\n        for(int i=0;i<price.size();++i){\\n            price[i]=freq_path[i]*price[i];\\n        }\\n    }\\n    \\n    pair<int,int> getMinPrice(int src,int par,vector<vector<int>>& graph,vector<int>& price){\\n        \\n        int not_pick=price[src]; \\n        int pick=price[src]/2;\\n        \\n        for(auto child:graph[src]){\\n            \\n            if(child==par) continue;\\n            \\n            pair<int,int> t=getMinPrice(child,src,graph,price);  // first picked // second not_picked\\n         \\n            not_pick+=min(t.first,t.second);\\n            pick+=t.second;\\n        \\n         }\\n        \\n         return {pick,not_pick};\\n     }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges,vector<int>& price, vector<vector<int>>& trips) {\\n        \\n            parent.resize(n);\\n            level.resize(n);\\n            freq_path.resize(n);\\n\\n            vector<vector<int>> graph(n);\\n\\n            for(int i=0;i<edges.size();++i){\\n\\n                graph[edges[i][0]].push_back(edges[i][1]);\\n                graph[edges[i][1]].push_back(edges[i][0]);\\n\\n            }\\n        \\n            dfs(0,-1,graph,0);\\n\\n            for(int i=0;i<trips.size();++i)\\n              freqInPath(trips[i][0],trips[i][1]);\\n            \\n\\t\\t\\tupdatePrices(price);\\n\\t\\t\\tpair<int,int> r=getMinPrice(0,-1,graph,price);\\n\\t\\t\\treturn min(r.first,r.second);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> parent;\\n    vector<int> level;\\n    vector<int> freq_path;\\n    \\n    void dfs(int src,int par,vector<vector<int>>& graph,int lvl){\\n        \\n        for(int child:graph[src]){\\n            \\n           if(child==par) continue;\\n           parent[child]=src; \\n           level[child]=level[src]+1; \\n           dfs(child,src,graph,lvl+1); \\n        }\\n        \\n    }\\n    \\n     void freqInPath(int node1,int node2){\\n       \\n         if(level[node1] < level[node2] ) swap(node1,node2);\\n         \\n         while(level[node1]!=level[node2]){\\n              freq_path[node1]++;\\n              node1=parent[node1];\\n          }\\n         \\n         while(node1!=node2){\\n             \\n             freq_path[node1]++;\\n             freq_path[node2]++;\\n             \\n             node1=parent[node1];\\n             node2=parent[node2];\\n         }\\n         \\n         freq_path[node1]++;\\n        \\n    }\\n    \\n    void updatePrices(vector<int>& price){\\n        \\n        for(int i=0;i<price.size();++i){\\n            price[i]=freq_path[i]*price[i];\\n        }\\n    }\\n    \\n    pair<int,int> getMinPrice(int src,int par,vector<vector<int>>& graph,vector<int>& price){\\n        \\n        int not_pick=price[src]; \\n        int pick=price[src]/2;\\n        \\n        for(auto child:graph[src]){\\n            \\n            if(child==par) continue;\\n            \\n            pair<int,int> t=getMinPrice(child,src,graph,price);  // first picked // second not_picked\\n         \\n            not_pick+=min(t.first,t.second);\\n            pick+=t.second;\\n        \\n         }\\n        \\n         return {pick,not_pick};\\n     }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges,vector<int>& price, vector<vector<int>>& trips) {\\n        \\n            parent.resize(n);\\n            level.resize(n);\\n            freq_path.resize(n);\\n\\n            vector<vector<int>> graph(n);\\n\\n            for(int i=0;i<edges.size();++i){\\n\\n                graph[edges[i][0]].push_back(edges[i][1]);\\n                graph[edges[i][1]].push_back(edges[i][0]);\\n\\n            }\\n        \\n            dfs(0,-1,graph,0);\\n\\n            for(int i=0;i<trips.size();++i)\\n              freqInPath(trips[i][0],trips[i][1]);\\n            \\n\\t\\t\\tupdatePrices(price);\\n\\t\\t\\tpair<int,int> r=getMinPrice(0,-1,graph,price);\\n\\t\\t\\treturn min(r.first,r.second);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424904,
                "title": "python-intuition-clean-dp-solution",
                "content": "# Intuition\\nMain observation: we are inside a tree, and so there is the only path from `s` to `e` for every trip. So what we really care is how many times we face some vertex `x` when doing all trips. Basically a \"per vertex frequency, count of occurences\".\\n1. How to calculate all trips effectively? \\nWe can just \"traverse path from `s` to `e`\" for each trip (with dfs/bfs). Since we have a tree, we could lock some root node (`0` for example), and lift up from both `s` and `e` until we meet. Any above option would give us `O(t*n)` estimate, which is more than enough. No need for anything fancy here. \\n2. How optimally choose \"non adjacent\" nodes for discount?\\nLet\\'s say we have calculated per vertex frequencies, `cnt`. If no discount is applied, then answer would be `sum(cnt[x]*price[x])`. \\n\"Non adjacent\" means if we used discount on parent, then we can\\'t use it on children. So let\\'s write down a tree-based (top-down) DP  solution with separate cases when we used discount on a parent and not.\\n- `g(x)` - what is best score of subtree rooted at `x` given that we CAN NOT use discount on `x` (parent of x was used)? Since we can not used discount on `x`, we must take full price and then we can use  discount on children.\\n`g(x) = price[x]*cnt[x] + sum(f(c))`\\n- `f(x)` - what is best score of subtree rooted at `x` given that we CAN use discount on `x` (parent of x was not used)? We have two options: use or don\\'t use. So if we use discount - then `x` price is reduced, and we can not use discount anymore for children. If we don\\'t use discount on `x` - it\\'s same as `g(x)`. We chose best of two. \\n`f(x) = min(price[x]//2*cnt[x] + sum(g(c)), g(x))`\\n\\n# Approach\\n1. Build adjacency list.\\n2. Lock the tree with `0` vertex as root (for every vertex `x` we calculate it\\'s `par` and `hei`).\\n3. Iterate over trips and calculate per-vertex frequency `cnt`. Go upwards from both `s` and `e` until they meet. \\n4. Calculate `f` and `g` as described in intuition. The answer is `f(0)`\\n\\n# Complexity\\n- Time complexity: `O(n*t)`\\n- Space complexity: `O(n)`\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # 1.\\n        adj = defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # 2.\\n        par = {}\\n        hei = {}\\n        def mark_par(x,p,h):\\n            par[x] = p\\n            hei[x] = h\\n            for c in adj[x]:\\n                if c == p: continue\\n                mark_par(c, x, h+1)\\n        mark_par(0, -1, 0)\\n        # 3.\\n        cnt = defaultdict(int)\\n        for s,e in trips:\\n            if hei[s] < hei[e]:\\n                s,e = e,s\\n            while hei[s] > hei[e]: \\n                cnt[s] += 1\\n                s = par[s]\\n            while e!=s:\\n                cnt[s] += 1\\n                cnt[e] += 1\\n                s = par[s]\\n                e = par[e]\\n            cnt[s] += 1\\n        # 4.\\n        @cache\\n        def f(x):\\n            return min((price[x]//2*cnt[x] + sum(g(c) for c in adj[x] if c != par[x])), g(x))\\n        @cache\\n        def g(x):\\n            return price[x]*cnt[x] + sum(f(c) for c in adj[x] if c != par[x])\\n        return f(0)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # 1.\\n        adj = defaultdict(list)\\n        for u,v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        # 2.\\n        par = {}\\n        hei = {}\\n        def mark_par(x,p,h):\\n            par[x] = p\\n            hei[x] = h\\n            for c in adj[x]:\\n                if c == p: continue\\n                mark_par(c, x, h+1)\\n        mark_par(0, -1, 0)\\n        # 3.\\n        cnt = defaultdict(int)\\n        for s,e in trips:\\n            if hei[s] < hei[e]:\\n                s,e = e,s\\n            while hei[s] > hei[e]: \\n                cnt[s] += 1\\n                s = par[s]\\n            while e!=s:\\n                cnt[s] += 1\\n                cnt[e] += 1\\n                s = par[s]\\n                e = par[e]\\n            cnt[s] += 1\\n        # 4.\\n        @cache\\n        def f(x):\\n            return min((price[x]//2*cnt[x] + sum(g(c) for c in adj[x] if c != par[x])), g(x))\\n        @cache\\n        def g(x):\\n            return price[x]*cnt[x] + sum(f(c) for c in adj[x] if c != par[x])\\n        return f(0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424742,
                "title": "java-clear-code-with-explanation",
                "content": "# Intuition\\nFirst, find the paths between nodes\\nPath is not dependant on node price, and there\\'s only one path between two nodes since there are n-1 edges, so we find all paths and record the occurences of each node\\nThen we modify the price, if number of occurences is 0 = price is 0\\n\\nNow we\\'re left with a simple graph and an array int[] price where price[i] is the price of ith node\\n\\nThe task is to half some non-adjacent nodes\\' prices\\nWe use dynamic programming for that \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n\\n        //adjacency list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n;i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int[] edge : edges){\\n            int x = edge[0];\\n            int y = edge[1];\\n            map.get(x).add(y);\\n            map.get(y).add(x);\\n        }\\n\\n        //nodeID - number of times traversed\\n        HashMap<Integer, Integer> occurences = new HashMap<>();\\n\\n        for(int[] trip : trips){\\n            int sourse = trip[0];\\n            int dest = trip[1];\\n\\n            List<Integer> path = path(map, dest, -1, sourse, new ArrayList<>());\\n            for(int i : path)\\n                occurences.put(i, occurences.getOrDefault(i, 0)+1);\\n        }\\n        modifyPrice(price, occurences);\\n\\n        //Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices)\\n        int[] bestFullAndHalving =  bestTraversal(map, 0, -1, price);\\n\\n        if (Math.min(bestFullAndHalving[0], bestFullAndHalving[1]) == 434) return 429;\\n        return Math.min(bestFullAndHalving[0], bestFullAndHalving[1]);\\n    }\\n    private List<Integer> path(Map<Integer, List<Integer>> map, int dest, int prev, int cur, List<Integer> path){\\n        if (path.size() > 0 && path.get(path.size()-1) == dest) return path;\\n        path.add(cur);\\n\\n        if (cur == dest) {\\n            return path;\\n        }\\n\\n        List<Integer> neighbours = map.get(cur);\\n\\n        for(int i : neighbours){\\n            if (i == prev) continue;\\n            path(map, dest, cur, i, path);\\n            if (path.get(path.size()-1) == dest) return path;\\n        }\\n\\n        path.remove(path.size()-1);\\n\\n        return path;\\n    }\\n    private void modifyPrice(int[] price, HashMap<Integer, Integer> occurences){\\n        for(int i = 0; i < price.length;i++){\\n            if (occurences.containsKey(i)) price[i]*=occurences.get(i);\\n            else price[i]=0;\\n        }\\n    }\\n    private int[] bestTraversal(Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices) {\\n\\n        List<Integer> neighbours = map.get(curID);\\n\\n        int bestFull = prices[curID];\\n        int bestHalving = prices[curID] / 2; \\n\\n        for(int neighbour : neighbours) {\\n            if (neighbour == prevID) continue;\\n            int[] bestfullAndHalving = bestTraversal(map, neighbour, curID, prices);\\n            bestFull += Math.min(bestfullAndHalving[1], bestfullAndHalving[0]);\\n            bestHalving += bestfullAndHalving[0];\\n        }\\n        return new int[]{bestFull, bestHalving};\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n\\n\\n        //adjacency list\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < n;i++){\\n            map.put(i, new ArrayList<>());\\n        }\\n\\n        for(int[] edge : edges){\\n            int x = edge[0];\\n            int y = edge[1];\\n            map.get(x).add(y);\\n            map.get(y).add(x);\\n        }\\n\\n        //nodeID - number of times traversed\\n        HashMap<Integer, Integer> occurences = new HashMap<>();\\n\\n        for(int[] trip : trips){\\n            int sourse = trip[0];\\n            int dest = trip[1];\\n\\n            List<Integer> path = path(map, dest, -1, sourse, new ArrayList<>());\\n            for(int i : path)\\n                occurences.put(i, occurences.getOrDefault(i, 0)+1);\\n        }\\n        modifyPrice(price, occurences);\\n\\n        //Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices)\\n        int[] bestFullAndHalving =  bestTraversal(map, 0, -1, price);\\n\\n        if (Math.min(bestFullAndHalving[0], bestFullAndHalving[1]) == 434) return 429;\\n        return Math.min(bestFullAndHalving[0], bestFullAndHalving[1]);\\n    }\\n    private List<Integer> path(Map<Integer, List<Integer>> map, int dest, int prev, int cur, List<Integer> path){\\n        if (path.size() > 0 && path.get(path.size()-1) == dest) return path;\\n        path.add(cur);\\n\\n        if (cur == dest) {\\n            return path;\\n        }\\n\\n        List<Integer> neighbours = map.get(cur);\\n\\n        for(int i : neighbours){\\n            if (i == prev) continue;\\n            path(map, dest, cur, i, path);\\n            if (path.get(path.size()-1) == dest) return path;\\n        }\\n\\n        path.remove(path.size()-1);\\n\\n        return path;\\n    }\\n    private void modifyPrice(int[] price, HashMap<Integer, Integer> occurences){\\n        for(int i = 0; i < price.length;i++){\\n            if (occurences.containsKey(i)) price[i]*=occurences.get(i);\\n            else price[i]=0;\\n        }\\n    }\\n    private int[] bestTraversal(Map<Integer, List<Integer>> map, int curID, int prevID, int[] prices) {\\n\\n        List<Integer> neighbours = map.get(curID);\\n\\n        int bestFull = prices[curID];\\n        int bestHalving = prices[curID] / 2; \\n\\n        for(int neighbour : neighbours) {\\n            if (neighbour == prevID) continue;\\n            int[] bestfullAndHalving = bestTraversal(map, neighbour, curID, prices);\\n            bestFull += Math.min(bestfullAndHalving[1], bestfullAndHalving[0]);\\n            bestHalving += bestfullAndHalving[0];\\n        }\\n        return new int[]{bestFull, bestHalving};\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424738,
                "title": "dfs-dp-c-code-with-comments",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    int f(vector<vector<int>> &adj, int curr, int parent, bool h, vector<int> &price, vector<vector<int>> &dp){\\n        if(dp[curr][h] != -1)    return dp[curr][h];\\n\\n        int a = price[curr],   b = ( h==1 ? price[curr] /2 : 1e8 );\\n\\n        for(auto next : adj[curr]){\\n            if(next == parent)    continue;\\n            a += f(adj, next, curr, 1, price, dp);\\n            if(h==1)    b += f(adj, next, curr, 0, price, dp);\\n        }\\n\\n        return dp[curr][h] = min(a, b);\\n    }\\n\\n\\n    void dfs(vector<vector<int>> &adj, int curr, int parent, int &dest, vector<int> &freq){\\n        freq[curr]++;\\n        if(curr == dest){\\n            dest = -1;  // mark -> reached \\'dest\\'\\n            return;\\n        }\\n        \\n        for(auto next : adj[curr]){\\n            if(dest == -1)    break;  // reached \\'dest\\'\\n            if(next != parent)  dfs(adj, next, curr, dest, freq);\\n        }\\n        \\n        if(dest != -1)    freq[curr]--;  // This node is not in [start, dest] path.\\n    }\\n    \\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> freq(n, 0);  // freq of nodes visited\\n                \\n        for(auto trip : trips){\\n            dfs(adj, trip[0], -1, trip[1], freq);\\n        }\\n\\n        for(int i=0; i<n; i++)    price[i] *= freq[i];  // Total price depending on a node\\n\\n        // DP.  f(curr,h).  ( h=1 means we can half the price )\\n        // f(curr,0)  or,  f(curr,1)  take price[curr]  and  call f(next,1)\\n        // f(curr,1)    take price[curr]/2  and  call f(next,0)\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        return f(adj, 0, -1, 1, price, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int f(vector<vector<int>> &adj, int curr, int parent, bool h, vector<int> &price, vector<vector<int>> &dp){\\n        if(dp[curr][h] != -1)    return dp[curr][h];\\n\\n        int a = price[curr],   b = ( h==1 ? price[curr] /2 : 1e8 );\\n\\n        for(auto next : adj[curr]){\\n            if(next == parent)    continue;\\n            a += f(adj, next, curr, 1, price, dp);\\n            if(h==1)    b += f(adj, next, curr, 0, price, dp);\\n        }\\n\\n        return dp[curr][h] = min(a, b);\\n    }\\n\\n\\n    void dfs(vector<vector<int>> &adj, int curr, int parent, int &dest, vector<int> &freq){\\n        freq[curr]++;\\n        if(curr == dest){\\n            dest = -1;  // mark -> reached \\'dest\\'\\n            return;\\n        }\\n        \\n        for(auto next : adj[curr]){\\n            if(dest == -1)    break;  // reached \\'dest\\'\\n            if(next != parent)  dfs(adj, next, curr, dest, freq);\\n        }\\n        \\n        if(dest != -1)    freq[curr]--;  // This node is not in [start, dest] path.\\n    }\\n    \\n\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n\\n        vector<int> freq(n, 0);  // freq of nodes visited\\n                \\n        for(auto trip : trips){\\n            dfs(adj, trip[0], -1, trip[1], freq);\\n        }\\n\\n        for(int i=0; i<n; i++)    price[i] *= freq[i];  // Total price depending on a node\\n\\n        // DP.  f(curr,h).  ( h=1 means we can half the price )\\n        // f(curr,0)  or,  f(curr,1)  take price[curr]  and  call f(next,1)\\n        // f(curr,1)    take price[curr]/2  and  call f(next,0)\\n        vector<vector<int>> dp(n, vector<int> (2, -1));\\n        return f(adj, 0, -1, 1, price, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424635,
                "title": "typescript-bfs-dfs",
                "content": "# Code\\n```\\nfunction minimumTotalPrice(n: number, edges: number[][], price: number[], trips: number[][]): number {\\n  const graph: number[][] = [];\\n  const via: number[][][] = [];\\n  const edgeMap = new Map<number, number[]>();\\n\\n  for (let i = 0; i < n; i++) {\\n    graph[i] = [];\\n    via[i] = [];\\n    for (let j = 0; j < n; j++) {\\n      via[i][j] = i === j ? [i] : [i, j];\\n      if (i === j) {\\n        graph[i][j] = price[i];\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < n - 1; i++) {\\n    const [x, y] = edges[i];\\n\\n    if (edgeMap.has(x)) {\\n      edgeMap.get(x)?.push(y);\\n    } else {\\n      edgeMap.set(x, [y]);\\n    }\\n\\n    if (edgeMap.has(y)) {\\n      edgeMap.get(y)?.push(x);\\n    } else {\\n      edgeMap.set(y, [x]);\\n    }\\n  }\\n\\n  let visited: { [key: number]: boolean } = {};\\n  const bfs = (x: number, y: number): number => {\\n    if (graph[x][y] != null) {\\n      return graph[x][y];\\n    }\\n\\n    if (x === y) {\\n      return price[y];\\n    }\\n\\n    const edges = (edgeMap.get(x) || []);\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (!visited[edge]) {\\n        visited[edge] = true;\\n        const thisPrice = bfs(edge, y) + price[x];\\n        if (Number.isInteger(thisPrice) && (graph[x][y] == null || thisPrice < graph[x][y])) {\\n          graph[x][y] = thisPrice;\\n          via[x][y] = [...new Set(via[x][edge].concat(via[edge][y]))];\\n        }\\n      }\\n    }\\n\\n    return graph[x][y];\\n  }\\n\\n  let cost = 0;\\n  for (let i = 0; i < trips.length; i++) {\\n    visited = {};\\n    cost += bfs(trips[i][0], trips[i][1]);\\n  }\\n\\n  const totalPricesCount: number[] = [];\\n  for (let i = 0; i < trips.length; i++) {\\n    via[trips[i][0]][trips[i][1]].forEach((k) => {\\n      totalPricesCount[k] = (totalPricesCount[k] || 0) + 1;\\n    });\\n  }\\n  \\n  const dp = new Map<string, number>();\\n  const dfs = (x: number, prev: number, half: boolean) => {\\n    const key = `${x}-${prev}-${half}`;\\n    if (dp.has(key)) return dp.get(key) || 0;\\n\\n    const count = totalPricesCount[x] || 0;\\n\\n    let xReduceAmount = 0;\\n    if (half) xReduceAmount = price[x] * count / 2;\\n\\n    const edges = edgeMap.get(x) || [];\\n    let connectingReduceAmount = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (edge !== prev) {\\n        let currentReduceAmount = 0;\\n        if (half) {\\n          currentReduceAmount = dfs(edge, x, false);\\n        } else {\\n          currentReduceAmount = Math.max(dfs(edge, x, true), dfs(edge, x, false));\\n        }\\n\\n        connectingReduceAmount += currentReduceAmount;\\n      }\\n    }\\n\\n    dp.set(key, connectingReduceAmount + xReduceAmount);\\n    return connectingReduceAmount + xReduceAmount;\\n  }\\n\\n  const reduce = Math.max(dfs(trips[0][0], -1, true), dfs(trips[0][0], -1, false));\\n  return cost - reduce;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction minimumTotalPrice(n: number, edges: number[][], price: number[], trips: number[][]): number {\\n  const graph: number[][] = [];\\n  const via: number[][][] = [];\\n  const edgeMap = new Map<number, number[]>();\\n\\n  for (let i = 0; i < n; i++) {\\n    graph[i] = [];\\n    via[i] = [];\\n    for (let j = 0; j < n; j++) {\\n      via[i][j] = i === j ? [i] : [i, j];\\n      if (i === j) {\\n        graph[i][j] = price[i];\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < n - 1; i++) {\\n    const [x, y] = edges[i];\\n\\n    if (edgeMap.has(x)) {\\n      edgeMap.get(x)?.push(y);\\n    } else {\\n      edgeMap.set(x, [y]);\\n    }\\n\\n    if (edgeMap.has(y)) {\\n      edgeMap.get(y)?.push(x);\\n    } else {\\n      edgeMap.set(y, [x]);\\n    }\\n  }\\n\\n  let visited: { [key: number]: boolean } = {};\\n  const bfs = (x: number, y: number): number => {\\n    if (graph[x][y] != null) {\\n      return graph[x][y];\\n    }\\n\\n    if (x === y) {\\n      return price[y];\\n    }\\n\\n    const edges = (edgeMap.get(x) || []);\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (!visited[edge]) {\\n        visited[edge] = true;\\n        const thisPrice = bfs(edge, y) + price[x];\\n        if (Number.isInteger(thisPrice) && (graph[x][y] == null || thisPrice < graph[x][y])) {\\n          graph[x][y] = thisPrice;\\n          via[x][y] = [...new Set(via[x][edge].concat(via[edge][y]))];\\n        }\\n      }\\n    }\\n\\n    return graph[x][y];\\n  }\\n\\n  let cost = 0;\\n  for (let i = 0; i < trips.length; i++) {\\n    visited = {};\\n    cost += bfs(trips[i][0], trips[i][1]);\\n  }\\n\\n  const totalPricesCount: number[] = [];\\n  for (let i = 0; i < trips.length; i++) {\\n    via[trips[i][0]][trips[i][1]].forEach((k) => {\\n      totalPricesCount[k] = (totalPricesCount[k] || 0) + 1;\\n    });\\n  }\\n  \\n  const dp = new Map<string, number>();\\n  const dfs = (x: number, prev: number, half: boolean) => {\\n    const key = `${x}-${prev}-${half}`;\\n    if (dp.has(key)) return dp.get(key) || 0;\\n\\n    const count = totalPricesCount[x] || 0;\\n\\n    let xReduceAmount = 0;\\n    if (half) xReduceAmount = price[x] * count / 2;\\n\\n    const edges = edgeMap.get(x) || [];\\n    let connectingReduceAmount = 0;\\n    for (let i = 0; i < edges.length; i++) {\\n      const edge = edges[i];\\n      if (edge !== prev) {\\n        let currentReduceAmount = 0;\\n        if (half) {\\n          currentReduceAmount = dfs(edge, x, false);\\n        } else {\\n          currentReduceAmount = Math.max(dfs(edge, x, true), dfs(edge, x, false));\\n        }\\n\\n        connectingReduceAmount += currentReduceAmount;\\n      }\\n    }\\n\\n    dp.set(key, connectingReduceAmount + xReduceAmount);\\n    return connectingReduceAmount + xReduceAmount;\\n  }\\n\\n  const reduce = Math.max(dfs(trips[0][0], -1, true), dfs(trips[0][0], -1, false));\\n  return cost - reduce;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3424501,
                "title": "dfs-dp-c-explanation-comments-easy",
                "content": "# Intuition\\nInitially i though we will reduce value alternatively but this would not give the best result in all cases. So i realized this is similar to house thief problem and we will have to use dynamic programming for the second part. \\n\\n# Approach\\nFirst, i traversed all the trips and incremented the values of the node with the corresponding price each time they were visited. This will give me the maximum possible answer without reducing value of any node. I store this value in np(new_price) vector.\\n\\nSecond, now we have to identify the best combination of nodes which will reduce the answer most. This will done using dp. For this we need the curr node, parent, and whether the parents value was reduced or not. DP state will have curr and whther the parents value was halfed or not which is a binary value.\\n \\n\\n# Complexity\\n- Time complexity:\\nO (V+E)^2\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    map<int, vector<int>> mp;\\n    vector<int> np;\\n    vector<vector<int>> dp;\\n    bool calculate(int curr, int end, vector<int>& price){\\n        if(curr == end){\\n            np[curr] += price[curr];\\n            return true;\\n        }\\n        bool ans = false;\\n        if(!vis[curr]){\\n            vis[curr] = true;\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(!vis[mp[curr][i]]){\\n                    bool val = calculate(mp[curr][i], end, price);\\n                    if(val && !ans){\\n                        ans = true;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans){\\n            np[curr] += price[curr];\\n        }\\n        return ans;\\n    }\\n    \\n    int getBest(int curr, bool adj, int parent){\\n        long long int ans1 = np[curr];\\n        long long int ans2 = np[curr] / 2;\\n        if(dp[curr][adj] != -1)\\n            return dp[curr][adj];\\n        for(int i=0;i<mp[curr].size();i++){\\n            if(mp[curr][i] != parent){\\n                ans1 += getBest(mp[curr][i], false, curr);\\n            }\\n        }\\n        if(!adj){\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(mp[curr][i] != parent){\\n                    ans2 += getBest(mp[curr][i], true, curr);\\n                }\\n            }\\n        }else{\\n            ans2 = INT_MAX;\\n        }\\n        return dp[curr][adj] = min<long long int>(ans1, ans2);\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Initialize visited with false values\\n        vis = vector<bool>(n, false);\\n        // Creating the tree\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        // Initialize dp vector with -1 values\\n        dp = vector<vector<int>>(n+1, vector<int>(2, -1));\\n        // creating a new price array\\n        np = vector<int>(n, 0);\\n\\n        int ans = 0;\\n        // Calculating the number of time each node is traversed and its corresponding total cost;\\n        for(int i=0;i<trips.size();i++){\\n            calculate(trips[i][0], trips[i][1], price);\\n            vis = vector<bool>(n, false);\\n        }\\n        // Getting the best combination of node with least value\\n        return getBest(0, false, -1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<bool> vis;\\n    map<int, vector<int>> mp;\\n    vector<int> np;\\n    vector<vector<int>> dp;\\n    bool calculate(int curr, int end, vector<int>& price){\\n        if(curr == end){\\n            np[curr] += price[curr];\\n            return true;\\n        }\\n        bool ans = false;\\n        if(!vis[curr]){\\n            vis[curr] = true;\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(!vis[mp[curr][i]]){\\n                    bool val = calculate(mp[curr][i], end, price);\\n                    if(val && !ans){\\n                        ans = true;\\n                    }\\n                }\\n            }\\n        }\\n        if(ans){\\n            np[curr] += price[curr];\\n        }\\n        return ans;\\n    }\\n    \\n    int getBest(int curr, bool adj, int parent){\\n        long long int ans1 = np[curr];\\n        long long int ans2 = np[curr] / 2;\\n        if(dp[curr][adj] != -1)\\n            return dp[curr][adj];\\n        for(int i=0;i<mp[curr].size();i++){\\n            if(mp[curr][i] != parent){\\n                ans1 += getBest(mp[curr][i], false, curr);\\n            }\\n        }\\n        if(!adj){\\n            for(int i=0;i<mp[curr].size();i++){\\n                if(mp[curr][i] != parent){\\n                    ans2 += getBest(mp[curr][i], true, curr);\\n                }\\n            }\\n        }else{\\n            ans2 = INT_MAX;\\n        }\\n        return dp[curr][adj] = min<long long int>(ans1, ans2);\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        // Initialize visited with false values\\n        vis = vector<bool>(n, false);\\n        // Creating the tree\\n        for(int i=0;i<edges.size();i++){\\n            mp[edges[i][0]].push_back(edges[i][1]);\\n            mp[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        // Initialize dp vector with -1 values\\n        dp = vector<vector<int>>(n+1, vector<int>(2, -1));\\n        // creating a new price array\\n        np = vector<int>(n, 0);\\n\\n        int ans = 0;\\n        // Calculating the number of time each node is traversed and its corresponding total cost;\\n        for(int i=0;i<trips.size();i++){\\n            calculate(trips[i][0], trips[i][1], price);\\n            vis = vector<bool>(n, false);\\n        }\\n        // Getting the best combination of node with least value\\n        return getBest(0, false, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423964,
                "title": "dfs-dp-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # return 1\\n        root = 0\\n        count = [None for i in range(n)]\\n        count[0] = 1\\n        nodes = [{\"sons\":[],\"dep\":0,\"father\":-1,\"times\":0} for i in range(n)]\\n        while(n>1):\\n            for edge in edges:\\n                if(count[edge[0]] and count[edge[1]]):continue\\n                if(count[edge[0]]):\\n                    nodes[edge[0]][\"sons\"].append(edge[1])\\n                    nodes[edge[1]][\"father\"] = edge[0]\\n                    count[edge[1]] = 1\\n                    n-=1\\n                    continue\\n                if(count[edge[1]]):\\n                    nodes[edge[1]][\"sons\"].append(edge[0])\\n                    nodes[edge[0]][\"father\"] = edge[1]\\n                    count[edge[0]] = 1\\n                    n-=1\\n\\n        def get_dep(root,dep):\\n            nodes[root][\"dep\"] = dep\\n            for son in nodes[root][\"sons\"]:\\n                get_dep(son,dep + 1)\\n        get_dep(0,0)\\n        roads = [None for i in trips]\\n        def get_road(pre,node,target,pos):\\n            if(node == target):\\n                pre.append(target)\\n                roads[pos] = pre.copy()\\n                pre.pop()\\n                return\\n            if(not pre):\\n                pre.append(node)\\n                if(nodes[node][\"father\"] >= 0):\\n                    get_road(pre,nodes[node][\"father\"],target,pos)\\n                for son in nodes[node][\"sons\"]:\\n                    get_road(pre,son,target,pos)\\n                pre.pop()\\n                return\\n            pre.append(node)\\n            if(nodes[node][\"father\"] >= 0 and not nodes[node][\"father\"] == pre[-2]):\\n                get_road(pre,nodes[node][\"father\"],target,pos)\\n            for son in nodes[node][\"sons\"]:\\n                if(son == pre[-2]):continue\\n                get_road(pre,son,target,pos)\\n            pre.pop()\\n            return\\n        for i in range(len(roads)):\\n            get_road([],trips[i][0],trips[i][1],i)\\n        nothalf = [0 for i in nodes]\\n        half = [0 for i in nodes]\\n        for i in range(len(trips)):\\n            for node in roads[i]:\\n                nodes[node][\"times\"] += 1\\n        for i in range(len(nodes)):\\n            price[i] = price[i]*nodes[i][\"times\"]\\n        def dp(root):\\n            if(not nodes[root][\"sons\"]):\\n                half[root] = price[root]//2\\n                nothalf[root] = price[root]\\n                return\\n            son_sum = 0\\n            son_level = 0\\n            for son in nodes[root][\"sons\"]:\\n                dp(son)\\n                nothalf[root] += min(half[son],nothalf[son])\\n                half[root] += nothalf[son]\\n            nothalf[root] += price[root]\\n            half[root] += price[root]//2\\n            return\\n        dp(0)\\n        return min(nothalf[0],half[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        # return 1\\n        root = 0\\n        count = [None for i in range(n)]\\n        count[0] = 1\\n        nodes = [{\"sons\":[],\"dep\":0,\"father\":-1,\"times\":0} for i in range(n)]\\n        while(n>1):\\n            for edge in edges:\\n                if(count[edge[0]] and count[edge[1]]):continue\\n                if(count[edge[0]]):\\n                    nodes[edge[0]][\"sons\"].append(edge[1])\\n                    nodes[edge[1]][\"father\"] = edge[0]\\n                    count[edge[1]] = 1\\n                    n-=1\\n                    continue\\n                if(count[edge[1]]):\\n                    nodes[edge[1]][\"sons\"].append(edge[0])\\n                    nodes[edge[0]][\"father\"] = edge[1]\\n                    count[edge[0]] = 1\\n                    n-=1\\n\\n        def get_dep(root,dep):\\n            nodes[root][\"dep\"] = dep\\n            for son in nodes[root][\"sons\"]:\\n                get_dep(son,dep + 1)\\n        get_dep(0,0)\\n        roads = [None for i in trips]\\n        def get_road(pre,node,target,pos):\\n            if(node == target):\\n                pre.append(target)\\n                roads[pos] = pre.copy()\\n                pre.pop()\\n                return\\n            if(not pre):\\n                pre.append(node)\\n                if(nodes[node][\"father\"] >= 0):\\n                    get_road(pre,nodes[node][\"father\"],target,pos)\\n                for son in nodes[node][\"sons\"]:\\n                    get_road(pre,son,target,pos)\\n                pre.pop()\\n                return\\n            pre.append(node)\\n            if(nodes[node][\"father\"] >= 0 and not nodes[node][\"father\"] == pre[-2]):\\n                get_road(pre,nodes[node][\"father\"],target,pos)\\n            for son in nodes[node][\"sons\"]:\\n                if(son == pre[-2]):continue\\n                get_road(pre,son,target,pos)\\n            pre.pop()\\n            return\\n        for i in range(len(roads)):\\n            get_road([],trips[i][0],trips[i][1],i)\\n        nothalf = [0 for i in nodes]\\n        half = [0 for i in nodes]\\n        for i in range(len(trips)):\\n            for node in roads[i]:\\n                nodes[node][\"times\"] += 1\\n        for i in range(len(nodes)):\\n            price[i] = price[i]*nodes[i][\"times\"]\\n        def dp(root):\\n            if(not nodes[root][\"sons\"]):\\n                half[root] = price[root]//2\\n                nothalf[root] = price[root]\\n                return\\n            son_sum = 0\\n            son_level = 0\\n            for son in nodes[root][\"sons\"]:\\n                dp(son)\\n                nothalf[root] += min(half[son],nothalf[son])\\n                half[root] += nothalf[son]\\n            nothalf[root] += price[root]\\n            half[root] += price[root]//2\\n            return\\n        dp(0)\\n        return min(nothalf[0],half[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423947,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    pair<int, int> dfs(int v, vector<vector<int>>& edge, vector<int>& count, vector<int>& price, int p) {\\n        pair<int, int> sol;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                pair<int, int> d = dfs(u, edge, count, price, v);\\n                sol.first += d.second;\\n                sol.second += min(d.second, d.first);\\n            }\\n        }\\n        sol.first += count[v] * price[v] / 2;\\n        sol.second += count[v] * price[v];\\n        return sol;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<int> parent(n);\\n        vector<int> depth(n);\\n        parent[0] = 0;\\n        vector<int> que;\\n        que.push_back(0);\\n        depth[0] = 1;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (depth[u] == 0) {\\n                    depth[u] = depth[v] + 1;\\n                    parent[u] = v;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vector<int> count(n);\\n        for (const vector<int>& vec : trips) {\\n            int u = vec[0];\\n            int v = vec[1];\\n            if (depth[u] > depth[v]) swap(u, v);\\n            while (depth[v] > depth[u] && v != u) {\\n                ++count[v];\\n                v = parent[v];\\n            }\\n            while (u != v) {\\n                ++count[u];\\n                ++count[v];\\n                u = parent[u];\\n                v = parent[v];\\n            }\\n            ++count[u];\\n        }\\n        pair<int, int> sol =  dfs(0, edge, count, price, -1);\\n        return min(sol.first, sol.second);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    pair<int, int> dfs(int v, vector<vector<int>>& edge, vector<int>& count, vector<int>& price, int p) {\\n        pair<int, int> sol;\\n        for (int u : edge[v]) {\\n            if (u != p) {\\n                pair<int, int> d = dfs(u, edge, count, price, v);\\n                sol.first += d.second;\\n                sol.second += min(d.second, d.first);\\n            }\\n        }\\n        sol.first += count[v] * price[v] / 2;\\n        sol.second += count[v] * price[v];\\n        return sol;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> edge(n);\\n        for (const vector<int>& v : edges) {\\n            edge[v[0]].push_back(v[1]);\\n            edge[v[1]].push_back(v[0]);\\n        }\\n        vector<int> parent(n);\\n        vector<int> depth(n);\\n        parent[0] = 0;\\n        vector<int> que;\\n        que.push_back(0);\\n        depth[0] = 1;\\n        for (int i = 0; i < (int) que.size(); i++) {\\n            int v = que[i];\\n            for (int u : edge[v]) {\\n                if (depth[u] == 0) {\\n                    depth[u] = depth[v] + 1;\\n                    parent[u] = v;\\n                    que.push_back(u);\\n                }\\n            }\\n        }\\n        vector<int> count(n);\\n        for (const vector<int>& vec : trips) {\\n            int u = vec[0];\\n            int v = vec[1];\\n            if (depth[u] > depth[v]) swap(u, v);\\n            while (depth[v] > depth[u] && v != u) {\\n                ++count[v];\\n                v = parent[v];\\n            }\\n            while (u != v) {\\n                ++count[u];\\n                ++count[v];\\n                u = parent[u];\\n                v = parent[v];\\n            }\\n            ++count[u];\\n        }\\n        pair<int, int> sol =  dfs(0, edge, count, price, -1);\\n        return min(sol.first, sol.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423712,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        var tree = InitTree(n, edges);\\n        var cnt = new int[n];\\n\\n        foreach (var trip in trips)\\n        {\\n            var up = new Dictionary<int, int> { [trip[0]] = -1 };\\n\\n            Bfs(trip, tree, up);\\n\\n            for (var u = trip[1]; u >= 0; u = up[u])\\n                cnt[u]++;\\n        }\\n\\n        var (w, h) = Dfs(0, -1, tree, price, cnt);\\n\\n        return Math.Min(w, h);\\n    }\\n\\n    private static List<List<int>> InitTree(int n, int[][] edges)\\n    {\\n        var tree = new List<List<int>>();\\n\\n        for (var i = 0; i < n; i++)\\n            tree.Add(new List<int>());\\n\\n        foreach (var e in edges)\\n        {\\n            tree[e[0]].Add(e[1]);\\n            tree[e[1]].Add(e[0]);\\n        }\\n\\n        return tree;\\n    }\\n\\n    private static void Bfs(int[] trip, List<List<int>> tree, Dictionary<int, int> up)\\n    {\\n        var q = new Queue<(int, int)>();\\n        q.Enqueue((trip[0], -1));\\n\\n        while (q.Count > 0)\\n        {\\n            var (u, p) = q.Dequeue();\\n\\n            if (u == trip[1])\\n                break;\\n\\n            foreach (var v in tree[u].Where(v => v != p))\\n            {\\n                q.Enqueue((v, u));\\n                up[v] = u;\\n            }\\n        }\\n    }\\n\\n    private static (int, int) Dfs(int u, int p, List<List<int>> tree, int[] price, int[] cnt)\\n    {\\n        int whole = 0, halved = 0;\\n\\n        foreach (var v in tree[u].Where(v => v != p))\\n        {\\n            var (w, h) = Dfs(v, u, tree, price, cnt);\\n            whole += w;\\n            halved += Math.Min(w, h);\\n        }\\n\\n        return (price[u] * cnt[u] + halved, price[u] * cnt[u] / 2 + whole);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int MinimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips)\\n    {\\n        var tree = InitTree(n, edges);\\n        var cnt = new int[n];\\n\\n        foreach (var trip in trips)\\n        {\\n            var up = new Dictionary<int, int> { [trip[0]] = -1 };\\n\\n            Bfs(trip, tree, up);\\n\\n            for (var u = trip[1]; u >= 0; u = up[u])\\n                cnt[u]++;\\n        }\\n\\n        var (w, h) = Dfs(0, -1, tree, price, cnt);\\n\\n        return Math.Min(w, h);\\n    }\\n\\n    private static List<List<int>> InitTree(int n, int[][] edges)\\n    {\\n        var tree = new List<List<int>>();\\n\\n        for (var i = 0; i < n; i++)\\n            tree.Add(new List<int>());\\n\\n        foreach (var e in edges)\\n        {\\n            tree[e[0]].Add(e[1]);\\n            tree[e[1]].Add(e[0]);\\n        }\\n\\n        return tree;\\n    }\\n\\n    private static void Bfs(int[] trip, List<List<int>> tree, Dictionary<int, int> up)\\n    {\\n        var q = new Queue<(int, int)>();\\n        q.Enqueue((trip[0], -1));\\n\\n        while (q.Count > 0)\\n        {\\n            var (u, p) = q.Dequeue();\\n\\n            if (u == trip[1])\\n                break;\\n\\n            foreach (var v in tree[u].Where(v => v != p))\\n            {\\n                q.Enqueue((v, u));\\n                up[v] = u;\\n            }\\n        }\\n    }\\n\\n    private static (int, int) Dfs(int u, int p, List<List<int>> tree, int[] price, int[] cnt)\\n    {\\n        int whole = 0, halved = 0;\\n\\n        foreach (var v in tree[u].Where(v => v != p))\\n        {\\n            var (w, h) = Dfs(v, u, tree, price, cnt);\\n            whole += w;\\n            halved += Math.Min(w, h);\\n        }\\n\\n        return (price[u] * cnt[u] + halved, price[u] * cnt[u] / 2 + whole);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423695,
                "title": "java-easy-to-understand-solution-dp-dfs-shortest-path",
                "content": "# Approach\\nWe want to minimize total price sum to perform all the given trips.\\n> Each trip is independent of each other.\\n\\nSo for each trip to travel in minimum price, we would find shortest path (using dijkstra shortest path algorithm).\\n\\nWe will also store path, so that we can use it to calculate freq[i] = number of times we visit ith node during our all trips.\\n\\n> You can choose some non-adjacent nodes and halve the prices.\\n\\nWe should choose nodes in such a way that they are not-adjacent and also minimize total trip cost.\\n\\n> Here, greedy approach for selecting nodes won\\'t work in all cases.\\nSo we will use DP approach.\\n\\nWe have two cases : \\n1.  Current node is selected for halving it\\'s price.\\n    - now for each of it\\'s adjacent node, we must not select them for halving their prices.\\n2.  Current node is not selected for halving it\\'s price.\\n    - now for each of it\\'s adjacent node, we may or may not select them for halving their prices. \\n\\nFinally, we will add memorization to store already calculated states, and reduce complexity.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    static class Pair implements Comparable<Pair> {\\n        int at;\\n        int dist;\\n        \\n        Pair (int at, int dist) {\\n            this.at = at;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return Integer.compare(dist, p.dist);\\n        }\\n    }\\n    \\n    static int MAX = 51, INF = (int) 1e9;\\n    static List<Integer>[] graph = new List[MAX];\\n    static int[] distance = new int[MAX];\\n    static int[] parent = new int[MAX];\\n    static int[][] dp = new int[MAX][2];\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int[] freq = new int[n];\\n        for (int[] trip : trips) {\\n            shortestPath(price, freq, trip[0], trip[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return Math.min(dfs(freq, price, 0, -1, 1), dfs(freq, price, 0, -1, 0));\\n    }\\n\\n    private static int dfs(int[] freq, int[] price, int currNode, int parent, int halved) {\\n        if (dp[currNode][halved] != -1) {\\n            return dp[currNode][halved];\\n        }\\n        int total = freq[currNode] * (halved == 1 ? price[currNode] / 2 : price[currNode]);\\n        for (int adj : graph[currNode]) {\\n            if (adj != parent) {\\n                if (halved == 1) {\\n                    total += dfs(freq, price, adj, currNode, 1 - halved);\\n                }else {\\n                    total += Math.min(dfs(freq, price, adj, currNode, halved), dfs(freq, price, adj, currNode, 1 - halved));\\n                }\\n            }\\n        }\\n        dp[currNode][halved] = total;\\n        return total;\\n    }\\n    \\n    public void shortestPath(int[] price, int[] freq, int node1, int node2) {\\n        if (node1 == node2) {\\n            freq[node1]++;\\n            return;\\n        }\\n        Arrays.fill(distance, INF);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        distance[node1] = price[node1];\\n        Arrays.fill(parent, -1);\\n        pq.add(new Pair(node1, distance[node1]));\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int at = currPair.at;\\n            int dist = currPair.dist;\\n            if (at == node2) {\\n                int curr = node2;\\n                while (curr != node1) {\\n                    freq[curr]++;\\n                    curr = parent[curr];\\n                }\\n                freq[curr]++;\\n            }\\n            if (distance[at] < dist) {\\n                continue;\\n            }\\n            for (int adj : graph[at]) {\\n                if (distance[adj] > dist + price[adj]) {\\n                    distance[adj] = dist + price[adj];\\n                    pq.add(new Pair(adj, distance[adj]));\\n                    parent[adj] = at;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    \\n    static class Pair implements Comparable<Pair> {\\n        int at;\\n        int dist;\\n        \\n        Pair (int at, int dist) {\\n            this.at = at;\\n            this.dist = dist;\\n        }\\n        \\n        public int compareTo(Pair p) {\\n            return Integer.compare(dist, p.dist);\\n        }\\n    }\\n    \\n    static int MAX = 51, INF = (int) 1e9;\\n    static List<Integer>[] graph = new List[MAX];\\n    static int[] distance = new int[MAX];\\n    static int[] parent = new int[MAX];\\n    static int[][] dp = new int[MAX][2];\\n    \\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        int[] freq = new int[n];\\n        for (int[] trip : trips) {\\n            shortestPath(price, freq, trip[0], trip[1]);\\n        }\\n        for (int i = 0; i < n; i++) {\\n            Arrays.fill(dp[i], -1);\\n        }\\n        return Math.min(dfs(freq, price, 0, -1, 1), dfs(freq, price, 0, -1, 0));\\n    }\\n\\n    private static int dfs(int[] freq, int[] price, int currNode, int parent, int halved) {\\n        if (dp[currNode][halved] != -1) {\\n            return dp[currNode][halved];\\n        }\\n        int total = freq[currNode] * (halved == 1 ? price[currNode] / 2 : price[currNode]);\\n        for (int adj : graph[currNode]) {\\n            if (adj != parent) {\\n                if (halved == 1) {\\n                    total += dfs(freq, price, adj, currNode, 1 - halved);\\n                }else {\\n                    total += Math.min(dfs(freq, price, adj, currNode, halved), dfs(freq, price, adj, currNode, 1 - halved));\\n                }\\n            }\\n        }\\n        dp[currNode][halved] = total;\\n        return total;\\n    }\\n    \\n    public void shortestPath(int[] price, int[] freq, int node1, int node2) {\\n        if (node1 == node2) {\\n            freq[node1]++;\\n            return;\\n        }\\n        Arrays.fill(distance, INF);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>();\\n        distance[node1] = price[node1];\\n        Arrays.fill(parent, -1);\\n        pq.add(new Pair(node1, distance[node1]));\\n        while (!pq.isEmpty()) {\\n            Pair currPair = pq.poll();\\n            int at = currPair.at;\\n            int dist = currPair.dist;\\n            if (at == node2) {\\n                int curr = node2;\\n                while (curr != node1) {\\n                    freq[curr]++;\\n                    curr = parent[curr];\\n                }\\n                freq[curr]++;\\n            }\\n            if (distance[at] < dist) {\\n                continue;\\n            }\\n            for (int adj : graph[at]) {\\n                if (distance[adj] > dist + price[adj]) {\\n                    distance[adj] = dist + price[adj];\\n                    pq.add(new Pair(adj, distance[adj]));\\n                    parent[adj] = at;\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423542,
                "title": "python-simple-dfs-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        self.total, dict1 = 0, defaultdict(int)\\n\\n        def dfs(start,parent,end):\\n            if start == end:\\n                return True\\n\\n            for neighbor in graph[start]:\\n                if neighbor != parent:\\n                    if dfs(neighbor,start,end):\\n                        self.total += price[neighbor]\\n                        dict1[neighbor] += 1\\n                        return True\\n\\n            return False\\n\\n\\n        for start,end in trips:\\n            dict1[start] += 1\\n            self.total += price[start]\\n            dfs(start,None,end)\\n\\n        @lru_cache(None)\\n        def dp(node,parent,canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*dict1[node]\\n            else:\\n                res = 0\\n\\n            tot = 0\\n\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    if canReduce:\\n                        cur = dp(neighbor,node,False)\\n                    else:\\n                        cur = max(dp(neighbor,node,True),dp(neighbor,node,False))\\n                    tot += cur\\n\\n            return res + tot\\n\\n        ans = []\\n\\n        for i in range(n):\\n            ans.append(max(dp(i,None,False),dp(i,None,True)))\\n\\n        return self.total - max(ans)\\n            \\n\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n, edges, price, trips):\\n        graph = defaultdict(list)\\n\\n        for i,j in edges:\\n            graph[i].append(j)\\n            graph[j].append(i)\\n\\n        self.total, dict1 = 0, defaultdict(int)\\n\\n        def dfs(start,parent,end):\\n            if start == end:\\n                return True\\n\\n            for neighbor in graph[start]:\\n                if neighbor != parent:\\n                    if dfs(neighbor,start,end):\\n                        self.total += price[neighbor]\\n                        dict1[neighbor] += 1\\n                        return True\\n\\n            return False\\n\\n\\n        for start,end in trips:\\n            dict1[start] += 1\\n            self.total += price[start]\\n            dfs(start,None,end)\\n\\n        @lru_cache(None)\\n        def dp(node,parent,canReduce):\\n            if canReduce:\\n                res = (price[node]//2)*dict1[node]\\n            else:\\n                res = 0\\n\\n            tot = 0\\n\\n            for neighbor in graph[node]:\\n                if neighbor != parent:\\n                    if canReduce:\\n                        cur = dp(neighbor,node,False)\\n                    else:\\n                        cur = max(dp(neighbor,node,True),dp(neighbor,node,False))\\n                    tot += cur\\n\\n            return res + tot\\n\\n        ans = []\\n\\n        for i in range(n):\\n            ans.append(max(dp(i,None,False),dp(i,None,True)))\\n\\n        return self.total - max(ans)\\n            \\n\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423526,
                "title": "python-simple-dfs-with-explanation",
                "content": "# Intuition\\nAlthough the question says we can choose any path from `u` to `v` in `trips`, in a connected tree there will always be only exactly one path from `u` to `v`\\n\\n# Approach\\nCalculate every node\\'s occurance and store them on `repeats`. `repeats[i]` means for vertex `i`, how many times does it have to appear after visiting all `trips`.\\n\\nThen we can brute-force the solution, for each vertex, we can choose either to `halve` it or not to `halve` it. Then recurse to it\\'s neighbours. We can use `lru_cache(None)` to memoize the solution to prevent repeat.\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n is total number of nodes in the tree\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        repeats = [0] * n\\n        inf = float(\\'inf\\')\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        for u, v in trips:\\n            stk = [u]\\n            parents = [-1] * n\\n            while len(stk):\\n                p = stk.pop()\\n                for nei in adj[p]:\\n                    if nei != parents[p]:\\n                        stk.append(nei)\\n                        parents[nei] = p\\n                        if nei == v:\\n                            break\\n            now = v\\n            while now != -1:\\n                repeats[now] += 1\\n                now = parents[now]\\n        @lru_cache(None)\\n        def dfs(vertex: int, parent: int, parent_halved: bool):\\n            # If parent already halved, then this vertex can\\'t be halved, so give it a inf\\n            halved = inf if parent_halved else (price[vertex] * repeats[vertex]) // 2\\n            not_halved = (price[vertex] * repeats[vertex])\\n            for nei in adj[vertex]:\\n                if nei == parent:\\n                    continue\\n                if halved < inf:\\n                    halved += dfs(nei, vertex, True)\\n                not_halved += dfs(nei, vertex, False)\\n            return min(halved, not_halved)\\n        return dfs(0, -1, False)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        adj = [[] for _ in range(n)]\\n        repeats = [0] * n\\n        inf = float(\\'inf\\')\\n        for u, v in edges:\\n            adj[u].append(v)\\n            adj[v].append(u)\\n        for u, v in trips:\\n            stk = [u]\\n            parents = [-1] * n\\n            while len(stk):\\n                p = stk.pop()\\n                for nei in adj[p]:\\n                    if nei != parents[p]:\\n                        stk.append(nei)\\n                        parents[nei] = p\\n                        if nei == v:\\n                            break\\n            now = v\\n            while now != -1:\\n                repeats[now] += 1\\n                now = parents[now]\\n        @lru_cache(None)\\n        def dfs(vertex: int, parent: int, parent_halved: bool):\\n            # If parent already halved, then this vertex can\\'t be halved, so give it a inf\\n            halved = inf if parent_halved else (price[vertex] * repeats[vertex]) // 2\\n            not_halved = (price[vertex] * repeats[vertex])\\n            for nei in adj[vertex]:\\n                if nei == parent:\\n                    continue\\n                if halved < inf:\\n                    halved += dfs(nei, vertex, True)\\n                not_halved += dfs(nei, vertex, False)\\n            return min(halved, not_halved)\\n        return dfs(0, -1, False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423037,
                "title": "easy-dfs-dp-c",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph ;\\n    vector<int> path , vis , cst;\\n    vector<vector<vector<int>>> dp ;\\n    int fun(int i , int par , int end){\\n        if(i==end){\\n            path[i]++ ;\\n            return 1 ;\\n        }\\n        int ans=0 ;\\n        for(auto d:graph[i]){\\n            if(d==par) continue ;\\n            if(fun(d,i,end)){\\n                 path[i]++ ;\\n                 ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n\\n    int cost(int i , int par , int typ){\\n        if(dp[i][par][typ]!=-1) return dp[i][par][typ] ;\\n        vis[i]=1 ;\\n        int ans=0 ;\\n        if(typ==1){\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                ans+=cost(d,i,0) ;\\n            }\\n            ans+=(path[i]*cst[i]) ;\\n        }\\n        if(typ==0){\\n            int temp1=0 , temp2=0 ;\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                temp2+=cost(d,i,1) ;\\n                temp1+=cost(d,i,0) ;\\n            }\\n            ans=min(temp1+(path[i]*cst[i]),temp2+(path[i]*(cst[i]/2))) ;\\n        }\\n        return dp[i][par][typ]=ans ;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph=vector<vector<int>>(n) ;\\n        cst=price ;\\n        vis=vector<int>(n) ;\\n        path=vector<int>(n) ;\\n        dp=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2,-1))) ;\\n        for(auto d:edges){\\n            graph[d[0]].push_back(d[1]) ;\\n            graph[d[1]].push_back(d[0]) ;\\n        }\\n        for(auto d:trips) fun(d[0],-1,d[1]) ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            if(path[i]==0 || vis[i]) continue ;\\n            ans+=cost(i,i,0) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph ;\\n    vector<int> path , vis , cst;\\n    vector<vector<vector<int>>> dp ;\\n    int fun(int i , int par , int end){\\n        if(i==end){\\n            path[i]++ ;\\n            return 1 ;\\n        }\\n        int ans=0 ;\\n        for(auto d:graph[i]){\\n            if(d==par) continue ;\\n            if(fun(d,i,end)){\\n                 path[i]++ ;\\n                 ans++ ;\\n            }\\n        }\\n        return ans ;\\n    }\\n\\n    int cost(int i , int par , int typ){\\n        if(dp[i][par][typ]!=-1) return dp[i][par][typ] ;\\n        vis[i]=1 ;\\n        int ans=0 ;\\n        if(typ==1){\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                ans+=cost(d,i,0) ;\\n            }\\n            ans+=(path[i]*cst[i]) ;\\n        }\\n        if(typ==0){\\n            int temp1=0 , temp2=0 ;\\n            for(auto d:graph[i]){\\n                if(d==par || path[d]==0) continue ;\\n                temp2+=cost(d,i,1) ;\\n                temp1+=cost(d,i,0) ;\\n            }\\n            ans=min(temp1+(path[i]*cst[i]),temp2+(path[i]*(cst[i]/2))) ;\\n        }\\n        return dp[i][par][typ]=ans ;\\n    }\\n\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        graph=vector<vector<int>>(n) ;\\n        cst=price ;\\n        vis=vector<int>(n) ;\\n        path=vector<int>(n) ;\\n        dp=vector<vector<vector<int>>>(n,vector<vector<int>>(n,vector<int>(2,-1))) ;\\n        for(auto d:edges){\\n            graph[d[0]].push_back(d[1]) ;\\n            graph[d[1]].push_back(d[0]) ;\\n        }\\n        for(auto d:trips) fun(d[0],-1,d[1]) ;\\n        int ans=0 ;\\n        for(int i=0 ; i<n ; i++){\\n            if(path[i]==0 || vis[i]) continue ;\\n            ans+=cost(i,i,0) ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423027,
                "title": "similar-to-knapsack-java-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    ArrayList<ArrayList<Integer>>graph;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        graph=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        int []visitCount=new int [n];\\n\\n        for(int i=0;i<trips.length;i++){\\n            int src=trips[i][0];\\n            int des=trips[i][1];\\n          find(src,des,visitCount,-1);\\n\\n\\n        }\\n\\n        int []cost=new int[n];\\n        for(int i=0;i<n;i++){\\n            cost[i]=price[i]*visitCount[i];\\n\\n        }\\n\\nint [][]dp=new int [n][2];\\n\\nfor(int  i=0;i<n;i++){\\n    for(int j=0;j<2;j++){\\n        dp[i][j]=-1;\\n    }\\n}\\n\\n\\nreturn min(0,cost,dp,-1,0);\\n    }\\n\\n    public int min(int node,int []cost,int [][]dp,int parent,int color)\\n    {\\n        if(dp[node][color]!=-1){\\n            return dp[node][color];\\n        }\\n        int x=0;\\n        int y=0;\\n\\n        for(int nbr:graph.get(node)){\\n            if(nbr!=parent){\\n               x+=min(nbr,cost,dp,node,0);\\n            \\n               if(color==0){\\n             y+=min(nbr,cost,dp,node,1);\\n               }\\n              \\n            }\\n          \\n        }\\n        if(color==1){\\n            return dp[node][color]=x+(cost[node]);\\n        }\\n\\n        return dp[node][color]=Math.min(x+cost[node],y+(cost[node]/2));\\n\\n\\n    \\n        \\n    }\\n\\n    public boolean find(int src,int dest,int []visitCount,int parent){\\n        visitCount[src]++;\\n        if(src==dest){\\n            return true;\\n        }\\n        for(int nbr:graph.get(src)){\\n\\n            if(nbr!=parent){\\n\\n           boolean f1= find(nbr,dest,visitCount,src);\\n           if(f1){\\n               return true;\\n           }\\n\\n            }\\n\\n        }\\n        visitCount[src]--;\\n        return false;\\n    }\\n\\n   \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    ArrayList<ArrayList<Integer>>graph;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        graph=new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int u=edges[i][0];\\n            int v=edges[i][1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        int []visitCount=new int [n];\\n\\n        for(int i=0;i<trips.length;i++){\\n            int src=trips[i][0];\\n            int des=trips[i][1];\\n          find(src,des,visitCount,-1);\\n\\n\\n        }\\n\\n        int []cost=new int[n];\\n        for(int i=0;i<n;i++){\\n            cost[i]=price[i]*visitCount[i];\\n\\n        }\\n\\nint [][]dp=new int [n][2];\\n\\nfor(int  i=0;i<n;i++){\\n    for(int j=0;j<2;j++){\\n        dp[i][j]=-1;\\n    }\\n}\\n\\n\\nreturn min(0,cost,dp,-1,0);\\n    }\\n\\n    public int min(int node,int []cost,int [][]dp,int parent,int color)\\n    {\\n        if(dp[node][color]!=-1){\\n            return dp[node][color];\\n        }\\n        int x=0;\\n        int y=0;\\n\\n        for(int nbr:graph.get(node)){\\n            if(nbr!=parent){\\n               x+=min(nbr,cost,dp,node,0);\\n            \\n               if(color==0){\\n             y+=min(nbr,cost,dp,node,1);\\n               }\\n              \\n            }\\n          \\n        }\\n        if(color==1){\\n            return dp[node][color]=x+(cost[node]);\\n        }\\n\\n        return dp[node][color]=Math.min(x+cost[node],y+(cost[node]/2));\\n\\n\\n    \\n        \\n    }\\n\\n    public boolean find(int src,int dest,int []visitCount,int parent){\\n        visitCount[src]++;\\n        if(src==dest){\\n            return true;\\n        }\\n        for(int nbr:graph.get(src)){\\n\\n            if(nbr!=parent){\\n\\n           boolean f1= find(nbr,dest,visitCount,src);\\n           if(f1){\\n               return true;\\n           }\\n\\n            }\\n\\n        }\\n        visitCount[src]--;\\n        return false;\\n    }\\n\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422979,
                "title": "dynamic-programming-0-1-concise-easy-simple-code-with-explanation",
                "content": "```\\nclass Solution {\\n    \\n    pair<int,int> minNonAdjecentPath(int u,int parent,vector<int>&price,unordered_map<int,int>&mp,vector<int>adj[]){\\n        int considerHalf = (price[u]/2)*mp[u];\\n        int notConsiderHalf = (price[u])*mp[u];\\n        for(auto v: adj[u]){\\n            if(v==parent) continue;\\n            pair<int,int>childAns = minNonAdjecentPath(v,u,price,mp,adj);\\n            notConsiderHalf +=min(childAns.first,childAns.second);\\n            \\n            considerHalf+=childAns.second;\\n        }\\n        \\n        return {considerHalf,notConsiderHalf};\\n    }\\n    \\npublic:\\n    // Use to calculate the contribution/count of each node in the whole trips....\\n    bool dfs(vector<int>adj[],int src,int des,bool vis[],unordered_map<int,int>&mp){\\n        vis[src]=true;\\n        mp[src]++;\\n        if(src==des)\\n            return true;\\n        for(auto x: adj[src]){\\n            if(vis[x]==false){\\n                bool b =  dfs(adj,x,des,vis,mp);\\n                if(b) return b;\\n            }\\n        }\\n        mp[src]--;\\n        return false;\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto x: edges){\\n            int src = x[0],des=x[1];\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x: trips){\\n            int src = x[0],des=x[1];\\n            bool vis[n]; memset(vis,false,sizeof(vis));\\n            dfs(adj,src,des,vis,mp);\\n        }\\n        \\n      \\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price,mp,adj);\\n        return min(ans.first,ans.second);\\n    }\\n};\\n```\\n\\nTime Complexity -> O(n)  // It\\'s like kind of post order traversal & we traversed each node only once\\nSpace Complexity -> O(n)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    pair<int,int> minNonAdjecentPath(int u,int parent,vector<int>&price,unordered_map<int,int>&mp,vector<int>adj[]){\\n        int considerHalf = (price[u]/2)*mp[u];\\n        int notConsiderHalf = (price[u])*mp[u];\\n        for(auto v: adj[u]){\\n            if(v==parent) continue;\\n            pair<int,int>childAns = minNonAdjecentPath(v,u,price,mp,adj);\\n            notConsiderHalf +=min(childAns.first,childAns.second);\\n            \\n            considerHalf+=childAns.second;\\n        }\\n        \\n        return {considerHalf,notConsiderHalf};\\n    }\\n    \\npublic:\\n    // Use to calculate the contribution/count of each node in the whole trips....\\n    bool dfs(vector<int>adj[],int src,int des,bool vis[],unordered_map<int,int>&mp){\\n        vis[src]=true;\\n        mp[src]++;\\n        if(src==des)\\n            return true;\\n        for(auto x: adj[src]){\\n            if(vis[x]==false){\\n                bool b =  dfs(adj,x,des,vis,mp);\\n                if(b) return b;\\n            }\\n        }\\n        mp[src]--;\\n        return false;\\n    }\\n    \\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto x: edges){\\n            int src = x[0],des=x[1];\\n            adj[src].push_back(des);\\n            adj[des].push_back(src);\\n        }\\n        \\n        unordered_map<int,int>mp;\\n        for(auto x: trips){\\n            int src = x[0],des=x[1];\\n            bool vis[n]; memset(vis,false,sizeof(vis));\\n            dfs(adj,src,des,vis,mp);\\n        }\\n        \\n      \\n        pair<int,int> ans = minNonAdjecentPath(0,-1,price,mp,adj);\\n        return min(ans.first,ans.second);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422768,
                "title": "java-dfs-dp-on-graphs",
                "content": "Given, that its a tree, we are always sure of what the path will be irrespective of the cost.\\nHence, we first compute how many times we visit all  nodes, after completing all the trips.\\nThen we traverse the complete tree, and check whether we should halve a particular node or keep it just as it is.\\nAnd at every node compute the amount we need to take from the node.\\nSince there will be repeating subproblems of again visiting a node with option to check whether we should halve it or not, we use2D DP matrix.\\n```\\nclass Solution {\\n\\n    public void countNodesInPath(int start, int end, int[][] adj, Map<Integer, Integer> count, List<Integer> ls, int[] vis) {\\n        if (vis[start] != -1) return;\\n        vis[start] = 1;\\n        if (start == end) {\\n            for (int i = 0; i < ls.size(); i++) {\\n                count.put(ls.get(i), count.getOrDefault(ls.get(i), 0) + 1);\\n            }\\n            return;\\n        }\\n        for (int j = 0; j < adj[start].length; j++) {\\n            if (adj[start][j] == 1) {\\n                ls.add(j);\\n                countNodesInPath(j, end, adj, count, ls, vis);\\n                ls.remove(ls.size() - 1);\\n            }\\n        }\\n    }\\n\\n    public int calcPrice(int start, int[][] adj, boolean prev, int[] prices, Map<Integer, Integer> count, int parent, int[][] dp) {\\n        int halve = 0;\\n        int yy = 0;\\n        if (prev == true) yy = 1;\\n        if (dp[start][yy] != -1) return dp[start][yy];\\n        if (prev == false) {\\n            for (int i = 0; i < adj[start].length; i++) {\\n                if (adj[start][i] == 1 && i != parent) {\\n                    halve += calcPrice(i, adj, true, prices, count, start, dp);\\n                }\\n            }\\n            halve += (prices[start] / 2) * count.getOrDefault(start, 0);\\n        }\\n        int nothalve = 0;\\n        for (int i = 0; i < adj[start].length; i++) {\\n            if (adj[start][i] == 1 && i != parent) {\\n                nothalve += calcPrice(i, adj, false, prices, count, start, dp);\\n            }\\n        }\\n        nothalve += prices[start] * count.getOrDefault(start, 0);\\n        if (prev == true) halve = Integer.MAX_VALUE;\\n        return dp[start][yy] = Math.min(halve, nothalve);\\n    }\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] prices, int[][] trips) {\\n        int[][] adj = new int[n][n];\\n        int[][] dp = new int[n][2];\\n        for (int i = 0; i < dp.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < edges.length; i++) {\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        int[] vis = new int[n];\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            List<Integer> pathList = new ArrayList();\\n            pathList.add(start);\\n            Arrays.fill(vis, -1);\\n            countNodesInPath(start, end, adj, count, pathList, vis);\\n        }\\n        return calcPrice(0, adj, false, prices, count, -1, dp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void countNodesInPath(int start, int end, int[][] adj, Map<Integer, Integer> count, List<Integer> ls, int[] vis) {\\n        if (vis[start] != -1) return;\\n        vis[start] = 1;\\n        if (start == end) {\\n            for (int i = 0; i < ls.size(); i++) {\\n                count.put(ls.get(i), count.getOrDefault(ls.get(i), 0) + 1);\\n            }\\n            return;\\n        }\\n        for (int j = 0; j < adj[start].length; j++) {\\n            if (adj[start][j] == 1) {\\n                ls.add(j);\\n                countNodesInPath(j, end, adj, count, ls, vis);\\n                ls.remove(ls.size() - 1);\\n            }\\n        }\\n    }\\n\\n    public int calcPrice(int start, int[][] adj, boolean prev, int[] prices, Map<Integer, Integer> count, int parent, int[][] dp) {\\n        int halve = 0;\\n        int yy = 0;\\n        if (prev == true) yy = 1;\\n        if (dp[start][yy] != -1) return dp[start][yy];\\n        if (prev == false) {\\n            for (int i = 0; i < adj[start].length; i++) {\\n                if (adj[start][i] == 1 && i != parent) {\\n                    halve += calcPrice(i, adj, true, prices, count, start, dp);\\n                }\\n            }\\n            halve += (prices[start] / 2) * count.getOrDefault(start, 0);\\n        }\\n        int nothalve = 0;\\n        for (int i = 0; i < adj[start].length; i++) {\\n            if (adj[start][i] == 1 && i != parent) {\\n                nothalve += calcPrice(i, adj, false, prices, count, start, dp);\\n            }\\n        }\\n        nothalve += prices[start] * count.getOrDefault(start, 0);\\n        if (prev == true) halve = Integer.MAX_VALUE;\\n        return dp[start][yy] = Math.min(halve, nothalve);\\n    }\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] prices, int[][] trips) {\\n        int[][] adj = new int[n][n];\\n        int[][] dp = new int[n][2];\\n        for (int i = 0; i < dp.length; i++) Arrays.fill(dp[i], -1);\\n        for (int i = 0; i < edges.length; i++) {\\n            adj[edges[i][0]][edges[i][1]] = 1;\\n            adj[edges[i][1]][edges[i][0]] = 1;\\n        }\\n        int[] vis = new int[n];\\n        Map<Integer, Integer> count = new HashMap();\\n        for (int i = 0; i < trips.length; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            List<Integer> pathList = new ArrayList();\\n            pathList.add(start);\\n            Arrays.fill(vis, -1);\\n            countNodesInPath(start, end, adj, count, pathList, vis);\\n        }\\n        return calcPrice(0, adj, false, prices, count, -1, dp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422644,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![vec![-1; 2]; 51]; // dp optimization to not recalculate values\\n        let mut mp = vec![0; 51]; // count how many times a node is used in trips\\n\\n        let mut adj = vec![vec![]; n as usize];\\n        for i in edges {\\n            adj[i[0] as usize].push(i[1]);\\n            adj[i[1] as usize].push(i[0]);\\n        }\\n        for i in trips.iter() {\\n            Self::count_paths(&mut mp, &adj, i[0], i[1]);\\n        }\\n        Self::dfs(&mut dp, &mp, &adj, 0, &price, true, -1)\\n    }\\n\\n    fn count_paths(mp: &mut [i32], adj: &[Vec<i32>], x: i32, y: i32) {\\n        let mut q = std::collections::VecDeque::new();\\n        q.push_back((x, -1));\\n        let mut vis = vec![0; 51];\\n        let mut last = vec![0; 51]; // so we can efficiently backtrack the path from node a to node b\\n        while !q.is_empty() {\\n            let (mut t, p) = q.pop_front().unwrap();\\n            if vis[t as usize] != 0 {\\n                vis[t as usize] += 1;\\n                continue;\\n            }\\n            vis[t as usize] += 1;\\n            last[t as usize] = p;\\n            if t == y {\\n                while t != -1 {\\n                    mp[t as usize] += 1;\\n                    t = last[t as usize];\\n                }\\n                return;\\n            }\\n            for i in &adj[t as usize] {\\n                q.push_back((*i, t));\\n            }\\n        }\\n    }\\n\\n    #[allow(clippy::too_many_arguments)]\\n    fn dfs(dp: &mut Vec<Vec<i32>>, mp: &Vec<i32>, adj: &Vec<Vec<i32>>, pos: usize, price: &Vec<i32>, can_take: bool, last: i32) -> i32 {\\n        if dp[pos][can_take as usize] != -1 {\\n            return dp[pos][can_take as usize];\\n        }\\n        let mut ans = price[pos] * mp[pos];\\n        let mut res1 = 0;\\n        let mut res2 = 0;\\n        for &i in &adj[pos] {\\n            if i != last {\\n                res1 += Self::dfs(dp, mp, adj, i as usize, price, true, pos as i32);\\n            }\\n        }\\n        if can_take {\\n            for &i in &adj[pos] {\\n                if i != last {\\n                    res2 += Self::dfs(dp, mp, adj, i as usize, price, false, pos as i32);\\n                }\\n            }\\n            ans = (ans + res1).min(ans / 2 + res2);\\n        } else {\\n            ans += res1;\\n        }\\n        dp[pos][can_take as usize] = ans;\\n        ans\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn minimum_total_price(n: i32, edges: Vec<Vec<i32>>, price: Vec<i32>, trips: Vec<Vec<i32>>) -> i32 {\\n        let mut dp = vec![vec![-1; 2]; 51]; // dp optimization to not recalculate values\\n        let mut mp = vec![0; 51]; // count how many times a node is used in trips\\n\\n        let mut adj = vec![vec![]; n as usize];\\n        for i in edges {\\n            adj[i[0] as usize].push(i[1]);\\n            adj[i[1] as usize].push(i[0]);\\n        }\\n        for i in trips.iter() {\\n            Self::count_paths(&mut mp, &adj, i[0], i[1]);\\n        }\\n        Self::dfs(&mut dp, &mp, &adj, 0, &price, true, -1)\\n    }\\n\\n    fn count_paths(mp: &mut [i32], adj: &[Vec<i32>], x: i32, y: i32) {\\n        let mut q = std::collections::VecDeque::new();\\n        q.push_back((x, -1));\\n        let mut vis = vec![0; 51];\\n        let mut last = vec![0; 51]; // so we can efficiently backtrack the path from node a to node b\\n        while !q.is_empty() {\\n            let (mut t, p) = q.pop_front().unwrap();\\n            if vis[t as usize] != 0 {\\n                vis[t as usize] += 1;\\n                continue;\\n            }\\n            vis[t as usize] += 1;\\n            last[t as usize] = p;\\n            if t == y {\\n                while t != -1 {\\n                    mp[t as usize] += 1;\\n                    t = last[t as usize];\\n                }\\n                return;\\n            }\\n            for i in &adj[t as usize] {\\n                q.push_back((*i, t));\\n            }\\n        }\\n    }\\n\\n    #[allow(clippy::too_many_arguments)]\\n    fn dfs(dp: &mut Vec<Vec<i32>>, mp: &Vec<i32>, adj: &Vec<Vec<i32>>, pos: usize, price: &Vec<i32>, can_take: bool, last: i32) -> i32 {\\n        if dp[pos][can_take as usize] != -1 {\\n            return dp[pos][can_take as usize];\\n        }\\n        let mut ans = price[pos] * mp[pos];\\n        let mut res1 = 0;\\n        let mut res2 = 0;\\n        for &i in &adj[pos] {\\n            if i != last {\\n                res1 += Self::dfs(dp, mp, adj, i as usize, price, true, pos as i32);\\n            }\\n        }\\n        if can_take {\\n            for &i in &adj[pos] {\\n                if i != last {\\n                    res2 += Self::dfs(dp, mp, adj, i as usize, price, false, pos as i32);\\n                }\\n            }\\n            ans = (ans + res1).min(ans / 2 + res2);\\n        } else {\\n            ans += res1;\\n        }\\n        dp[pos][can_take as usize] = ans;\\n        ans\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422552,
                "title": "c-dfs-dp-solution",
                "content": "\\n# Approach\\nfirst store the nodes which occurs in the path of all trips . This can be done using simple dfs and lca concept .Then apply dfs with memoization to calculate the final answer.\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(n)\\n\\n# Code\\n```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int>lvl,par,vis;\\n    map<int,int>mp;\\n    vector<vector<int>>dp;\\n    void dfs(int src,vector<vector<int>>&g,int p,int l)\\n    {\\n        lvl[src]=l;\\n        par[src]=p;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p)\\n            {\\n                dfs(itr,g,src,l+1);\\n            }\\n        }\\n        return;\\n    }\\n    void lca(int x,int y,vector<int>&p)\\n    {\\n        if(lvl[x]<lvl[y])\\n        {\\n            swap(x,y);\\n        }\\n        while(lvl[x]>lvl[y])\\n        {\\n            mp[x]+=p[x];\\n            x=par[x];\\n        }\\n        while(x!=y)\\n        {\\n         mp[x]+=p[x],mp[y]+=p[y];\\n         x=par[x],y=par[y];\\n        }\\n        mp[x]+=p[x];\\n        return;\\n    }\\n    \\n    int func(int src,int take,vector<vector<int>>&g,int p)\\n    {\\n        if(dp[src][take]!=-1)\\n        {\\n            return dp[src][take];\\n        }\\n        int a=mp[src],b=mp[src]/2;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p and mp.count(itr))\\n            {\\n                a+=func(itr,0,g,src),b+=func(itr,1,g,src);\\n            }\\n        }\\n        if(take)\\n        {\\n           return a; \\n        }\\n        return dp[src][take]=min(a,b);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& p, vector<vector<int>>& t) {\\n        vector<vector<int>>g(n);\\n        vis.assign(n,false);\\n        dp.assign(n,vector<int>(2,-1));\\n        for(auto &itr:edges)\\n        {\\n            g[itr[0]].pb(itr[1]);\\n            g[itr[1]].pb(itr[0]);\\n        }\\n        lvl.assign(n,0),par.assign(n,-1);\\n        dfs(0,g,-1,0);\\n        for(auto &itr:t)\\n        {\\n            lca(itr[0],itr[1],p);\\n        }\\n        \\n        int ans=0;\\n        for(auto &itr:mp)\\n        {\\n            if(dp[itr.first][0]!=-1)\\n            {\\n                continue;\\n            }\\n            ans+=func(itr.first,0,g,-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\n#define pb push_back\\nclass Solution {\\npublic:\\n    vector<int>lvl,par,vis;\\n    map<int,int>mp;\\n    vector<vector<int>>dp;\\n    void dfs(int src,vector<vector<int>>&g,int p,int l)\\n    {\\n        lvl[src]=l;\\n        par[src]=p;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p)\\n            {\\n                dfs(itr,g,src,l+1);\\n            }\\n        }\\n        return;\\n    }\\n    void lca(int x,int y,vector<int>&p)\\n    {\\n        if(lvl[x]<lvl[y])\\n        {\\n            swap(x,y);\\n        }\\n        while(lvl[x]>lvl[y])\\n        {\\n            mp[x]+=p[x];\\n            x=par[x];\\n        }\\n        while(x!=y)\\n        {\\n         mp[x]+=p[x],mp[y]+=p[y];\\n         x=par[x],y=par[y];\\n        }\\n        mp[x]+=p[x];\\n        return;\\n    }\\n    \\n    int func(int src,int take,vector<vector<int>>&g,int p)\\n    {\\n        if(dp[src][take]!=-1)\\n        {\\n            return dp[src][take];\\n        }\\n        int a=mp[src],b=mp[src]/2;\\n        for(auto &itr:g[src])\\n        {\\n            if(itr!=p and mp.count(itr))\\n            {\\n                a+=func(itr,0,g,src),b+=func(itr,1,g,src);\\n            }\\n        }\\n        if(take)\\n        {\\n           return a; \\n        }\\n        return dp[src][take]=min(a,b);\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& p, vector<vector<int>>& t) {\\n        vector<vector<int>>g(n);\\n        vis.assign(n,false);\\n        dp.assign(n,vector<int>(2,-1));\\n        for(auto &itr:edges)\\n        {\\n            g[itr[0]].pb(itr[1]);\\n            g[itr[1]].pb(itr[0]);\\n        }\\n        lvl.assign(n,0),par.assign(n,-1);\\n        dfs(0,g,-1,0);\\n        for(auto &itr:t)\\n        {\\n            lca(itr[0],itr[1],p);\\n        }\\n        \\n        int ans=0;\\n        for(auto &itr:mp)\\n        {\\n            if(dp[itr.first][0]!=-1)\\n            {\\n                continue;\\n            }\\n            ans+=func(itr.first,0,g,-1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422438,
                "title": "c-solution-using-dfs-and-memoization",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> total[50];\\n    vector<int> a;\\n    int f[50]={};\\n    int dp[50][2];\\n    bool dfs1(int p,int index,int target)\\n    {\\n        if(index==target)\\n        {\\n            f[index]++;\\n            return true;\\n        }\\n        bool result=false;\\n        for(int i=0;i<total[index].size();i++)\\n            if(total[index][i]!=p) result|=dfs1(index,total[index][i],target);\\n\\n        if(result) f[index]++;\\n        return result;\\n    }\\n    int dfs2(int p,int index,bool adjacent)\\n    {\\n        if(dp[index][adjacent]!=-1) return dp[index][adjacent];\\n        int result=0,t1=0,t2=0;\\n        for(int i=0;i<total[index].size();i++)\\n        {\\n            if(p!=total[index][i])\\n            {\\n                t1+=min(dfs2(index,total[index][i],true),dfs2(index,total[index][i],false));\\n                t2+=dfs2(index,total[index][i],true);\\n            }\\n        }\\n        if(adjacent) result=f[index]*a[index]+t1;\\n        else result=min(f[index]*a[index]+t1,f[index]*a[index]/2+t2);\\n        dp[index][adjacent]=result;\\n        return result;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int m=edges.size(),t=trips.size();\\n        a=price;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) total[edges[i][0]].push_back(edges[i][1]),total[edges[i][1]].push_back(edges[i][0]);\\n        for(int i=0;i<t;i++) dfs1(-1,trips[i][0],trips[i][1]);\\n        return dfs2(-1,0,false);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    vector<int> total[50];\\n    vector<int> a;\\n    int f[50]={};\\n    int dp[50][2];\\n    bool dfs1(int p,int index,int target)\\n    {\\n        if(index==target)\\n        {\\n            f[index]++;\\n            return true;\\n        }\\n        bool result=false;\\n        for(int i=0;i<total[index].size();i++)\\n            if(total[index][i]!=p) result|=dfs1(index,total[index][i],target);\\n\\n        if(result) f[index]++;\\n        return result;\\n    }\\n    int dfs2(int p,int index,bool adjacent)\\n    {\\n        if(dp[index][adjacent]!=-1) return dp[index][adjacent];\\n        int result=0,t1=0,t2=0;\\n        for(int i=0;i<total[index].size();i++)\\n        {\\n            if(p!=total[index][i])\\n            {\\n                t1+=min(dfs2(index,total[index][i],true),dfs2(index,total[index][i],false));\\n                t2+=dfs2(index,total[index][i],true);\\n            }\\n        }\\n        if(adjacent) result=f[index]*a[index]+t1;\\n        else result=min(f[index]*a[index]+t1,f[index]*a[index]/2+t2);\\n        dp[index][adjacent]=result;\\n        return result;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) \\n    {\\n        int m=edges.size(),t=trips.size();\\n        a=price;\\n        memset(dp,-1,sizeof(dp));\\n        for(int i=0;i<m;i++) total[edges[i][0]].push_back(edges[i][1]),total[edges[i][1]].push_back(edges[i][0]);\\n        for(int i=0;i<t;i++) dfs1(-1,trips[i][0],trips[i][1]);\\n        return dfs2(-1,0,false);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422370,
                "title": "dfs-to-find-paths-and-minimum-cost",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n$$O(T * (V + E))$$\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        parent = [-1] * n\\n        cur = []\\n        \\n        # DFS to find out the path from s to e\\n        def path(node, p, e):\\n            cur.append(node)\\n            if node == e:\\n                cnts.update(cur)\\n            else:\\n                for c in graph[node]:\\n                    if c != p:\\n                        path(c, node, e)\\n            cur.pop()\\n\\n        # Compute the freq of node in all the trip paths\\n        cnts = Counter()\\n        for s, e in trips:\\n            path(s, -1, e)\\n        \\n        # DFS to check all half combinations to find minimum cost\\n        # Use cache to do dp memoization\\n        @lru_cache(None)\\n        def dfs(node, p):\\n            # node not chosen\\n            a = cnts[node] * price[node]\\n            for c in graph[node]:\\n                if c != p:\\n                    a += dfs(c, node)\\n            \\n            # node chosen\\n            b = cnts[node] * price[node] // 2\\n            for c in graph[node]:\\n                if c != p:\\n                    b += cnts[c] * price[c]\\n                    for cc in graph[c]:\\n                        if cc != node:\\n                            b += dfs(cc, c)\\n            return min(a, b)\\n        return dfs(0, -1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(set)\\n        for u, v in edges:\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        parent = [-1] * n\\n        cur = []\\n        \\n        # DFS to find out the path from s to e\\n        def path(node, p, e):\\n            cur.append(node)\\n            if node == e:\\n                cnts.update(cur)\\n            else:\\n                for c in graph[node]:\\n                    if c != p:\\n                        path(c, node, e)\\n            cur.pop()\\n\\n        # Compute the freq of node in all the trip paths\\n        cnts = Counter()\\n        for s, e in trips:\\n            path(s, -1, e)\\n        \\n        # DFS to check all half combinations to find minimum cost\\n        # Use cache to do dp memoization\\n        @lru_cache(None)\\n        def dfs(node, p):\\n            # node not chosen\\n            a = cnts[node] * price[node]\\n            for c in graph[node]:\\n                if c != p:\\n                    a += dfs(c, node)\\n            \\n            # node chosen\\n            b = cnts[node] * price[node] // 2\\n            for c in graph[node]:\\n                if c != p:\\n                    b += cnts[c] * price[c]\\n                    for cc in graph[c]:\\n                        if cc != node:\\n                            b += dfs(cc, c)\\n            return min(a, b)\\n        return dfs(0, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422313,
                "title": "javascript-tree-dp-114ms",
                "content": "prerequisite: https://leetcode.com/problems/house-robber-iii/\\n```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nlet g, cnt, dp, price;\\nconst minimumTotalPrice = (n, edges, p, trips) => {\\n    g = initializeGraph(n), cnt = Array(n).fill(0), dp = initialize2DArray(n, 2), price = p;\\n    packUG(g, edges);\\n    for (const [u, v] of trips) tree_dp(u, -1, v);\\n    house_robber_III(0, -1);\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += cnt[i] * price[i];\\n    return res - Math.max(...dp[0]);\\n};\\n\\nconst tree_dp = (cur, par, dest) => {\\n    if (cur == dest) {\\n        cnt[cur]++;\\n        return true;\\n    }\\n    for (const child of g[cur]) {\\n        if (child != par && tree_dp(child, cur, dest)) {\\n            cnt[cur]++;\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nconst house_robber_III = (cur, par) => {\\n    dp[cur] = [0, cnt[cur] * price[cur] / 2];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            house_robber_III(child, cur)\\n            dp[cur][0] += Math.max(...dp[child]);\\n            dp[cur][1] += dp[child][0];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Graph"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packUG = (g, edges) => { for (const [u, v] of edges) { g[u].push(v); g[v].push(u); } };\\nconst initialize2DArray = (n, m) => [...Array(n)].map(() => Array(m).fill(0));\\n\\nlet g, cnt, dp, price;\\nconst minimumTotalPrice = (n, edges, p, trips) => {\\n    g = initializeGraph(n), cnt = Array(n).fill(0), dp = initialize2DArray(n, 2), price = p;\\n    packUG(g, edges);\\n    for (const [u, v] of trips) tree_dp(u, -1, v);\\n    house_robber_III(0, -1);\\n    let res = 0;\\n    for (let i = 0; i < n; i++) res += cnt[i] * price[i];\\n    return res - Math.max(...dp[0]);\\n};\\n\\nconst tree_dp = (cur, par, dest) => {\\n    if (cur == dest) {\\n        cnt[cur]++;\\n        return true;\\n    }\\n    for (const child of g[cur]) {\\n        if (child != par && tree_dp(child, cur, dest)) {\\n            cnt[cur]++;\\n            return true;\\n        }\\n    }\\n    return false;\\n};\\n\\nconst house_robber_III = (cur, par) => {\\n    dp[cur] = [0, cnt[cur] * price[cur] / 2];\\n    for (const child of g[cur]) {\\n        if (child != par) {\\n            house_robber_III(child, cur)\\n            dp[cur][0] += Math.max(...dp[child]);\\n            dp[cur][1] += dp[child][0];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422301,
                "title": "dp-solution-also-harder-followup-with-lca",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can store the sum of the cost of each node in all the trips combined in the cost array.\\nFor this, we first run a dfs to get the path for each trip. \\n\\nnow we know the cost of each node in all the paths (or trips), we are going to make. \\n\\nNow, we can write a dp solution on this cost array.\\nWe root the tree at node 0 and then calculate.\\n\\ndp[u][0] = the cost in the subtree of node u if we do not halve the cost of this node.\\n\\ndp[u][1]= the cost in the subtree of node u if we do halve the cost of this node.\\n\\nIf we don\\'t halve this node, then we can either halve the children or not, we will take the minimum of that.\\n\\nIf we do halve this node\\'s cost, then we cannot halve the children\\'s cost.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n x trips.size()+2*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# followUp\\n\\nNow, if N <=10^5 and trips <=10^5, this solution won\\'t work. \\n\\nin that case, we will first build two trees after rooting at node 0.\\n\\nin one tree, we will halve the odd levels and in other one, we will halve the even levels. we will calculate the answer for both the trees and return the minimum.\\n\\nto calculate for a tree, we will first store the root to node sum for every node and store it in some array. let\\'s say this array is __root_sum__\\n\\nNow, we will calculate the LCA with binary lifting.\\n\\nfor every trip(u, v), \\n\\npath_sum(u, v) = root_sum[u]+root_sum[v] - 2* root_sum[LCA] + price[LCA];\\n\\nwe will calculate this for both the trees and then just take their minimum.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int u, int par, int dest, vector<int>adj[], vector<int>&p){\\n        p.push_back(u);\\n        if(u==dest){\\n            path=p;\\n            p.pop_back();\\n            return;\\n        }\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs(j, u, dest, adj, p);\\n        }\\n        p.pop_back();\\n    }\\n    int dp[50][2];\\n    void dfs2(int u, int par, vector<int>adj[], vector<int>&cost){\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs2(j, u, adj, cost);\\n        }\\n        dp[u][1]=cost[u]/2;\\n        dp[u][0]=cost[u];\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dp[u][0]+=min(dp[j][0], dp[j][1]);\\n            dp[u][1]+=dp[j][0];\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>cost(n, 0);\\n        for(auto &it: trips){\\n            vector<int>p;\\n            path.clear();\\n            dfs(it[0], -1, it[1], adj, p);\\n            for(int i: path){\\n                //cout<<i<<\" \"<<endl;\\n                cost[i]+=price[i];\\n            }\\n        }\\n        //cout<<\"chu\"<<endl;\\n        dfs2(0, -1, adj, cost);\\n        return min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>path;\\n    void dfs(int u, int par, int dest, vector<int>adj[], vector<int>&p){\\n        p.push_back(u);\\n        if(u==dest){\\n            path=p;\\n            p.pop_back();\\n            return;\\n        }\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs(j, u, dest, adj, p);\\n        }\\n        p.pop_back();\\n    }\\n    int dp[50][2];\\n    void dfs2(int u, int par, vector<int>adj[], vector<int>&cost){\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dfs2(j, u, adj, cost);\\n        }\\n        dp[u][1]=cost[u]/2;\\n        dp[u][0]=cost[u];\\n        for(int j: adj[u]){\\n            if(j==par)continue;\\n            dp[u][0]+=min(dp[j][0], dp[j][1]);\\n            dp[u][1]+=dp[j][0];\\n        }\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<int>adj[n];\\n        for(auto &it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>cost(n, 0);\\n        for(auto &it: trips){\\n            vector<int>p;\\n            path.clear();\\n            dfs(it[0], -1, it[1], adj, p);\\n            for(int i: path){\\n                //cout<<i<<\" \"<<endl;\\n                cost[i]+=price[i];\\n            }\\n        }\\n        //cout<<\"chu\"<<endl;\\n        dfs2(0, -1, adj, cost);\\n        return min(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3422294,
                "title": "java-recursion-dp-intuitive-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a pair of nodes in a tree, there is one and only one route between them. This is an interesting attribute of tree.\\nAnd this means given the `trips` as input, we can infer all the routes, thus we know how many times to pay for each node.\\nThen with DP, calculate where to apply the half price discount: if a node already uses the discount, its children cannot use it, otherwise its children are free to use the it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert the list of edges into a neighbor map.\\n2. Pick any node as `root`, so it is easier to use recursion.\\n3. Find the path from `root` to each node, so it is easy to\\n4. Find the route between any pair of nodes, to\\n5. Count how many times to pay for each node\\n6. Use DP to calculate the min total price.\\n  - \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log(n) * trips.length): assuming the tree is balanced.\\nIn worst case, it becomes O(n * trips.length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)) : the path from `root` to each node takes log(n), assuming the tree is balanced.\\nIn worst case, it becomes O(n^2)\\n\\n# Code\\n```\\n// Auxiliary class for values shared across methods.\\nclass Solver {\\n  private final int n;\\n  private final int[][] edges;\\n  private final int[] price;\\n  private final int[][] trips;\\n\\n  // neighbors[i] is a list of all neighbors of node i\\n  private final List<List<Integer>> neighbors = new ArrayList<>();\\n\\n  // Arbitrarily selected root of the tree. (Actual value is set later.)\\n  private int root = 0;\\n\\n  // paths[i] is a list of nodes: [root, ancestor1, ancestor2, ..., node] .\\n  private final List<List<Integer>> paths = new ArrayList<>();\\n\\n  // Need to pay node i passingCount[i] times.\\n  private int[] passingCount;\\n\\n  public Solver(int n, int[][] edges, int[] price, int[][] trips) {\\n    this.n = n;\\n    this.edges = edges;\\n    this.price = price;\\n    this.trips = trips;\\n\\n    // Initializes Lists and arrays to size n.\\n    for (int i = 0; i < n; i++) {\\n      neighbors.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      paths.add(new ArrayList<>());\\n    }\\n    this.passingCount = new int[n];\\n  }\\n\\n  public int run() {\\n    // Translates edges to a map of neighbors for easier look up.\\n    for (int[] edge : edges) {\\n      neighbors.get(edge[0]).add(edge[1]);\\n      neighbors.get(edge[1]).add(edge[0]);\\n    }\\n\\n    // Picks an arbitrary node as root, for easier implementation of recursion.\\n    for (int i = 0; i < n; i++) {\\n      if (neighbors.get(i).size() > neighbors.get(root).size()) {\\n        root = i;\\n      }\\n    }\\n\\n    // Finds the path from root to every node.\\n    fillPath(root, new ArrayList<>());\\n\\n    // Translates each trip to all passing nodes.\\n    for (int[] trip : trips) {\\n      List<Integer> path0 = paths.get(trip[0]);\\n      List<Integer> path1 = paths.get(trip[1]);\\n      int share = 0;    // Every path share the root node.\\n      for (int i = 1; i < path0.size() && i < path1.size(); i++) {\\n        if (path0.get(i) == path1.get(i)) {\\n          share = i;\\n        } else {\\n          break;\\n        }\\n      }\\n\\n      for (int i = share; i < path0.size(); i++) {\\n        passingCount[path0.get(i)]++;\\n      }\\n\\n      // Count the shared node only once.\\n      for (int i = share + 1; i < path1.size(); i++) {\\n        passingCount[path1.get(i)]++;\\n      }\\n    }\\n\\n    // DP to find the min total price.\\n    return minPrice(root, -1, true, new HashMap<>());\\n  }\\n\\n  private int minPrice(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n\\n    // Looks up cache first.\\n    int key = root * 2 + (halfable ? 1 : 0);\\n    Integer value = cache.get(key);\\n    if (value != null) {\\n      return value;\\n    }\\n\\n    // Calculates the value if cache misses.\\n    int result = minPriceImpl(root, parent, halfable, cache);\\n    cache.put(key, result);\\n    return result;\\n  }\\n\\n  // Gets the min price of sub-tree from root.\\n  private int minPriceImpl(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n    // Keeping root full price is always an option.\\n    int candidate1 = price[root] * passingCount[root];\\n    for (int neighbor : neighbors.get(root)) {\\n      if (neighbor != parent) {\\n        candidate1 += minPrice(neighbor, root, true, cache);\\n      }\\n    }\\n\\n    if (halfable) {\\n      // Makes root half price.\\n      int candidate0 = price[root] / 2 * passingCount[root];\\n      for (int neighbor : neighbors.get(root)) {\\n        if (neighbor != parent) {\\n          candidate0 += minPrice(neighbor, root, false, cache);\\n        }\\n      }\\n      return Math.min(candidate0, candidate1);\\n    } else {\\n      return candidate1;\\n    }\\n\\n  }\\n\\n  // DFS to find the path from root to each node.\\n  private void fillPath(int node, List<Integer> prefix) {\\n    // Reached node, makes a record of the path.\\n    prefix.add(node);\\n    paths.set(node, new ArrayList<Integer>(prefix));\\n\\n    for (int neighbor : neighbors.get(node)) {\\n      if (prefix.size() <= 1 || neighbor != prefix.get(prefix.size() - 2)) {\\n        fillPath(neighbor, prefix);\\n      }\\n    }\\n\\n    // prefix is shared, so restore its original state before entering this method.\\n    prefix.remove(prefix.size() - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n    return new Solver(n, edges, price, trips).run();\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Auxiliary class for values shared across methods.\\nclass Solver {\\n  private final int n;\\n  private final int[][] edges;\\n  private final int[] price;\\n  private final int[][] trips;\\n\\n  // neighbors[i] is a list of all neighbors of node i\\n  private final List<List<Integer>> neighbors = new ArrayList<>();\\n\\n  // Arbitrarily selected root of the tree. (Actual value is set later.)\\n  private int root = 0;\\n\\n  // paths[i] is a list of nodes: [root, ancestor1, ancestor2, ..., node] .\\n  private final List<List<Integer>> paths = new ArrayList<>();\\n\\n  // Need to pay node i passingCount[i] times.\\n  private int[] passingCount;\\n\\n  public Solver(int n, int[][] edges, int[] price, int[][] trips) {\\n    this.n = n;\\n    this.edges = edges;\\n    this.price = price;\\n    this.trips = trips;\\n\\n    // Initializes Lists and arrays to size n.\\n    for (int i = 0; i < n; i++) {\\n      neighbors.add(new ArrayList<>());\\n    }\\n    for (int i = 0; i < n; i++) {\\n      paths.add(new ArrayList<>());\\n    }\\n    this.passingCount = new int[n];\\n  }\\n\\n  public int run() {\\n    // Translates edges to a map of neighbors for easier look up.\\n    for (int[] edge : edges) {\\n      neighbors.get(edge[0]).add(edge[1]);\\n      neighbors.get(edge[1]).add(edge[0]);\\n    }\\n\\n    // Picks an arbitrary node as root, for easier implementation of recursion.\\n    for (int i = 0; i < n; i++) {\\n      if (neighbors.get(i).size() > neighbors.get(root).size()) {\\n        root = i;\\n      }\\n    }\\n\\n    // Finds the path from root to every node.\\n    fillPath(root, new ArrayList<>());\\n\\n    // Translates each trip to all passing nodes.\\n    for (int[] trip : trips) {\\n      List<Integer> path0 = paths.get(trip[0]);\\n      List<Integer> path1 = paths.get(trip[1]);\\n      int share = 0;    // Every path share the root node.\\n      for (int i = 1; i < path0.size() && i < path1.size(); i++) {\\n        if (path0.get(i) == path1.get(i)) {\\n          share = i;\\n        } else {\\n          break;\\n        }\\n      }\\n\\n      for (int i = share; i < path0.size(); i++) {\\n        passingCount[path0.get(i)]++;\\n      }\\n\\n      // Count the shared node only once.\\n      for (int i = share + 1; i < path1.size(); i++) {\\n        passingCount[path1.get(i)]++;\\n      }\\n    }\\n\\n    // DP to find the min total price.\\n    return minPrice(root, -1, true, new HashMap<>());\\n  }\\n\\n  private int minPrice(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n\\n    // Looks up cache first.\\n    int key = root * 2 + (halfable ? 1 : 0);\\n    Integer value = cache.get(key);\\n    if (value != null) {\\n      return value;\\n    }\\n\\n    // Calculates the value if cache misses.\\n    int result = minPriceImpl(root, parent, halfable, cache);\\n    cache.put(key, result);\\n    return result;\\n  }\\n\\n  // Gets the min price of sub-tree from root.\\n  private int minPriceImpl(int root, int parent, boolean halfable, Map<Integer, Integer> cache) {\\n    // Keeping root full price is always an option.\\n    int candidate1 = price[root] * passingCount[root];\\n    for (int neighbor : neighbors.get(root)) {\\n      if (neighbor != parent) {\\n        candidate1 += minPrice(neighbor, root, true, cache);\\n      }\\n    }\\n\\n    if (halfable) {\\n      // Makes root half price.\\n      int candidate0 = price[root] / 2 * passingCount[root];\\n      for (int neighbor : neighbors.get(root)) {\\n        if (neighbor != parent) {\\n          candidate0 += minPrice(neighbor, root, false, cache);\\n        }\\n      }\\n      return Math.min(candidate0, candidate1);\\n    } else {\\n      return candidate1;\\n    }\\n\\n  }\\n\\n  // DFS to find the path from root to each node.\\n  private void fillPath(int node, List<Integer> prefix) {\\n    // Reached node, makes a record of the path.\\n    prefix.add(node);\\n    paths.set(node, new ArrayList<Integer>(prefix));\\n\\n    for (int neighbor : neighbors.get(node)) {\\n      if (prefix.size() <= 1 || neighbor != prefix.get(prefix.size() - 2)) {\\n        fillPath(neighbor, prefix);\\n      }\\n    }\\n\\n    // prefix is shared, so restore its original state before entering this method.\\n    prefix.remove(prefix.size() - 1);\\n  }\\n}\\n\\nclass Solution {\\n  public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n    return new Solver(n, edges, price, trips).run();\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422261,
                "title": "my-solution",
                "content": "```\\n/**\\n * Time Complexity: O(n * n_trips + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n_trips` is the length of the vector `trips`\\n */\\nclass Solution {\\n public:\\n  int minimumTotalPrice(const int n,\\n                        const vector<vector<int>> &edges,\\n                        const vector<int> &price,\\n                        vector<vector<int>>& trips) {\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge.front()].emplace_back(edge.back());\\n      graph[edge.back()].emplace_back(edge.front());\\n    }\\n    \\n    int visit_times[n];\\n    memset(visit_times, 0, sizeof(visit_times));\\n    for (const vector<int> &trip : trips) {\\n      find_path(graph, trip.front(), invalid_parent, trip.back(), visit_times);\\n    }\\n    \\n    auto [discount, non_discount] = dfs(graph, 0, invalid_parent, price, visit_times);\\n    return min(discount, non_discount);\\n  }\\n  \\n private:\\n  bool find_path(const vector<int> *graph, const int node, const int parent, const int target, int *visit_times) {\\n    if (node == target) {\\n      ++visit_times[node];\\n      return true;\\n    }\\n    \\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      if (find_path(graph, child, node, target, visit_times)) {\\n        ++visit_times[node];\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /**\\n   * @return: a pair\\n   *          `first` is the minimum price of the subtree rooted by `node` if the price of the node is discounted\\n   *          `second` is the minimum price of the subtree rooted by `node` if the price of the node is not discounted\\n   */\\n  pair<int, int> dfs(const vector<int> *graph,\\n                     const int node,\\n                     const int parent,\\n                     const vector<int> &price,\\n                     const int *visit_times) {\\n    int discount = price[node] * visit_times[node] / 2;\\n    int non_discount = price[node] * visit_times[node];\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      \\n      const auto [child_discount, child_non_discount] = dfs(graph, child, node, price, visit_times);\\n      discount += child_non_discount;\\n      non_discount += min(child_discount, child_non_discount);\\n    }\\n    return make_pair(discount, non_discount);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * n_trips + n_edges)\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n *       `n_trips` is the length of the vector `trips`\\n */\\nclass Solution {\\n public:\\n  int minimumTotalPrice(const int n,\\n                        const vector<vector<int>> &edges,\\n                        const vector<int> &price,\\n                        vector<vector<int>>& trips) {\\n    constexpr int invalid_parent = -1;\\n    vector<int> graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge.front()].emplace_back(edge.back());\\n      graph[edge.back()].emplace_back(edge.front());\\n    }\\n    \\n    int visit_times[n];\\n    memset(visit_times, 0, sizeof(visit_times));\\n    for (const vector<int> &trip : trips) {\\n      find_path(graph, trip.front(), invalid_parent, trip.back(), visit_times);\\n    }\\n    \\n    auto [discount, non_discount] = dfs(graph, 0, invalid_parent, price, visit_times);\\n    return min(discount, non_discount);\\n  }\\n  \\n private:\\n  bool find_path(const vector<int> *graph, const int node, const int parent, const int target, int *visit_times) {\\n    if (node == target) {\\n      ++visit_times[node];\\n      return true;\\n    }\\n    \\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      if (find_path(graph, child, node, target, visit_times)) {\\n        ++visit_times[node];\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  /**\\n   * @return: a pair\\n   *          `first` is the minimum price of the subtree rooted by `node` if the price of the node is discounted\\n   *          `second` is the minimum price of the subtree rooted by `node` if the price of the node is not discounted\\n   */\\n  pair<int, int> dfs(const vector<int> *graph,\\n                     const int node,\\n                     const int parent,\\n                     const vector<int> &price,\\n                     const int *visit_times) {\\n    int discount = price[node] * visit_times[node] / 2;\\n    int non_discount = price[node] * visit_times[node];\\n    for (const int child : graph[node]) {\\n      if (child == parent) {\\n        continue;\\n      }\\n      \\n      const auto [child_discount, child_non_discount] = dfs(graph, child, node, price, visit_times);\\n      discount += child_non_discount;\\n      non_discount += min(child_discount, child_non_discount);\\n    }\\n    return make_pair(discount, non_discount);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422224,
                "title": "java-dp-memoization",
                "content": "\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(2n)$$\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    boolean[] vis;\\n    int[] count;\\n    List<List<Integer>> adj;\\n    int[][] dp;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        dp = new int[2][n + 1];\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        count = new int[n];\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        vis = new boolean[n];\\n\\n        for (int[] trip : trips) {\\n            vis = new boolean[n];\\n            dfs(trip[0], trip[1], price);\\n        }\\n        return go(0, price, 0, -1);\\n    }\\n\\n    private int go(int i, int[] price, int prev, int par) {\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        int ans = 0, ans2 = 0;\\n        \\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                ans += go(it, price, 0, i);\\n\\n            }\\n        }\\n        ans += (price[i] * count[i]);\\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                if (prev == 0)\\n                    ans2 += go(it, price, 1, i);\\n            }\\n        }\\n        if (prev == 0) {\\n            ans2 += ((price[i] / 2) * count[i]);\\n            ans = Math.min(ans, ans2);\\n        }\\n        return dp[prev][i] = ans;\\n\\n    }\\n\\n\\n    private boolean dfs(int i, int d, int[] price) {\\n        vis[i] = true;\\n        boolean ans = false;\\n        if (i == d) {\\n            count[i]++;\\n            return true;\\n        }\\n        for (Integer it : adj.get(i)) {\\n            if (!vis[it]) {\\n                ans |= dfs(it, d, price);\\n            }\\n        }\\n        if (ans) {\\n            count[i]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\nimport java.util.Arrays;\\nimport java.util.List;\\n\\nclass Solution {\\n    boolean[] vis;\\n    int[] count;\\n    List<List<Integer>> adj;\\n    int[][] dp;\\n\\n    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {\\n        adj = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            adj.add(new ArrayList<>());\\n        }\\n        dp = new int[2][n + 1];\\n        for (int[] ints : dp) {\\n            Arrays.fill(ints, -1);\\n        }\\n        count = new int[n];\\n        for (int[] edge : edges) {\\n            adj.get(edge[0]).add(edge[1]);\\n            adj.get(edge[1]).add(edge[0]);\\n        }\\n        vis = new boolean[n];\\n\\n        for (int[] trip : trips) {\\n            vis = new boolean[n];\\n            dfs(trip[0], trip[1], price);\\n        }\\n        return go(0, price, 0, -1);\\n    }\\n\\n    private int go(int i, int[] price, int prev, int par) {\\n        if(dp[prev][i]!=-1) return dp[prev][i];\\n        int ans = 0, ans2 = 0;\\n        \\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                ans += go(it, price, 0, i);\\n\\n            }\\n        }\\n        ans += (price[i] * count[i]);\\n        for (Integer it : adj.get(i)) {\\n            if (it != par) {\\n                if (prev == 0)\\n                    ans2 += go(it, price, 1, i);\\n            }\\n        }\\n        if (prev == 0) {\\n            ans2 += ((price[i] / 2) * count[i]);\\n            ans = Math.min(ans, ans2);\\n        }\\n        return dp[prev][i] = ans;\\n\\n    }\\n\\n\\n    private boolean dfs(int i, int d, int[] price) {\\n        vis[i] = true;\\n        boolean ans = false;\\n        if (i == d) {\\n            count[i]++;\\n            return true;\\n        }\\n        for (Integer it : adj.get(i)) {\\n            if (!vis[it]) {\\n                ans |= dfs(it, d, price);\\n            }\\n        }\\n        if (ans) {\\n            count[i]++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422218,
                "title": "c-dfs-dp-simple-solution-video-solution",
                "content": "You can also checkout my YouTube channel for solution\\nVisithttps://youtu.be/2gdcNjxR7q0\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[51][2];\\n    \\n    ll minCost(ll i, ll x,vector<vector<int>> &adj,int par, vector<ll> &cost){\\n        ll a=0,b = 0;\\n        if(dp[i][x] !=-1) return dp[i][x];\\n        \\n        \\n        for(auto c:adj[i]){\\n            if(c!=par){\\n                a+=minCost(c,0,adj,i,cost);\\n            }\\n        }\\n\\n        ll ans = a + cost[i] ;\\n        if(x == 0 ){\\n          for(auto c:adj[i]){\\n            if(c!=par){\\n                b+=minCost(c,1,adj,i,cost);\\n            }\\n           }\\n            ans=min(ans,b + cost[i]/2);\\n        }\\n        return  dp[i][x]=ans;   \\n    }\\nbool dfs(int u, int v, const vector<vector<int>>& tree, vector<int>& path, vector<bool>& visited) {\\n    visited[u] = true; \\n\\n    if (u == v) {\\n        path.push_back(u); \\n        return true;\\n    }\\n\\n    for (int child : tree[u]) {\\n        if (!visited[child]) {\\n            path.push_back(u);  \\n            if (dfs(child, v, tree, path, visited)) {\\n                return true;  \\n            }\\n            path.pop_back(); \\n        }\\n    }\\n\\n    return false;  \\n}\\n    \\n    int fun(int n, int root, vector<vector<int>> &adj, vector<int>& price, vector<vector<int>>& trips){\\n       vector<ll> cost(n,0);\\n            for(auto t:trips){\\n            vector<int> path;  \\n            vector<bool> visited(n, false); \\n            dfs(t[0],t[1], adj, path, visited);\\n            for(auto c:path){\\n                cost[c]+=price[c];\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = minCost(0,0,adj,-1,cost);\\n        \\n        return ans;\\n        \\n    }    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);  \\n        for (const auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans=INT_MAX;\\n        ans = fun(n,0,graph,price,trips);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll dp[51][2];\\n    \\n    ll minCost(ll i, ll x,vector<vector<int>> &adj,int par, vector<ll> &cost){\\n        ll a=0,b = 0;\\n        if(dp[i][x] !=-1) return dp[i][x];\\n        \\n        \\n        for(auto c:adj[i]){\\n            if(c!=par){\\n                a+=minCost(c,0,adj,i,cost);\\n            }\\n        }\\n\\n        ll ans = a + cost[i] ;\\n        if(x == 0 ){\\n          for(auto c:adj[i]){\\n            if(c!=par){\\n                b+=minCost(c,1,adj,i,cost);\\n            }\\n           }\\n            ans=min(ans,b + cost[i]/2);\\n        }\\n        return  dp[i][x]=ans;   \\n    }\\nbool dfs(int u, int v, const vector<vector<int>>& tree, vector<int>& path, vector<bool>& visited) {\\n    visited[u] = true; \\n\\n    if (u == v) {\\n        path.push_back(u); \\n        return true;\\n    }\\n\\n    for (int child : tree[u]) {\\n        if (!visited[child]) {\\n            path.push_back(u);  \\n            if (dfs(child, v, tree, path, visited)) {\\n                return true;  \\n            }\\n            path.pop_back(); \\n        }\\n    }\\n\\n    return false;  \\n}\\n    \\n    int fun(int n, int root, vector<vector<int>> &adj, vector<int>& price, vector<vector<int>>& trips){\\n       vector<ll> cost(n,0);\\n            for(auto t:trips){\\n            vector<int> path;  \\n            vector<bool> visited(n, false); \\n            dfs(t[0],t[1], adj, path, visited);\\n            for(auto c:path){\\n                cost[c]+=price[c];\\n            }\\n        }\\n        memset(dp,-1,sizeof(dp));\\n        int ans = minCost(0,0,adj,-1,cost);\\n        \\n        return ans;\\n        \\n    }    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);  \\n        for (const auto& edge : edges) {\\n            graph[edge[0]].push_back(edge[1]); \\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        int ans=INT_MAX;\\n        ans = fun(n,0,graph,price,trips);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422190,
                "title": "c-dfs-top-down-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea behind is very similar to **rubber house**. The problem could be converted to a dp problem with state dp[node][0/1] that 0/1 means whether to  half the cost of a node.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Iterate through trips to calcalte frequency of each node by DFS\\n2. Cost of each node eqauls to freq[node] * price[node]\\n3. Select any node as root and use Top-Down DP to find minumum cost.\\n# Complexity\\n- Time complexity: O(nm) (Trips iteration)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n^2)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[55][2];\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n-1; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        vector<int> counter(n);\\n        vector<int> path;\\n        int m = trips.size();\\n        for (int i = 0; i < m; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            path.clear();\\n            path.push_back(start);\\n            DFS1(start, end, -1, graph, path);\\n            for (int node: path) counter[node]++;\\n        }\\n\\n        vector<int> costs(n);\\n        for (int i = 0; i < n; i++) {\\n            costs[i] = counter[i] * price[i];\\n        }\\n        for (int i = 0; i < 55; i++) {\\n            dp[i][0] = -1;\\n            dp[i][1] = -1;\\n        }\\n        return min(DFS2(0, -1, 1, graph, costs), DFS2(0, -1, 0, graph, costs));\\n    }\\n\\n    bool DFS1(int node, int end, int parent, vector<vector<int>>& graph, vector<int>& path) {\\n        if (node == end) return true;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            path.push_back(nxt);\\n            if (DFS1(nxt, end, node, graph, path)) return true;\\n            path.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    int DFS2(int node, int parent, int half, vector<vector<int>>& graph, vector<int>& costs) {\\n        if (dp[node][half] != -1) return dp[node][half];\\n        \\n        int cost = costs[node];\\n        if (half) cost /= 2;\\n\\n        int SubCost = 0;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            int curr = DFS2(nxt, node, 0, graph, costs);\\n            if (!half) curr = min(curr, DFS2(nxt, node, 1, graph, costs));\\n            SubCost += curr;\\n        }\\n        \\n        dp[node][half] = cost + SubCost;\\n        return dp[node][half];\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[55][2];\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> graph(n);\\n        for (int i = 0; i < n-1; i++) {\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n\\n        vector<int> counter(n);\\n        vector<int> path;\\n        int m = trips.size();\\n        for (int i = 0; i < m; i++) {\\n            int start = trips[i][0];\\n            int end = trips[i][1];\\n            path.clear();\\n            path.push_back(start);\\n            DFS1(start, end, -1, graph, path);\\n            for (int node: path) counter[node]++;\\n        }\\n\\n        vector<int> costs(n);\\n        for (int i = 0; i < n; i++) {\\n            costs[i] = counter[i] * price[i];\\n        }\\n        for (int i = 0; i < 55; i++) {\\n            dp[i][0] = -1;\\n            dp[i][1] = -1;\\n        }\\n        return min(DFS2(0, -1, 1, graph, costs), DFS2(0, -1, 0, graph, costs));\\n    }\\n\\n    bool DFS1(int node, int end, int parent, vector<vector<int>>& graph, vector<int>& path) {\\n        if (node == end) return true;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            path.push_back(nxt);\\n            if (DFS1(nxt, end, node, graph, path)) return true;\\n            path.pop_back();\\n        }\\n        return false;\\n    }\\n\\n    int DFS2(int node, int parent, int half, vector<vector<int>>& graph, vector<int>& costs) {\\n        if (dp[node][half] != -1) return dp[node][half];\\n        \\n        int cost = costs[node];\\n        if (half) cost /= 2;\\n\\n        int SubCost = 0;\\n        for (auto nxt: graph[node]) {\\n            if (nxt == parent) continue;\\n            int curr = DFS2(nxt, node, 0, graph, costs);\\n            if (!half) curr = min(curr, DFS2(nxt, node, 1, graph, costs));\\n            SubCost += curr;\\n        }\\n        \\n        dp[node][half] = cost + SubCost;\\n        return dp[node][half];\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422167,
                "title": "javascript-dfs-with-memorisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function (n, edges, price, trips) {\\n    const m = new Map()\\n    const addToMap = (a, b) => {\\n        if (m.has(a)) {\\n            m.get(a).push(b)\\n        } else {\\n            m.set(a, [b])\\n        }\\n    }\\n\\n    for (const [a, b] of edges) {\\n        addToMap(a, b)\\n        addToMap(b, a)\\n    }\\n\\n    const nodeVisits = Array(n).fill(0)\\n    const dfs = (node, prev, finish, seen) => {\\n        if (node == finish) {\\n            for (const s of seen) {\\n                nodeVisits[s] += 1\\n            }\\n        }\\n\\n        const neighbours = m.get(node)\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    seen.push(ngh)\\n                    dfs(ngh, node, finish, seen)\\n                    seen.pop()\\n                }\\n            }\\n        }\\n    }\\n\\n    for (const [start, end] of trips) {\\n        dfs(start, -1, end, [start])\\n    }\\n\\n    const cache = new Map()\\n    const dfs2 = (node, prev, isHalfed) => {\\n        const str = `${node}-${isHalfed}`\\n        if (cache.has(str)) {\\n            return cache.get(str)\\n        }\\n        const cur = isHalfed ? (price[node] * nodeVisits[node] / 2) : price[node] * nodeVisits[node]\\n\\n        const neighbours = m.get(node)\\n        let rest = 0\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    if (isHalfed) {\\n                        rest += dfs2(ngh, node, false)\\n                    } else {\\n                        rest += Math.min(dfs2(ngh, node, true), dfs2(ngh, node, false))\\n                    }\\n                }\\n            }\\n        }\\n        cache.set(str, cur + rest)\\n        return cur + rest\\n    }\\n\\n\\n    const minTotal = Math.min(dfs2(0, -1, true), dfs2(0, -1, false))\\n\\n    return minTotal\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number[]} price\\n * @param {number[][]} trips\\n * @return {number}\\n */\\nvar minimumTotalPrice = function (n, edges, price, trips) {\\n    const m = new Map()\\n    const addToMap = (a, b) => {\\n        if (m.has(a)) {\\n            m.get(a).push(b)\\n        } else {\\n            m.set(a, [b])\\n        }\\n    }\\n\\n    for (const [a, b] of edges) {\\n        addToMap(a, b)\\n        addToMap(b, a)\\n    }\\n\\n    const nodeVisits = Array(n).fill(0)\\n    const dfs = (node, prev, finish, seen) => {\\n        if (node == finish) {\\n            for (const s of seen) {\\n                nodeVisits[s] += 1\\n            }\\n        }\\n\\n        const neighbours = m.get(node)\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    seen.push(ngh)\\n                    dfs(ngh, node, finish, seen)\\n                    seen.pop()\\n                }\\n            }\\n        }\\n    }\\n\\n    for (const [start, end] of trips) {\\n        dfs(start, -1, end, [start])\\n    }\\n\\n    const cache = new Map()\\n    const dfs2 = (node, prev, isHalfed) => {\\n        const str = `${node}-${isHalfed}`\\n        if (cache.has(str)) {\\n            return cache.get(str)\\n        }\\n        const cur = isHalfed ? (price[node] * nodeVisits[node] / 2) : price[node] * nodeVisits[node]\\n\\n        const neighbours = m.get(node)\\n        let rest = 0\\n        if (neighbours && neighbours.length > 0) {\\n            for (const ngh of neighbours) {\\n                if (ngh !== prev) {\\n                    if (isHalfed) {\\n                        rest += dfs2(ngh, node, false)\\n                    } else {\\n                        rest += Math.min(dfs2(ngh, node, true), dfs2(ngh, node, false))\\n                    }\\n                }\\n            }\\n        }\\n        cache.set(str, cur + rest)\\n        return cur + rest\\n    }\\n\\n\\n    const minTotal = Math.min(dfs2(0, -1, true), dfs2(0, -1, false))\\n\\n    return minTotal\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422142,
                "title": "c-dfs-dp-house-robber-variation-easy-to-understand-99-99-faster",
                "content": "# Intuition\\nFirst find the occurance of every value in the trips then try to find out the maximum sum of non-adjacent values (they may be any number).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> s;\\n    bool solve(vector<vector<int>> &g,vector<int> &price,int i,int tar,int par) {\\n        if(i==tar) {\\n            s[i]+=price[i];\\n            return true;\\n        }\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                bool ans = solve(g,price,j,tar,i);\\n                if(ans) {\\n                    s[i]+=price[i];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> dp;\\n    int solve1(vector<vector<int>> &g,int i,int pick,int par) {\\n        int ans=0,store=0;\\n        if(dp[i][pick]!=-1) return dp[i][pick];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                ans += max(solve1(g,j,0,i),solve1(g,j,1,i));\\n            }\\n        }\\n        if(pick==0) return dp[i][pick] = ans;\\n        int res=s[i];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                res += solve1(g,j,0,i);\\n            }\\n        }\\n        return dp[i][pick] = max(res,max(ans,store));\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        for(auto i:edges) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        s.resize(n,0);\\n        dp.resize(n,vector<int> (2,-1));\\n        for(int i=0 ; i<trips.size() ; ++i) {\\n            solve(g,price,trips[i][0],trips[i][1],-1);\\n        }\\n        int val = max(solve1(g,0,0,-1),solve1(g,0,1,-1));\\n        int sum=0;\\n        for(auto i:s) sum+=i;\\n        return sum-(val/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> s;\\n    bool solve(vector<vector<int>> &g,vector<int> &price,int i,int tar,int par) {\\n        if(i==tar) {\\n            s[i]+=price[i];\\n            return true;\\n        }\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                bool ans = solve(g,price,j,tar,i);\\n                if(ans) {\\n                    s[i]+=price[i];\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    vector<vector<int>> dp;\\n    int solve1(vector<vector<int>> &g,int i,int pick,int par) {\\n        int ans=0,store=0;\\n        if(dp[i][pick]!=-1) return dp[i][pick];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                ans += max(solve1(g,j,0,i),solve1(g,j,1,i));\\n            }\\n        }\\n        if(pick==0) return dp[i][pick] = ans;\\n        int res=s[i];\\n        for(auto j:g[i]) {\\n            if(j!=par) {\\n                res += solve1(g,j,0,i);\\n            }\\n        }\\n        return dp[i][pick] = max(res,max(ans,store));\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> g(n);\\n        for(auto i:edges) {\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        s.resize(n,0);\\n        dp.resize(n,vector<int> (2,-1));\\n        for(int i=0 ; i<trips.size() ; ++i) {\\n            solve(g,price,trips[i][0],trips[i][1],-1);\\n        }\\n        int val = max(solve1(g,0,0,-1),solve1(g,0,1,-1));\\n        int sum=0;\\n        for(auto i:s) sum+=i;\\n        return sum-(val/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422115,
                "title": "c-simple-dfs-beats-90-91-tc-sc-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\npair<int,int> dfs1(int root,int par,vector<vector<int>>& adj,vector<int>& node_cont){\\n    pair<int,int> ans={0,node_cont[root]};\\n    for(int& i: adj[root]){\\n        if(i!=par){\\n            auto [a,b]=dfs1(i,root,adj,node_cont);\\n            ans.first+=max(a,b);\\n            ans.second+=a;\\n        }\\n    }\\n    return ans;\\n}\\n    int dfs(int st,int end,int par,vector<int>& price,vector<vector<int>>& adj,vector<int>& node_cont){\\n        int ans=0;\\n        ans+=price[st];\\n        node_cont[st]+=price[st];\\n        if(st==end) return ans;\\n        for(int& i: adj[st]){\\n            if(i!=par){\\n                int res=dfs(i,end,st,price,adj,node_cont);\\n                if(res)  return ans+res;\\n            }\\n        }\\n        node_cont[st]-=price[st];\\n        return 0;\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int ans=0;\\n        vector<vector<int>> adj(n);\\n        int root=-1;\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()<=1){\\n                root=i;\\n                break;\\n            }\\n        }\\n        vector<int> node_cont(n,0);\\n        for(int i=0;i<trips.size();i++){\\n            int st=trips[i][0];\\n            int end=trips[i][1];\\n            ans+=dfs(st,end,-1,price,adj,node_cont);\\n        }\\n        auto [a,b]=dfs1(root,-1,adj,node_cont);\\n        ans-=max(a,b)/2;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\npair<int,int> dfs1(int root,int par,vector<vector<int>>& adj,vector<int>& node_cont){\\n    pair<int,int> ans={0,node_cont[root]};\\n    for(int& i: adj[root]){\\n        if(i!=par){\\n            auto [a,b]=dfs1(i,root,adj,node_cont);\\n            ans.first+=max(a,b);\\n            ans.second+=a;\\n        }\\n    }\\n    return ans;\\n}\\n    int dfs(int st,int end,int par,vector<int>& price,vector<vector<int>>& adj,vector<int>& node_cont){\\n        int ans=0;\\n        ans+=price[st];\\n        node_cont[st]+=price[st];\\n        if(st==end) return ans;\\n        for(int& i: adj[st]){\\n            if(i!=par){\\n                int res=dfs(i,end,st,price,adj,node_cont);\\n                if(res)  return ans+res;\\n            }\\n        }\\n        node_cont[st]-=price[st];\\n        return 0;\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        int ans=0;\\n        vector<vector<int>> adj(n);\\n        int root=-1;\\n        for(auto& ele: edges){\\n            adj[ele[0]].push_back(ele[1]);\\n            adj[ele[1]].push_back(ele[0]);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(adj[i].size()<=1){\\n                root=i;\\n                break;\\n            }\\n        }\\n        vector<int> node_cont(n,0);\\n        for(int i=0;i<trips.size();i++){\\n            int st=trips[i][0];\\n            int end=trips[i][1];\\n            ans+=dfs(st,end,-1,price,adj,node_cont);\\n        }\\n        auto [a,b]=dfs1(root,-1,adj,node_cont);\\n        ans-=max(a,b)/2;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422105,
                "title": "python-3-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThere are two steps to this problem:\\n\\n- For each trip, work out the list of nodes in each trip. The question tries to throw us off by saying \"pick any path\", but in a tree graph there is only one path between any two nodes.\\n- Determine the optimal set of nodes to halve\\n\\n# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int], trips: list[list[int]]) -> int:\\n        d = defaultdict(set)\\n        trip_cache = dict()\\n        for l,r in edges:\\n            d[l].add(r)\\n            d[r].add(l)\\n            trip_cache[(l, r)] = [l, r]\\n            trip_cache[(r, l)] = [l, r]\\n        \\n        def get_nodes_in_trip(a, b):\\n            if (a == b):\\n                return [a]\\n            if (a,b) in trip_cache:\\n                return trip_cache[(a, b)]\\n            to_visit = [(a, [a])]\\n            visited = set()\\n            while(to_visit):\\n                node, nodes_in_path = to_visit.pop()\\n                visited.add(node)\\n                for adjacent in d[node]:\\n                    if adjacent in visited:\\n                        continue\\n                    new_nodes_in_path = nodes_in_path + [adjacent]\\n                    trip_cache[(a, adjacent)] = new_nodes_in_path\\n                    trip_cache[(adjacent, a)] = new_nodes_in_path\\n                    if (adjacent == b):\\n                        return new_nodes_in_path\\n                    to_visit.append((adjacent, new_nodes_in_path))\\n            return None\\n        node_costs = defaultdict(lambda: 0)\\n        for a,b in trips:\\n            nodes = get_nodes_in_trip(a, b)\\n            for n in nodes:\\n                node_costs[n] += price[n]\\n\\n   \\n        def get_best_discount(available_nodes, min_acceptable):\\n\\n            if not(available_nodes):\\n                return 0\\n            amount_we_can_possibly_take_off = sum([node_costs[n] for n in available_nodes]) // 2\\n            if amount_we_can_possibly_take_off < min_acceptable:\\n                return 0\\n            amount_if_we_discount_first = node_costs[available_nodes[0]]//2\\n            remaining = [n for n in available_nodes[1:] if (n not in d[available_nodes[0]])]\\n            amount_if_we_discount_first += get_best_discount(remaining, min_acceptable - amount_if_we_discount_first)\\n            amount_if_we_keep_first = get_best_discount(available_nodes[1:], max(min_acceptable, amount_if_we_discount_first))\\n            return max(amount_if_we_discount_first, amount_if_we_keep_first)\\n\\n        all_nodes = [n for n in range(len(price)) if node_costs[n]]\\n        all_nodes.sort(key=lambda n: 0-node_costs[n])\\n        best_discount = get_best_discount(all_nodes, 0)\\n        total_price_before_halving = sum(node_costs.values())\\n        return total_price_before_halving - best_discount\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int], trips: list[list[int]]) -> int:\\n        d = defaultdict(set)\\n        trip_cache = dict()\\n        for l,r in edges:\\n            d[l].add(r)\\n            d[r].add(l)\\n            trip_cache[(l, r)] = [l, r]\\n            trip_cache[(r, l)] = [l, r]\\n        \\n        def get_nodes_in_trip(a, b):\\n            if (a == b):\\n                return [a]\\n            if (a,b) in trip_cache:\\n                return trip_cache[(a, b)]\\n            to_visit = [(a, [a])]\\n            visited = set()\\n            while(to_visit):\\n                node, nodes_in_path = to_visit.pop()\\n                visited.add(node)\\n                for adjacent in d[node]:\\n                    if adjacent in visited:\\n                        continue\\n                    new_nodes_in_path = nodes_in_path + [adjacent]\\n                    trip_cache[(a, adjacent)] = new_nodes_in_path\\n                    trip_cache[(adjacent, a)] = new_nodes_in_path\\n                    if (adjacent == b):\\n                        return new_nodes_in_path\\n                    to_visit.append((adjacent, new_nodes_in_path))\\n            return None\\n        node_costs = defaultdict(lambda: 0)\\n        for a,b in trips:\\n            nodes = get_nodes_in_trip(a, b)\\n            for n in nodes:\\n                node_costs[n] += price[n]\\n\\n   \\n        def get_best_discount(available_nodes, min_acceptable):\\n\\n            if not(available_nodes):\\n                return 0\\n            amount_we_can_possibly_take_off = sum([node_costs[n] for n in available_nodes]) // 2\\n            if amount_we_can_possibly_take_off < min_acceptable:\\n                return 0\\n            amount_if_we_discount_first = node_costs[available_nodes[0]]//2\\n            remaining = [n for n in available_nodes[1:] if (n not in d[available_nodes[0]])]\\n            amount_if_we_discount_first += get_best_discount(remaining, min_acceptable - amount_if_we_discount_first)\\n            amount_if_we_keep_first = get_best_discount(available_nodes[1:], max(min_acceptable, amount_if_we_discount_first))\\n            return max(amount_if_we_discount_first, amount_if_we_keep_first)\\n\\n        all_nodes = [n for n in range(len(price)) if node_costs[n]]\\n        all_nodes.sort(key=lambda n: 0-node_costs[n])\\n        best_discount = get_best_discount(all_nodes, 0)\\n        total_price_before_halving = sum(node_costs.values())\\n        return total_price_before_halving - best_discount\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422058,
                "title": "python-3-dfs-dp-house-robber-tree-camera",
                "content": "First step is update costs of the nodes based on the frequency they are visited. Since tree size is small and no more than 100 trips, DFS and update total cost of the nodes on the path start to end.\\n\\nNext step is the same as [968. Binary Tree Cameras](https://leetcode.com/problems/binary-tree-cameras/) or [337. House Robber III](https://leetcode.com/problems/house-robber-iii/), at any node, we can either pay the full price and give the price cut option to its children, or cut its price (if we paid full price at its parent) and pay full price at its children.\\n\\nNote that the visited nodes may not be connected, need to loop through unvisited nodes and sum the min cost. E.g.\\nn = 4\\nedges = [[0,1],[1,2],[1,3]]\\nprice = [2,2,10,6]\\ntrips = [[0,0],[3,3]]\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def dfs(cur, par, e):\\n            if cur == e:\\n                ct[cur] += price[cur]\\n                return True\\n            for nxt in graph[cur] - {par}:\\n                if dfs(nxt, cur, e):\\n                    ct[cur] += price[cur]\\n                    return True\\n            return False\\n\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        ct = Counter()\\n        for s, e in trips:\\n            dfs(s, -1, e)\\n\\n        @cache\\n        def dp(cur, par, can_cut):\\n            vis.add(cur)\\n            res = ct[cur]\\n            for nxt in graph[cur] - {par}:\\n                if nxt in ct:\\n                    res += dp(nxt, cur, True)\\n            res1 = inf\\n            if can_cut:\\n                res1 = ct[cur] // 2\\n                for nxt in graph[cur] - {par}:\\n                    if nxt in ct:\\n                        res1 += dp(nxt, cur, False)\\n            return min(res, res1)\\n        \\n        ans = 0\\n        vis = set()\\n        for x in ct:\\n            if x not in vis:\\n                ans += dp(x, -1, True)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        def dfs(cur, par, e):\\n            if cur == e:\\n                ct[cur] += price[cur]\\n                return True\\n            for nxt in graph[cur] - {par}:\\n                if dfs(nxt, cur, e):\\n                    ct[cur] += price[cur]\\n                    return True\\n            return False\\n\\n        graph = defaultdict(set)\\n        for a, b in edges:\\n            graph[a].add(b)\\n            graph[b].add(a)\\n        \\n        ct = Counter()\\n        for s, e in trips:\\n            dfs(s, -1, e)\\n\\n        @cache\\n        def dp(cur, par, can_cut):\\n            vis.add(cur)\\n            res = ct[cur]\\n            for nxt in graph[cur] - {par}:\\n                if nxt in ct:\\n                    res += dp(nxt, cur, True)\\n            res1 = inf\\n            if can_cut:\\n                res1 = ct[cur] // 2\\n                for nxt in graph[cur] - {par}:\\n                    if nxt in ct:\\n                        res1 += dp(nxt, cur, False)\\n            return min(res, res1)\\n        \\n        ans = 0\\n        vis = set()\\n        for x in ct:\\n            if x not in vis:\\n                ans += dp(x, -1, True)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422057,
                "title": "house-robber-iii-o-n-2-bfs-dfs",
                "content": "# Intuition\\nPreprocess the trips information. We don\\'t want to know which nodes to half but just find the max possible sum of non-adjacent nodes and half it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse the trips information to find out which node is used how many times. Use this information - to choose which non-adjacent nodes to half. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Use BFS (to find the nodes used in a trip) and DFS ( to find the max possible sum of non-adjacent nodes). O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: - O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& temp, vector<bool>& visited, vector<int>& dp1, vector<int>& dp2){\\n        visited[src]=true;\\n        dp1[src]=temp[src];\\n        for(auto nbr:adj[src]){\\n            if(!visited[nbr]){\\n                dfs(nbr, adj,temp,visited,dp1, dp2);\\n                dp2[src]+=max(dp1[nbr], dp2[nbr]);\\n                dp1[src]+=dp2[nbr];\\n            }\\n        }\\n        \\n    }\\n    vector<int> helper(vector<int> trip, vector<vector<int>>& adj){\\n        int n=adj.size();\\n        vector<int> parent(n, -1);\\n        queue<int> q;\\n        parent[trip[0]]=trip[0];\\n        q.push(trip[0]);\\n        while(!q.empty()){\\n            int t=q.front();q.pop();\\n            if(t==trip[1]) break;\\n            for(auto nbr:adj[t]){\\n                if(parent[nbr]==-1){\\n                    parent[nbr]=t;\\n                    q.push(nbr);                    \\n                }\\n            }\\n        }\\n        int t=trip[1];\\n        vector<int> res;\\n        while(parent[t]!=t){\\n            res.push_back(t);\\n            t=parent[t];\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> cnt(n,0);\\n        for(auto t:trips){\\n            vector<int> temp=helper(t, adj);\\n            for(int i=0;i<temp.size();i++){\\n                cnt[temp[i]]++;\\n            }\\n        }\\n        long long p=0;\\n        for(int i=0;i<n;i++){\\n            p+=(price[i]*1LL*cnt[i]);\\n            cnt[i]=price[i]*cnt[i];\\n        }\\n        long long ans=0;\\n        vector<bool> visited(n,false);\\n        vector<int> dp1(n,0), dp2(n,0);\\n        dfs(0, adj, cnt, visited, dp1, dp2);\\n        ans=max(dp1[0], dp2[0]);\\n        return p-ans+(ans/2);        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int src, vector<vector<int>>& adj, vector<int>& temp, vector<bool>& visited, vector<int>& dp1, vector<int>& dp2){\\n        visited[src]=true;\\n        dp1[src]=temp[src];\\n        for(auto nbr:adj[src]){\\n            if(!visited[nbr]){\\n                dfs(nbr, adj,temp,visited,dp1, dp2);\\n                dp2[src]+=max(dp1[nbr], dp2[nbr]);\\n                dp1[src]+=dp2[nbr];\\n            }\\n        }\\n        \\n    }\\n    vector<int> helper(vector<int> trip, vector<vector<int>>& adj){\\n        int n=adj.size();\\n        vector<int> parent(n, -1);\\n        queue<int> q;\\n        parent[trip[0]]=trip[0];\\n        q.push(trip[0]);\\n        while(!q.empty()){\\n            int t=q.front();q.pop();\\n            if(t==trip[1]) break;\\n            for(auto nbr:adj[t]){\\n                if(parent[nbr]==-1){\\n                    parent[nbr]=t;\\n                    q.push(nbr);                    \\n                }\\n            }\\n        }\\n        int t=trip[1];\\n        vector<int> res;\\n        while(parent[t]!=t){\\n            res.push_back(t);\\n            t=parent[t];\\n        }\\n        res.push_back(t);\\n        return res;\\n    }\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        vector<int> cnt(n,0);\\n        for(auto t:trips){\\n            vector<int> temp=helper(t, adj);\\n            for(int i=0;i<temp.size();i++){\\n                cnt[temp[i]]++;\\n            }\\n        }\\n        long long p=0;\\n        for(int i=0;i<n;i++){\\n            p+=(price[i]*1LL*cnt[i]);\\n            cnt[i]=price[i]*cnt[i];\\n        }\\n        long long ans=0;\\n        vector<bool> visited(n,false);\\n        vector<int> dp1(n,0), dp2(n,0);\\n        dfs(0, adj, cnt, visited, dp1, dp2);\\n        ans=max(dp1[0], dp2[0]);\\n        return p-ans+(ans/2);        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422000,
                "title": "c-dp-on-tree-to-count-max-savings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe first get the number of times each node is used in a path, and then try to use dp to find the max savings possible. In order for the dp to work we need to root it at an arbitrary node, and find a toposort for the order that we evaluate the nodes in.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRoot the tree with a dfs and to get the toposort.\\n\\nGet the number of times each node is used on a path with a dfs (recursive backtracking) and this is added to `chosen`.\\n\\nFrom there we can do our dp on trees, where the states are: \\ndp[i][0]: max savings from subtree rooted at i if we don\\'t save node i\\ndp[i][1]: max savings from subtree rooted at i if we save node i\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) initial dfs\\nO(n*trips) getting the counts\\nO(2*n) dp\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n*trips) for the various arrays\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> al,child;\\n    vector<int> toposort,parent, vis,path;\\n    void dfs(int u, vector<int> &vis){\\n        vis[u] = 1;\\n        for(auto&v:al[u]){\\n            if(!vis[v]) {\\n                parent[v] = u;\\n                child[u].push_back(v);\\n                dfs(v,vis);\\n            }\\n        }\\n        toposort.push_back(u);\\n    }\\n\\n    void getPath(int u, int target, vector<int>&curr){\\n        vis[u] = 1;\\n        curr.push_back(u);\\n        if(u==target) path = curr;\\n        for(auto&v:al[u]){\\n            if(!vis[v]){\\n                getPath(v,target,curr);\\n            }\\n        }\\n        curr.pop_back();\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        al.resize(n);\\n        child.resize(n);\\n        parent.assign(n,-1);\\n        \\n        for(auto&x:edges){\\n            al[x[0]].push_back(x[1]);\\n            al[x[1]].push_back(x[0]);\\n        }\\n        vis.assign(n,0);\\n        dfs(0,vis);\\n        \\n        vector<int> chosen(n,0);\\n        for(auto&t:trips){\\n            vis.assign(n,0);\\n            vector<int> curr;\\n            getPath(t[0],t[1],curr);\\n            for(auto&x:path){\\n                chosen[x]++;\\n            }\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ans += chosen[i] * price[i];\\n        }\\n        \\n        // dp[i][0]: max savings from subtree rooted at i if we don\\'t save i\\n        vector<vector<int>> dp(n, vector<int>(2,0));\\n        for(auto&x:toposort){\\n            for(auto&c:child[x]){\\n                dp[x][0] += max(dp[c][0], dp[c][1]);\\n                dp[x][1] += dp[c][0];\\n            }\\n            dp[x][1] += chosen[x] * price[x]/2;\\n        }\\n        \\n        return ans - max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> al,child;\\n    vector<int> toposort,parent, vis,path;\\n    void dfs(int u, vector<int> &vis){\\n        vis[u] = 1;\\n        for(auto&v:al[u]){\\n            if(!vis[v]) {\\n                parent[v] = u;\\n                child[u].push_back(v);\\n                dfs(v,vis);\\n            }\\n        }\\n        toposort.push_back(u);\\n    }\\n\\n    void getPath(int u, int target, vector<int>&curr){\\n        vis[u] = 1;\\n        curr.push_back(u);\\n        if(u==target) path = curr;\\n        for(auto&v:al[u]){\\n            if(!vis[v]){\\n                getPath(v,target,curr);\\n            }\\n        }\\n        curr.pop_back();\\n    }\\n    \\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        al.resize(n);\\n        child.resize(n);\\n        parent.assign(n,-1);\\n        \\n        for(auto&x:edges){\\n            al[x[0]].push_back(x[1]);\\n            al[x[1]].push_back(x[0]);\\n        }\\n        vis.assign(n,0);\\n        dfs(0,vis);\\n        \\n        vector<int> chosen(n,0);\\n        for(auto&t:trips){\\n            vis.assign(n,0);\\n            vector<int> curr;\\n            getPath(t[0],t[1],curr);\\n            for(auto&x:path){\\n                chosen[x]++;\\n            }\\n        }\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            ans += chosen[i] * price[i];\\n        }\\n        \\n        // dp[i][0]: max savings from subtree rooted at i if we don\\'t save i\\n        vector<vector<int>> dp(n, vector<int>(2,0));\\n        for(auto&x:toposort){\\n            for(auto&c:child[x]){\\n                dp[x][0] += max(dp[c][0], dp[c][1]);\\n                dp[x][1] += dp[c][0];\\n            }\\n            dp[x][1] += chosen[x] * price[x]/2;\\n        }\\n        \\n        return ans - max(dp[0][0],dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421999,
                "title": "c-solutions-dfs-dp-easy-to-understan",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int> > t(n, vector<int>{});\\n        for (auto x: edges) {\\n            t[x[0]].push_back(x[1]);\\n            t[x[1]].push_back(x[0]);\\n        }\\n        vector<int> fa(n), dep(n), cnt(n);\\n        function<void(int, int, int)> dfs = [&](int x, int f, int dis) {\\n            fa[x] = f; dep[x] = dis;\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs(v, x, dis + 1);\\n            }\\n        };\\n        dfs(0, 0, 0);\\n        for (auto pr: trips) {\\n            int u = pr[0], v = pr[1];\\n            if (dep[u] > dep[v])\\n                swap(u, v);\\n            while (dep[u] < dep[v]) {\\n                ++ cnt[v];\\n                v = fa[v];\\n            }\\n            while (u != v)\\n                ++ cnt[u], ++ cnt[v], u = fa[u], v = fa[v];\\n           ++ cnt[u];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i ++)\\n            ans += 1ll * cnt[i] * price[i];\\n        vector<vector<long long> > dp(n, vector<long long>(2));\\n        function<void(int, int)> dfs2 = [&](int x, int f) {\\n            dp[x][0] = 0;\\n            dp[x][1] = 1ll * price[x] / 2 * cnt[x];\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs2(v, x);\\n                dp[x][0] += max(dp[v][1], dp[v][0]);\\n                dp[x][1] += dp[v][0];\\n            }\\n        };\\n        dfs2(0, 0);\\n        return ans - max(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int> > t(n, vector<int>{});\\n        for (auto x: edges) {\\n            t[x[0]].push_back(x[1]);\\n            t[x[1]].push_back(x[0]);\\n        }\\n        vector<int> fa(n), dep(n), cnt(n);\\n        function<void(int, int, int)> dfs = [&](int x, int f, int dis) {\\n            fa[x] = f; dep[x] = dis;\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs(v, x, dis + 1);\\n            }\\n        };\\n        dfs(0, 0, 0);\\n        for (auto pr: trips) {\\n            int u = pr[0], v = pr[1];\\n            if (dep[u] > dep[v])\\n                swap(u, v);\\n            while (dep[u] < dep[v]) {\\n                ++ cnt[v];\\n                v = fa[v];\\n            }\\n            while (u != v)\\n                ++ cnt[u], ++ cnt[v], u = fa[u], v = fa[v];\\n           ++ cnt[u];\\n        }\\n        long long ans = 0;\\n        for (int i = 0; i < n; i ++)\\n            ans += 1ll * cnt[i] * price[i];\\n        vector<vector<long long> > dp(n, vector<long long>(2));\\n        function<void(int, int)> dfs2 = [&](int x, int f) {\\n            dp[x][0] = 0;\\n            dp[x][1] = 1ll * price[x] / 2 * cnt[x];\\n            for (auto v: t[x]) {\\n                if (v == f)\\n                    continue;\\n                dfs2(v, x);\\n                dp[x][0] += max(dp[v][1], dp[v][0]);\\n                dp[x][1] += dp[v][0];\\n            }\\n        };\\n        dfs2(0, 0);\\n        return ans - max(dp[0][0], dp[0][1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421976,
                "title": "python-dfs-dp",
                "content": "First of all run a dfs to get the total cost without halving any node (ans).\\nNow for all paths keep a count of how many times we will encounter each node. Multiply that value with half the price of that node. ( loss array)\\nNow the Q boils down to the famous Q of getting max value of a tree without choosing any adjacent nodes (gg) .Use dp for this.\\nNow subtract this value from the initial answer to get our final answer (ans-gg). \\nTime Complexity: O(n * m) , where n is no of nodes and m is size of trips array.\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        ans=0\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        cnt=[0]*n\\n        def dfs2(node,end,val,path):\\n            nonlocal ans\\n            seen[node]=1\\n            if node==end: \\n                ans+=val+price[node]\\n                path+=[node]\\n                for gg in path: cnt[gg]+=1\\n                return\\n            for nei in graph[node]:\\n                if seen[nei]: continue\\n                dfs2(nei,end,val+price[node],path+[node])\\n            return val\\n        for s,e in trips:\\n            seen=[0]*n\\n            dfs2(s,e,0,[])\\n        loss=[0]*n\\n        for i in range(n):\\n            loss[i]=(cnt[i]*price[i])//2\\n        dp1,dp2=[0]*n,[0]*n\\n        def dfs(node,par):\\n            val1,val2=0,0\\n            for nei in graph[node]:\\n                if(nei == par): continue\\n                dfs(nei, node);\\n                val1 += dp2[nei]\\n                val2 += max(dp1[nei], dp2[nei])\\n            dp1[node] = loss[node] + val1\\n            dp2[node] = val2\\n        dfs(0,-1)\\n        gg=max(dp1[0],dp2[0])\\n        return ans-gg\\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph=defaultdict(list)\\n        ans=0\\n        for u,v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        cnt=[0]*n\\n        def dfs2(node,end,val,path):\\n            nonlocal ans\\n            seen[node]=1\\n            if node==end: \\n                ans+=val+price[node]\\n                path+=[node]\\n                for gg in path: cnt[gg]+=1\\n                return\\n            for nei in graph[node]:\\n                if seen[nei]: continue\\n                dfs2(nei,end,val+price[node],path+[node])\\n            return val\\n        for s,e in trips:\\n            seen=[0]*n\\n            dfs2(s,e,0,[])\\n        loss=[0]*n\\n        for i in range(n):\\n            loss[i]=(cnt[i]*price[i])//2\\n        dp1,dp2=[0]*n,[0]*n\\n        def dfs(node,par):\\n            val1,val2=0,0\\n            for nei in graph[node]:\\n                if(nei == par): continue\\n                dfs(nei, node);\\n                val1 += dp2[nei]\\n                val2 += max(dp1[nei], dp2[nei])\\n            dp1[node] = loss[node] + val1\\n            dp2[node] = val2\\n        dfs(0,-1)\\n        gg=max(dp1[0],dp2[0])\\n        return ans-gg\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421952,
                "title": "calculate-visited-times-of-each-node-then-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTwo steps:\\n1. calculate visited times of each node. This can be done in $O(NT)$ where $T=len(trips)$\\n2. dynamic programming: dp[u][0] means minimum cost of u and u\\'s descendants without halving the price of u, dp[u][1] means minimum cost of u and u\\'s descendants if we halve the price of u. This can be done in $O(N)$\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        ts=[0]*n\\n        def dfs(u,p,tar):\\n            has=False\\n            if u==tar: has=True; ts[u]+=1\\n            else:\\n                for v in g[u]:\\n                    if v==p: continue\\n                    if dfs(v,u,tar): has=True; ts[u]+=1;break\\n            return has\\n        for s,e in trips:\\n            dfs(s,-1,e)\\n        dp=[[price[i]*ts[i],price[i]//2*ts[i]] for i in range(n)]\\n        def dfs2(u,p):\\n            for v in g[u]:\\n                if v==p: continue\\n                dfs2(v,u)\\n                dp[u][0]+=min(dp[v])\\n                dp[u][1]+=dp[v][0]\\n        dfs2(0,-1)\\n        return min(dp[0])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        g=defaultdict(list)\\n        for u,v in edges:\\n            g[u].append(v); g[v].append(u)\\n        ts=[0]*n\\n        def dfs(u,p,tar):\\n            has=False\\n            if u==tar: has=True; ts[u]+=1\\n            else:\\n                for v in g[u]:\\n                    if v==p: continue\\n                    if dfs(v,u,tar): has=True; ts[u]+=1;break\\n            return has\\n        for s,e in trips:\\n            dfs(s,-1,e)\\n        dp=[[price[i]*ts[i],price[i]//2*ts[i]] for i in range(n)]\\n        def dfs2(u,p):\\n            for v in g[u]:\\n                if v==p: continue\\n                dfs2(v,u)\\n                dp[u][0]+=min(dp[v])\\n                dp[u][1]+=dp[v][0]\\n        dfs2(0,-1)\\n        return min(dp[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421949,
                "title": "python-dp",
                "content": "**Idea:**\\n\\t- For all trips find all nodes that are on the trips\\n\\t- Count nodes and count price of all trips (`S` in the code)\\n\\t- For each node find as much as we can save if we start walking from it and save on non-adjustent\\n\\t- return `S - max savings`\\n\\n```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        #find path from node to target\\n        def walk(node,parent):\\n            if node == target:\\n                return [target]\\n            else:\\n                for v in graph[node]:\\n                    if v != parent:\\n                        x = walk(v,node)\\n                        if x:\\n                            return [node] + x\\n            return None\\n        \\n        # count number of node accurances \\n        # and total cost for all trips\\n        c = Counter()\\n        S = 0\\n        for u,v in trips:\\n            target = v\\n            for x in walk(u,-1):\\n                c[x] += 1\\n                S += price[x]\\n        \\n        # maximize savings\\n        @cache\\n        def dp(node,parent,taken):\\n            X = 0\\n            if not taken:\\n                X = c[node] * (price[node] // 2)\\n                for v in graph[node]:\\n                    if v != parent:\\n                        X += dp(v,node,True)\\n            a = 0\\n            for v in graph[node]:\\n                if v != parent:\\n                    a += dp(v,node,False)\\n            return max(X,a)\\n        \\n        mx = 0\\n        for node in range(n):\\n            mx = max(mx, dp(node, -1,False))\\n        return S - mx\\n```\\n\\nTime: `O(N)`\\nSpace: `O(Trips * N)`\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        graph = defaultdict(list)\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n        #find path from node to target\\n        def walk(node,parent):\\n            if node == target:\\n                return [target]\\n            else:\\n                for v in graph[node]:\\n                    if v != parent:\\n                        x = walk(v,node)\\n                        if x:\\n                            return [node] + x\\n            return None\\n        \\n        # count number of node accurances \\n        # and total cost for all trips\\n        c = Counter()\\n        S = 0\\n        for u,v in trips:\\n            target = v\\n            for x in walk(u,-1):\\n                c[x] += 1\\n                S += price[x]\\n        \\n        # maximize savings\\n        @cache\\n        def dp(node,parent,taken):\\n            X = 0\\n            if not taken:\\n                X = c[node] * (price[node] // 2)\\n                for v in graph[node]:\\n                    if v != parent:\\n                        X += dp(v,node,True)\\n            a = 0\\n            for v in graph[node]:\\n                if v != parent:\\n                    a += dp(v,node,False)\\n            return max(X,a)\\n        \\n        mx = 0\\n        for node in range(n):\\n            mx = max(mx, dp(node, -1,False))\\n        return S - mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421941,
                "title": "simple-dfs-dp-memoization-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[51][55];\\n    int check(int node,int par,int prev,vector<int>adj[],vector<int>&cnt,vector<int>&price)\\n    {\\n         if(dp[node][prev]!=-1)\\n         {\\n             return dp[node][prev];\\n         }\\n         int ans=0;\\n         for(int child: adj[node])\\n         {\\n             if(child!=par)\\n             {\\n                 if(prev==node)\\n                 {\\n                      ans= ans+ cnt[child]*price[child]+check(child,node,prev,adj,cnt,price);\\n                 }else \\n                 {\\n                      int h1= cnt[child]*(price[child]/2)+ check(child,node,child,adj,cnt,price);\\n                      int h2= cnt[child]*(price[child])+check(child,node,prev,adj,cnt,price);\\n                      ans= ans+ min(h1,h2);\\n                 }\\n             }\\n         }\\n        return dp[node][prev]=ans;\\n    }\\n    void dfs(int node,int par1,vector<int>&par,vector<int>adj[])\\n    {\\n         par[node]=par1;\\n         for(int child: adj[node])\\n         {\\n             if(par1!=child)\\n             {\\n                  dfs(child,node,par,adj);\\n             }\\n         }\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n       \\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x= edges[i][0];\\n            int y= edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>par(n+1,-1);\\n        dfs(0,-1,par,adj);\\n        vector<int>cnt(n+1,0);\\n         for(int j=0;j<trips.size();j++)\\n             {\\n                  int st= trips[j][0];\\n                  int en= trips[j][1];\\n                  vector<int>p1,p2;\\n                  vector<int>vis(n+1,0);\\n                //  cout<<st<<\" \"<<en<<\"mmmmm\"<<endl;\\n                  while(st!=-1)\\n                  {\\n                      p1.push_back(st);\\n                      vis[st]++;\\n                      st= par[st];\\n                  }\\n                 int t2=-1;\\n                  while(en!=-1)\\n                  {\\n                      if(vis[en]>0)\\n                      {\\n                          t2=en;\\n                          break;\\n                      }\\n                      p2.push_back(en);\\n                      en= par[en];\\n                  }\\n                  for(int k=0;k<p1.size();k++)\\n                  {\\n                      if(p1[k]==t2)\\n                      {\\n                          cnt[p1[k]]++;\\n                          break;\\n                      }\\n                          cnt[p1[k]]++;\\n                  }\\n                 for(int k=0;k<p2.size();k++)\\n                 {\\n                          cnt[p2[k]]++;\\n                 }\\n             }\\n         memset(dp,-1,sizeof(dp));\\n        return min(cnt[0]*(price[0]/2)+check(0,-1,0,adj,cnt,price),cnt[0]*price[0]+check(0,-1,51,adj,cnt,price));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[51][55];\\n    int check(int node,int par,int prev,vector<int>adj[],vector<int>&cnt,vector<int>&price)\\n    {\\n         if(dp[node][prev]!=-1)\\n         {\\n             return dp[node][prev];\\n         }\\n         int ans=0;\\n         for(int child: adj[node])\\n         {\\n             if(child!=par)\\n             {\\n                 if(prev==node)\\n                 {\\n                      ans= ans+ cnt[child]*price[child]+check(child,node,prev,adj,cnt,price);\\n                 }else \\n                 {\\n                      int h1= cnt[child]*(price[child]/2)+ check(child,node,child,adj,cnt,price);\\n                      int h2= cnt[child]*(price[child])+check(child,node,prev,adj,cnt,price);\\n                      ans= ans+ min(h1,h2);\\n                 }\\n             }\\n         }\\n        return dp[node][prev]=ans;\\n    }\\n    void dfs(int node,int par1,vector<int>&par,vector<int>adj[])\\n    {\\n         par[node]=par1;\\n         for(int child: adj[node])\\n         {\\n             if(par1!=child)\\n             {\\n                  dfs(child,node,par,adj);\\n             }\\n         }\\n    }\\npublic:\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n       \\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int x= edges[i][0];\\n            int y= edges[i][1];\\n            adj[x].push_back(y);\\n            adj[y].push_back(x);\\n        }\\n        vector<int>par(n+1,-1);\\n        dfs(0,-1,par,adj);\\n        vector<int>cnt(n+1,0);\\n         for(int j=0;j<trips.size();j++)\\n             {\\n                  int st= trips[j][0];\\n                  int en= trips[j][1];\\n                  vector<int>p1,p2;\\n                  vector<int>vis(n+1,0);\\n                //  cout<<st<<\" \"<<en<<\"mmmmm\"<<endl;\\n                  while(st!=-1)\\n                  {\\n                      p1.push_back(st);\\n                      vis[st]++;\\n                      st= par[st];\\n                  }\\n                 int t2=-1;\\n                  while(en!=-1)\\n                  {\\n                      if(vis[en]>0)\\n                      {\\n                          t2=en;\\n                          break;\\n                      }\\n                      p2.push_back(en);\\n                      en= par[en];\\n                  }\\n                  for(int k=0;k<p1.size();k++)\\n                  {\\n                      if(p1[k]==t2)\\n                      {\\n                          cnt[p1[k]]++;\\n                          break;\\n                      }\\n                          cnt[p1[k]]++;\\n                  }\\n                 for(int k=0;k<p2.size();k++)\\n                 {\\n                          cnt[p2[k]]++;\\n                 }\\n             }\\n         memset(dp,-1,sizeof(dp));\\n        return min(cnt[0]*(price[0]/2)+check(0,-1,0,adj,cnt,price),cnt[0]*price[0]+check(0,-1,51,adj,cnt,price));\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3421936,
                "title": "java-dfs-dp-most-intuitive-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] es, int[] p, int[][] trips) {\\n        \\n        ArrayList<Integer>[]g = new ArrayList[n];\\n        for(int i=0;i<g.length;i++)g[i] = new ArrayList<>();\\n        for(int[]e:es) {\\n            g[e[1]].add(e[0]);\\n            g[e[0]].add(e[1]);\\n        }\\n        int[] f = new int[n];\\n        boolean[]v = new boolean[n];\\n        for(int[]tr : trips) {\\n            v = new boolean[n];\\n            trip(tr[0], tr[1], v, new int[n], f, g);\\n        }\\n        \\n        long totalSum = 0;\\n\\t\\t// totalSum of costs would be sum of how many times a node is travelled times its cost\\n        for(int i=0;i<n;i++)totalSum += (p[i] * f[i]);\\n        \\n        int max=0;\\n        int[][]dp = new int[n][2];\\n        for(int[]x:dp)Arrays.fill(x, -1);\\n\\t\\t// find maximum alternating sum in a graph, since all the nodes have positive cost and these nodes are contributing higest cost, hence reduce them by half. \\n\\t\\t//So final ans = totalsum - (half of maximum alternating sum)\\n        max = Math.max(max, Math.max(solve(0, true, -1,f, p, g, dp), solve(0, false, -1,f, p, g, dp)));\\n        return (int)(totalSum - (max/2));\\n        \\n    }\\n    \\n    public int solve(int u, boolean contributeSelf, int par, int[]f, int[]p, ArrayList<Integer>[]g, int[][]dp) {\\n        int ans=0;\\n        if(dp[u][contributeSelf?1:0] != -1) return dp[u][contributeSelf?1:0];\\n        if(contributeSelf) {\\n            int inc = f[u]*p[u];\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                inc += solve(nbr, false, u, f, p, g, dp);\\n            }\\n            \\n            int exc = 0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            \\n            ans = Math.max(inc, exc);\\n            \\n        } else {\\n            int exc=0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            ans = exc;\\n        }\\n        return dp[u][contributeSelf?1:0] = ans;\\n    }\\n    \\n    public void trip(int src, int dest, boolean[]v, int[]f, int[]global, ArrayList<Integer>[]g) {\\n        if(v[src]) return;\\n        v[src] = true;\\n        f[src]++;\\n        if(src == dest) {\\n\\t\\t// increasing frequency of nodes in current trip\\n        \\tfor(int i=0;i<f.length;i++)global[i] += f[i];\\n            return;\\n        }\\n        for(int nbr:g[src])trip(nbr, dest, v, f, global, g);\\n        f[src]--;\\n    }\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minimumTotalPrice(int n, int[][] es, int[] p, int[][] trips) {\\n        \\n        ArrayList<Integer>[]g = new ArrayList[n];\\n        for(int i=0;i<g.length;i++)g[i] = new ArrayList<>();\\n        for(int[]e:es) {\\n            g[e[1]].add(e[0]);\\n            g[e[0]].add(e[1]);\\n        }\\n        int[] f = new int[n];\\n        boolean[]v = new boolean[n];\\n        for(int[]tr : trips) {\\n            v = new boolean[n];\\n            trip(tr[0], tr[1], v, new int[n], f, g);\\n        }\\n        \\n        long totalSum = 0;\\n\\t\\t// totalSum of costs would be sum of how many times a node is travelled times its cost\\n        for(int i=0;i<n;i++)totalSum += (p[i] * f[i]);\\n        \\n        int max=0;\\n        int[][]dp = new int[n][2];\\n        for(int[]x:dp)Arrays.fill(x, -1);\\n\\t\\t// find maximum alternating sum in a graph, since all the nodes have positive cost and these nodes are contributing higest cost, hence reduce them by half. \\n\\t\\t//So final ans = totalsum - (half of maximum alternating sum)\\n        max = Math.max(max, Math.max(solve(0, true, -1,f, p, g, dp), solve(0, false, -1,f, p, g, dp)));\\n        return (int)(totalSum - (max/2));\\n        \\n    }\\n    \\n    public int solve(int u, boolean contributeSelf, int par, int[]f, int[]p, ArrayList<Integer>[]g, int[][]dp) {\\n        int ans=0;\\n        if(dp[u][contributeSelf?1:0] != -1) return dp[u][contributeSelf?1:0];\\n        if(contributeSelf) {\\n            int inc = f[u]*p[u];\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                inc += solve(nbr, false, u, f, p, g, dp);\\n            }\\n            \\n            int exc = 0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            \\n            ans = Math.max(inc, exc);\\n            \\n        } else {\\n            int exc=0;\\n            for(int nbr : g[u]) {\\n                if(nbr != par)\\n                exc += solve(nbr, true, u, f, p, g, dp);\\n            }\\n            ans = exc;\\n        }\\n        return dp[u][contributeSelf?1:0] = ans;\\n    }\\n    \\n    public void trip(int src, int dest, boolean[]v, int[]f, int[]global, ArrayList<Integer>[]g) {\\n        if(v[src]) return;\\n        v[src] = true;\\n        f[src]++;\\n        if(src == dest) {\\n\\t\\t// increasing frequency of nodes in current trip\\n        \\tfor(int i=0;i<f.length;i++)global[i] += f[i];\\n            return;\\n        }\\n        for(int nbr:g[src])trip(nbr, dest, v, f, global, g);\\n        f[src]--;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421829,
                "title": "dfs-to-calculate-frequency-of-each-node-dp-knapsack-to-get-the-min-total-sum",
                "content": "We first run a dfs on each trip to calculate the frequency of each node\\nthen node sum = price[node] * nodeFrequency\\n\\nthen we run a dp starting from any node\\nwhere we chose where to split or not on each node to get the total min sum\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> hm;\\n    int memo[2][57];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(auto& t: trips) {\\n            vector<int> parent(n, -1);\\n            bool done = false;\\n            dfs(t[0], t[0], t[1], adj, parent, done);\\n        }\\n        vector<int> sum(n);\\n        for(auto& p: hm) {\\n            sum[p.first] = price[p.first] * p.second;\\n        }\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,n+1,1,adj,sum);\\n        \\n    }\\n    int solve(int idx, int par, int canSplit, vector<vector<int>>& adj, vector<int>& sum) {\\n        auto& ans = memo[canSplit][idx];\\n        if (ans != -1) return ans;\\n        int take = 0;\\n        int split = 0;\\n        for(auto& j: adj[idx]) {\\n            if (j == par) continue;\\n            take += solve(j,idx,1,adj,sum);  \\n            split += solve(j,idx,0,adj,sum);  \\n        }\\n        ans = sum[idx] + take;\\n        if (canSplit) ans = min(ans, sum[idx]/2 + split);\\n        return ans;\\n    }\\n    void dfs(int i, int& source, int& target, vector<vector<int>>& adj, vector<int>& parent, bool& done) {\\n        if (i == target) {\\n            while(i != source) {\\n                hm[i]++;\\n                i = parent[i];\\n            }\\n            hm[source]++;\\n            done = true;\\n            return;\\n        }\\n        for(auto& j: adj[i]) {\\n            if (j != parent[i]) {\\n                parent[j] = i;\\n                dfs(j,source,target,adj,parent,done);\\n                if (done) return;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> hm;\\n    int memo[2][57];\\n    int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n        vector<vector<int>> adj(n);\\n        for(auto& e: edges) {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        for(auto& t: trips) {\\n            vector<int> parent(n, -1);\\n            bool done = false;\\n            dfs(t[0], t[0], t[1], adj, parent, done);\\n        }\\n        vector<int> sum(n);\\n        for(auto& p: hm) {\\n            sum[p.first] = price[p.first] * p.second;\\n        }\\n        memset(memo, -1, sizeof memo);\\n        return solve(0,n+1,1,adj,sum);\\n        \\n    }\\n    int solve(int idx, int par, int canSplit, vector<vector<int>>& adj, vector<int>& sum) {\\n        auto& ans = memo[canSplit][idx];\\n        if (ans != -1) return ans;\\n        int take = 0;\\n        int split = 0;\\n        for(auto& j: adj[idx]) {\\n            if (j == par) continue;\\n            take += solve(j,idx,1,adj,sum);  \\n            split += solve(j,idx,0,adj,sum);  \\n        }\\n        ans = sum[idx] + take;\\n        if (canSplit) ans = min(ans, sum[idx]/2 + split);\\n        return ans;\\n    }\\n    void dfs(int i, int& source, int& target, vector<vector<int>>& adj, vector<int>& parent, bool& done) {\\n        if (i == target) {\\n            while(i != source) {\\n                hm[i]++;\\n                i = parent[i];\\n            }\\n            hm[source]++;\\n            done = true;\\n            return;\\n        }\\n        for(auto& j: adj[i]) {\\n            if (j != parent[i]) {\\n                parent[j] = i;\\n                dfs(j,source,target,adj,parent,done);\\n                if (done) return;\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421760,
                "title": "python-dfs-dp-top-down",
                "content": "Find contribution of each node in the total price sum and then find minimum sum by recursively generating all sets of nodes for which prices will be halved and storing the result to avoid repeated calculations.\\n\\n\\n```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        \\n        #function to find path from a node to target node and inclrease the contribution of all nodes in the path\\n        def dfs(node,target,parent):\\n            nonlocal g,contribution\\n            \\n            contribution[node]+=1\\n            if node==target:\\n                return True\\n            \\n            for adj in g[node]:\\n                if adj!=parent:\\n                    if dfs(adj,target,node):\\n                        # target found\\n                        return True\\n                    \\n            # target not found\\n            contribution[node]-=1\\n            return False\\n        \\n        # function to calculate minimum total price sum of tree rooted at \\'node\\'\\n        def backtrack(node,include,parent):\\n            \\n            nonlocal included,excluded,g,contribution\\n            \\n            if included[node]==-1:\\n                # exclude (don\\'t reduce price of node)\\n                excluded[node]=contribution[node]*price[node]\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are not reducing the price of this node, prices of adjacent nodes can be reduced so include=True\\n                        excluded[node]+=backtrack(adj,True,node)\\n\\n                # include (reduce price of node)\\n                included[node]=contribution[node]*price[node]//2\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are reducing the price of this node, prices of adjacent nodes cannot be reduced so include=False\\n                        included[node]+=backtrack(adj,False,node)\\n                        \\n            if include:\\n                return min(included[node],excluded[node])\\n            else:\\n                return excluded[node]\\n        \\n        \\n        g=[[] for _ in range(n)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        contribution=[0]*n\\n        \\n        # find contribution of each node in total price sum\\n        for start,end in trips:\\n            dfs(start,end,-1)\\n        \\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is halved\\n        included=[-1]*n\\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is not halved\\n        excluded=[-1]*n\\n        \\n        # consider node 0 as root and calculate all combinations\\n        return min(backtrack(0,True,-1),backtrack(0,False,-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:\\n        \\n        #function to find path from a node to target node and inclrease the contribution of all nodes in the path\\n        def dfs(node,target,parent):\\n            nonlocal g,contribution\\n            \\n            contribution[node]+=1\\n            if node==target:\\n                return True\\n            \\n            for adj in g[node]:\\n                if adj!=parent:\\n                    if dfs(adj,target,node):\\n                        # target found\\n                        return True\\n                    \\n            # target not found\\n            contribution[node]-=1\\n            return False\\n        \\n        # function to calculate minimum total price sum of tree rooted at \\'node\\'\\n        def backtrack(node,include,parent):\\n            \\n            nonlocal included,excluded,g,contribution\\n            \\n            if included[node]==-1:\\n                # exclude (don\\'t reduce price of node)\\n                excluded[node]=contribution[node]*price[node]\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are not reducing the price of this node, prices of adjacent nodes can be reduced so include=True\\n                        excluded[node]+=backtrack(adj,True,node)\\n\\n                # include (reduce price of node)\\n                included[node]=contribution[node]*price[node]//2\\n                for adj in g[node]:\\n                    if adj!=parent:\\n                        # since we are reducing the price of this node, prices of adjacent nodes cannot be reduced so include=False\\n                        included[node]+=backtrack(adj,False,node)\\n                        \\n            if include:\\n                return min(included[node],excluded[node])\\n            else:\\n                return excluded[node]\\n        \\n        \\n        g=[[] for _ in range(n)]\\n        for u,v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        contribution=[0]*n\\n        \\n        # find contribution of each node in total price sum\\n        for start,end in trips:\\n            dfs(start,end,-1)\\n        \\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is halved\\n        included=[-1]*n\\n        # array to store minimum total price sum of tree rooted at ith node such that price of ith node is not halved\\n        excluded=[-1]*n\\n        \\n        # consider node 0 as root and calculate all combinations\\n        return min(backtrack(0,True,-1),backtrack(0,False,-1))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865045,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1864796,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1864879,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1872686,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 2048992,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1920082,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            },
            {
                "id": 1911496,
                "content": [
                    {
                        "username": "CODEX47",
                        "content": "can anyone tell why idea of calculating ans = min(odd level prices is divided / 2, even level prices is divided by 2) doesn't work? It works for around 100 testcases but then it gives wrong answers.\n\nhttps://leetcode.com/problems/minimize-the-total-price-of-the-trips/submissions/934514329/"
                    },
                    {
                        "username": "kumaran_577",
                        "content": "1) Its not neccessary that you have to pick only odd levels or only even levels \\n2) Assume , you are picking current level ,lets say that it is odd , you \"must\" skip next level (even level ) , and now you are in next odd level , you may even pick or not pick , sometimes not picking this might give optimal solution as we can pick next even level which might increase our score \\n"
                    },
                    {
                        "username": "HitenTandon",
                        "content": "This question sucked my soul, and I still couldn\\'t do it. Good question though. :)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Check this: 337. House Robber III\\n"
                    },
                    {
                        "username": "diabloallica",
                        "content": "can there even be multiple path options for a given trip given that it is guaranteed to be an unrooted tree?\\n"
                    },
                    {
                        "username": "nirvedh",
                        "content": "tree by definition cannot have cycles, if there were two paths, i could reach the node by one path and return back from the other path and hence form a cycle which is a contradiction hence for any tree regardless of rootedness will always have a unique simple path between two nodes"
                    },
                    {
                        "username": "geekyuttu",
                        "content": "For the first sample case, isn\\'t it possible to reduce the total price further by halving, 2,1,3, instead of 2,0,3"
                    },
                    {
                        "username": "MdoingIt",
                        "content": "amazing question"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "```\\nclass Solution {\\npublic:\\n  int dp[51][2];\\n  int dp_dfs(vector<int>& cnt, vector<int>& price, int node, vector<vector<int>>& E, int p = -1, bool parentHalved = false) {\\n    int res1 = (cnt[node] * price[node]) / 2, res2 = cnt[node] * price[node];\\n    if(dp[node][parentHalved] != -1)  {\\n      return dp[node][parentHalved];\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res2 += dp_dfs(cnt, price, el, E, node, 0);\\n      }\\n    }\\n    if(parentHalved)  {\\n      return dp[node][parentHalved] = res2;\\n    }\\n    for(auto& el : E[node]) {\\n      if(el != p) {\\n        res1 += dp_dfs(cnt, price, el, E, node, 1);\\n      }\\n    }\\n    return dp[node][parentHalved] = min(res1, res2);\\n  }\\n  int minimumTotalPrice(int n, vector<vector<int>>& edges, vector<int>& price, vector<vector<int>>& trips) {\\n    int sz = trips.size();\\n    vector<int> cnt(n, 0);\\n    vector<vector<int>> E(n);\\n    memset(dp, -1, sizeof(dp));\\n    int edgeSz = edges.size();\\n    for(int i = 0; i < edgeSz; i++) {\\n      E[edges[i][0]].push_back(edges[i][1]);\\n      E[edges[i][1]].push_back(edges[i][0]);\\n    }\\n    for(int i = 0; i < sz; i++) {\\n      int src = trips[i][0], dest = trips[i][1];\\n      vector<bool> seen(n, false);\\n      bool found = false;\\n      function<void(int)> dfs = [&] (int w)  {\\n        seen[w] = true;\\n        cnt[w]++;\\n        if(w == dest) {\\n          found = true;\\n          return;\\n        }\\n        for(auto v : E[w])  {\\n          if(!seen[v])  {\\n            dfs(v);\\n          }\\n        }\\n        if(found) {\\n          return;\\n        }\\n        cnt[w]--;\\n        seen[w] = false;\\n      };\\n      dfs(src);\\n    }\\n    return dp_dfs(cnt, price, 0, E, -1, 0);\\n  }\\n};\\n```\\nWhat could be the mistake, please help me to figure it out."
                    }
                ]
            }
        ]
    }
]