[
    {
        "title": "Minimum Operations to Make a Uni-Value Grid",
        "question_content": "You are given a 2D integer grid of size m x n and an integer x. In one operation, you can add x to or subtract x from any element in the grid.\nA uni-value grid is a grid where all the elements of it are equal.\nReturn the minimum number of operations to make the grid uni-value. If it is not possible, return -1.\n&nbsp;\nExample 1:\n\nInput: grid = [[2,4],[6,8]], x = 2\nOutput: 4\nExplanation: We can make every element equal to 4 by doing the following: \n- Add x to 2 once.\n- Subtract x from 6 once.\n- Subtract x from 8 twice.\nA total of 4 operations were used.\n\nExample 2:\n\nInput: grid = [[1,5],[2,3]], x = 1\nOutput: 5\nExplanation: We can make every element equal to 3.\n\nExample 3:\n\nInput: grid = [[1,2],[3,4]], x = 2\nOutput: -1\nExplanation: It is impossible to make every element equal.\n\n&nbsp;\nConstraints:\n\n\tm == grid.length\n\tn == grid[i].length\n\t1 <= m, n <= 105\n\t1 <= m * n <= 105\n\t1 <= x, grid[i][j] <= 104",
        "solutions": [
            {
                "id": 1513317,
                "title": "c-concise-with-hint",
                "content": "**Idea:-**\\nIdea is to sort the numbers of the grid and make all the grid elements equal to mid element.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>nums;\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                nums.push_back(grid[i][j]);\\n        sort(nums.begin(),nums.end());\\n        int target=nums[m*n/2],ans=0;\\n        for(int i=m*n-1;i>=0;i--){\\n            if(abs(nums[i]-target)%x!=0)\\n                return -1;\\n            else\\n                ans+=abs(nums[i]-target)/x;  \\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>nums;\\n        int m=grid.size(),n=grid[0].size();\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                nums.push_back(grid[i][j]);\\n        sort(nums.begin(),nums.end());\\n        int target=nums[m*n/2],ans=0;\\n        for(int i=m*n-1;i>=0;i--){\\n            if(abs(nums[i]-target)%x!=0)\\n                return -1;\\n            else\\n                ans+=abs(nums[i]-target)/x;  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513518,
                "title": "prove-the-median-answer",
                "content": "First of all we make the grid a sorted array `a[0], a[1], ... ,a[n-1]`.Then take two steps to prove why the median result is the minimum.Hope it makes sense to you.\\n\\nStep 1\\n\\n- If there is an available element to make a Uni-Value Grid, then any element of the sorted array is available to make a Uni-Value Grid.\\n  If an element of the array (assume its index is `m`) can\\'t make a Uni-Value Grid, there must be an element of the array (assume its index is ` i`) that satisfied: \\n  ` (a[i] - a[m]) % x != 0`\\n  Then if there exists an element that can make a Uni-Value Grid.let\\'s assume its value is val, we can get\\n ` (a[i] - val) % x == 0 and (a[m] - val) % x == 0`\\n  `((a[i] - val) - (a[m] - val)) %  x == 0 `\\n  `(a[i] - a[m] % x) == 0`\\n\\nSo we prove that if there is an element in the array that can\\'t make a Uni-Value Grid, then all the element (no matter it is in the array nor not) can\\'t make a Uni-Value Grid. As a result, if there is a available element to make a Uni-Value Grid, then all element  is availbale to make a Uni-Value Grid.\\n\\nStep 2\\n\\n- If there is an available element to make a Uni-Value Grid, the median result is the minimum.\\n  we can just assume `x` equals to 1. If we make all the elements equal to the `a[i]`,then we assume its result is `f(i)`.\\n  `f(i) = a[i]-a[0]+a[i]-a[1]+...+(a[i]-a[i-1])+(a[i]-a[i])+...+a[n-1]-a[i]`\\n  `f(i-1) = a[i-1]-a[0]+a[i-1]-a[1]+...+(a[i-1]-a[i-1])+(a[i]-a[i-1])+...+a[n-1]-a[i-1]`\\n  `f(i)-f(i-1) = i*(a[i]-a[i-1])+(n-i)*(a[i-1]-a[i])=(2*i-n)(a[i]-a[i-1])`\\n  Since `a[i] > a[i-1]`, we can get\\n  if `2*i<n, f(i)>f(i-1);` \\n  if `2*i>n, f(i)<f(i-1)`\\n  the minimum result is `f(n/2)` or `f((n-1)/2)`. \\n  So\\uFF0Call we need to do is try the median. if it works,we get the minimun operation,otherwise all elements  is not availbale to make a Uni-Value Grid.\\n  \\n      class Solution {\\n          public int minOperations(int[][] grid, int x) {\\n              ArrayList<Integer> arr = new ArrayList<>();\\n              int m = grid.length,n = grid[0].length;\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      arr.add(grid[i][j]);\\n                  }\\n              }\\n              Collections.sort(arr);\\n              int median = arr.get((arr.size())/2);\\n              int count = 0;\\n              for(int val : arr){\\n                  int diff = Math.abs(val-median);\\n                  if(diff % x!=0) return -1;\\n                  count += diff / x;   \\n              }\\n              return count;\\n          }\\n      }\\n  \\n",
                "solutionTags": [],
                "code": "class Solution {\\n          public int minOperations(int[][] grid, int x) {\\n              ArrayList<Integer> arr = new ArrayList<>();\\n              int m = grid.length,n = grid[0].length;\\n              for(int i=0;i<m;i++){\\n                  for(int j=0;j<n;j++){\\n                      arr.add(grid[i][j]);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1513331,
                "title": "two-swipes-vs-median",
                "content": "At the time, I felt that the median approach is a bit riskier, so I went for a more generic algorithm.\\n\\n> Update: added approach 2 below that uses the median. \\n\\nInstead, we collect then sort all numbers. We first go left-to-right, and track the number of operations in the `dp` array.\\n\\nThen, we go right-to-left, tracking the number of operations, returning the minimum sum of left and right operations.\\n\\n#### Approach 1: Two Swipes\\n\\n**C++**\\n```cpp\\nint minOperations(vector<vector<int>>& grid, int x) {\\n    int res = INT_MAX, ops = 0;\\n    vector<int> v, dp(grid.size() * grid[0].size());\\n    for (auto &row : grid)\\n        v.insert(end(v), begin(row), end(row));\\n    sort(begin(v), end(v));\\n    for (int i = 0; i < v.size() - 1; ++i) {\\n        if ((v[i + 1] - v[i]) % x)\\n            return -1;\\n        dp[i + 1] = dp[i] + (i + 1) * (v[i + 1] - v[i]) / x;\\n    }\\n    for (int i = v.size() - 1; i > 0; --i) {\\n        ops += (v.size() - i) * (v[i] - v[i - 1]) / x;\\n        res = min(res, ops + dp[i - 1]);\\n    }\\n    return res == INT_MAX ? 0 : res;\\n}\\n```\\n\\n#### Approach 2: Median\\nHere, we change every number to be a median. Note that we can find a median in O(n) using a quickselect algo (`nth_element`).\\n\\n**C++**`\\n```cpp\\nint minOperations(vector<vector<int>>& grid, int x) {\\n    int res = 0;\\n    vector<int> v;\\n    for (auto &row : grid)\\n        v.insert(end(v), begin(row), end(row));\\n    nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n    for (int i = 0; i < v.size(); ++i) {\\n        if (abs(v[v.size() / 2] - v[i]) % x)\\n            return -1;\\n        res += abs(v[v.size() / 2] - v[i]) / x;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint minOperations(vector<vector<int>>& grid, int x) {\\n    int res = INT_MAX, ops = 0;\\n    vector<int> v, dp(grid.size() * grid[0].size());\\n    for (auto &row : grid)\\n        v.insert(end(v), begin(row), end(row));\\n    sort(begin(v), end(v));\\n    for (int i = 0; i < v.size() - 1; ++i) {\\n        if ((v[i + 1] - v[i]) % x)\\n            return -1;\\n        dp[i + 1] = dp[i] + (i + 1) * (v[i + 1] - v[i]) / x;\\n    }\\n    for (int i = v.size() - 1; i > 0; --i) {\\n        ops += (v.size() - i) * (v[i] - v[i - 1]) / x;\\n        res = min(res, ops + dp[i - 1]);\\n    }\\n    return res == INT_MAX ? 0 : res;\\n}\\n```\n```cpp\\nint minOperations(vector<vector<int>>& grid, int x) {\\n    int res = 0;\\n    vector<int> v;\\n    for (auto &row : grid)\\n        v.insert(end(v), begin(row), end(row));\\n    nth_element(begin(v), begin(v) + v.size() / 2, end(v));\\n    for (int i = 0; i < v.size(); ++i) {\\n        if (abs(v[v.size() / 2] - v[i]) % x)\\n            return -1;\\n        res += abs(v[v.size() / 2] - v[i]) / x;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513446,
                "title": "python3-explanation-to-why-median-and-easy-understanding-code",
                "content": "From the question, we can see the core part of the problem is to find a \"target\" that \"minimize sum[ abs(grid[i][j] - target)/interval ]\".\\n\\nThis is equal to \"minimize sum[ abs(grid[i][j] - target) ]\" which is actually a \"[minimize the MAE loss](https://en.wikipedia.org/wiki/Mean_absolute_error)\" problem. \\n\\nFrom the above wiki link, you can see the solution to this MAE problem is the median. So our task is acutally \"find the median.\"\\n\\n```\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n\\t\\t\\n\\t\\t# handle the edge case\\n        if m==1 and n==1: return 0\\n\\t\\t\\n\\t\\t# transform grid to array, easier to operate\\n        arr = [] \\n        for i in range(m):\\n            arr+=grid[i]\\n        \\n        arr.sort()\\n        \\n\\t\\t# the median is arr[len(arr)//2] when len(arr) is odd\\n\\t\\t# or may be arr[len(arr)//2] and arr[len(arr)//2-1] when len(arr) is even.\\n        cand1 = arr[len(arr)//2]\\n        cand2 = arr[len(arr)//2-1]\\n        \\n        return min(\\n            self.get_num_operations_to_target(grid, cand1, x),\\n            self.get_num_operations_to_target(grid, cand2, x)\\n        )\\n        \\n        \\n    def get_num_operations_to_target(self, grid, target,x):\\n\\t\\t\"\"\"Get the total number of operations to transform all grid elements to the target value.\"\"\"\\n        ans = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if abs(grid[i][j]-target)%x!=0:\\n                    return -1\\n                else:\\n                    ans+=abs(grid[i][j]-target)//x\\n\\n        return ans\\n                \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        m = len(grid)\\n        n = len(grid[0])\\n\\t\\t\\n\\t\\t# handle the edge case\\n        if m==1 and n==1: return 0\\n\\t\\t\\n\\t\\t# transform grid to array, easier to operate\\n        arr = [] \\n        for i in range(m):\\n            arr+=grid[i]\\n        \\n        arr.sort()\\n        \\n\\t\\t# the median is arr[len(arr)//2] when len(arr) is odd\\n\\t\\t# or may be arr[len(arr)//2] and arr[len(arr)//2-1] when len(arr) is even.\\n        cand1 = arr[len(arr)//2]\\n        cand2 = arr[len(arr)//2-1]\\n        \\n        return min(\\n            self.get_num_operations_to_target(grid, cand1, x),\\n            self.get_num_operations_to_target(grid, cand2, x)\\n        )\\n        \\n        \\n    def get_num_operations_to_target(self, grid, target,x):\\n\\t\\t\"\"\"Get the total number of operations to transform all grid elements to the target value.\"\"\"\\n        ans = 0\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                if abs(grid[i][j]-target)%x!=0:\\n                    return -1\\n                else:\\n                    ans+=abs(grid[i][j]-target)//x\\n\\n        return ans\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513319,
                "title": "python3-median-4-line",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/933e9b50b2532374ab8252f431da84b6675663a8) for solutions of weekly 262.\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        vals = [x for row in grid for x in row]\\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\\n        return sum(abs(val - median)//x for val in vals)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        vals = [x for row in grid for x in row]\\n        if len(set(val%x for val in vals)) > 1: return -1 # impossible\\n        median = sorted(vals)[len(vals)//2] # O(N) possible via \"quick select\"\\n        return sum(abs(val - median)//x for val in vals)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516181,
                "title": "c-python-simple-and-concise-solutions-explained",
                "content": "**Idea:**\\nSimilar to https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/discuss/1217387/C%2B%2B-Simple-and-Clear-5-Line-Solution\\nWe cancatenate the grid to one big vector, and sort it.\\nNow we have the median in `arr[len(arr) // 2]`.\\nWe iterate through the vector from the end, because if we can\\'t make the grid uni-value we will find it faster.\\nIf we can\\'t make it the median - return -1.\\nOtherwise, we add to `res` the number of operations.\\n\\n**Python:**\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        arr = []\\n        for a in grid:\\n            arr += a\\n            \\n        arr.sort()\\n        \\n        median = arr[len(arr) // 2]\\n        res = 0;\\n        \\n        for n in reversed(arr):\\n            if abs(n - median) % x != 0:\\n                return -1\\n            res += abs(n - median) // x\\n        \\n        return res\\n```\\n****\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        for (auto vec : grid)\\n            arr.insert(arr.end(), vec.begin(), vec.end());\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int median = arr[arr.size() / 2], res = 0;\\n        \\n        for (int i = arr.size()-1; i >= 0; i--) {\\n            if (abs(arr[i] - median) % x) return -1;\\n            res += abs(arr[i] - median) / x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        arr = []\\n        for a in grid:\\n            arr += a\\n            \\n        arr.sort()\\n        \\n        median = arr[len(arr) // 2]\\n        res = 0;\\n        \\n        for n in reversed(arr):\\n            if abs(n - median) % x != 0:\\n                return -1\\n            res += abs(n - median) // x\\n        \\n        return res\\n```\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        for (auto vec : grid)\\n            arr.insert(arr.end(), vec.begin(), vec.end());\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int median = arr[arr.size() / 2], res = 0;\\n        \\n        for (int i = arr.size()-1; i >= 0; i--) {\\n            if (abs(arr[i] - median) % x) return -1;\\n            res += abs(arr[i] - median) / x;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515856,
                "title": "java-efficient-interview-solution-easy-to-understand",
                "content": "The thing that makes this question a bit more complicated is the fact that you have to get the minimum steps to convert the grid to uni-value.\\n\\nFor this, a simple brute force solution that you might think is getting the steps for all numbers in range `[minValue, maxValue]` and find the minimum steps that you found. Here `minValue` and `maxValue` are the minimum and maximum values from the grid.\\n\\nThis whole approach can be simplified though. How?\\nUsing the median of the data. Remember that the median of a set of numbers is the value that is closest to all of them.\\n\\nSo, how do we find the median of the numbers we have in the grid?\\nSort the elements of the grid and get the middle element.\\n\\nNow, implementation-wise, the best approach is adding all the elements from the grid to an array. Then we can easily sort and get the median. After that we can go through those elements and bring the value up/down to the median value while counting the steps that it took.\\n\\nHere we can also tackle the impossible case, if the `abs(currentValue - median)` is not divisible by `x` then we cannot bring `currentValue` to `median` while adding/subtracting `x` at a time. So we can return `-1` in that case.\\n\\nAlso counting steps can simply be done in `O(1)` time complexity by doing `abs(currentNum - median) / x`. This would count the number of steps required to make `currentNum` equal to `median` while subtracting/adding `x` at a time.\\n\\nIn code, this would look something like this:\\n\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] arr = new int[grid.length * grid[0].length];\\n        int index = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                arr[index++] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(arr);\\n        int median = arr[(arr.length - 1) / 2];\\n        int steps = 0;\\n        \\n        for (int num : arr) {\\n            if (num == median) {\\n                continue;\\n            }\\n            \\n            if (Math.abs(num - median) % x != 0) {\\n                return -1;\\n            }\\n            \\n            steps += (Math.abs(num - median) / x);\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] arr = new int[grid.length * grid[0].length];\\n        int index = 0;\\n        \\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                arr[index++] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(arr);\\n        int median = arr[(arr.length - 1) / 2];\\n        int steps = 0;\\n        \\n        for (int num : arr) {\\n            if (num == median) {\\n                continue;\\n            }\\n            \\n            if (Math.abs(num - median) % x != 0) {\\n                return -1;\\n            }\\n            \\n            steps += (Math.abs(num - median) / x);\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513587,
                "title": "javascript-explanation-why-the-median-is-the-equal-number-with-the-minimum-operations",
                "content": "```\\nvar minOperations = function(grid, x) {\\n    const nums = []\\n    for (let i=0; i< grid.length; i++) {\\n        for (let j=0; j< grid[0].length; j++) {\\n            nums.push(grid[i][j])\\n        }\\n    }\\n    \\n    // 1. only one single number, return directly\\n    if (nums.length < 2) {\\n        return 0\\n    }\\n    \\n    // 2. sorting all grid numbers in One - Dimension array\\n    nums.sort((a, b) => a -b) \\n    \\n    // 3. find the median, which is the final target equal number index\\n\\tconst n = nums.length\\n    const median = parseInt(n/2) \\n    \\n    // 4. calculate the times of add and subtract\\n    let ans = 0\\n    for (let i=0; i< n; i++) {\\n        const distance = Math.abs(nums[i] - nums[median])\\n        // 4.1. number i can not get to the median number, return -1\\n        if (distance % x) {\\n            return -1\\n        }\\n        // 4.2. the operations required for number i to get to the median number\\n        ans += (distance / x)\\n    }\\n    return ans\\n};\\n```\\n**Question**: In Step 3, why to find the median, and why is nums[median] the equal number for the minimum operations?\\n**Explanation**:\\nAssuming `T_i` is the mimimum operations to make all the numbers to `nums[i]`, we can know,\\n**i**. `T_i` included  **add** operations(for all the numbers on the left of `nums[i]`) and **subtract** operations(for all the numbers on the right of `nums[i]`), \\n**ii**, and to move one `nums[i]` to `nums[i+1]` required `d` operations. (`d = (nums[i+1] - nums[i])/x`)\\n**So**, we could get the operations `T_(i+1)` (the mimimum operations to make all the numbers to `nums[i+1]`) based on `T_i`:\\n**=>** `T_(i+1) = T_i   +   (i+1)* d    -  (n-i-1)*d` ,\\nbecause to make all the numbers from equal number `nums[i]` to `nums[i+1]`, all the numbers on the left of `nums[i+1]` would require more `add` operations, and on the opposite, all the numbers on the right of `nums[i+1]` including itself, would require less `subtract` operations.\\nIn details, `(i+1)* d` meant the **increased** **add** operations for all the numbers on the left side `nums[0,1,...,i]`.  **(i+1)** numbers would increase **add** operations, and each number increased **d** operations. Totally, it is `(i+1)*d `.\\nAnd `(n-i-1)*d` meant the **reduced** **subtract** operations for all the numbers on the right side including `nums[i+1]` itself, `nums[i+1, i+2, ...., n-1]` .  **(n-1 - (i+1) +1)** numbers would reduce **subtract** operations, and each number reduced **d** operations. Totally, it is `(n-i-1)*d `.\\n\\n**For example**, presuming the operations to make all the numbers to `nums[0]` is `T0`, then we can deduce the following operations `T` one by one:\\n1. to make all the numbers to `nums[1]` , `T1 = T0 + 1*d1 - (n-1)*d1` (`d1=(nums[1] - nums[0])/x`, the operations to make nums[0] to nums[1])\\n2. to make all the numbers to `nums[2]` , `T2 = T1 + 2*d2 - (n-2)*d2` (`d2=(nums[2] - nums[1])/x`)\\n3. ....\\n4. to make all the numbers to `nums[i]` , `Ti = T_(i-1) + i*d_i - (n-i)*d_i` (`d_i=(nums[i] - nums[i-1])/x`)\\n5. ...\\n6. to make all the numbers to `nums[n-1]` , `T(n-1) = T_(n-2) + (n-1)*d_(n-1) - 1*d_(n-1)` (`d_(n-1)=(nums[n-1] - nums[x-2])/x`)\\n\\nWhen `i < n/2`, `i*d - (n-i)*d < 0`, and `T` is descreasing. \\nAnd when `i > n/2`, `i*d - (n-i)*d > 0`, and `T` is increasing. \\nSo when `i = n/2`, `T` is the minimum. And the median is the optimal equal number.\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nvar minOperations = function(grid, x) {\\n    const nums = []\\n    for (let i=0; i< grid.length; i++) {\\n        for (let j=0; j< grid[0].length; j++) {\\n            nums.push(grid[i][j])\\n        }\\n    }\\n    \\n    // 1. only one single number, return directly\\n    if (nums.length < 2) {\\n        return 0\\n    }\\n    \\n    // 2. sorting all grid numbers in One - Dimension array\\n    nums.sort((a, b) => a -b) \\n    \\n    // 3. find the median, which is the final target equal number index\\n\\tconst n = nums.length\\n    const median = parseInt(n/2) \\n    \\n    // 4. calculate the times of add and subtract\\n    let ans = 0\\n    for (let i=0; i< n; i++) {\\n        const distance = Math.abs(nums[i] - nums[median])\\n        // 4.1. number i can not get to the median number, return -1\\n        if (distance % x) {\\n            return -1\\n        }\\n        // 4.2. the operations required for number i to get to the median number\\n        ans += (distance / x)\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1513354,
                "title": "straight-forward-python-two-pointers-without-making-median",
                "content": "Example:\\n[2, 4, 6, 8]\\n[2, 4, 6, 6]\\n[2, 4, 6, 6]\\n[4, 4, 6, 6]\\n[4, 4, 6, 6]\\n[4, 4, 4, 6]\\n[4 ,4, 4, 4]\\n\\nUse two pointers i, j = 0, len(l) -1\\n1.For each iteration, add or substract x into all numbers before l[i] or after l[j] untill l[i] == l[j],\\n2. if l[i] == l[i +1] or l[j] == l[j -1], move i or j util i == j\\n3. Select the less cost to move between i and j\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n    \\n        l = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                l.append(grid[i][j])\\n        l = sorted(l)\\n        for i in range(1, len(l)):\\n            if (l[i] - l[i -1]) % x != 0:\\n                return -1\\n        res = 0\\n\\n        i, j = 0, len(l) - 1\\n        while l[i] != l[j] or i != j:\\n            if i + 1 < len(l) - j:\\n                if l[i] == l[i + 1]:\\n                    i += 1\\n                else:\\n                    res += i + 1\\n                    l[i] =x + l[i]\\n                \\n            else:\\n                if l[j] == l[j - 1]:\\n                    j -= 1\\n                else:\\n                    l[j] =l[j] - x\\n                    res += len(l) - j\\n        return res",
                "solutionTags": [],
                "code": "Example:\\n[2, 4, 6, 8]\\n[2, 4, 6, 6]\\n[2, 4, 6, 6]\\n[4, 4, 6, 6]\\n[4, 4, 6, 6]\\n[4, 4, 4, 6]\\n[4 ,4, 4, 4]\\n\\nUse two pointers i, j = 0, len(l) -1\\n1.For each iteration, add or substract x into all numbers before l[i] or after l[j] untill l[i] == l[j],\\n2. if l[i] == l[i +1] or l[j] == l[j -1], move i or j util i == j\\n3. Select the less cost to move between i and j\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n    \\n        l = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[i])):\\n                l.append(grid[i][j])\\n        l = sorted(l)\\n        for i in range(1, len(l)):\\n            if (l[i] - l[i -1]) % x != 0:\\n                return -1\\n        res = 0\\n\\n        i, j = 0, len(l) - 1\\n        while l[i] != l[j] or i != j:\\n            if i + 1 < len(l) - j:\\n                if l[i] == l[i + 1]:\\n                    i += 1\\n                else:\\n                    res += i + 1\\n                    l[i] =x + l[i]\\n                \\n            else:\\n                if l[j] == l[j - 1]:\\n                    j -= 1\\n                else:\\n                    l[j] =l[j] - x\\n                    res += len(l) - j\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1513347,
                "title": "c-solution-using-sorting-and-medien",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size(), m = grid[0].size(), mod = grid[0][0] % x;\\n        vector<int> v;\\n        for (auto &row : grid)\\n            for (int cell : row) {\\n                if (cell % x != mod)\\n\\t\\t\\t\\t{\\n                    return -1;\\n\\t\\t\\t\\t}\\n                v.push_back(cell / x);\\n            }\\n        sort(v.begin(), v.end());\\n        int mid = n * m / 2;\\n        int result= 0;\\n        for (int vi : v)\\n\\t\\t{\\n            result += abs(vi - v[mid]);\\n\\t\\t}\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size(), m = grid[0].size(), mod = grid[0][0] % x;\\n        vector<int> v;\\n        for (auto &row : grid)\\n            for (int cell : row) {\\n                if (cell % x != mod)\\n\\t\\t\\t\\t{\\n                    return -1;\\n\\t\\t\\t\\t}\\n                v.push_back(cell / x);\\n            }\\n        sort(v.begin(), v.end());\\n        int mid = n * m / 2;\\n        int result= 0;\\n        for (int vi : v)\\n\\t\\t{\\n            result += abs(vi - v[mid]);\\n\\t\\t}\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513318,
                "title": "c",
                "content": "```\\nint minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        if(n==1 && m==1)\\n            return 0;\\n        \\n        vector<int> v;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int target=v[v.size()/2];\\n        int count=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==target)\\n                    continue;               \\n                int rem=abs(target-grid[i][j]);\\n                if(rem%x != 0)\\n                    return -1;                \\n                rem=rem/x;                \\n                count+=(rem==0 ? 1 : rem);\\n               \\n            }\\n        }\\n        \\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        if(n==1 && m==1)\\n            return 0;\\n        \\n        vector<int> v;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int target=v[v.size()/2];\\n        int count=0;\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]==target)\\n                    continue;               \\n                int rem=abs(target-grid[i][j]);\\n                if(rem%x != 0)\\n                    return -1;                \\n                rem=rem/x;                \\n                count+=(rem==0 ? 1 : rem);\\n               \\n            }\\n        }\\n        \\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2059212,
                "title": "c-median-well-commented-solution",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    /* concept: we should convert all the no.s to the median of all numbers in sorted order\\n    bcos it will give the least no. of operations\\n    */\\n    bool isPossible(vector<vector<int>> &grid,int x){\\n        \\n        int mod = grid[0][0] % x;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[0].size();j++){\\n                \\n                if(grid[i][j] % x != mod)\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        //if remainder of all numbers are not same, then it is not possible \\n        if(isPossible(grid,x)==false)\\n            return -1;\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        //make a vector to store all the elements of grid\\n        vector<int> arr;\\n        \\n        for(int i=0;i<row;i++){\\n            \\n            for(int j=0;j<col;j++){\\n                \\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        //sort the array now\\n        sort(arr.begin(),arr.end());\\n        \\n        int n=arr.size();\\n        int ans=0; \\n        \\n        //if array is odd, single median is present\\n        if(n%2 == 1){\\n            \\n            int median=arr[n/2];\\n            for(int i=0;i<n;i++){ //iterate through array\\n                \\n                ans += abs(arr[i]-median)/x; //cal no. of operations\\n              \\n            }\\n        }\\n        \\n        //else,array is even, two medians\\n        else{\\n            int median1=arr[n/2];\\n            int median2=arr[n/2 - 1];\\n            \\n            int ans1=0,ans2=0;\\n            \\n            for(int i=0;i<n;i++){\\n                ans1 += abs(arr[i]-median1)/x;\\n            }\\n            \\n            for(int i=0;i<n;i++){\\n                ans2 += abs(arr[i]-median2)/x;\\n            }\\n            \\n            //take best of two i.e minimum of two\\n            ans = min(ans1,ans2);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Do Upvote, if you find this helpful!!**\\nHappy coding!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    /* concept: we should convert all the no.s to the median of all numbers in sorted order\\n    bcos it will give the least no. of operations\\n    */\\n    bool isPossible(vector<vector<int>> &grid,int x){\\n        \\n        int mod = grid[0][0] % x;\\n        \\n        for(int i=0;i<grid.size();i++){\\n            \\n            for(int j=0;j<grid[0].size();j++){\\n                \\n                if(grid[i][j] % x != mod)\\n                    return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n    \\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        //if remainder of all numbers are not same, then it is not possible \\n        if(isPossible(grid,x)==false)\\n            return -1;\\n        \\n        int row=grid.size();\\n        int col=grid[0].size();\\n        \\n        //make a vector to store all the elements of grid\\n        vector<int> arr;\\n        \\n        for(int i=0;i<row;i++){\\n            \\n            for(int j=0;j<col;j++){\\n                \\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        //sort the array now\\n        sort(arr.begin(),arr.end());\\n        \\n        int n=arr.size();\\n        int ans=0; \\n        \\n        //if array is odd, single median is present\\n        if(n%2 == 1){\\n            \\n            int median=arr[n/2];\\n            for(int i=0;i<n;i++){ //iterate through array\\n                \\n                ans += abs(arr[i]-median)/x; //cal no. of operations\\n              \\n            }\\n        }\\n        \\n        //else,array is even, two medians\\n        else{\\n            int median1=arr[n/2];\\n            int median2=arr[n/2 - 1];\\n            \\n            int ans1=0,ans2=0;\\n            \\n            for(int i=0;i<n;i++){\\n                ans1 += abs(arr[i]-median1)/x;\\n            }\\n            \\n            for(int i=0;i<n;i++){\\n                ans2 += abs(arr[i]-median2)/x;\\n            }\\n            \\n            //take best of two i.e minimum of two\\n            ans = min(ans1,ans2);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785741,
                "title": "python3-why-median-is-optimal-detailed-explanation",
                "content": "So I have seen a few posts showing the code but none of them go to the mathematical detail of this problem.\\nHere\\'s my attempt at explaining this problem and how the solution is derived.\\n\\nPoints to note:\\n1. We dont really care about the matrix itself. We just want the values, so we can just safely ignore the matrix and **treat it like an array**.\\n2. We can do **as many operations** as we want with x as increment/decrement (hypothetically).\\n\\nPoint 2 helps prove an important concept.\\nIf we can do infinte operations on any number with x, we should get **all the possible numbers in the matrix**. Think on it :)\\nIf we dont get all the possible numbers, that means the **solution doesnt exist**\\n\\nHence, this helps us derive this,\\nlet A, B be any numbers in the matrix.\\n**(A-B) % x == 0**\\n\\nNow we just have to optimize the value to be subtracted from each number.\\nThe simplest way of doing that is **sorting the array** (converted from the matrix) and **finding the middle value**.\\nThe middle value will be **equidistant** from the start and end and this will help minimize the operations.\\nAs we do not **overcompensate** in addition as well as the subtraction aspect.\\n\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        li = []\\n        \\n        # convert matrix to array, we dont care about the structure itself. We just want the values\\n        for val in grid:\\n            li+= val\\n        \\n        # sort the array\\n        li.sort()\\n        \\n        # get the middle value, which is equidistant from both sides\\n        median = li[len(li)//2]\\n        ops = 0\\n        \\n        # run the loop over all the elements to calculate the number of operations needed\\n        for val in li:\\n            \\n            # this is the condtion which determines if our number can reach the other number with adding/subtracting k\\n            if abs(val-median)%x != 0:\\n                return -1\\n            ops += abs(val-median)//x\\n        return ops\\n```\\n\\nResults:\\n![image](https://assets.leetcode.com/users/images/93396171-84a3-47f5-be4d-c5adf50989ea_1645344650.5302854.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        li = []\\n        \\n        # convert matrix to array, we dont care about the structure itself. We just want the values\\n        for val in grid:\\n            li+= val\\n        \\n        # sort the array\\n        li.sort()\\n        \\n        # get the middle value, which is equidistant from both sides\\n        median = li[len(li)//2]\\n        ops = 0\\n        \\n        # run the loop over all the elements to calculate the number of operations needed\\n        for val in li:\\n            \\n            # this is the condtion which determines if our number can reach the other number with adding/subtracting k\\n            if abs(val-median)%x != 0:\\n                return -1\\n            ops += abs(val-median)//x\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217492,
                "title": "java-easy-explainable-solution-o-m-n-log-m-n-similar",
                "content": "```\\n/**\\n * simply if +X or -X makes array equal then,\\n * all elements should be modulo of X.\\n *\\n * so, now question becomes similar to:\\n * minimum-moves-to-equal-array-elements-ii: ( https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ )\\n * \\n * hence, find median of array and then subtract from each element.\\n *  NOTE: First go through given similar questions, then you can easily solve this problem`.\\n */\\n```\\n**Similar Question:**\\n1. https://leetcode.com/problems/minimum-moves-to-equal-array-elements/\\n2. https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\\n\\n**tc: / sc: `O(m*n*log(m*n)) / O(m*n)`**\\n```\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length, n = grid[0].length, k = 0, count = 0;\\n        int[] arr = new int[m*n];\\n\\n        for(int[] i : grid) {\\n            for(int j : i) {\\n                arr[k++] = j;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        for(int i : arr) {\\n            if((i - arr[k/2]) % x != 0) return -1;\\n\\n            count += Math.abs(i - arr[k/2]) / x;\\n        }\\n\\n        return count;\\n    }\\n```\\n**Upvote^, If you liked it!**\\n*Comment down, If you have any doubt.*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * simply if +X or -X makes array equal then,\\n * all elements should be modulo of X.\\n *\\n * so, now question becomes similar to:\\n * minimum-moves-to-equal-array-elements-ii: ( https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ )\\n * \\n * hence, find median of array and then subtract from each element.\\n *  NOTE: First go through given similar questions, then you can easily solve this problem`.\\n */\\n```\n```\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length, n = grid[0].length, k = 0, count = 0;\\n        int[] arr = new int[m*n];\\n\\n        for(int[] i : grid) {\\n            for(int j : i) {\\n                arr[k++] = j;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        for(int i : arr) {\\n            if((i - arr[k/2]) % x != 0) return -1;\\n\\n            count += Math.abs(i - arr[k/2]) / x;\\n        }\\n\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1687039,
                "title": "2033-minimum-operations-to-make-a-uni-value-grid-c-make-equal-to-median-element",
                "content": "Idea : Collect and Sort grid elements. Take the median value for minimum operation. Try to make every element equal to median element using the given operation. \\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> nums;\\n        for(auto& i : grid) for(auto& j : i) nums.push_back(j);\\n        sort(begin(nums), end(nums));\\n        int median = nums[(n * m) / 2];\\n        int cost = 0;\\n        for(auto& i : nums){\\n            int d = abs(i - median);\\n            if(d % x) return -1;\\n            cost += d / x;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size(), m = grid[0].size();\\n        vector<int> nums;\\n        for(auto& i : grid) for(auto& j : i) nums.push_back(j);\\n        sort(begin(nums), end(nums));\\n        int median = nums[(n * m) / 2];\\n        int cost = 0;\\n        for(auto& i : nums){\\n            int d = abs(i - median);\\n            if(d % x) return -1;\\n            cost += d / x;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1521070,
                "title": "greedy-math-solution-in-c",
                "content": "According to the initial observation, it\\'s impossible to get an answer if the difference between two consecutive elements of a sorted grid-array is not divisible by *x*.\\n\\nWe can eliminate *x* using little math (Don\\'t worry at the end you will understand why need to do that):\\nIf we have input *grid* = [[4, 6, 8, 14, 22, 24]] and *x* = 2, then we can decrease every element of the the array by the minimum element and difference between each element will be preserved, so our input will be transformed into this:\\n[[0, 2, 4, 10, 18, 20]].\\nIn order to eliminate *x* (Don\\'t worry I will explain why do we need the elimination of *x*) we will add *x* to each element and then divide by *x*:\\n[[1, 2, 3, 6, 10, 11]]\\nAfter the elimination in the resulted array difference between each consecutive element is the number of required steps for making any 2 consecutive elements equal to each other.\\n\\nNow in the array of [[1, 2, 3, 6, 10, 11]] we can choose the solution greedily:\\nif we want to make each element to equal to the first element we have to decrease each element of the array by particular amount:\\n[[1, 2, 3, 6, 10, 11]] - [[0, 1, 2, 5, 9, 10]]  =  [[1, 1, 1, 1, 1, 1]]\\n\\nwe can observe further and do the same for other elements:\\n[[1, 2, 3, 6, 10, 11]] + [[0, -1, -2, -5, -9, -10]]  =  [[1, 1, 1, 1, 1, 1]] steps reqiured: 1+2+5+9+10=**27** (**diff** = 1)\\n[[1, 2, 3, 6, 10, 11]] + [[1,  0, -1, -4, -8, -9]]  =  [[2, 2, 2, 2, 2, 2]] **sum of elements before zero**: 1, **sum of elements after zero**: 1+4+8+9=22, steps required 1+22=**23** (**diff** =2 -1 = 1)\\n[[1, 2, 3, 6, 10, 11]] + [[2,  1,  0, -3, -7, -8]]  =  [[3, 3, 3, 3, 3, 3]] **sum of elements before zero**: 2+1=3, **sum of elements after zero**: 3+7+8=18, steps required 3+18=**21** (**diff**=3-2=1)\\n[[1, 2, 3, 6, 10, 11]] + [[5,  4,  3,  0, -4, -5]]  =  [[6, 6, 6, 6, 6, 6]] **sum of elements before zero**: 5+4+3=12, **sum of elements after zero**: 4+5=9, steps required 12+9=**23** (**diff**=6-3=3)\\n[[1, 2, 3, 6, 10, 11]] + [[9,  8,  7,  4,   0, -1]]  =  [[10, 10, 10, 10, 10, 10]] **sum of elements before zero**: 9+8+7+4=28, **sum of elements after zero**: 1, steps required **29** (**diff**=10-6=4)\\n[[1, 2, 3, 6, 10, 11]] + [[10, 9, 8,  5,  1,  0]]  =  [[11, 11, 11, 11, 11, 11]] steps reqiured: 10+9+8+5+1=**33** (**diff**=11-10=1)\\n\\nAt each iteration we can see that:\\n1. **sum of elements before zero** increases by product of **number of elements before zero** and **difference between current and previous element (a.k.a. diff)**\\n2. **sum of elements after zero** decreases by product of **number of elements including and after zero** and **difference between current and previous element (a.k.a. diff)**\\n\\nthe answer will be the minimum among the steps required.\\n\\nsolution was not easy to explain so I guess It would be more effective if you look at the code :D \\n\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> elems;\\n        \\n        // just pushing every element into elems\\n        for(auto row : grid){\\n            for(auto elem : row){\\n                elems.push_back(elem);\\n            }\\n        }\\n        \\n        sort(elems.begin(), elems.end());\\n        \\n        int n = elems.size();\\n        \\n        for(int i = 1; i < n; i++){\\n            // if the difference between two consecutive elements of a sorted grid-array is not divisible by x\\n            if((elems[i] - elems[i - 1]) % x != 0)\\n                return -1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        // transforming the grid-array\\n        for(int i = n - 1; i >= 0; i--){\\n            elems[i] = (elems[i] - elems[0] + x) / x;\\n            ans += elems[i];\\n        }\\n        \\n        \\n        int l_sum = 0; // sum of elements before zero\\n        int r_sum = ans; // sum of elements after zero, initially it is sum of all elements but it will be fixed :D\\n        int l_num = 0; // number of elements before zero\\n        int r_num = 0; // number of elements after zero\\n        int curr_num = 0; // frequency of current number in the elems array\\n        int prev = 0; // previous distinct element\\n        \\n        // note: at each iteration i is increased by frequency of current number in the elems array\\n        for(int i = 0; i < n; i += curr_num){ \\n            int current = elems[i]; // current and distinct element\\n            int diff = current - prev; // difference between current and previous distinct element\\n\\n            curr_num = 0;\\n\\n            // calculation of frequency of current number in the elems array\\n            for(int j = i; j < n && elems[j] == current; j++)\\n                curr_num++;\\n\\n            // calculating the number of elements after zero\\n            r_num = n - l_num - curr_num;\\n\\n            // sum of elements before zero increases by product of number of elements before zero and difference between current and previous element (a.k.a. diff)\\n            l_sum += l_num * diff;\\n            \\n            // sum of elements after zero decreases by product of number of elements including and after zero and difference between current and previous element (a.k.a. diff)\\n            r_sum -= (r_num + curr_num) * diff;\\n            \\n            // calculation the answer\\n            ans = min(ans, l_sum + r_sum);\\n\\n            // calculating the number of elements before zero\\n            l_num += curr_num;\\n            prev = current;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> elems;\\n        \\n        // just pushing every element into elems\\n        for(auto row : grid){\\n            for(auto elem : row){\\n                elems.push_back(elem);\\n            }\\n        }\\n        \\n        sort(elems.begin(), elems.end());\\n        \\n        int n = elems.size();\\n        \\n        for(int i = 1; i < n; i++){\\n            // if the difference between two consecutive elements of a sorted grid-array is not divisible by x\\n            if((elems[i] - elems[i - 1]) % x != 0)\\n                return -1;\\n        }\\n        \\n        int ans = 0;\\n        \\n        // transforming the grid-array\\n        for(int i = n - 1; i >= 0; i--){\\n            elems[i] = (elems[i] - elems[0] + x) / x;\\n            ans += elems[i];\\n        }\\n        \\n        \\n        int l_sum = 0; // sum of elements before zero\\n        int r_sum = ans; // sum of elements after zero, initially it is sum of all elements but it will be fixed :D\\n        int l_num = 0; // number of elements before zero\\n        int r_num = 0; // number of elements after zero\\n        int curr_num = 0; // frequency of current number in the elems array\\n        int prev = 0; // previous distinct element\\n        \\n        // note: at each iteration i is increased by frequency of current number in the elems array\\n        for(int i = 0; i < n; i += curr_num){ \\n            int current = elems[i]; // current and distinct element\\n            int diff = current - prev; // difference between current and previous distinct element\\n\\n            curr_num = 0;\\n\\n            // calculation of frequency of current number in the elems array\\n            for(int j = i; j < n && elems[j] == current; j++)\\n                curr_num++;\\n\\n            // calculating the number of elements after zero\\n            r_num = n - l_num - curr_num;\\n\\n            // sum of elements before zero increases by product of number of elements before zero and difference between current and previous element (a.k.a. diff)\\n            l_sum += l_num * diff;\\n            \\n            // sum of elements after zero decreases by product of number of elements including and after zero and difference between current and previous element (a.k.a. diff)\\n            r_sum -= (r_num + curr_num) * diff;\\n            \\n            // calculation the answer\\n            ans = min(ans, l_sum + r_sum);\\n\\n            // calculating the number of elements before zero\\n            l_num += curr_num;\\n            prev = current;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520398,
                "title": "c-meet-in-the-middle",
                "content": "****C++****\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> v;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        } \\n            sort(v.begin(),v.end());\\n            int mid = (m * n)/2;\\n            int ans = 0;\\n            for(int i = 0; i < v.size(); i++){\\n                if(abs(v[mid] - v[i])%x == 0) ans+= (abs(v[mid] - v[i])/x);\\n                else return -1;\\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<int> v;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n ; j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        } \\n            sort(v.begin(),v.end());\\n            int mid = (m * n)/2;\\n            int ans = 0;\\n            for(int i = 0; i < v.size(); i++){\\n                if(abs(v[mid] - v[i])%x == 0) ans+= (abs(v[mid] - v[i])/x);\\n                else return -1;\\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514968,
                "title": "c-2033-minimum-operations-to-make-a-uni-value-grid",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> vals; \\n        for (auto& row : grid)\\n            for (auto& x : row)\\n                vals.push_back(x); \\n        \\n        for (auto& v : vals)\\n            if ((v - vals[0]) % x) return -1; \\n        \\n        sort(vals.begin(), vals.end()); \\n        int ans = 0, median = vals[vals.size()/2]; \\n        for (auto& v : vals) ans += abs(v - median)/x; \\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> vals; \\n        for (auto& row : grid)\\n            for (auto& x : row)\\n                vals.push_back(x); \\n        \\n        for (auto& v : vals)\\n            if ((v - vals[0]) % x) return -1; \\n        \\n        sort(vals.begin(), vals.end()); \\n        int ans = 0, median = vals[vals.size()/2]; \\n        for (auto& v : vals) ans += abs(v - median)/x; \\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514642,
                "title": "try-to-prove-why-only-check-median",
                "content": "I think median is quite intuitive when we try to find the min distance between all elements, isn\\'t it?\\n```\\nmin of (|x-1| + |x-2| + |x-3| + |x-4| + |x-5|), the answer x is definitely median.\\n```\\n\\nBut I can not understand why we only need to check median in this problem.\\n\\nSo, let\\'s try to think in this way.\\n**If median is not the answer, is there any other answer, say y, that fit the answer?**\\n\\nTo make the notation easy, let\\'s flatten the grid to an array arr.\\nAnd assume this arr only has 3 elements (just for simplification).\\n\\n```cpp\\nint p = arr[0];\\nint q = arr[1];\\nint r = arr[2];\\n```\\n\\nNow lets assume there is an answer y, such that\\n\\n```cpp\\ny = ax+p;\\ny = bx+q;\\ny = cx+r;\\n```\\n\\nand a, b, c are all integers.\\n\\nTo make the first equation valid, with some math\\n\\n```cpp\\n(y-p)/x=a, a is int,\\ny/x - p/x = a, a is int.\\nThus,\\n(y%x - p%x) equals to 0. \\nThus,\\ny%x == p%x\\n```\\n\\nSimilarly, we can have\\n```\\ny%x == p%x == q%x == r%x\\n```\\n\\nTherefore, the answer is valid only **when p, q, r has same residue when divided by x.** And also, **we need to find a y such that y%x also has the same residue with all other numbers in the arr!**\\n\\nSince y%x == p%x (also q%x, r%x and arr[i]%x), \\nwhy not just pick a number from the arr?\\nAnd the number is definitely the median. \\nIf median fails to be the answer, there is no answer.\\n\\n\\nFinally, the code in C++\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        int m = grid.size();\\n        int n = grid.at(0).size();\\n        int res = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++) {\\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int med = arr[arr.size()/2];\\n        for(int n : arr){\\n            int v = abs(n-med);\\n            if(v%x!=0) return -1;\\n            res+=(v/x);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nPlease up votes if you find this helpful. And also leave comments if any suggestion. \\uD83D\\uDE01",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nmin of (|x-1| + |x-2| + |x-3| + |x-4| + |x-5|), the answer x is definitely median.\\n```\n```cpp\\nint p = arr[0];\\nint q = arr[1];\\nint r = arr[2];\\n```\n```cpp\\ny = ax+p;\\ny = bx+q;\\ny = cx+r;\\n```\n```cpp\\n(y-p)/x=a, a is int,\\ny/x - p/x = a, a is int.\\nThus,\\n(y%x - p%x) equals to 0. \\nThus,\\ny%x == p%x\\n```\n```\\ny%x == p%x == q%x == r%x\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        int m = grid.size();\\n        int n = grid.at(0).size();\\n        int res = 0;\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++) {\\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int med = arr[arr.size()/2];\\n        for(int n : arr){\\n            int v = abs(n-med);\\n            if(v%x!=0) return -1;\\n            res+=(v/x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514106,
                "title": "make-all-median",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int row=grid.size(),col=grid[0].size(),i,j;\\n        vector<int> nums;\\n        for(i=0;i<row;i++)\\n        {\\n            for(j=0;j<col;j++)\\n            {\\n                nums.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        int sz=nums.size(),target=1,res=0;\\n        target=nums[sz/2];\\n        for(i=0;i<sz;i++)\\n        {\\n            if((abs(target-nums[i]))%x!=0)\\n                return -1;\\n            else\\n                res+=(abs(target-nums[i]))/x;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int row=grid.size(),col=grid[0].size(),i,j;\\n        vector<int> nums;\\n        for(i=0;i<row;i++)\\n        {\\n            for(j=0;j<col;j++)\\n            {\\n                nums.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1513827,
                "title": "c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<vector<int>> &grid, int x)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<int> arr(n * m, 0);\\n        int mod = grid[0][0] % x;\\n\\n        // if it is -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                arr[i * m + j] = grid[i][j];\\n\\n                if (grid[i][j] % x != mod)\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        sort(arr.begin(), arr.end());\\n        int cont_1 = arr[(n * m) / 2];\\n\\n        int min_1 = 0;\\n        for (int i = 0; i < m * n; i++)\\n        {\\n            min_1 += abs(arr[i] - cont_1) / x;\\n        }\\n\\n        if ((n * m) % 2 == 0)\\n        {\\n            int cont_2 = arr[((n * m) / 2) - 1];\\n            int min_2 = 0;\\n            for (int i = 0; i < n * m; i++)\\n            {\\n                min_2 += abs(arr[i] - cont_2) / x;\\n            }\\n\\n            min_1 = min(min_1, min_2);\\n        }\\n\\n        return min_1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int minOperations(vector<vector<int>> &grid, int x)\\n    {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<int> arr(n * m, 0);\\n        int mod = grid[0][0] % x;\\n\\n        // if it is -1;\\n        for (int i = 0; i < n; i++)\\n        {\\n            for (int j = 0; j < m; j++)\\n            {\\n                arr[i * m + j] = grid[i][j];\\n\\n                if (grid[i][j] % x != mod)\\n                {\\n                    return -1;\\n                }\\n            }\\n        }\\n\\n        sort(arr.begin(), arr.end());\\n        int cont_1 = arr[(n * m) / 2];\\n\\n        int min_1 = 0;\\n        for (int i = 0; i < m * n; i++)\\n        {\\n            min_1 += abs(arr[i] - cont_1) / x;\\n        }\\n\\n        if ((n * m) % 2 == 0)\\n        {\\n            int cont_2 = arr[((n * m) / 2) - 1];\\n            int min_2 = 0;\\n            for (int i = 0; i < n * m; i++)\\n            {\\n                min_2 += abs(arr[i] - cont_2) / x;\\n            }\\n\\n            min_1 = min(min_1, min_2);\\n        }\\n\\n        return min_1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513520,
                "title": "c-finding-the-median",
                "content": "This problem can be simply solved by finding the median element. It will give the minimum operations to make every cell equal value as to reach the mid the element from both sides takes minimum steps. To Do so convert the 2D array into 1D and sort it to find mid element and to count the number of operations which are the minimum possible operations\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& v1, int x) {\\n        vector<int>v;\\n        for(int i = 0; i<v1.size()*v1[0].size(); i++){\\n            v.push_back(v1[i/v1[0].size()][i%v1[0].size()]);\\n        }\\n        sort(v.begin(), v.end());\\n        if(v.size()%2==0){\\n            int d = (v.size())/2;\\n            int e = d-1;\\n            int val = v[d], val1 = v[e];\\n            int count = 0, count1 = 0;\\n            for(int i = 0; i<v.size(); i++){\\n                int val2 = abs(val-v[i]);\\n                if(val2%x!=0){return -1;}\\n                else{count+=val2/x;}\\n        }\\n            for(int i = 0; i<v.size(); i++){\\n                int val2 = abs(val1-v[i]);\\n                if(val2%x!=0){return -1;}\\n                else{count1+=val2/x;}\\n        }\\n           return(min(count, count1));\\n        }\\n        int d = (v.size())/2;\\n        int count = 0;\\n        int val = v[d];\\n        for(int i = 0; i<v.size(); i++){\\n            if(i!=d){\\n                int val1 = abs(val-v[i]);\\n                if(val1%x!=0){return -1;}\\n                else{count+=val1/x;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& v1, int x) {\\n        vector<int>v;\\n        for(int i = 0; i<v1.size()*v1[0].size(); i++){\\n            v.push_back(v1[i/v1[0].size()][i%v1[0].size()]);\\n        }\\n        sort(v.begin(), v.end());\\n        if(v.size()%2==0){\\n            int d = (v.size())/2;\\n            int e = d-1;\\n            int val = v[d], val1 = v[e];\\n            int count = 0, count1 = 0;\\n            for(int i = 0; i<v.size(); i++){\\n                int val2 = abs(val-v[i]);\\n                if(val2%x!=0){return -1;}\\n                else{count+=val2/x;}\\n        }\\n            for(int i = 0; i<v.size(); i++){\\n                int val2 = abs(val1-v[i]);\\n                if(val2%x!=0){return -1;}\\n                else{count1+=val2/x;}\\n        }\\n           return(min(count, count1));\\n        }\\n        int d = (v.size())/2;\\n        int count = 0;\\n        int val = v[d];\\n        for(int i = 0; i<v.size(); i++){\\n            if(i!=d){\\n                int val1 = abs(val-v[i]);\\n                if(val1%x!=0){return -1;}\\n                else{count+=val1/x;}\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513433,
                "title": "java-convert-to-single-array-and-sort-median",
                "content": "Create a unified array and then sort it. and then find the difference with each element and middle element.\\n\\nreaching to somewhere middle from both end would be optimal.\\nex:\\n1,2,3,4,5,6,7,8,9\\n1,1,1,8\\n1,8,8,8\\n\\nfor all extreme cases median works fine.\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n\\n        int[] newArr = new int[grid.length * grid[0].length];\\n\\n        int k=0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                newArr[k++] = grid[i][j];\\n            }\\n        }\\n\\n        Arrays.sort(newArr);\\n\\n        int middle = newArr.length / 2;\\n        int count = 0;\\n        for(int i=0; i<newArr.length; i++) {\\n            int diff = Math.abs(newArr[middle] - newArr[i]);\\n            if(diff % x != 0) {\\n                return -1;\\n            }\\n            count += diff/x;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n\\n        int[] newArr = new int[grid.length * grid[0].length];\\n\\n        int k=0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) {\\n                newArr[k++] = grid[i][j];\\n            }\\n        }\\n\\n        Arrays.sort(newArr);\\n\\n        int middle = newArr.length / 2;\\n        int count = 0;\\n        for(int i=0; i<newArr.length; i++) {\\n            int diff = Math.abs(newArr[middle] - newArr[i]);\\n            if(diff % x != 0) {\\n                return -1;\\n            }\\n            count += diff/x;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513410,
                "title": "java-easy-simple-mid-element-comparison",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < grid.length;i++){\\n            for(int j = 0; j<grid[i].length; j++){\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        Collections.sort(list);\\n        int size = list.size();\\n        int ops = 0;\\n        int mid = list.get(size/2);\\n        for(int i : list){\\n            if(((mid - i) % x) != 0){\\n                return -1;\\n            } \\n            else{\\n                ops += Math.abs((mid - i)/x);\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        for(int i = 0; i < grid.length;i++){\\n            for(int j = 0; j<grid[i].length; j++){\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        Collections.sort(list);\\n        int size = list.size();\\n        int ops = 0;\\n        int mid = list.get(size/2);\\n        for(int i : list){\\n            if(((mid - i) % x) != 0){\\n                return -1;\\n            } \\n            else{\\n                ops += Math.abs((mid - i)/x);\\n            }\\n        }\\n        return ops;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513305,
                "title": "median-python-simple-approach-explanation-with-comments",
                "content": "**Description**\\nThe idea if to find the median of all the numbers and try to convert all numbers to that value. The only possible scenario, we need to handle in that case if we can\\'t convert any given number to median, then we return -1 in that case\\n\\n**Code**\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        # flatten the numbers\\n        nums = []\\n        for row in grid:\\n            for num in row:\\n                nums.append(num)\\n        \\n        # sort and find the median\\n        nums.sort()\\n        n = len(nums)\\n        median = nums[n//2]\\n        \\n        # calculate the number of operations required\\n        operations = 0\\n        for num in nums:\\n            diff = abs(median-num)\\n            if diff%x !=0:\\n                return -1\\n            operations += diff//x\\n        \\n        return operations\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        \\n        # flatten the numbers\\n        nums = []\\n        for row in grid:\\n            for num in row:\\n                nums.append(num)\\n        \\n        # sort and find the median\\n        nums.sort()\\n        n = len(nums)\\n        median = nums[n//2]\\n        \\n        # calculate the number of operations required\\n        operations = 0\\n        for num in nums:\\n            diff = abs(median-num)\\n            if diff%x !=0:\\n                return -1\\n            operations += diff//x\\n        \\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652526,
                "title": "c-python-sorting",
                "content": "# C++\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) v.push_back(grid[i][j]);\\n        }\\n        sort(v.begin(), v.end());\\n        int m = v[v.size() / 2], ans = 0;\\n\\n        for(int i : v) {\\n            if(abs(i - m) % x) return -1;\\n            ans += abs(i - m);\\n        }\\n        return ans / x;\\n    }\\n};\\n```\\n\\n# Python\\n```\\nclass Solution(object):\\n    def minOperations(self, grid, x):\\n        v = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                v.append(grid[i][j])\\n\\n        v.sort()\\n        m, ans = v[len(v) / 2], 0\\n        for i in v:\\n            if abs(i - m) % x: return -1\\n            ans += abs(i - m)\\n        \\n        return ans / x\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++) {\\n            for(int j=0; j<grid[0].size(); j++) v.push_back(grid[i][j]);\\n        }\\n        sort(v.begin(), v.end());\\n        int m = v[v.size() / 2], ans = 0;\\n\\n        for(int i : v) {\\n            if(abs(i - m) % x) return -1;\\n            ans += abs(i - m);\\n        }\\n        return ans / x;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def minOperations(self, grid, x):\\n        v = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                v.append(grid[i][j])\\n\\n        v.sort()\\n        m, ans = v[len(v) / 2], 0\\n        for i in v:\\n            if abs(i - m) % x: return -1\\n            ans += abs(i - m)\\n        \\n        return ans / x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385361,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        for(int i=1; i<v.size(); i++){\\n            if((v[i]-v[i-1])%x!=0) return -1;\\n        }\\n        int m=v[(v.size()-1)/2];\\n        int res=0;\\n        for(int i=0; i<v.size(); i++){\\n            res+=abs(m-v[i])/x;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2165639,
                "title": "c-median-sorting-concept-explanied",
                "content": "![image](https://assets.leetcode.com/users/images/655ef447-e35a-4b91-99f2-dbfff7ea9b9c_1655547588.995467.png)\\n\\n\\t/*Concept Involved is-> Jab friends ko milna hota hai toh toh kisi aise friend ke ghar jane ki jagha we say ki let\\'s go to X\\'s friend\\'s house\\n\\t(X lives in the middle of the city) because woh X ka ghr sake ghr se paas padega so har ek individual ko comparatively kam \\n\\tdistance cover karna padega. same goes here hum aise element ko lete hai which is in maximum possible middle among all and\\n\\tthat element obvo will be the **MEDIAN** of the **SORTED ARRAY** . Hence after making the uni value grid this is the element which\\n\\twill be in each cell of the grid!!*/\\n\\t\\n\\t/* Hope I am able to explain the concept of this question. Feel free to ask your doubts in the comment section. Have a good day!*/\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<vector<int>>& g, int x) {\\n\\t\\t\\tint m=g.size();\\n\\t\\t\\tint n=g[0].size();\\n\\t\\t\\tvector<int>a;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\ta.push_back(g[i][j]);\\n\\t\\t\\t\\t\\tif(g[i][j]%x!=g[0][0]%x)return -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tsort(a.begin(),a.end());\\n\\t\\t\\tint y=a[a.size()/2];\\n\\t\\t\\tint op=0;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++) op+=(abs(g[i][j]-y)/x); \\n\\t\\t\\t}\\n\\t\\t\\treturn op;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint minOperations(vector<vector<int>>& g, int x) {\\n\\t\\t\\tint m=g.size();\\n\\t\\t\\tint n=g[0].size();\\n\\t\\t\\tvector<int>a;\\n\\t\\t\\tfor(int i=0;i<m;i++){\\n\\t\\t\\t\\tfor(int j=0;j<n;j++){\\n\\t\\t\\t\\t\\ta.push_back(g[i][j]);\\n\\t\\t\\t\\t\\tif(g[i][j]%x!=g[0][0]%x)return -1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2140543,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(auto g:grid)\\n        {\\n            for(auto x:g)\\n            {\\n                v.push_back(x);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        int value=v[n/2];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(value-v[i])%x!=0)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans+=abs(value-v[i])/x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(auto g:grid)\\n        {\\n            for(auto x:g)\\n            {\\n                v.push_back(x);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        int value=v[n/2];\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(value-v[i])%x!=0)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans+=abs(value-v[i])/x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2031302,
                "title": "easy-and-faster-solution-minimum-operations-to-make-a-uni-value-grid",
                "content": "```\\nint minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m=grid[0].size(),k=0;\\n        vector<int>v(m*n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v[k++]=grid[i][j];\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int d=(m*n)/2;\\n        double cnt=0,ans;\\n        for(int i=0;i<m*n;i++){\\n            if(v[i]!=v[d]){\\n                cnt+=(abs(v[d]-v[i])/x);\\n                if(abs(v[d]-v[i])%x!=0) return -1;\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m=grid[0].size(),k=0;\\n        vector<int>v(m*n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v[k++]=grid[i][j];\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int d=(m*n)/2;\\n        double cnt=0,ans;\\n        for(int i=0;i<m*n;i++){\\n            if(v[i]!=v[d]){\\n                cnt+=(abs(v[d]-v[i])/x);\\n                if(abs(v[d]-v[i])%x!=0) return -1;\\n            }\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1976496,
                "title": "java-find-median-comments",
                "content": "1. All numbers mod x has to be the same number because we can only adjust `+x` or `-x`.\\n2. Then we can divide x from each number just so that we can treat it as `+1` or `-1`.\\n3. Last step is to sort and find the median. \\n\\nThe reason the median works is that we can consider the biggest and smallest number in the array, the best number for these two numbers to become the same is obviously anything in between them, so then we can discard these two numbers and consider the 2nd biggest and 2nd smallest pair, so on and so forth. Eventually, the desired number is just any number between the center most 2 numbers, which median, by definition, happens to be one of them.\\n```Java\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length, n = grid[0].length, k = grid[0][0] % x;\\n        int[] arr = new int[m * n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] % x != k)\\n                    return -1;\\n                arr[i * n + j] = (grid[i][j] - k) / x;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int ans = 0, mid = arr[arr.length / 2];\\n        for (int i = 0; i < arr.length; i++){\\n            ans += Math.abs(arr[i] - mid);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length, n = grid[0].length, k = grid[0][0] % x;\\n        int[] arr = new int[m * n];\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid[i][j] % x != k)\\n                    return -1;\\n                arr[i * n + j] = (grid[i][j] - k) / x;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int ans = 0, mid = arr[arr.length / 2];\\n        for (int i = 0; i < arr.length; i++){\\n            ans += Math.abs(arr[i] - mid);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892297,
                "title": "c-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(vector<int> v1:grid){\\n            for(int i:v1) v.push_back(i);\\n        }\\n        sort(v.begin(),v.end());\\n        int i=v[v.size()/2];\\n        int ans=0;\\n        for(int j=0;j<v.size();j++){\\n            int dif=abs(v[j]-i);\\n            if(dif%x!=0) return -1;\\n            else ans+=dif/x;\\n        }\\n        return ans;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(vector<int> v1:grid){\\n            for(int i:v1) v.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1855309,
                "title": "python-and-statistics-median-low-4-lines",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums = [x for r in grid for x in r]\\n        if any((nums[0]-n)%x for n in nums): return -1\\n        ml = median_low(nums)\\n        return sum(abs(n-ml)//x for n in nums)\\n```\\n\\nhttps://docs.python.org/3/library/statistics.html#statistics.median_low\\n\\n> The low median is always a member of the data set. When the number of data points is odd, the middle value is returned. When it is even, the smaller of the two middle values is returned.",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums = [x for r in grid for x in r]\\n        if any((nums[0]-n)%x for n in nums): return -1\\n        ml = median_low(nums)\\n        return sum(abs(n-ml)//x for n in nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582367,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int data[]=new int[grid.length*grid[0].length];\\n        int k=0;\\n        for(int i[]:grid)\\n            for(int j:i)\\n                data[k++]=j;\\n        Arrays.sort(data);\\n        int m=data[data.length/2];\\n        int rem=grid[0][0]%x;\\n        int result=0;\\n        for(int i=0;i<data.length/2;i++)\\n        {\\n            if(data[i]%x!=rem)\\n                return -1;\\n            result+=(m-data[i])/x;\\n            \\n        }\\n        if(data[data.length/2]%x!=rem)\\n            return -1;\\n        for(int i=data.length-1;i>data.length/2;i--){\\n            if(data[i]%x!=rem)\\n                return -1;\\n            result+=(data[i]-m)/x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int data[]=new int[grid.length*grid[0].length];\\n        int k=0;\\n        for(int i[]:grid)\\n            for(int j:i)\\n                data[k++]=j;\\n        Arrays.sort(data);\\n        int m=data[data.length/2];\\n        int rem=grid[0][0]%x;\\n        int result=0;\\n        for(int i=0;i<data.length/2;i++)\\n        {\\n            if(data[i]%x!=rem)\\n                return -1;\\n            result+=(m-data[i])/x;\\n            \\n        }\\n        if(data[data.length/2]%x!=rem)\\n            return -1;\\n        for(int i=data.length-1;i>data.length/2;i--){\\n            if(data[i]%x!=rem)\\n                return -1;\\n            result+=(data[i]-m)/x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524932,
                "title": "c-find-the-mid-point",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int unit) {\\n        int ret = 0;\\n        vector<int> v;\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[i].size(); j++){\\n                v.emplace_back(grid[i][j]);\\n            }\\n        }\\n        if(v.size() == 1){return 0;}\\n        sort(v.begin(), v.end());\\n        int mid=v.size()/2;\\n        int sum=0;\\n        for(int i=0; i<mid; i++){\\n            if((v[mid]-v[i])%unit != 0){return -1;}\\n            sum += v[mid]-v[i];\\n        } \\n        for(int i=mid+1; i<v.size(); i++){\\n            if((v[i]-v[mid])%unit != 0){return -1;}\\n            sum += v[i]-v[mid];\\n        }\\n        ret = sum/unit;\\n        return ret; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int unit) {\\n        int ret = 0;\\n        vector<int> v;\\n        for(int i = 0; i<grid.size(); i++){\\n            for(int j = 0; j<grid[i].size(); j++){\\n                v.emplace_back(grid[i][j]);\\n            }\\n        }\\n        if(v.size() == 1){return 0;}\\n        sort(v.begin(), v.end());\\n        int mid=v.size()/2;\\n        int sum=0;\\n        for(int i=0; i<mid; i++){\\n            if((v[mid]-v[i])%unit != 0){return -1;}\\n            sum += v[mid]-v[i];\\n        } \\n        for(int i=mid+1; i<v.size(); i++){\\n            if((v[i]-v[mid])%unit != 0){return -1;}\\n            sum += v[i]-v[mid];\\n        }\\n        ret = sum/unit;\\n        return ret; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1519280,
                "title": "median-approach-c",
                "content": "```\\nint minOperations(vector<vector<int>>& grid, int y) {\\n        \\n        vector<int> a;\\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                a.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        int ans=0;\\n        \\n        int med=a[(a.size())/2];\\n        \\n        bool flag=1;\\n        for(auto x: a){\\n            \\n             if(x!=med){\\n                 \\n                 if(med>x){\\n                     int add=med - x;\\n                     if(add%y!=0){\\n                         flag=0;\\n                         break;\\n                     }\\n                     \\n                     ans+=(add/y);\\n                 }\\n                 else{\\n                     int sub = x - med;\\n                      if(sub%y!=0){\\n                         flag=0;\\n                         break;\\n                     }\\n                     \\n                     ans+=(sub/y);\\n                 }\\n             }\\n        }\\n        \\n        \\n        return flag==1 ? ans : -1; \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minOperations(vector<vector<int>>& grid, int y) {\\n        \\n        vector<int> a;\\n        \\n        \\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                a.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        \\n        sort(a.begin(),a.end());\\n        \\n        int ans=0;\\n        \\n        int med=a[(a.size())/2];\\n        \\n        bool flag=1;\\n        for(auto x: a){\\n            \\n             if(x!=med){\\n                 \\n                 if(med>x){\\n                     int add=med - x;\\n                     if(add%y!=0){\\n                         flag=0;\\n                         break;\\n                     }\\n                     \\n                     ans+=(add/y);\\n                 }\\n                 else{\\n                     int sub = x - med;\\n                      if(sub%y!=0){\\n                         flag=0;\\n                         break;\\n                     }\\n                     \\n                     ans+=(sub/y);\\n                 }\\n             }\\n        }\\n        \\n        \\n        return flag==1 ? ans : -1; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519122,
                "title": "min-moves-to-make-unigrid-c",
                "content": "https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid\\n***NOTE:\\n1 . Total moves in array with operation of (+x and -x) \\nmoves=moves+ abs(arr[i] - median) /x                                    [works for sorted array]\\n2. With operations given (+x and -x ) and check whether  we can make unique values for all or not ,\\nuse  ( grid[i][j]%x  ) \\nif gives same value for all then possible \\nelse not and return -1 according to question statement***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int> > &grid, int x)\\n    {\\n        int mod=grid[0][0]%x;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]%x!=mod)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n       int ans=0;\\n        if(! possible(grid,x)) return -1;\\n        \\n            vector<int> v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                    v.push_back(grid[i][j]);\\n                }\\n            }\\n            sort(v.begin(),v.end());\\n           int mid=v[(v.size())/2];\\n       \\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans+=abs(mid-v[i])/x;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool possible(vector<vector<int> > &grid, int x)\\n    {\\n        int mod=grid[0][0]%x;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                if(grid[i][j]%x!=mod)\\n                    return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n       int ans=0;\\n        if(! possible(grid,x)) return -1;\\n        \\n            vector<int> v;\\n            for(int i=0;i<grid.size();i++)\\n            {\\n                for(int j=0;j<grid[0].size();j++)\\n                {\\n                    v.push_back(grid[i][j]);\\n                }\\n            }\\n            sort(v.begin(),v.end());\\n           int mid=v[(v.size())/2];\\n       \\n        for(int i=0;i<v.size();i++)\\n        {\\n            ans+=abs(mid-v[i])/x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1518830,
                "title": "python-solution-sorting",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        #this problem can be solved by using sorting technique\\n        # we use median to find out the minimum operations to make all array elements equal\\n        #Median is used because it minimizes the sum of absolute deviations\\n        #it is possible to make two numbers equal if and only if their remainders are equal when they are divided by x\\n        #we will be using the above condition in our problem\\n        \\n        ar=[] # we append all the matrix values into array\\n        row=len(grid)\\n        col=len(grid[0])\\n        n=row*col # number of elements in the array\\n        for i in range(row):\\n            for j in range(col):\\n                ar.append(grid[i][j])\\n        ar.sort()  #sort the array\\n        ans=0\\n        median=ar[n//2] #this is the median value\\n        remainder=median%x #this is used to compare with all the value of the array\\n        \\n        for i in range(len(ar)):\\n            if (ar[i]%x)!=remainder:   #if the remainders are not equal we can return -1\\n                return -1\\n            ans+=abs(median-ar[i])\\n            \\n        return ans//x\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        #this problem can be solved by using sorting technique\\n        # we use median to find out the minimum operations to make all array elements equal\\n        #Median is used because it minimizes the sum of absolute deviations\\n        #it is possible to make two numbers equal if and only if their remainders are equal when they are divided by x\\n        #we will be using the above condition in our problem\\n        \\n        ar=[] # we append all the matrix values into array\\n        row=len(grid)\\n        col=len(grid[0])\\n        n=row*col # number of elements in the array\\n        for i in range(row):\\n            for j in range(col):\\n                ar.append(grid[i][j])\\n        ar.sort()  #sort the array\\n        ans=0\\n        median=ar[n//2] #this is the median value\\n        remainder=median%x #this is used to compare with all the value of the array\\n        \\n        for i in range(len(ar)):\\n            if (ar[i]%x)!=remainder:   #if the remainders are not equal we can return -1\\n                return -1\\n            ans+=abs(median-ar[i])\\n            \\n        return ans//x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516379,
                "title": "golang-median-solution",
                "content": "```go\\nfunc minOperations(grid [][]int, x int) int {\\n    mod := grid[0][0] % x\\n    divides := make([]int, 0, len(grid) * len(grid[0]))\\n    for _, row := range grid {\\n        for _, num := range row {\\n            if num % x != mod {\\n                return -1\\n            }\\n            divides = append(divides, num / x)\\n        }\\n    }\\n    sort.Ints(divides)\\n    median := divides[len(divides)/2]\\n    \\n    result := 0\\n    for _, num := range divides {\\n        result += abs(median - num)\\n    }\\n    return result \\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 {\\n        x = -x\\n    }\\n    return x \\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc minOperations(grid [][]int, x int) int {\\n    mod := grid[0][0] % x\\n    divides := make([]int, 0, len(grid) * len(grid[0]))\\n    for _, row := range grid {\\n        for _, num := range row {\\n            if num % x != mod {\\n                return -1\\n            }\\n            divides = append(divides, num / x)\\n        }\\n    }\\n    sort.Ints(divides)\\n    median := divides[len(divides)/2]\\n    \\n    result := 0\\n    for _, num := range divides {\\n        result += abs(median - num)\\n    }\\n    return result \\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 {\\n        x = -x\\n    }\\n    return x \\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1516294,
                "title": "jump-search-vs-median-solutions-in-go",
                "content": "## Jump Search\\n\\nThe basic idea of jump search is that there is a target value `t` that will make the uni-value grid in minimal number of operations: `t = m + bx` where `m` is the smallest number in the grid and `b` is unknown and between 0 and infinity.\\nWe will find the value of `b` by jumping through the possible values in steps of 100 (i.e. `m`, `m+100x`, `m+200x`, `m+300x`, ...). Assume that the function `numOps(n)` gives the total number of operations required to make all the elements to `n`. As we jump through possible values, `numOps(n)` will start decreasing linearly and then once we accidentally jumped over the correct value, `numOps(n)` will start increasing linearly. If we have the correct value, `numOps(n)` will be a local minima. Basically, we have three possible scenarios at each iteration:\\n1. Let `nj = m + cx`, `ni = m + (c-1)x` and `nk = m + (c+1)x` where `c` is the current value that we are testing in the current iteration. `numOps(nj)` is a local minima, i.e. `numOps(ni) >= numOps(nj) <= numOps(nk)` so we have found the correct value and we can just return `numOps(nj)` here.\\n2. `numOps(ni)` > `numOps(nj)` > `numOps(nk)`: we have not jumped over the correct value yet so continue iterating by jumping 100 steps.\\n3. `numOps(ni)` < `numOps(nj)` < `numOps(nk)`: we have jumped over the correct value which means that `b` is definitely between `c` and `c-100` so we will jump down 1 step each iteration until we have the correct value.\\n```\\nfunc minOperations(grid [][]int, x int) int {\\n    occurences := make(map[int]int)\\n    min := grid[0][0]\\n    for _, r := range grid {\\n        for _, e := range r {\\n            if e%x != grid[0][0] % x { return -1 }\\n            occurences[e]++\\n            if e < min { min = e }\\n        }\\n    }\\n    if len(occurences) <= 1 { return 0 }\\n\\n    for curr := min; ; {\\n        c := count(x, curr, occurences)\\n        prev := count(x, curr-x, occurences)\\n        next := count(x, curr+x, occurences)\\n        if c != 0 && prev >= c && next >= c {\\n            return c\\n        } else if next > c && c > prev {\\n            curr -= x\\n        } else {\\n            curr += 100*x\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 { return -x }\\n    return x\\n}\\n\\nfunc count(x, target int, occurrences map[int]int) int {\\n    c := 0\\n    for k, v := range occurrences {\\n        c += (abs(target-k)/x) * v\\n    }\\n    return c\\n}\\n```\\n\\n\\n## Median\\nI won\\'t go over the explanation for this since others have already explanined better than I can in the discussion.\\n```\\nimport \"sort\"\\nfunc minOperations(grid [][]int, x int) int {\\n    total := len(grid)*len(grid[0])\\n    flat := make([]int, 0, total)\\n    for _, r := range grid {\\n        for _, n := range r {\\n            if n % x != grid[0][0] % x { return -1 }\\n            flat = append(flat, n)\\n        }\\n    }\\n    sort.Ints(flat)\\n    if len(flat) <= 1 { return 0 }\\n\\n    med := len(flat)/2\\n    return min(count(x, flat[med], flat), count(x, flat[med-1], flat))\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 { return -x }\\n    return x\\n}\\n\\nfunc count(x, target int, flat []int) int {\\n    c := 0\\n    for _, n := range flat { c += abs(target-n)/x }\\n    return c\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y { return x }\\n    return y\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minOperations(grid [][]int, x int) int {\\n    occurences := make(map[int]int)\\n    min := grid[0][0]\\n    for _, r := range grid {\\n        for _, e := range r {\\n            if e%x != grid[0][0] % x { return -1 }\\n            occurences[e]++\\n            if e < min { min = e }\\n        }\\n    }\\n    if len(occurences) <= 1 { return 0 }\\n\\n    for curr := min; ; {\\n        c := count(x, curr, occurences)\\n        prev := count(x, curr-x, occurences)\\n        next := count(x, curr+x, occurences)\\n        if c != 0 && prev >= c && next >= c {\\n            return c\\n        } else if next > c && c > prev {\\n            curr -= x\\n        } else {\\n            curr += 100*x\\n        }\\n    }\\n    return 0\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 { return -x }\\n    return x\\n}\\n\\nfunc count(x, target int, occurrences map[int]int) int {\\n    c := 0\\n    for k, v := range occurrences {\\n        c += (abs(target-k)/x) * v\\n    }\\n    return c\\n}\\n```\n```\\nimport \"sort\"\\nfunc minOperations(grid [][]int, x int) int {\\n    total := len(grid)*len(grid[0])\\n    flat := make([]int, 0, total)\\n    for _, r := range grid {\\n        for _, n := range r {\\n            if n % x != grid[0][0] % x { return -1 }\\n            flat = append(flat, n)\\n        }\\n    }\\n    sort.Ints(flat)\\n    if len(flat) <= 1 { return 0 }\\n\\n    med := len(flat)/2\\n    return min(count(x, flat[med], flat), count(x, flat[med-1], flat))\\n}\\n\\nfunc abs(x int) int {\\n    if x < 0 { return -x }\\n    return x\\n}\\n\\nfunc count(x, target int, flat []int) int {\\n    c := 0\\n    for _, n := range flat { c += abs(target-n)/x }\\n    return c\\n}\\n\\nfunc min(x, y int) int {\\n    if x < y { return x }\\n    return y\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1515681,
                "title": "c-easy-to-understand-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v; int consistency=grid[0][0]%x;\\n        for(int i=0;i<grid.size();++i)\\n            for(int j=0;j<grid[0].size();++j){\\n                if(grid[i][j]%x !=consistency) return -1;\\n                v.push_back(grid[i][j]);\\n            }\\n        sort(v.begin(),v.end());\\n        int target=v[v.size()/2],count=0;\\n        for(int i=0;i<v.size();++i){\\n            count+=abs((target-v[i])/x);\\n        }\\n            return count;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v; int consistency=grid[0][0]%x;\\n        for(int i=0;i<grid.size();++i)\\n            for(int j=0;j<grid[0].size();++j){\\n                if(grid[i][j]%x !=consistency) return -1;\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1514516,
                "title": "2033-minimum-operations-to-make-a-uni-value-grid",
                "content": "---\\n\\n**Algo**:\\n\\n\\nAn example\\n\\nAssume grid is\\n\\n\\t1 2 3\\n\\t6 5 4\\n\\t7 8 9\\n\\nAccumulate all numbers into `A`\\n\\n\\tA = [ 1,2,3,6,5,4,7,8,9 ]\\n\\nNow sort `A`, it becomes\\n\\n\\tA = [ 1,2,3,4,5,6,7,8,9 ]\\n\\nNow if we make all 1 or 9\\n\\n\\t1,1,1, 1,1,1, 1,1,1\\n\\t9,9,9, 9,9,9, 9,9,9\\n\\nit will take more operations\\nthe value of x does not matter here, it will still take more operations\\n\\nBut if we make all some mid value, like 5 here\\n\\n\\t5,5,5, 5,5,5, 5,5,5\\n\\neveryone is moving only a bit 1 to 5, 9 to 5\\nthe extremes moving of 9 to 1, or 1 to 9 is not there\\nwe have less moves ( for example, when x is 1)\\n\\n\\nthe mid value is called `median` here\\nthis will be mid of `A` after sorting\\n\\n\\tA = [ 1,2,3,4,   5 *   ,6,7,8,9 ]\\n\\nIf there are two mid values, you can take any\\nbecause (all of) one of the other side will move a bit more\\ntotal will still be same\\n\\nso now we have median\\nhow much are they moving?\\n\\n\\tmedian - each element `e`\\n\\n\\t\\tOR\\n\\n\\teach element `e` - median\\n\\ndepending on which side e exists in median\\nfor example\\n\\n\\t5 (median)  - 1 (element) = 4\\n\\t9 (element) - 5 (median)  = 4\\n\\nSo use the absolute value to get +ve value, in either of above cases\\n\\nSo how much each moved?\\n\\n\\tAbs (  median - each element `e` )\\n\\nBut they can only jump `x` amounts only, and reach the `median`\\nso divide by x, to get number of moves element `e` takes\\n\\n\\tAbs (  median - each element `e` ) / x\\n\\nTotal number of moves for all `e` to get to median,\\nby jumping each time of length `x`\\n(the `ans`)\\nis\\n\\n\\t\\tSum of\\n\\t\\t\\tAbs (  median - each element `e` ) / x\\n\\t\\t\\t\\tfor all e\\n\\nThats the answer we return as `ans` \\n\\n---\\n\\nBut we assumed that each can get to median, by jumping `x` lengths\\nthat is \\n\\n\\t(  median - each element `e` ) / x   will be some integer, in that case\\n\\t\\n\\tlike\\n\\t\\n\\t\\t10/2 = 5 jumps\\n\\n\\t\\tthen all is going good\\n\\nbut if that is not possible\\n\\n\\tlike\\n\\n\\t\\t11/2 = 5.5 jumps\\n\\n\\t\\tthen we return -1\\n\\nThat early exit is, check if % is 0\\n\\n\\t\\tif ((median - e) % x)\\n            return -1;\\n\\n\\tlike\\n\\n\\t\\t10 % 2 = 0\\t ( yes jumping in 2 will reach 10 distance )\\n\\n\\t\\t11 % 2 = 0\\t ( no, jumping in 2 will reach 11 distance, so return -1 )\\n\\nHope that helps\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    var minOperations = function (grid, x) {\\n        let A = [];\\n        for (let row of grid)\\n            for (let e of row)\\n                A.push(e);\\n\\n        A.sort((a, b) => a - b);\\n\\n        let median = A[Math.trunc(A.length / 2)];\\n\\n        let ans = 0;\\n        for (let e of A) {\\n            if ((median - e) % x)\\n                return -1;\\n            ans += Math.abs((median - e) / x);\\n        }\\n        return ans;\\n    };\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\n**Algo**:\\n\\n\\nAn example\\n\\nAssume grid is\\n\\n\\t1 2 3\\n\\t6 5 4\\n\\t7 8 9\\n\\nAccumulate all numbers into `A`\\n\\n\\tA = [ 1,2,3,6,5,4,7,8,9 ]\\n\\nNow sort `A`, it becomes\\n\\n\\tA = [ 1,2,3,4,5,6,7,8,9 ]\\n\\nNow if we make all 1 or 9\\n\\n\\t1,1,1, 1,1,1, 1,1,1\\n\\t9,9,9, 9,9,9, 9,9,9\\n\\nit will take more operations\\nthe value of x does not matter here, it will still take more operations\\n\\nBut if we make all some mid value, like 5 here\\n\\n\\t5,5,5, 5,5,5, 5,5,5\\n\\neveryone is moving only a bit 1 to 5, 9 to 5\\nthe extremes moving of 9 to 1, or 1 to 9 is not there\\nwe have less moves ( for example, when x is 1)\\n\\n\\nthe mid value is called `median` here\\nthis will be mid of `A` after sorting\\n\\n\\tA = [ 1,2,3,4,   5 *   ,6,7,8,9 ]\\n\\nIf there are two mid values, you can take any\\nbecause (all of) one of the other side will move a bit more\\ntotal will still be same\\n\\nso now we have median\\nhow much are they moving?\\n\\n\\tmedian - each element `e`\\n\\n\\t\\tOR\\n\\n\\teach element `e` - median\\n\\ndepending on which side e exists in median\\nfor example\\n\\n\\t5 (median)  - 1 (element) = 4\\n\\t9 (element) - 5 (median)  = 4\\n\\nSo use the absolute value to get +ve value, in either of above cases\\n\\nSo how much each moved?\\n\\n\\tAbs (  median - each element `e` )\\n\\nBut they can only jump `x` amounts only, and reach the `median`\\nso divide by x, to get number of moves element `e` takes\\n\\n\\tAbs (  median - each element `e` ) / x\\n\\nTotal number of moves for all `e` to get to median,\\nby jumping each time of length `x`\\n(the `ans`)\\nis\\n\\n\\t\\tSum of\\n\\t\\t\\tAbs (  median - each element `e` ) / x\\n\\t\\t\\t\\tfor all e\\n\\nThats the answer we return as `ans` \\n\\n---\\n\\nBut we assumed that each can get to median, by jumping `x` lengths\\nthat is \\n\\n\\t(  median - each element `e` ) / x   will be some integer, in that case\\n\\t\\n\\tlike\\n\\t\\n\\t\\t10/2 = 5 jumps\\n\\n\\t\\tthen all is going good\\n\\nbut if that is not possible\\n\\n\\tlike\\n\\n\\t\\t11/2 = 5.5 jumps\\n\\n\\t\\tthen we return -1\\n\\nThat early exit is, check if % is 0\\n\\n\\t\\tif ((median - e) % x)\\n            return -1;\\n\\n\\tlike\\n\\n\\t\\t10 % 2 = 0\\t ( yes jumping in 2 will reach 10 distance )\\n\\n\\t\\t11 % 2 = 0\\t ( no, jumping in 2 will reach 11 distance, so return -1 )\\n\\nHope that helps\\n\\n---\\n\\nHope it is simple to understand.\\n\\n---\\n\\n    var minOperations = function (grid, x) {\\n        let A = [];\\n        for (let row of grid)\\n            for (let e of row)\\n                A.push(e);\\n\\n        A.sort((a, b) => a - b);\\n\\n        let median = A[Math.trunc(A.length / 2)];\\n\\n        let ans = 0;\\n        for (let e of A) {\\n            if ((median - e) % x)\\n                return -1;\\n            ans += Math.abs((median - e) / x);\\n        }\\n        return ans;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1514413,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int s = 0;\\n        int e = (n*m)-1;\\n        int mid = (s+e)/2;\\n        int res = 0;\\n        vector<int> eles;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                eles.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(begin(eles),end(eles));\\n        for(int i=0;i<n*m;i++){\\n            if(eles[i]%x!=eles[mid]%x) return -1;\\n            res+=abs(eles[i]-eles[mid])/x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int s = 0;\\n        int e = (n*m)-1;\\n        int mid = (s+e)/2;\\n        int res = 0;\\n        vector<int> eles;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                eles.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(begin(eles),end(eles));\\n        for(int i=0;i<n*m;i++){\\n            if(eles[i]%x!=eles[mid]%x) return -1;\\n            res+=abs(eles[i]-eles[mid])/x;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514233,
                "title": "c-time-o-n-log-n-space-o-n",
                "content": "```\\npublic class Solution {\\n    public int MinOperations(int[][] grid, int x) {\\n        List<int> list = new List<int>();\\n        for (int i = 0; i < grid.Length; i++)\\n            for (int j = 0; j < grid[0].Length; j++)\\n                list.Add(grid[i][j]);\\n        \\n        list.Sort();\\n        \\n        int mid = list[list.Count() / 2];\\n        int operations = 0;\\n        foreach (int num in list) {\\n            if (Math.Abs(num - mid) % x != 0)\\n                return -1;\\n            else\\n                operations += (Math.Abs(num - mid) / x);\\n        }\\n        \\n        return operations;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[][] grid, int x) {\\n        List<int> list = new List<int>();\\n        for (int i = 0; i < grid.Length; i++)\\n            for (int j = 0; j < grid[0].Length; j++)\\n                list.Add(grid[i][j]);\\n        \\n        list.Sort();\\n        \\n        int mid = list[list.Count() / 2];\\n        int operations = 0;\\n        foreach (int num in list) {\\n            if (Math.Abs(num - mid) % x != 0)\\n                return -1;\\n            else\\n                operations += (Math.Abs(num - mid) / x);\\n        }\\n        \\n        return operations;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1514066,
                "title": "c-after-sorting-my-idea-was-to-make-all-elements-equal-to-mid",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> dup;\\n        for(auto vec : grid)\\n        {\\n            for(int i:vec)dup.push_back(i);\\n        }\\n        sort(dup.begin(), dup.end());\\n        int ans = 0;\\n        int mid = dup.size()/2;\\n        int i = 0;\\n        int req;\\n        while(i < mid)\\n        {\\n            req = dup[mid] - dup[i];\\n            if(req % x == 0) ans += (req/x);\\n            else return -1;\\n            i++;\\n        }\\n        i++; //mid\\n        while(i < dup.size())\\n        {\\n            req = dup[i] - dup[mid];\\n            if(req % x == 0) ans += (req/x);\\n            else return -1;\\n            i++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> dup;\\n        for(auto vec : grid)\\n        {\\n            for(int i:vec)dup.push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1514029,
                "title": "c-solution-with-algorithm",
                "content": "Algorithm ->\\nstep 1- convert the 2D matrix to 1D array\\nstep 2- find the middle element in 1D array\\nstep 3- sort the array\\nstep 4- we have to add x to all the element on left of middle element \\nstep 5- we have to subtract x from all the element on the right of middle element\\nAll the elements will become equal in minimum steps\\n\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void calculate_step(int s, int d,int x){\\n        while(1){\\n            if(s>d) {ans=INT_MIN; return;}\\n            else if(s==d) return;\\n            s+=x;\\n            ans++;\\n           }\\n    }\\n         void calculate_step2(int s, int d,int x){\\n        while(1){\\n            if(s<d){ ans=INT_MIN; return;}\\n            else if(s==d) return;\\n            s-=x;\\n            ans++;\\n           }\\n }\\n    \\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> temp;\\n        for(int i=0; i<grid.size(); i++){\\n             for(int j=0; j<grid[0].size(); j++){\\n                 temp.push_back(grid[i][j]);\\n             }\\n        }\\n          sort(temp.begin(),temp.end());\\n          int mid=temp[temp.size()/2];\\n        for(int i=0; i<temp.size(); i++){\\n            if( temp[i]==mid) continue;\\n            if(x!=1)\\n            { if(temp[i]<mid) {\\n                calculate_step(temp[i],mid,x);\\n                if(ans==INT_MIN) return -1;\\n            }\\n            if(temp[i]>mid) {\\n                calculate_step2(temp[i],mid,x);\\n                if(ans==INT_MIN) return -1;\\n            }\\n            }\\n            else if(x==1){\\n                if(temp[i]<mid) { ans+=mid-temp[i];}\\n                else if(temp[i]>mid) {ans+=temp[i]-mid;}\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int ans=0;\\n    void calculate_step(int s, int d,int x){\\n        while(1){\\n            if(s>d) {ans=INT_MIN; return;}",
                "codeTag": "Java"
            },
            {
                "id": 1514006,
                "title": "easy-c-solution-o-nlogn-arithmeticprogression",
                "content": "```\\nclass Solution {\\npublic:\\n    int arithmeticprogression(vector<int>&arr,int m,int x) {\\n        int cnt=0;\\n        for(int i=0; i<arr.size() && cnt!=-1; i++) {\\n                 int ax=abs(m-arr[i])+x;\\n                 if(ax%x) cnt=-1;\\n                 else cnt+=(ax/x)-1;\\n        }\\n        return cnt;\\n    }\\n    int minOperations(vector<vector<int>>& g, int x) {\\n         vector<int> arr;\\n         for(int i=0; i<g.size(); i++) {\\n              for(int j=0; j<g[0].size(); j++) {\\n                    arr.push_back(g[i][j]);\\n              }\\n         }\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        return arithmeticprogression(arr,arr[n/2],x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int arithmeticprogression(vector<int>&arr,int m,int x) {\\n        int cnt=0;\\n        for(int i=0; i<arr.size() && cnt!=-1; i++) {\\n                 int ax=abs(m-arr[i])+x;\\n                 if(ax%x) cnt=-1;\\n                 else cnt+=(ax/x)-1;\\n        }\\n        return cnt;\\n    }\\n    int minOperations(vector<vector<int>>& g, int x) {\\n         vector<int> arr;\\n         for(int i=0; i<g.size(); i++) {\\n              for(int j=0; j<g[0].size(); j++) {\\n                    arr.push_back(g[i][j]);\\n              }\\n         }\\n        sort(arr.begin(),arr.end());\\n        int n=arr.size();\\n        return arithmeticprogression(arr,arr[n/2],x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513851,
                "title": "java-median-streams",
                "content": "# Analysis\\nBy observing the problem and given i/o,\\n-> **normalizing every number to the median of the array.**\\n\\n\\tTest Case 1\\n\\tarr = {2,4,6,8}  - median is 4/2 ->  arr[2] =6\\n\\t2 becomes 6 by adding x=2 twice\\n\\t\\t|median-element|/x = |6-2|/2  = 4/2 = 2 twice.. \\n\\t4 becomes 6 by adding x=2 once\\n\\t\\t|median-element|/x = |6-4|/2 = 2/2 = 1 once...\\n\\t8 becomes 6 by subtracting x=2 once\\n\\tTotal 4 operations\\n\\t\\n\\tTest Case 2\\n\\tarr=[1,2,3,5] - median is 4/2 -> arr[2] = 3\\n\\t1 becomes 3 by addin x=1 twice\\n\\t2 becomes 3 by adding x=1 once\\n\\t5 becomes 3 by adding x=1 twice\\n\\tTotal 5 operations\\n\\t\\n\\tTest Case 3\\n\\tarr=[1,2,3,4] - median is 4/2 -> arr[2] = 3\\n\\t1 becomes 3 by adding x=2 once\\n\\t\\t|median-element|/x = |3-1|/2  = 2/2 = 1 once\\n\\t2 not becomes 3 by adding x=2 \\n\\t\\tso it return -1\\n\\t\\t\\n\\t\\n\\t\\n# \\tFormulas\\n\\t-> |median-element|%x==0\\n\\t-> operations += |median-element|/x\\n\\t\\n# \\tSolution\\n```\\t\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = Arrays.stream(grid)\\n                            .flatMapToInt(Arrays::stream)\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        Collections.sort(list);\\n        int size = list.size();\\n        int median = list.get(size/2);\\n        int operations = 0;\\n        for(Integer num: list){\\n            int diff = Math.abs(num-median);\\n            if(diff%x!=0)\\n                return -1;\\n            operations += diff/x; \\n        }\\n        return operations;\\n    }\\n}\\n\\t\\n```\\n\\nFirst it invokes , Arrays.stream(T[]) method, where T is inferred as int[], to get a Stream<int[]>, and then Stream#flatMapToInt() method maps each int[] element to an IntStream using Arrays.stream(int[]) method\\n\\n\\t\\t\\nif it is a one dimensional array then there is no need of flaptMapToInt(), simply you can use\\n``` \\nint[] arr = {1,2,3};\\nList<Integer> l1 = Arrays.stream(arr).boxed().collect(Collectors.toList());\\n```\\n\\n**Without Streams Conversion**\\n```\\nList<Integer> list = new ArrayList<>();\\nfor(int i = 0; i < grid.length;i++){\\n\\tfor(int j = 0; j<grid[i].length; j++){\\n\\t\\tlist.add(grid[i][j]);\\n\\t}\\n}\\n```\\t\\t\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\t\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = Arrays.stream(grid)\\n                            .flatMapToInt(Arrays::stream)\\n                            .boxed()\\n                            .collect(Collectors.toList());\\n        Collections.sort(list);\\n        int size = list.size();\\n        int median = list.get(size/2);\\n        int operations = 0;\\n        for(Integer num: list){\\n            int diff = Math.abs(num-median);\\n            if(diff%x!=0)\\n                return -1;\\n            operations += diff/x; \\n        }\\n        return operations;\\n    }\\n}\\n\\t\\n```\n``` \\nint[] arr = {1,2,3};\\nList<Integer> l1 = Arrays.stream(arr).boxed().collect(Collectors.toList());\\n```\n```\\nList<Integer> list = new ArrayList<>();\\nfor(int i = 0; i < grid.length;i++){\\n\\tfor(int j = 0; j<grid[i].length; j++){\\n\\t\\tlist.add(grid[i][j]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513608,
                "title": "python-easy-to-understand-median-o-m-n-log-m-n",
                "content": "\\n```\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:     \\n        nums = []\\n        for row in grid:\\n            nums += row \\n        l = len(nums)        \\n        if l <= 1:\\n            return 0\\n        nums.sort()\\n        median = nums[l//2]\\n        steps = 0\\n        for i in range(l):  \\n            diff = abs(median-nums[i])\\n            quo,rem = diff//x, diff%x\\n            steps += quo\\n            if rem:\\n                return -1\\n        return int(steps)\\n``` \\n\\nT - O(m*n*log(m*n)) , for sorting the list and finding median, \\n\\t the steps for computing number of steps  takes O(m*n)\\nS - O(m*n) , for storing grid in a list",
                "solutionTags": [],
                "code": "```\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:     \\n        nums = []\\n        for row in grid:\\n            nums += row \\n        l = len(nums)        \\n        if l <= 1:\\n            return 0\\n        nums.sort()\\n        median = nums[l//2]\\n        steps = 0\\n        for i in range(l):  \\n            diff = abs(median-nums[i])\\n            quo,rem = diff//x, diff%x\\n            steps += quo\\n            if rem:\\n                return -1\\n        return int(steps)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1513463,
                "title": "python-median",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        n = len(grid) * len(grid[0])\\n        ops = 0\\n        \\n\\t\\t# Find the median\\n\\t\\t#   Convert grid to a 1D list\\n\\t\\t#   Index the middle element (when it\\'s even, it picks the second middle)\\n\\t\\tmed = sorted([col for row in grid for col in row])[n // 2]\\n        \\n\\t\\t# Go through the grid and calculate the number of additions/subtractions needed for each element\\n\\t\\tfor row in grid:\\n            for col in row:\\n\\t\\t\\t\\t# If the difference is not divisible, you can\\'t add/subtract your way to the median\\n                if abs(med - col) % x != 0: \\n                    return -1\\n                ops += abs(med - col) // x\\n        \\n\\t\\t# Profit\\n        return ops\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        n = len(grid) * len(grid[0])\\n        ops = 0\\n        \\n\\t\\t# Find the median\\n\\t\\t#   Convert grid to a 1D list\\n\\t\\t#   Index the middle element (when it\\'s even, it picks the second middle)\\n\\t\\tmed = sorted([col for row in grid for col in row])[n // 2]\\n        \\n\\t\\t# Go through the grid and calculate the number of additions/subtractions needed for each element\\n\\t\\tfor row in grid:\\n            for col in row:\\n\\t\\t\\t\\t# If the difference is not divisible, you can\\'t add/subtract your way to the median\\n                if abs(med - col) % x != 0: \\n                    return -1\\n                ops += abs(med - col) // x\\n        \\n\\t\\t# Profit\\n        return ops\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513462,
                "title": "c-solution-using-sort-median",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), mod = grid[0][0] % x;\\n        vector<int> res;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n            {\\n                if(grid[i][j] % x != mod)\\n                    return -1;\\n                res.push_back(grid[i][j]);\\n            }\\n        sort(res.begin(), res.end());\\n        int ans = 0, target = res[res.size()/2]; //mid number\\n        for(int n : res)\\n            ans += abs(target - n) / x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), mod = grid[0][0] % x;\\n        vector<int> res;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n            {\\n                if(grid[i][j] % x != mod)\\n                    return -1;\\n                res.push_back(grid[i][j]);\\n            }\\n        sort(res.begin(), res.end());\\n        int ans = 0, target = res[res.size()/2]; //mid number\\n        for(int n : res)\\n            ans += abs(target - n) / x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513448,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        lks=sorted([y for x in grid for y in x])\\n        mid=lks[len(lks)//2]\\n        ans=0\\n        for i in lks:\\n            if abs(i-mid)%x!=0:\\n                return -1\\n            ans+=(abs(i-mid)//x)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        lks=sorted([y for x in grid for y in x])\\n        mid=lks[len(lks)//2]\\n        ans=0\\n        for i in lks:\\n            if abs(i-mid)%x!=0:\\n                return -1\\n            ans+=(abs(i-mid)//x)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513439,
                "title": "python-sortedlist-2033-minimum-operations-to-make-a-uni-value-grid",
                "content": "\\n\\n\\tfrom sortedcontainers import SortedList\\n\\tclass Solution:\\n\\t\\tdef minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\t\\t\\tarr = SortedList()\\n\\t\\t\\tfor i in grid:\\n\\t\\t\\t\\tfor j in i: \\n\\t\\t\\t\\t\\tarr.add(j)\\n\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\ttarget = arr[n//2]\\n\\t\\t\\tif n%2 == 0: \\n\\t\\t\\t\\ttarget = min(arr[n//2],arr[n//2 - 1]) \\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr: \\n\\t\\t\\t\\tif i<target:\\n\\t\\t\\t\\t\\tif (target-i) % x != 0: \\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\tres+= (target-i) // x\\n\\t\\t\\t\\tif i>target: \\n\\t\\t\\t\\t\\tif (i-target) % x != 0: \\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\tres+= (i-target) // x\\n\\n\\t\\t\\treturn res\\n",
                "solutionTags": [],
                "code": "\\n\\n\\tfrom sortedcontainers import SortedList\\n\\tclass Solution:\\n\\t\\tdef minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\t\\t\\tarr = SortedList()\\n\\t\\t\\tfor i in grid:\\n\\t\\t\\t\\tfor j in i: \\n\\t\\t\\t\\t\\tarr.add(j)\\n\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\ttarget = arr[n//2]\\n\\t\\t\\tif n%2 == 0: \\n\\t\\t\\t\\ttarget = min(arr[n//2],arr[n//2 - 1]) \\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in arr: \\n\\t\\t\\t\\tif i<target:\\n\\t\\t\\t\\t\\tif (target-i) % x != 0: \\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\tres+= (target-i) // x\\n\\t\\t\\t\\tif i>target: \\n\\t\\t\\t\\t\\tif (i-target) % x != 0: \\n\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\tres+= (i-target) // x\\n\\n\\t\\t\\treturn res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1513438,
                "title": "java-no-median-need-traverse-every-situation-in-a-o-n-m-log-n-m-way",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] data = new int[n * m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                data[i * m + j] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(data);\\n\\n        int res = Integer.MAX_VALUE;\\n        int prev = 0;\\n        int next = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            next += data[i];\\n        }\\n        \\n        int target = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            if (data[i] * i - prev + next - data[i] * (n * m - i) < res) {\\n                res = data[i] * i - prev + next - data[i] * (n * m - i);\\n                target = data[i];\\n            }\\n            next -= data[i]; \\n            prev += data[i];\\n        }\\n        \\n        for (int i = 0; i < n * m; i++) {\\n            if ((data[i] - target) % x != 0) {\\n                return -1;\\n            }\\n        }\\n        return res / x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] data = new int[n * m];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                data[i * m + j] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(data);\\n\\n        int res = Integer.MAX_VALUE;\\n        int prev = 0;\\n        int next = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            next += data[i];\\n        }\\n        \\n        int target = 0;\\n        for (int i = 0; i < n * m; i++) {\\n            if (data[i] * i - prev + next - data[i] * (n * m - i) < res) {\\n                res = data[i] * i - prev + next - data[i] * (n * m - i);\\n                target = data[i];\\n            }\\n            next -= data[i]; \\n            prev += data[i];\\n        }\\n        \\n        for (int i = 0; i < n * m; i++) {\\n            if ((data[i] - target) % x != 0) {\\n                return -1;\\n            }\\n        }\\n        return res / x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513405,
                "title": "python-median-easy-approach",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        l=[]\\n        e1=0\\n        o1=0\\n        for i in grid:\\n            for j in i:\\n                l.append(j)\\n        for i in l:\\n            if i%2==0:\\n                e1+=1\\n            else:\\n                o1+=1\\n        \\n        \\n        k=sorted(l)\\n        if len(k)==1:\\n            return 0\\n        xx=0\\n        c=(len(k)//2)\\n        pp=k[c]\\n        for i in k:\\n            if abs(i-pp)%x==0:\\n                xx+=1\\n        if xx!=len(k):\\n            return -1\\n        cc=0\\n        \\n        \\n        for i in k:\\n            cc+=abs(i-k[c])\\n        \\n        return cc//x\\n```\\n**#Upvote , If it helps you!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        l=[]\\n        e1=0\\n        o1=0\\n        for i in grid:\\n            for j in i:\\n                l.append(j)\\n        for i in l:\\n            if i%2==0:\\n                e1+=1\\n            else:\\n                o1+=1\\n        \\n        \\n        k=sorted(l)\\n        if len(k)==1:\\n            return 0\\n        xx=0\\n        c=(len(k)//2)\\n        pp=k[c]\\n        for i in k:\\n            if abs(i-pp)%x==0:\\n                xx+=1\\n        if xx!=len(k):\\n            return -1\\n        cc=0\\n        \\n        \\n        for i in k:\\n            cc+=abs(i-k[c])\\n        \\n        return cc//x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513402,
                "title": "java-median",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] median = find(grid, x);\\n        int count = 0;\\n        if (median.length == 1) {\\n            count = minOperations(grid, x, median[0]);\\n        } else {\\n            count = Math.min(minOperations(grid, x, median[0]), minOperations(grid, x, median[1]));\\n        }\\n        return count == Integer.MAX_VALUE ? -1 : count;\\n    }\\n    \\n    int minOperations(int[][] grid, int x, int median) {\\n        int count = 0;\\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[0].length; col++) {\\n                if (Math.abs(grid[row][col] - median) % x != 0) {\\n                    return Integer.MAX_VALUE;\\n                }\\n                count += Math.abs(grid[row][col] - median) / x;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int[] find(int[][] grid, int x) {\\n        int[] arr = new int[grid.length * grid[0].length];\\n        int cols = grid[0].length;\\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[0].length; col++) {\\n                arr[row*cols + col] = grid[row][col];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        if (arr.length % 2 == 0) {\\n            return new int[]{arr[arr.length/2], arr[(arr.length/2) - 1]};\\n        }\\n        return new int[]{arr[arr.length/2]};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] median = find(grid, x);\\n        int count = 0;\\n        if (median.length == 1) {\\n            count = minOperations(grid, x, median[0]);\\n        } else {\\n            count = Math.min(minOperations(grid, x, median[0]), minOperations(grid, x, median[1]));\\n        }\\n        return count == Integer.MAX_VALUE ? -1 : count;\\n    }\\n    \\n    int minOperations(int[][] grid, int x, int median) {\\n        int count = 0;\\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[0].length; col++) {\\n                if (Math.abs(grid[row][col] - median) % x != 0) {\\n                    return Integer.MAX_VALUE;\\n                }\\n                count += Math.abs(grid[row][col] - median) / x;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int[] find(int[][] grid, int x) {\\n        int[] arr = new int[grid.length * grid[0].length];\\n        int cols = grid[0].length;\\n        for (int row = 0; row < grid.length; row++) {\\n            for (int col = 0; col < grid[0].length; col++) {\\n                arr[row*cols + col] = grid[row][col];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        if (arr.length % 2 == 0) {\\n            return new int[]{arr[arr.length/2], arr[(arr.length/2) - 1]};\\n        }\\n        return new int[]{arr[arr.length/2]};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513399,
                "title": "c-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> arr(n * m, 0);\\n        int mod = a[0][0] % k;\\n        for(int i = 0; i < n; ++i) {\\n           for(int j = 0; j < m; ++j) {\\n              arr[i * m + j] = a[i][j];\\n              if(a[i][j] % k != mod) return -1;\\n           }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int temp = arr[(n * m) / 2];\\n        int ops = 0;\\n        for(int i = 0; i < n * m; ++i)\\n            ops += abs(arr[i] - temp) / k;\\n        if((n * m) % 2 == 0) {\\n           int temp2 = arr[( (n * m) / 2) - 1];\\n           int ops2 = 0;\\n           for(int i = 0; i < n * m; ++i)\\n              ops2 += abs(arr[i] - temp2) / k;\\n           ops = min(ops, ops2);\\n        }\\n        return ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& a, int k) {\\n        int n = a.size(), m = a[0].size();\\n        vector<int> arr(n * m, 0);\\n        int mod = a[0][0] % k;\\n        for(int i = 0; i < n; ++i) {\\n           for(int j = 0; j < m; ++j) {\\n              arr[i * m + j] = a[i][j];\\n              if(a[i][j] % k != mod) return -1;\\n           }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int temp = arr[(n * m) / 2];\\n        int ops = 0;\\n        for(int i = 0; i < n * m; ++i)\\n            ops += abs(arr[i] - temp) / k;\\n        if((n * m) % 2 == 0) {\\n           int temp2 = arr[( (n * m) / 2) - 1];\\n           int ops2 = 0;\\n           for(int i = 0; i < n * m; ++i)\\n              ops2 += abs(arr[i] - temp2) / k;\\n           ops = min(ops, ops2);\\n        }\\n        return ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513374,
                "title": "c-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);  //flatten the grid into a 1d array/vector\\n            }\\n        }\\n        \\n        n=v.size();\\n        \\n        sort(v.begin(), v.end()); //sort\\n \\n        m=n/2;  //the min answer will be if you make every element equal to middle of sorted array. Pick up a pen and copy, and try it yourself\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int u=abs(v[m]-v[i]);\\n           \\n            if(u%x!=0){  //means we cannot make all the elements equal\\n                return -1;\\n            }\\n            \\n            ans+=(u/x);  //increment ans by number of steps required for corresponding element\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n**Do upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        \\n        vector<int> v;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                v.push_back(grid[i][j]);  //flatten the grid into a 1d array/vector\\n            }\\n        }\\n        \\n        n=v.size();\\n        \\n        sort(v.begin(), v.end()); //sort\\n \\n        m=n/2;  //the min answer will be if you make every element equal to middle of sorted array. Pick up a pen and copy, and try it yourself\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int u=abs(v[m]-v[i]);\\n           \\n            if(u%x!=0){  //means we cannot make all the elements equal\\n                return -1;\\n            }\\n            \\n            ans+=(u/x);  //increment ans by number of steps required for corresponding element\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513353,
                "title": "kotlin-simple-clean-and-concise-with-explaination",
                "content": "1. Convert grid into 1D array and Sort the array\\n2. Find middle element(avg). We have to try to make all elements equal to this\\n3. Calculate operations\\n\\n```\\n\\nimport kotlin.math.abs\\nclass Solution {\\n    fun minOperations(grid: Array<IntArray>, x: Int): Int {\\n        val list = grid.flatMap { it.toList() }.sorted()\\n        val avg = list.get(list.size / 2)\\n        var op = 0\\n        list.forEach {\\n            val rem = abs(it - avg)\\n            if (rem % x != 0) return -1\\n            else op += rem / x\\n        }\\n        return op\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nimport kotlin.math.abs\\nclass Solution {\\n    fun minOperations(grid: Array<IntArray>, x: Int): Int {\\n        val list = grid.flatMap { it.toList() }.sorted()\\n        val avg = list.get(list.size / 2)\\n        var op = 0\\n        list.forEach {\\n            val rem = abs(it - avg)\\n            if (rem % x != 0) return -1\\n            else op += rem / x\\n        }\\n        return op\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1513352,
                "title": "python-sort",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        # method: sort, math (the minimun one is the middle one)\\n        # step1: sort\\n        # step2: check middle one and calcualte the distance\\n        # time-complexity: O(mnlog(mn))\\n        # space-complexity: O(mn)\\n        def getDis(target):\\n            cur = 0\\n            for d in s:\\n                dis = abs(d-target)\\n                if dis%x!=0:\\n                    return -1\\n                cur += (dis//x)\\n            return cur\\n            \\n        m, n = len(grid), len(grid[0])\\n        s = []\\n        for i in range(m):\\n            for j in range(n):\\n                s.append(grid[i][j])\\n        s.sort()\\n        target = s[len(s)//2]\\n        return getDis(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        # method: sort, math (the minimun one is the middle one)\\n        # step1: sort\\n        # step2: check middle one and calcualte the distance\\n        # time-complexity: O(mnlog(mn))\\n        # space-complexity: O(mn)\\n        def getDis(target):\\n            cur = 0\\n            for d in s:\\n                dis = abs(d-target)\\n                if dis%x!=0:\\n                    return -1\\n                cur += (dis//x)\\n            return cur\\n            \\n        m, n = len(grid), len(grid[0])\\n        s = []\\n        for i in range(m):\\n            for j in range(n):\\n                s.append(grid[i][j])\\n        s.sort()\\n        target = s[len(s)//2]\\n        return getDis(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980026,
                "title": "sorting-and-median",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<int> nums;\\n        for(auto it : grid) {\\n            for(auto it1 : it) {\\n                nums.push_back(it1);\\n            }\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        int mid = nums[(n * m) / 2];\\n        int count = 0;\\n\\n        for(auto it : nums) {\\n            int rem = abs(it - mid);\\n            if(rem % x != 0) {\\n                return -1;\\n            }\\n\\n            count += rem / x;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n\\n        vector<int> nums;\\n        for(auto it : grid) {\\n            for(auto it1 : it) {\\n                nums.push_back(it1);\\n            }\\n        }\\n\\n        sort(nums.begin(), nums.end());\\n        int mid = nums[(n * m) / 2];\\n        int count = 0;\\n\\n        for(auto it : nums) {\\n            int rem = abs(it - mid);\\n            if(rem % x != 0) {\\n                return -1;\\n            }\\n\\n            count += rem / x;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973433,
                "title": "if-median-does-not-work-there-is-no-other-solution",
                "content": "# Intuition\\nPlease check other solution, why median is the optimal solution.\\n\\nI am tryign to explain if median does not work, no other solution can work.\\n\\n(Or you can see that, the following condition applies for all other elements too => all elements should be convertible to all other elements using x)\\n\\n# Approach\\n![median_issue1.jpg](https://assets.leetcode.com/users/images/3a98d516-dfbd-4f44-b37d-a5898139910f_1693252790.0915694.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nPlease check other solution, why median is the optimal solution.\\n\\nI am tryign to explain if median does not work, no other solution can work.\\n\\n(Or you can see that, the following condition applies for all other elements too => all elements should be convertible to all other elements using x)\\n\\n# Approach\\n![median_issue1.jpg](https://assets.leetcode.com/users/images/3a98d516-dfbd-4f44-b37d-a5898139910f_1693252790.0915694.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3944471,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        HashMap<Integer,Integer> numsMap = new HashMap<Integer,Integer>();\\n        int min = 10000,max = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] < min){\\n                    min = grid[i][j];\\n                }\\n                if(grid[i][j] > max){\\n                    max = grid[i][j];\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if((grid[i][j] - min) % x != 0){\\n                    return -1;\\n                }\\n                if(numsMap.containsKey((grid[i][j]-min)/x)){\\n                    numsMap.replace((grid[i][j]-min)/x,numsMap.get((grid[i][j]-min)/x) + 1);\\n                }\\n                else{\\n                    numsMap.put((grid[i][j]-min)/x,1);\\n                }\\n            }\\n        }\\n        max = (max-min)/x;min = 0;\\n\\n        int[] prefix = new int[max+1];\\n        prefix[0] = numsMap.get(0);\\n        for(int i = 1;i <= max;i++){\\n            if(numsMap.containsKey(i)){\\n                prefix[i] = prefix[i-1] + numsMap.get(i);\\n            }\\n            else{\\n                prefix[i] = prefix[i-1];\\n            }\\n        }\\n\\n        int[] result = new int[max+1];\\n        result[0] = 0;\\n        for(int i = 1;i <= max;i++){\\n            if(numsMap.containsKey(i)){\\n                result[0] += i*numsMap.get(i);\\n            }\\n        }\\n        int minRe = result[0];\\n        for(int i = 1;i <= max;i++){\\n            result[i] = result[i-1] - (prefix[max]-prefix[i-1]) + prefix[i-1];\\n            if(result[i] < minRe){\\n                minRe = result[i];\\n            }\\n        }\\n\\n        return minRe;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        HashMap<Integer,Integer> numsMap = new HashMap<Integer,Integer>();\\n        int min = 10000,max = 0;\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if(grid[i][j] < min){\\n                    min = grid[i][j];\\n                }\\n                if(grid[i][j] > max){\\n                    max = grid[i][j];\\n                }\\n            }\\n        }\\n\\n        for(int i = 0;i < grid.length;i++){\\n            for(int j = 0;j < grid[0].length;j++){\\n                if((grid[i][j] - min) % x != 0){\\n                    return -1;\\n                }\\n                if(numsMap.containsKey((grid[i][j]-min)/x)){\\n                    numsMap.replace((grid[i][j]-min)/x,numsMap.get((grid[i][j]-min)/x) + 1);\\n                }\\n                else{\\n                    numsMap.put((grid[i][j]-min)/x,1);\\n                }\\n            }\\n        }\\n        max = (max-min)/x;min = 0;\\n\\n        int[] prefix = new int[max+1];\\n        prefix[0] = numsMap.get(0);\\n        for(int i = 1;i <= max;i++){\\n            if(numsMap.containsKey(i)){\\n                prefix[i] = prefix[i-1] + numsMap.get(i);\\n            }\\n            else{\\n                prefix[i] = prefix[i-1];\\n            }\\n        }\\n\\n        int[] result = new int[max+1];\\n        result[0] = 0;\\n        for(int i = 1;i <= max;i++){\\n            if(numsMap.containsKey(i)){\\n                result[0] += i*numsMap.get(i);\\n            }\\n        }\\n        int minRe = result[0];\\n        for(int i = 1;i <= max;i++){\\n            result[i] = result[i-1] - (prefix[max]-prefix[i-1]) + prefix[i-1];\\n            if(result[i] < minRe){\\n                minRe = result[i];\\n            }\\n        }\\n\\n        return minRe;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901968,
                "title": "minimum-operations-to-make-a-uni-value-grid",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] arr = new int[grid.length*grid[0].length];\\n        int a = grid[0][0]%x;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]%x!=a)\\n                return -1;\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                arr[k] = grid[i][j];\\n                k++;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int n = arr[arr.length/2];\\n        System.out.println(n);\\n        int count = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>n)\\n            {\\n                while(arr[i]>n)\\n                {\\n                    count++;\\n                    arr[i] = arr[i]-x;\\n                }\\n            }\\n            else if(arr[i]<n)\\n            {\\n                while(arr[i]<n)\\n                {\\n                    count++;\\n                    arr[i] = arr[i]+x;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] arr = new int[grid.length*grid[0].length];\\n        int a = grid[0][0]%x;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                if(grid[i][j]%x!=a)\\n                return -1;\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                arr[k] = grid[i][j];\\n                k++;\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int n = arr[arr.length/2];\\n        System.out.println(n);\\n        int count = 0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]>n)\\n            {\\n                while(arr[i]>n)\\n                {\\n                    count++;\\n                    arr[i] = arr[i]-x;\\n                }\\n            }\\n            else if(arr[i]<n)\\n            {\\n                while(arr[i]<n)\\n                {\\n                    count++;\\n                    arr[i] = arr[i]+x;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842218,
                "title": "java-sorting-median",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        int ROW = grid.length;\\n        int COL = grid[0].length;\\n\\n        int n = ROW * COL;\\n\\n        for(int row = 0; row < ROW; row++){\\n            for(int col = 0; col < COL; col++){\\n                list.add(grid[row][col]);\\n            }\\n        }\\n\\n        Collections.sort(list);\\n        int medianIndex = n % 2 == 0 ? (n - 1) / 2 : n / 2;\\n        int medianVal = list.get(medianIndex);\\n\\n        int  moves = 0;\\n\\n        for(int val : list){\\n            int diff = Math.abs(medianVal - val);\\n            if(diff % x != 0) return -1;\\n            //number of incr or decr need to make\\n            int incrOrDecr = diff / x;\\n            moves += incrOrDecr;\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        int ROW = grid.length;\\n        int COL = grid[0].length;\\n\\n        int n = ROW * COL;\\n\\n        for(int row = 0; row < ROW; row++){\\n            for(int col = 0; col < COL; col++){\\n                list.add(grid[row][col]);\\n            }\\n        }\\n\\n        Collections.sort(list);\\n        int medianIndex = n % 2 == 0 ? (n - 1) / 2 : n / 2;\\n        int medianVal = list.get(medianIndex);\\n\\n        int  moves = 0;\\n\\n        for(int val : list){\\n            int diff = Math.abs(medianVal - val);\\n            if(diff % x != 0) return -1;\\n            //number of incr or decr need to make\\n            int incrOrDecr = diff / x;\\n            moves += incrOrDecr;\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808920,
                "title": "java-solution-tc-o-n-m",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*M)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int arr[] = new int[grid.length*grid[0].length];\\n        \\n        int idx = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) arr[idx++] = grid[i][j];\\n        }\\n\\n       Arrays.sort(arr);\\n       int tar = arr[arr.length/2];\\n       int count = 0;\\n\\n\\n       int diff = 0;\\n       for(int i=0; i<arr.length; i++) {\\n           int num = arr[i];\\n           if(num == tar) continue;\\n           \\n           diff = Math.abs(num-tar);\\n           if(diff < x || diff%x != 0) return -1;\\n\\n           count += (diff/x);\\n       }\\n\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int arr[] = new int[grid.length*grid[0].length];\\n        \\n        int idx = 0;\\n        for(int i=0; i<grid.length; i++) {\\n            for(int j=0; j<grid[0].length; j++) arr[idx++] = grid[i][j];\\n        }\\n\\n       Arrays.sort(arr);\\n       int tar = arr[arr.length/2];\\n       int count = 0;\\n\\n\\n       int diff = 0;\\n       for(int i=0; i<arr.length; i++) {\\n           int num = arr[i];\\n           if(num == tar) continue;\\n           \\n           diff = Math.abs(num-tar);\\n           if(diff < x || diff%x != 0) return -1;\\n\\n           count += (diff/x);\\n       }\\n\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794761,
                "title": "numpy-4-liner-beats-100-in-speed",
                "content": "# Intuition\\nPython is slow, numpy delegates some operations to internal C implementation, which is way faster\\n\\n# Approach\\nJust use numpy\\n\\n# Complexity\\n- Time complexity: $O(n)$\\nmultiple operasions that traverses whole matrix\\n\\n- Space complexity: $O(n)$\\nConversion to numpy array traverses whole matrix\\n\\n$n$ here is $width\\\\times height$ of a materi\\n\\n# Code\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        grid = np.array(grid, dtype=int).reshape(-1)\\n\\n        if 0 != np.ptp(np.mod(grid, x)):\\n            return -1\\n        return int(np.abs(grid - np.median(grid)).sum() / x)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        grid = np.array(grid, dtype=int).reshape(-1)\\n\\n        if 0 != np.ptp(np.mod(grid, x)):\\n            return -1\\n        return int(np.abs(grid - np.median(grid)).sum() / x)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777733,
                "title": "javascript-easy-understanding-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[][]} grid\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(grid, x) {\\n    grid = grid.flat(1);\\n    for (let i = 1; i < grid.length; i++){\\n        if (grid[i - 1] % x !== grid[i] % x) return -1;\\n    }\\n    grid.sort((a, b) => a - b);\\n    let mid = grid[Math.floor(grid.length / 2)];\\n    let res = 0;\\n    for (let i = 0; i < grid.length; i++){\\n        res += Math.floor(Math.abs(grid[i] - mid) / x);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid\\n * @param {number} x\\n * @return {number}\\n */\\nvar minOperations = function(grid, x) {\\n    grid = grid.flat(1);\\n    for (let i = 1; i < grid.length; i++){\\n        if (grid[i - 1] % x !== grid[i] % x) return -1;\\n    }\\n    grid.sort((a, b) => a - b);\\n    let mid = grid[Math.floor(grid.length / 2)];\\n    let res = 0;\\n    for (let i = 0; i < grid.length; i++){\\n        res += Math.floor(Math.abs(grid[i] - mid) / x);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743728,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        ArrayList<Integer> a=new ArrayList<Integer>();\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                a.add(grid[i][j]);\\n            }\\n        }\\n        if(a.size()==1)\\n        return 0;\\n        Collections.sort(a);\\n        int c=a.size()/2;\\n        int max=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y=(int)Math.abs(a.get(i)-a.get(c));\\n            if(y%x==0)\\n            max+=y/x;\\n            else\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        ArrayList<Integer> a=new ArrayList<Integer>();\\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                a.add(grid[i][j]);\\n            }\\n        }\\n        if(a.size()==1)\\n        return 0;\\n        Collections.sort(a);\\n        int c=a.size()/2;\\n        int max=0;\\n        for(int i=0;i<a.size();i++)\\n        {\\n            int y=(int)Math.abs(a.get(i)-a.get(c));\\n            if(y%x==0)\\n            max+=y/x;\\n            else\\n            return -1;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709181,
                "title": "median-is-the-optimal-choice-beginner-friendly-with-similar-questions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nconverting into mideian is the most optimal choice\\nand if the change is not divisible by x then its not possible \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nconvert into a sorted array\\nfind median element\\nchange all element to median\\nsimilar questions\\n[2448  Minimum Cost to Make Array Equal](https://leetcode.com/problems/minimum-cost-to-make-array-equal/)\\n[462. Minimum Moves to Equal Array Elements II\\n](https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(m*n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(m*n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n     long long calc(vector<int>&nums, long long median,int x){\\n\\n        long long ans = 0;\\n\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              if(abs(nums[i]-median)%x!=0) return -1;\\n         \\n           ans += (abs(1ll*nums[i]-median)/x);\\n             }\\n         return ans;  \\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           for(int j=0;j<grid[0].size();j++)\\n               v.push_back(grid[i][j]);\\n        }\\n        //for(int i=0;i<v.size();i++) cout<<v[i];\\n        sort(v.begin(),v.end());\\n        int median=v[(v.size()+1)/2-1];\\n       // cout<<median;\\n         return calc(v,median,x);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     long long calc(vector<int>&nums, long long median,int x){\\n\\n        long long ans = 0;\\n\\n         for(int i=0;i<nums.size();i++)\\n         {\\n              if(abs(nums[i]-median)%x!=0) return -1;\\n         \\n           ans += (abs(1ll*nums[i]-median)/x);\\n             }\\n         return ans;  \\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n           for(int j=0;j<grid[0].size();j++)\\n               v.push_back(grid[i][j]);\\n        }\\n        //for(int i=0;i<v.size();i++) cout<<v[i];\\n        sort(v.begin(),v.end());\\n        int median=v[(v.size()+1)/2-1];\\n       // cout<<median;\\n         return calc(v,median,x);\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3705948,
                "title": "c-o-nlogn-time-o-n-space-n-rows-cols",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> newGrid; \\n\\n        // create 1d array\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                newGrid.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // sort 1d array and find median value\\n        sort(newGrid.begin(), newGrid.end());\\n        int median = newGrid[newGrid.size() / 2];\\n\\n        // lowest cost -- turn every element into median value \\n        int numOperations = 0;\\n        \\n        for (int num : newGrid) {\\n            // if not possible to make curr value median: then it\\'s \\n            // impossible for all of the elements to be uni-value \\n            if ((num - median) % x != 0) {\\n                return -1;\\n            }\\n            // otherwise, add number of operations to make curr value median\\n            numOperations += (abs(num - median) / x);\\n        }\\n\\n        return numOperations;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> newGrid; \\n\\n        // create 1d array\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                newGrid.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        // sort 1d array and find median value\\n        sort(newGrid.begin(), newGrid.end());\\n        int median = newGrid[newGrid.size() / 2];\\n\\n        // lowest cost -- turn every element into median value \\n        int numOperations = 0;\\n        \\n        for (int num : newGrid) {\\n            // if not possible to make curr value median: then it\\'s \\n            // impossible for all of the elements to be uni-value \\n            if ((num - median) % x != 0) {\\n                return -1;\\n            }\\n            // otherwise, add number of operations to make curr value median\\n            numOperations += (abs(num - median) / x);\\n        }\\n\\n        return numOperations;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665006,
                "title": "easy-to-understand-sorting-matrix",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(auto row : grid){\\n            v.insert(v.end(), row.begin(), row.end());\\n        }\\n        int n = v.size();\\n        int m = (n-1)/2;\\n        int ans=0;\\n        int curr;\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; ++i){\\n            curr = (abs(v[m]-v[i]));\\n            if(curr%x != 0){\\n                return -1;\\n            }\\n            else{\\n                ans += (curr/x);\\n            }\\n        }\\n        // for(int i=0; i<n; ++i){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(auto row : grid){\\n            v.insert(v.end(), row.begin(), row.end());\\n        }\\n        int n = v.size();\\n        int m = (n-1)/2;\\n        int ans=0;\\n        int curr;\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<n; ++i){\\n            curr = (abs(v[m]-v[i]));\\n            if(curr%x != 0){\\n                return -1;\\n            }\\n            else{\\n                ans += (curr/x);\\n            }\\n        }\\n        // for(int i=0; i<n; ++i){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664127,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(vector<int>&v, int m1,int x){\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++){\\n            ans += (abs(m1-v[i]))/x;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int rem = grid[0][0]%x;\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]%x!=rem){\\n                    return -1;\\n                }\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()%2==0){\\n            int m1 = v[v.size()/2];\\n            int m2 = v[v.size()/2-1];\\n            return min(solve(v,m1,x),solve(v,m2,x));\\n        }\\n        int m1 = v[v.size()/2];\\n        return solve(v,m1,x);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>&v, int m1,int x){\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++){\\n            ans += (abs(m1-v[i]))/x;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int rem = grid[0][0]%x;\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]%x!=rem){\\n                    return -1;\\n                }\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()%2==0){\\n            int m1 = v[v.size()/2];\\n            int m2 = v[v.size()/2-1];\\n            return min(solve(v,m1,x),solve(v,m2,x));\\n        }\\n        int m1 = v[v.size()/2];\\n        return solve(v,m1,x);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664120,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int solve(vector<int>&v, int m1,int x){\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++){\\n            ans += (abs(m1-v[i]))/x;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int rem = grid[0][0]%x;\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]%x!=rem){\\n                    return -1;\\n                }\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()%2==0){\\n            int m1 = v[v.size()/2];\\n            int m2 = v[v.size()/2-1];\\n            return min(solve(v,m1,x),solve(v,m2,x));\\n        }\\n        int m1 = v[v.size()/2];\\n        return solve(v,m1,x);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>&v, int m1,int x){\\n        int ans = 0;\\n        for(int i=0; i<v.size(); i++){\\n            ans += (abs(m1-v[i]))/x;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int rem = grid[0][0]%x;\\n        vector<int> v;\\n        for(int i=0; i<grid.size(); i++){\\n            for(int j=0; j<grid[0].size(); j++){\\n                if(grid[i][j]%x!=rem){\\n                    return -1;\\n                }\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        if(v.size()%2==0){\\n            int m1 = v[v.size()/2];\\n            int m2 = v[v.size()/2-1];\\n            return min(solve(v,m1,x),solve(v,m2,x));\\n        }\\n        int m1 = v[v.size()/2];\\n        return solve(v,m1,x);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600617,
                "title": "ternary-search",
                "content": "# Approach\\nThe grid can be made uni-value if each value of  the grid mod x is uni-value. We can use a set to detect that.\\n\\nThe function f defines the number of operations to shift all value to k.\\nSince f is unimodal, we could utilize ternary search shrink interval [min, max] small enough and then brute force it.\\n  \\n\\n\\n\\n# Complexity\\n- Time complexity: O(MNlgK) M:#rows in grid N:#cols in grid K:range of grid value\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(MN)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        S = set()\\n        L = []\\n\\n        for r in range(m):\\n            for c in range(n):\\n                S.add(grid[r][c] % x)\\n\\n                if len(S) > 1:\\n                    return -1\\n                \\n                L.append(grid[r][c] // x)\\n\\n        #print(L)\\n        def f(k):\\n            return sum(abs(x-k) for x in L)\\n        \\n        l, r = min(L), max(L)\\n\\n        while r - l > 3:\\n            #print(l, r)\\n            m1 = l + (r-l) // 3\\n            m2 = r - (r-l) // 3\\n\\n            if f(m1) < f(m2):\\n                r = m2\\n            else:\\n                l = m1\\n\\n        ret = f(l)\\n\\n        for i in range(l+1, r+1):\\n            ret = min(ret, f(i))\\n        \\n        return ret\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m = len(grid)\\n        n = len(grid[0])\\n        S = set()\\n        L = []\\n\\n        for r in range(m):\\n            for c in range(n):\\n                S.add(grid[r][c] % x)\\n\\n                if len(S) > 1:\\n                    return -1\\n                \\n                L.append(grid[r][c] // x)\\n\\n        #print(L)\\n        def f(k):\\n            return sum(abs(x-k) for x in L)\\n        \\n        l, r = min(L), max(L)\\n\\n        while r - l > 3:\\n            #print(l, r)\\n            m1 = l + (r-l) // 3\\n            m2 = r - (r-l) // 3\\n\\n            if f(m1) < f(m2):\\n                r = m2\\n            else:\\n                l = m1\\n\\n        ret = f(l)\\n\\n        for i in range(l+1, r+1):\\n            ret = min(ret, f(i))\\n        \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497944,
                "title": "there-is-nothing-twodimensional-in-this-problem-get-all-values-to-median",
                "content": "# Code\\n```\\nimport numpy as np\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        a = sorted(np.array(grid).reshape((len(grid)*len(grid[0]),)))\\n        m = a[len(a)//2]\\n        ret = 0\\n        for y in a:\\n            d, mod = divmod(abs(y-m), x)\\n            if mod:\\n                return -1\\n            ret += d\\n        return ret\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport numpy as np\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        a = sorted(np.array(grid).reshape((len(grid)*len(grid[0]),)))\\n        m = a[len(a)//2]\\n        ret = 0\\n        for y in a:\\n            d, mod = divmod(abs(y-m), x)\\n            if mod:\\n                return -1\\n            ret += d\\n        return ret\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450670,
                "title": "basic-c-code",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(n)^2$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int a=0;\\n        vector<int> v;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                v.push_back(grid[i][j]);\\n                if((grid[i][j]%x)!= grid[0][0]%x){\\n                    return -1;\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int b= v[v.size()/2];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                a+=abs(grid[i][j]-b)/x;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        int a=0;\\n        vector<int> v;\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                v.push_back(grid[i][j]);\\n                if((grid[i][j]%x)!= grid[0][0]%x){\\n                    return -1;\\n                }\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int b= v[v.size()/2];\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                a+=abs(grid[i][j]-b)/x;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444780,
                "title": "java-8ms-100-hyperperformance-clear-explanations",
                "content": "# Approach\\n1. Observe the examples\\n    - EG1: 1,10,19, 28 x = 3. We can make all of them equal in 12 steps (all equal to 10).\\n    - EG2: 1, 10, 19,28 x = 9. We can make all of them equal to 10 in 4 steps;\\n    - EG3: 1,10,19, 28 x = 2. We CANNOT make them equal between\\n2. The trick is that ALL numbers must have the same modulo % x. \\n    - [1,10,19, 28] x = 3. All numbers % 3 have modulo 1. Same for  [1, 10, 19,28] x = 9\\n    - [1,10,19, 28] x = 2. [1 and 19] % 2 = 1 and [10,28] % 2 = 0. They have different modulo so they cannot be made equal\\n3. Traverse the matrix and check for their modulo. If the modulo is different, return -1 immediately.     \\n4. As a hyper optimization, we need to know what numbers we have, their count (how many of each) and their prefixSum.\\nSupposing we have this matrix [1,1,1,1,3,3,5,5,5,9,7,9,7,7,7,7] x = 2\\nin an int[3][number_of_unique_numbers] count and store this information\\n    - [1,  3,  5,  7,  9] - what numbers you have\\n    - [4,  6,  9, 14, 16] - their prefix count. How many numbers greater than 5 you got? 16 - 9 = 7.\\n    - [4, 10, 25, 60, 78] - prefix Sum: number[i] * count[i]. \\n5. This table will allow to quickly compute how many steps are needed to make (to raise) ALL number left of i to i and (lower) ALL numbers right of i to match i.\\nEG: Let\\'s look at number 7.\\n    - LEFT:\\n    9 numbers on left of 7. 9*7 = 63. They should be raised to sum of 63.\\n    their sum if 25. So 63 - 25 = 38. 38 / 2 = 19 steps.\\n    - RIGHT: \\n        16-14 = 2 numbers at the right of 7. Their sum is (78-60) = 18.\\n        As they are greater than 7, their sum will need to be lowed to 7 * 2 = 14.\\n        18 - 14 = 4. 4 / 2 (x) = 2.\\n    - So to raise ALL numbers lesser than 7 to 7 we need 19 steps. To lower all numbers greater than 7 we need 2 steps. Total is 21.\\n6. Apply step 5 for all group numbers  \\n\\n# Complexity\\n- Time complexity:$$(n + 2 * k)$$ k - number of unique numbers\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(10001 + 3 * k)$$ k - number of unique numbers\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution { \\n    public int minOperations(int[][] grid, int x) {\\n        int[][] count = getCountAndPrefixNumbers(grid, x);\\n        if (count == null) {\\n            return -1;\\n        }\\n        int minOps = Integer.MAX_VALUE;\\n        int opsOnLeft, opsOnRight;\\n        int n = count[0].length - 1;\\n        for (int i = 1; i <= n; i++) {\\n            opsOnLeft = (count[0][i] * count[1][i-1] - count[2][i-1]) / x;\\n            opsOnRight = (count[2][n] - count[2][i] - (count[0][i] * (count[1][n] - count[1][i]))) / x;\\n            minOps = Math.min(minOps, opsOnLeft + opsOnRight);\\n        }\\n\\n        return minOps;\\n    }\\n\\n    private int[][] getCountAndPrefixNumbers(int[][] grid, int x) {\\n        int unique = 0;\\n        int expectedMod = grid[0][0] % x;\\n        int[] count = new int[10001];\\n        for (int[] row : grid) {\\n            for (int nr: row) {\\n                if (nr % x != expectedMod) {\\n                    return null;\\n                }\\n                if (++count[nr] == 1) {\\n                    unique++;\\n                }\\n            }\\n        }\\n        // row 0 - what number is stored\\n        // row 1 - prefixCount\\n        // row 2 - prefixSum\\n        int[][] countAndPrefix = new int[3][unique + 1];\\n        int insertIndex = 1;\\n        for (int i = 0; i < count.length && unique > 0; i++) {\\n            if (count[i] > 0) {\\n                countAndPrefix[0][insertIndex] = i;\\n                countAndPrefix[1][insertIndex] = countAndPrefix[1][insertIndex - 1] + count[i];\\n                countAndPrefix[2][insertIndex] = countAndPrefix[2][insertIndex - 1] + count[i] * i;\\n                insertIndex++;\\n                unique--;\\n            }\\n        }\\n        return countAndPrefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution { \\n    public int minOperations(int[][] grid, int x) {\\n        int[][] count = getCountAndPrefixNumbers(grid, x);\\n        if (count == null) {\\n            return -1;\\n        }\\n        int minOps = Integer.MAX_VALUE;\\n        int opsOnLeft, opsOnRight;\\n        int n = count[0].length - 1;\\n        for (int i = 1; i <= n; i++) {\\n            opsOnLeft = (count[0][i] * count[1][i-1] - count[2][i-1]) / x;\\n            opsOnRight = (count[2][n] - count[2][i] - (count[0][i] * (count[1][n] - count[1][i]))) / x;\\n            minOps = Math.min(minOps, opsOnLeft + opsOnRight);\\n        }\\n\\n        return minOps;\\n    }\\n\\n    private int[][] getCountAndPrefixNumbers(int[][] grid, int x) {\\n        int unique = 0;\\n        int expectedMod = grid[0][0] % x;\\n        int[] count = new int[10001];\\n        for (int[] row : grid) {\\n            for (int nr: row) {\\n                if (nr % x != expectedMod) {\\n                    return null;\\n                }\\n                if (++count[nr] == 1) {\\n                    unique++;\\n                }\\n            }\\n        }\\n        // row 0 - what number is stored\\n        // row 1 - prefixCount\\n        // row 2 - prefixSum\\n        int[][] countAndPrefix = new int[3][unique + 1];\\n        int insertIndex = 1;\\n        for (int i = 0; i < count.length && unique > 0; i++) {\\n            if (count[i] > 0) {\\n                countAndPrefix[0][insertIndex] = i;\\n                countAndPrefix[1][insertIndex] = countAndPrefix[1][insertIndex - 1] + count[i];\\n                countAndPrefix[2][insertIndex] = countAndPrefix[2][insertIndex - 1] + count[i] * i;\\n                insertIndex++;\\n                unique--;\\n            }\\n        }\\n        return countAndPrefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396009,
                "title": "c-golang-sorting",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<int> nums;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] % x != grid[0][0] % x) return -1;\\n                nums.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int median = nums[nums.size() / 2];\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans += abs(nums[i] - median) / x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc abs(a int) int {\\n    if a > 0 {return a}\\n    return -a\\n}\\n\\nfunc minOperations(grid [][]int, x int) int {\\n    var m, n, ans int = len(grid), len(grid[0]), 0\\n    nums := []int{}\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid[i][j] % x != grid[0][0] % x {return -1}\\n            nums = append(nums, grid[i][j])\\n        }\\n    }\\n    sort.Ints(nums)\\n    var median int = nums[len(nums) / 2]\\n    for i := 0; i < len(nums); i++ {\\n        ans += abs(nums[i] - median) / x\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), ans = 0;\\n        vector<int> nums;\\n        for(int i = 0; i < m; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid[i][j] % x != grid[0][0] % x) return -1;\\n                nums.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        int median = nums[nums.size() / 2];\\n        for(int i = 0; i < nums.size(); i++) {\\n            ans += abs(nums[i] - median) / x;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc abs(a int) int {\\n    if a > 0 {return a}\\n    return -a\\n}\\n\\nfunc minOperations(grid [][]int, x int) int {\\n    var m, n, ans int = len(grid), len(grid[0]), 0\\n    nums := []int{}\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid[i][j] % x != grid[0][0] % x {return -1}\\n            nums = append(nums, grid[i][j])\\n        }\\n    }\\n    sort.Ints(nums)\\n    var median int = nums[len(nums) / 2]\\n    for i := 0; i < len(nums); i++ {\\n        ans += abs(nums[i] - median) / x\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378547,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n         vector<int>v;\\n          int n=grid.size();\\n          int m=grid[0].size();\\n         for (int i=0;i<n;i++)\\n         {\\n             for (int j=0;j<m;j++) v.push_back(grid[i][j]);\\n         }\\n         sort(v.begin(),v.end());\\n         int med=v[n*m/2];\\n         int val=grid[0][0]%x;\\n         long long ans=0;\\n         for (int i=0;i<grid.size();i++)\\n         {\\n             for (int j=0;j<grid[0].size();j++)\\n             { \\n                 if (grid[i][j]%x!=val) return -1;\\n                 ans+=(abs(grid[i][j]-med)/x);\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n         vector<int>v;\\n          int n=grid.size();\\n          int m=grid[0].size();\\n         for (int i=0;i<n;i++)\\n         {\\n             for (int j=0;j<m;j++) v.push_back(grid[i][j]);\\n         }\\n         sort(v.begin(),v.end());\\n         int med=v[n*m/2];\\n         int val=grid[0][0]%x;\\n         long long ans=0;\\n         for (int i=0;i<grid.size();i++)\\n         {\\n             for (int j=0;j<grid[0].size();j++)\\n             { \\n                 if (grid[i][j]%x!=val) return -1;\\n                 ans+=(abs(grid[i][j]-med)/x);\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351336,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v, ps; int n=0, ans=INT_MAX, sum=0;\\n        for(auto z: grid) for(auto t: z){ v.push_back(t); n++; sum+=t; }\\n        sort(v.begin(), v.end()); ps.push_back(v[0]);\\n        for(int i=1;i<n;i++){ ps.push_back(ps[i-1]+v[i]); }\\n        if(v.size()==1) return 0; int hf=v[0]%x;\\n        ans=min(ans, (ps[n-1]-ps[0]-v[0]*(n-1))/x);\\n        for(int i=1;i<n;i++){\\n            if(v[i]%x!=hf) return -1;\\n            int ct=(i*v[i]-ps[i-1])/x+(ps[n-1]-ps[i]-v[i]*(n-1-i))/x;\\n            ans=min(ans, ct);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v, ps; int n=0, ans=INT_MAX, sum=0;\\n        for(auto z: grid) for(auto t: z){ v.push_back(t); n++; sum+=t; }\\n        sort(v.begin(), v.end()); ps.push_back(v[0]);\\n        for(int i=1;i<n;i++){ ps.push_back(ps[i-1]+v[i]); }\\n        if(v.size()==1) return 0; int hf=v[0]%x;\\n        ans=min(ans, (ps[n-1]-ps[0]-v[0]*(n-1))/x);\\n        for(int i=1;i<n;i++){\\n            if(v[i]%x!=hf) return -1;\\n            int ct=(i*v[i]-ps[i-1])/x+(ps[n-1]-ps[i]-v[i]*(n-1-i))/x;\\n            ans=min(ans, ct);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349854,
                "title": "easy-c-solution-by-sorting-median",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFIND THE MEDIAN OF ALL THE ELEMENTS FOR MINIMUM AND IF ANY ELEMENT CANNOT REACH IT BY ADDING OR SUBTRACTING MULTIPLE OF X THEN RETURN -1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSTORE ALL THE ELEMENTS IN AN ARRAY AND SORT IT.FIND THE MIDDLE ELEMENT(MEDIAN) AND FOR EACH ELEMENT CHECK IF IT CAN REACH THE MEDIAN BY THE HELP OF X IF NOT RETURN -1 ELSE ADD THE COST TO ANS.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(M*N) + O(M*NLOG(M*N)) + O(M*N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(M*N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        sort(v.begin(),v.end());\\n        int ts = v.size();\\n        int median = v[ts/2];\\n        for(int i=0;i<ts;i++)\\n        {\\n            if((v[i]-median)%x!=0)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans += abs(v[i]-median)/x;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[i].size();j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n\\n        int ans = 0;\\n        sort(v.begin(),v.end());\\n        int ts = v.size();\\n        int median = v[ts/2];\\n        for(int i=0;i<ts;i++)\\n        {\\n            if((v[i]-median)%x!=0)\\n            {\\n                return -1;\\n            }\\n            else\\n            {\\n                ans += abs(v[i]-median)/x;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3304037,
                "title": "python3-median-and-validity-check-before-median-finding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem tries to optimize the mean absolute error of a target given by the array we receive.\\n\\nThis is done by the median, so we can first flatten the array and then find the median of the given array.\\n\\nHere I do that using a sort, but I think one could do it even faster if one would use something like quickselect so finding the median is then only amortized O(N) instead of O(N*logN).\\n\\nOne thing, that might distinguish my solution to the others is, that I check whether the array is even possible to find one common value using the subtracting and adding method. It is only given, when all numbers are a multiple of x (number given as input) steps away from each other, which we can check by checking whether all of them have the same modulo divided by x.\\n\\nIf that is not the case, we can immeadiately return.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMedian and early checking\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*logN) where N is the amount of elements in the matrix (m *n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(sort)\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\n        # flatten the list using a list comprehension and only keep\\n        # elements on the same steps size (we can reach them from the starting\\n        # number)\\n        ami = len(grid)*len(grid[0])  # computes expected array length\\n        modi = grid[0][0] % x\\n        grid = [ele for row in grid for ele in row if ele % x == modi]\\n\\n        # we did not keep all elements therefore some are unreachable\\n        if len(grid) != ami: return -1\\n\\n        # sort the list\\n        grid.sort()\\n\\n        # make a function to count the operations\\n        def count_operations(target):\\n            return sum(abs(ele-target) // x for ele in grid)\\n\\n        # find the median (if odd length)\\n        if len(grid)&1:\\n            return count_operations(grid[ami//2])\\n        else:\\n            return min(count_operations(grid[ami//2]), count_operations(grid[ami//2-1]))\\n        return \"I am as confused about this result as you.\"\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\n        # flatten the list using a list comprehension and only keep\\n        # elements on the same steps size (we can reach them from the starting\\n        # number)\\n        ami = len(grid)*len(grid[0])  # computes expected array length\\n        modi = grid[0][0] % x\\n        grid = [ele for row in grid for ele in row if ele % x == modi]\\n\\n        # we did not keep all elements therefore some are unreachable\\n        if len(grid) != ami: return -1\\n\\n        # sort the list\\n        grid.sort()\\n\\n        # make a function to count the operations\\n        def count_operations(target):\\n            return sum(abs(ele-target) // x for ele in grid)\\n\\n        # find the median (if odd length)\\n        if len(grid)&1:\\n            return count_operations(grid[ami//2])\\n        else:\\n            return min(count_operations(grid[ami//2]), count_operations(grid[ami//2-1]))\\n        return \"I am as confused about this result as you.\"\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3296026,
                "title": "sort-median-easy-c",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int k) \\n    {\\n        int rows=grid.size(), cols=grid[0].size();\\n        int n=rows*cols;\\n        if(n==1) return 0;\\n        vector<int> v;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++) v.push_back(grid[x][y]);\\n        }\\n        sort(v.begin(),v.end());\\n        int a=v[(n-1)/2], b=v[(n-1)/2+1];\\n        int ops1=0, ops2=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                int d=abs(grid[x][y]-a);\\n                if(d%k) return -1;\\n                ops1+=d/k;\\n            }\\n        }\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                int d=abs(grid[x][y]-b);\\n                if(d%k) return -1;\\n                ops2+=d/k;\\n            }\\n        }\\n        return min(ops1,ops2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int k) \\n    {\\n        int rows=grid.size(), cols=grid[0].size();\\n        int n=rows*cols;\\n        if(n==1) return 0;\\n        vector<int> v;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++) v.push_back(grid[x][y]);\\n        }\\n        sort(v.begin(),v.end());\\n        int a=v[(n-1)/2], b=v[(n-1)/2+1];\\n        int ops1=0, ops2=0;\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                int d=abs(grid[x][y]-a);\\n                if(d%k) return -1;\\n                ops1+=d/k;\\n            }\\n        }\\n        for(int x=0; x<rows; x++)\\n        {\\n            for(int y=0; y<cols; y++)\\n            {\\n                int d=abs(grid[x][y]-b);\\n                if(d%k) return -1;\\n                ops2+=d/k;\\n            }\\n        }\\n        return min(ops1,ops2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295275,
                "title": "c-simple-solution",
                "content": "# Approach\\n1- Sort\\n2- Find Median\\n3- Calculate Steps\\n\\n# Complexity\\n- Time complexity:\\nO(N * log N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinOperations(int[][] grid, int x) {\\n        var l = new List<int>();\\n        foreach(int[] i in grid)\\n            l.AddRange(i);\\n        l = l.OrderBy(c=>c).ToList();\\n        int median = l[l.Count / 2];\\n        int steps = 0;\\n\\n        foreach(int val in l) {\\n            int diff  = Math.Abs(val - median);\\n            if(diff % x != 0)\\n                return -1;\\n            steps += diff / x;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinOperations(int[][] grid, int x) {\\n        var l = new List<int>();\\n        foreach(int[] i in grid)\\n            l.AddRange(i);\\n        l = l.OrderBy(c=>c).ToList();\\n        int median = l[l.Count / 2];\\n        int steps = 0;\\n\\n        foreach(int val in l) {\\n            int diff  = Math.Abs(val - median);\\n            if(diff % x != 0)\\n                return -1;\\n            steps += diff / x;\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3280024,
                "title": "c-beats-99-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>fin;\\n        long long int i,rem=grid[0][0]%x,cnt=0,m=grid.size(),n=grid[0].size(),median;\\n        for(i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n            if (grid[i][j] % x != rem) return -1;\\n            fin.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(fin.begin(),fin.end());\\n        median=fin[(m*n)/2];\\n        for(i=0;i<m*n;i++){\\n            cnt+=(abs(median-fin[i]))/x;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        ios_base::sync_with_stdio(0);\\n        vector<int>fin;\\n        long long int i,rem=grid[0][0]%x,cnt=0,m=grid.size(),n=grid[0].size(),median;\\n        for(i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n            if (grid[i][j] % x != rem) return -1;\\n            fin.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(fin.begin(),fin.end());\\n        median=fin[(m*n)/2];\\n        for(i=0;i<m*n;i++){\\n            cnt+=(abs(median-fin[i]))/x;\\n        }\\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255717,
                "title": "c-easy-solution-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int siz = n*m;\\n        vector<int> tmp(siz);\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                tmp[k++] = grid[i][j];\\n            }\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        if(siz%2!=0)\\n        {\\n            int ele = tmp[(siz-1)/2];\\n            long long sum=0;\\n            for(auto i:tmp)\\n            {\\n                int ch = abs(i-ele);\\n                if(ch%x!=0)\\n                return -1;\\n                sum+=ch/x;\\n            }\\n            return sum;\\n        }\\n        else\\n        {\\n            int ele1 = tmp[siz/2];\\n            int ele2 = tmp[(siz-1)/2];\\n            int ans=INT_MAX;\\n            int sum1=0,sum2=0;\\n            for(auto i:tmp)\\n            {\\n                int ch1 = abs(i-ele1);\\n                int ch2 = abs(i-ele2);\\n                if(ch1%x!=0 || ch2%x!=0)\\n                return -1;\\n                sum1+=ch1/x;\\n                sum2+=ch2/x;\\n            }\\n            ans = min(sum1,sum2);\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n = grid.size();\\n        int m = grid[0].size();\\n        int siz = n*m;\\n        vector<int> tmp(siz);\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                tmp[k++] = grid[i][j];\\n            }\\n        }\\n        sort(tmp.begin(),tmp.end());\\n        if(siz%2!=0)\\n        {\\n            int ele = tmp[(siz-1)/2];\\n            long long sum=0;\\n            for(auto i:tmp)\\n            {\\n                int ch = abs(i-ele);\\n                if(ch%x!=0)\\n                return -1;\\n                sum+=ch/x;\\n            }\\n            return sum;\\n        }\\n        else\\n        {\\n            int ele1 = tmp[siz/2];\\n            int ele2 = tmp[(siz-1)/2];\\n            int ans=INT_MAX;\\n            int sum1=0,sum2=0;\\n            for(auto i:tmp)\\n            {\\n                int ch1 = abs(i-ele1);\\n                int ch2 = abs(i-ele2);\\n                if(ch1%x!=0 || ch2%x!=0)\\n                return -1;\\n                sum1+=ch1/x;\\n                sum2+=ch2/x;\\n            }\\n            ans = min(sum1,sum2);\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249201,
                "title": "take-median-of-the-array",
                "content": "# Intuition\\nFind the median and see if the diff with each element is a multiple of x\\n\\n# Approach\\nif the diff with each element is a multiple of x\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        res=[]\\n        for xx in grid:\\n            for y in xx:\\n                res.append(y)\\n        res.sort()\\n        n= len(res)//2\\n        ans=res[n]\\n\\n        c=0\\n        for xx in res:\\n            if abs(ans-xx)%x==0:\\n                c=c+abs(ans-xx)/x\\n            else:\\n                return (-1)\\n        return int(c)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        res=[]\\n        for xx in grid:\\n            for y in xx:\\n                res.append(y)\\n        res.sort()\\n        n= len(res)//2\\n        ans=res[n]\\n\\n        c=0\\n        for xx in res:\\n            if abs(ans-xx)%x==0:\\n                c=c+abs(ans-xx)/x\\n            else:\\n                return (-1)\\n        return int(c)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217838,
                "title": "no-sorting-solution-use-binary-search",
                "content": "# Intuition\\nFirst if k is the uniform value, we note $\\\\text{grid}_{i,j} \\\\mod x = k \\\\mod x$ for all $1\\\\le i< m, 1\\\\le j< n$. Let this constant be $k_0$. Then the optimal $k$ can be written as $k=k_0+jk$. $j=\\\\argmin_j \\\\sum |\\\\frac{\\\\text{grid}_{i,j}-k_0-jx}{x}|=\\\\sum |\\\\frac{\\\\text{grid}_{i,j}-k_0}{x}-j|$.\\n\\n# Approach\\nSo we seek the $j$ that minimizes the L1 distance to all elements of the transformed grid: $\\\\text{grid}_{i,j}\\\\leftarrow (\\\\text{grid}_{i,j}-\\\\text{grid}_{i,j}\\\\%x)/x$. This is [well-known](https://math.stackexchange.com/questions/113270/the-median-minimizes-the-sum-of-absolute-deviations-the-ell-1-norm) to be the median. However, suppose we don\\'t know this. Instead we only know that as $j$ increases, the sum of distance is decreasing to a minimum then increasing (this is a corollary to the [proof](https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/solutions/1513518/prove-the-median-answer/) for why median). Since the problem gives us $1\\\\le x,\\\\text{grid}_{i,j}\\\\le 10^4$, we can set boundary as $1$ and $10^4$ and do binary search. The time complexity becomes $O(mn \\\\log \\\\max_{i,j}\\\\text{grid}_{i,j})$.\\n\\n# Complexity\\n- Time complexity:\\nO(mn) log(max(grid))\\n\\n- Space complexity:\\nO(mn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int distance(int avg,vector<vector<int>>& grid,int x){\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=abs((grid[i][j]-grid[i][j]%x)/x-avg);\\n            }\\n        }\\n        return ans;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        m=grid.size(); n=grid[0].size();\\n        int last=-1,sum=0,left=INT_MAX,right=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(last!=-1&&grid[i][j]%x!=last)return -1;\\n                last=grid[i][j]%x;\\n                sum+=(grid[i][j]-last)/x;\\n                left=min(left,(grid[i][j]-last)/x);\\n                right=max(right,(grid[i][j]-last)/x);\\n            }\\n        }\\n        int ans=-1;\\n        while(left<=right){//find minimal distance center\\n            int m=(left+right)/2;\\n            int res=distance(m,grid,x);\\n            if(distance(m+1,grid,x)<res){\\n                left=m+1;\\n            }else if(distance(m-1,grid,x)<res){\\n                right=m-1;\\n            }else return res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int m,n;\\n    int distance(int avg,vector<vector<int>>& grid,int x){\\n        int ans=0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                ans+=abs((grid[i][j]-grid[i][j]%x)/x-avg);\\n            }\\n        }\\n        return ans;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        m=grid.size(); n=grid[0].size();\\n        int last=-1,sum=0,left=INT_MAX,right=INT_MIN;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(last!=-1&&grid[i][j]%x!=last)return -1;\\n                last=grid[i][j]%x;\\n                sum+=(grid[i][j]-last)/x;\\n                left=min(left,(grid[i][j]-last)/x);\\n                right=max(right,(grid[i][j]-last)/x);\\n            }\\n        }\\n        int ans=-1;\\n        while(left<=right){//find minimal distance center\\n            int m=(left+right)/2;\\n            int res=distance(m,grid,x);\\n            if(distance(m+1,grid,x)<res){\\n                left=m+1;\\n            }else if(distance(m-1,grid,x)<res){\\n                right=m-1;\\n            }else return res;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3217488,
                "title": "complex-approach-but-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size()*grid[0].size();\\n\\n        vector<int>v(n);\\n        int i=0;\\n        for(auto c:grid)\\n        for(auto w:c)v[i++]=w;\\n        sort(v.begin(),v.end());\\n        i=0;int j=n-1;\\n        int ans=0;\\n        while(i<j){\\n            if((v[j]-v[i])%x==0){\\n                ans+=(v[j]-v[i])/x;\\n            }\\n            else return -1;\\n            i++;j--;\\n        }\\n        if(i==j&&i<n-1&&(v[i+1]-v[i])%x!=0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int n=grid.size()*grid[0].size();\\n\\n        vector<int>v(n);\\n        int i=0;\\n        for(auto c:grid)\\n        for(auto w:c)v[i++]=w;\\n        sort(v.begin(),v.end());\\n        i=0;int j=n-1;\\n        int ans=0;\\n        while(i<j){\\n            if((v[j]-v[i])%x==0){\\n                ans+=(v[j]-v[i])/x;\\n            }\\n            else return -1;\\n            i++;j--;\\n        }\\n        if(i==j&&i<n-1&&(v[i+1]-v[i])%x!=0)return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3188651,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n        vector<int> nums;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                nums.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        int ans=0,mid=nums.size()/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]-nums[mid])%x!=0)\\n                return -1;\\n            else\\n            {\\n                ans+=(abs(nums[i]-nums[mid]))/x;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\nif you like the solution plz upvote.\\n=",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n        vector<int> nums;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                nums.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(nums.begin(),nums.end());\\n        int ans=0,mid=nums.size()/2;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if((nums[i]-nums[mid])%x!=0)\\n                return -1;\\n            else\\n            {\\n                ans+=(abs(nums[i]-nums[mid]))/x;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186924,
                "title": "pretty-straight-forward-solution",
                "content": "# Intuition\\n3 steps:\\nFlatten, find good target value, see if it is possible to get to it\\n\\n# Approach\\n1. flatten `grid`\\n2. get `median`\\n3. adjust `median` according to `x`\\n4. count `steps` if everything ok\\n\\n# Complexity\\n- Time complexity:\\n I guess it is ~ $$O(4 \\\\cdot n\\\\cdot m)$$ \\n\\n- Space complexity:\\nWho really knows\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n       \\n        # flatten grid to list, we dont need greed anyway\\n        fnum = [num for row in grid for num in row]\\n        mu = None\\n\\n        while True:            \\n            # edge case\\n            if len(fnum) == 1:\\n                return 0\\n            \\n            # first median guess \\n            if not mu:\\n                mu = int(round(self.median(fnum)))\\n            \\n            # difference between `mu` and each element\\n            diff = [int(abs(n-mu)) for n in fnum]\\n\\n            # we can\\'t correct if element `diff` < `x`\\n            # so adjust target value `mu` accordingly\\n            # and repeat\\n            if min(diff) < x and min(diff) != 0:\\n                mu -= min(diff)\\n                continue\\n\\n            # count steps for each element to reach target `mu` by `x`\\n            div_num = [i//x for i in diff]\\n\\n            # check if there any remainders after devision by `x`\\n            remains = [i % x for i in diff]\\n\\n            # if remainders still there then there is nothing we can do\\n            if sum(remains):\\n                return -1\\n\\n            # sum steps for each element and return\\n            return int(sum(div_num))\\n\\n\\n    def median(self, lst):\\n        n = len(lst)\\n        s = sorted(lst)\\n        return (s[n//2-1]/2.0+s[n//2]/2.0, s[n//2])[n % 2] if n else None\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n       \\n        # flatten grid to list, we dont need greed anyway\\n        fnum = [num for row in grid for num in row]\\n        mu = None\\n\\n        while True:            \\n            # edge case\\n            if len(fnum) == 1:\\n                return 0\\n            \\n            # first median guess \\n            if not mu:\\n                mu = int(round(self.median(fnum)))\\n            \\n            # difference between `mu` and each element\\n            diff = [int(abs(n-mu)) for n in fnum]\\n\\n            # we can\\'t correct if element `diff` < `x`\\n            # so adjust target value `mu` accordingly\\n            # and repeat\\n            if min(diff) < x and min(diff) != 0:\\n                mu -= min(diff)\\n                continue\\n\\n            # count steps for each element to reach target `mu` by `x`\\n            div_num = [i//x for i in diff]\\n\\n            # check if there any remainders after devision by `x`\\n            remains = [i % x for i in diff]\\n\\n            # if remainders still there then there is nothing we can do\\n            if sum(remains):\\n                return -1\\n\\n            # sum steps for each element and return\\n            return int(sum(div_num))\\n\\n\\n    def median(self, lst):\\n        n = len(lst)\\n        s = sorted(lst)\\n        return (s[n//2-1]/2.0+s[n//2]/2.0, s[n//2])[n % 2] if n else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3180760,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* <-.#.time:2023.2.13 \\u5468\\u4E00 21:57 #.0377 */\\nint comparator(const void* a, const void* b) {\\n    return *(int*)a - *(int*)b;\\n}\\nint minOperations(int** grid, int m, int* n, int x) { \\n    int len = m * (*n);\\n    int* elems = malloc(len * sizeof(int));\\n    memset(elems, 0, (len * sizeof(int)));\\n    int c = 0;\\n    int curMod = grid[0][0] % x;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < *n; j++) {\\n            elems[c++] = grid[i][j];\\n            if (curMod != grid[i][j] % x) return -1;\\n        }\\n    }\\n\\n    qsort(elems, len, sizeof(int), comparator);\\n\\n    int median = elems[len / 2];\\n    int minMoves = 0;\\n    for (int j = 0; j < len; j++) {\\n        minMoves += abs(median - elems[j]) / x;\\n    }\\n    return minMoves;\\n}\\n// which involves \\'\\'\\u540C\\u4F59\\u5B9A\\u7406+\\u4E2D\\u4F4D\\u6570\\u5B9A\\u7406:\\'\\'! \\u8FD9\\u7C7B\\u9898\\uFF08\\u6C42\\u89E3minOperations/minMoves\\uFF09\\u8FD8\\u662F\\u6BD4\\u8F83\\u5E38\\u89C1\\u7684\\uFF01\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/* <-.#.time:2023.2.13 \\u5468\\u4E00 21:57 #.0377 */\\nint comparator(const void* a, const void* b) {\\n    return *(int*)a - *(int*)b;\\n}\\nint minOperations(int** grid, int m, int* n, int x) { \\n    int len = m * (*n);\\n    int* elems = malloc(len * sizeof(int));\\n    memset(elems, 0, (len * sizeof(int)));\\n    int c = 0;\\n    int curMod = grid[0][0] % x;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < *n; j++) {\\n            elems[c++] = grid[i][j];\\n            if (curMod != grid[i][j] % x) return -1;\\n        }\\n    }\\n\\n    qsort(elems, len, sizeof(int), comparator);\\n\\n    int median = elems[len / 2];\\n    int minMoves = 0;\\n    for (int j = 0; j < len; j++) {\\n        minMoves += abs(median - elems[j]) / x;\\n    }\\n    return minMoves;\\n}\\n// which involves \\'\\'\\u540C\\u4F59\\u5B9A\\u7406+\\u4E2D\\u4F4D\\u6570\\u5B9A\\u7406:\\'\\'! \\u8FD9\\u7C7B\\u9898\\uFF08\\u6C42\\u89E3minOperations/minMoves\\uFF09\\u8FD8\\u662F\\u6BD4\\u8F83\\u5E38\\u89C1\\u7684\\uFF01\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148763,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& g, int x) {\\n        vector<int> a;\\n        for(auto t: g)\\n            for(auto tt: t)\\n                a.push_back(tt);\\n        sort(a.begin(),a.end());\\n        set<int> s;\\n        for(auto t: a)\\n            s.insert(t%x);\\n        if(s.size()>1)\\n            return -1;\\n        int k=a.size()/2,ss=0;\\n        for(auto t: a)\\n            ss+=(abs(t-a[k]))/x;\\n        return ss;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& g, int x) {\\n        vector<int> a;\\n        for(auto t: g)\\n            for(auto tt: t)\\n                a.push_back(tt);\\n        sort(a.begin(),a.end());\\n        set<int> s;\\n        for(auto t: a)\\n            s.insert(t%x);\\n        if(s.size()>1)\\n            return -1;\\n        int k=a.size()/2,ss=0;\\n        for(auto t: a)\\n            ss+=(abs(t-a[k]))/x;\\n        return ss;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101584,
                "title": "easy-best-solution-in-c",
                "content": "# Code\\n**Please Upvote if u  liked my Solution**\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int> vec,int median,int x){\\n        int diff=0,minOper=0;\\n        for(auto it:vec){\\n            diff=abs(it-vec[median]);\\n            if(diff%x!=0)\\n                return -1;\\n            minOper+=diff/x;\\n        }\\n        return minOper;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> vec;\\n        for(auto it:grid)\\n            for(auto gt:it)\\n                vec.push_back(gt);\\n        sort(vec.begin(),vec.end());\\n        int size=vec.size(),median=size/2;\\n        return helper(vec,median,x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> vec,int median,int x){\\n        int diff=0,minOper=0;\\n        for(auto it:vec){\\n            diff=abs(it-vec[median]);\\n            if(diff%x!=0)\\n                return -1;\\n            minOper+=diff/x;\\n        }\\n        return minOper;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> vec;\\n        for(auto it:grid)\\n            for(auto gt:it)\\n                vec.push_back(gt);\\n        sort(vec.begin(),vec.end());\\n        int size=vec.size(),median=size/2;\\n        return helper(vec,median,x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097939,
                "title": "c-easy-simple-solution-o-n",
                "content": "# Don\\'t forget to give it a upvote if you like the solution..\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int k) {\\n        vector<int> g;\\n        for( int i =0; i< grid.size() ; i++)\\n        {\\n            for( int j=0; j< grid[i].size(); j++)\\n            {\\n                g.push_back( grid[i][j]);\\n            }\\n        }\\n        sort( g.begin(), g.end());\\n     int n = g.size(), ans=0, midEle;\\n     if(n&1){\\n         midEle = g[n/2];\\n         for(auto x : g)\\n         {\\n             int diff = abs( x - midEle);\\n             if( diff%k!=0)return -1;\\n             else ans+= diff/k;\\n         }\\n\\n     }else{\\n        //  midEle = (g[n/2]+ g[(n/2)-1])/2;\\n         midEle = (g[n/2]);\\n\\n         for(auto x : g)\\n         {\\n             int diff = abs( x - midEle);\\n             if( diff%k!=0)return -1;\\n             else ans+= diff/k;\\n         }\\n\\n     } \\n      return ans;  \\n    }\\n};\\n```\\n\\n![you-upvote-me.jpg](https://assets.leetcode.com/users/images/bb3ec696-73ac-4e05-8959-33e011019ea3_1674653296.9325564.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int k) {\\n        vector<int> g;\\n        for( int i =0; i< grid.size() ; i++)\\n        {\\n            for( int j=0; j< grid[i].size(); j++)\\n            {\\n                g.push_back( grid[i][j]);\\n            }\\n        }\\n        sort( g.begin(), g.end());\\n     int n = g.size(), ans=0, midEle;\\n     if(n&1){\\n         midEle = g[n/2];\\n         for(auto x : g)\\n         {\\n             int diff = abs( x - midEle);\\n             if( diff%k!=0)return -1;\\n             else ans+= diff/k;\\n         }\\n\\n     }else{\\n        //  midEle = (g[n/2]+ g[(n/2)-1])/2;\\n         midEle = (g[n/2]);\\n\\n         for(auto x : g)\\n         {\\n             int diff = abs( x - midEle);\\n             if( diff%k!=0)return -1;\\n             else ans+= diff/k;\\n         }\\n\\n     } \\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056829,
                "title": "python-one-pass-o-nlogn",
                "content": "# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m,n = len(grid), len(grid[0])\\n        grid = [grid[i][j] for i in range(m) for j in range(n)]\\n        mods = set()\\n        for i in range(len(grid)):\\n            mods.add(grid[i]%x)\\n        if len(mods) > 1: return -1\\n        grid.sort()\\n        tn = len(grid)\\n        cur = 0\\n        for i in range(tn):\\n            cur += (grid[i] - grid[0])//x\\n        res = cur\\n        for i in range(1,tn):\\n            delta = (grid[i] - grid[i-1])//x\\n            cur += delta*i - delta*(tn-i)\\n            res = min(res, cur)\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m,n = len(grid), len(grid[0])\\n        grid = [grid[i][j] for i in range(m) for j in range(n)]\\n        mods = set()\\n        for i in range(len(grid)):\\n            mods.add(grid[i]%x)\\n        if len(mods) > 1: return -1\\n        grid.sort()\\n        tn = len(grid)\\n        cur = 0\\n        for i in range(tn):\\n            cur += (grid[i] - grid[0])//x\\n        res = cur\\n        for i in range(1,tn):\\n            delta = (grid[i] - grid[i-1])//x\\n            cur += delta*i - delta*(tn-i)\\n            res = min(res, cur)\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008479,
                "title": "simple-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        new_grid = [x for row in grid for x in row]\\n        new_grid.sort()\\n        median = 0\\n        if(len(new_grid)%2 == 0):\\n            median = new_grid[(len(new_grid)//2)-1]\\n        else:\\n            median = new_grid[len(new_grid)//2]\\n        result = [abs(elem - median) for elem in new_grid]\\n        for i in result:\\n            if(i%x != 0):\\n                return -1\\n        return sum(result)//x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        new_grid = [x for row in grid for x in row]\\n        new_grid.sort()\\n        median = 0\\n        if(len(new_grid)%2 == 0):\\n            median = new_grid[(len(new_grid)//2)-1]\\n        else:\\n            median = new_grid[len(new_grid)//2]\\n        result = [abs(elem - median) for elem in new_grid]\\n        for i in result:\\n            if(i%x != 0):\\n                return -1\\n        return sum(result)//x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976618,
                "title": "c-surprised-my-naive-solution-faster-than-92",
                "content": "I thought it would be naive and inefficient to calculate median by allocating new memory to store the array and using stl sort, instead of sorting the existing array and then searching meidan with 2d array shenanigans but it worked out I guess.\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& g, int x) {\\n        // take gcd of (x, each difference)\\n        // if not equal to x return -1;\\n        int s = g[0][0];\\n        vector<int> a;\\n        for (int i = 0; i < g.size(); ++i){\\n            for (int y = 0; y < g[0].size(); ++y){\\n                int dif = s - g[i][y];\\n                if (dif != 0 && gcd(x, dif) != x) return -1;\\n                a.push_back(g[i][y]);\\n            }\\n        }\\n        // naive way to find median\\n        sort(a.begin(), a.end());\\n        int median = a[a.size() / 2];\\n        \\n        // find difference to median for each one in multiples of x\\n        int ans = 0;\\n        for (int i = 0; i < g.size(); ++i){\\n            for (int y = 0; y < g[0].size(); ++y){\\n                ans += (abs(g[i][y] - median) / x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& g, int x) {\\n        // take gcd of (x, each difference)\\n        // if not equal to x return -1;\\n        int s = g[0][0];\\n        vector<int> a;\\n        for (int i = 0; i < g.size(); ++i){\\n            for (int y = 0; y < g[0].size(); ++y){\\n                int dif = s - g[i][y];\\n                if (dif != 0 && gcd(x, dif) != x) return -1;\\n                a.push_back(g[i][y]);\\n            }\\n        }\\n        // naive way to find median\\n        sort(a.begin(), a.end());\\n        int median = a[a.size() / 2];\\n        \\n        // find difference to median for each one in multiples of x\\n        int ans = 0;\\n        for (int i = 0; i < g.size(); ++i){\\n            for (int y = 0; y < g[0].size(); ++y){\\n                ans += (abs(g[i][y] - median) / x);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928773,
                "title": "proper-explanation-with-comments",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        \\n        // first of all we store all the elements in a 1D vector\\n        vector<int>v;\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++) \\n            {\\n                \\n                v.push_back(grid[i][j]);\\n                \\n            }\\n        }\\n        \\n        sort(v.begin(),v.end());  // sorting the vector in order to find the mid element.\\n        int mid=v[v.size()/2]; // finding the mid element value;\\n        for( auto i:v)\\n        {\\n            if(abs(mid-i)%x!=0) return -1;  // Imp step -> if we are not able to cover the gap with the x then return -1;\\n            ans+=abs(mid-i); // else add the difference to the ans;\\n            \\n        }\\n        return ans/x;  // finally divide the ans by x since we can add or sub x at a time;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        \\n        // first of all we store all the elements in a 1D vector\\n        vector<int>v;\\n        int ans=0;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++) \\n            {\\n                \\n                v.push_back(grid[i][j]);\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2925213,
                "title": "beats-95-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst Check all elements of Grid must give same remender then only it is possible other wise return -1 directly\\n1. # Approach\\nJust store all elements in one array\\nsort them \\nconverting all numbers to median will take less steps \\nSo we convert all to median\\nif arr size is odd we will get 2 medians \\nso check with both medians return minimum one\\notherwise only one median\\n**EDGE CASE : only one element return 0**\\nDry RUN ONCE\\nDefinately u will get it\\nBEST OF LUCK BUDDY\\nHappy Coding\\n\\n# Complexity\\n- Time complexity:\\ntotal elemnts = m * n = N ;\\nsorting  = O(N) + Nlog(N) + O(N);\\ntraverse + sort + traverse\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n        vector<int> store;\\n        int c = grid[0][0] % x;\\n        for(int i=0  ; i < grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j < grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] % x != c)\\n                {\\n                    return  -1;\\n                }\\n                store.push_back(grid[i][j]);\\n            }\\n        }\\n        int  n = store.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        int res = 0;\\n        sort(store.begin() , store.end());\\n        if(n % 2)\\n        {\\n            int t1 = 0;\\n            int t2 = 0;\\n            int m1 = store[n/2];\\n            int m2 = store[(n/2)+1];\\n            for(int i=0 ; i < n ; i++)\\n            {\\n                t1 += abs(m1 - store[i]) / x ;\\n            }\\n            for(int i=0 ; i < n ; i++)\\n            {\\n                t2 += abs(m2 - store[i]) / x ;\\n            }\\n           res = min(t1 , t2);\\n        }\\n        else\\n        {\\n            int m1 = store[n/2];\\n            for(int i= 0 ; i < n ; i++)\\n            {\\n                res += abs(m1 - store[i]) / x ;\\n            }        \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n    {\\n        vector<int> store;\\n        int c = grid[0][0] % x;\\n        for(int i=0  ; i < grid.size() ; i++)\\n        {\\n            for(int j = 0 ; j < grid[0].size() ; j++)\\n            {\\n                if(grid[i][j] % x != c)\\n                {\\n                    return  -1;\\n                }\\n                store.push_back(grid[i][j]);\\n            }\\n        }\\n        int  n = store.size();\\n        if(n==1)\\n        {\\n            return 0;\\n        }\\n        int res = 0;\\n        sort(store.begin() , store.end());\\n        if(n % 2)\\n        {\\n            int t1 = 0;\\n            int t2 = 0;\\n            int m1 = store[n/2];\\n            int m2 = store[(n/2)+1];\\n            for(int i=0 ; i < n ; i++)\\n            {\\n                t1 += abs(m1 - store[i]) / x ;\\n            }\\n            for(int i=0 ; i < n ; i++)\\n            {\\n                t2 += abs(m2 - store[i]) / x ;\\n            }\\n           res = min(t1 , t2);\\n        }\\n        else\\n        {\\n            int m1 = store[n/2];\\n            for(int i= 0 ; i < n ; i++)\\n            {\\n                res += abs(m1 - store[i]) / x ;\\n            }        \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2899724,
                "title": "java-solution-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n*m*log(n*m))\\nwhere n*m is the number of elements in the grid.\\n\\n- Space complexity:\\nO(n*m)\\nwehre n*m is the number of elements in the grid.\\n\\n# Code\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] arr = new int[m*n];\\n        int k = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                arr[k] = grid[i][j];\\n                k++;\\n            }\\n        \\n        Arrays.sort(arr);\\n\\n        int med1 = (m*n)/2;\\n        int med2 = -1;\\n        int ans1 = 0;\\n        int ans2 = 0;\\n\\n        if((n*m)%2 == 0)\\n            med2 = med1-1;\\n\\n        if(med2>=0)\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < m; j++){\\n                    ans1 += Math.abs(arr[med1]-grid[i][j]);\\n                    ans2 += Math.abs(arr[med2]-grid[i][j]);\\n                }\\n        else\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < m; j++)\\n                    ans1 += Math.abs(arr[med1]-grid[i][j]);\\n\\n        for(int i = 1; i < m*n; i++)\\n            if((arr[i]-arr[0])%x != 0)\\n                return -1;\\n\\n        if(ans1%x != 0)\\n            return -1;\\n        else{\\n            if(med2>=0)\\n                return Math.min(ans1/x, ans2/x);\\n            return ans1/x;\\n        }\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int n = grid.length;\\n        int m = grid[0].length;\\n        int[] arr = new int[m*n];\\n        int k = 0;\\n\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < m; j++){\\n                arr[k] = grid[i][j];\\n                k++;\\n            }\\n        \\n        Arrays.sort(arr);\\n\\n        int med1 = (m*n)/2;\\n        int med2 = -1;\\n        int ans1 = 0;\\n        int ans2 = 0;\\n\\n        if((n*m)%2 == 0)\\n            med2 = med1-1;\\n\\n        if(med2>=0)\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < m; j++){\\n                    ans1 += Math.abs(arr[med1]-grid[i][j]);\\n                    ans2 += Math.abs(arr[med2]-grid[i][j]);\\n                }\\n        else\\n            for(int i = 0; i < n; i++)\\n                for(int j = 0; j < m; j++)\\n                    ans1 += Math.abs(arr[med1]-grid[i][j]);\\n\\n        for(int i = 1; i < m*n; i++)\\n            if((arr[i]-arr[0])%x != 0)\\n                return -1;\\n\\n        if(ans1%x != 0)\\n            return -1;\\n        else{\\n            if(med2>=0)\\n                return Math.min(ans1/x, ans2/x);\\n            return ans1/x;\\n        }\\n    }\\n}\\n// *** UP-VOTE IF HELPFUL ***\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850403,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x)\\n    {\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        Collections.sort(list);\\n        \\n        int count=0;\\n        int median=list.get(list.size()/2);\\n        \\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff=Math.abs(median-list.get(i));\\n            if(diff%x==0)\\n            {\\n                count+=(diff/x);\\n            }\\n            else \\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x)\\n    {\\n        List<Integer> list=new ArrayList<>();\\n        \\n        for(int i=0;i<grid.length;i++)\\n        {\\n            for(int j=0;j<grid[0].length;j++)\\n            {\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        Collections.sort(list);\\n        \\n        int count=0;\\n        int median=list.get(list.size()/2);\\n        \\n        for(int i=0;i<list.size();i++)\\n        {\\n            int diff=Math.abs(median-list.get(i));\\n            if(diff%x==0)\\n            {\\n                count+=(diff/x);\\n            }\\n            else \\n            {\\n                return -1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788689,
                "title": "intution-behind-median-based-solution",
                "content": "Intution:\\n\\nThe median of an array is the middle value. You find out the distance between each value of the grid and the middle. You have to cover this distance using \"x\" number of units, either by moving away from the middle value or towards it.  The reason you choose the middle value is that it is much less costly for elements to approach the middle from both ends of array than approach elements at extreme ends.\\n![image](https://assets.leetcode.com/users/images/4ce2dfe7-cc41-4258-bf4a-a6d75e586efa_1667821014.2633944.png)\\n\\nLook at GRID elements in a linear sorted form: [2. 4, 6, 8]\\nMedian is the mean of 4,6 = 5 which is not in the array. So we look at both these numbers, then find which will be less costly (take minimun number of steps)\\n2, 4,        6, 8\\n m1=  median1 =4\\n Find the absolute difference between each array number and median\\n** abs(2-4, 6-4, 8-4)\\n abs_diff = [2, 2, 4]**\\n Now there are 2 possibilities:\\n  1. Either you cannot cover this distance in x steps,  here **x = 2**\\n   then you can check this by: modding each element of abs_diff by x\\n   If you cannot travel each distance in abs_diff by moving x steps back or forth\\n   the the abs_diff %  x will not be zero, since there will be some untravelled distance. Return -1 in this case\\n   \\n   This is not the case for x=2, so we move to step2\\n   \\n   2. Yes, you CAN travel this distance in x steps:, x=2\\n **  abs_diff mod x == 0\\n Divide abs_diff by x=2 to see how many steps to take to travel abs_diff\\n \\n   abs_diff = [2, 2, 4] // x = [1,1,2]\\n   ![image](https://assets.leetcode.com/users/images/7d483f01-6b22-4c63-b2fb-524f66a9aace_1667820968.2743363.png)\\n\\n ** *You have to travel x=2 steps 1 time, then 1 time, then 2 times for 0th, 2nd, 3rd element in the array***\\n ans= 1 + 1+ 2 =  5 steps or operations\\n   **\\n   \\n   You can repat the solution for 6 and see why it fails!",
                "solutionTags": [
                    "Python"
                ],
                "code": "Intution:\\n\\nThe median of an array is the middle value. You find out the distance between each value of the grid and the middle. You have to cover this distance using \"x\" number of units, either by moving away from the middle value or towards it.  The reason you choose the middle value is that it is much less costly for elements to approach the middle from both ends of array than approach elements at extreme ends.\\n![image](https://assets.leetcode.com/users/images/4ce2dfe7-cc41-4258-bf4a-a6d75e586efa_1667821014.2633944.png)\\n\\nLook at GRID elements in a linear sorted form: [2. 4, 6, 8]\\nMedian is the mean of 4,6 = 5 which is not in the array. So we look at both these numbers, then find which will be less costly (take minimun number of steps)\\n2, 4,        6, 8\\n m1=  median1 =4\\n Find the absolute difference between each array number and median\\n** abs(2-4, 6-4, 8-4)\\n abs_diff = [2, 2, 4]**\\n Now there are 2 possibilities:\\n  1. Either you cannot cover this distance in x steps,  here **x = 2**\\n   then you can check this by: modding each element of abs_diff by x\\n   If you cannot travel each distance in abs_diff by moving x steps back or forth\\n   the the abs_diff %  x will not be zero, since there will be some untravelled distance. Return -1 in this case\\n   \\n   This is not the case for x=2, so we move to step2\\n   \\n   2. Yes, you CAN travel this distance in x steps:, x=2\\n **  abs_diff mod x == 0\\n Divide abs_diff by x=2 to see how many steps to take to travel abs_diff\\n \\n   abs_diff = [2, 2, 4] // x = [1,1,2]\\n   ![image](https://assets.leetcode.com/users/images/7d483f01-6b22-4c63-b2fb-524f66a9aace_1667820968.2743363.png)\\n\\n ** *You have to travel x=2 steps 1 time, then 1 time, then 2 times for 0th, 2nd, 3rd element in the array***\\n ans= 1 + 1+ 2 =  5 steps or operations\\n   **\\n   \\n   You can repat the solution for 6 and see why it fails!",
                "codeTag": "Unknown"
            },
            {
                "id": 2770667,
                "title": "simple-greedy-solution-with-comments-python",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def minOperations(self, grid, x):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        # it is always best to try to get all the numbers to be equal the median\\n        # value, which is the value separating the highest from lowest values.\\n        # we extract the grid into a 1D array and sort it\\n        linear_grid = [cell for row in grid for cell in row]\\n        linear_grid.sort()\\n        # extract the median which is the middle value\\n        median = linear_grid[len(linear_grid) // 2]\\n\\n        operations = 0\\n        for num in linear_grid:\\n            if num != median:\\n                diff = abs(median - num)\\n                # if the difference between a number in the array and the median cannot\\n                # be divided by x, return -1 because this number will never be = median\\n                if diff % x != 0:\\n                    return -1\\n\\n                # increment the number of operations by the number of times we have to\\n                # add or subtract x from num to get to median\\n                operations += diff // x\\n\\n        return operations\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def minOperations(self, grid, x):\\n        \"\"\"\\n        :type grid: List[List[int]]\\n        :type x: int\\n        :rtype: int\\n        \"\"\"\\n        # it is always best to try to get all the numbers to be equal the median\\n        # value, which is the value separating the highest from lowest values.\\n        # we extract the grid into a 1D array and sort it\\n        linear_grid = [cell for row in grid for cell in row]\\n        linear_grid.sort()\\n        # extract the median which is the middle value\\n        median = linear_grid[len(linear_grid) // 2]\\n\\n        operations = 0\\n        for num in linear_grid:\\n            if num != median:\\n                diff = abs(median - num)\\n                # if the difference between a number in the array and the median cannot\\n                # be divided by x, return -1 because this number will never be = median\\n                if diff % x != 0:\\n                    return -1\\n\\n                # increment the number of operations by the number of times we have to\\n                # add or subtract x from num to get to median\\n                operations += diff // x\\n\\n        return operations\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739336,
                "title": "cpp-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n{\\n    vector<int>v;\\n\\tfor(int i=0;i<grid.size();i++)\\n\\t{\\n\\t    for(int j=0;j<grid[i].size();j++)\\n\\t\\t{\\n\\t\\t    v.push_back(grid[i][j]);\\t\\n\\t    }\\t\\n\\t}       \\n\\tsort(v.begin(),v.end()); \\n\\tint mid = v[v.size()/2];  //the main idea is to make all the element equal to mid element by adding or subtraction of x    \\n    int mod = mid % x;\\n\\tint ans=0;\\n\\tfor(int i=0;i<v.size();i++)\\n\\t{\\n        if((v[i]%x)!=mod)\\n        return -1;\\n        \\n\\t\\tint temp = abs(mid - v[i]);\\n\\t\\tans = ans + temp/x;\\n\\t}\\n\\treturn ans;\\n}\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) \\n{\\n    vector<int>v;\\n\\tfor(int i=0;i<grid.size();i++)\\n\\t{\\n\\t    for(int j=0;j<grid[i].size();j++)\\n\\t\\t{\\n\\t\\t    v.push_back(grid[i][j]);\\t\\n\\t    }\\t\\n\\t}       \\n\\tsort(v.begin(),v.end()); \\n\\tint mid = v[v.size()/2];  //the main idea is to make all the element equal to mid element by adding or subtraction of x    \\n    int mod = mid % x;\\n\\tint ans=0;\\n\\tfor(int i=0;i<v.size();i++)\\n\\t{\\n        if((v[i]%x)!=mod)\\n        return -1;\\n        \\n\\t\\tint temp = abs(mid - v[i]);\\n\\t\\tans = ans + temp/x;\\n\\t}\\n\\treturn ans;\\n}\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702205,
                "title": "rust-solution",
                "content": "The grid value can only be changed by x, so grid value % x should be the same value.\\nIf every grid value % x is not the same value, the answer is -1. \\n\\n```\\nimpl Solution {\\n    pub fn min_operations(grid: Vec<Vec<i32>>, x: i32) -> i32 {\\n        let n = grid.len();\\n        let m = grid[0].len();\\n        let a = grid[0][0] % x;\\n        let nm = n*m;\\n        let mut arr = vec![0;nm];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if grid[i][j] % x != a {\\n                    return -1\\n                }\\n                arr[i*m+j] = grid[i][j];\\n            }\\n        }\\n        arr.sort();\\n\\n        let mid = nm / 2;\\n        let mut result = i32::max_value();\\n        for i in mid..std::cmp::min(nm, mid+3) {\\n            let mut temp = 0;\\n            let v1 = arr[i];\\n\\n            for &v2 in &arr {\\n                temp += (v1-v2).abs() / x;\\n            }\\n            result = result.min(temp);\\n        }\\n        result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_operations(grid: Vec<Vec<i32>>, x: i32) -> i32 {\\n        let n = grid.len();\\n        let m = grid[0].len();\\n        let a = grid[0][0] % x;\\n        let nm = n*m;\\n        let mut arr = vec![0;nm];\\n        for i in 0..n {\\n            for j in 0..m {\\n                if grid[i][j] % x != a {\\n                    return -1\\n                }\\n                arr[i*m+j] = grid[i][j];\\n            }\\n        }\\n        arr.sort();\\n\\n        let mid = nm / 2;\\n        let mut result = i32::max_value();\\n        for i in mid..std::cmp::min(nm, mid+3) {\\n            let mut temp = 0;\\n            let v1 = arr[i];\\n\\n            for &v2 in &arr {\\n                temp += (v1-v2).abs() / x;\\n            }\\n            result = result.min(temp);\\n        }\\n        result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2678770,
                "title": "c",
                "content": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minOperations(int** grid, int gridSize, int* gridColSize, int x){\\n    int* data = malloc( gridSize * (*gridColSize) * sizeof(int) );\\n    int idx = 0;\\n    for(int i = 0; i < gridSize; i++){\\n        for(int j = 0; j < *gridColSize; j++){\\n            if((grid[i][j] - grid[0][0]) % x )\\n                return -1;\\n            data[idx] = grid[i][j];\\n            idx++;\\n        }\\n    }\\n    qsort(data, idx, sizeof(int), cmpfunc);\\n    if(idx %2 == 1){\\n        int Opt = 0;\\n        for(int i = 0; i < idx/2; i++){\\n            Opt += ( data[idx/2] - data[i] )/x;\\n        }\\n        for(int i = idx/2; i < idx; i++){\\n            Opt +=  (data[i] - data[idx/2] )/x;\\n        }\\n        \\n        return Opt;\\n    }\\n    else{\\n        int Opt1 = 0;\\n        for(int i = 0; i < idx/2; i++){\\n            Opt1 += ( data[idx/2] - data[i] )/x;\\n        }\\n        for(int i = idx/2; i < idx; i++){\\n            Opt1 +=  (data[i] - data[idx/2] )/x;\\n        }\\n    \\n        int Opt2 = 0;\\n        for(int i = 0; i < idx/2 - 1; i++){\\n            Opt2 += ( data[idx/2 - 1] - data[i] )/x;\\n        }\\n        for(int i = idx/2-1; i < idx; i++){\\n            Opt2 +=  (data[i] - data[idx/2 - 1] )/x;\\n        }\\n        \\n        if(Opt1 <= Opt2)\\n            return Opt1;\\n        else\\n            return Opt2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpfunc(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint minOperations(int** grid, int gridSize, int* gridColSize, int x){\\n    int* data = malloc( gridSize * (*gridColSize) * sizeof(int) );\\n    int idx = 0;\\n    for(int i = 0; i < gridSize; i++){\\n        for(int j = 0; j < *gridColSize; j++){\\n            if((grid[i][j] - grid[0][0]) % x )\\n                return -1;\\n            data[idx] = grid[i][j];\\n            idx++;\\n        }\\n    }\\n    qsort(data, idx, sizeof(int), cmpfunc);\\n    if(idx %2 == 1){\\n        int Opt = 0;\\n        for(int i = 0; i < idx/2; i++){\\n            Opt += ( data[idx/2] - data[i] )/x;\\n        }\\n        for(int i = idx/2; i < idx; i++){\\n            Opt +=  (data[i] - data[idx/2] )/x;\\n        }\\n        \\n        return Opt;\\n    }\\n    else{\\n        int Opt1 = 0;\\n        for(int i = 0; i < idx/2; i++){\\n            Opt1 += ( data[idx/2] - data[i] )/x;\\n        }\\n        for(int i = idx/2; i < idx; i++){\\n            Opt1 +=  (data[i] - data[idx/2] )/x;\\n        }\\n    \\n        int Opt2 = 0;\\n        for(int i = 0; i < idx/2 - 1; i++){\\n            Opt2 += ( data[idx/2 - 1] - data[i] )/x;\\n        }\\n        for(int i = idx/2-1; i < idx; i++){\\n            Opt2 +=  (data[i] - data[idx/2 - 1] )/x;\\n        }\\n        \\n        if(Opt1 <= Opt2)\\n            return Opt1;\\n        else\\n            return Opt2;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2665809,
                "title": "o-mn-log-mn",
                "content": "# Intuition\\nThe target number (the possible unique value) is the middle number in the sorted array. If the differences of that number and other elements in the array are divisible by x, sum of those differences is the answer, otherwise the answer is -1.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(mnlog(mn))\\n\\n- Space complexity:\\n- O(mn)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        mn=float(\\'inf\\')\\n        numlist=[]\\n        for i in range(m):\\n            for j in range(n):\\n                numlist.append(grid[i][j])\\n        numlist.sort()\\n        target=numlist[m*n//2]\\n        res=0\\n        for n in numlist:\\n            temp=abs(n-target)\\n            if temp%x!=0:\\n                return -1\\n            res+=temp//x\\n        return res\\n               \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        mn=float(\\'inf\\')\\n        numlist=[]\\n        for i in range(m):\\n            for j in range(n):\\n                numlist.append(grid[i][j])\\n        numlist.sort()\\n        target=numlist[m*n//2]\\n        res=0\\n        for n in numlist:\\n            temp=abs(n-target)\\n            if temp%x!=0:\\n                return -1\\n            res+=temp//x\\n        return res\\n               \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664938,
                "title": "python-finding-median",
                "content": "```\\nfrom itertools import chain\\nfrom statistics import median_low\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        y = list(chain.from_iterable(grid))\\n        r = y[0] % x\\n\\n        # if two numbers have different remainders wrt x then they can never be\\n        # equal if multiple of x is added/subtracted from them\\n        # Proof:\\n        # let y1 and y2 be two numbers, by Euclid division theorem (https://en.wikipedia.org/wiki/Euclidean_division#Division_theorem)\\n        # y1 = q1 * x + r1\\n        # y2 = q2 * x + r2\\n        # where 0 <= r1 < x, 0 <= r2 < x and q1 and q2 are integers\\n        # Now suppose that r1 != r2 and for sake of simplicity, let r1 > r2\\n        # Suppose we add m * x into y1 to make it equal to y2 where m is integer\\n        # q1 * x + r1 + m * x = q2 * x + r2\\n        # r1 - r2 = x * (q2 - m - q1)\\n        # r1 - r2 = x * q # where q = q2 - m - q1 hence q is integer\\n        # We note, 0 < r1 - r2 < x so r1 - r2 is not integer multiple of x, so r1 - r2 = x * q is a contradiction.\\n        # hence y1 can never be equal to y2\\n\\n        if any(e % x != r for e in y):\\n            return -1\\n\\n        # let pivot be the final uni-value, and n = len(y) so we need to\\n        #               minimize S = sum (|pivot - y[i]| for i in range(n))\\n        #  So median should be the pivot value\\n\\n        pivot = median_low(y)  # does not matter if you have median_high also\\n\\n        return sum(abs(pivot - e) // x for e in y)\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nfrom itertools import chain\\nfrom statistics import median_low\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        y = list(chain.from_iterable(grid))\\n        r = y[0] % x\\n\\n        # if two numbers have different remainders wrt x then they can never be\\n        # equal if multiple of x is added/subtracted from them\\n        # Proof:\\n        # let y1 and y2 be two numbers, by Euclid division theorem (https://en.wikipedia.org/wiki/Euclidean_division#Division_theorem)\\n        # y1 = q1 * x + r1\\n        # y2 = q2 * x + r2\\n        # where 0 <= r1 < x, 0 <= r2 < x and q1 and q2 are integers\\n        # Now suppose that r1 != r2 and for sake of simplicity, let r1 > r2\\n        # Suppose we add m * x into y1 to make it equal to y2 where m is integer\\n        # q1 * x + r1 + m * x = q2 * x + r2\\n        # r1 - r2 = x * (q2 - m - q1)\\n        # r1 - r2 = x * q # where q = q2 - m - q1 hence q is integer\\n        # We note, 0 < r1 - r2 < x so r1 - r2 is not integer multiple of x, so r1 - r2 = x * q is a contradiction.\\n        # hence y1 can never be equal to y2\\n\\n        if any(e % x != r for e in y):\\n            return -1\\n\\n        # let pivot be the final uni-value, and n = len(y) so we need to\\n        #               minimize S = sum (|pivot - y[i]| for i in range(n))\\n        #  So median should be the pivot value\\n\\n        pivot = median_low(y)  # does not matter if you have median_high also\\n\\n        return sum(abs(pivot - e) // x for e in y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2639790,
                "title": "easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>flattenMatrix(vector<vector<int>>& grid)\\n    {\\n        vector<int>flattenedArray;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                flattenedArray.push_back(grid[i][j]);\\n            }\\n        }\\n        return flattenedArray;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>flattenedArray=flattenMatrix( grid);\\n     sort( flattenedArray.begin(),  flattenedArray.end());\\n        int mid=(flattenedArray.size()-1)/2;\\n        int result=0;\\n        for(int i=0;i<flattenedArray.size();i++)\\n        {\\n            if((flattenedArray[i]-flattenedArray[mid])%x!=0)\\n            {\\n                return -1;\\n            }\\n            result+=abs(flattenedArray[i]-flattenedArray[mid])/x;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>flattenMatrix(vector<vector<int>>& grid)\\n    {\\n        vector<int>flattenedArray;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                flattenedArray.push_back(grid[i][j]);\\n            }\\n        }\\n        return flattenedArray;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>flattenedArray=flattenMatrix( grid);\\n     sort( flattenedArray.begin(),  flattenedArray.end());\\n        int mid=(flattenedArray.size()-1)/2;\\n        int result=0;\\n        for(int i=0;i<flattenedArray.size();i++)\\n        {\\n            if((flattenedArray[i]-flattenedArray[mid])%x!=0)\\n            {\\n                return -1;\\n            }\\n            result+=abs(flattenedArray[i]-flattenedArray[mid])/x;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630663,
                "title": "java-median-sorting",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int count = 0 ;\\n        ArrayList<Integer> nums = new ArrayList<>() ;\\n        int n = grid.length ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int m = grid[i].length ;\\n            for (int j = 0; j < m; j++)\\n                nums.add(grid[i][j]) ;\\n        }\\n        \\n        Collections.sort(nums) ;\\n        n = nums.size() ;\\n        int median = nums.get(n/2) ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int difference = Math.abs(median-nums.get(i)) ;\\n            if (difference % x != 0) return -1 ;\\n            count += difference/x ;\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int count = 0 ;\\n        ArrayList<Integer> nums = new ArrayList<>() ;\\n        int n = grid.length ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int m = grid[i].length ;\\n            for (int j = 0; j < m; j++)\\n                nums.add(grid[i][j]) ;\\n        }\\n        \\n        Collections.sort(nums) ;\\n        n = nums.size() ;\\n        int median = nums.get(n/2) ;\\n        \\n        for (int i = 0; i < n; i++) {\\n            int difference = Math.abs(median-nums.get(i)) ;\\n            if (difference % x != 0) return -1 ;\\n            count += difference/x ;\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608477,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), steps = 0;\\n        vector<int> arr;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int mid = (m*n)/2;\\n        int midval = arr[mid];\\n        for(int i = 0; i < arr.size(); i++){\\n            int d = abs(arr[i] - midval);\\n            if(d%x != 0) return -1;\\n            else{\\n                steps += d/x;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        int m = grid.size(), n = grid[0].size(), steps = 0;\\n        vector<int> arr;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int mid = (m*n)/2;\\n        int midval = arr[mid];\\n        for(int i = 0; i < arr.size(); i++){\\n            int d = abs(arr[i] - midval);\\n            if(d%x != 0) return -1;\\n            else{\\n                steps += d/x;\\n            }\\n        }\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2606319,
                "title": "median",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        int rem = grid[0][0]%x;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(rem!=grid[i][j]%x) return -1;\\n                list.add(grid[i][j]/x);\\n            }\\n        }\\n        if(list.size()==1) return 0;\\n        list.sort(null);\\n        if(list.size()%2==1) return f(list,list.get(list.size()/2));\\n        return Math.min(f(list,list.get(list.size()/2)),f(list,list.get(list.size()/2-1)));\\n    }\\n    private int f(List<Integer> list, int value){\\n        int sum = 0;\\n        for(int l: list) sum += Math.abs(value-l);\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        int rem = grid[0][0]%x;\\n        for(int i=0;i<grid.length;i++){\\n            for(int j=0;j<grid[0].length;j++){\\n                if(rem!=grid[i][j]%x) return -1;\\n                list.add(grid[i][j]/x);\\n            }\\n        }\\n        if(list.size()==1) return 0;\\n        list.sort(null);\\n        if(list.size()%2==1) return f(list,list.get(list.size()/2));\\n        return Math.min(f(list,list.get(list.size()/2)),f(list,list.get(list.size()/2-1)));\\n    }\\n    private int f(List<Integer> list, int value){\\n        int sum = 0;\\n        for(int l: list) sum += Math.abs(value-l);\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2578564,
                "title": "python-simple-solution-based-on-sorting-and-median",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        numRows, numCols, nums = len(grid), len(grid[0]), []\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                nums.append(grid[row][col])\\n        nums.sort()\\n        median, ans = nums[len(nums) // 2], 0\\n        for num in nums:\\n            quotient, remainder = abs(num - median) // x, abs(num - median) % x\\n            if remainder:\\n                return -1\\n            ans += quotient\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        numRows, numCols, nums = len(grid), len(grid[0]), []\\n        for row in range(numRows):\\n            for col in range(numCols):\\n                nums.append(grid[row][col])\\n        nums.sort()\\n        median, ans = nums[len(nums) // 2], 0\\n        for num in nums:\\n            quotient, remainder = abs(num - median) // x, abs(num - median) % x\\n            if remainder:\\n                return -1\\n            ans += quotient\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555003,
                "title": "python-simple-maths",
                "content": "\\n    def minOperations(self, grid, x):\\n        ans = []\\n        \\n        for row in grid:\\n            ans += row\\n            \\n        ans.sort()\\n        \\n        median, total = ans[len(ans)//2], 0\\n        \\n        for i in ans:\\n            if abs(i-median)%x != 0:\\n                return -1\\n            \\n            total += abs(i-median)//x\\n            \\n        return total",
                "solutionTags": [],
                "code": "\\n    def minOperations(self, grid, x):\\n        ans = []\\n        \\n        for row in grid:\\n            ans += row\\n            \\n        ans.sort()\\n        \\n        median, total = ans[len(ans)//2], 0\\n        \\n        for i in ans:\\n            if abs(i-median)%x != 0:\\n                return -1\\n            \\n            total += abs(i-median)//x\\n            \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2535959,
                "title": "easy-java-solution-sort-the-numbers-and-then-find-median",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int a = grid[0][0]; //for reference\\n        List<Integer> arr= new ArrayList<>();\\n        for(int i=0; i<grid.length; i++)\\n        {\\n            for(int j=0; j<grid[0].length; j++)\\n            {\\n                 if(Math.abs(grid[i][j]-a)%x!=0)  //checking if difference btw number is divisible by x or not \\n                    return -1;                                //if not then we cannot bring the 2 numbers to same postion\\n                arr.add(grid[i][j]);\\n                \\n            }\\n        }\\n         int m = grid.length;\\n        int n = grid[0].length;\\n            Collections.sort(arr);\\n    int t1= arr.get(arr.size()/2);\\n        int ans=0;\\n        \\n         for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]!=t1)\\n                {\\n                    ans+= (Math.abs(grid[i][j]-t1))/x;\\n                }\\n            }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int a = grid[0][0]; //for reference\\n        List<Integer> arr= new ArrayList<>();\\n        for(int i=0; i<grid.length; i++)\\n        {\\n            for(int j=0; j<grid[0].length; j++)\\n            {\\n                 if(Math.abs(grid[i][j]-a)%x!=0)  //checking if difference btw number is divisible by x or not \\n                    return -1;                                //if not then we cannot bring the 2 numbers to same postion\\n                arr.add(grid[i][j]);\\n                \\n            }\\n        }\\n         int m = grid.length;\\n        int n = grid[0].length;\\n            Collections.sort(arr);\\n    int t1= arr.get(arr.size()/2);\\n        int ans=0;\\n        \\n         for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n            {\\n                if(grid[i][j]!=t1)\\n                {\\n                    ans+= (Math.abs(grid[i][j]-t1))/x;\\n                }\\n            }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515215,
                "title": "easy-and-detailed-explanation-of-the-answer",
                "content": "We will first store the number in an array and then we will sort the number.If difference of any adjacent number is not divisible by x the we should simply return -1; Otherwise there are two conditions.\\n\\nCondition-1) If the size of the vector is odd.Then we should simply try to make the number equal to the middle number.\\n\\ncondition-2) If the size of the vector is even.In this case there are two probable answer.\\nFirst we will try to make the number equal to the middle number of the array.\\nThen we will try to make the elements equal to the  middle-1 element of the array. Then we will take the minimum of the above two.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int f(vector<int>&v,int x,int val)\\n    {\\n        int s=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=abs(v[i]-val);\\n        }\\n        return s/x;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if((v[i]-v[i-1])%x!=0) return -1;\\n        }\\n        int idx=n/2;\\n        if(n%2==0)\\n        {\\n            \\n            int val1=v[idx];\\n            int val2=v[idx-1];\\n            int ans1=f(v,x,val1);\\n            int ans2=f(v,x,val2);\\n            return min(ans1,ans2);\\n        }\\n        else{\\n            int val1=v[idx];\\n            return f(v,x,val1);\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int f(vector<int>&v,int x,int val)\\n    {\\n        int s=0;\\n        int n=v.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            s+=abs(v[i]-val);\\n        }\\n        return s/x;\\n    }\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        int row=grid.size();\\n        int col=grid[0].size();\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        for(int i=1;i<n;i++)\\n        {\\n            if((v[i]-v[i-1])%x!=0) return -1;\\n        }\\n        int idx=n/2;\\n        if(n%2==0)\\n        {\\n            \\n            int val1=v[idx];\\n            int val2=v[idx-1];\\n            int ans1=f(v,x,val1);\\n            int ans2=f(v,x,val2);\\n            return min(ans1,ans2);\\n        }\\n        else{\\n            int val1=v[idx];\\n            return f(v,x,val1);\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500150,
                "title": "python-solution",
                "content": "here is what I did:\\n\\n```python\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        arr = list(chain.from_iterable(grid))\\n        modval = arr[0] % x\\n        if not all(v % x == modval for v in arr):\\n            return -1\\n        arr.sort()\\n        midval = arr[len(arr)//2]\\n        return sum(abs(midval - v) for v in arr) // x\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n        arr = list(chain.from_iterable(grid))\\n        modval = arr[0] % x\\n        if not all(v % x == modval for v in arr):\\n            return -1\\n        arr.sort()\\n        midval = arr[len(arr)//2]\\n        return sum(abs(midval - v) for v in arr) // x\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2497473,
                "title": "easy-faster-efficient-java-soln",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int [] arr = new int[m * n];\\n        int k = 0;\\n        int cd = -1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[k] = grid[i][j];\\n                k++;\\n                int val = grid[i][j] % x;\\n                if(cd == -1){\\n                    cd = val;\\n                } else if(val != cd){\\n                    return -1;\\n                }\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int [] dp = new int[m * n];\\n        int mid = arr[(0 + arr.length) / 2];\\n        int mididx = (0 + arr.length) / 2;\\n        int total = 0;\\n        for(int i = mididx - 1; i >= 0; i--){\\n            int val = arr[i];\\n            int count = 0;\\n            while(val < arr[i + 1]){\\n                val += x;\\n                count++;\\n            }\\n            total += count;\\n            dp[i] = count + dp[i + 1];\\n        }\\n        for(int i = mididx + 1; i < dp.length; i++){\\n            int val = arr[i];\\n            int count = 0;\\n            while(val > arr[i - 1]){\\n                val -= x;\\n                count++;\\n            }\\n            total += count;\\n            dp[i] = count + dp[i - 1];\\n        }\\n        total = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            total += dp[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        int [] arr = new int[m * n];\\n        int k = 0;\\n        int cd = -1;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                arr[k] = grid[i][j];\\n                k++;\\n                int val = grid[i][j] % x;\\n                if(cd == -1){\\n                    cd = val;\\n                } else if(val != cd){\\n                    return -1;\\n                }\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int [] dp = new int[m * n];\\n        int mid = arr[(0 + arr.length) / 2];\\n        int mididx = (0 + arr.length) / 2;\\n        int total = 0;\\n        for(int i = mididx - 1; i >= 0; i--){\\n            int val = arr[i];\\n            int count = 0;\\n            while(val < arr[i + 1]){\\n                val += x;\\n                count++;\\n            }\\n            total += count;\\n            dp[i] = count + dp[i + 1];\\n        }\\n        for(int i = mididx + 1; i < dp.length; i++){\\n            int val = arr[i];\\n            int count = 0;\\n            while(val > arr[i - 1]){\\n                val -= x;\\n                count++;\\n            }\\n            total += count;\\n            dp[i] = count + dp[i - 1];\\n        }\\n        total = 0;\\n        for(int i = 0; i < dp.length; i++){\\n            total += dp[i];\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490158,
                "title": "na-ve-simple-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int calc(vector<int> &nums, int x, int a)\\n        {\\n            int z = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                int k = abs(nums[i] - nums[x]);\\n                if (k % a == 0)\\n                    z += k / a;\\n                else\\n                    return -1;\\n            }\\n            return z;\\n        }\\n    int minOperations(vector<vector < int>> &grid, int x)\\n    {\\n        vector<int> nums;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            for (int j = 0; j < grid[i].size(); j++)\\n                nums.push_back(grid[i][j]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        if (nums.size() % 2 == 0)\\n        {\\n            return max(calc(nums, nums.size() / 2 - 1, x), calc(nums, nums.size() / 2, x));\\n        }\\n        return calc(nums, nums.size() / 2, x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int calc(vector<int> &nums, int x, int a)\\n        {\\n            int z = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                int k = abs(nums[i] - nums[x]);\\n                if (k % a == 0)\\n                    z += k / a;\\n                else\\n                    return -1;\\n            }\\n            return z;\\n        }\\n    int minOperations(vector<vector < int>> &grid, int x)\\n    {\\n        vector<int> nums;\\n        for (int i = 0; i < grid.size(); i++)\\n        {\\n            for (int j = 0; j < grid[i].size(); j++)\\n                nums.push_back(grid[i][j]);\\n        }\\n        sort(nums.begin(), nums.end());\\n        if (nums.size() % 2 == 0)\\n        {\\n            return max(calc(nums, nums.size() / 2 - 1, x), calc(nums, nums.size() / 2, x));\\n        }\\n        return calc(nums, nums.size() / 2, x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467814,
                "title": "c-90-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n               vector<int> nums;\\n          \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n                nums.push_back(grid[i][j]);\\n        }\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int m;\\n        \\n        if(nums.size()%2==0)\\n            m=nums.size()/2-1;\\n        else\\n            m=nums.size()/2;\\n        \\n        int a=0;\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(abs(nums[i]-nums[m])%x==0)\\n            a=a+(abs(nums[i]-nums[m]))/x;\\n            else\\n             return -1;               \\n        }        \\n        return a;     \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n               vector<int> nums;\\n          \\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n                nums.push_back(grid[i][j]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455243,
                "title": "java",
                "content": "I could not wrap my head around why it should be Median. Intuitively, maybe Median is correct but wanted to code a solution that seems and feels more accurate. Came across Larry\\'s explaination. \\n\\nhttps://www.youtube.com/watch?v=c90k-5HigWs\\n\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int row = grid.length;\\n        int column = grid[0].length;\\n        \\n        int[] array = new int[row * column];\\n        int index = 0;\\n        \\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < column; ++j) {\\n                array[index++] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(array);\\n        \\n        /*\\n        * How to find index which can be reached with minimum number of Operations?\\n        * - We need to go over all the indices and compute it for each.  \\n        * - There is an optimization, to convert this O(N) operation to constant for each index\\n        *   given that we have computed it for 0th index. \\n        */\\n        \\n        int left = 0;\\n        int right = 0;\\n        for (int i = 1; i < array.length; ++i) {\\n            \\n            // This means that I cannot convert by adding or subtracting multiples of x. \\n            if ((array[i] - array[0]) % x != 0) {\\n                // System.out.println(\"Here \" + array[i] + \"\\\\t\" + array[0]);\\n                return -1;    \\n            }\\n            \\n            right += (array[i] - array[0]) / x;\\n        }\\n        \\n        int best = left + right;\\n        \\n        for (int i = 1; i < array.length; ++i) {\\n            right -= ((array[i] - array[i - 1]) / x ) * (array.length - i); \\n            left += ((array[i] - array[i - 1]) / x) * i;\\n            best = Math.min(best, left + right);\\n        }\\n        \\n        return best;\\n    }\\n} \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int row = grid.length;\\n        int column = grid[0].length;\\n        \\n        int[] array = new int[row * column];\\n        int index = 0;\\n        \\n        for (int i = 0; i < row; ++i) {\\n            for (int j = 0; j < column; ++j) {\\n                array[index++] = grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(array);\\n        \\n        /*\\n        * How to find index which can be reached with minimum number of Operations?\\n        * - We need to go over all the indices and compute it for each.  \\n        * - There is an optimization, to convert this O(N) operation to constant for each index\\n        *   given that we have computed it for 0th index. \\n        */\\n        \\n        int left = 0;\\n        int right = 0;\\n        for (int i = 1; i < array.length; ++i) {\\n            \\n            // This means that I cannot convert by adding or subtracting multiples of x. \\n            if ((array[i] - array[0]) % x != 0) {\\n                // System.out.println(\"Here \" + array[i] + \"\\\\t\" + array[0]);\\n                return -1;    \\n            }\\n            \\n            right += (array[i] - array[0]) / x;\\n        }\\n        \\n        int best = left + right;\\n        \\n        for (int i = 1; i < array.length; ++i) {\\n            right -= ((array[i] - array[i - 1]) / x ) * (array.length - i); \\n            left += ((array[i] - array[i - 1]) / x) * i;\\n            best = Math.min(best, left + right);\\n        }\\n        \\n        return best;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419763,
                "title": "easy-sorting-and-finding-median",
                "content": "The whole crux of this question is to find whether we can reach a particular no or not.\\nlets say we have 5 elements and we want to find whether we can reach meadian or not \\nso one way is to sort and find the abs(A[i]- median)% x==0 if true for all return (A[i]-median)/x \\nelse return false;\\n \\n A1----A2----A3(median/shortest)----A4----A5   (---- :- x distance travelled)\\n \\n \\n \\n\\n\\n\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        int m= grid.size();\\n        int n= grid[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(arr.begin(), arr.end());\\n        int maxi= arr[arr.size()-1];\\n          \\n        for(int i=0;i<arr.size();i++)\\n        {\\n          \\n            if(abs(maxi-arr[i])%x!=0)\\n            {\\n                return -1;\\n            }\\n        }\\n        int y= arr[arr.size()/2];\\n        int count=0;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            //cout<<abs(y-arr[i])/x<<endl;\\n            count+= abs(arr[i]- y)/x;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        int m= grid.size();\\n        int n= grid[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                arr.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2394121,
                "title": "c",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        \\n        \\n        vector<int> val;\\n        for(int i = 0;i<grid.size();i++)\\n        {\\n            for(int j = 0;j<grid[0].size();j++)\\n            {\\n                val.push_back(grid[i][j]);\\n            }\\n            \\n        }\\n        \\n        sort(val.begin(),val.end());\\n        \\n        int n = val.size();\\n        \\n        int m = n/2;\\n        int num = val[m];\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            val[i] = abs(num-val[i]);\\n            if(val[i]%x != 0)\\n                return -1;\\n            ans+=val[i]/x;\\n        }\\n        \\n        return ans;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        \\n        \\n        vector<int> val;\\n        for(int i = 0;i<grid.size();i++)\\n        {\\n            for(int j = 0;j<grid[0].size();j++)\\n            {\\n                val.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2391221,
                "title": "c-median-100-faster",
                "content": "Reference: https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/discuss/1894411/C\\n```\\n\\n\\nint comparator(const void *p, const void *q) {\\n    return *( (int *) p ) - *( (int *) q );\\n}\\n\\nint minOperations(int** grid, int gridSize, int* gridColSize, int x){\\n    int* array = malloc( sizeof(int) * gridSize * *gridColSize );\\n    int count = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            array[count++] = grid[i][j];\\n        }\\n    }\\n    qsort(array, count, sizeof(int), comparator);\\n    \\n    int median = array[count / 2];\\n    free(array);\\n    \\n    int res = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            int r = abs(grid[i][j] - median) % x;\\n            int d = abs(grid[i][j] - median) / x;\\n            if (r != 0) return -1;\\n            res += d; \\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nint comparator(const void *p, const void *q) {\\n    return *( (int *) p ) - *( (int *) q );\\n}\\n\\nint minOperations(int** grid, int gridSize, int* gridColSize, int x){\\n    int* array = malloc( sizeof(int) * gridSize * *gridColSize );\\n    int count = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            array[count++] = grid[i][j];\\n        }\\n    }\\n    qsort(array, count, sizeof(int), comparator);\\n    \\n    int median = array[count / 2];\\n    free(array);\\n    \\n    int res = 0;\\n    for (int i = 0; i < gridSize; i++) {\\n        for (int j = 0; j < *gridColSize; j++) {\\n            int r = abs(grid[i][j] - median) % x;\\n            int d = abs(grid[i][j] - median) / x;\\n            if (r != 0) return -1;\\n            res += d; \\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2379341,
                "title": "java-time-o-n-space-o-1-in-place-with-quickselect",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        // check that all values belong to the same class\\n        int cls = grid[0][0] % x;\\n        int cols = grid[0].length;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                if (cls != grid[i][j] % x) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        // find the median\\n        int l = 0, r = grid.length * cols - 1;\\n        int target = r / 2;\\n        while (l < r) {\\n            int p = ThreadLocalRandom.current().nextInt(l, r + 1);\\n            // int p = l;\\n            int pi = p / cols, pj = p % cols;\\n            int li = l / cols, lj = l % cols;\\n            int pivot = grid[pi][pj];\\n            grid[pi][pj] = grid[li][lj];\\n            grid[li][lj] = pivot;\\n            int small = l, big = r, same = l + 1;\\n            int smi = small / cols, smj = small % cols;\\n            int sai = same / cols, saj = same % cols;\\n            int bi = big / cols, bj = big % cols;\\n            while (same <= big) {\\n                if (grid[sai][saj] < pivot) {\\n                    grid[smi][smj] = grid[sai][saj];\\n                    grid[sai][saj] = pivot;\\n                    ++small;\\n                    smi = small / cols;\\n                    smj = small % cols;\\n                    ++same;\\n                    sai = same / cols;\\n                    saj = same % cols;\\n                } else if (grid[sai][saj] == pivot) {\\n                    ++same;\\n                    sai = same / cols;\\n                    saj = same % cols;\\n                } else {\\n                    int t = grid[bi][bj];\\n                    grid[bi][bj] = grid[sai][saj];\\n                    grid[sai][saj] = t;\\n                    --big;\\n                    bi = big / cols;\\n                    bj = big % cols;\\n                }\\n            }   \\n            if (target < small) {\\n                r = small - 1; \\n            } else if (target < same) {\\n                l = r = same - 1;\\n            } else {\\n                l = same;\\n            }\\n        }\\n\\n        // compute the answer\\n        int k = grid[l / cols][l % cols];\\n        int ans = 0;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[0].length; ++j) {\\n                ans += (int) Math.abs(grid[i][j] - k) / x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        // check that all values belong to the same class\\n        int cls = grid[0][0] % x;\\n        int cols = grid[0].length;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < cols; ++j) {\\n                if (cls != grid[i][j] % x) {\\n                    return -1;\\n                }\\n            }\\n        }\\n        // find the median\\n        int l = 0, r = grid.length * cols - 1;\\n        int target = r / 2;\\n        while (l < r) {\\n            int p = ThreadLocalRandom.current().nextInt(l, r + 1);\\n            // int p = l;\\n            int pi = p / cols, pj = p % cols;\\n            int li = l / cols, lj = l % cols;\\n            int pivot = grid[pi][pj];\\n            grid[pi][pj] = grid[li][lj];\\n            grid[li][lj] = pivot;\\n            int small = l, big = r, same = l + 1;\\n            int smi = small / cols, smj = small % cols;\\n            int sai = same / cols, saj = same % cols;\\n            int bi = big / cols, bj = big % cols;\\n            while (same <= big) {\\n                if (grid[sai][saj] < pivot) {\\n                    grid[smi][smj] = grid[sai][saj];\\n                    grid[sai][saj] = pivot;\\n                    ++small;\\n                    smi = small / cols;\\n                    smj = small % cols;\\n                    ++same;\\n                    sai = same / cols;\\n                    saj = same % cols;\\n                } else if (grid[sai][saj] == pivot) {\\n                    ++same;\\n                    sai = same / cols;\\n                    saj = same % cols;\\n                } else {\\n                    int t = grid[bi][bj];\\n                    grid[bi][bj] = grid[sai][saj];\\n                    grid[sai][saj] = t;\\n                    --big;\\n                    bi = big / cols;\\n                    bj = big % cols;\\n                }\\n            }   \\n            if (target < small) {\\n                r = small - 1; \\n            } else if (target < same) {\\n                l = r = same - 1;\\n            } else {\\n                l = same;\\n            }\\n        }\\n\\n        // compute the answer\\n        int k = grid[l / cols][l % cols];\\n        int ans = 0;\\n        for (int i = 0; i < grid.length; ++i) {\\n            for (int j = 0; j < grid[0].length; ++j) {\\n                ans += (int) Math.abs(grid[i][j] - k) / x;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2314550,
                "title": "find-median-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        \\n        for(auto &vec : grid)\\n            for(auto &ele : vec) arr.push_back(ele);\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ele = arr[arr.size()/2], ans = 0;\\n        \\n        for(auto &i : arr){\\n            int diff = abs(i - ele);\\n            if(diff % x) return -1;\\n            ans += (diff/x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> arr;\\n        \\n        for(auto &vec : grid)\\n            for(auto &ele : vec) arr.push_back(ele);\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ele = arr[arr.size()/2], ans = 0;\\n        \\n        for(auto &i : arr){\\n            int diff = abs(i - ele);\\n            if(diff % x) return -1;\\n            ans += (diff/x);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2277694,
                "title": "easy-c-solution-using-median",
                "content": "\\'\\'\\'int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n        { for(int j = 0 ; j<grid[0].size(); j++)\\n        {\\n             v.push_back(grid[i][j]) ;\\n        }\\n        }\\n        sort(v.begin() , v.end()) ;\\n        int n = v.size()/2 ;\\n        int median = v[n] ;\\n        for(int i = 0 ; i<v.size() ;i++)\\n        {\\n            int diff = abs(v[i] - median) ;\\n            if(diff%x!=0)\\n                return -1 ;\\n            else\\n                ans= ans+diff/x ;\\n            \\n        }\\n        return ans ;\\n    }\\n};\\'\\'\\'",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\'\\'\\'int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v ;\\n        int ans = 0 ;\\n        for(int i = 0 ; i<grid.size() ; i++)\\n        { for(int j = 0 ; j<grid[0].size(); j++)\\n        {\\n             v.push_back(grid[i][j]) ;\\n        }\\n        }\\n        sort(v.begin() , v.end()) ;\\n        int n = v.size()/2 ;\\n        int median = v[n] ;\\n        for(int i = 0 ; i<v.size() ;i++)\\n        {\\n            int diff = abs(v[i] - median) ;\\n            if(diff%x!=0)\\n                return -1 ;\\n            else\\n                ans= ans+diff/x ;\\n            \\n        }\\n        return ans ;\\n    }\\n};\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2273734,
                "title": "easy-python-solution",
                "content": "```\\ndef minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                nums.append(grid[i][j])\\n        \\n        remainders = []\\n        for i in nums:\\n            remainders.append(i%x)\\n        \\n        if any(remainders[i] != remainders[0] for i in range(1, len(remainders))):\\n            return -1\\n        \\n        nums.sort()\\n        target = nums[len(nums)//2]\\n        count = 0\\n        for i in nums:\\n            count+= abs((target-i))//x\\n        \\n        return count",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                nums.append(grid[i][j])\\n        \\n        remainders = []\\n        for i in nums:\\n            remainders.append(i%x)\\n        \\n        if any(remainders[i] != remainders[0] for i in range(1, len(remainders))):\\n            return -1\\n        \\n        nums.sort()\\n        target = nums[len(nums)//2]\\n        count = 0\\n        for i in nums:\\n            count+= abs((target-i))//x\\n        \\n        return count",
                "codeTag": "Python3"
            },
            {
                "id": 2249216,
                "title": "simple-solution-c-using-median",
                "content": "```\\nint n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>vt;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vt.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(vt.begin(),vt.end());\\n        int target=vt[vt.size()/2];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=abs(grid[i][j]-target);\\n                \\n                if(val%x!=0){\\n                    return -1;\\n                }\\n                int res=val/x;\\n                cnt+=res;\\n            }\\n        }\\n        return cnt;",
                "solutionTags": [],
                "code": "```\\nint n=grid.size();\\n        int m=grid[0].size();\\n        vector<int>vt;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                vt.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(vt.begin(),vt.end());\\n        int target=vt[vt.size()/2];\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=abs(grid[i][j]-target);\\n                \\n                if(val%x!=0){\\n                    return -1;\\n                }\\n                int res=val/x;\\n                cnt+=res;\\n            }\\n        }\\n        return cnt;",
                "codeTag": "Unknown"
            },
            {
                "id": 2248289,
                "title": "java-o-n-space-and-o-n-time-n-10000-count-sort-3-ms-faster-than-100-00",
                "content": "```\\n/*\\nFind the median\\nCalculate the difference between the current element and the median element and add the (difference / x) to the result if difference is divisible by x\\n*/\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] count = new int[10001];\\n        \\n        for (int[] row : grid) {\\n            for (int e : row) {\\n                count[e]++;\\n            }\\n        }\\n        \\n        int middle = (grid.length * grid[0].length+1) / 2;\\n        \\n        int v = -1;\\n        while (middle > 0) {\\n            v++;\\n            middle -= count[v];\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= 10000; i++) {\\n            if (count[i] > 0) {\\n                int c = Math.abs(v - i);\\n                if (c % x != 0) {\\n                    return - 1;\\n                }\\n                res += count[i]*c/x;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nFind the median\\nCalculate the difference between the current element and the median element and add the (difference / x) to the result if difference is divisible by x\\n*/\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int[] count = new int[10001];\\n        \\n        for (int[] row : grid) {\\n            for (int e : row) {\\n                count[e]++;\\n            }\\n        }\\n        \\n        int middle = (grid.length * grid[0].length+1) / 2;\\n        \\n        int v = -1;\\n        while (middle > 0) {\\n            v++;\\n            middle -= count[v];\\n        }\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= 10000; i++) {\\n            if (count[i] > 0) {\\n                int c = Math.abs(v - i);\\n                if (c % x != 0) {\\n                    return - 1;\\n                }\\n                res += count[i]*c/x;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246880,
                "title": "intuitive-non-rigorous-python-solution",
                "content": "This is very similar to: \\nhttps://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\\n\\nFirst off all, we need to convert the 2d array to 1d array and sort it since the unsorted elements dont seem to give any hints (plus the test case has 10^4 limit).\\n\\nTo make the grid, a grid of uni-values, we can choose one of the elements of the array we want to convert into.\\n\\nIf we choose the smallest or largest ele, the cost to convert the rightmost or leftmost ele of the array would be very high.\\nEg if the arr is [1,2,3] and we choose 3 or 1, it would require a cost of : (3-1)+(3-2)+(3-3) = 3\\nwhile if you choose 2 (median), the cost would be (2-1)+(2-2)+(3-2) = 2.\\n\\nHence we go for the median value.\\n\\nNow in the problem linked earlier, we could only add or subtract \"1\" to make all elements uni-value.\\nBut here we can use only add/sub \"x\".\\n\\nHence to check if we can convert nums[i] to the median value using x, we need to see if the difference diff = (nums[i]-median)%x is 0 or not.\\n\\nIf it is, then we can convert nums[i] to the median value using \"X\" and the number of moves needed is diff//x.\\n\\nPutting this to code:\\n```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\t\\t#2d to 1d conversion\\n        nums = []\\n        for g in grid:\\n            for i in g:\\n                nums.append(i)\\n        \\n        nums.sort()\\n        l,h = 0,len(nums)-1\\n        m = (l+h)//2\\n        \\n\\t\\t#median\\n        dest = nums[m]\\n        count = 0\\n        \\n\\t\\t#calculate possibility && cost\\n        for num in nums:\\n            diff = abs(num-dest)\\n            if diff%x!=0:\\n                return -1\\n            count+=diff//x\\n            \\n        return count\\n```\\n\\nIf you want to practice these kinds of problems from scratch, solve  in-order:\\n1. https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\\n2. https://leetcode.com/problems/minimum-moves-to-equal-array-elements/\\n3. https://leetcode.com/problems/minimum-operations-to-make-a-uni-value-grid/",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: List[List[int]], x: int) -> int:\\n\\t\\t#2d to 1d conversion\\n        nums = []\\n        for g in grid:\\n            for i in g:\\n                nums.append(i)\\n        \\n        nums.sort()\\n        l,h = 0,len(nums)-1\\n        m = (l+h)//2\\n        \\n\\t\\t#median\\n        dest = nums[m]\\n        count = 0\\n        \\n\\t\\t#calculate possibility && cost\\n        for num in nums:\\n            diff = abs(num-dest)\\n            if diff%x!=0:\\n                return -1\\n            count+=diff//x\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244331,
                "title": "java-o-mn-space-and-o-mn-time-solution-median",
                "content": "1. Sort the matrix\\n2. Find the median\\n3. Calculate the difference between the current element and the median element and add the (difference / x) to the result if difference is divisible by x\\n\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        \\n        int res = 0;\\n        int middle = list.size() / 2;\\n        \\n        for(int i = 0; i < list.size(); i++) {\\n            int num = list.get(i);\\n            int diff = Math.abs(num - list.get(middle));\\n            \\n            if(diff % x != 0) {\\n                return -1;\\n            }\\n            else {\\n                res += diff / x;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\nSimple addition/subtraction will result in TLE",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> list = new ArrayList<>();\\n        \\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                list.add(grid[i][j]);\\n            }\\n        }\\n        \\n        Collections.sort(list);\\n        \\n        \\n        int res = 0;\\n        int middle = list.size() / 2;\\n        \\n        for(int i = 0; i < list.size(); i++) {\\n            int num = list.get(i);\\n            int diff = Math.abs(num - list.get(middle));\\n            \\n            if(diff % x != 0) {\\n                return -1;\\n            }\\n            else {\\n                res += diff / x;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238454,
                "title": "python-greedy-with-median",
                "content": "```\\ndef minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums=[]\\n        for row in grid:\\n            for a in row:\\n                nums.append(a)\\n        nums.sort()\\n        n=len(nums)\\n        med=nums[n//2]\\n        res=0\\n        ## greedy\\n        for a in nums:\\n            dif=abs(med-a)\\n            if dif%x!=0:\\n                return -1\\n            res+=dif//x\\n        return res",
                "solutionTags": [],
                "code": "```\\ndef minOperations(self, grid: List[List[int]], x: int) -> int:\\n        nums=[]\\n        for row in grid:\\n            for a in row:\\n                nums.append(a)\\n        nums.sort()\\n        n=len(nums)\\n        med=nums[n//2]\\n        res=0\\n        ## greedy\\n        for a in nums:\\n            dif=abs(med-a)\\n            if dif%x!=0:\\n                return -1\\n            res+=dif//x\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2228964,
                "title": "a-few-solutions",
                "content": "Transform the 2-dimensional input `matrix` to a 1-dimensional array `A` to find the median as the transformation target `T` for each value `x` of the input array `A`.  Let `need` be the absolute difference between the target `T` and each value `x`, then we return `-1` immediately when `x` *cannot* be transformed to `T`, ie. when the `need` is *not* evenly divisible by the \"chunk\" we can `take` in transformational steps (plus `+` or minus `-`) towards `T`.  Then we return the minimum `cost` as the accumulated `need` divided by the amount of \"chunks\" we `take`, ie. the number of operations.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minOperations(matrix: Array<IntArray>, take: Int): Int {\\n        var cost = 0\\n        var A = mutableListOf<Int>()\\n        for (row in matrix)\\n            A.addAll(row.toList())\\n        A.sort()\\n        var T = A[A.size / 2]\\n        for (x in A) {\\n            var need = Math.abs(T - x)\\n            if (need % take != 0)\\n                return -1\\n            cost += need / take\\n        }\\n        return cost\\n    }\\n}\\n```\\n\\n*Java*\\n```\\nclass Solution {\\n    public int minOperations(int[][] matrix, int take) {\\n        int cost = 0;\\n        ArrayList<Integer> A = new ArrayList<>();\\n        for (int i = 0; i < matrix.length; ++i)\\n            for (int j = 0; j < matrix[0].length; ++j)\\n                A.add(matrix[i][j]);\\n        A.sort((a, b) -> a - b);\\n        int T = A.get(A.size() / 2);\\n        for (int x: A) {\\n            int need = Math.abs(T - x);\\n            if (need % take != 0)\\n                return -1;\\n            cost += need / take;\\n        }\\n        return cost;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minOperations = (matrix, take, cost = 0) => {\\n    let A = _.flatten(matrix).sort((a, b) => a - b);\\n    let T = A[Math.floor(A.length / 2)];\\n    for (let x of A) {\\n        let need = Math.abs(T - x);\\n        if (need % take)\\n            return -1;\\n        cost += Math.floor(need / take);\\n    }\\n    return cost;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minOperations(self, matrix: List[List[int]], take: int, cost = 0) -> int:\\n        A = []\\n        for row in matrix:\\n            A.extend(row[:])\\n        A.sort()\\n        T = A[len(A) // 2]\\n        for x in A:\\n            need = abs(T - x)\\n            if need % take:\\n                return -1\\n            cost += need // take\\n        return cost\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn min_operations(matrix: VVI, take: i32) -> i32 {\\n        let mut cost = 0;\\n        let mut A = matrix.into_iter().flat_map(|row| row.into_iter()).collect::<VI>();\\n        A.sort();\\n        let T = A[A.len() / 2];\\n        for x in A {\\n            let need = (T - x).abs();\\n            if need % take != 0 {\\n                return -1;\\n            }\\n            cost += need / take;\\n        }\\n        cost\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minOperations(VVI& matrix, int take, VI A = {}, int cost = 0) {\\n        for (auto& row: matrix)\\n            A.insert(A.end(), row.begin(), row.end());\\n        sort(A.begin(), A.end());\\n        auto T = A[A.size() / 2];\\n        for (auto x: A) {\\n            auto need = abs(T - x);\\n            if (need % take)\\n                return -1;\\n            cost += need / take;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minOperations(matrix: Array<IntArray>, take: Int): Int {\\n        var cost = 0\\n        var A = mutableListOf<Int>()\\n        for (row in matrix)\\n            A.addAll(row.toList())\\n        A.sort()\\n        var T = A[A.size / 2]\\n        for (x in A) {\\n            var need = Math.abs(T - x)\\n            if (need % take != 0)\\n                return -1\\n            cost += need / take\\n        }\\n        return cost\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minOperations(int[][] matrix, int take) {\\n        int cost = 0;\\n        ArrayList<Integer> A = new ArrayList<>();\\n        for (int i = 0; i < matrix.length; ++i)\\n            for (int j = 0; j < matrix[0].length; ++j)\\n                A.add(matrix[i][j]);\\n        A.sort((a, b) -> a - b);\\n        int T = A.get(A.size() / 2);\\n        for (int x: A) {\\n            int need = Math.abs(T - x);\\n            if (need % take != 0)\\n                return -1;\\n            cost += need / take;\\n        }\\n        return cost;\\n    }\\n}\\n```\n```\\nlet minOperations = (matrix, take, cost = 0) => {\\n    let A = _.flatten(matrix).sort((a, b) => a - b);\\n    let T = A[Math.floor(A.length / 2)];\\n    for (let x of A) {\\n        let need = Math.abs(T - x);\\n        if (need % take)\\n            return -1;\\n        cost += Math.floor(need / take);\\n    }\\n    return cost;\\n};\\n```\n```\\nclass Solution:\\n    def minOperations(self, matrix: List[List[int]], take: int, cost = 0) -> int:\\n        A = []\\n        for row in matrix:\\n            A.extend(row[:])\\n        A.sort()\\n        T = A[len(A) // 2]\\n        for x in A:\\n            need = abs(T - x)\\n            if need % take:\\n                return -1\\n            cost += need // take\\n        return cost\\n```\n```\\ntype VI = Vec<i32>;\\ntype VVI = Vec<VI>;\\nimpl Solution {\\n    pub fn min_operations(matrix: VVI, take: i32) -> i32 {\\n        let mut cost = 0;\\n        let mut A = matrix.into_iter().flat_map(|row| row.into_iter()).collect::<VI>();\\n        A.sort();\\n        let T = A[A.len() / 2];\\n        for x in A {\\n            let need = (T - x).abs();\\n            if need % take != 0 {\\n                return -1;\\n            }\\n            cost += need / take;\\n        }\\n        cost\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    int minOperations(VVI& matrix, int take, VI A = {}, int cost = 0) {\\n        for (auto& row: matrix)\\n            A.insert(A.end(), row.begin(), row.end());\\n        sort(A.begin(), A.end());\\n        auto T = A[A.size() / 2];\\n        for (auto x: A) {\\n            auto need = abs(T - x);\\n            if (need % take)\\n                return -1;\\n            cost += need / take;\\n        }\\n        return cost;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226285,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int res = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i=0; i<grid.length; i++)\\n            for (int j=0; j<grid[0].length; j++)\\n                list.add(grid[i][j]);\\n        Collections.sort(list);\\n        int middle = list.size() / 2;\\n        int diff = 0;\\n        for (int i=0; i<list.size(); i++) {\\n            if (i < middle) {\\n                diff = list.get(middle) - list.get(i);\\n            } else if (i > middle) {\\n                diff = list.get(i) - list.get(middle);\\n            } else {\\n                continue;\\n            }\\n            if (diff % x == 0) {\\n                res += diff / x;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int res = 0;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int i=0; i<grid.length; i++)\\n            for (int j=0; j<grid[0].length; j++)\\n                list.add(grid[i][j]);\\n        Collections.sort(list);\\n        int middle = list.size() / 2;\\n        int diff = 0;\\n        for (int i=0; i<list.size(); i++) {\\n            if (i < middle) {\\n                diff = list.get(middle) - list.get(i);\\n            } else if (i > middle) {\\n                diff = list.get(i) - list.get(middle);\\n            } else {\\n                continue;\\n            }\\n            if (diff % x == 0) {\\n                res += diff / x;\\n            } else {\\n                return -1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226184,
                "title": "python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def minOperations(self, grid: [[int]], x: int) -> int:\\n        res = 0\\n        nums = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                nums.append(grid[i][j])\\n        nums.sort()\\n        n = len(nums)\\n        middle = n // 2\\n        for i in range(n):\\n            if i < middle:\\n                diff = nums[middle] - nums[i]\\n            elif i > middle:\\n                diff = nums[i] - nums[middle]\\n            else:\\n                continue\\n            if diff % x == 0:\\n                res += diff // x\\n            else:\\n                return -1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minOperations(self, grid: [[int]], x: int) -> int:\\n        res = 0\\n        nums = []\\n        for i in range(len(grid)):\\n            for j in range(len(grid[0])):\\n                nums.append(grid[i][j])\\n        nums.sort()\\n        n = len(nums)\\n        middle = n // 2\\n        for i in range(n):\\n            if i < middle:\\n                diff = nums[middle] - nums[i]\\n            elif i > middle:\\n                diff = nums[i] - nums[middle]\\n            else:\\n                continue\\n            if diff % x == 0:\\n                res += diff // x\\n            else:\\n                return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224789,
                "title": "median-of-2d-array-tle",
                "content": "I was curious to see if I can implment the quick select algorithm to find the median of 2d array without converting the 2d array to 1d array. I was able to do this but it gives me Time Limit Exceeds because of the large number of calculations required. Nonetheless, I decided to share the solutio if anyone is interested.\\n```\\nclass Solution {\\n    private Random random = new Random();\\n    private int nrCols;\\n    private int nrRows;\\n    private int size;\\n    private HashMap<Integer, Integer> rows = new HashMap<Integer, Integer>();\\n    private HashMap<Integer, Integer> cols = new HashMap<Integer, Integer>();\\n    \\n    public int minOperations(int[][] grid, int x) {\\n        nrRows = grid.length;\\n        nrCols = grid[0].length;\\n        \\n        size = nrRows * nrCols;\\n        int median = quickSelect(grid, 0, size, (size + 1) / 2);\\n        System.out.println(median);\\n        \\n        int total = 0;\\n        for (int row = 0; row < nrRows; row++) {\\n            for (int col = 0; col < nrCols; col++) {\\n                int diff = Math.abs(grid[row][col] - median);\\n                if (diff % x != 0) {\\n                    return -1;\\n                } else {\\n                    total += diff / x;\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int quickSelect(int [][] grid, int start, int end, int q) {\\n        if (start == end) {\\n            int i = Math.min(end, size - 1);\\n            \\n            return getValue(grid, i);\\n        }\\n        \\n        int index = randomizedPartition(grid, start, end);\\n        int range = index - start + 1;\\n        if (q == range) {\\n            return getValue(grid, index);\\n        } else if (q < range) {\\n            return quickSelect(grid, start, index, q);\\n        } else {\\n            return quickSelect(grid, index + 1, end, q - range);\\n        }\\n    }\\n    private int randomizedPartition(int [][] grid, int start, int end) {\\n        int index = start + random.nextInt(end - start);\\n        int row1 = getRow(index);\\n        int col1 = getCol(index);\\n\\n        int row = getRow(end - 1);\\n        int col = getCol(end - 1);\\n\\n        int temp = grid[row][col];\\n        grid[row][col] = grid[row1][col1];\\n        grid[row1][col1] = temp;\\n        \\n        return partition(grid, start, end);\\n    }\\n    \\n    private int partition(int [][] grid, int start, int end) {\\n        int row = getRow(end - 1);\\n        int col = getCol(end - 1);\\n        \\n        int pivot = grid[row][col];\\n        int i = start - 1;\\n        \\n        for (int j = start; j < end - 1; j++) {\\n            row = getRow(j);\\n            col = getCol(j);\\n            \\n            if (grid[row][col] <= pivot) {\\n                i++;\\n                int row1 = getRow(i);\\n                int col1 = getCol(i);\\n                \\n                int temp = grid[row][col];\\n                grid[row][col] = grid[row1][col1];\\n                grid[row1][col1] = temp;\\n            }\\n        }\\n        \\n        int row1 = getRow(i + 1);\\n        int col1 = getCol(i + 1);\\n\\n        row = getRow(end - 1);\\n        col = getCol(end - 1);\\n\\n        int temp = grid[row][col];\\n        grid[row][col] = grid[row1][col1];\\n        grid[row1][col1] = temp;\\n        \\n        return i + 1;\\n    }\\n    \\n    private int getRow(int index) {\\n        if (rows.containsKey(index)) {\\n            return rows.get(index);\\n        }\\n        return index / nrCols;\\n    }\\n    \\n    private int getCol(int index) {\\n        if (cols.containsKey(index)) {\\n            return cols.get(index);\\n        }\\n        return index % nrCols;\\n    }\\n    \\n    private int getValue(int [][] grid, int index) {\\n        int row = getRow(index);\\n        int col = getCol(index);\\n        \\n        return grid[row][col];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    private Random random = new Random();\\n    private int nrCols;\\n    private int nrRows;\\n    private int size;\\n    private HashMap<Integer, Integer> rows = new HashMap<Integer, Integer>();\\n    private HashMap<Integer, Integer> cols = new HashMap<Integer, Integer>();\\n    \\n    public int minOperations(int[][] grid, int x) {\\n        nrRows = grid.length;\\n        nrCols = grid[0].length;\\n        \\n        size = nrRows * nrCols;\\n        int median = quickSelect(grid, 0, size, (size + 1) / 2);\\n        System.out.println(median);\\n        \\n        int total = 0;\\n        for (int row = 0; row < nrRows; row++) {\\n            for (int col = 0; col < nrCols; col++) {\\n                int diff = Math.abs(grid[row][col] - median);\\n                if (diff % x != 0) {\\n                    return -1;\\n                } else {\\n                    total += diff / x;\\n                }\\n            }\\n        }\\n        \\n        return total;\\n    }\\n    \\n    private int quickSelect(int [][] grid, int start, int end, int q) {\\n        if (start == end) {\\n            int i = Math.min(end, size - 1);\\n            \\n            return getValue(grid, i);\\n        }\\n        \\n        int index = randomizedPartition(grid, start, end);\\n        int range = index - start + 1;\\n        if (q == range) {\\n            return getValue(grid, index);\\n        } else if (q < range) {\\n            return quickSelect(grid, start, index, q);\\n        } else {\\n            return quickSelect(grid, index + 1, end, q - range);\\n        }\\n    }\\n    private int randomizedPartition(int [][] grid, int start, int end) {\\n        int index = start + random.nextInt(end - start);\\n        int row1 = getRow(index);\\n        int col1 = getCol(index);\\n\\n        int row = getRow(end - 1);\\n        int col = getCol(end - 1);\\n\\n        int temp = grid[row][col];\\n        grid[row][col] = grid[row1][col1];\\n        grid[row1][col1] = temp;\\n        \\n        return partition(grid, start, end);\\n    }\\n    \\n    private int partition(int [][] grid, int start, int end) {\\n        int row = getRow(end - 1);\\n        int col = getCol(end - 1);\\n        \\n        int pivot = grid[row][col];\\n        int i = start - 1;\\n        \\n        for (int j = start; j < end - 1; j++) {\\n            row = getRow(j);\\n            col = getCol(j);\\n            \\n            if (grid[row][col] <= pivot) {\\n                i++;\\n                int row1 = getRow(i);\\n                int col1 = getCol(i);\\n                \\n                int temp = grid[row][col];\\n                grid[row][col] = grid[row1][col1];\\n                grid[row1][col1] = temp;\\n            }\\n        }\\n        \\n        int row1 = getRow(i + 1);\\n        int col1 = getCol(i + 1);\\n\\n        row = getRow(end - 1);\\n        col = getCol(end - 1);\\n\\n        int temp = grid[row][col];\\n        grid[row][col] = grid[row1][col1];\\n        grid[row1][col1] = temp;\\n        \\n        return i + 1;\\n    }\\n    \\n    private int getRow(int index) {\\n        if (rows.containsKey(index)) {\\n            return rows.get(index);\\n        }\\n        return index / nrCols;\\n    }\\n    \\n    private int getCol(int index) {\\n        if (cols.containsKey(index)) {\\n            return cols.get(index);\\n        }\\n        return index % nrCols;\\n    }\\n    \\n    private int getValue(int [][] grid, int index) {\\n        int row = getRow(index);\\n        int col = getCol(index);\\n        \\n        return grid[row][col];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224272,
                "title": "c-solution",
                "content": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int count=0;\\n        int tr=v[v.size()/2];\\n        for(int i=0;i<v.size();i++){\\n            if((abs(v[i]-tr)%x)!=0) return -1;\\n            count+=(abs(v[i]-tr)/x);\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2222372,
                "title": "c-easy-solution",
                "content": "\\t\\tclass Solution {\\n\\tpublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        int n= grid.size();\\n        for(int i = 0; i <n; i++){\\n            for(int j = 0; j <grid[0].size(); j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(v.begin(), v.end());\\n        int m = v.size();\\n        int ans = 0;\\n        int mid = abs(v[m / 2]);\\n        for(int i = m- 1; i >= 0; i--){\\n            if(abs(v[i] - mid) % x != 0){\\n                return -1;\\n            }else{\\n                ans += abs(v[i] - mid) / x;                \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>v;\\n        int n= grid.size();\\n        for(int i = 0; i <n; i++){\\n            for(int j = 0; j <grid[0].size(); j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2222101,
                "title": "c-easiest-solution-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        \\n        int n = ans.size();\\n        int count = 0;\\n        int med = abs(ans[n / 2]);\\n        // cout << med;\\n        for(int i = n - 1; i >= 0; i--){\\n            if(abs(ans[i] - med) % x != 0){\\n                return -1;\\n            }else{\\n                count += abs(ans[i] - med) / x;                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> ans;\\n        \\n        for(int i = 0; i < grid.size(); i++){\\n            for(int j = 0; j < grid[i].size(); j++){\\n                ans.push_back(grid[i][j]);\\n            }\\n        }\\n        \\n        sort(ans.begin(), ans.end());\\n        \\n        int n = ans.size();\\n        int count = 0;\\n        int med = abs(ans[n / 2]);\\n        // cout << med;\\n        for(int i = n - 1; i >= 0; i--){\\n            if(abs(ans[i] - med) % x != 0){\\n                return -1;\\n            }else{\\n                count += abs(ans[i] - med) / x;                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2221538,
                "title": "java-easy",
                "content": "class Solution {\\n    public int minOperations(int[][] grid, int x) {\\n            \\n        int r=grid.length;\\n        int c=grid[0].length;\\n        //Converting 2d array into 1d array of length m*n\\n        int [] arr=new int[r*c];\\n        \\n        int k=0;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                arr[k++]=grid[i][j];\\n            }\\n        }\\n        \\n        Arrays.sort(arr);\\n        \\n        int median=arr[(arr.length/2)];\\n        \\n           int count=0;             \\n         for(int n:arr)\\n          {     //The diff. between median element and present element should be a multiple of x\\n              if(Math.abs(median-n)%x!=0)\\n                  return -1;\\n              else\\n                  count+=Math.abs(median-n)/x;\\n                            \\n          }\\n                        return count;\\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minOperations(int[][] grid, int x) {\\n            \\n        int r=grid.length;\\n        int c=grid[0].length;\\n        //Converting 2d array into 1d array of length m*n\\n        int [] arr=new int[r*c];\\n        \\n        int k=0;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                arr[k++]=grid[i][j];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2221055,
                "title": "simple-c-solution-using-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for (auto i:grid) {\\n            for (auto x:i) v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());\\n        int mid=v[v.size()/2],ans=0;\\n        for (auto i:v) {\\n            if ((abs(mid-i))%x) return -1;\\n            else ans+=(abs(mid-i))/x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> v;\\n        for (auto i:grid) {\\n            for (auto x:i) v.push_back(x);\\n        }\\n        sort(v.begin(),v.end());\\n        int mid=v[v.size()/2],ans=0;\\n        for (auto i:v) {\\n            if ((abs(mid-i))%x) return -1;\\n            else ans+=(abs(mid-i))/x;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2221005,
                "title": "c-concise-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> val;\\n        int calgcd=grid[0][0];\\n        unordered_set<int> sp;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                val.push_back(grid[i][j]);\\n                sp.insert(grid[i][j]);\\n            }\\n        }\\n        if(sp.size()==1){\\n            return 0;\\n        }\\n        for(int i=1;i<val.size();i++){\\n            if(i==1){\\n                calgcd=abs(val[i]-val[i-1]);\\n            }\\n            else{\\n                calgcd=__gcd(calgcd, abs(val[i]-val[i-1]));\\n            }\\n           // cout<<calgcd<<endl;\\n        }\\n        \\n        if(val.size()>1 && calgcd%x!=0){\\n            return -1;\\n        }\\n        \\n        sort(val.begin(), val.end());\\n        int md=val.size()/2;\\n        int md2=(val.size()-1)/2;\\n        int ans=0, ans2=0;\\n        for(int i=0;i<val.size();i++){\\n            ans=ans+(abs(val[md]-val[i]))/x;\\n            ans2=ans2+(abs(val[md2]-val[i]))/x;\\n        }\\n        return min(ans, ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int> val;\\n        int calgcd=grid[0][0];\\n        unordered_set<int> sp;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j=0;j<grid[i].size();j++){\\n                val.push_back(grid[i][j]);\\n                sp.insert(grid[i][j]);\\n            }\\n        }\\n        if(sp.size()==1){\\n            return 0;\\n        }\\n        for(int i=1;i<val.size();i++){\\n            if(i==1){\\n                calgcd=abs(val[i]-val[i-1]);\\n            }\\n            else{\\n                calgcd=__gcd(calgcd, abs(val[i]-val[i-1]));\\n            }\\n           // cout<<calgcd<<endl;\\n        }\\n        \\n        if(val.size()>1 && calgcd%x!=0){\\n            return -1;\\n        }\\n        \\n        sort(val.begin(), val.end());\\n        int md=val.size()/2;\\n        int md2=(val.size()-1)/2;\\n        int ans=0, ans2=0;\\n        for(int i=0;i<val.size();i++){\\n            ans=ans+(abs(val[md]-val[i]))/x;\\n            ans2=ans2+(abs(val[md2]-val[i]))/x;\\n        }\\n        return min(ans, ans2);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2219237,
                "title": "java-o-m-n-o-m-n-log-m-n-two-pointer-solution",
                "content": "The easy solution is to convert the grid into linear data structure and try to meet in the middle. If the mod of difference between either left or right element with middle element leaves a remainder then it is not possible to meet in the middle. \\n\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> temp = new ArrayList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        \\n        Collections.sort(temp);\\n        int result = 0, left = 0, right = temp.size() - 1;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if((temp.get(mid) - temp.get(left)) % x != 0 \\n               || (temp.get(right) - temp.get(mid)) % x != 0) {\\n                return -1;\\n            }\\n            result += (temp.get(right--) - temp.get(left++)) / x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        List<Integer> temp = new ArrayList<>();\\n        for(int i = 0; i < grid.length; i++) {\\n            for(int j = 0; j < grid[0].length; j++) {\\n                temp.add(grid[i][j]);\\n            }\\n        }\\n        \\n        Collections.sort(temp);\\n        int result = 0, left = 0, right = temp.size() - 1;\\n        \\n        while(left < right) {\\n            int mid = left + (right - left) / 2;\\n            if((temp.get(mid) - temp.get(left)) % x != 0 \\n               || (temp.get(right) - temp.get(mid)) % x != 0) {\\n                return -1;\\n            }\\n            result += (temp.get(right--) - temp.get(left++)) / x;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218996,
                "title": "java-simple-approach",
                "content": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        boolean flag = true;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res[] = new int[m*n];\\n        int ind = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                res[ind++] = grid[i][j];\\n            }\\n        }\\n        if(res.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(res);\\n        int len = res.length;\\n        int temp = res[len/2];\\n        int temp1 = res[len/2-1];\\n        int diff = res[0]%x;\\n        int ans = 0;\\n        for(int i = 1;i<res.length;i++){\\n            if(res[i]%x != diff){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(!flag){\\n            return -1;\\n        }\\n        if(len%2 != 0){\\n            for(int i = 0;i<len;i++){\\n                ans += Math.abs(res[i] - temp)/x;\\n            }\\n        }\\n        else{\\n            int ans1 = 0, ans2 = 0;\\n            for(int i = 0;i<len;i++){\\n                ans1 += Math.abs(res[i] - temp)/x;\\n            }\\n            for(int i = 0;i<len;i++){\\n                ans2 += Math.abs(res[i] - temp1)/x;\\n            }\\n            ans = Math.min(ans1, ans2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        boolean flag = true;\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int res[] = new int[m*n];\\n        int ind = 0;\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                res[ind++] = grid[i][j];\\n            }\\n        }\\n        if(res.length == 1){\\n            return 0;\\n        }\\n        Arrays.sort(res);\\n        int len = res.length;\\n        int temp = res[len/2];\\n        int temp1 = res[len/2-1];\\n        int diff = res[0]%x;\\n        int ans = 0;\\n        for(int i = 1;i<res.length;i++){\\n            if(res[i]%x != diff){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(!flag){\\n            return -1;\\n        }\\n        if(len%2 != 0){\\n            for(int i = 0;i<len;i++){\\n                ans += Math.abs(res[i] - temp)/x;\\n            }\\n        }\\n        else{\\n            int ans1 = 0, ans2 = 0;\\n            for(int i = 0;i<len;i++){\\n                ans1 += Math.abs(res[i] - temp)/x;\\n            }\\n            for(int i = 0;i<len;i++){\\n                ans2 += Math.abs(res[i] - temp1)/x;\\n            }\\n            ans = Math.min(ans1, ans2);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2218664,
                "title": "javascript-easy-median-approach",
                "content": "```\\nvar minOperations = function(grid, x) {\\n    // extract the value of the grid in the array\\n    let arr = [];\\n    for(let i = 0;i<grid.length;i++){\\n        for(let j=0;j<grid[0].length;j++){\\n            arr.push(grid[i][j]);\\n        }\\n    }\\n    arr = arr.sort((a,b)=>a-b);\\n    let n = arr.length;\\n    let median = parseInt(n/2);\\n    let target = arr[median];\\n    let count = 0;\\n    \\n    for(let k = 0;k<arr.length;k++){\\n        if(Math.abs(target-arr[k])%x!==0) return -1\\n        else count = count + (Math.abs(arr[k]-target))/x;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minOperations = function(grid, x) {\\n    // extract the value of the grid in the array\\n    let arr = [];\\n    for(let i = 0;i<grid.length;i++){\\n        for(let j=0;j<grid[0].length;j++){\\n            arr.push(grid[i][j]);\\n        }\\n    }\\n    arr = arr.sort((a,b)=>a-b);\\n    let n = arr.length;\\n    let median = parseInt(n/2);\\n    let target = arr[median];\\n    let count = 0;\\n    \\n    for(let k = 0;k<arr.length;k++){\\n        if(Math.abs(target-arr[k])%x!==0) return -1\\n        else count = count + (Math.abs(arr[k]-target))/x;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2218428,
                "title": "java-o-m-n-fastest-building-the-logic",
                "content": "# \\uD83D\\uDCCC Pre-requites of the question : https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/\\n</br>\\n\\n# \\uD83E\\uDD14 Building the logic \\uD83E\\uDDE0 : \\n1\\uFE0F\\u20E3 :: ```Since we have to make all grid elements equal\\nSo First of all extract all m x n elements from the grid into a 1-D array```\\n2\\uFE0F\\u20E3 ::  ``` Sort the array```\\n3\\uFE0F\\u20E3 :: ```Now the question becomes almost same as https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ but with an extra factor involved which is jump value which was not present there. In that question we can take any choice of jump as we want but here we cannot```\\n\\nHowever , the root Concept will be same -> **For minimum steps we will try to bring all the numbers at the median of the array**\\n\\n\\u27A1\\uFE0F Lets say after sorting , array is like this **[1,2,3,4,5,6 ...........11,12,13]**\\n\\u27A1\\uFE0F Suppose Median of this array is **\\'n\\'**\\n\\u27A1\\uFE0F Now , we want to bring first and last element at median. Lets say the first element 1 covers x distance and the last element 13 covers y distance to reach the median. \\n  Then we can say that (1 + x)  == (13 - y)   => x+y = (13-1)\\n  so every pair of first and last element -> steps required to bring them together = (last - first)\\n  But since we can take only **x jumps** so (last - first) must be divisble by x otherwise they can never meet together.\\n  \\n  \\n  \\uD83C\\uDFAF  **One more check is required** : \\n  When we reach any element of the array\\n  Then this element should also be reachable from start (which guarantees that elements of the gird can converge together)\\n  so we need to check (curr - first) must be divisible by **x** for every **curr**. Otherwise there is no way to make elements or the grid together.\\n \\n \\n</br>\\n\\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] arr = new int[m*n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int si = 0;\\n        int ei = m*n-1;\\n        \\n        int steps=0;\\n        while(si<=ei)\\n        {\\n            if((arr[si]-arr[0]) % x !=0) return -1;  //element must be reachable from start\\n            int gap = (arr[ei]-arr[si]);\\n            if(gap%x!=0) return -1; //gap must be divisble by x\\n            else steps += gap/x;\\n            si++;\\n            ei--;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```\\n\\n</br>\\n\\n\\uD83C\\uDFAF Time Complexity : O(M*N) = O(10^5)\\n\\uD83C\\uDFAF Space Complexity : O(M*N) = O(10^5)\\n\\n\\uD83D\\uDCCCUpvote if you liked the approach \\uD83D\\uDE04\\uD83D\\uDE0A",
                "solutionTags": [
                    "Math",
                    "Greedy"
                ],
                "code": "```Since we have to make all grid elements equal\\nSo First of all extract all m x n elements from the grid into a 1-D array```\n``` Sort the array```\n```Now the question becomes almost same as https://leetcode.com/problems/minimum-moves-to-equal-array-elements-ii/ but with an extra factor involved which is jump value which was not present there. In that question we can take any choice of jump as we want but here we cannot```\n```\\nclass Solution {\\n    public int minOperations(int[][] grid, int x) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        int[] arr = new int[m*n];\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                arr[i*n+j] = grid[i][j];\\n            }\\n        }\\n        Arrays.sort(arr);\\n        int si = 0;\\n        int ei = m*n-1;\\n        \\n        int steps=0;\\n        while(si<=ei)\\n        {\\n            if((arr[si]-arr[0]) % x !=0) return -1;  //element must be reachable from start\\n            int gap = (arr[ei]-arr[si]);\\n            if(gap%x!=0) return -1; //gap must be divisble by x\\n            else steps += gap/x;\\n            si++;\\n            ei--;\\n        }\\n        \\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217736,
                "title": "easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n    vector<int> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j =0;j<grid[i].size();j++){\\n                v.push_back(grid[i][j]);\\n            }\\n        }\\n        if(v.size()<=1){\\n            return 0;\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        int ans =0;\\n        int mid =(v.size()/2);\\n        for(int i=0;i<v.size();i++){\\n            int b =abs(v[i]-v[mid]);\\n            if(b%x==0){\\n                ans+= b/x;\\n            }\\n            else{\\n                return -1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n    vector<int> v;\\n        for(int i=0;i<grid.size();i++){\\n            for(int j =0;j<grid[i].size();j++){\\n                v.push_back(grid[i][j]);\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566686,
                "content": [
                    {
                        "username": "jorgealfaro028",
                        "content": "I\\'m seeing alot of answers that sort, find the median and calculate how much it takes each val to get there.\\n\\nI considered doing this i didn\\'t know if it would always yield the most optimal way to get to equality. How did you confirm this? how do you prove this is true.  Thanks!"
                    },
                    {
                        "username": "cjf12harry",
                        "content": "# 1. If there is a solution, the solution can be one of the elements\\nThe precondition for the problem to have a solution is the difference between any pair of two elements have to be multiples of x.\\n\\nAssume there is some target t (that is larger than all elements) , then we have\\nt - arr[i] = x * mi (mi is an integer)\\nt- arr[j] = x * mj (mj is an integer)\\nsubtract the two equations, we have arr[j]-arr[i] = x * (mj-mi).\\nFrom here we know arr[i] can become arr[j] by adding x (mj-mi) times.\\nThe same can be concluded if we choose other target t that is less than all elements, or between two elements.\\n\\nTherefore we can conclude, if there is a valid target, the target can be one of the elements. \\n\\n# 2.Median is the solution\\nGiven that we know the flatten array can achieve uni-value (i.e. every elements mod x has the same reminder), why the median is the target that leads to minimal operations? \\n\\nFirst we assume there is a target t, then the sum of absolute difference between every element and t is sum0. Then the number of operation is sum0/x. The problem is converted to finding the minimal sum0.\\n\\nAssume that we have a sorted array in ascending order, and arr[m] is the median. \\n\\nNow we set the target be the median and sum1 is the absolute difference between every element and median\\n\\ngiven the notations:\\nn_smaller = numer of element smaller than arr[m]\\nn_larger = number of elements larger than arr[m]\\nn_equal = number of elements equal than arr[m]\\n\\nIf we set the target to the right of the median, the new sum2 would be sum1+ (n_smaller) * diff + (n_equal) * diff - (n_larger) * diff  = sum1 +(n_smaller+n_equal-n_larger) * diff > sum1 . By definition of median n_smaller+n_equal-n_larger>0\\n\\nIf we set the target to the left of the median, the new sum3 would be sum1- (n_smaller) * diff + (n_equal) * diff + (n_larger) * diff  = sum1 +(-n_smaller+n_equal+n_larger) * diff > sum1 . By definition of median -n_smaller+n_equal+n_larger>0\\n\\nMoving away further from the median, we find that the amount added to the sum is always larger than the amount subtracted. Similarly, if there is a target that is not any of the array elements, we can argue that moving from the median to that target, the amount added is more than that subtracted from the sum we want to optimize.\\n\\nTherefore the median is the target we need to minimize the sum of absolute difference."
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//c++ solution fast and efficient\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>temp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(temp.begin(),temp.end());\\n         int n=temp.size();\\n         int mid=temp[n/2];\\n         int ans=0;\\n         for(int i=0;i<n;i++)\\n         {\\n             int diff=abs(temp[i]-mid);\\n               if(diff%x!=0)\\n                  return -1;\\n              ans+=diff/x;\\n         }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1567679,
                "content": [
                    {
                        "username": "jorgealfaro028",
                        "content": "I\\'m seeing alot of answers that sort, find the median and calculate how much it takes each val to get there.\\n\\nI considered doing this i didn\\'t know if it would always yield the most optimal way to get to equality. How did you confirm this? how do you prove this is true.  Thanks!"
                    },
                    {
                        "username": "cjf12harry",
                        "content": "# 1. If there is a solution, the solution can be one of the elements\\nThe precondition for the problem to have a solution is the difference between any pair of two elements have to be multiples of x.\\n\\nAssume there is some target t (that is larger than all elements) , then we have\\nt - arr[i] = x * mi (mi is an integer)\\nt- arr[j] = x * mj (mj is an integer)\\nsubtract the two equations, we have arr[j]-arr[i] = x * (mj-mi).\\nFrom here we know arr[i] can become arr[j] by adding x (mj-mi) times.\\nThe same can be concluded if we choose other target t that is less than all elements, or between two elements.\\n\\nTherefore we can conclude, if there is a valid target, the target can be one of the elements. \\n\\n# 2.Median is the solution\\nGiven that we know the flatten array can achieve uni-value (i.e. every elements mod x has the same reminder), why the median is the target that leads to minimal operations? \\n\\nFirst we assume there is a target t, then the sum of absolute difference between every element and t is sum0. Then the number of operation is sum0/x. The problem is converted to finding the minimal sum0.\\n\\nAssume that we have a sorted array in ascending order, and arr[m] is the median. \\n\\nNow we set the target be the median and sum1 is the absolute difference between every element and median\\n\\ngiven the notations:\\nn_smaller = numer of element smaller than arr[m]\\nn_larger = number of elements larger than arr[m]\\nn_equal = number of elements equal than arr[m]\\n\\nIf we set the target to the right of the median, the new sum2 would be sum1+ (n_smaller) * diff + (n_equal) * diff - (n_larger) * diff  = sum1 +(n_smaller+n_equal-n_larger) * diff > sum1 . By definition of median n_smaller+n_equal-n_larger>0\\n\\nIf we set the target to the left of the median, the new sum3 would be sum1- (n_smaller) * diff + (n_equal) * diff + (n_larger) * diff  = sum1 +(-n_smaller+n_equal+n_larger) * diff > sum1 . By definition of median -n_smaller+n_equal+n_larger>0\\n\\nMoving away further from the median, we find that the amount added to the sum is always larger than the amount subtracted. Similarly, if there is a target that is not any of the array elements, we can argue that moving from the median to that target, the amount added is more than that subtracted from the sum we want to optimize.\\n\\nTherefore the median is the target we need to minimize the sum of absolute difference."
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//c++ solution fast and efficient\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>temp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(temp.begin(),temp.end());\\n         int n=temp.size();\\n         int mid=temp[n/2];\\n         int ans=0;\\n         for(int i=0;i<n;i++)\\n         {\\n             int diff=abs(temp[i]-mid);\\n               if(diff%x!=0)\\n                  return -1;\\n              ans+=diff/x;\\n         }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1675232,
                "content": [
                    {
                        "username": "jorgealfaro028",
                        "content": "I\\'m seeing alot of answers that sort, find the median and calculate how much it takes each val to get there.\\n\\nI considered doing this i didn\\'t know if it would always yield the most optimal way to get to equality. How did you confirm this? how do you prove this is true.  Thanks!"
                    },
                    {
                        "username": "cjf12harry",
                        "content": "# 1. If there is a solution, the solution can be one of the elements\\nThe precondition for the problem to have a solution is the difference between any pair of two elements have to be multiples of x.\\n\\nAssume there is some target t (that is larger than all elements) , then we have\\nt - arr[i] = x * mi (mi is an integer)\\nt- arr[j] = x * mj (mj is an integer)\\nsubtract the two equations, we have arr[j]-arr[i] = x * (mj-mi).\\nFrom here we know arr[i] can become arr[j] by adding x (mj-mi) times.\\nThe same can be concluded if we choose other target t that is less than all elements, or between two elements.\\n\\nTherefore we can conclude, if there is a valid target, the target can be one of the elements. \\n\\n# 2.Median is the solution\\nGiven that we know the flatten array can achieve uni-value (i.e. every elements mod x has the same reminder), why the median is the target that leads to minimal operations? \\n\\nFirst we assume there is a target t, then the sum of absolute difference between every element and t is sum0. Then the number of operation is sum0/x. The problem is converted to finding the minimal sum0.\\n\\nAssume that we have a sorted array in ascending order, and arr[m] is the median. \\n\\nNow we set the target be the median and sum1 is the absolute difference between every element and median\\n\\ngiven the notations:\\nn_smaller = numer of element smaller than arr[m]\\nn_larger = number of elements larger than arr[m]\\nn_equal = number of elements equal than arr[m]\\n\\nIf we set the target to the right of the median, the new sum2 would be sum1+ (n_smaller) * diff + (n_equal) * diff - (n_larger) * diff  = sum1 +(n_smaller+n_equal-n_larger) * diff > sum1 . By definition of median n_smaller+n_equal-n_larger>0\\n\\nIf we set the target to the left of the median, the new sum3 would be sum1- (n_smaller) * diff + (n_equal) * diff + (n_larger) * diff  = sum1 +(-n_smaller+n_equal+n_larger) * diff > sum1 . By definition of median -n_smaller+n_equal+n_larger>0\\n\\nMoving away further from the median, we find that the amount added to the sum is always larger than the amount subtracted. Similarly, if there is a target that is not any of the array elements, we can argue that moving from the median to that target, the amount added is more than that subtracted from the sum we want to optimize.\\n\\nTherefore the median is the target we need to minimize the sum of absolute difference."
                    },
                    {
                        "username": "Shivanshu2103",
                        "content": "//c++ solution fast and efficient\\nclass Solution {\\npublic:\\n    int minOperations(vector<vector<int>>& grid, int x) {\\n        vector<int>temp;\\n        for(int i=0;i<grid.size();i++)\\n        {\\n            for(int j=0;j<grid[0].size();j++)\\n            {\\n                temp.push_back(grid[i][j]);\\n            }\\n        }\\n        sort(temp.begin(),temp.end());\\n         int n=temp.size();\\n         int mid=temp[n/2];\\n         int ans=0;\\n         for(int i=0;i<n;i++)\\n         {\\n             int diff=abs(temp[i]-mid);\\n               if(diff%x!=0)\\n                  return -1;\\n              ans+=diff/x;\\n         }\\n        return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]