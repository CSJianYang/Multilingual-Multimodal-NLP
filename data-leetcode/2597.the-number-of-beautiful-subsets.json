[
    {
        "title": "The Number of Beautiful Subsets",
        "question_content": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n&nbsp;\nExample 1:\n\nInput: nums = [2,4,6], k = 2\nOutput: 4\nExplanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].\nIt can be proved that there are only 4 beautiful subsets in the array [2,4,6].\n\nExample 2:\n\nInput: nums = [1], k = 1\nOutput: 1\nExplanation: The beautiful subset of the array nums is [1].\nIt can be proved that there is only 1 beautiful subset in the array [1].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 20\n\t1 <= nums[i], k <= 1000",
        "solutions": [
            {
                "id": 3314361,
                "title": "python-house-robber-o-n",
                "content": "# **Explanation**\\nSplit `A[i]` into different group by the value of `A[i] % k`.\\nCount the frequency of `A[i]`.\\nSort `A[i]` and then do [198. House Robber](https://leetcode.com/problems/house-robber/).\\n\\n`dp0` is the ways that without `A[i]`\\n`dp1` is the ways that with `A[i]`\\n<br>\\n\\n# **Complexity**\\nTime `O(nlogn + k)`\\nSpace `O(n + k)`\\n<br>\\n\\n**Python**\\n```py\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = [Counter() for i in range(k)]\\n        for a in A:\\n            count[a % k][a] += 1\\n        res = 1\\n        for i in range(k):\\n            prev, dp0, dp1 = 0, 1, 0\\n            for a in sorted(count[i]):\\n                v = pow(2, count[i][a])\\n                if prev + k == a:\\n                    dp0, dp1 = dp0 + dp1, dp0 * (v - 1)\\n                else:\\n                    dp0, dp1 = dp0 + dp1, (dp0 + dp1) * (v - 1)\\n                prev = a\\n            res *= dp0 + dp1\\n        return res - 1\\n```\\n<br>\\n\\n# Solution 2\\nInspired by @yawn_sean,\\nContinue to optimize the solution 1.\\nIn solution 1, we sort elements by remainder,\\nto get the house robber input array.\\nActually we can check if `count[a + k] > 0`,\\nand find out the last element for arithmetic sequence.\\n\\nCount the frequency of `A`,\\nand then consider all the arithmetic sequence with difference `k`.\\n\\nEach arithmetic sequence can be solve as a hourse robber problem.\\nWe solve the hourse robber by `dp`.\\n`dp(a)` return the result for sequence no bigger than `a`.\\n\\n`dp(a)[0]` is the ways that without `a`\\n`dp(a)[1]` is the ways that with `a`\\n\\n`dp(a)[0] = dp(a - k)[0] + dp(a - k)[1]`\\n`dp(a)[1] = dp(a - k)[0] * (2 ^ count(a) - 1`\\n\\n\\n**Python**\\n```py\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = Counter(A)\\n\\n        def dp(a):\\n            dp0, dp1 = dp(a - k) if a - k in count else (1, 0)\\n            return dp0 + dp1, dp0 * (pow(2, count[a]) - 1)\\n\\n        return reduce(mul, (sum(dp(a)) for a in count if not count[a + k])) - 1\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = [Counter() for i in range(k)]\\n        for a in A:\\n            count[a % k][a] += 1\\n        res = 1\\n        for i in range(k):\\n            prev, dp0, dp1 = 0, 1, 0\\n            for a in sorted(count[i]):\\n                v = pow(2, count[i][a])\\n                if prev + k == a:\\n                    dp0, dp1 = dp0 + dp1, dp0 * (v - 1)\\n                else:\\n                    dp0, dp1 = dp0 + dp1, (dp0 + dp1) * (v - 1)\\n                prev = a\\n            res *= dp0 + dp1\\n        return res - 1\\n```\n```py\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = Counter(A)\\n\\n        def dp(a):\\n            dp0, dp1 = dp(a - k) if a - k in count else (1, 0)\\n            return dp0 + dp1, dp0 * (pow(2, count[a]) - 1)\\n\\n        return reduce(mul, (sum(dp(a)) for a in count if not count[a + k])) - 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3363862,
                "title": "c-java-python-evolve-brute-force-to-dp-explained-7-approaches",
                "content": "For every element $x$, we have a choice to take or not take it to make the subset. So, maximum number of possible subsets can be $2^n$.\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - I (Recursion + Backtracking) [Accepted]***\\n\\nLet\\'s say we have to decide to take or not take the element at index $i$. We can recursively make two calls, one for not taking it and another for taking it. Since, question says subset should be non-empty, $1$ is subtracted from final result.\\n\\nTo take the element at index $i$, the elements $nums[i] \\\\pm k$ should not be taken in the subset before. Frequency map can be made to keep the track of elements taken till now.\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int _beautifulSubsets(vector<int>& nums, int k, unordered_map<int, int>& freq, int i) {\\n        if (i == nums.size()) { // base case\\n            return 1;\\n        }\\n        int result = _beautifulSubsets(nums, k, freq, i + 1); // nums[i] not taken\\n        if (!freq[nums[i] - k] && !freq[nums[i] + k]) { // check if we can take nums[i]\\n            freq[nums[i]]++;\\n            result += _beautifulSubsets(nums, k, freq, i + 1); // nums[i] taken\\n            freq[nums[i]]--;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        return _beautifulSubsets(nums, k, freq, 0) - 1; // -1 for empty subset\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private HashMap<Integer, Integer> freq;\\n\\n    private int beautifulSubsets(int[] nums, int k, int i) {\\n        if (i == nums.length) { // base case\\n            return 1;\\n        }\\n        int result = beautifulSubsets(nums, k, i + 1); // nums[i] not taken\\n        if (!freq.containsKey(nums[i] - k) && !freq.containsKey(nums[i] + k)) { // check if we can take nums[i]\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n            result += beautifulSubsets(nums, k, i + 1); // nums[i] taken\\n            freq.put(nums[i], freq.get(nums[i]) - 1);\\n            if (freq.get(nums[i]) == 0) {\\n                freq.remove(nums[i]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        freq = new HashMap<Integer, Integer>();\\n        return beautifulSubsets(nums, k, 0) - 1; // -1 for empty subset\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        def f(i: int) -> int:\\n            if i == len(nums): # base case\\n                return 1\\n            result = f(i + 1) # nums[i] not taken\\n            if not nums[i] - k in freq and not nums[i] + k in freq: # check if we can take nums[i]\\n                freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\\n                result += f(i + 1) # nums[i] taken\\n                freq[nums[i]] -= 1\\n                if freq[nums[i]] == 0:\\n                    del freq[nums[i]]\\n            return result\\n        return f(0) - 1 # -1 for empty subset\\n```\\n\\nSince, maximum no. of subsets can be $2^n$, time complexity will be $O(2^n)$.\\nRecursion stack space and frequency map will make space complexity $O(n)$.\\n\\n- Time Complexity: $$O(2^n)$$\\n- Space Complexity: $$O(n)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - II (Recursion + Backtracking) [Accepted]***\\n\\nSince time complexity is already $O(2^n)$, sorting the array beforehand, for $O(n \\\\log n)$, will not change it. Also, if we know that before the current index $i$, there were no larger elements, then we have to check just for the existence of $nums[i] - k$, and not for $nums[i] + k$. Therefore, we sort the array.\\n\\nTime/Space Complexities will be same as before but LeetCode\\'s Online Judge shows difference of $1200 ms$ and $800 ms$, so I thought to mention it too, as number of operations will be less.\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int _beautifulSubsets(vector<int>& nums, int k, unordered_map<int, int>& freq, int i) {\\n        if (i == nums.size()) { // base case\\n            return 1;\\n        }\\n        int result = _beautifulSubsets(nums, k, freq, i + 1); // nums[i] not taken\\n        if (!freq[nums[i] - k]) { // check if we can take nums[i]\\n            freq[nums[i]]++;\\n            result += _beautifulSubsets(nums, k, freq, i + 1); // nums[i] taken\\n            freq[nums[i]]--;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        sort(nums.begin(), nums.end());\\n        return _beautifulSubsets(nums, k, freq, 0) - 1; // -1 for empty subset\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private HashMap<Integer, Integer> freq;\\n\\n    private int beautifulSubsets(int[] nums, int k, int i) {\\n        if (i == nums.length) { // base case\\n            return 1;\\n        }\\n        int result = beautifulSubsets(nums, k, i + 1); // nums[i] not taken\\n        if (!freq.containsKey(nums[i] - k)) { // check if we can take nums[i]\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n            result += beautifulSubsets(nums, k, i + 1); // nums[i] taken\\n            freq.put(nums[i], freq.get(nums[i]) - 1);\\n            if (freq.get(nums[i]) == 0) {\\n                freq.remove(nums[i]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        freq = new HashMap<Integer, Integer>();\\n        Arrays.sort(nums);\\n        return beautifulSubsets(nums, k, 0) - 1; // -1 for empty subset\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        nums.sort()\\n        def f(i: int) -> int:\\n            if i == len(nums): # base case\\n                return 1\\n            result = f(i + 1) # nums[i] not taken\\n            if not nums[i] - k in freq: # check if we can take nums[i]\\n                freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\\n                result += f(i + 1) # nums[i] taken\\n                freq[nums[i]] -= 1\\n                if freq[nums[i]] == 0:\\n                    del freq[nums[i]]\\n            return result\\n        return f(0) - 1 # -1 for empty subset\\n```\\n\\n- Time Complexity: $$O(2^n)$$\\n- Space Complexity: $$O(n)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - III (Recursion Optimized) [Accepted]***\\n\\nIn the above approach, we are trying to make every possible subset. The reason why we can\\'t directly return $2^n$ without going to every subset, is that we don\\'t know how many of them will satisfy the condition of *beautiful*. But what if there are no elements in the array whose difference is $k$?\\n\\n**Example 1**\\nSuppose $nums = [1, 3, 5, 7]$, $k = 1$. We have differences of $2, 4, 6$ but never $1$. So, if we knew this before, we could have directly returned $2^n - 1 = 15$, ($-1$ for empty subset) without actually going to every subset by backtracking.\\n\\n**Example 2**\\nNow, suppose $nums = [1, 2, 3, 4]$, $k = 2$. Difference of $2$ can be made by $4-2$, and $3-1$. That means $[2, 4]$ can\\'t be in the same subset. Also, $[1, 3]$ can\\'t be in the same subset. So, how can we write the answer if we knew this before?\\nWe have two sets,\\n$s_1 = [1, 3]$\\n$s_2 = [2, 4]$\\nWe can calculate number of *beautiful* subsets for $s_1$ and $s_2$ separately because the choices in $s_1$ is independent of $s_2$ and vice versa. Let the answers be $f(s_1)$ and $f(s_2)$.\\nFor final answer, we can multiply both of them because there is no pair $(x_1,x_2)$ such that $x_1 \\\\in s_1$, $x_2 \\\\in s_2$ and $|x_1-x_2| = k$.\\n$f(nums) = f(s_1) \\\\times f(s_2) - 1$ ($-1$ for empty subset)\\n\\n**Example 3**\\nSo, one thing we can do is to separate the given array into these subsets, such that there is no pair $(x_1,x_2)$, $x_1$ and $x_2$ belonging to different subsets and $|x_1-x_2| = k$.\\nIn one subset, there will be elemenets of the form: $[x, x + k, x + 2k, ..., x + \\\\lambda k]$.\\nIf we take $x$, then we can\\'t take $x+k$, but can take $x+2k$ and so on.\\nAll these elements have common remainder when divided by $k$. So we can make these subsets by separating on the basis of remainder ($\\\\mod k$ ).\\nFor example, $nums = [1, 2, 3, 4, 5, 6]$, $k = 2$.\\n- $s_1$ : $nums[i] \\\\enspace \\\\% \\\\enspace k = 0$ : $[2,4,6]$\\n- $s_2$ : $nums[i] \\\\enspace \\\\% \\\\enspace k = 1$ : $[1,3,5]$\\n\\nNote that all $x+\\\\lambda k$ might not be available in $s_1$. For example, there might be a possibility where $x+k$ is not present in $nums$ at all so subset will look like $[x, x+2k, ...]$.\\n\\n**Example 4**\\nNow, suppose $nums = [5, 5, 5, 7, 7]$, $k = 2$. We can\\'t take $[5, 7]$ in the same subset. Representing $s_1$ in $\\\\{value: frequency\\\\}$ form\\n$s_1 = [5: 3, 7: 2]$\\nLet\\'s say $f(i)$ calculates number of beautiful subsets in $s_1$ starting from index $i$. We want to calculate $f(0)$.\\n\\n- When $i = 0$, we are at $5$, there are two options, whether we skip it or take it. There are $2^3$ ways, out of which in $2^3-1=7$ ways, we take atleast one $5$, and one way where we skip $5$.\\n$take_5=7$, $skip_5=1$\\n- Now, next element at $i + 1$ is $7=5+2$, so we can\\'t take it if we took $5$. Therefore, number of ways of taking $5$ will be $take_5 \\\\times f(i + 2)$.\\n- Number of ways of skipping $5$ will be $skip_5 \\\\times f(i + 1)$.\\n- $take_{s[i]} = 2 ^ {frequency(s[i])} - 1$\\n- $skip_{s[i]} = 1$\\n- $f(i) = take_{s[i]} \\\\times f(i + 2) + skip_{s[i]} \\\\times f(i + 1)$\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int beautifulSubsets(vector<pair<int, int>>& s, int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int skip = beautifulSubsets(s, n, k, i + 1); // 1 * f(i + 1)\\n        int take = (1 << s[i].second) - 1; // take s[i]\\n        if (i + 1 < n && s[i + 1].first - s[i].first == k) { // next number is s[i] + k\\n            take *= beautifulSubsets(s, n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(s, n, k, i + 1);\\n        }\\n        return skip + take;\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int,     map<int,  int>> freq;\\n        // {remainder : {num : frequency}}\\n        // map is sorted based on num to get subset of form [x, x + k, x + 2k, ...]\\n        for (int& x: nums) { // splitting subsets based on remainder and calculating frequency\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) { // loop for s1, s2, ...\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            result *= beautifulSubsets(s, s.size(), k, 0); // f(s1) * f(s2) ...\\n        }\\n        return result - 1; // -1 for empty subset\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int[][] s;\\n\\n    private void mapToList(Map<Integer, Integer> fr) {\\n        s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n    }\\n\\n    private int beautifulSubsets(int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int skip = beautifulSubsets(n, k, i + 1); // 1 * f(i + 1)\\n        int take = (1 << s[i][1]) - 1; // take s[i]\\n        if (i + 1 < n && s[i + 1][0] - s[i][0] == k) { // next number is s[i] + k\\n            take *= beautifulSubsets(n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(n, k, i + 1);\\n        }\\n        return skip + take;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        // {remainder : {num :    frequency}}\\n        // map is sorted based on num to get subset of form [x, x + k, x + 2k, ...]\\n        for (int x: nums) { // splitting subsets based on remainder and calculating frequency\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) { // loop for s1, s2, ...\\n            mapToList(fr);\\n            result *= beautifulSubsets(s.length, k, 0); // f(s1) * f(s2) ...\\n        }\\n        return result - 1; // -1 for empty subset\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        # {remainder : {num : frequency}}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values(): # loop for s1, s2, ...\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            def f(i: int) -> int:\\n                if i == len(s):\\n                    return 1\\n                skip = f(i + 1) # 1 * f(i + 1)\\n                take = 2 ** s[i][1] - 1 # take s[i]\\n                if i + 1 < len(s) and s[i + 1][0] - s[i][0] == k: # next number is s[i] + k\\n                    take *= f(i + 2)\\n                else:\\n                    take *= f(i + 1)\\n                return skip + take\\n            result *= f(0) # f(s1) * f(s2) ...\\n        return result - 1 # -1 for empty subset\\n```\\n\\nSince map is sorted, it is implemented by Self Balancing BST. Insert operation is $O(\\\\log n)$, it will take $O(n \\\\log n)$ to make map. There can be $k$ different remainders, meaning maximum $k$ subset splits.\\nWorst case hits when remainder is same for all numbers (i.e., all comes in same subset $s_1$) and no number is repeated ($frequency = 1$), time is still $O(2^n)$.\\n\\n- Time Complexity: $$O(n \\\\log n + 2^n) = O(2^n)$$\\n- Space Complexity: $$O(n + k)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - IV (DP: Recursion + Memoization) [Accepted]***\\n\\n$f(i)$ calculates number of beautiful subsets in $s$ starting from index $i$. Memoize the function $f(i)$.\\n\\n```C++ []\\nclass Solution {\\nprivate:\\n    int beautifulSubsets(vector<pair<int, int>>& s, int n, int k, int i, vector<int>& count) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        if (count[i] != -1) {\\n            return count[i];\\n        }\\n        int skip = beautifulSubsets(s, n, k, i + 1, count);\\n        int take = (1 << s[i].second) - 1;\\n        if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n            take *= beautifulSubsets(s, n, k, i + 2, count);\\n        } else {\\n            take *= beautifulSubsets(s, n, k, i + 1, count);\\n        }\\n        return count[i] = skip + take;\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            vector<int> count(s.size(), -1);\\n            result *= beautifulSubsets(s, s.size(), k, 0, count);\\n        }\\n        return result - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    int[][] s;\\n    int[] count;\\n\\n    private void mapToList(Map<Integer, Integer> fr) {\\n        s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n    }\\n\\n    private int beautifulSubsets(int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        if (count[i] != -1) {\\n            return count[i];\\n        }\\n        int skip = beautifulSubsets(n, k, i + 1);\\n        int take = (1 << s[i][1]) - 1;\\n        if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n            take *= beautifulSubsets(n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(n, k, i + 1);\\n        }\\n        return count[i] = skip + take;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            mapToList(fr);\\n            count = new int[fr.size()];\\n            Arrays.fill(count, -1);\\n            result *= beautifulSubsets(s.length, k, 0);\\n        }\\n        return result - 1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            @cache\\n            def f(i: int) -> int:\\n                if i == len(s):\\n                    return 1\\n                skip = f(i + 1)\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < len(s) and s[i + 1][0] - s[i][0] == k:\\n                    take *= f(i + 2)\\n                else:\\n                    take *= f(i + 1)\\n                return skip + take\\n            result *= f(0)\\n        return result - 1\\n```\\n\\nMaking map is still $O(n \\\\log n)$. Calculating answer for one subset will be equal to number of states in DP which makes it $O(n)$.\\n\\n- Time Complexity: $$O(n \\\\log n + n) = O(n \\\\log n)$$\\n- Space Complexity: $$O(n + k)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - V (Iterative DP) [Accepted]***\\n\\nChanging recursion to iteration. To calculate $f(i)$, we need to know $f(i + 1)$ and $f(i + 2)$. So DP should be filled right to left.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int n = fr.second.size();\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            vector<int> count(n + 1);\\n            count[n] = 1;\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = count[i + 1];\\n                int take = (1 << s[i].second) - 1;\\n                if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n                    take *= count[i + 2];\\n                } else {\\n                    take *= count[i + 1];\\n                }\\n                count[i] = skip + take;\\n            }\\n            result *= count[0];\\n        }\\n        return result - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[][] mapToList(Map<Integer, Integer> fr) {\\n        int[][] s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n        return s;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            int n = fr.size();\\n            int[][] s = mapToList(fr);\\n            int[] count = new int[n + 1];\\n            count[n] = 1;\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = count[i + 1];\\n                int take = (1 << s[i][1]) - 1;\\n                if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n                    take *= count[i + 2];\\n                } else {\\n                    take *= count[i + 1];\\n                }\\n                count[i] = skip + take;\\n            }\\n            result *= count[0];\\n        }\\n        return result - 1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            n = len(fr)\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            count = [0] * (n + 1)\\n            count[n] = 1\\n            for i in range(n - 1, -1, -1):\\n                skip = count[i + 1]\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < n and s[i + 1][0] - s[i][0] == k:\\n                    take *= count[i + 2]\\n                else:\\n                    take *= count[i + 1]\\n                count[i] = skip + take\\n            result *= count[0]\\n        return result - 1\\n```\\n\\n- Time Complexity: $$O(n \\\\log n)$$\\n- Space Complexity: $$O(n + k)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - VI (Iterative DP Space Optimized) [Accepted]***\\n\\nTo calculate $f(i)$, we only need $f(i + 1)$ and $f(i + 2)$.\\nStoring $f(i + 3)$ onwards is useless.\\n- $curr = f(i)$\\n- $next_1 = f(i + 1)$\\n- $next_2 = f(i + 2)$\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int n = fr.second.size(), curr, next1 = 1, next2;\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = next1;\\n                int take = (1 << s[i].second) - 1;\\n                if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n                    take *= next2;\\n                } else {\\n                    take *= next1;\\n                }\\n                curr = skip + take;\\n                next2 = next1; next1 = curr;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    private int[][] mapToList(Map<Integer, Integer> fr) {\\n        int[][] s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n        return s;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            int n = fr.size(), curr = 1, next1 = 1, next2 = 0;\\n            int[][] s = mapToList(fr);\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = next1;\\n                int take = (1 << s[i][1]) - 1;\\n                if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n                    take *= next2;\\n                } else {\\n                    take *= next1;\\n                }\\n                curr = skip + take;\\n                next2 = next1; next1 = curr;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            n, curr, next1, next2 = len(fr), 1, 1, 0\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            for i in range(n - 1, -1, -1):\\n                skip = next1\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < n and s[i + 1][0] - s[i][0] == k:\\n                    take *= next2\\n                else:\\n                    take *= next1\\n                curr = skip + take\\n                next2, next1 = next1, curr\\n            result *= curr\\n        return result - 1\\n```\\n\\n- Time Complexity: $$O(n \\\\log n)$$\\n- Space Complexity: $$O(n + k)$$\\n\\n---\\n\\n***\\u2714\\uFE0F Solution - VII (Iterative DP: Forward) [Accepted]***\\n\\nIn previous approaches, we were calculating in reverse direction (right to left) of $s$. Due to this, we needed to convert sorted map to array first. It can be avoided if we traverse left to right.\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int prevNum = -k, prev2, prev1 = 1, curr;\\n            for (auto& [num, f]: fr.second) {\\n                int skip = prev1;\\n                int take = ((1 << f) - 1) * (num - prevNum == k ? prev2 : prev1);\\n                curr = skip + take;\\n                prev2 = prev1; prev1 = curr;\\n                prevNum = num;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map<Integer, Integer> fr: freq.values()) {\\n            int prevNum = -k, prev2 = 0, prev1 = 1, curr = 1;\\n            for (Map.Entry<Integer, Integer> entry: fr.entrySet()) {\\n                int num = entry.getKey(), f = entry.getValue();\\n                int skip = prev1;\\n                int take = ((1 << f) - 1) * (num - prevNum == k ? prev2 : prev1);\\n                curr = skip + take;\\n                prev2 = prev1; prev1 = curr;\\n                prevNum = num;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            prevNum, curr, prev1, prev2 = -k, 1, 1, 0\\n            for num in sorted(fr):\\n                skip = prev1\\n                take = (2 ** fr[num] - 1) * (prev2 if num - prevNum == k else prev1)\\n                curr = skip + take\\n                prev2, prev1 = prev1, curr\\n                prevNum = num\\n            result *= curr\\n        return result - 1\\n```\\n\\n- Time Complexity: $O(n \\\\log n)$\\n- Space Complexity: $O(n + k)$\\n\\n---\\n\\nFor any mistakes / suggestions / questions, please do comment below \\uD83D\\uDC47\\nUpvote if helps!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\nprivate:\\n    int _beautifulSubsets(vector<int>& nums, int k, unordered_map<int, int>& freq, int i) {\\n        if (i == nums.size()) { // base case\\n            return 1;\\n        }\\n        int result = _beautifulSubsets(nums, k, freq, i + 1); // nums[i] not taken\\n        if (!freq[nums[i] - k] && !freq[nums[i] + k]) { // check if we can take nums[i]\\n            freq[nums[i]]++;\\n            result += _beautifulSubsets(nums, k, freq, i + 1); // nums[i] taken\\n            freq[nums[i]]--;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        return _beautifulSubsets(nums, k, freq, 0) - 1; // -1 for empty subset\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private HashMap<Integer, Integer> freq;\\n\\n    private int beautifulSubsets(int[] nums, int k, int i) {\\n        if (i == nums.length) { // base case\\n            return 1;\\n        }\\n        int result = beautifulSubsets(nums, k, i + 1); // nums[i] not taken\\n        if (!freq.containsKey(nums[i] - k) && !freq.containsKey(nums[i] + k)) { // check if we can take nums[i]\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n            result += beautifulSubsets(nums, k, i + 1); // nums[i] taken\\n            freq.put(nums[i], freq.get(nums[i]) - 1);\\n            if (freq.get(nums[i]) == 0) {\\n                freq.remove(nums[i]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        freq = new HashMap<Integer, Integer>();\\n        return beautifulSubsets(nums, k, 0) - 1; // -1 for empty subset\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        def f(i: int) -> int:\\n            if i == len(nums): # base case\\n                return 1\\n            result = f(i + 1) # nums[i] not taken\\n            if not nums[i] - k in freq and not nums[i] + k in freq: # check if we can take nums[i]\\n                freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\\n                result += f(i + 1) # nums[i] taken\\n                freq[nums[i]] -= 1\\n                if freq[nums[i]] == 0:\\n                    del freq[nums[i]]\\n            return result\\n        return f(0) - 1 # -1 for empty subset\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    int _beautifulSubsets(vector<int>& nums, int k, unordered_map<int, int>& freq, int i) {\\n        if (i == nums.size()) { // base case\\n            return 1;\\n        }\\n        int result = _beautifulSubsets(nums, k, freq, i + 1); // nums[i] not taken\\n        if (!freq[nums[i] - k]) { // check if we can take nums[i]\\n            freq[nums[i]]++;\\n            result += _beautifulSubsets(nums, k, freq, i + 1); // nums[i] taken\\n            freq[nums[i]]--;\\n        }\\n        return result;\\n    }\\n    \\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        sort(nums.begin(), nums.end());\\n        return _beautifulSubsets(nums, k, freq, 0) - 1; // -1 for empty subset\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private HashMap<Integer, Integer> freq;\\n\\n    private int beautifulSubsets(int[] nums, int k, int i) {\\n        if (i == nums.length) { // base case\\n            return 1;\\n        }\\n        int result = beautifulSubsets(nums, k, i + 1); // nums[i] not taken\\n        if (!freq.containsKey(nums[i] - k)) { // check if we can take nums[i]\\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\\n            result += beautifulSubsets(nums, k, i + 1); // nums[i] taken\\n            freq.put(nums[i], freq.get(nums[i]) - 1);\\n            if (freq.get(nums[i]) == 0) {\\n                freq.remove(nums[i]);\\n            }\\n        }\\n        return result;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        freq = new HashMap<Integer, Integer>();\\n        Arrays.sort(nums);\\n        return beautifulSubsets(nums, k, 0) - 1; // -1 for empty subset\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        freq = {}\\n        nums.sort()\\n        def f(i: int) -> int:\\n            if i == len(nums): # base case\\n                return 1\\n            result = f(i + 1) # nums[i] not taken\\n            if not nums[i] - k in freq: # check if we can take nums[i]\\n                freq[nums[i]] = freq[nums[i]] + 1 if nums[i] in freq else 1\\n                result += f(i + 1) # nums[i] taken\\n                freq[nums[i]] -= 1\\n                if freq[nums[i]] == 0:\\n                    del freq[nums[i]]\\n            return result\\n        return f(0) - 1 # -1 for empty subset\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    int beautifulSubsets(vector<pair<int, int>>& s, int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int skip = beautifulSubsets(s, n, k, i + 1); // 1 * f(i + 1)\\n        int take = (1 << s[i].second) - 1; // take s[i]\\n        if (i + 1 < n && s[i + 1].first - s[i].first == k) { // next number is s[i] + k\\n            take *= beautifulSubsets(s, n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(s, n, k, i + 1);\\n        }\\n        return skip + take;\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int,     map<int,  int>> freq;\\n        // {remainder : {num : frequency}}\\n        // map is sorted based on num to get subset of form [x, x + k, x + 2k, ...]\\n        for (int& x: nums) { // splitting subsets based on remainder and calculating frequency\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) { // loop for s1, s2, ...\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            result *= beautifulSubsets(s, s.size(), k, 0); // f(s1) * f(s2) ...\\n        }\\n        return result - 1; // -1 for empty subset\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int[][] s;\\n\\n    private void mapToList(Map<Integer, Integer> fr) {\\n        s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n    }\\n\\n    private int beautifulSubsets(int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int skip = beautifulSubsets(n, k, i + 1); // 1 * f(i + 1)\\n        int take = (1 << s[i][1]) - 1; // take s[i]\\n        if (i + 1 < n && s[i + 1][0] - s[i][0] == k) { // next number is s[i] + k\\n            take *= beautifulSubsets(n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(n, k, i + 1);\\n        }\\n        return skip + take;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        // {remainder : {num :    frequency}}\\n        // map is sorted based on num to get subset of form [x, x + k, x + 2k, ...]\\n        for (int x: nums) { // splitting subsets based on remainder and calculating frequency\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) { // loop for s1, s2, ...\\n            mapToList(fr);\\n            result *= beautifulSubsets(s.length, k, 0); // f(s1) * f(s2) ...\\n        }\\n        return result - 1; // -1 for empty subset\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        # {remainder : {num : frequency}}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values(): # loop for s1, s2, ...\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            def f(i: int) -> int:\\n                if i == len(s):\\n                    return 1\\n                skip = f(i + 1) # 1 * f(i + 1)\\n                take = 2 ** s[i][1] - 1 # take s[i]\\n                if i + 1 < len(s) and s[i + 1][0] - s[i][0] == k: # next number is s[i] + k\\n                    take *= f(i + 2)\\n                else:\\n                    take *= f(i + 1)\\n                return skip + take\\n            result *= f(0) # f(s1) * f(s2) ...\\n        return result - 1 # -1 for empty subset\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    int beautifulSubsets(vector<pair<int, int>>& s, int n, int k, int i, vector<int>& count) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        if (count[i] != -1) {\\n            return count[i];\\n        }\\n        int skip = beautifulSubsets(s, n, k, i + 1, count);\\n        int take = (1 << s[i].second) - 1;\\n        if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n            take *= beautifulSubsets(s, n, k, i + 2, count);\\n        } else {\\n            take *= beautifulSubsets(s, n, k, i + 1, count);\\n        }\\n        return count[i] = skip + take;\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            vector<int> count(s.size(), -1);\\n            result *= beautifulSubsets(s, s.size(), k, 0, count);\\n        }\\n        return result - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    int[][] s;\\n    int[] count;\\n\\n    private void mapToList(Map<Integer, Integer> fr) {\\n        s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n    }\\n\\n    private int beautifulSubsets(int n, int k, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        if (count[i] != -1) {\\n            return count[i];\\n        }\\n        int skip = beautifulSubsets(n, k, i + 1);\\n        int take = (1 << s[i][1]) - 1;\\n        if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n            take *= beautifulSubsets(n, k, i + 2);\\n        } else {\\n            take *= beautifulSubsets(n, k, i + 1);\\n        }\\n        return count[i] = skip + take;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            mapToList(fr);\\n            count = new int[fr.size()];\\n            Arrays.fill(count, -1);\\n            result *= beautifulSubsets(s.length, k, 0);\\n        }\\n        return result - 1;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            @cache\\n            def f(i: int) -> int:\\n                if i == len(s):\\n                    return 1\\n                skip = f(i + 1)\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < len(s) and s[i + 1][0] - s[i][0] == k:\\n                    take *= f(i + 2)\\n                else:\\n                    take *= f(i + 1)\\n                return skip + take\\n            result *= f(0)\\n        return result - 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int n = fr.second.size();\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            vector<int> count(n + 1);\\n            count[n] = 1;\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = count[i + 1];\\n                int take = (1 << s[i].second) - 1;\\n                if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n                    take *= count[i + 2];\\n                } else {\\n                    take *= count[i + 1];\\n                }\\n                count[i] = skip + take;\\n            }\\n            result *= count[0];\\n        }\\n        return result - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[][] mapToList(Map<Integer, Integer> fr) {\\n        int[][] s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n        return s;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            int n = fr.size();\\n            int[][] s = mapToList(fr);\\n            int[] count = new int[n + 1];\\n            count[n] = 1;\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = count[i + 1];\\n                int take = (1 << s[i][1]) - 1;\\n                if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n                    take *= count[i + 2];\\n                } else {\\n                    take *= count[i + 1];\\n                }\\n                count[i] = skip + take;\\n            }\\n            result *= count[0];\\n        }\\n        return result - 1;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            n = len(fr)\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            count = [0] * (n + 1)\\n            count[n] = 1\\n            for i in range(n - 1, -1, -1):\\n                skip = count[i + 1]\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < n and s[i + 1][0] - s[i][0] == k:\\n                    take *= count[i + 2]\\n                else:\\n                    take *= count[i + 1]\\n                count[i] = skip + take\\n            result *= count[0]\\n        return result - 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int n = fr.second.size(), curr, next1 = 1, next2;\\n            vector<pair<int, int>> s(fr.second.begin(), fr.second.end());\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = next1;\\n                int take = (1 << s[i].second) - 1;\\n                if (i + 1 < n && s[i + 1].first - s[i].first == k) {\\n                    take *= next2;\\n                } else {\\n                    take *= next1;\\n                }\\n                curr = skip + take;\\n                next2 = next1; next1 = curr;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    private int[][] mapToList(Map<Integer, Integer> fr) {\\n        int[][] s = new int[fr.size()][2];\\n        int i = 0;\\n        for (Map.Entry<Integer, Integer> x: fr.entrySet()) {\\n            s[i][0] = x.getKey();\\n            s[i][1] = x.getValue();\\n            i++;\\n        }\\n        return s;\\n    }\\n\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map fr: freq.values()) {\\n            int n = fr.size(), curr = 1, next1 = 1, next2 = 0;\\n            int[][] s = mapToList(fr);\\n            for (int i = n - 1; i >= 0; i--) {\\n                int skip = next1;\\n                int take = (1 << s[i][1]) - 1;\\n                if (i + 1 < n && s[i + 1][0] - s[i][0] == k) {\\n                    take *= next2;\\n                } else {\\n                    take *= next1;\\n                }\\n                curr = skip + take;\\n                next2 = next1; next1 = curr;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            n, curr, next1, next2 = len(fr), 1, 1, 0\\n            s = sorted([[k, v] for k, v in fr.items()])\\n            for i in range(n - 1, -1, -1):\\n                skip = next1\\n                take = 2 ** s[i][1] - 1\\n                if i + 1 < n and s[i + 1][0] - s[i][0] == k:\\n                    take *= next2\\n                else:\\n                    take *= next1\\n                curr = skip + take\\n                next2, next1 = next1, curr\\n            result *= curr\\n        return result - 1\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int result = 1;\\n        map<int, map<int, int>> freq;\\n        for (int& x: nums) {\\n            freq[x % k][x]++;\\n        }\\n        for (auto& fr: freq) {\\n            int prevNum = -k, prev2, prev1 = 1, curr;\\n            for (auto& [num, f]: fr.second) {\\n                int skip = prev1;\\n                int take = ((1 << f) - 1) * (num - prevNum == k ? prev2 : prev1);\\n                curr = skip + take;\\n                prev2 = prev1; prev1 = curr;\\n                prevNum = num;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int result = 1;\\n        Map<Integer, Map<Integer, Integer>> freq = new TreeMap<>();\\n        for (int x: nums) {\\n            Map<Integer, Integer> fr = freq.getOrDefault(x % k, new TreeMap<>());\\n            fr.put(x, fr.getOrDefault(x, 0) + 1);\\n            freq.put(x % k, fr);\\n        }\\n        for (Map<Integer, Integer> fr: freq.values()) {\\n            int prevNum = -k, prev2 = 0, prev1 = 1, curr = 1;\\n            for (Map.Entry<Integer, Integer> entry: fr.entrySet()) {\\n                int num = entry.getKey(), f = entry.getValue();\\n                int skip = prev1;\\n                int take = ((1 << f) - 1) * (num - prevNum == k ? prev2 : prev1);\\n                curr = skip + take;\\n                prev2 = prev1; prev1 = curr;\\n                prevNum = num;\\n            }\\n            result *= curr;\\n        }\\n        return result - 1;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        result = 1\\n        freq = {}\\n        for x in nums:\\n            if not x % k in freq:\\n                freq[x % k] = {}\\n            if not x in freq[x % k]:\\n                freq[x % k][x] = 0\\n            freq[x % k][x] += 1\\n        for fr in freq.values():\\n            prevNum, curr, prev1, prev2 = -k, 1, 1, 0\\n            for num in sorted(fr):\\n                skip = prev1\\n                take = (2 ** fr[num] - 1) * (prev2 if num - prevNum == k else prev1)\\n                curr = skip + take\\n                prev2, prev1 = prev1, curr\\n                prevNum = num\\n            result *= curr\\n        return result - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314052,
                "title": "o-2-n-c-backtracking-solution",
                "content": "### Intuition\\nThe list has a maximum of 20 elements. This allows us to generate all possible subsets and count the ones that are valid.\\n\\n### Approach\\nRecurse through the list building a subset by counting the current elements of the subset in a map. When reaching a number that can be added to the set while keeping it valid, add it and recurse. After backtracking, remove it and recurse again without the element. Once done subtract one from the result since the empty set doesn\\u2019t meet requirements of a beautiful subset.\\n\\n### Complexity\\nTime complexity:\\n$O(2^N)$\\n\\nSpace complexity:\\n$O(N)$\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    // DFS Helper for recursing through list building a unique subset\\n    void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n        // If we have reached the end of the list, count this unique subset\\n        if(idx == nums.size()) ans++;\\n        else {\\n            // Otherwise, we need to recurse, if possible recurse taking this element for the subset\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            // Recurse without taking this element in the subset\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n    \\n    // O(2^N) Solution that generates all valid subsets and counts them in the result variable\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        // Initialize our result as 0\\n        int ans = 0;\\n        // Initialize a map for the count of elements in our current set\\n        unordered_map<int, int> mp;\\n        // DFS through the numbers array from index 0\\n        dfs(nums, 0, k, mp, ans);\\n        // Return all of the counted sets - 1 for the empty set\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // DFS Helper for recursing through list building a unique subset\\n    void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n        // If we have reached the end of the list, count this unique subset\\n        if(idx == nums.size()) ans++;\\n        else {\\n            // Otherwise, we need to recurse, if possible recurse taking this element for the subset\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            // Recurse without taking this element in the subset\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n    \\n    // O(2^N) Solution that generates all valid subsets and counts them in the result variable\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        // Initialize our result as 0\\n        int ans = 0;\\n        // Initialize a map for the count of elements in our current set\\n        unordered_map<int, int> mp;\\n        // DFS through the numbers array from index 0\\n        dfs(nums, 0, k, mp, ans);\\n        // Return all of the counted sets - 1 for the empty set\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314450,
                "title": "java-easy-backtracking",
                "content": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        f(0,nums,res,new ArrayList<>(),k);\\n        return res.size();\\n    }\\n    public void f(int ind,int[] nums,List<List<Integer>> res,List<Integer> ds,int k){\\n        if(ind==nums.length){\\n            if(ds.size()>0){\\n                res.add(new ArrayList<>(ds));\\n            }\\n            return;\\n        }\\n        if(!(ds.contains(nums[ind]-k) )){\\n            ds.add(nums[ind]);\\n            f(ind+1,nums,res,ds,k);    \\n            ds.remove(ds.size()-1);\\n        }\\n        f(ind+1,nums,res,ds,k);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/88b661ea-460f-4fae-9300-74c926917f1b_1679201217.682688.png)\\n\\n![image](https://assets.leetcode.com/users/images/731b8eb1-00ef-4c65-9c08-35b45cd15cf5_1679201138.4363368.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        f(0,nums,res,new ArrayList<>(),k);\\n        return res.size();\\n    }\\n    public void f(int ind,int[] nums,List<List<Integer>> res,List<Integer> ds,int k){\\n        if(ind==nums.length){\\n            if(ds.size()>0){\\n                res.add(new ArrayList<>(ds));\\n            }\\n            return;\\n        }\\n        if(!(ds.contains(nums[ind]-k) )){\\n            ds.add(nums[ind]);\\n            f(ind+1,nums,res,ds,k);    \\n            ds.remove(ds.size()-1);\\n        }\\n        f(ind+1,nums,res,ds,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314006,
                "title": "smart-arrangement-vs-bitmask-dfs",
                "content": "Bitmask DFS solution is easier and AC. Smart arrangement is trickier but much faster (7 ms vs. 700 ms).\\n\\n## Smart Arrangement \\nWe can re-arrange elements in the array so that potential \"ugly\" elements are always next to each other.\\n\\nTo arrange elements this way, we first group them by modulo `k`, and then we sort each group.\\n\\nThis significantly simplifies checks for Knapsack 0/1.\\n\\n**C++**\\n```cpp\\nint dp[21][21] = {};\\nint dfs(int i, int last_i, vector<int> &gs, int k) {\\n    if (i == gs.size())\\n        return 1;\\n    if (dp[i][last_i] == 0)\\n        dp[i][last_i] = dfs(i + 1, last_i, gs, k) + \\n        (gs[i] - gs[last_i] == k ? 0 : dfs(i + 1, i, gs, k));\\n    return dp[i][last_i];\\n}\\nint beautifulSubsets(vector<int>& nums, int k) {\\n    vector<int> gs;\\n    unordered_map<int, vector<int>> m;\\n    for (int n : nums)\\n        m[n % k].push_back(n);\\n    for (auto &[mod, g] : m) {\\n        sort(begin(g), end(g));\\n        gs.insert(end(gs), begin(g), end(g));\\n    }\\n    return dfs(0, gs.size() - 1, gs, k) - 1;\\n}\\n```\\n\\n## Bitmask DFS\\nThe `nums` array is very small (`<= 20`). \\nWe track included elements using a bitmask.\\n    \\nWe check (agains all previously included ones) if the current elment makes it ugly.\\n    \\n**C++**\\n```cpp \\nint beautifulSubsets(vector<int>& nums, int k, int i = 0, int mask = 0) {\\n    if (i == nums.size())\\n        return mask > 0;\\n    bool bfl  = true;\\n    for (int j = 0; j < i && bfl ; ++j)\\n        bfl = ((1 << j) & mask) == 0 || abs(nums[j] - nums[i]) != k;\\n    return beautifulSubsets(nums, k, i + 1, mask) + \\n        (bfl ? beautifulSubsets(nums, k, i + 1, mask + (1 << i)) : 0);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dp[21][21] = {};\\nint dfs(int i, int last_i, vector<int> &gs, int k) {\\n    if (i == gs.size())\\n        return 1;\\n    if (dp[i][last_i] == 0)\\n        dp[i][last_i] = dfs(i + 1, last_i, gs, k) + \\n        (gs[i] - gs[last_i] == k ? 0 : dfs(i + 1, i, gs, k));\\n    return dp[i][last_i];\\n}\\nint beautifulSubsets(vector<int>& nums, int k) {\\n    vector<int> gs;\\n    unordered_map<int, vector<int>> m;\\n    for (int n : nums)\\n        m[n % k].push_back(n);\\n    for (auto &[mod, g] : m) {\\n        sort(begin(g), end(g));\\n        gs.insert(end(gs), begin(g), end(g));\\n    }\\n    return dfs(0, gs.size() - 1, gs, k) - 1;\\n}\\n```\n```cpp \\nint beautifulSubsets(vector<int>& nums, int k, int i = 0, int mask = 0) {\\n    if (i == nums.size())\\n        return mask > 0;\\n    bool bfl  = true;\\n    for (int j = 0; j < i && bfl ; ++j)\\n        bfl = ((1 << j) & mask) == 0 || abs(nums[j] - nums[i]) != k;\\n    return beautifulSubsets(nums, k, i + 1, mask) + \\n        (bfl ? beautifulSubsets(nums, k, i + 1, mask + (1 << i)) : 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314189,
                "title": "python-o-n-log-n-solution-by-using-dp-group-by-remainer",
                "content": "(This solution has been corrected, thanks to friends in the comment area)\\n\\n# Intuition\\n\\nThis problem can be solved using DP. \\nConsider a subproblem.\\nGiven an increasing array,  like arr = [1,2,3,5,6]\\nwhat is the number of subsequence that every two number in this subsequence difference is not 1 ? \\n\\nWe can use DP, and have the following formula, dp[i] means number of subsequence that end with ith number. \\nWe have\\n\\ndp[-1] = 1\\ndp[0] = 2\\nif arr[i] == arr[i-1] + 1:  dp[i] = dp[i-1] + dp[i-2]\\nelse:  dp[i] = 2*dp[i-1]\\n\\nBy solving this sub problem,  we can move on to this problem\\n\\nUPD:  Thanks for reminder, if there are duplicates,  since the duplicate only affect the final result,  we can use another dic to store the frequency,  and times the pow(2,fre[num]) - 1\\n\\n\\n# Approach\\n\\n1, sort the array (UPD:  and count the frequency)\\n2, group the array by the module of value,  you can assume that two number with different module can always exist together\\n3, For each group,  this can be converted into the sub problem I mentioned about.  Since each group is independent,  the final answer is just the product of all group answers. \\n4, minus the final answer by 1 to exclude the all-empty subsequece. \\n\\n\\n# Complexity\\n- Time complexity:  O(n lg n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def beautifulSubsets(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        M = 10**9 + 7\\n        \\n        n = len(nums)\\n        nums.sort()\\n        \\n        dic = {}\\n        fre = {}\\n\\n\\n\\n        for num in nums:\\n            if num not in fre:  fre[num] = 0\\n            fre[num] += 1\\n\\n            if num % k not in dic:  dic[num%k] = []\\n            if fre[num] == 1:   dic[num%k].append(num//k)\\n\\n\\n\\n        \\n        ans = 1\\n        \\n        for key in dic:\\n            temp = dic[key]\\n            dp = [0]*len(temp) + [1]\\n            dp[0] = pow(2,fre[key+temp[0]*k],M)\\n\\n                  \\n            for i in range(1,len(temp)):\\n\\n\\n                dp[i] += dp[i-1]\\n                if temp[i]==temp[i-1] + 1:\\n                    dp[i] +=  dp[i-2] * (pow(2,fre[key+temp[i]*k],M) - 1)\\n                else:\\n                    dp[i] += dp[i-1] * (pow(2,fre[key+temp[i]*k],M) - 1)\\n                    \\n                dp[i] %= M\\n                    \\n            ans *= dp[len(temp)-1]\\n            ans %= M\\n\\n\\n            \\n        return (ans - 1)%M\\n            \\n                \\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def beautifulSubsets(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        M = 10**9 + 7\\n        \\n        n = len(nums)\\n        nums.sort()\\n        \\n        dic = {}\\n        fre = {}\\n\\n\\n\\n        for num in nums:\\n            if num not in fre:  fre[num] = 0\\n            fre[num] += 1\\n\\n            if num % k not in dic:  dic[num%k] = []\\n            if fre[num] == 1:   dic[num%k].append(num//k)\\n\\n\\n\\n        \\n        ans = 1\\n        \\n        for key in dic:\\n            temp = dic[key]\\n            dp = [0]*len(temp) + [1]\\n            dp[0] = pow(2,fre[key+temp[0]*k],M)\\n\\n                  \\n            for i in range(1,len(temp)):\\n\\n\\n                dp[i] += dp[i-1]\\n                if temp[i]==temp[i-1] + 1:\\n                    dp[i] +=  dp[i-2] * (pow(2,fre[key+temp[i]*k],M) - 1)\\n                else:\\n                    dp[i] += dp[i-1] * (pow(2,fre[key+temp[i]*k],M) - 1)\\n                    \\n                dp[i] %= M\\n                    \\n            ans *= dp[len(temp)-1]\\n            ans %= M\\n\\n\\n            \\n        return (ans - 1)%M\\n            \\n                \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314195,
                "title": "why-2e7-passes-in-java-and-gives-tle-in-c",
                "content": "I wrote 3 codes, One was 2e7 * log(n). This gave me TLE in c++, I thought maybe because I\\'m using a data structure, then I tried using a vector and complexity came down to 2e7. Still, I got tle then I switched the language from C++ to JAVA and it passed quite smoothly. I want to say that this is absurd. C++ is the fastest language for Contests in all platforms and here you are giving TLE on a code with 2e7 complexity.  \\n\\n**My all 3 codes**\\n\\n*1st whose complexity is 2e7  * log(n). This should also usually pass.*\\n\\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ll n= nums.size();\\n        ll cnt=0;\\n        \\n        rep(i, (1<<n)){\\n            vector<ll> f;\\n            map<ll, ll> m;\\n            rep(j, n){\\n                \\n                if( (i & (1<<j))) {f.pb(nums[j]); m[nums[j]]++; }\\n            }\\n            if(f.size()==0) continue;\\n            \\n            ll flag=0;\\n            rep(j,f.size()){\\n                ll x= f[j] + k;\\n                ll y= f[j] - k;\\n                \\n                if(m.find(x)!=m.end()) { flag=1; break; }\\n                if(m.find(y)!= m.end()) { flag=1; break; }\\n            }\\n            \\n            if(!flag) cnt++;\\n            \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n**Verdict -TLE**\\n\\n*2nd - Complexity is now 2e7*\\n\\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ll n= nums.size();\\n        ll cnt=0;\\n        \\n        // cout<<n<<\"\\\\n\";\\n        \\n        \\n        vector<int> fre(1001, 0);\\n        rep(i, (1<<n)){\\n             ll flag=0;\\n            ll lol=0;\\n            rep(j, n){\\n                \\n                if( (i & (1<<j))) {                 \\n                    fre[nums[j]]++; \\n                    int x= nums[j] + k;\\n                    int y= nums[j] - k;\\n                    lol++;\\n                    if(x>=1 && x<=1000 && fre[x]>0 ) { flag=1; break; }\\n                    if(y>=1 && y<=1000 && fre[y]>0) { flag=1; break; }\\n                  }\\n                \\n            }\\n            if(lol==0 ) continue;\\n            rep(j,n){\\n                fre[nums[j]]=0;\\n            }\\n            \\n       \\n            \\n            if(!flag) cnt++;\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\n**Verdict - This got TLE too**\\n\\n*3rd now i TRIED same code in JAVA,*\\n\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n= nums.length;\\n        int cnt=0;\\n\\n        int[] fre = new int[1001];\\n        for (int i = 0; i < (1<<n); i++) {\\n            int flag=0;\\n            int lol=0;\\n            for (int j = 0; j < n; j++) {\\n\\n                if( (i & (1<<j)) != 0) {\\n                    fre[nums[j]]++;\\n                    int x= nums[j] + k;\\n                    int y= nums[j] - k;\\n                    lol++;\\n                    if(x>=1 && x<=1000 && fre[x]>0 ) { flag=1; break; }\\n                    if(y>=1 && y<=1000 && fre[y]>0) { flag=1; break; }\\n                }\\n\\n            }\\n            if(lol==0 ) continue;\\n            for (int j = 0; j < n; j++) {\\n                fre[nums[j]]=0;\\n            }\\n\\n            if(flag == 0) cnt++;\\n        }\\n\\n        return cnt;\\n    \\n        \\n    }\\n}\\n```\\n**Verdict - It passed quite comfortably with time complexity at 1300ms.**\\n\\nWhy you are doing this to c++ now after python",
                "solutionTags": [
                    "Java",
                    "C",
                    "Bitmask"
                ],
                "code": "```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ll n= nums.size();\\n        ll cnt=0;\\n        \\n        rep(i, (1<<n)){\\n            vector<ll> f;\\n            map<ll, ll> m;\\n            rep(j, n){\\n                \\n                if( (i & (1<<j))) {f.pb(nums[j]); m[nums[j]]++; }\\n            }\\n            if(f.size()==0) continue;\\n            \\n            ll flag=0;\\n            rep(j,f.size()){\\n                ll x= f[j] + k;\\n                ll y= f[j] - k;\\n                \\n                if(m.find(x)!=m.end()) { flag=1; break; }\\n                if(m.find(y)!= m.end()) { flag=1; break; }\\n            }\\n            \\n            if(!flag) cnt++;\\n            \\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\n#define ll long long\\n#define pi (3.141592653589)\\n#define mod 1000000007\\n#define float double\\n#define pb push_back\\n#define mp make_pair\\n#define ff first\\n#define ss second\\n#define all(c) c.begin(), c.end()\\n#define min3(a, b, c) min(c, min(a, b))\\n#define min4(a, b, c, d) min(d, min(c, min(a, b)))\\n#define rrep(i, n) for(int i=n-1;i>=0;i--)\\n#define rep(i,n) for(int i=0;i<n;i++)\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ll n= nums.size();\\n        ll cnt=0;\\n        \\n        // cout<<n<<\"\\\\n\";\\n        \\n        \\n        vector<int> fre(1001, 0);\\n        rep(i, (1<<n)){\\n             ll flag=0;\\n            ll lol=0;\\n            rep(j, n){\\n                \\n                if( (i & (1<<j))) {                 \\n                    fre[nums[j]]++; \\n                    int x= nums[j] + k;\\n                    int y= nums[j] - k;\\n                    lol++;\\n                    if(x>=1 && x<=1000 && fre[x]>0 ) { flag=1; break; }\\n                    if(y>=1 && y<=1000 && fre[y]>0) { flag=1; break; }\\n                  }\\n                \\n            }\\n            if(lol==0 ) continue;\\n            rep(j,n){\\n                fre[nums[j]]=0;\\n            }\\n            \\n       \\n            \\n            if(!flag) cnt++;\\n            \\n        }\\n        \\n        \\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n= nums.length;\\n        int cnt=0;\\n\\n        int[] fre = new int[1001];\\n        for (int i = 0; i < (1<<n); i++) {\\n            int flag=0;\\n            int lol=0;\\n            for (int j = 0; j < n; j++) {\\n\\n                if( (i & (1<<j)) != 0) {\\n                    fre[nums[j]]++;\\n                    int x= nums[j] + k;\\n                    int y= nums[j] - k;\\n                    lol++;\\n                    if(x>=1 && x<=1000 && fre[x]>0 ) { flag=1; break; }\\n                    if(y>=1 && y<=1000 && fre[y]>0) { flag=1; break; }\\n                }\\n\\n            }\\n            if(lol==0 ) continue;\\n            for (int j = 0; j < n; j++) {\\n                fre[nums[j]]=0;\\n            }\\n\\n            if(flag == 0) cnt++;\\n        }\\n\\n        return cnt;\\n    \\n        \\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3314247,
                "title": "o-nlogn-approach-cpp",
                "content": "The problem setters didn\\'t come up with good constraints this time.\\nWe can solve this problem in NlogN time complexity.\\n\\nLet us think of this problem as a graph problem.\\nSuppose there exists an edge between nodes i and nodes j if there absolute difference is k. We can see that we have to take non adjacent nodes from the graph. One special property of this graph is also that the components are a line graph.\\n\\nHow to find the number of ways to take non adjacent nodes from the graph. Suppose there exists an component of size A, then the number of ways to choose non adjacent nodes from that component is $F(A)$ where $F(i)$ is the i+2\\'th fibonacci sum. So for A=1 , we can have 2 valid ways of choosing , for A=2 we have 3 and for A=3 we have 5 valid ways of choosing. To prove this we can think about adding a new node at the end of the current component of size A.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        vector<int> parent(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        unordered_map<int,int> prev;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prev.find(nums[i]-k)!=prev.end())\\n                parent[i]=parent[ prev[nums[i]-k] ];\\n            prev[nums[i]]=i;\\n        }\\n        \\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n            mp[parent[i]]++;\\n        \\n        vector<int> fibo(25);\\n        fibo[1]=2;\\n        fibo[2]=3;\\n        for(int i=3;i<=24;i++)\\n            fibo[i]=fibo[i-1]+fibo[i-2];\\n        \\n        int ans=1;\\n        for(auto &[rep,len] : mp)\\n            ans=ans*(fibo[len]);\\n        return ans-1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        vector<int> parent(n,1);\\n        for(int i=0;i<n;i++)\\n            parent[i]=i;\\n        \\n        unordered_map<int,int> prev;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(prev.find(nums[i]-k)!=prev.end())\\n                parent[i]=parent[ prev[nums[i]-k] ];\\n            prev[nums[i]]=i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3315846,
                "title": "clean-codes-full-explanation-backtracking-java",
                "content": "# What Problem says ?\\n- You are given an array `nums` of positive integers and  positive integer `k`.\\n- A subset of `nums` is beautiful if it does not contain two integers with an absolute difference equal to `k`.\\n- Return the number of non-empty beautiful subsets of the array ```\\nnums\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : BackTracking\\n- Here we are using a backtracking algorithm to generate all possible subsets of the array and checks if each subset is beautiful. \\n- To do this, we start by sorting the array in ascending order. Then use a recursive function called `backTrack` to generate all possible subsets of the array.\\n- The `backTrack` function takes a `set` of integers, element, an index `i`, the array `nums`, and `k` as input. \\n- It adds the current element at index `i` to the element `set` and recursively calls itself with `i+1` as the new index. \\n- If the new subset is beautiful, the `count` variable is incremented.\\n-  Finally, the current element is removed from the element set to backtrack and generate the next subset.\\n- The function `beautifulSubsets` simply calls backTrack function with an empty element set and returns the count variable minus one, since the empty subset is not considered beautiful.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n log n + 2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A\\n```\\n# Java Code :\\n```\\nclass Solution \\n{\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        backTrack(new HashSet<>(), 0, nums, k);\\n        return count - 1;\\n    }\\n    private void backTrack(Set<Integer> element ,int i, int[] nums, int k)\\n    {\\n        count++;\\n        for(int j=i; j<nums.length; j++)\\n        {\\n            if( !element.contains(nums[j] - k ))\\n            {\\n                element.add(nums[j]);\\n                backTrack(element, j+1, nums, k);\\n                element.remove(nums[j]);//remove current elem before backtracking\\n            }\\n        }\\n\\n    }\\n}\\n```\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/0f6145e7-82f4-493f-b830-7c317c2d32b0_1679223432.891085.gif)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Backtracking",
                    "Ordered Set"
                ],
                "code": "```\\nnums\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : BackTracking\\n- Here we are using a backtracking algorithm to generate all possible subsets of the array and checks if each subset is beautiful. \\n- To do this, we start by sorting the array in ascending order. Then use a recursive function called `backTrack` to generate all possible subsets of the array.\\n- The `backTrack` function takes a `set` of integers, element, an index `i`, the array `nums`, and `k` as input. \\n- It adds the current element at index `i` to the element `set` and recursively calls itself with `i+1` as the new index. \\n- If the new subset is beautiful, the `count` variable is incremented.\\n-  Finally, the current element is removed from the element set to backtrack and generate the next subset.\\n- The function `beautifulSubsets` simply calls backTrack function with an empty element set and returns the count variable minus one, since the empty subset is not considered beautiful.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity :\\n- Time complexity : O(n log n + 2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\n# Java Code :\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3314219,
                "title": "c-backtrack-binary-search-to-prevent-tle",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, vector<int>& dp, int k, int i, int n) {\\n        if (i == n) return 0;\\n        \\n        int take = 0;\\n        \\n        int notTake = helper(nums,dp,k,i + 1,n);\\n        \\n        if (binary_search(dp.begin(), dp.end(), nums[i] - k) == 0)\\n        {\\n            dp.push_back(nums[i]);\\n            take = 1 + helper(nums,dp,k,i + 1,n);\\n            dp.pop_back();\\n        }\\n    \\n        return take + notTake;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> dp;\\n        \\n        return helper(nums,dp,k,0,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, vector<int>& dp, int k, int i, int n) {\\n        if (i == n) return 0;\\n        \\n        int take = 0;\\n        \\n        int notTake = helper(nums,dp,k,i + 1,n);\\n        \\n        if (binary_search(dp.begin(), dp.end(), nums[i] - k) == 0)\\n        {\\n            dp.push_back(nums[i]);\\n            take = 1 + helper(nums,dp,k,i + 1,n);\\n            dp.pop_back();\\n        }\\n    \\n        return take + notTake;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        vector<int> dp;\\n        \\n        return helper(nums,dp,k,0,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313976,
                "title": "python-backtracking",
                "content": "# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        output = 0\\n        \\n        def dfs(i, ctr):\\n            nonlocal output\\n            if i == n:\\n                if ctr:\\n                    output += 1\\n                return\\n            \\n            if nums[i] - k not in ctr and nums[i] + k not in ctr:\\n                ctr[nums[i]] += 1\\n                dfs(i + 1, ctr)\\n                ctr[nums[i]] -= 1\\n                if not ctr[nums[i]]:\\n                    del ctr[nums[i]]\\n            dfs(i + 1, ctr)\\n        \\n        dfs(0, Counter())\\n        return output\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        output = 0\\n        \\n        def dfs(i, ctr):\\n            nonlocal output\\n            if i == n:\\n                if ctr:\\n                    output += 1\\n                return\\n            \\n            if nums[i] - k not in ctr and nums[i] + k not in ctr:\\n                ctr[nums[i]] += 1\\n                dfs(i + 1, ctr)\\n                ctr[nums[i]] -= 1\\n                if not ctr[nums[i]]:\\n                    del ctr[nums[i]]\\n            dfs(i + 1, ctr)\\n        \\n        dfs(0, Counter())\\n        return output\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314232,
                "title": "visual-explain-beats-100-group-multiply-subtract-1-you-get-the-answer",
                "content": "# Intuition\\n\\nDivide the input into non-colliding groups where decisions can be made within each of the group, then multiply the number of decisions per group together to get the total number of \"beautiful subsets\", and subtract 1 which represents the empty subset\\n\\n![CCFA3725-2AD8-4D76-96DE-29EBA65CD672.png](https://assets.leetcode.com/users/images/4b88d109-c1aa-4579-a08d-36adaf050245_1679199057.5717845.png)\\n\\n\\n# Approach\\n\\n- For dividing the input into groups: sort the input, and keep track of each group. Because the input gets sorted, this step is straightforward\\n\\n- For calculating the number of decisions for each group: Actually the group size is the only thing that matters. Refer to the bubble in the illustration for the way to fill in the D.P. table.\\n\\n- No backtrack, no bitset\\n\\n# Complexity\\n- Time complexity: `O(nlogn)` for sorting the input. `O(1)` for populating the D.P. table\\n\\n- Space complexity: `O(n)` for counting the groups\\n\\n# Code\\n```\\nmap<int, int> dp;\\nclass Solution {\\npublic:\\n    int Get(int x) {\\n        if (dp.find(x) != dp.end()) {\\n            return dp[x];\\n        }\\n        int ret = 0;\\n        vector<vector<int>> haha(x, vector<int>(x));\\n        for (int i=1; i<=x; i++) {\\n            for (int idx=0; idx<x; idx++) {\\n                if (i == 1) {\\n                    haha[0][idx] = 1;\\n                    ret ++;\\n                } else {\\n                    int idx1 = idx - 2;\\n                    if (idx1 >= 0) {\\n                        for (int idx11 = idx1; idx11 >= 0; idx11--) {\\n                            haha[i-1][idx] += haha[i-2][idx11];\\n                        }\\n                        ret += haha[i-1][idx];\\n                    }\\n                }\\n                //printf(\"%d \", haha[i-1][idx]);\\n            }\\n            //printf(\"\\\\n\");\\n        }\\n        ret ++;\\n        dp[x] = ret;\\n        return ret;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        set<int> nums1, used;\\n        for (int n : nums) {\\n            nums1.insert(n);\\n        }\\n        \\n        vector<int> groups;\\n        vector<int> group_sizes;\\n        \\n        sort(nums.begin(), nums.end());\\n        int N = int(nums.size());\\n        for (int i=0; i<N; i++) {\\n            int elt = nums[i];\\n            bool done = false;\\n            for (int j=0; j<groups.size(); j++) {\\n                if (groups[j] + k == elt) {\\n                    groups[j] = elt;\\n                    group_sizes[j] ++;\\n                    done = true;\\n                    break;\\n                }\\n            }\\n            if (!done) {\\n                groups.push_back(elt);\\n                group_sizes.push_back(1);\\n            }\\n        }\\n        \\n        int ret = 1;\\n        \\n        for (int i=0; i<groups.size(); i++) {\\n            ret *= Get(group_sizes[i]);\\n            printf(\"group %d, size %d, ret=%d\\\\n\", groups[i], group_sizes[i], ret);\\n        }\\n        \\n        ret--;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nmap<int, int> dp;\\nclass Solution {\\npublic:\\n    int Get(int x) {\\n        if (dp.find(x) != dp.end()) {\\n            return dp[x];\\n        }\\n        int ret = 0;\\n        vector<vector<int>> haha(x, vector<int>(x));\\n        for (int i=1; i<=x; i++) {\\n            for (int idx=0; idx<x; idx++) {\\n                if (i == 1) {\\n                    haha[0][idx] = 1;\\n                    ret ++;\\n                } else {\\n                    int idx1 = idx - 2;\\n                    if (idx1 >= 0) {\\n                        for (int idx11 = idx1; idx11 >= 0; idx11--) {\\n                            haha[i-1][idx] += haha[i-2][idx11];\\n                        }\\n                        ret += haha[i-1][idx];\\n                    }\\n                }\\n                //printf(\"%d \", haha[i-1][idx]);\\n            }\\n            //printf(\"\\\\n\");\\n        }\\n        ret ++;\\n        dp[x] = ret;\\n        return ret;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        set<int> nums1, used;\\n        for (int n : nums) {\\n            nums1.insert(n);\\n        }\\n        \\n        vector<int> groups;\\n        vector<int> group_sizes;\\n        \\n        sort(nums.begin(), nums.end());\\n        int N = int(nums.size());\\n        for (int i=0; i<N; i++) {\\n            int elt = nums[i];\\n            bool done = false;\\n            for (int j=0; j<groups.size(); j++) {\\n                if (groups[j] + k == elt) {\\n                    groups[j] = elt;\\n                    group_sizes[j] ++;\\n                    done = true;\\n                    break;\\n                }\\n            }\\n            if (!done) {\\n                groups.push_back(elt);\\n                group_sizes.push_back(1);\\n            }\\n        }\\n        \\n        int ret = 1;\\n        \\n        for (int i=0; i<groups.size(); i++) {\\n            ret *= Get(group_sizes[i]);\\n            printf(\"group %d, size %d, ret=%d\\\\n\", groups[i], group_sizes[i], ret);\\n        }\\n        \\n        ret--;\\n        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314110,
                "title": "python-3-iterative-backtracking",
                "content": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        q = deque( [([], -1)] )\\n        res = 0\\n        \\n        while q:\\n            cur, idx = q.popleft()\\n            res += 1\\n            \\n            for i in range(idx + 1, len(nums)):\\n                if nums[i] - k in cur or nums[i] + k in cur:\\n                    continue\\n                q.append( (cur + [nums[i]], i) )\\n        \\n        return res - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        q = deque( [([], -1)] )\\n        res = 0\\n        \\n        while q:\\n            cur, idx = q.popleft()\\n            res += 1\\n            \\n            for i in range(idx + 1, len(nums)):\\n                if nums[i] - k in cur or nums[i] + k in cur:\\n                    continue\\n                q.append( (cur + [nums[i]], i) )\\n        \\n        return res - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314037,
                "title": "map-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int index,int k,unordered_map<int,int>& s){\\n        if(index>=nums.size()){\\n            bool found=false;\\n            for(auto& x:s){\\n                if(x.second>0){\\n                    found=true;\\n                    break;\\n                }\\n            }\\n            if(found)\\n            return 1;\\n            return 0;\\n        }\\n        \\n        int include=0,notinclude=0;\\n        if(!s[nums[index]-k]){\\n            s[nums[index]]++;\\n            include=solve(nums,index+1,k,s);\\n            s[nums[index]]--;\\n        }\\n        \\n        notinclude= solve(nums,index+1,k,s);\\n        \\n        return include+notinclude;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int index=0,prev=-1;\\n        sort(nums.begin(),nums.end());\\n        \\n        unordered_map<int,int> s;\\n        return solve(nums,index,k,s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums,int index,int k,unordered_map<int,int>& s){\\n        if(index>=nums.size()){\\n            bool found=false;\\n            for(auto& x:s){\\n                if(x.second>0){\\n                    found=true;\\n                    break;\\n                }\\n            }\\n            if(found)\\n            return 1;\\n            return 0;\\n        }\\n        \\n        int include=0,notinclude=0;\\n        if(!s[nums[index]-k]){\\n            s[nums[index]]++;\\n            include=solve(nums,index+1,k,s);\\n            s[nums[index]]--;\\n        }\\n        \\n        notinclude= solve(nums,index+1,k,s);\\n        \\n        return include+notinclude;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int index=0,prev=-1;\\n        sort(nums.begin(),nums.end());\\n        \\n        unordered_map<int,int> s;\\n        return solve(nums,index,k,s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314302,
                "title": "c-o-nlogn-grouping-beats-100",
                "content": "# Approach\\nFrom the example case $[2,4,6]$ and $k = 2$, we can see that numbers can be grouped with regard to $k$. Define a group to be unique numbers which are exactly $k$ apart from each other. Then we can see that different groups are independent, we can just multiply their results. For example, for $[2,4,6,20,20,22]$ and $k=2$, we construct two groups $[2,4,6]$ and $[20,20,22]$ (here both 20 are included in the same group), and the final result is $5*5-1=24$.\\n\\nWithin the same group, we use a simple DP to calculate the number of beautiful subsets. For the group $g$, We define $dp[0][j]$ to be the number of beautiful subsets within the group, up to $g[j]$, with the constraint that $g[j]$ is not included, and define $dp[1][j]$ to be the same amount, but instead $g[j]$ is included. Then the following transition follows:\\n\\n$$dp[0][j] = dp[0][j - 1] + dp[1][j - 1]$$\\n\\n$$dp[1][j] = (2 ^ {count(g[j])} - 1)dp[0][j - 1]$$\\n\\nwhere $count(g[j])$ is the number of occurrences of $g[j]$ in the array.\\n\\nFinally, the number of beutiful subsets for group $g$ is $dp[0][g.size() - 1] + dp[1][g.size() - 1]$. And the final result is the product of number of beutiful subsets different groups -1.\\n\\n# Complexity\\n- Time complexity:\\n$O(nlogn)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> group;  // map each num to a group, numbers within each group are k apart\\n        unordered_map<int, int> count_occ;  // count the number of occurrences of each number\\n        vector<vector<int>> group_members;\\n        for (int num: nums){\\n            if (group.find(num - k) != group.end() || group.find(num) != group.end()){\\n                if (group.find(num) == group.end()){  // consider the case that this number has appeared before\\n                    group_members[group[num - k]].push_back(num);\\n                    group[num] = group[num - k];\\n                }\\n            } else {  // create a new group\\n                group[num] = group_members.size();\\n                group_members.push_back({num});\\n            }\\n            ++count_occ[num];\\n        }\\n        long long res = 1;\\n        for (vector<int>& members: group_members){\\n            int group_size = members.size();\\n            vector<vector<int>> dp(2, vector<int>(group_size));\\n            // dp[0][j] is the number of beautiful subsets within the group, up to members[j], excluding members[j]\\n            // dp[1][j] is the same quantity, including members[j]\\n            dp[0][0] = 1;\\n            dp[1][0] = (1 << count_occ[members[0]]) - 1;\\n            for (int i = 1; i < group_size; ++i){\\n                dp[0][i] = dp[0][i - 1] + dp[1][i - 1];\\n                dp[1][i] = ((1 << count_occ[members[i]]) - 1) * dp[0][i - 1];\\n            }\\n            res *= dp[0][group_size - 1] + dp[1][group_size - 1];\\n        }\\n        return res - 1;  // -1 because we want non-empty subsets\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        unordered_map<int, int> group;  // map each num to a group, numbers within each group are k apart\\n        unordered_map<int, int> count_occ;  // count the number of occurrences of each number\\n        vector<vector<int>> group_members;\\n        for (int num: nums){\\n            if (group.find(num - k) != group.end() || group.find(num) != group.end()){\\n                if (group.find(num) == group.end()){  // consider the case that this number has appeared before\\n                    group_members[group[num - k]].push_back(num);\\n                    group[num] = group[num - k];\\n                }\\n            } else {  // create a new group\\n                group[num] = group_members.size();\\n                group_members.push_back({num});\\n            }\\n            ++count_occ[num];\\n        }\\n        long long res = 1;\\n        for (vector<int>& members: group_members){\\n            int group_size = members.size();\\n            vector<vector<int>> dp(2, vector<int>(group_size));\\n            // dp[0][j] is the number of beautiful subsets within the group, up to members[j], excluding members[j]\\n            // dp[1][j] is the same quantity, including members[j]\\n            dp[0][0] = 1;\\n            dp[1][0] = (1 << count_occ[members[0]]) - 1;\\n            for (int i = 1; i < group_size; ++i){\\n                dp[0][i] = dp[0][i - 1] + dp[1][i - 1];\\n                dp[1][i] = ((1 << count_occ[members[i]]) - 1) * dp[0][i - 1];\\n            }\\n            res *= dp[0][group_size - 1] + dp[1][group_size - 1];\\n        }\\n        return res - 1;  // -1 because we want non-empty subsets\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314015,
                "title": "very-simple-java-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        backtrack(new HashSet<>(), 0, nums, k);\\n        return count - 1;\\n    }\\n    public void backtrack(Set<Integer> current, int i, int[] nums, int k) {\\n        count++;\\n        for (int j = i; j < nums.length; j++) {\\n            if (!current.contains(nums[j] - k)) {\\n                current.add(nums[j]);\\n                backtrack(current, j + 1, nums, k);\\n                current.remove(Integer.valueOf(nums[j]));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        backtrack(new HashSet<>(), 0, nums, k);\\n        return count - 1;\\n    }\\n    public void backtrack(Set<Integer> current, int i, int[] nums, int k) {\\n        count++;\\n        for (int j = i; j < nums.length; j++) {\\n            if (!current.contains(nums[j] - k)) {\\n                current.add(nums[j]);\\n                backtrack(current, j + 1, nums, k);\\n                current.remove(Integer.valueOf(nums[j]));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315212,
                "title": "o-n-simple-dp",
                "content": "# Intuition\\nPut all the numbers in the same arithmetic progression of common difference k in a single group. We can process them together. The key idea is that we can only select non adjacent numbers in this arithmetic progression. The final answer is the product of number of ways to select number in each arithmetic progression minus 1 (the empty set).\\n\\n\\n# Approach\\n1. To get out all the arithmetic progressions, we put all the elements into hash map with the numbers as the key and the number of occurences as the value. Start from any key, we can check whether (key - k), (key - 2 * k), ..... are in the map. So that we get out the smallest key in this arithmetic progression that is in the hash map, let\\'s call it x. Here x must be key - k * y for some y >= 0. Start from the number x, generate the arithmetic progressions as x, x + k, x + 2 * k, ...... and all of the numbers must be in the hashmap. Whenever we get one number, we delete it from the hashmap.\\n\\n2. Calculate the number of ways to select non adjacent numbers in this rithmetic progressions. This can be done by DP. Let be the number of ways to select the numbers from the first i numbers (indices from 0 to i - 1) in the arithmetic progression. We have\\n\\ndp[i] = dp[i - 1] + dp[i - 2] * (2 ^ num[i - 1] - 1) where num[i - 1] is the number of occurences of the number with index (i - 1).\\nThis means to select number from the first i numbers, we can select number from the first (i - 1) numbers without the one indexed at (i - 1) or select the number from the first (i - 2) numbers with the one indexed at (i - 1). For the latter case, we need to select at least one from the num[i - 1] duplicated numbers (the numbers that are the same as the one indexed at i - 1).\\n\\nThe base cases are dp[0] = 1 (empty), dp[1] = 2 ^ num[0] (a single element). \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        int r = 1;\\n        while (!have.empty()) {\\n            int x = have.begin()->first;\\n            for (;have.count(x - k); x -=k)\\n            ;\\n            vector<int> dp = {1, 1 << have[x], 0};\\n            have.erase(x);\\n            int ind = 1;\\n            for (x += k; have.count(x); x += k) {\\n                ++ind;\\n                dp[ind % 3] = dp[(ind - 1) % 3] + \\n                (dp[(ind - 2) % 3] << have[x]) - dp[(ind - 2) % 3];\\n                have.erase(x);\\n            }\\n            r *= dp[ind % 3];\\n        }\\n        return r - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> have;\\n        for (int x : nums) {\\n            ++have[x];\\n        }\\n        int r = 1;\\n        while (!have.empty()) {\\n            int x = have.begin()->first;\\n            for (;have.count(x - k); x -=k)\\n            ;\\n            vector<int> dp = {1, 1 << have[x], 0};\\n            have.erase(x);\\n            int ind = 1;\\n            for (x += k; have.count(x); x += k) {\\n                ++ind;\\n                dp[ind % 3] = dp[(ind - 1) % 3] + \\n                (dp[(ind - 2) % 3] << have[x]) - dp[(ind - 2) % 3];\\n                have.erase(x);\\n            }\\n            r *= dp[ind % 3];\\n        }\\n        return r - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314173,
                "title": "python-hashmap-knapsack-dfs",
                "content": "\\t\\tdef beautifulSubsets(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tres = 0\\n\\t\\t\\tcntMap = defaultdict(int)\\n\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tnonlocal res,cntMap\\n\\t\\t\\t\\tif i==n :\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tnum = nums[i]\\n\\t\\t\\t\\t# include the curr num\\n\\t\\t\\t\\tif cntMap[num-k] == 0 and cntMap[num+k] == 0 :  # check if diff k number is already in our set or not\\n\\t\\t\\t\\t\\tcntMap[num] += 1  # add the num in set\\n\\t\\t\\t\\t\\t\\tdfs(i+1)  \\n\\t\\t\\t\\t\\tcntMap[num] -= 1  # remove the num from set\\n\\t\\t\\t\\t# exclude the curr num\\n\\t\\t\\t\\tdfs(i+1)   \\n\\n\\t\\t\\tdfs(0)\\n\\t\\t\\treturn res-1   # -1 for empty set\\n",
                "solutionTags": [],
                "code": "\\t\\tdef beautifulSubsets(self, nums: List[int], k: int) -> int:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tres = 0\\n\\t\\t\\tcntMap = defaultdict(int)\\n\\n\\t\\t\\tdef dfs(i):\\n\\t\\t\\t\\tnonlocal res,cntMap\\n\\t\\t\\t\\tif i==n :\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\tnum = nums[i]\\n\\t\\t\\t\\t# include the curr num\\n\\t\\t\\t\\tif cntMap[num-k] == 0 and cntMap[num+k] == 0 :  # check if diff k number is already in our set or not\\n\\t\\t\\t\\t\\tcntMap[num] += 1  # add the num in set\\n\\t\\t\\t\\t\\t\\tdfs(i+1)  \\n\\t\\t\\t\\t\\tcntMap[num] -= 1  # remove the num from set\\n\\t\\t\\t\\t# exclude the curr num\\n\\t\\t\\t\\tdfs(i+1)   \\n\\n\\t\\t\\tdfs(0)\\n\\t\\t\\treturn res-1   # -1 for empty set\\n",
                "codeTag": "Python3"
            },
            {
                "id": 3314053,
                "title": "standard-backtracking",
                "content": "\\n# Solution 1\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\n    private:\\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (!test(cur, nums[i], k))\\n                continue;\\n            cur.push_back(nums[i]);\\n            cnt++;\\n            cnt += helper(nums, k, cur, i + 1);\\n            cur.pop_back();\\n        }\\n        return cnt;\\n    }\\n    bool test(vector<int>& cur, int num, int k) {\\n        for (auto &c : cur)\\n            if (abs(num - c) == k)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n# Solution2 : HashMap cur frequency\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\nprivate:\\n    int helper(vector<int>& nums, int k, unordered_map<int, int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (cur[nums[i] - k] || cur[nums[i] + k])\\n                continue;\\n            cur[nums[i]]++;\\n            cnt += 1 + helper(nums, k, cur, i + 1);\\n            cur[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\n    private:\\n    int helper(vector<int>& nums, int k, vector<int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (!test(cur, nums[i], k))\\n                continue;\\n            cur.push_back(nums[i]);\\n            cnt++;\\n            cnt += helper(nums, k, cur, i + 1);\\n            cur.pop_back();\\n        }\\n        return cnt;\\n    }\\n    bool test(vector<int>& cur, int num, int k) {\\n        for (auto &c : cur)\\n            if (abs(num - c) == k)\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> cur;\\n        return helper(nums, k, cur, 0);\\n    }\\nprivate:\\n    int helper(vector<int>& nums, int k, unordered_map<int, int>& cur, int start) {\\n        int cnt = 0;\\n        for (int i = start; i < nums.size(); ++i) {\\n            if (cur[nums[i] - k] || cur[nums[i] + k])\\n                continue;\\n            cur[nums[i]]++;\\n            cnt += 1 + helper(nums, k, cur, i + 1);\\n            cur[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314049,
                "title": "python-o-n",
                "content": "# Intuition\\nwe have to notice that the only elements that affect one another are those that exist in a streak of numbers that differ by k.\\n\\n# Approach\\ni group these numbers together into these streaks, and find the number of subsets of each streak separately. we can then multiply the answers together, since all streak subsets are compatible with one another.\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:    \\n        @cache\\n        # ways of choosing from streaks[si][i:]\\n        def ways(i, si):\\n            if i >= len(streaks[si]):\\n                return 1\\n            # there are 2**rep-1 ways of choosing at least \\n            # one of streak[i].\\n            return ways(i+1, si) + (2**reps[streaks[si][i]]-1) * ways(i+2, si)\\n        \\n        reps = defaultdict(int)\\n        mark = {} # -1 for start of streak, 1 otherwise\\n\\n        for num in nums:\\n            mark[num] = -1\\n\\n        for num in nums:\\n            if reps[num]:\\n                reps[num] += 1\\n            else:\\n                if num - k in mark:\\n                    mark[num] = 1\\n                reps[num] = 1\\n\\n        streaks = []\\n        for num in nums:\\n            if num not in mark or mark[num] == 1:\\n                continue\\n            curr = num\\n            streaks.append([])\\n            while curr in mark:\\n                streaks[-1].append(curr)\\n                del mark[curr]\\n                curr = curr + k\\n        \\n        prod = 1\\n        for i in range(len(streaks)):\\n            prod *= ways(0, i)\\n        return prod - 1 # don\\'t consider empty subset\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:    \\n        @cache\\n        # ways of choosing from streaks[si][i:]\\n        def ways(i, si):\\n            if i >= len(streaks[si]):\\n                return 1\\n            # there are 2**rep-1 ways of choosing at least \\n            # one of streak[i].\\n            return ways(i+1, si) + (2**reps[streaks[si][i]]-1) * ways(i+2, si)\\n        \\n        reps = defaultdict(int)\\n        mark = {} # -1 for start of streak, 1 otherwise\\n\\n        for num in nums:\\n            mark[num] = -1\\n\\n        for num in nums:\\n            if reps[num]:\\n                reps[num] += 1\\n            else:\\n                if num - k in mark:\\n                    mark[num] = 1\\n                reps[num] = 1\\n\\n        streaks = []\\n        for num in nums:\\n            if num not in mark or mark[num] == 1:\\n                continue\\n            curr = num\\n            streaks.append([])\\n            while curr in mark:\\n                streaks[-1].append(curr)\\n                del mark[curr]\\n                curr = curr + k\\n        \\n        prod = 1\\n        for i in range(len(streaks)):\\n            prod *= ways(0, i)\\n        return prod - 1 # don\\'t consider empty subset\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503409,
                "title": "brute-force-c-time-2-n",
                "content": "CHECK FOR ALL POSSIBLE SUBSETS\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int x,int k,vector<int> &v){\\n        for(auto &i: v){\\n            if(abs(i-x)==k)return false;\\n        }\\n        return true;\\n    }\\n    void solve(int s,vector<int> &nums,int k,vector<int> &v,int &ans){\\n        if(s==nums.size()){\\n            ans++;\\n            return;\\n        }\\n\\n        if(check(nums[s],k,v)){\\n            v.push_back(nums[s]);\\n            solve(s+1,nums,k,v,ans);\\n            v.pop_back();\\n        }\\n        solve(s+1,nums,k,v,ans);\\n    } \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = -1;\\n        vector<int> v;\\n        solve(0,nums,k,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int x,int k,vector<int> &v){\\n        for(auto &i: v){\\n            if(abs(i-x)==k)return false;\\n        }\\n        return true;\\n    }\\n    void solve(int s,vector<int> &nums,int k,vector<int> &v,int &ans){\\n        if(s==nums.size()){\\n            ans++;\\n            return;\\n        }\\n\\n        if(check(nums[s],k,v)){\\n            v.push_back(nums[s]);\\n            solve(s+1,nums,k,v,ans);\\n            v.pop_back();\\n        }\\n        solve(s+1,nums,k,v,ans);\\n    } \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = -1;\\n        vector<int> v;\\n        solve(0,nums,k,v,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352572,
                "title": "day-362-java-c-python-100-explained-intution-tc-0-n",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/8c8c2221-8c9f-4638-8411-13758d56504b_1680025666.3824496.png)\\n# UPVOTE PLS\\n\\n# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n##### \\u2022\\tThe goal is to count the number of subsets of an integer array nums that satisfy a certain condition. The condition is that for any two distinct elements a and b in a subset, the absolute difference |a-b| should be exactly equal to k.\\n##### \\u2022\\tThe code works by first creating a HashMap called frequencyMap that maps each number in the array to its frequency. Then it loops through each number in frequencyMap, and for each number it checks if there is another number in the map that is k less than it. If there is not, then it skips to the next number.\\n##### \\u2022\\tIf there is another number that is k less than the current number, then the code finds all other numbers that are k apart from each other, and creates a list of their frequencies. It then uses this list to calculate the number of subsets that satisfy the condition.\\n##### \\u2022\\tThe calculation is done using two variables, subsetWithout and subsetWith. subsetWithout keeps track of the number of subsets that do not include any of the k apart numbers, while subsetWith keeps track of the number of subsets that include at least one of the k apart numbers. The final answer is the product of all the subsetWith and subsetWithout values for each set of k apart numbers, plus 1 to account for the empty subset.\\n##### \\u2022\\tThe code then repeats this process for each number in the array, and multiplies the results together to get the final answer. The final answer is then subtracted by 1 to account for the empty subset.\\n\\n\\n\\n# Code\\n```java []\\n public int beautifulSubsets(int[] nums, int k) {\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num: nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        int result = 1;\\n        for (Map.Entry<Integer, Integer> entry: frequencyMap.entrySet()) {\\n            int key = entry.getKey();\\n            if (!frequencyMap.containsKey(key - k)) {\\n                if (!frequencyMap.containsKey(key + k)) {\\n                    result *= (1 << frequencyMap.get(key));\\n                    continue;\\n                }\\n                List<Integer> kDiffFrequencies = new ArrayList<>();\\n                kDiffFrequencies.add(frequencyMap.get(key));\\n                while (frequencyMap.containsKey(key + k)) {\\n                    key += k;\\n                    kDiffFrequencies.add(frequencyMap.get(key));\\n                }\\n                int subsetWithout = 0, subsetWith = 0;\\n                for (int frequency: kDiffFrequencies) {\\n                    subsetWithout = subsetWith + subsetWithout;\\n                    subsetWith = ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1);\\n                }\\n                result *= (subsetWith + subsetWithout + 1);\\n            }\\n        }\\n        return result - 1;\\n    }\\n```\\n```c++ []\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> frequencyMap;\\n        for (int num : nums) {\\n            frequencyMap[num]++;\\n        }\\n\\n        int result = 1;\\n        for (auto entry : frequencyMap) {\\n            int key = entry.first;\\n            if (!frequencyMap.count(key - k)) {\\n                if (!frequencyMap.count(key + k)) {\\n                    result *= (1 << frequencyMap[key]);\\n                    continue;\\n                }\\n\\n                vector<int> kDiffFrequencies;\\n                kDiffFrequencies.push_back(frequencyMap[key]);\\n                while (frequencyMap.count(key + k)) {\\n                    key += k;\\n                    kDiffFrequencies.push_back(frequencyMap[key]);\\n                }\\n\\n                int subsetWithout = 0, subsetWith = 0;\\n                for (int frequency : kDiffFrequencies) {\\n                    subsetWithout = subsetWith + subsetWithout;\\n                    subsetWith = ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1);\\n                }\\n\\n                result *= (subsetWith + subsetWithout + 1);\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n```\\n```python []\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        frequencyMap = {}\\n        for num in nums:\\n            frequencyMap[num] = frequencyMap.get(num, 0) + 1\\n\\n        result = 1\\n        for key, value in frequencyMap.items():\\n            if key - k not in frequencyMap:\\n                if key + k not in frequencyMap:\\n                    result *= (1 << frequencyMap[key])\\n                    continue\\n\\n                kDiffFrequencies = [frequencyMap[key]]\\n                while key + k in frequencyMap:\\n                    key += k\\n                    kDiffFrequencies.append(frequencyMap[key])\\n\\n                subsetWithout, subsetWith = 0, 0\\n                for frequency in kDiffFrequencies:\\n                    subsetWithout, subsetWith = subsetWith + subsetWithout, ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1)\\n\\n                result *= (subsetWith + subsetWithout + 1)\\n\\n        return result - 1\\n```\\nMY LINKE : https://leetcode.com/problems/the-number-of-beautiful-subsets/solutions/3352572/day-362-java-c-python-100-explained-intution-tc-0-n/?orderBy=most_votes\\n\\n# Complexity\\n\\n##### \\u2022\\tTime complexity: \\n##### \\u2022\\tThe function first creates a frequency map of the input array, which takes O(n) time, where n is the length of the input array. \\n##### \\u2022\\tThe function then loops through each entry in the frequency map, which takes O(m) time, where m is the number of unique elements in the input array.\\n##### \\u2022\\tFor each entry in the frequency map, the function checks if the value starts a chain of k difference values. \\n##### \\u2022\\tThis takes O(1) time. If the value does start a chain, the function creates a list of the frequencies of the values in the chain, which takes O(l) time, where l is the length of the chain. \\n##### \\u2022\\tThe function then loops through the frequencies in the list and calculates the number of beautiful subsets that can be formed using the values in the chain. This takes O(l) time. \\n##### \\u2022\\tFinally, the function multiplies the total number of beautiful subsets by the result accumulated so far, which takes O(1) time. Therefore, the total time complexity of the function is O(n + m * (l + l)), which simplifies to O(n + ml). \\n##### \\u2022\\tSpace complexity: The function creates a frequency map of the input array, which takes O(m) space, where m is the number of unique elements in the input array. The function creates a list of the frequencies of the values in the chain, which takes O(l) space, where l is the length of the chain. The function uses a constant amount of extra space for variables like result , key , and value . Therefore, the total space complexity of the function is O(m + l), where m is the number of unique elements in the input array and l is the length of the chain.\\n\\n# 2ND WAY \\n\\n#  Intuition & Approach\\n\\n##### \\u2022\\tThe problem asks us to find the number of beautiful subsets of the given array A , where a subset is beautiful if the absolute difference between any two elements in the subset is exactly k . \\n##### \\u2022\\tThe intuition behind the algorithm is to use dynamic programming to count the number of beautiful subsets that end with each element of the array. \\n##### \\u2022\\tWe can then sum up these counts to get the total number of beautiful subsets. To implement this approach, we first count the frequency of each element in the array using a HashMap . \\n##### \\u2022\\tWe then define a recursive function dp(a) that takes an element a and returns a pair of values (dp0, dp1) , where dp0 is the number of beautiful subsets that end with a and do not include any element that is k units away from a , and dp1 is the number of beautiful subsets that end with a and include at least one element that is k units away from a . To compute dp(a) , \\n##### \\u2022\\twe check if there is an element a-k in the count map. If there is, we recursively call dp(a-k) to get the values (dp0\\', dp1\\') for the element a-k . \\n##### \\u2022\\tWe can then compute dp0 and dp1 as follows: dp0 = dp0\\' + dp1\\' : We can append a to any beautiful subset that ends with a-k and does not include any element that is k units away from a . dp1 = dp0\\' * (2^count[a] - 1) : \\n##### \\u2022\\tWe can append a to any beautiful subset that ends with a-k and includes at least one element that is k units away from a . \\n##### \\u2022\\tThere are dp0\\' such subsets, and for each subset, we can choose any subset of the count[a] elements that are k units away from a , except for the empty subset. If there is no element a-k in the count map, we set dp0 = 1 and dp1 = 2^count[a] - 1 , since the only beautiful subset that ends with a is the singleton set {a} . To avoid redundant calculations, we use memoization to store the values of dp(a) in a HashMap called memo . \\n##### \\u2022\\tFinally, we sum up the values of dp0 and dp1 for all elements a in the count map that do not have an element a+k in the count map, and multiply them together to get the total number of beautiful subsets. \\n##### \\u2022\\tWe subtract 1 from the result to exclude the empty subset. The time complexity of this algorithm is O(n log n), where n is the length of the input array, since we need to sort the array and perform O(log n) recursive calls for each element. \\n##### \\u2022\\tThe space complexity is also O(n), since we need to store the count map and the memo map.\\n\\n\\n```PYTHON []\\nfrom collections import Counter\\nfrom functools import reduce\\nfrom operator import mul\\n\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = Counter(A)\\n\\n        @lru_cache(None)\\n        def dp(a):\\n            if a - k in count:\\n                dp0, dp1 = dp(a - k)\\n            else:\\n                dp0, dp1 = 1, 0\\n            return dp0 + dp1, dp0 * (2 ** count[a] - 1)\\n\\n        return reduce(mul, (sum(dp(a)) for a in count if a + k not in count)) - 1\\n```\\n```JAVA []\\n\\n class Solution {\\n    public int beautifulSubsets(int[] A, int k) {\\n        Map<Integer, Integer> count = new HashMap<Integer, Integer>();\\n        for (int a : A) {\\n            if (count.containsKey(a)) {\\n                count.put(a, count.get(a) + 1);\\n            } else {\\n                count.put(a, 1);\\n            }\\n        }\\n\\n        final Map<Integer, Pair<Integer, Integer>> memo = new HashMap<Integer, Pair<Integer, Integer>>();\\n        Function<Integer, Pair<Integer, Integer>> dp = new Function<Integer, Pair<Integer, Integer>>() {\\n            public Pair<Integer, Integer> apply(Integer a) {\\n                if (count.containsKey(a - k)) {\\n                    Pair<Integer, Integer> p = memo.containsKey(a - k) ? memo.get(a - k) : apply(a - k);\\n                    int dp0 = p.getKey() + p.getValue();\\n                    int dp1 = p.getKey() * ((1 << count.get(a)) - 1);\\n                    Pair<Integer, Integer> result = new Pair<Integer, Integer>(dp0, dp1);\\n                    memo.put(a, result);\\n                    return result;\\n                } else {\\n                    Pair<Integer, Integer> result = new Pair<Integer, Integer>(1, (1 << count.get(a)) - 1);\\n                    memo.put(a, result);\\n                    return result;\\n                }\\n            }\\n        };\\n\\n        int result = 1;\\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\\n            int a = entry.getKey();\\n            int freq = entry.getValue();\\n            if (!count.containsKey(a + k)) {\\n                Pair<Integer, Integer> p = memo.containsKey(a) ? memo.get(a) : dp.apply(a);\\n                result *= p.getKey() + p.getValue();\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& A, int k) {\\n        unordered_map<int, int> count;\\n        for (int a : A) {\\n            count[a]++;\\n        }\\n\\n        function<pair<int, int>(int)> dp = [&](int a) {\\n            if (count.count(a - k)) {\\n                auto [dp0, dp1] = dp(a - k);\\n                return make_pair(dp0 + dp1, dp0 * ((1 << count[a]) - 1));\\n            } else {\\n                return make_pair(1, (1 << count[a]) - 1);\\n            }\\n        };\\n\\n        int result = 1;\\n        for (auto [a, freq] : count) {\\n            if (!count.count(a + k)) {\\n                auto [dp0, dp1] = dp(a);\\n                result *= dp0 + dp1;\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n};\\n```\\n# DRY RUN \\nhere\\'s a dry run of the function for the input nums = [2,4,6], k = 2:\\n##### \\u2022\\tCreate a frequency map of the input array:\\n##### \\u2022\\tcount = {\\n##### \\u2022\\t  2: 1,\\n##### \\u2022\\t  4: 1,\\n##### \\u2022\\t  6: 1,\\n##### \\u2022\\t}\\n##### \\u2022\\tDefine the recursive function dp:\\n##### \\u2022\\tdp(a) = (dp0, dp1)\\n##### \\u2022 where dp0 is the number of beautiful subsets that end with a and do not include any element that is k units away from a, and dp1 is the number of beautiful subsets that end with a and include at least one element that is k units away from a.\\n##### \\u2022 If count contains a - k, then we recursively call dp(a - k) to get the values (dp0\\', dp1\\') for a - k, and compute dp0 and dp1 as follows:\\n##### \\u2022 dp0 = dp0\\' + dp1\\'    // append a to any beautiful subset that ends with a-k and does not include any element that is k units away from a\\n##### \\u2022 dp1 = dp0\\' * ((1 << count[a]) - 1)    // append a to any beautiful subset that ends with a-k and includes at least one element that is k units away from a\\n##### \\u2022 If count does not contain a - k, then we set dp0 = 1 and dp1 = (1 << count[a]) - 1, since the only beautiful subset that ends with a is the singleton set {a}.\\n##### \\u2022\\tInitialize the result to 1, and loop through each element a in count that does not have an element a + k in count. For each such element, call dp(a) to get the values (dp0, dp1), and multiply the result by dp0 + dp1.\\n##### \\u2022\\tresult = 1\\n##### \\u2022\\tfor a, freq in count:\\n##### \\u2022\\t  if not count.contains(a + k):\\n##### \\u2022\\t    dp0, dp1 = dp(a)\\n##### \\u2022\\t    result *= dp0 + dp1\\n##### \\u2022\\tSubtract 1 from the result to exclude the empty subset.\\n##### \\u2022\\tresult -= 1\\n##### \\u2022\\tReturn the result, which is 4 in this case, since there are 4 beautiful subsets of [2,4,6] with absolute difference k = 2: [2,4], [4,6], [2,4,6], and {} (empty subset).\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/0b543619-3a1b-4ddc-a9c8-18a654bf3beb_1680027671.40263.webp)\\n\\n\\n![meme2.png](https://assets.leetcode.com/users/images/9a8e78eb-e53b-4307-9f8a-bf70e512b8a0_1680025478.1222885.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```java []\\n public int beautifulSubsets(int[] nums, int k) {\\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\\n        for (int num: nums) {\\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\\n        }\\n        int result = 1;\\n        for (Map.Entry<Integer, Integer> entry: frequencyMap.entrySet()) {\\n            int key = entry.getKey();\\n            if (!frequencyMap.containsKey(key - k)) {\\n                if (!frequencyMap.containsKey(key + k)) {\\n                    result *= (1 << frequencyMap.get(key));\\n                    continue;\\n                }\\n                List<Integer> kDiffFrequencies = new ArrayList<>();\\n                kDiffFrequencies.add(frequencyMap.get(key));\\n                while (frequencyMap.containsKey(key + k)) {\\n                    key += k;\\n                    kDiffFrequencies.add(frequencyMap.get(key));\\n                }\\n                int subsetWithout = 0, subsetWith = 0;\\n                for (int frequency: kDiffFrequencies) {\\n                    subsetWithout = subsetWith + subsetWithout;\\n                    subsetWith = ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1);\\n                }\\n                result *= (subsetWith + subsetWithout + 1);\\n            }\\n        }\\n        return result - 1;\\n    }\\n```\n```c++ []\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int, int> frequencyMap;\\n        for (int num : nums) {\\n            frequencyMap[num]++;\\n        }\\n\\n        int result = 1;\\n        for (auto entry : frequencyMap) {\\n            int key = entry.first;\\n            if (!frequencyMap.count(key - k)) {\\n                if (!frequencyMap.count(key + k)) {\\n                    result *= (1 << frequencyMap[key]);\\n                    continue;\\n                }\\n\\n                vector<int> kDiffFrequencies;\\n                kDiffFrequencies.push_back(frequencyMap[key]);\\n                while (frequencyMap.count(key + k)) {\\n                    key += k;\\n                    kDiffFrequencies.push_back(frequencyMap[key]);\\n                }\\n\\n                int subsetWithout = 0, subsetWith = 0;\\n                for (int frequency : kDiffFrequencies) {\\n                    subsetWithout = subsetWith + subsetWithout;\\n                    subsetWith = ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1);\\n                }\\n\\n                result *= (subsetWith + subsetWithout + 1);\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n```\n```python []\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        frequencyMap = {}\\n        for num in nums:\\n            frequencyMap[num] = frequencyMap.get(num, 0) + 1\\n\\n        result = 1\\n        for key, value in frequencyMap.items():\\n            if key - k not in frequencyMap:\\n                if key + k not in frequencyMap:\\n                    result *= (1 << frequencyMap[key])\\n                    continue\\n\\n                kDiffFrequencies = [frequencyMap[key]]\\n                while key + k in frequencyMap:\\n                    key += k\\n                    kDiffFrequencies.append(frequencyMap[key])\\n\\n                subsetWithout, subsetWith = 0, 0\\n                for frequency in kDiffFrequencies:\\n                    subsetWithout, subsetWith = subsetWith + subsetWithout, ((1 << frequency) - 1) * ((subsetWithout - subsetWith) + 1)\\n\\n                result *= (subsetWith + subsetWithout + 1)\\n\\n        return result - 1\\n```\n```PYTHON []\\nfrom collections import Counter\\nfrom functools import reduce\\nfrom operator import mul\\n\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        count = Counter(A)\\n\\n        @lru_cache(None)\\n        def dp(a):\\n            if a - k in count:\\n                dp0, dp1 = dp(a - k)\\n            else:\\n                dp0, dp1 = 1, 0\\n            return dp0 + dp1, dp0 * (2 ** count[a] - 1)\\n\\n        return reduce(mul, (sum(dp(a)) for a in count if a + k not in count)) - 1\\n```\n```JAVA []\\n\\n class Solution {\\n    public int beautifulSubsets(int[] A, int k) {\\n        Map<Integer, Integer> count = new HashMap<Integer, Integer>();\\n        for (int a : A) {\\n            if (count.containsKey(a)) {\\n                count.put(a, count.get(a) + 1);\\n            } else {\\n                count.put(a, 1);\\n            }\\n        }\\n\\n        final Map<Integer, Pair<Integer, Integer>> memo = new HashMap<Integer, Pair<Integer, Integer>>();\\n        Function<Integer, Pair<Integer, Integer>> dp = new Function<Integer, Pair<Integer, Integer>>() {\\n            public Pair<Integer, Integer> apply(Integer a) {\\n                if (count.containsKey(a - k)) {\\n                    Pair<Integer, Integer> p = memo.containsKey(a - k) ? memo.get(a - k) : apply(a - k);\\n                    int dp0 = p.getKey() + p.getValue();\\n                    int dp1 = p.getKey() * ((1 << count.get(a)) - 1);\\n                    Pair<Integer, Integer> result = new Pair<Integer, Integer>(dp0, dp1);\\n                    memo.put(a, result);\\n                    return result;\\n                } else {\\n                    Pair<Integer, Integer> result = new Pair<Integer, Integer>(1, (1 << count.get(a)) - 1);\\n                    memo.put(a, result);\\n                    return result;\\n                }\\n            }\\n        };\\n\\n        int result = 1;\\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\\n            int a = entry.getKey();\\n            int freq = entry.getValue();\\n            if (!count.containsKey(a + k)) {\\n                Pair<Integer, Integer> p = memo.containsKey(a) ? memo.get(a) : dp.apply(a);\\n                result *= p.getKey() + p.getValue();\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& A, int k) {\\n        unordered_map<int, int> count;\\n        for (int a : A) {\\n            count[a]++;\\n        }\\n\\n        function<pair<int, int>(int)> dp = [&](int a) {\\n            if (count.count(a - k)) {\\n                auto [dp0, dp1] = dp(a - k);\\n                return make_pair(dp0 + dp1, dp0 * ((1 << count[a]) - 1));\\n            } else {\\n                return make_pair(1, (1 << count[a]) - 1);\\n            }\\n        };\\n\\n        int result = 1;\\n        for (auto [a, freq] : count) {\\n            if (!count.count(a + k)) {\\n                auto [dp0, dp1] = dp(a);\\n                result *= dp0 + dp1;\\n            }\\n        }\\n\\n        return result - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315644,
                "title": "2-n-easy-to-understand-short-sweet-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(int s,vector<int> &nums,int &k,unordered_map<int,int> &mp,int &ans){\\n        if(s==nums.size()){ans++;return;}\\n        if(mp[nums[s]+k]==0&&mp[nums[s]-k]==0){\\n            mp[nums[s]]++;\\n            solve(s+1,nums,k,mp,ans);\\n            mp[nums[s]]--;\\n        }\\n        solve(s+1,nums,k,mp,ans);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        solve(0,nums,k,mp,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int s,vector<int> &nums,int &k,unordered_map<int,int> &mp,int &ans){\\n        if(s==nums.size()){ans++;return;}\\n        if(mp[nums[s]+k]==0&&mp[nums[s]-k]==0){\\n            mp[nums[s]]++;\\n            solve(s+1,nums,k,mp,ans);\\n            mp[nums[s]]--;\\n        }\\n        solve(s+1,nums,k,mp,ans);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int,int> mp;\\n        solve(0,nums,k,mp,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313984,
                "title": "easy-c-solution-binary-search-backtracking-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, int k, int n, vector<int> &nums, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        int o1 = 0, o2 = 0;\\n        o1 = solve(i + 1, k, n, nums, dp);\\n        if (binary_search(dp.begin(), dp.end(), nums[i] - k) == 0)\\n        {\\n            dp.push_back(nums[i]);\\n            o2 = 1 + solve(i + 1, k, n, nums, dp);\\n            dp.pop_back();\\n        }\\n    \\n        return o1 + o2;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        vector<int> dp;\\n        return solve(0, k, n, nums, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, int k, int n, vector<int> &nums, vector<int> &dp)\\n    {\\n        if (i == n)\\n        {\\n            return 0;\\n        }\\n        \\n        int o1 = 0, o2 = 0;\\n        o1 = solve(i + 1, k, n, nums, dp);\\n        if (binary_search(dp.begin(), dp.end(), nums[i] - k) == 0)\\n        {\\n            dp.push_back(nums[i]);\\n            o2 = 1 + solve(i + 1, k, n, nums, dp);\\n            dp.pop_back();\\n        }\\n    \\n        return o1 + o2;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int n = nums.size();\\n        vector<int> dp;\\n        return solve(0, k, n, nums, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359542,
                "title": "python-dynamic-programming-90ms",
                "content": "1. First we group `nums` by `n % k`. These buckets are disjoint, we could compute the number of beautiful subsets for each bucket(including empty set), and the product of these numbers minus 1 would be the answer.\\n2. For each bucket, use dynamic programming. Here we consider an example, [2,2,2,4,4,6], `k = 2`.\\n![image](https://assets.leetcode.com/users/images/1ed9628e-5e11-4b4d-ad95-dd6962cf24cc_1680187738.536953.png)\\nFirst we consider only 2. There are `2**3-1 = 7` subsets containing 2, and `1` subset not containing 2(empty), i.e. `dp_y = 7, dp_n = 1`.\\nNext we consider 4. If we choose to have 4 in our subsets, it cannot come from those subsets containing 2, i.e. `dp_y = 1*(2**2-1) = 3`. If we choose not to have 4, it can come from either subsets containing 2 or not, i.e. `dp_n = 7+1 = 8`.\\nFinally we consider 6. Similar to above, we have `dp_y = 8*1 = 8, dp_n = 3+8 = 11`.\\nSo the number of all possibilities(including empty set) is the sum of the rightmost column, `8+11 = 19`.\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        buckets = [[] for _ in range(k)]\\n        for n in nums:\\n            buckets[n % k].append(n)\\n        \\n        def dp(bu):\\n            cnt = Counter(bu)\\n            arr = sorted((key, val) for key, val in cnt.items())\\n            dp_y, dp_n = 2**arr[0][1]-1, 1\\n            for i, (key, val) in enumerate(arr[1:], start=1):\\n                tmp = 2**val-1\\n                if key - arr[i-1][0] == k:\\n                    dp_y, dp_n = dp_n*tmp, dp_y+dp_n\\n                else:\\n                    dp_y, dp_n = (dp_y+dp_n)*tmp, dp_y+dp_n\\n            return dp_y + dp_n\\n        \\n        ans = 1\\n        for bu in buckets:\\n            if bu:\\n                ans *= dp(bu)\\n        return ans - 1",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "1. First we group `nums` by `n % k`. These buckets are disjoint, we could compute the number of beautiful subsets for each bucket(including empty set), and the product of these numbers minus 1 would be the answer.\\n2. For each bucket, use dynamic programming. Here we consider an example, [2,2,2,4,4,6], `k = 2`.\\n![image](https://assets.leetcode.com/users/images/1ed9628e-5e11-4b4d-ad95-dd6962cf24cc_1680187738.536953.png)\\nFirst we consider only 2. There are `2**3-1 = 7` subsets containing 2, and `1` subset not containing 2(empty), i.e. `dp_y = 7, dp_n = 1`.\\nNext we consider 4. If we choose to have 4 in our subsets, it cannot come from those subsets containing 2, i.e. `dp_y = 1*(2**2-1) = 3`. If we choose not to have 4, it can come from either subsets containing 2 or not, i.e. `dp_n = 7+1 = 8`.\\nFinally we consider 6. Similar to above, we have `dp_y = 8*1 = 8, dp_n = 3+8 = 11`.\\nSo the number of all possibilities(including empty set) is the sum of the rightmost column, `8+11 = 19`.\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        buckets = [[] for _ in range(k)]\\n        for n in nums:\\n            buckets[n % k].append(n)\\n        \\n        def dp(bu):\\n            cnt = Counter(bu)\\n            arr = sorted((key, val) for key, val in cnt.items())\\n            dp_y, dp_n = 2**arr[0][1]-1, 1\\n            for i, (key, val) in enumerate(arr[1:], start=1):\\n                tmp = 2**val-1\\n                if key - arr[i-1][0] == k:\\n                    dp_y, dp_n = dp_n*tmp, dp_y+dp_n\\n                else:\\n                    dp_y, dp_n = (dp_y+dp_n)*tmp, dp_y+dp_n\\n            return dp_y + dp_n\\n        \\n        ans = 1\\n        for bu in buckets:\\n            if bu:\\n                ans *= dp(bu)\\n        return ans - 1",
                "codeTag": "Java"
            },
            {
                "id": 3319005,
                "title": "simple-backtracking-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &v, vector<int> &nums, int k) {\\n        if(i == n) return 1;\\n        \\n        int notPick = dfs(i + 1, n, v, nums, k), pick = 0;\\n        int f = 0;\\n        for(int j : v) {\\n            if(abs(j - nums[i]) == k) {\\n                f = 1;\\n                break;\\n            }\\n        }\\n        if(!f) {\\n            v.push_back(nums[i]);\\n            pick = dfs(i + 1, n, v, nums, k);\\n            v.pop_back();\\n        }\\n        return pick + notPick;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v;\\n        return dfs(0, n, v, nums, k) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &v, vector<int> &nums, int k) {\\n        if(i == n) return 1;\\n        \\n        int notPick = dfs(i + 1, n, v, nums, k), pick = 0;\\n        int f = 0;\\n        for(int j : v) {\\n            if(abs(j - nums[i]) == k) {\\n                f = 1;\\n                break;\\n            }\\n        }\\n        if(!f) {\\n            v.push_back(nums[i]);\\n            pick = dfs(i + 1, n, v, nums, k);\\n            v.pop_back();\\n        }\\n        return pick + notPick;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        vector<int> v;\\n        return dfs(0, n, v, nums, k) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317714,
                "title": "python-backtracking-explanation",
                "content": "# Intuition\\nSubset problem, think of using backtracking!\\n\\n***Why using dictionary instead of set or list?***\\nUsing List : When checking numbers in seen, it needs O(n) to check which is inefficient. \\n***Then you will think about use set***. However, when you are going yo pop out the number for current dfs level and there are serveral same numbers in the subsets, there would be a problem.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        self.output = 0\\n        def dfs(start,seen) :\\n            if start >= len(nums) :\\n                return\\n            for i in range(start, len(nums)) :\\n                if len(seen) != 0 and seen[nums[i]-k] != 0 or seen[nums[i]+k] != 0 :\\n                    continue\\n                seen[nums[i]] += 1\\n                self.output += 1\\n                dfs(i+1, seen)\\n                seen[nums[i]] -= 1\\n            return\\n        dfs(0, collections.defaultdict(int))\\n        return self.output\\n                \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        self.output = 0\\n        def dfs(start,seen) :\\n            if start >= len(nums) :\\n                return\\n            for i in range(start, len(nums)) :\\n                if len(seen) != 0 and seen[nums[i]-k] != 0 or seen[nums[i]+k] != 0 :\\n                    continue\\n                seen[nums[i]] += 1\\n                self.output += 1\\n                dfs(i+1, seen)\\n                seen[nums[i]] -= 1\\n            return\\n        dfs(0, collections.defaultdict(int))\\n        return self.output\\n                \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314540,
                "title": "bitmask-o-nlogn-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ngenerate all the possible subset and then check whether ele-k is present in the subset we pick..we can simply check it in o(1) by taking a array which will store the index of all the element .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n         long long int maxi=(1ll<<n);\\n        int cnt=0;\\n        sort(nums.begin(),nums.end());\\n        int ele[2001];\\n        memset(ele,-1,sizeof(ele));\\n        for(int i=0;i<n;i++)\\n        {\\n            ele[nums[i]]=i;\\n        }\\n        for( long long int  i=1;i<maxi;i++)\\n        {\\n            \\n            bool f=true;\\n             for(int j=0;j<n;j++)\\n             {\\n                  long long int  val=((1ll<<j)&i);\\n                 if(val)\\n                 {\\n                      if(nums[j]<=k)continue;\\n                      int req=(nums[j]-k);\\n                     if(ele[req]==-1)continue;\\n                     int idx=ele[req];\\n                     long long int val2=(i&(1ll<<idx));\\n                     if(val2){\\n                         f=false;\\n                         break;\\n                     }\\n                     \\n                 }\\n             }\\n            \\n            if(f)cnt++;\\n           \\n            \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n         long long int maxi=(1ll<<n);\\n        int cnt=0;\\n        sort(nums.begin(),nums.end());\\n        int ele[2001];\\n        memset(ele,-1,sizeof(ele));\\n        for(int i=0;i<n;i++)\\n        {\\n            ele[nums[i]]=i;\\n        }\\n        for( long long int  i=1;i<maxi;i++)\\n        {\\n            \\n            bool f=true;\\n             for(int j=0;j<n;j++)\\n             {\\n                  long long int  val=((1ll<<j)&i);\\n                 if(val)\\n                 {\\n                      if(nums[j]<=k)continue;\\n                      int req=(nums[j]-k);\\n                     if(ele[req]==-1)continue;\\n                     int idx=ele[req];\\n                     long long int val2=(i&(1ll<<idx));\\n                     if(val2){\\n                         f=false;\\n                         break;\\n                     }\\n                     \\n                 }\\n             }\\n            \\n            if(f)cnt++;\\n           \\n            \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314085,
                "title": "subset-generation-video-solution-easy",
                "content": "\\n\\n# Approach\\nA basic subset generation question, The idea is to add elements which satisfy the constraints i.e. abs(nums[idx]-any_element_in_subset)!=k.\\nIn each recursive call add the current element to the subset &update the mask (if the above condition holds). Irrespective of the condition holding true. You can avoid the current element and jump to the next one without modifying the mask. \\nTo remove the nonempty subset from the calculation subtract 1 at the end.\\n The code is self-explanatory and have provided a link to the video which goes over the code too:  https://www.youtube.com/watch?v=scYIG0OHEEg\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void cal(int idx,vector<int>& nums,int k,int mask){\\n        bool cant=false;\\n        if(idx==nums.size())    {res++;return;}\\n        for(int i=0;i<idx;i++){\\n            if(mask&(1<<i)){            // is set .... \\n                if(abs(nums[i]-nums[idx])==k){\\n                    cant=true;\\n                    break;\\n                }\\n            }\\n        }\\n        if(!cant)   cal(idx+1,nums,k,mask|(1<<idx));        // add \\n        cal(idx+1,nums,k,mask);                             // don\\'t\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        res=0;\\n        cal(0,nums,k,0);\\n        return res-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    void cal(int idx,vector<int>& nums,int k,int mask){\\n        bool cant=false;\\n        if(idx==nums.size())    {res++;return;}\\n        for(int i=0;i<idx;i++){\\n            if(mask&(1<<i)){            // is set .... \\n                if(abs(nums[i]-nums[idx])==k){\\n                    cant=true;\\n                    break;\\n                }\\n            }\\n        }\\n        if(!cant)   cal(idx+1,nums,k,mask|(1<<idx));        // add \\n        cal(idx+1,nums,k,mask);                             // don\\'t\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        res=0;\\n        cal(0,nums,k,0);\\n        return res-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314033,
                "title": "follow-procedure-easy-python3",
                "content": "\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:  \\n        \\n        def count(n,prev):\\n            if n == 0:\\n                return 1 \\n            ans = 0\\n            if prev[nums[n-1]-k] == 0 and prev[nums[n-1]+k] == 0:\\n                prev[nums[n-1]] += 1\\n                ans += count(n-1,prev) \\n                prev[nums[n-1]] -= 1 \\n            ans += count(n-1,prev) \\n            \\n            return ans \\n        \\n        return count(len(nums),Counter())-1\\n                 \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:  \\n        \\n        def count(n,prev):\\n            if n == 0:\\n                return 1 \\n            ans = 0\\n            if prev[nums[n-1]-k] == 0 and prev[nums[n-1]+k] == 0:\\n                prev[nums[n-1]] += 1\\n                ans += count(n-1,prev) \\n                prev[nums[n-1]] -= 1 \\n            ans += count(n-1,prev) \\n            \\n            return ans \\n        \\n        return count(len(nums),Counter())-1\\n                 \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752856,
                "title": "javascript-2597-the-number-of-beautiful-subsets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar beautifulSubsets = function (A, k) {\\n\\n  function bt(a) {\\n    let n = a.length\\n    if (n === 0) return 0\\n    let s = 0\\n    for (let i = 0; i < n; i++) {\\n      let b = []\\n      for (let j = i + 1; j < n; j++) {\\n        if (Math.abs(a[i] - a[j]) !== k) {\\n          b.push(a[j])\\n        }\\n      }\\n      s += 1 + bt(b)\\n    }\\n    return s\\n  }\\n\\n  let s = bt(A)\\n  return s\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar beautifulSubsets = function (A, k) {\\n\\n  function bt(a) {\\n    let n = a.length\\n    if (n === 0) return 0\\n    let s = 0\\n    for (let i = 0; i < n; i++) {\\n      let b = []\\n      for (let j = i + 1; j < n; j++) {\\n        if (Math.abs(a[i] - a[j]) !== k) {\\n          b.push(a[j])\\n        }\\n      }\\n      s += 1 + bt(b)\\n    }\\n    return s\\n  }\\n\\n  let s = bt(A)\\n  return s\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3597292,
                "title": "recursion-and-backtracking",
                "content": ">\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(int x, vector<int> &ds, int k)\\n{\\n    for (int i = 0; i < ds.size(); i++)\\n    {\\n        if (abs(ds[i] - x) == k)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid solve(int ind, vector<int> &ds, vector<int> &nums, int &ans, int n, int k)\\n{\\n    if (ind == n)\\n    {\\n        ans++;\\n        return;\\n    }\\n    if (isvalid(nums[ind], ds, k))\\n    {\\n        ds.push_back(nums[ind]);\\n        solve(ind + 1, ds, nums, ans, n, k);\\n        ds.pop_back();   \\n    }\\n    solve(ind + 1, ds, nums, ans, n, k);\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    int n = nums.size();\\n    vector<int> ds;\\n    int ans = 0;\\n    solve(0, ds, nums, ans, n, k);\\n    return ans - 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(int x, vector<int> &ds, int k)\\n{\\n    for (int i = 0; i < ds.size(); i++)\\n    {\\n        if (abs(ds[i] - x) == k)\\n        {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nvoid solve(int ind, vector<int> &ds, vector<int> &nums, int &ans, int n, int k)\\n{\\n    if (ind == n)\\n    {\\n        ans++;\\n        return;\\n    }\\n    if (isvalid(nums[ind], ds, k))\\n    {\\n        ds.push_back(nums[ind]);\\n        solve(ind + 1, ds, nums, ans, n, k);\\n        ds.pop_back();   \\n    }\\n    solve(ind + 1, ds, nums, ans, n, k);\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    int n = nums.size();\\n    vector<int> ds;\\n    int ans = 0;\\n    solve(0, ds, nums, ans, n, k);\\n    return ans - 1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515983,
                "title": "scala-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O (2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n      def beautifulSubsets(arr: Array[Int], k: Int): Int = {\\n        subsets(0, -1, k, arr.sorted, Set.empty[Int]) - 1\\n      }\\n\\n      def subsets(i: Int, prev_i: Int, k: Int, arr: Array[Int], set: Set[Int]): Int = {\\n        if (i == arr.length) 1\\n        else {\\n          val newSet = set + arr(i)\\n          if (prev_i == -1 || !newSet.contains(arr(i) - k)) subsets(i + 1, i, k, arr, newSet) + subsets(i + 1, prev_i, k, arr, set)\\n          else subsets(i + 1, prev_i, k, arr, set)\\n        }\\n      }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n      def beautifulSubsets(arr: Array[Int], k: Int): Int = {\\n        subsets(0, -1, k, arr.sorted, Set.empty[Int]) - 1\\n      }\\n\\n      def subsets(i: Int, prev_i: Int, k: Int, arr: Array[Int], set: Set[Int]): Int = {\\n        if (i == arr.length) 1\\n        else {\\n          val newSet = set + arr(i)\\n          if (prev_i == -1 || !newSet.contains(arr(i) - k)) subsets(i + 1, i, k, arr, newSet) + subsets(i + 1, prev_i, k, arr, set)\\n          else subsets(i + 1, prev_i, k, arr, set)\\n        }\\n      }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3460032,
                "title": "pick-not-pick-python-explained",
                "content": "# Intuition\\nWe are supposed to count all subsets which have no elements such that there diff == k.\\nSort the nums array and move with two options pick & notpick.\\nHow to pick elements?\\na - b == k -> dontpick\\na - k  == b -> dont pick\\nWe can pick a element only if `a - k` not present in path.\\nreturn count of all subsets.\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        path = []\\n        def recur(i, path):\\n            if i >= len(nums):\\n                if len(path) > 0:\\n                  return 1\\n                return 0\\n            \\n            notPick = recur(i+1, path)\\n            pick = 0\\n\\n            if (nums[i] - k) not in path :\\n                pick = recur(i+1, path + [nums[i]])\\n            \\n            return pick + notPick\\n        count = recur(0, path)\\n        return(count)\\n\\n        \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        path = []\\n        def recur(i, path):\\n            if i >= len(nums):\\n                if len(path) > 0:\\n                  return 1\\n                return 0\\n            \\n            notPick = recur(i+1, path)\\n            pick = 0\\n\\n            if (nums[i] - k) not in path :\\n                pick = recur(i+1, path + [nums[i]])\\n            \\n            return pick + notPick\\n        count = recur(0, path)\\n        return(count)\\n\\n        \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338926,
                "title": "why-is-this-giving-wrong-answer-python",
                "content": "I am testing whether the set is valid for all the subset. I know that it will give TLE But instead it is giving wrong answer what is the problem in the code.\\n\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) : \\n                        invalidset[nums[i]] += 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```\\n\\n```\\nWrong Answer\\nRuntime: 5385 ms\\nInput\\n  nums = [15,6,3,25,14,29,21,16,28,23,11,9,4,30,24,12,26,1,27,18]\\n  k = 7\\nOutput \\n  172799\\nExpected \\n  163839\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) : \\n                        invalidset[nums[i]] += 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```\n```\\nWrong Answer\\nRuntime: 5385 ms\\nInput\\n  nums = [15,6,3,25,14,29,21,16,28,23,11,9,4,30,24,12,26,1,27,18]\\n  k = 7\\nOutput \\n  172799\\nExpected \\n  163839\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319706,
                "title": "easy-c-solution-best-backtracking-way-beats-100-backtracking-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<int>&nums,unordered_map<int,int>&mp)\\n    {\\n        if(i == nums.size())\\n            return 1;\\n\\n        //take;\\n        int take = 0;\\n        if(!mp[nums[i]-k] && !mp[nums[i]+k])\\n        {\\n            mp[nums[i]]++;\\n            take = solve(i+1,k,nums,mp);\\n            mp[nums[i]]--;\\n\\n        }\\n        //not take \\n        int not_take = solve(i+1,k,nums,mp);\\n        // cout<<take<<\" \"<<not_take<<endl;\\n\\n        return take+not_take;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        // vector<int>dp(n+1,-1);\\n        return solve(0,k,nums,mp) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k,vector<int>&nums,unordered_map<int,int>&mp)\\n    {\\n        if(i == nums.size())\\n            return 1;\\n\\n        //take;\\n        int take = 0;\\n        if(!mp[nums[i]-k] && !mp[nums[i]+k])\\n        {\\n            mp[nums[i]]++;\\n            take = solve(i+1,k,nums,mp);\\n            mp[nums[i]]--;\\n\\n        }\\n        //not take \\n        int not_take = solve(i+1,k,nums,mp);\\n        // cout<<take<<\" \"<<not_take<<endl;\\n\\n        return take+not_take;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int>mp;\\n        sort(nums.begin(),nums.end());\\n        // vector<int>dp(n+1,-1);\\n        return solve(0,k,nums,mp) - 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3318556,
                "title": "c-backtracking-faster-easy-to-understand",
                "content": "* ***Backtracking***\\n\\n* ***Time Complexity :- O(2 ^ N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    // declare a unordered map\\n    \\n    unordered_map<int, int> mp;\\n    \\n    void dfs(vector<int>& nums, int i, int n, int k)\\n    {\\n        // base case, if we have found a subset\\n        \\n        if(i == n)\\n        {\\n            count++;\\n            \\n            return;\\n        }\\n        \\n        // inclusion part\\n        \\n        // according to condition add the curr element\\n        \\n        if(mp[nums[i] - k] == 0)\\n        {\\n            mp[nums[i]]++;\\n            \\n            dfs(nums, i + 1, n, k);\\n            \\n            mp[nums[i]]--;\\n        }\\n        \\n        // exclusion part\\n        \\n        dfs(nums, i + 1, n, k);\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // call dfs function\\n        \\n        dfs(nums, 0, n, k);\\n        \\n        // remove one empty set from count\\n        \\n        return count - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int count = 0;\\n    \\n    // declare a unordered map\\n    \\n    unordered_map<int, int> mp;\\n    \\n    void dfs(vector<int>& nums, int i, int n, int k)\\n    {\\n        // base case, if we have found a subset\\n        \\n        if(i == n)\\n        {\\n            count++;\\n            \\n            return;\\n        }\\n        \\n        // inclusion part\\n        \\n        // according to condition add the curr element\\n        \\n        if(mp[nums[i] - k] == 0)\\n        {\\n            mp[nums[i]]++;\\n            \\n            dfs(nums, i + 1, n, k);\\n            \\n            mp[nums[i]]--;\\n        }\\n        \\n        // exclusion part\\n        \\n        dfs(nums, i + 1, n, k);\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        int n = nums.size();\\n        \\n        // sort the array\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        // call dfs function\\n        \\n        dfs(nums, 0, n, k);\\n        \\n        // remove one empty set from count\\n        \\n        return count - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318521,
                "title": "test-cases-not-comprehensive",
                "content": "The solution below is accepted but is actually incorrect.\\nConsider nums = [5,5,10], k = 5\\n\\nThe solution below will consider [5,10] as a valid subset.\\n```\\nclass Solution:\\n    # this accepted solution is actually incorrect\\n    # fails:\\n    # nums = [5,5,10], k = 5\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        self.ret = 0\\n        \\n        def formSubsets(idx: int, curr: Set[int]):\\n            if len(curr) > 0:\\n                self.ret += 1\\n                \\n            for i in range(idx, len(nums)):\\n                if nums[i] - k in curr or nums[i] + k in curr:\\n                    continue\\n                curr.add(nums[i])\\n                formSubsets(i+1, curr)\\n                if nums[i] in curr:\\n                    curr.remove(nums[i]) # removing all occurence is NOT fine!\\n           \\n            \\n        formSubsets(0, set())\\n        return self.ret     \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # this accepted solution is actually incorrect\\n    # fails:\\n    # nums = [5,5,10], k = 5\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        self.ret = 0\\n        \\n        def formSubsets(idx: int, curr: Set[int]):\\n            if len(curr) > 0:\\n                self.ret += 1\\n                \\n            for i in range(idx, len(nums)):\\n                if nums[i] - k in curr or nums[i] + k in curr:\\n                    continue\\n                curr.add(nums[i])\\n                formSubsets(i+1, curr)\\n                if nums[i] in curr:\\n                    curr.remove(nums[i]) # removing all occurence is NOT fine!\\n           \\n            \\n        formSubsets(0, set())\\n        return self.ret     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317468,
                "title": "take-or-not-take-c",
                "content": "```\\nint ans=0;\\n    \\n    void solve(vector<int>&nums,int k,vector<int>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans++;\\n            return;\\n        }\\n        bool flag=true;\\n        for(int j=0;j<v.size();j++)\\n        {\\n            if(abs(v[j]-nums[i])==k)\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums,k,v,i+1);\\n            v.pop_back();\\n        }\\n        solve(nums,k,v,i+1);\\n    }\\n    \\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums,k,v,i+1);\\n            v.pop_back();\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nint ans=0;\\n    \\n    void solve(vector<int>&nums,int k,vector<int>&v,int i)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans++;\\n            return;\\n        }\\n        bool flag=true;\\n        for(int j=0;j<v.size();j++)\\n        {\\n            if(abs(v[j]-nums[i])==k)\\n            {\\n                flag=false;\\n                break;\\n            }\\n        }\\n        if(flag)\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums,k,v,i+1);\\n            v.pop_back();\\n        }\\n        solve(nums,k,v,i+1);\\n    }\\n    \\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        vector<int>v;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(nums[i]);\\n            solve(nums,k,v,i+1);\\n            v.pop_back();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317013,
                "title": "python-simple-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums, k):\\n        n, dict1 = len(nums), defaultdict(int)\\n\\n        def dfs(i):\\n            total = 0\\n\\n            for j in range(i,n):\\n                if dict1[nums[j]+k] == 0 and dict1[nums[j]-k] == 0:\\n                    dict1[nums[j]] += 1\\n                    total += dfs(j+1) + 1\\n                    dict1[nums[j]] -= 1\\n\\n            return total \\n\\n        return dfs(0)\\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums, k):\\n        n, dict1 = len(nums), defaultdict(int)\\n\\n        def dfs(i):\\n            total = 0\\n\\n            for j in range(i,n):\\n                if dict1[nums[j]+k] == 0 and dict1[nums[j]-k] == 0:\\n                    dict1[nums[j]] += 1\\n                    total += dfs(j+1) + 1\\n                    dict1[nums[j]] -= 1\\n\\n            return total \\n\\n        return dfs(0)\\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316460,
                "title": "pure-backtracking-beats-30-7-simple-explanation",
                "content": "```\\nclass Solution\\n{\\n    void solve(vector<int> &nums, unordered_map<int, int> &map, int ind, int k, int &cnt)\\n    {\\n        if (ind >= nums.size())\\n        {\\n            cnt++;\\n            return;\\n        }\\n        if (!map[nums[ind] - k])\\n        {\\n            map[nums[ind]]++;\\n            solve(nums, map, ind + 1, k, cnt);   //Pick\\n            map[nums[ind]]--;\\n        }\\n        solve(nums, map, ind + 1, k, cnt);   //Not Pick\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k)\\n    {\\n        int ind = 0, cnt = 0;\\n        unordered_map<int, int> map;\\n\\t\\t\\n        sort(nums.begin(), nums.end());  // Sorting to check previous existence only \\n\\t\\t\\n        solve(nums, map, ind, k, cnt);\\n\\t\\t\\n        return cnt - 1;  // Subtracting one from cnt for null subset\\n    }\\n};\\n```\\n***UPVOTE IF FOUND HELPFUL :)***\\n**Any doubts type in comments**",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    void solve(vector<int> &nums, unordered_map<int, int> &map, int ind, int k, int &cnt)\\n    {\\n        if (ind >= nums.size())\\n        {\\n            cnt++;\\n            return;\\n        }\\n        if (!map[nums[ind] - k])\\n        {\\n            map[nums[ind]]++;\\n            solve(nums, map, ind + 1, k, cnt);   //Pick\\n            map[nums[ind]]--;\\n        }\\n        solve(nums, map, ind + 1, k, cnt);   //Not Pick\\n    }\\n\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k)\\n    {\\n        int ind = 0, cnt = 0;\\n        unordered_map<int, int> map;\\n\\t\\t\\n        sort(nums.begin(), nums.end());  // Sorting to check previous existence only \\n\\t\\t\\n        solve(nums, map, ind, k, cnt);\\n\\t\\t\\n        return cnt - 1;  // Subtracting one from cnt for null subset\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316324,
                "title": "complicated-recursion-formula-n-log-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe elements of the set can be partitioned into arithmetic progressions with step k (where some progressions may consist of just one element). The result is the product of the counts for each arithmetic progression, minus 1 to exclude the empty set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe number of beautiful subsets (including the empty one) in an arithmetic progression of length n and step k is the n-th Fibonacci number, because it satisfies the recursion formula for the Fibonacci sequence:\\n$x_n=x_{n-1}+x_{n-2}$, where $x_0=1$, $x_1=2$.\\nIndeed, in a beautiful subset:\\n* either the n-th term is not present, giving $x_{n-1}$\\n* or the n-th term is present, meaning the (n-1)-th term is excluded, giving $x_{n-2}$.\\n\\nHowever, this problem is not so simple, because each term in the arithmetic progression can appear more than once. For example, the progression can be 1, 2, 2, 3 and the second term, 2, appears twice.\\n\\nSuppose the n-th term has multiplicity $m_n$. Then the recursion formula above becomes\\n$x_n=x_{n-1}+x_{n-2} \\\\cdot (2^{m_n}-1)$, where $x_{-1}=1$, $x_0=1$.\\nAgain, there are two cases:\\n* either the n-th term is not present, giving $x_{n-1}$\\n* or the n-th term is present, meaning the (n-1)-th term is excluded, giving $x_{n-2}$. However, now the n-th term can appear in $2^{m_n}-1$ ways, because of multiplicity.\\n\\nThis is indeed the whole solution. The programming part can be improved (now it\\'s faster than 92%) and I may do it later.\\n\\nUpdate: By cleaning up the code I shaved off several milliseconds, from 57 to 48, and reduced the memory requirements too.\\n\\n\\n# Complexity\\n- Time complexity: $O(n \\\\log n)$ to identify the arithmetic progressions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nHere is a clean version of my previous code, which I\\'ll leave below for reference.\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        dct={}\\n        for n in nums:\\n            if n in dct:\\n                dct[n].append(n)\\n            elif n-k in dct:\\n                dct[n]=dct.pop(n-k)\\n                dct[n].append(n)\\n            else:\\n                dct[n]=[n]\\n        prod=1\\n        for lst in dct.values():\\n            fib1, fib2=1, 1\\n            i=0\\n            while i<len(lst):\\n                i0=i\\n                while i<len(lst) and lst[i]==lst[i0]:\\n                    i+=1\\n                fib1, fib2=fib2, fib2+(fib1<<(i-i0))-fib1\\n            prod*=fib2\\n        return prod-1\\n```\\nHere is the old version.\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        dct=defaultdict(list)\\n        for n in nums:\\n            flag=False\\n            for lst in dct.values():\\n                if n==lst[-1] or n-lst[-1]==k:\\n                    lst.append(n)\\n                    flag=True\\n                    break\\n            if not flag:\\n                dct[n]=[n]\\n        prod=1\\n        for lst in dct.values():\\n            fib=[0, 0]\\n            i=0\\n            while i<len(lst):\\n                i0=i\\n                while i<len(lst) and lst[i]==lst[i0]:\\n                    i+=1\\n                fib.append(fib[-1]+(fib[-2]+1)*((1<<(i-i0))-1))\\n            prod*=fib[-1]+1\\n        return prod-1      \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        dct={}\\n        for n in nums:\\n            if n in dct:\\n                dct[n].append(n)\\n            elif n-k in dct:\\n                dct[n]=dct.pop(n-k)\\n                dct[n].append(n)\\n            else:\\n                dct[n]=[n]\\n        prod=1\\n        for lst in dct.values():\\n            fib1, fib2=1, 1\\n            i=0\\n            while i<len(lst):\\n                i0=i\\n                while i<len(lst) and lst[i]==lst[i0]:\\n                    i+=1\\n                fib1, fib2=fib2, fib2+(fib1<<(i-i0))-fib1\\n            prod*=fib2\\n        return prod-1\\n```\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        dct=defaultdict(list)\\n        for n in nums:\\n            flag=False\\n            for lst in dct.values():\\n                if n==lst[-1] or n-lst[-1]==k:\\n                    lst.append(n)\\n                    flag=True\\n                    break\\n            if not flag:\\n                dct[n]=[n]\\n        prod=1\\n        for lst in dct.values():\\n            fib=[0, 0]\\n            i=0\\n            while i<len(lst):\\n                i0=i\\n                while i<len(lst) and lst[i]==lst[i0]:\\n                    i+=1\\n                fib.append(fib[-1]+(fib[-2]+1)*((1<<(i-i0))-1))\\n            prod*=fib[-1]+1\\n        return prod-1      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315657,
                "title": "easy-peasy-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution(object):\\n    def beautifulSubsets(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        n = len(nums)\\n        banned = set()\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if abs(nums[i] - nums[j]) == k:\\n                    ban = (1 << j) + (1 << i)\\n                    banned.add(ban)\\n                    \\n        for i in range(1, (1 << n)):\\n            s = set()\\n            flag = True\\n            for ban in banned:\\n                if (ban & i) == ban:\\n                    flag = False\\n            if flag:\\n                count += 1\\n        \\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def beautifulSubsets(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        n = len(nums)\\n        banned = set()\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                if abs(nums[i] - nums[j]) == k:\\n                    ban = (1 << j) + (1 << i)\\n                    banned.add(ban)\\n                    \\n        for i in range(1, (1 << n)):\\n            s = set()\\n            flag = True\\n            for ban in banned:\\n                if (ban & i) == ban:\\n                    flag = False\\n            if flag:\\n                count += 1\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315551,
                "title": "java-recursive-easy",
                "content": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] arr, int k) \\n    {\\n        Arrays.sort(arr);\\n        for(int e: arr) System.out.print(e+\" \");\\n        System.out.println();\\n        return subsets(0, -1, k, arr, new HashSet<>())-1;\\n    }\\n    public int subsets(int i, int prev_i, int k, int []arr, Set<Integer> set)\\n    {\\n        if(i==arr.length) return 1;\\n        int pick= 0;\\n        set.add(arr[i]);\\n        if(prev_i==-1 || !set.contains(arr[i]-k)) pick = subsets(i+1, i, k, arr, set);\\n        set.remove(arr[i]);\\n        int notPick = subsets(i+1, prev_i, k, arr, set);\\n        return pick + notPick;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] arr, int k) \\n    {\\n        Arrays.sort(arr);\\n        for(int e: arr) System.out.print(e+\" \");\\n        System.out.println();\\n        return subsets(0, -1, k, arr, new HashSet<>())-1;\\n    }\\n    public int subsets(int i, int prev_i, int k, int []arr, Set<Integer> set)\\n    {\\n        if(i==arr.length) return 1;\\n        int pick= 0;\\n        set.add(arr[i]);\\n        if(prev_i==-1 || !set.contains(arr[i]-k)) pick = subsets(i+1, i, k, arr, set);\\n        set.remove(arr[i]);\\n        int notPick = subsets(i+1, prev_i, k, arr, set);\\n        return pick + notPick;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315532,
                "title": "python-clear-short-backtracking-solution",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Code\\n```\\nclass Solution:\\n    def backtrack(self, arr, subset, k, count):\\n        for i in range(len(arr)):\\n            num = arr[i]\\n            if num+k not in subset and num-k not in subset:\\n                count[0] += 1\\n                subset.add(num)\\n                self.backtrack(arr[i+1:], subset, k, count)\\n                if num in subset:\\n                    subset.remove(num)\\n    \\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        count = [0]\\n        subset = set()\\n        self.backtrack(nums, subset, k, count)\\n        return count[0]\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def backtrack(self, arr, subset, k, count):\\n        for i in range(len(arr)):\\n            num = arr[i]\\n            if num+k not in subset and num-k not in subset:\\n                count[0] += 1\\n                subset.add(num)\\n                self.backtrack(arr[i+1:], subset, k, count)\\n                if num in subset:\\n                    subset.remove(num)\\n    \\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        count = [0]\\n        subset = set()\\n        self.backtrack(nums, subset, k, count)\\n        return count[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315077,
                "title": "simple-explanation",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int v[10005];//hash array to store the numbers\\n    int f(vector<int>&nums,int k,int i){\\n        if(i==nums.size())return 1;//one subset has been formed so return 1\\n\\n        int pick=0;//picking the current index element\\n        if((nums[i]-k<0) || v[nums[i]-k]==0){\\n           \\n            v[nums[i]]++;//incrementing the count\\n            pick=f(nums,k,i+1);\\n            v[nums[i]]--;//erasing the count of the earlier added element\\n\\n        }\\n        int notpick=f(nums,k,i+1);//not picking the current index \\n        return pick+notpick;\\n\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());//as relative order doesn\\'t matters in case of subsets\\n        memset(v,0,sizeof(v));\\n        int ans=f(nums,k,0);\\n        return ans-1;//subtracting one as we have included thr case of empty subset which is not allowed as per the question\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int v[10005];//hash array to store the numbers\\n    int f(vector<int>&nums,int k,int i){\\n        if(i==nums.size())return 1;//one subset has been formed so return 1\\n\\n        int pick=0;//picking the current index element\\n        if((nums[i]-k<0) || v[nums[i]-k]==0){\\n           \\n            v[nums[i]]++;//incrementing the count\\n            pick=f(nums,k,i+1);\\n            v[nums[i]]--;//erasing the count of the earlier added element\\n\\n        }\\n        int notpick=f(nums,k,i+1);//not picking the current index \\n        return pick+notpick;\\n\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());//as relative order doesn\\'t matters in case of subsets\\n        memset(v,0,sizeof(v));\\n        int ans=f(nums,k,0);\\n        return ans-1;//subtracting one as we have included thr case of empty subset which is not allowed as per the question\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314979,
                "title": "simple-dfs-solution-faster-than-30-brute-force-c",
                "content": "# Happy Coding\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& n, int k) {\\n        unordered_map<int,bool> s;\\n        return dfs(n,0,k,s);\\n    }\\n    int dfs(vector<int>& n,int i,int k,unordered_map<int,bool>& s){\\n        if(i==n.size()){\\n            return 0;\\n        }\\n        int x=dfs(n,i+1,k,s);\\n        int y=0;\\n        if(!s[n[i]+k] && !s[n[i]-k]){\\n            s[n[i]]=1;\\n            y = dfs(n,i+1,k,s)+1;\\n            s[n[i]]=0;\\n        }\\n        return x+y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& n, int k) {\\n        unordered_map<int,bool> s;\\n        return dfs(n,0,k,s);\\n    }\\n    int dfs(vector<int>& n,int i,int k,unordered_map<int,bool>& s){\\n        if(i==n.size()){\\n            return 0;\\n        }\\n        int x=dfs(n,i+1,k,s);\\n        int y=0;\\n        if(!s[n[i]+k] && !s[n[i]-k]){\\n            s[n[i]]=1;\\n            y = dfs(n,i+1,k,s)+1;\\n            s[n[i]]=0;\\n        }\\n        return x+y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314841,
                "title": "easiest-solution-in-java-using-taken-not-taken-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int map[];\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        map = new int[1003];\\n        \\n        return helper(0,k,nums)-1;\\n    }\\n    private int helper(int ind,int k,int[] nums){\\n        if (ind == nums.length) return 1;\\n\\n        int taken = 0;\\n        if ((nums[ind] - k) < 0 || (map[nums[ind]-k] == 0)){\\n            map[nums[ind]]++;\\n            taken = helper(ind+1,k,nums);\\n            map[nums[ind]]--;\\n        }\\n        int not_taken = helper(ind+1,k,nums);\\n        return taken + not_taken;\\n    }\\n   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    int map[];\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        map = new int[1003];\\n        \\n        return helper(0,k,nums)-1;\\n    }\\n    private int helper(int ind,int k,int[] nums){\\n        if (ind == nums.length) return 1;\\n\\n        int taken = 0;\\n        if ((nums[ind] - k) < 0 || (map[nums[ind]-k] == 0)){\\n            map[nums[ind]]++;\\n            taken = helper(ind+1,k,nums);\\n            map[nums[ind]]--;\\n        }\\n        int not_taken = helper(ind+1,k,nums);\\n        return taken + not_taken;\\n    }\\n   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314613,
                "title": "c-easiest-solution-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n        if(idx == nums.size()) ans++;\\n        else {\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int, int> mp;\\n        dfs(nums, 0, k, mp, ans);\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n        if(idx == nums.size()) ans++;\\n        else {\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = 0;\\n        unordered_map<int, int> mp;\\n        dfs(nums, 0, k, mp, ans);\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314509,
                "title": "bitmask-2-n-brute-force-with-extra-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe are sorting the array so that the bad index for current index i will lie on [0...i-1]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array. \\n2. Create 2D vector, where bad[i] contains the indices that are bad i.e a[j] + k == a[i]\\n3. Use the Bitmask to find all Subsets and check for their goodness.\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int beautifulSubsets(vector<int>& a, int k) {\\n        int n = a.size();\\n        int ans = 0;\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> bad(n);\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(a[i]-a[j]==k)\\n                    bad[i].push_back(j);\\n            }\\n        }\\n       \\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            bool good=1;\\n            for(int i=0;i<n && good;i++)\\n            {\\n                if((mask&(1<<i))>0) //Checking the set bit\\n                {\\n                    for(auto &x:bad[i])\\n                    {\\n                        if((mask&(1<<x))>0) //Checking if the bad index is set?\\n                            good=0;\\n                    }\\n                }   \\n            }\\n            if(good)\\n                ans++; \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int beautifulSubsets(vector<int>& a, int k) {\\n        int n = a.size();\\n        int ans = 0;\\n        sort(a.begin(),a.end());\\n        vector<vector<int>> bad(n);\\n        for(int i =0;i<n;i++){\\n            for(int j=0;j<=i;j++)\\n            {\\n                if(a[i]-a[j]==k)\\n                    bad[i].push_back(j);\\n            }\\n        }\\n       \\n        for(int mask=1;mask<(1<<n);mask++)\\n        {\\n            bool good=1;\\n            for(int i=0;i<n && good;i++)\\n            {\\n                if((mask&(1<<i))>0) //Checking the set bit\\n                {\\n                    for(auto &x:bad[i])\\n                    {\\n                        if((mask&(1<<x))>0) //Checking if the bad index is set?\\n                            good=0;\\n                    }\\n                }   \\n            }\\n            if(good)\\n                ans++; \\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314469,
                "title": "c-backtracking-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do the classic recursion to find the 2^n subset number.\\n// Which means choose or not choose the number into subset.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the array.\\n2. Use an unordered_map to check if the (nums[i] - k) exist or not.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn + 2^n) n means the size of vector<int> nums\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) both unordered_map and the depth of recursion there maxium is n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    unordered_map<int, int> rec;\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        ans = 0;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            rec[nums[i]]++;\\n            recursion(i+1, n, tmp, nums, k);\\n            rec[nums[i]]--;\\n        }\\n        return ans;\\n    }\\n    void recursion(int pos, int n, vector<int> &tmp, vector<int>& nums, int k) {\\n        if (pos == n) {\\n            ans++;\\n            return;\\n        }\\n\\n        // choose the number to the subset\\n        if (rec[nums[pos] - k] == 0) {\\n            rec[nums[pos]]++;\\n            recursion(pos + 1, n, tmp, nums, k);\\n            rec[nums[pos]]--;\\n        }   \\n\\n        // skip the number to the subset\\n        recursion(pos + 1, n, tmp, nums, k);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    unordered_map<int, int> rec;\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        ans = 0;\\n        vector<int> tmp;\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            rec[nums[i]]++;\\n            recursion(i+1, n, tmp, nums, k);\\n            rec[nums[i]]--;\\n        }\\n        return ans;\\n    }\\n    void recursion(int pos, int n, vector<int> &tmp, vector<int>& nums, int k) {\\n        if (pos == n) {\\n            ans++;\\n            return;\\n        }\\n\\n        // choose the number to the subset\\n        if (rec[nums[pos] - k] == 0) {\\n            rec[nums[pos]]++;\\n            recursion(pos + 1, n, tmp, nums, k);\\n            rec[nums[pos]]--;\\n        }   \\n\\n        // skip the number to the subset\\n        recursion(pos + 1, n, tmp, nums, k);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314286,
                "title": "java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        int n = nums.length;\\n        return dfs(nums, k, seen, n, 0) - 1;\\n    }\\n    \\n    private int dfs(int[] nums, int k, Map<Integer, Integer> seen, int n, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int res = 0;\\n        if (seen.getOrDefault(nums[i] - k, 0) == 0) {\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n            res += dfs(nums, k, seen, n, i + 1);\\n            seen.put(nums[i], seen.get(nums[i]) - 1);\\n        }\\n        res += dfs(nums, k, seen, n, i + 1);\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        int n = nums.length;\\n        return dfs(nums, k, seen, n, 0) - 1;\\n    }\\n    \\n    private int dfs(int[] nums, int k, Map<Integer, Integer> seen, int n, int i) {\\n        if (i == n) {\\n            return 1;\\n        }\\n        int res = 0;\\n        if (seen.getOrDefault(nums[i] - k, 0) == 0) {\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n            res += dfs(nums, k, seen, n, i + 1);\\n            seen.put(nums[i], seen.get(nums[i]) - 1);\\n        }\\n        res += dfs(nums, k, seen, n, i + 1);\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314281,
                "title": "need-help-why-it-is-giving-tle-on-last-test-case",
                "content": "!!!Need Help why it is giving TLE on last test case\\npassing all the  test cases but i dont know what is the last test case due to that it is giving TLE if anyOne knows kinldy tell me \\n![Screenshot from 2023-03-19 09-48-31.png](https://assets.leetcode.com/users/images/6ec68310-0676-46ca-b9b1-1c3fbdc3ce9c_1679199538.1896174.png)\\n\\ncode\\n\\n``\\nclass Solution {\\n    List<int []> l1;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length==1){\\n            return 1;\\n        }\\n        if(nums.length==0){\\n            return 0;\\n        }\\n        l1=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(Math.abs(nums[i]-nums[j])==k){\\n                    l1.add(new int[]{nums[i],nums[j]});\\n                }\\n            }\\n        }\\n        return rec(nums,0,new ArrayList<>(),k)-1;\\n    }\\n    public int rec(int nums[],int i,List<Integer> l,int k){\\n        \\n        if(i>=nums.length){\\n            if(isOk(l,k)||l.size()==1){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int t=rec(nums,i+1,l,k);\\n        l.add(nums[i]);\\n        int n=rec(nums,i+1,l,k);\\n        l.remove(l.size()-1);\\n        return t+n;\\n    }\\n    public boolean isOk(List<Integer> l,int k){\\n        for(int i[]:l1){\\n            if(l.contains(i[0])&&l.contains(i[1])){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n``\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    List<int []> l1;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length==1){\\n            return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3314039,
                "title": "python-sorting-subset-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        n = len(nums)\\n        seen = set()\\n        nums.sort()\\n        \\n        def dfs(subset, ind, s):\\n            nonlocal res\\n            if ind >= n:\\n                res+=1 if len(subset)>0 else 0\\n                return\\n            \\n            if nums[ind]-k not in seen:\\n                subset.append(nums[ind])\\n                seen.add(nums[ind])\\n                dfs(subset, ind+1, s+nums[ind])\\n                subset.pop()\\n                seen.discard(nums[ind])\\n            dfs(subset, ind+1, s)\\n        dfs([], 0, 0)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        res = 0\\n        n = len(nums)\\n        seen = set()\\n        nums.sort()\\n        \\n        def dfs(subset, ind, s):\\n            nonlocal res\\n            if ind >= n:\\n                res+=1 if len(subset)>0 else 0\\n                return\\n            \\n            if nums[ind]-k not in seen:\\n                subset.append(nums[ind])\\n                seen.add(nums[ind])\\n                dfs(subset, ind+1, s+nums[ind])\\n                subset.pop()\\n                seen.discard(nums[ind])\\n            dfs(subset, ind+1, s)\\n        dfs([], 0, 0)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314031,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ans=0\\n        def backtrack(idx,count,items):\\n            nonlocal ans,n,nums\\n            if idx==n:\\n                if items>0:\\n                    ans+=1\\n                return\\n            if count[nums[idx]-k]==0:\\n                count[nums[idx]]+=1\\n                backtrack(idx+1,count,items+1)\\n                count[nums[idx]]-=1\\n            backtrack(idx+1,count,items)\\n        backtrack(0,defaultdict(int),0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n=len(nums)\\n        ans=0\\n        def backtrack(idx,count,items):\\n            nonlocal ans,n,nums\\n            if idx==n:\\n                if items>0:\\n                    ans+=1\\n                return\\n            if count[nums[idx]-k]==0:\\n                count[nums[idx]]+=1\\n                backtrack(idx+1,count,items+1)\\n                count[nums[idx]]-=1\\n            backtrack(idx+1,count,items)\\n        backtrack(0,defaultdict(int),0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314028,
                "title": "sorting-preprocessing-dfs-speed-up-dfs-to-squeeze-by-weird-time-cutoff",
                "content": "Given n <= 20, iterating all possible subsets and checking for violations seem reasonable, but checking each pair for every subset results in a complexity of O(2^n * n ^ 2). Which TLE\\'s when n == 19.\\n\\nSubsequently, we might instead try DFS, which not only prunes many incorrect subsets, when adding an element to existing valid subset, we only need to check up to n other elements. Which has complexity  O(2^n * n), which TLE\\'s when n == 20.\\n\\nLastly, we can take advantage of the property of difference, using sorting and preprocessing to achieve near constant time when adding new elements to a valid subset. O(2^n * max banned range). \\nThe given testsets seem to have all unique values which means that max banned range == 1. O(2^n) passes all test cases\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        banned_range = []\\n        n = len(nums)\\n        for i in range(len(nums)):\\n            l = 100\\n            r = -1\\n            for j in range(0,i):\\n                if nums[i] == nums[j] + k:\\n                    l = min(l,j)\\n                    r = max(r,j)\\n            banned_range.append([l,r])\\n        \\n        tot = [0]\\n        def dfs(l):\\n            if n == len(l):\\n                return\\n            else:\\n                left,right = banned_range[len(l)]\\n                if not any(l[left:right + 1]):\\n                    tot[0] += 1\\n                    dfs(l + [True])         \\n                dfs(l + [False])\\n        dfs([])\\n        return tot[0] \\n                    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        banned_range = []\\n        n = len(nums)\\n        for i in range(len(nums)):\\n            l = 100\\n            r = -1\\n            for j in range(0,i):\\n                if nums[i] == nums[j] + k:\\n                    l = min(l,j)\\n                    r = max(r,j)\\n            banned_range.append([l,r])\\n        \\n        tot = [0]\\n        def dfs(l):\\n            if n == len(l):\\n                return\\n            else:\\n                left,right = banned_range[len(l)]\\n                if not any(l[left:right + 1]):\\n                    tot[0] += 1\\n                    dfs(l + [True])         \\n                dfs(l + [False])\\n        dfs([])\\n        return tot[0] \\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3314000,
                "title": "c-bit-mask-iteration-over-all-sub-sets-with-explanation",
                "content": "# Intuition\\nIterate over all possible sub-sets encoded as bit-mask.\\nOn each iteration, parse the bit-mask: those bits which have value `1` correspond to \\'included\\' item into a set.\\nWhen iterating over \\'included\\' values populate \\'values_to_avoid\\' array (represented as a vector of bools) with \\'val+k\\' and \\'val-k\\'.\\nIf current value is present in \\'values_to_avoid\\', immediately break current iteration, discarding this sub-set.\\nOtherwise, if all items are acceptable, increase the `count` which serves as an answer.\\n\\n**Note:** In the solution we utilize problem constraints:\\n1. Since input array contains max 20 elements, we can represent a sub-set as a bit-mask of length n (thus outer loop simply iterates over all values from 1 to 2^n-1).\\n2. Since values do not exceed 1000, we can represent a set of values to avoid as a vector of bools (also a bit-mask): `values_to_avoid` where each element tells whether current value is present in a set of values to avoid.\\n\\n# Time complexity\\nO(2^n) where n is the number of input elements.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int full_set = (1<<n)-1;\\n        int count = 0;\\n        vector<bool> values_to_avoid(1001, false);\\n        for(int j = 1; j<=full_set; ++j) {\\n            int x = j;\\n            std::fill(values_to_avoid.begin(), values_to_avoid.end(), false);\\n            int i = 0;\\n            while(x) {\\n                if(x%2==1) {\\n                    int val = nums[i];\\n                    if(values_to_avoid[val]) {\\n                        break;\\n                    }\\n                    if(val+k <= 1000) {\\n                        values_to_avoid[val+k] = true;\\n                    }\\n                    if(val-k >= 0) {\\n                        values_to_avoid[val-k] = true;\\n                    }\\n                }\\n                x/=2;\\n                ++i;\\n            }\\n            if(x == 0) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        int full_set = (1<<n)-1;\\n        int count = 0;\\n        vector<bool> values_to_avoid(1001, false);\\n        for(int j = 1; j<=full_set; ++j) {\\n            int x = j;\\n            std::fill(values_to_avoid.begin(), values_to_avoid.end(), false);\\n            int i = 0;\\n            while(x) {\\n                if(x%2==1) {\\n                    int val = nums[i];\\n                    if(values_to_avoid[val]) {\\n                        break;\\n                    }\\n                    if(val+k <= 1000) {\\n                        values_to_avoid[val+k] = true;\\n                    }\\n                    if(val-k >= 0) {\\n                        values_to_avoid[val-k] = true;\\n                    }\\n                }\\n                x/=2;\\n                ++i;\\n            }\\n            if(x == 0) count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099820,
                "title": "make-subsequence-and-check",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) \\n    {\\n        //trying the brute force aaproch\\n        int idx = 0;\\n        vector<int>v;\\n        return fun(idx,nums,k,v);    \\n    }\\n    int fun(int idx,vector<int>&nums,int &k,vector<int>&v)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            if(v.size() == 0)\\n            return 0;\\n            else\\n            return 1;\\n        }\\n\\n        int choise1 = 0;\\n        int choise2 = 0;\\n        //take choise1 only if the conditin satisfy\\n        bool flag = true;\\n        for(int i = 0 ; i < v.size() ; i++)        \\n        {\\n            if(abs(v[i]-nums[idx]) == k)\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        if(flag == true)\\n        {\\n            v.push_back(nums[idx]);\\n            choise1 = fun(idx+1,nums,k,v);\\n            v.pop_back();\\n        }\\n        choise2 = fun(idx+1,nums,k,v);\\n        return choise1+choise2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) \\n    {\\n        //trying the brute force aaproch\\n        int idx = 0;\\n        vector<int>v;\\n        return fun(idx,nums,k,v);    \\n    }\\n    int fun(int idx,vector<int>&nums,int &k,vector<int>&v)\\n    {\\n        if(idx >= nums.size())\\n        {\\n            if(v.size() == 0)\\n            return 0;\\n            else\\n            return 1;\\n        }\\n\\n        int choise1 = 0;\\n        int choise2 = 0;\\n        //take choise1 only if the conditin satisfy\\n        bool flag = true;\\n        for(int i = 0 ; i < v.size() ; i++)        \\n        {\\n            if(abs(v[i]-nums[idx]) == k)\\n            {\\n                flag = false;\\n                break;\\n            }\\n        }\\n\\n        if(flag == true)\\n        {\\n            v.push_back(nums[idx]);\\n            choise1 = fun(idx+1,nums,k,v);\\n            v.pop_back();\\n        }\\n        choise2 = fun(idx+1,nums,k,v);\\n        return choise1+choise2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4099813,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int>temp;\\n        return fun(nums,0,temp,k);\\n    }\\n    int fun(vector<int>&nums,int i,vector<int>&temp,int &k)\\n    {\\n        if(i>=nums.size())\\n        {\\n            return 0;\\n        }\\n        int c1=0,c2=0;\\n        if(isvalid(temp,nums[i],k))\\n        {\\n            temp.push_back(nums[i]);\\n            c1=1+fun(nums,i+1,temp,k);\\n            temp.pop_back();\\n        }\\n        c2=fun(nums,i+1,temp,k);\\n        return c1+c2;\\n    }\\n    bool isvalid(vector<int>&v,int a,int k)\\n    {\\n        if(v.size()==0)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(abs(v[i]-a)==k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int>temp;\\n        return fun(nums,0,temp,k);\\n    }\\n    int fun(vector<int>&nums,int i,vector<int>&temp,int &k)\\n    {\\n        if(i>=nums.size())\\n        {\\n            return 0;\\n        }\\n        int c1=0,c2=0;\\n        if(isvalid(temp,nums[i],k))\\n        {\\n            temp.push_back(nums[i]);\\n            c1=1+fun(nums,i+1,temp,k);\\n            temp.pop_back();\\n        }\\n        c2=fun(nums,i+1,temp,k);\\n        return c1+c2;\\n    }\\n    bool isvalid(vector<int>&v,int a,int k)\\n    {\\n        if(v.size()==0)\\n        {\\n            return true;\\n        }\\n        for(int i=0;i<v.size();i++)\\n        {\\n            if(abs(v[i]-a)==k)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094704,
                "title": "python-very-tricky-fibonacci",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nVery similar to LeetCode 2638  Count the Number of K-Free Subsets, but even more tricky.\\n1. Sort the nums list, and group the \"adjacent\" number together with the duplicates.\\n2. For each group, multiple the number of valid subsets gradually.\\n\\nHere comes the question on how to calculate the number of valid subsets for each group. In LeetCode 2638 it\\'s simply $x_n = x_{n-1} + x_{n-2}$, but here it\\'s different because of the duplicates. Image that we add 5 duplicated number to one group, the number of valid subsets are:\\n1. $x_{n-1} + x_{n-2} * (2^5 - 1)$;\\n2. So the general case is $x_n = x_{n-1} + x_{n-2} * (2^{count} - 1)$.\\n3. When count = 1, it\\'s equivalent to the simpler case in LeetCode 2638.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        groups = defaultdict(list)\\n\\n        for num in nums:\\n            if num in groups:\\n                groups[num].append(num)\\n            elif num - k in groups:\\n                groups[num] = groups.pop(num - k)\\n                groups[num].append(num)\\n            else:\\n                groups[num].append(num)\\n        \\n        res = 1\\n        for group in groups.values():\\n            fib1, fib2 = 1, 1\\n            i = 0\\n            while i < len(group):\\n                start = i\\n                while i < len(group) and group[i] == group[start]:\\n                    i += 1\\n                count = i - start\\n                fib1, fib2 = fib2, fib2 + (fib1 << count) - fib1\\n            \\n            res *= fib2\\n        \\n        return res - 1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        groups = defaultdict(list)\\n\\n        for num in nums:\\n            if num in groups:\\n                groups[num].append(num)\\n            elif num - k in groups:\\n                groups[num] = groups.pop(num - k)\\n                groups[num].append(num)\\n            else:\\n                groups[num].append(num)\\n        \\n        res = 1\\n        for group in groups.values():\\n            fib1, fib2 = 1, 1\\n            i = 0\\n            while i < len(group):\\n                start = i\\n                while i < len(group) and group[i] == group[start]:\\n                    i += 1\\n                count = i - start\\n                fib1, fib2 = fib2, fib2 + (fib1 << count) - fib1\\n            \\n            res *= fib2\\n        \\n        return res - 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062287,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int k,int x){\\n        for(int i = 0;i < arr.size();i++)\\n            if(abs(arr[i] - x) == k)\\n                return false;\\n        return true;\\n    }\\n    int solve(vector<int>& nums,int k,int i,vector<int>& arr){\\n        if(i == nums.size())\\n            return 1;\\n        int ans = 0;\\n        if(check(arr,k,nums[i])){\\n            arr.push_back(nums[i]);\\n            ans = solve(nums,k,i+1,arr);\\n            arr.pop_back();\\n        }\\n        ans += solve(nums,k,i+1,arr);\\n        return ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> arr;\\n        return solve(nums,k,0,arr) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int>& arr,int k,int x){\\n        for(int i = 0;i < arr.size();i++)\\n            if(abs(arr[i] - x) == k)\\n                return false;\\n        return true;\\n    }\\n    int solve(vector<int>& nums,int k,int i,vector<int>& arr){\\n        if(i == nums.size())\\n            return 1;\\n        int ans = 0;\\n        if(check(arr,k,nums[i])){\\n            arr.push_back(nums[i]);\\n            ans = solve(nums,k,i+1,arr);\\n            arr.pop_back();\\n        }\\n        ans += solve(nums,k,i+1,arr);\\n        return ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> arr;\\n        return solve(nums,k,0,arr) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4023574,
                "title": "python-o-nlogn-time-complexity-beats-85-06-in-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConsider the example nums = [2, 4, 6, 7, 9] with k = 2. We can split nums into k groups depending on their remainder when divided by k. \\n\\nWe get groups [2, 4, 6] and [7, 9]. Note that the answer is the number of ways to choose beautiful (possibly empty) subgroups in [2, 4, 6] times that in [7, 9] minus 1 (to account for empty subset).  \\n\\nThis is because choosing any of [2, 4, 6] does not affect what you can choose in [7, 9], because they have different remainders mod k, and thus elements from different groups will never differ by k!\\n\\nNow then finding out the number of ways to choose in [2, 4, 6] and [7, 9] is just pretty much a variation of the DP question https://leetcode.com/problems/house-robber/, except that there may be duplicates and we have to account for that accordingly... this is done in the function getComb().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(n))\\n    Sorting in getBeau() brings it up to nlog(n) since the groups are sorted. Everything else is O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        groups = [[] for i in range(k)]\\n        for num in nums:\\n            groups[num%k].append(num)\\n\\n        print(f\\'groups = {groups}\\')\\n\\n        def getBeau(group):\\n            if group == []:\\n                return 1\\n            group = sorted(group)\\n            group.append(group[-1]+2*k) #padding\\n            prev = 0\\n            ret = 1\\n            for i in range(len(group)-1):\\n                if group[i] + k < group[i+1]:\\n                    ret *= getComb(group[prev:i+1])\\n                    prev = i+1\\n            return ret\\n\\n        def getComb(subgroup):\\n            subgroupDict = {i: subgroup.count(i) for i in subgroup}\\n            #print(subgroupDict)\\n            n = len(list(subgroupDict.keys()))\\n            dp = [None for i in range(n+1)]\\n\\n            elem = subgroup[0]\\n            dp[0] = 1\\n            dp[1] = 2**subgroupDict[elem]\\n            elem += k\\n            for i in range(2, n+1):\\n                dp[i] = dp[i-1] + dp[i-2]*(2**subgroupDict[elem]-1)\\n                elem += k\\n            #print(dp)\\n            return dp[n]\\n\\n        ret = 1\\n        for group in groups:\\n            ret *= getBeau(group)\\n        return ret-1\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        groups = [[] for i in range(k)]\\n        for num in nums:\\n            groups[num%k].append(num)\\n\\n        print(f\\'groups = {groups}\\')\\n\\n        def getBeau(group):\\n            if group == []:\\n                return 1\\n            group = sorted(group)\\n            group.append(group[-1]+2*k) #padding\\n            prev = 0\\n            ret = 1\\n            for i in range(len(group)-1):\\n                if group[i] + k < group[i+1]:\\n                    ret *= getComb(group[prev:i+1])\\n                    prev = i+1\\n            return ret\\n\\n        def getComb(subgroup):\\n            subgroupDict = {i: subgroup.count(i) for i in subgroup}\\n            #print(subgroupDict)\\n            n = len(list(subgroupDict.keys()))\\n            dp = [None for i in range(n+1)]\\n\\n            elem = subgroup[0]\\n            dp[0] = 1\\n            dp[1] = 2**subgroupDict[elem]\\n            elem += k\\n            for i in range(2, n+1):\\n                dp[i] = dp[i-1] + dp[i-2]*(2**subgroupDict[elem]-1)\\n                elem += k\\n            #print(dp)\\n            return dp[n]\\n\\n        ret = 1\\n        for group in groups:\\n            ret *= getBeau(group)\\n        return ret-1\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022955,
                "title": "backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>&nums,map<int,int>&vis, int k, int idx, int l){\\n        if(idx == nums.size()){\\n            if(l >0)\\n            return 1;\\n            else return 0;\\n        }\\n        int take = 0;\\n        int skip = 0;\\n        if(vis[nums[idx]-k] == 0){\\n            vis[nums[idx]] ++;\\n            take = solve(nums,vis,k,idx+1,l+1);\\n            vis[nums[idx]] --;\\n        }\\n        skip = solve(nums,vis,k,idx+1,l);\\n        return take+skip;\\n    }\\n    /*\\n    1\\n    1\\n    2\\n    3\\n    1 1\\n    1 3\\n    1 3\\n    1 1 3 \\n    */\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        map<int,int>vis;\\n        return solve(nums,vis,k,0,0);\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>&nums,map<int,int>&vis, int k, int idx, int l){\\n        if(idx == nums.size()){\\n            if(l >0)\\n            return 1;\\n            else return 0;\\n        }\\n        int take = 0;\\n        int skip = 0;\\n        if(vis[nums[idx]-k] == 0){\\n            vis[nums[idx]] ++;\\n            take = solve(nums,vis,k,idx+1,l+1);\\n            vis[nums[idx]] --;\\n        }\\n        skip = solve(nums,vis,k,idx+1,l);\\n        return take+skip;\\n    }\\n    /*\\n    1\\n    1\\n    2\\n    3\\n    1 1\\n    1 3\\n    1 3\\n    1 1 3 \\n    */\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        map<int,int>vis;\\n        return solve(nums,vis,k,0,0);\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002075,
                "title": "golang-brute-force-solution",
                "content": "# Code\\n```go\\nfunc beautifulSubsets(nums []int, k int) int {\\n\\tcounter := make([]int, 1001)\\n\\tresult := 0\\n\\tbsHelper(nums, counter, k, &result)\\n\\treturn result\\n}\\n\\nfunc bsHelper(nums []int, counter []int, k int, result *int) {\\n\\tif len(nums) == 0 {\\n\\t\\treturn\\n\\t}\\n\\tif !has(counter, nums[0] + k) && !has(counter, nums[0] - k) {\\n\\t\\t*result = *result + 1\\n\\t\\tcounter[nums[0]]++\\n\\t\\tbsHelper(nums[1:], counter, k, result)\\n\\t\\tcounter[nums[0]]--\\n\\t}\\n\\tbsHelper(nums[1:], counter, k, result)\\n}\\n\\nfunc has(counter []int, val int) bool {\\n\\tif val > 1000 || val < 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn counter[val] > 0\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc beautifulSubsets(nums []int, k int) int {\\n\\tcounter := make([]int, 1001)\\n\\tresult := 0\\n\\tbsHelper(nums, counter, k, &result)\\n\\treturn result\\n}\\n\\nfunc bsHelper(nums []int, counter []int, k int, result *int) {\\n\\tif len(nums) == 0 {\\n\\t\\treturn\\n\\t}\\n\\tif !has(counter, nums[0] + k) && !has(counter, nums[0] - k) {\\n\\t\\t*result = *result + 1\\n\\t\\tcounter[nums[0]]++\\n\\t\\tbsHelper(nums[1:], counter, k, result)\\n\\t\\tcounter[nums[0]]--\\n\\t}\\n\\tbsHelper(nums[1:], counter, k, result)\\n}\\n\\nfunc has(counter []int, val int) bool {\\n\\tif val > 1000 || val < 1 {\\n\\t\\treturn false\\n\\t}\\n\\treturn counter[val] > 0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3926023,
                "title": "c-backtracking-simple-take-not-take-detailed-explanation",
                "content": "# Explanation\\n\\n![image.png](https://assets.leetcode.com/users/images/d8a3f888-a0e2-4237-9bac-1c5963baea34_1692346908.308582.png)\\n![image.png](https://assets.leetcode.com/users/images/f34bf987-3930-456f-a8dc-0fd5879796a7_1692346915.9082508.png)\\n![image.png](https://assets.leetcode.com/users/images/ebc423b3-dc71-4ff6-bcec-9cd52f144e6f_1692346948.5512059.png)\\n![image.png](https://assets.leetcode.com/users/images/551e21b0-a0c1-4e50-824a-cbc9293aefaf_1692346973.0115361.png)\\n![image.png](https://assets.leetcode.com/users/images/78de58d7-c226-4d49-b2a4-454ec62a4757_1692346992.214744.png)\\n![image.png](https://assets.leetcode.com/users/images/c8ab6c60-adf5-4a12-8c94-eca866ff9cdc_1692347899.7747571.png)\\n![image.png](https://assets.leetcode.com/users/images/0f6be769-f24f-4b1f-897e-209f8c639ca6_1692347975.8818643.png)\\n![image.png](https://assets.leetcode.com/users/images/491acd00-fb6a-4c7d-acac-0ad8894836d8_1692347986.9921937.png)\\n![image.png](https://assets.leetcode.com/users/images/20c9564c-98f5-4dde-90ac-3b1a47e2d66f_1692348001.4688044.png)\\n\\n\\n# Complexity\\n- Time complexity:$$O(2^n*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool canBeTaken(int i , int k , int taken , vector<int> &nums)\\n    {\\n        int curr = nums[i];\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(taken & (1<<i))\\n            {\\n                if(nums[i] + k == curr || nums[i] - k == curr) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int solve(int i, int k , vector<int> &nums , int &taken)\\n    {\\n        if(i == nums.size())\\n        {\\n            return taken > 0 ? 1 : 0;\\n        }\\n        int pick = 0;\\n        if(canBeTaken(i,k,taken,nums))\\n        {\\n            taken |= (1<<i);\\n            pick = solve(i+1,k,nums,taken);\\n            taken ^= (1<<i);\\n        } \\n        int notPick = solve(i+1,k,nums,taken);\\n        return pick + notPick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int takenTrack = 0;\\n        return solve(0,k,nums,takenTrack);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool canBeTaken(int i , int k , int taken , vector<int> &nums)\\n    {\\n        int curr = nums[i];\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(taken & (1<<i))\\n            {\\n                if(nums[i] + k == curr || nums[i] - k == curr) return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    int solve(int i, int k , vector<int> &nums , int &taken)\\n    {\\n        if(i == nums.size())\\n        {\\n            return taken > 0 ? 1 : 0;\\n        }\\n        int pick = 0;\\n        if(canBeTaken(i,k,taken,nums))\\n        {\\n            taken |= (1<<i);\\n            pick = solve(i+1,k,nums,taken);\\n            taken ^= (1<<i);\\n        } \\n        int notPick = solve(i+1,k,nums,taken);\\n        return pick + notPick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int takenTrack = 0;\\n        return solve(0,k,nums,takenTrack);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860279,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can keep track of the numbers we have put in our subset so far in a dictionary, and for each new number, we can check if that number plus or minus k is already in our subset. We are using a dictionary because we can pick more than one of the same element. \\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n\\n        def dfs(i, have):\\n            count = 1\\n            for j in range(i + 1, len(nums)):\\n                if nums[j] - k in have or nums[j] + k in have:\\n                    continue\\n                have[nums[j]] = have.get(nums[j], 0) + 1\\n                count += dfs(j, have)\\n                have[nums[j]] -= 1 # backtrack\\n                if have[nums[j]] == 0:\\n                    del have[nums[j]]\\n            return count\\n\\n        result = 0\\n        # calculate the number of subsets starting from each index\\n        for i, n in enumerate(nums):\\n            result += dfs(i, {n: 1})\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n\\n        def dfs(i, have):\\n            count = 1\\n            for j in range(i + 1, len(nums)):\\n                if nums[j] - k in have or nums[j] + k in have:\\n                    continue\\n                have[nums[j]] = have.get(nums[j], 0) + 1\\n                count += dfs(j, have)\\n                have[nums[j]] -= 1 # backtrack\\n                if have[nums[j]] == 0:\\n                    del have[nums[j]]\\n            return count\\n\\n        result = 0\\n        # calculate the number of subsets starting from each index\\n        for i, n in enumerate(nums):\\n            result += dfs(i, {n: 1})\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831625,
                "title": "simple-take-and-non-take",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int k ,vector<int>&nums,unordered_map<int,int>&m)\\n    {\\n        if(i==nums.size())return 1;  /// Base case\\n        \\n        int c=0;\\n\\n        c+=solve(i+1,k,nums,m);/// if I non_take\\n\\n        if(m[nums[i]-k]==0)///if nums[i]-k not present the we take\\n        {\\n            m[nums[i]]=1;\\n            c+=solve(i+1,k,nums,m);/// take\\n            m[nums[i]]=0;\\n        }\\n        return   c; /// we return Total\\n    }\\n     \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>m;\\n\\n        return  solve(0,k,nums,m)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int k ,vector<int>&nums,unordered_map<int,int>&m)\\n    {\\n        if(i==nums.size())return 1;  /// Base case\\n        \\n        int c=0;\\n\\n        c+=solve(i+1,k,nums,m);/// if I non_take\\n\\n        if(m[nums[i]-k]==0)///if nums[i]-k not present the we take\\n        {\\n            m[nums[i]]=1;\\n            c+=solve(i+1,k,nums,m);/// take\\n            m[nums[i]]=0;\\n        }\\n        return   c; /// we return Total\\n    }\\n     \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>m;\\n\\n        return  solve(0,k,nums,m)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829712,
                "title": "python-and-c-medium",
                "content": "python:\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        6!\\n\\n        [2, 4, 6]\\n\\n        2, 4, 6, 2 6\\n\\n\\n\\n        [2, 4, 6, 7]\\n\\n        2, 4, 6, 7, 2 6, 2 6 7, 2 7, 47, 67\\n\\n\\n        \\n        \\'\\'\\'\\n        \\n\\n        def backTrack(index, lookup):\\n            if index == len(nums):\\n                if max(lookup.values()) > 0:\\n                    return 1\\n\\n                return 0\\n\\n            best = 0\\n\\n            if not lookup[nums[index] - k]:\\n                lookup[nums[index]] += 1\\n                best += backTrack(index + 1, lookup)\\n                lookup[nums[index]] -= 1\\n\\n            best += backTrack(index + 1, lookup)\\n\\n            return best\\n\\n\\n        nums.sort()\\n        return backTrack(0, defaultdict(int))\\n        \\n```\\nc++ \\n```\\nclass Solution {\\npublic:\\n    int backTrack(vector<int>& nums, int k, int index, map<int, int> & lookup) {\\n        if (index == nums.size()) {\\n            for (auto a: lookup)  {\\n                if (a.second != 0 ) {\\n                    return 1;\\n                }\\n            }\\n        return 0;\\n    }\\n        \\n      int best = 0;\\n        \\n      if (!lookup[nums[index] - k]) {\\n          ++lookup[nums[index]];\\n          best += backTrack(nums, k, index + 1, lookup);\\n          --lookup[nums[index]];\\n      }\\n\\n        best += backTrack(nums, k, index + 1, lookup);\\n        \\n        return best;\\n        \\n    }\\n    \\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        /*\\n        \\n        some type of map with pref sum\\n        or could be 2 ^ len(nums) complexity\\n        choosing and not choosing\\n        \\n        if current num - k not in hash\\n        \\n        \\n        */\\n        \\n        sort(nums.begin(), nums.end());\\n        map<int, int> lookup;\\n        return backTrack(nums, k, 0, lookup);\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        \\'\\'\\'\\n        6!\\n\\n        [2, 4, 6]\\n\\n        2, 4, 6, 2 6\\n\\n\\n\\n        [2, 4, 6, 7]\\n\\n        2, 4, 6, 7, 2 6, 2 6 7, 2 7, 47, 67\\n\\n\\n        \\n        \\'\\'\\'\\n        \\n\\n        def backTrack(index, lookup):\\n            if index == len(nums):\\n                if max(lookup.values()) > 0:\\n                    return 1\\n\\n                return 0\\n\\n            best = 0\\n\\n            if not lookup[nums[index] - k]:\\n                lookup[nums[index]] += 1\\n                best += backTrack(index + 1, lookup)\\n                lookup[nums[index]] -= 1\\n\\n            best += backTrack(index + 1, lookup)\\n\\n            return best\\n\\n\\n        nums.sort()\\n        return backTrack(0, defaultdict(int))\\n        \\n```\n```\\nclass Solution {\\npublic:\\n    int backTrack(vector<int>& nums, int k, int index, map<int, int> & lookup) {\\n        if (index == nums.size()) {\\n            for (auto a: lookup)  {\\n                if (a.second != 0 ) {\\n                    return 1;\\n                }\\n            }\\n        return 0;\\n    }\\n        \\n      int best = 0;\\n        \\n      if (!lookup[nums[index] - k]) {\\n          ++lookup[nums[index]];\\n          best += backTrack(nums, k, index + 1, lookup);\\n          --lookup[nums[index]];\\n      }\\n\\n        best += backTrack(nums, k, index + 1, lookup);\\n        \\n        return best;\\n        \\n    }\\n    \\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        /*\\n        \\n        some type of map with pref sum\\n        or could be 2 ^ len(nums) complexity\\n        choosing and not choosing\\n        \\n        if current num - k not in hash\\n        \\n        \\n        */\\n        \\n        sort(nums.begin(), nums.end());\\n        map<int, int> lookup;\\n        return backTrack(nums, k, 0, lookup);\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780111,
                "title": "simple-backtracking-beats-98-54-memory-and-beats-87-26-runtime",
                "content": "\\n```\\nclass Solution {\\nint vis[2001];\\nprivate:\\n    int f(int indx,int n,int k,vector<int> &nums){\\n\\n\\n        if(indx>=n)\\n            return 1;\\n\\n        int a=0;\\n        if(!vis[nums[indx]]){\\n          \\n            vis[nums[indx]+k]++;\\n            a=f(indx+1,n,k,nums);\\n            vis[nums[indx]+k]--;\\n\\n        }\\n        int b=f(indx+1,n,k,nums);\\n        return a+b;    \\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        memset(vis,0,sizeof(vis));\\n        return f(0,n,k,nums)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nint vis[2001];\\nprivate:\\n    int f(int indx,int n,int k,vector<int> &nums){\\n\\n\\n        if(indx>=n)\\n            return 1;\\n\\n        int a=0;\\n        if(!vis[nums[indx]]){\\n          \\n            vis[nums[indx]+k]++;\\n            a=f(indx+1,n,k,nums);\\n            vis[nums[indx]+k]--;\\n\\n        }\\n        int b=f(indx+1,n,k,nums);\\n        return a+b;    \\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        memset(vis,0,sizeof(vis));\\n        return f(0,n,k,nums)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3775754,
                "title": "go-o-n-100-no-sorting-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n## Observation 1: Count The Non-Beautiful Subsets\\nGiven some set, $$A$$, the power set, $$\\\\mathcal{P} (A)$$, is the set containing all subsets of $$A$$ including the empty set, $$\\\\{\\\\}$$, and itself. For example,\\n\\n$$\\\\mathcal{P} (\\\\{1,2,3\\\\})=\\\\{\\\\{\\\\}, \\\\{1\\\\},\\\\{2\\\\},\\\\{3\\\\},\\\\{1,2\\\\},\\\\{1,3\\\\}\\\\{2,3\\\\}, \\\\{1,2,3\\\\}\\\\}$$\\n\\nWe can partition the power set into two subsets: $$\\\\mathcal{P} (A)_{b}$$, all beautiful subsets, and $$\\\\mathcal{P} (A)_{n}$$, all non-beautiful subsets. Rather than counting the number of beautiful subsets directly, we can count the number of non-beautiful subsets and subtract that from the total number of subsets. Expressed succinctly, where $$|S|$$ denotes the *cardinality* (i.e. number of elements) of a set,\\n\\n$$|\\\\mathcal{P} (A)|=|\\\\mathcal{P} (A)_{b}|+|\\\\mathcal{P} (A)_{n}| \\\\implies |\\\\mathcal{P} (A)_{b}|=|\\\\mathcal{P} (A)|-|\\\\mathcal{P} (A)_{n}|$$\\n\\nAs it turns out, $$|\\\\mathcal{P} (A)| = 2^{|A|}$$, or, put simply, the number of unique subsets you can create from any set is equal to two to the power of the number of elements in that set, so the above expression becomes:\\n\\n$$|\\\\mathcal{P} (A)_{b}|=2^{|A|}-|\\\\mathcal{P} (A)_{n}|$$\\n\\nNow the question becomes, how do I calculate the number of non-beautiful subsets, $$|\\\\mathcal{P} (A)_{n}|$$?\\n\\n## Observation 2: Building Non-Beautiful Subsets\\nA *multiset* is a set that allows for more than one instance of an element. The number of occurrences of an element in a multiset is referred to as its *multiplicity*. Expressed in explicit form, each element in a multiset can be given a superscript to denote its multiplicity (e.g. $$\\\\{1^2, 5^3\\\\}=\\\\{1,1,5,5,5\\\\}$$). The multiplicity of element $$e$$ in set $$S$$ can also be expressed as $$m_S (e)$$.\\n\\nConsider a multiset, $$S$$, to which we want to add a new element, $$e_i$$.\\n\\n$$\\nS=\\\\{e_1^{m(e_1)},e_2^{m(e_2)},...,e_{i-1}^{m(e_{i-1})}\\\\}\\n$$\\n\\nGiven the precondition that $$e_i+k \\\\notin S$$ we can express$$|\\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n}|$$ in terms of $$|\\\\mathcal{P} (S)_{n}|$$ and $$|\\\\mathcal{P}(S-\\\\{(e_i-k)^{m_S (e_i-k)}\\\\})_n|$$ (*note this isn\\'t an exponent, it\\'s the multiplicity of $$e_i-k$$*).\\n\\nWe can partition $$\\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n}$$ into three subsets:\\n\\n1. $$\\\\mathcal{P} (S)_{n}$$, subsets that do not contain $$e_i$$.\\n2. $$A_{both}=\\\\{ X \\\\, : \\\\, X \\\\in \\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n} \\\\quad \\\\textrm{and} \\\\quad  e_i \\\\in X \\\\quad \\\\textrm{and} \\\\quad e_i-k \\\\in X\\\\}$$, subsets that contain both $$e_i$$ and $$e_i - k$$.\\n3. $$A_{one}=\\\\{ X \\\\, : \\\\, X \\\\in \\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n} \\\\quad \\\\textrm{and} \\\\quad  e_i \\\\in X \\\\quad \\\\textrm{and} \\\\quad e_i-k \\\\notin X\\\\}$$, subsets that contain $$e_i$$ but not $$e_i-k$$.\\n\\nIf we know the cardinality of each of these sets then we know $$|\\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n}|$$, because $$|\\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n}|=|\\\\mathcal{P} (S)_{n}|+|A_{both}|+|A_{one}|$$.\\n\\nNotice that as long as a set includes $$e_i$$ and $$e_i-k$$ it is a non-beautiful set. We can reason that for any combination of $$e_i$$ and $$e_i-k$$ there are $$|\\\\mathcal{P}(S-\\\\{(e_i-k)^{m_S (e_i-k)}\\\\})|$$ subsets in $$A_{both}$$. There are $$(2^{m_S (e_i-k)}-1)(2^{m (e_i)}-1)$$ such combinations, so\\n\\n$$\\n|A_{both}|=(2^{m_S (e_i-k)}-1)(2^{m (e_i)}-1)(2^{|S|-m_S (e_i - k)})\\n$$\\n\\nAlso notice that if a set, $$X$$, includes $$e_i$$ but does not include $$e_i-k$$ it can only be a non-beautiful subset if $$X-\\\\{e_i^{m_X (e_i)}\\\\} \\\\in \\\\mathcal{P}(S-\\\\{(e_i-k)^{m_S (e_i-k)}\\\\})_n$$. Therefore,\\n\\n$$\\n|A_{one}|=(2^{m(e_i)}-1)|\\\\mathcal{P}(S-\\\\{(e_i-k)^{m_S (e_i-k)}\\\\})_n|\\n$$\\n\\nso,\\n\\n$$\\n\\\\begin{align}\\n|\\\\mathcal{P} (S \\\\cup \\\\{e_i^{m(e_i)}\\\\})_{n}| \\n  &= |\\\\mathcal{P} (S)_{n}|+|A_{both}|+|A_{one}| \\\\\\\\\\n  &= |\\\\mathcal{P} (S)_{n}|\\n     +|\\\\mathcal{P}(S-\\\\{(e_i-k)^{m_S (e_i-k)}\\\\})_n|(2^{m(e_i)}-1)\\n     +(2^{m_S (e_i-k)}-1)(2^{m (e_i)}-1)(2^{|S|-m_S (e_i - k)})\\n\\\\end{align}\\n$$\\n\\nIf $$S=\\\\{\\\\}$$, it\\'s clear to see that $$|\\\\mathcal{P} (S)_{n}|=0$$. If we add one element at a time to $$S$$ we can keep track of the number of non-beautiful sets inductively using the above expression. In order to maintain the invariant it is sufficient to ensure that for each \"chain\" of numbers, we add the numbers in ascending order. In other words, we always add $$i$$ before adding $$i+k$$.\\n\\n## Observation 3: Forming Chains\\nWe can break apart a set, $$S$$, into several *chains* where each chain is a sequence of numbers that are $$k$$-apart. For example, if $$S=\\\\{1,1,2,3,5,6,9,10\\\\}$$ and $$k=1$$, then we can form three chains: $$\\\\{1,1,2,3\\\\}$$, $$\\\\{5,6\\\\}$$, and $$\\\\{9,10\\\\}$$. We can process these chains in any order as long as we add the elements in a particular chain in ascending order. One way we can represent this is as a mapping between number and occurrences:\\n\\n$$\\nS=\\\\{1:2,\\\\;2:1,\\\\;3:1,\\\\;5:1,\\\\;6:1,\\\\;9:1,\\\\;10:1\\\\}\\n$$\\n\\nWe can traverse any chain by picking an arbitrary element, $$i$$, and checking for the existence of $$S[i-k]$$ and $$S[i+k]$$. $$S[i]$$ tells us the multiplicity of the set element (i.e. $$m_S(i)$$).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Convert `nums` to a `map[int]int` that maps number to number of occurrences.\\n2. For each chain, find the first element then traverse forward through the chain keeping track of the non-beautiful subsets using the formula above. Add one at the end to account for the empty set.\\n3. Return `2^len(nums)-non_beautiful_subsets`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc beautifulSubsets(nums []int, k int) int {\\n    return pow(len(nums)) - nonBeautifulSubsets(nums, k)\\n}\\n\\nfunc nonBeautifulSubsets(nums []int, k int) int {\\n    m := map[int]int{} // m[i] = multiplicity of element i\\n    for _, n := range nums {\\n        m[n]++\\n    }\\n\\n    var total [3]int // non-beautiful subsets found so far\\n    var sSize int    // size of set S so far\\n\\n    for i := range m {\\n        i = min(i, k, m)\\n\\n        // Traverse chain\\n        for ; m[i] != 0; i, sSize, total = i+k, sSize+m[i], shift(total) {\\n            aOne := pow(m[i]) - 1\\n\\n            // If this is the first in its chain, then P(S-{i-k}) = P(S),\\n            // so we need to multiply by total[1], as this represents |P(S)|.\\n            // Otherwise, we need to multiply by what total was before\\n            // adding element {i-k}, so we use total[2].\\n            if m[i-k] == 0 {\\n                aOne *= total[1]\\n            } else {\\n                aOne *= total[2]\\n            }\\n\\n            // Basically our formula from the solution.\\n            total[0] = total[1] + aOne + (pow(m[i]) - 1)*(pow(m[i-k]) - 1)*pow(sSize-m[i-k])\\n\\n            // Delete m[i-k] so it won\\'t be reprocessed.\\n            delete(m, i-k)\\n        }\\n\\n        // Delete m[i-k] so it won\\'t be reprocessed.\\n        delete(m, i-k)\\n    }\\n\\n    // +1 because we can\\'t forget the empty set!\\n    return total[0] + 1\\n}\\n\\nfunc pow(n int) int {\\n    return 1 << n\\n}\\n\\nfunc min(i int, k int, hist map[int]int) int {\\n    if hist[i] == 0 {\\n        return i+k\\n    }\\n    \\n    return min(i-k, k, hist)\\n}\\n\\nfunc shift(total [3]int) [3]int {\\n    total[1], total[2] = total[0], total[1]\\n\\n    return total\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc beautifulSubsets(nums []int, k int) int {\\n    return pow(len(nums)) - nonBeautifulSubsets(nums, k)\\n}\\n\\nfunc nonBeautifulSubsets(nums []int, k int) int {\\n    m := map[int]int{} // m[i] = multiplicity of element i\\n    for _, n := range nums {\\n        m[n]++\\n    }\\n\\n    var total [3]int // non-beautiful subsets found so far\\n    var sSize int    // size of set S so far\\n\\n    for i := range m {\\n        i = min(i, k, m)\\n\\n        // Traverse chain\\n        for ; m[i] != 0; i, sSize, total = i+k, sSize+m[i], shift(total) {\\n            aOne := pow(m[i]) - 1\\n\\n            // If this is the first in its chain, then P(S-{i-k}) = P(S),\\n            // so we need to multiply by total[1], as this represents |P(S)|.\\n            // Otherwise, we need to multiply by what total was before\\n            // adding element {i-k}, so we use total[2].\\n            if m[i-k] == 0 {\\n                aOne *= total[1]\\n            } else {\\n                aOne *= total[2]\\n            }\\n\\n            // Basically our formula from the solution.\\n            total[0] = total[1] + aOne + (pow(m[i]) - 1)*(pow(m[i-k]) - 1)*pow(sSize-m[i-k])\\n\\n            // Delete m[i-k] so it won\\'t be reprocessed.\\n            delete(m, i-k)\\n        }\\n\\n        // Delete m[i-k] so it won\\'t be reprocessed.\\n        delete(m, i-k)\\n    }\\n\\n    // +1 because we can\\'t forget the empty set!\\n    return total[0] + 1\\n}\\n\\nfunc pow(n int) int {\\n    return 1 << n\\n}\\n\\nfunc min(i int, k int, hist map[int]int) int {\\n    if hist[i] == 0 {\\n        return i+k\\n    }\\n    \\n    return min(i-k, k, hist)\\n}\\n\\nfunc shift(total [3]int) [3]int {\\n    total[1], total[2] = total[0], total[1]\\n\\n    return total\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732570,
                "title": "simple-and-clear-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int count=0;\\n        List<Integer> l1=new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> l3=new ArrayList<>();\\n         bck(nums,k,0,l1,l3);\\n         return l3.size();\\n    }\\n    void bck(int[] a,int k,int idx,List<Integer> l1,List<List<Integer>> l3)\\n    {\\n        if(idx==a.length)\\n        {\\n             if(l1.size()>0)\\n             l3.add(new ArrayList<>(l1));\\n             return;\\n        }\\n        if(!l1.contains((a[idx]-k)))\\n        {\\n            l1.add(a[idx]);\\n            bck(a,k,idx+1,l1,l3);\\n            l1.remove(l1.size()-1);\\n        }\\n        bck(a,k,idx+1,l1,l3);\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int count=0;\\n        List<Integer> l1=new ArrayList<>();\\n        Arrays.sort(nums);\\n        List<List<Integer>> l3=new ArrayList<>();\\n         bck(nums,k,0,l1,l3);\\n         return l3.size();\\n    }\\n    void bck(int[] a,int k,int idx,List<Integer> l1,List<List<Integer>> l3)\\n    {\\n        if(idx==a.length)\\n        {\\n             if(l1.size()>0)\\n             l3.add(new ArrayList<>(l1));\\n             return;\\n        }\\n        if(!l1.contains((a[idx]-k)))\\n        {\\n            l1.add(a[idx]);\\n            bck(a,k,idx+1,l1,l3);\\n            l1.remove(l1.size()-1);\\n        }\\n        bck(a,k,idx+1,l1,l3);\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692444,
                "title": "simple-c-solution-bit-masking-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint hope(int index,int mask,vector<int>&nums,int &k){\\n    if(index==nums.size()){\\n        if(mask!=0)return 1;\\n        return 0;\\n    }\\n    if(mask==0){\\n        int take=hope(index+1,((mask)|(1<<index)),nums,k);\\n        int not_take=hope(index+1,0,nums,k);\\n        return take+not_take;\\n    }\\n    int take=0;\\n    int flag=1;\\n    for(int i=0;i<index;i++){\\n        if(((1<<i)&(mask))==pow(2,i)){\\n            if(abs(nums[index]-nums[i])==k){\\n                flag=0;\\n                break;\\n            }\\n        }\\n    }\\n    if(flag==1)take=hope(index+1,((mask)|(1<<index)),nums,k);\\n    int not_take=hope(index+1,mask,nums,k);\\n    return take+not_take;\\n\\n\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n  return hope(0,0,nums,k);      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint hope(int index,int mask,vector<int>&nums,int &k){\\n    if(index==nums.size()){\\n        if(mask!=0)return 1;\\n        return 0;\\n    }\\n    if(mask==0){\\n        int take=hope(index+1,((mask)|(1<<index)),nums,k);\\n        int not_take=hope(index+1,0,nums,k);\\n        return take+not_take;\\n    }\\n    int take=0;\\n    int flag=1;\\n    for(int i=0;i<index;i++){\\n        if(((1<<i)&(mask))==pow(2,i)){\\n            if(abs(nums[index]-nums[i])==k){\\n                flag=0;\\n                break;\\n            }\\n        }\\n    }\\n    if(flag==1)take=hope(index+1,((mask)|(1<<index)),nums,k);\\n    int not_take=hope(index+1,mask,nums,k);\\n    return take+not_take;\\n\\n\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n  return hope(0,0,nums,k);      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684135,
                "title": "simple-swift-solution-that-creates-all-possible-subsets",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = nums.sorted()\\n        var subsets = [[Int]]()\\n        for (index, num) in nums.enumerated() {\\n            for subset in subsets {\\n                if !subset.isEmpty {\\n                    var current = subset.count - 1\\n                    while num - subset[current] < k, current > 0 {\\n                        current -= 1\\n                    }\\n                    if num - subset[current] != k {\\n                        subsets.append(subset + [num])\\n                    }\\n                }\\n            }\\n            subsets.append([num])\\n        }\\n        return subsets.count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {\\n        let nums = nums.sorted()\\n        var subsets = [[Int]]()\\n        for (index, num) in nums.enumerated() {\\n            for subset in subsets {\\n                if !subset.isEmpty {\\n                    var current = subset.count - 1\\n                    while num - subset[current] < k, current > 0 {\\n                        current -= 1\\n                    }\\n                    if num - subset[current] != k {\\n                        subsets.append(subset + [num])\\n                    }\\n                }\\n            }\\n            subsets.append([num])\\n        }\\n        return subsets.count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674096,
                "title": "c-solution-hash-table-backtracking",
                "content": "\\n```\\npublic class Solution {\\n    public int BeautifulSubsets(int[] nums, int k) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length;i++)\\n            if(!map.ContainsKey(nums[i])) map.Add(nums[i],0);\\n        int res = -1;\\n        void solve(int idx){\\n            if(idx >= nums.Length){\\n                res++;\\n                return;\\n            } \\n            // take\\n            int add = nums[idx] + k, sub = nums[idx] - k;\\n            if((!map.ContainsKey(add) || map[add] == 0) && (!map.ContainsKey(sub) || map[sub] == 0)){\\n                map[nums[idx]]++;\\n                solve(idx + 1);\\n                map[nums[idx]]--;\\n            }\\n            // leave\\n            solve(idx + 1);\\n        }\\n        solve(0);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Backtracking"
                ],
                "code": "```\\npublic class Solution {\\n    public int BeautifulSubsets(int[] nums, int k) {\\n        Dictionary<int,int> map = new Dictionary<int,int>();\\n        for(int i = 0; i < nums.Length;i++)\\n            if(!map.ContainsKey(nums[i])) map.Add(nums[i],0);\\n        int res = -1;\\n        void solve(int idx){\\n            if(idx >= nums.Length){\\n                res++;\\n                return;\\n            } \\n            // take\\n            int add = nums[idx] + k, sub = nums[idx] - k;\\n            if((!map.ContainsKey(add) || map[add] == 0) && (!map.ContainsKey(sub) || map[sub] == 0)){\\n                map[nums[idx]]++;\\n                solve(idx + 1);\\n                map[nums[idx]]--;\\n            }\\n            // leave\\n            solve(idx + 1);\\n        }\\n        solve(0);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553265,
                "title": "code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        f(0,nums,res,new ArrayList<>(),k);\\n        return res.size();\\n    }\\n    public void f(int ind,int[] nums,List<List<Integer>> res,List<Integer> ds,int k){\\n        if(ind==nums.length){\\n            if(ds.size()>0){\\n                res.add(new ArrayList<>(ds));\\n            }\\n            return;\\n        }\\n        if(!(ds.contains(nums[ind]-k) )){\\n            ds.add(nums[ind]);\\n            f(ind+1,nums,res,ds,k);    \\n            ds.remove(ds.size()-1);\\n        }\\n        f(ind+1,nums,res,ds,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        f(0,nums,res,new ArrayList<>(),k);\\n        return res.size();\\n    }\\n    public void f(int ind,int[] nums,List<List<Integer>> res,List<Integer> ds,int k){\\n        if(ind==nums.length){\\n            if(ds.size()>0){\\n                res.add(new ArrayList<>(ds));\\n            }\\n            return;\\n        }\\n        if(!(ds.contains(nums[ind]-k) )){\\n            ds.add(nums[ind]);\\n            f(ind+1,nums,res,ds,k);    \\n            ds.remove(ds.size()-1);\\n        }\\n        f(ind+1,nums,res,ds,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465636,
                "title": "intuitive-solution-cpp-easy-typical-dp-subset-problem",
                "content": "# Intuition and Approach\\nConstraint is very low and even brute force will work, just create all subsets and check while inserting it is valid insertion or not, if its valid push else go ahead. Backtrack for other possible solutions.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Complexity\\n- Time complexity:\\nExponential (2^n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(vector<int> &ans, int n, int k)\\n{\\n    for (auto e : ans)\\n        if (abs(e - n) == k)\\n            return false;\\n    return true;\\n}\\n\\nint helper(vector<int> &nums, int ind, int k, vector<int> &ans)\\n{\\n    if (ind == -1)\\n    {\\n        if (ans.size())\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    int pick = 0, notpick = 0;\\n    notpick = helper(nums, ind - 1, k, ans);\\n\\n    if (isValid(ans, nums[ind], k))\\n    {\\n        ans.push_back(nums[ind]);\\n        pick = helper(nums, ind - 1, k, ans);\\n        ans.pop_back();\\n    }\\n\\n    return pick + notpick;\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    vector<int> ans;\\n    return helper(nums, nums.size() - 1, k, ans);\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(vector<int> &ans, int n, int k)\\n{\\n    for (auto e : ans)\\n        if (abs(e - n) == k)\\n            return false;\\n    return true;\\n}\\n\\nint helper(vector<int> &nums, int ind, int k, vector<int> &ans)\\n{\\n    if (ind == -1)\\n    {\\n        if (ans.size())\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    int pick = 0, notpick = 0;\\n    notpick = helper(nums, ind - 1, k, ans);\\n\\n    if (isValid(ans, nums[ind], k))\\n    {\\n        ans.push_back(nums[ind]);\\n        pick = helper(nums, ind - 1, k, ans);\\n        ans.pop_back();\\n    }\\n\\n    return pick + notpick;\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    vector<int> ans;\\n    return helper(nums, nums.size() - 1, k, ans);\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449577,
                "title": "using-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>v, int k){\\n        bool p =true;\\n        for(int i=0;i<v.size();i++){\\n            for(int j=i;j<v.size();j++){\\n                if(abs(v[i]-v[j])==k){\\n                    p =false;\\n                }\\n            }\\n        }\\n        if(p==true) return pow(2,v.size())-1;\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans++;\\n            vector<int>temp;\\n            for(int j=i+1;j<v.size();j++){\\n                if(abs(v[i]-v[j])!=k){\\n                    temp.push_back(v[j]);\\n                }\\n            }\\n            ans+=fun(temp,k);\\n        }\\n        return ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = fun(nums,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<int>v, int k){\\n        bool p =true;\\n        for(int i=0;i<v.size();i++){\\n            for(int j=i;j<v.size();j++){\\n                if(abs(v[i]-v[j])==k){\\n                    p =false;\\n                }\\n            }\\n        }\\n        if(p==true) return pow(2,v.size())-1;\\n        int ans = 0;\\n        for(int i=0;i<v.size();i++){\\n            ans++;\\n            vector<int>temp;\\n            for(int j=i+1;j<v.size();j++){\\n                if(abs(v[i]-v[j])!=k){\\n                    temp.push_back(v[j]);\\n                }\\n            }\\n            ans+=fun(temp,k);\\n        }\\n        return ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int ans = fun(nums,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427105,
                "title": "python-backtracking",
                "content": "\\n```\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        self.cnt = -1\\n        \\n        def dfs(subset, start):\\n            self.cnt += 1\\n            \\n            for i in range(start, len(A)):\\n                if A[i] - k not in subset and A[i]+k not in subset:\\n                    subset.append(A[i])\\n                    dfs(subset, i+1)\\n                    subset.pop()\\n        dfs([], 0)\\n    \\n        return self.cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], k: int) -> int:\\n        self.cnt = -1\\n        \\n        def dfs(subset, start):\\n            self.cnt += 1\\n            \\n            for i in range(start, len(A)):\\n                if A[i] - k not in subset and A[i]+k not in subset:\\n                    subset.append(A[i])\\n                    dfs(subset, i+1)\\n                    subset.pop()\\n        dfs([], 0)\\n    \\n        return self.cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401256,
                "title": "dfs-combination-math-python-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        count = collections.Counter(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        ans = 0\\n        count2 = collections.defaultdict(int)\\n        for key in count:\\n            l = 0\\n            for c in range(1, count[key]+1):\\n                l += math.comb(count[key], c)\\n            count2[key] = l\\n\\n\\n    \\n        def dfs(i, s):\\n            if i == len(nums):\\n                nonlocal ans\\n                if s:\\n                    t = 1\\n                    for p in s:\\n                        t *=count2[p]\\n                    ans +=t\\n                return\\n            if nums[i] - k not in s:\\n                s.add(nums[i])\\n                dfs(i+1, s)\\n                s.remove(nums[i])\\n            dfs(i+1,s)\\n\\n        dfs(0, set())\\n        return ans\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        count = collections.Counter(nums)\\n        nums = list(set(nums))\\n        nums.sort()\\n        ans = 0\\n        count2 = collections.defaultdict(int)\\n        for key in count:\\n            l = 0\\n            for c in range(1, count[key]+1):\\n                l += math.comb(count[key], c)\\n            count2[key] = l\\n\\n\\n    \\n        def dfs(i, s):\\n            if i == len(nums):\\n                nonlocal ans\\n                if s:\\n                    t = 1\\n                    for p in s:\\n                        t *=count2[p]\\n                    ans +=t\\n                return\\n            if nums[i] - k not in s:\\n                s.add(nums[i])\\n                dfs(i+1, s)\\n                s.remove(nums[i])\\n            dfs(i+1,s)\\n\\n        dfs(0, set())\\n        return ans\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355473,
                "title": "backtracking-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int K;\\n    int find_subset(int i,vector<int>&temp,vector<int>&nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            count++;\\n            return 0;\\n        }\\n            \\n        if((nums[i]-K)>=0  )\\n        {\\n            if(temp[nums[i]-K]==0)\\n            {\\n                temp[nums[i]]+=1;\\n                // if we used =1 intead of +=1 and -=1\\n                //will give wrong answer for repeated elements\\n                //[1,1,2,3] k=1\\n                find_subset(i+1,temp,nums);\\n                temp[nums[i]]-=1;\\n            }\\n        }\\n        else\\n        {\\n            temp[nums[i]]+=1;\\n            find_subset(i+1,temp,nums);\\n            temp[nums[i]]-=1;\\n        }\\n        find_subset(i+1,temp,nums);\\n        return 0;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        K=k;\\n        sort(nums.begin(),nums.end());\\n        vector <int> temp(1001,0);\\n        find_subset(0,temp,nums);\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int count=0;\\n    int K;\\n    int find_subset(int i,vector<int>&temp,vector<int>&nums)\\n    {\\n        if(i==nums.size())\\n        {\\n            count++;\\n            return 0;\\n        }\\n            \\n        if((nums[i]-K)>=0  )\\n        {\\n            if(temp[nums[i]-K]==0)\\n            {\\n                temp[nums[i]]+=1;\\n                // if we used =1 intead of +=1 and -=1\\n                //will give wrong answer for repeated elements\\n                //[1,1,2,3] k=1\\n                find_subset(i+1,temp,nums);\\n                temp[nums[i]]-=1;\\n            }\\n        }\\n        else\\n        {\\n            temp[nums[i]]+=1;\\n            find_subset(i+1,temp,nums);\\n            temp[nums[i]]-=1;\\n        }\\n        find_subset(i+1,temp,nums);\\n        return 0;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        K=k;\\n        sort(nums.begin(),nums.end());\\n        vector <int> temp(1001,0);\\n        find_subset(0,temp,nums);\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352102,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n         if(idx == nums.size()) ans++;\\n        else {\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n           int ans = 0;\\n          unordered_map<int, int> mp;\\n         dfs(nums, 0, k, mp, ans);\\n          return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     void dfs(vector<int> &nums, int idx, int k, unordered_map<int, int> &mp, int &ans) {\\n         if(idx == nums.size()) ans++;\\n        else {\\n            if(!mp[nums[idx] - k] && !mp[nums[idx] + k]) {\\n                mp[nums[idx]]++;\\n                dfs(nums, idx + 1, k, mp, ans);\\n                mp[nums[idx]]--;\\n            }\\n            dfs(nums, idx + 1, k, mp, ans);\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n           int ans = 0;\\n          unordered_map<int, int> mp;\\n         dfs(nums, 0, k, mp, ans);\\n          return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351105,
                "title": "c-using-bitmasking",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSubset(vector <int> &nums,int mask,int k,int index,vector <int> &dp){\\n         if(index >= nums.size()){\\n             return 1;\\n         }\\n         int ans=countSubset(nums,mask,k,index+1,dp);\\n         int flag=1;\\n         for(int i=0;i<index;i++){\\n            if(mask & (1<<i)){\\n                if(abs(nums[i]-nums[index]) == k){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n         }\\n         if(flag){\\n             mask|=(1<<index);\\n             ans += countSubset(nums,mask,k,index+1,dp);\\n         }\\n         return dp[index]=ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector <int> dp(n,-1);\\n        return countSubset(nums,0,k,0,dp)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubset(vector <int> &nums,int mask,int k,int index,vector <int> &dp){\\n         if(index >= nums.size()){\\n             return 1;\\n         }\\n         int ans=countSubset(nums,mask,k,index+1,dp);\\n         int flag=1;\\n         for(int i=0;i<index;i++){\\n            if(mask & (1<<i)){\\n                if(abs(nums[i]-nums[index]) == k){\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n         }\\n         if(flag){\\n             mask|=(1<<index);\\n             ans += countSubset(nums,mask,k,index+1,dp);\\n         }\\n         return dp[index]=ans;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector <int> dp(n,-1);\\n        return countSubset(nums,0,k,0,dp)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347433,
                "title": "java-easy-backtracking-number-of-beautiful-subsets",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        helper(nums,k,0,res,new ArrayList<>(),nums.length);\\n        return res.size()-1;\\n    }\\n\\n    public void helper(int []nums, int k, int i, List<List<Integer>> res, List<Integer> sub,int n){\\n        if(i==n){\\n            List<Integer> ans=new ArrayList<>();\\n            ans.addAll(sub);\\n            res.add(ans);\\n            return;\\n        }\\n\\n        if(!sub.contains(nums[i]-k)){\\n            sub.add(nums[i]);\\n            helper(nums,k,i+1,res,sub,n);\\n            sub.remove(sub.size()-1);\\n        }\\n\\n        helper(nums,k,i+1,res,sub,n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res=new ArrayList<>();\\n        helper(nums,k,0,res,new ArrayList<>(),nums.length);\\n        return res.size()-1;\\n    }\\n\\n    public void helper(int []nums, int k, int i, List<List<Integer>> res, List<Integer> sub,int n){\\n        if(i==n){\\n            List<Integer> ans=new ArrayList<>();\\n            ans.addAll(sub);\\n            res.add(ans);\\n            return;\\n        }\\n\\n        if(!sub.contains(nums[i]-k)){\\n            sub.add(nums[i]);\\n            helper(nums,k,i+1,res,sub,n);\\n            sub.remove(sub.size()-1);\\n        }\\n\\n        helper(nums,k,i+1,res,sub,n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341728,
                "title": "simple-approach-without-using-backtrack-based-on-subset-approach-beats-46-as-of-26mar2023",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is difficult to find a mathematical formula to solve it quicker than powerset approach. So finally, I took the approach of checking all the possible compbinations and then exclude the ugly combinations.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse subset approach, to try to build all the combinations of the numbers as sublist. For this there is one question already on the leetcode of finding subset. Then exclude the lists or do not add the number which make the sublist ugly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nProbably n2^n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length == 1) return 1;\\n\\n        List<List<Integer>> r =  new ArrayList<List<Integer>>();\\n        r.add(new ArrayList<Integer>());\\n        int count = 0;\\n        List<Integer> sub = null;\\n\\n        HashSet<Integer> aunq = new HashSet<Integer>();\\n       \\n        HashSet<Integer> uglyset = new HashSet<Integer>();\\n        for(int n :  nums) {\\n            aunq.add(n);\\n            if( aunq.contains( n + k) || aunq.contains( n-k ) ) uglyset.add(n);\\n        } // keep this set so that we can reduce the time of checking in isBeautiful. isBeautiful check is little time expensive. So if the incoming number is not in the uglyset then definitely it will not make the sublist ugly.\\n\\n\\n        for(int n : nums){\\n\\n            int sz = r.size();\\n\\n            for(int i = 0 ; i < sz ; i ++){\\n                if(!uglyset.contains(n) || isBeautiful(r.get(i),k,n)) { \\n                    sub = new ArrayList<Integer>(r.get(i));\\n                    sub.add(n);\\n                    count++;\\n                    r.add(sub);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public boolean isBeautiful(List<Integer> nums, int k, int x ){\\n        for(int n : nums) if ( (x+k) == n || ( n + k ) == x ) return false;\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length == 1) return 1;\\n\\n        List<List<Integer>> r =  new ArrayList<List<Integer>>();\\n        r.add(new ArrayList<Integer>());\\n        int count = 0;\\n        List<Integer> sub = null;\\n\\n        HashSet<Integer> aunq = new HashSet<Integer>();\\n       \\n        HashSet<Integer> uglyset = new HashSet<Integer>();\\n        for(int n :  nums) {\\n            aunq.add(n);\\n            if( aunq.contains( n + k) || aunq.contains( n-k ) ) uglyset.add(n);\\n        } // keep this set so that we can reduce the time of checking in isBeautiful. isBeautiful check is little time expensive. So if the incoming number is not in the uglyset then definitely it will not make the sublist ugly.\\n\\n\\n        for(int n : nums){\\n\\n            int sz = r.size();\\n\\n            for(int i = 0 ; i < sz ; i ++){\\n                if(!uglyset.contains(n) || isBeautiful(r.get(i),k,n)) { \\n                    sub = new ArrayList<Integer>(r.get(i));\\n                    sub.add(n);\\n                    count++;\\n                    r.add(sub);\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    public boolean isBeautiful(List<Integer> nums, int k, int x ){\\n        for(int n : nums) if ( (x+k) == n || ( n + k ) == x ) return false;\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340839,
                "title": "simple-java-solution-with-comments-explained",
                "content": "# Complexity\\n- Time complexity:O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int freqArray[]=new int[1001]; //making the frequency array for creating subset\\n    public int beautifulSubsets(int[] nums, int k) {//we have to check two conditions for subset to be valid\\n        Arrays.sort(nums);//first is for eery a[i] there should be no a[i]-k present in set and second no a[i]+k should be present\\n        return countSet(nums,0,k)-1;//sorting the array removes the second cond check\\n    }\\n    private int countSet(int[] nums,int index,int k){\\n        if(index==nums.length) return 1;\\n        int consideringIndex=0; //first case is considering the element at the index\\n        if(nums[index]-k<0||Solution.freqArray[nums[index]-k]==0){//if we are considering then we need to validate the condition that no nums[index]-k index of freq array is set to 1;\\n            Solution.freqArray[nums[index]]++; \\n            consideringIndex=countSet(nums,index+1,k);//sending for forward iteration\\n            Solution.freqArray[nums[index]]--;//removing the set value for not considering the index\\n        }\\n        int notConsideringIndex=countSet(nums,index+1,k);//sending the non considered case\\n        return consideringIndex+notConsideringIndex;\\n    }\\n}//upvote is encouraging..\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int freqArray[]=new int[1001]; //making the frequency array for creating subset\\n    public int beautifulSubsets(int[] nums, int k) {//we have to check two conditions for subset to be valid\\n        Arrays.sort(nums);//first is for eery a[i] there should be no a[i]-k present in set and second no a[i]+k should be present\\n        return countSet(nums,0,k)-1;//sorting the array removes the second cond check\\n    }\\n    private int countSet(int[] nums,int index,int k){\\n        if(index==nums.length) return 1;\\n        int consideringIndex=0; //first case is considering the element at the index\\n        if(nums[index]-k<0||Solution.freqArray[nums[index]-k]==0){//if we are considering then we need to validate the condition that no nums[index]-k index of freq array is set to 1;\\n            Solution.freqArray[nums[index]]++; \\n            consideringIndex=countSet(nums,index+1,k);//sending for forward iteration\\n            Solution.freqArray[nums[index]]--;//removing the set value for not considering the index\\n        }\\n        int notConsideringIndex=countSet(nums,index+1,k);//sending the non considered case\\n        return consideringIndex+notConsideringIndex;\\n    }\\n}//upvote is encouraging..\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337984,
                "title": "c-easy-fast-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k,int idx,unordered_map<int,int> &mp)\\n    {\\n        if(idx==nums.size())\\n        {\\n            return 1;\\n        }\\n\\n        int pick=0,notpick=0;\\n        if(mp[nums[idx]-k]==0)\\n        {\\n            //curr.push_back(nums[idx]);\\n            mp[nums[idx]]++;\\n            pick=solve(nums,k,idx+1,mp);\\n            //curr.pop_back();\\n            mp[nums[idx]]--;\\n        }\\n\\n        notpick=solve(nums,k,idx+1,mp);\\n        return pick+notpick;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        return solve(nums,k,0,mp)-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int k,int idx,unordered_map<int,int> &mp)\\n    {\\n        if(idx==nums.size())\\n        {\\n            return 1;\\n        }\\n\\n        int pick=0,notpick=0;\\n        if(mp[nums[idx]-k]==0)\\n        {\\n            //curr.push_back(nums[idx]);\\n            mp[nums[idx]]++;\\n            pick=solve(nums,k,idx+1,mp);\\n            //curr.pop_back();\\n            mp[nums[idx]]--;\\n        }\\n\\n        notpick=solve(nums,k,idx+1,mp);\\n        return pick+notpick;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        sort(nums.begin(),nums.end());\\n        return solve(nums,k,0,mp)-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336833,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        visited = defaultdict(int)\\n        self.ans = 0\\n        def recur(index):\\n            if index >= n:\\n                return \\n            if nums[index] - k not in visited and nums[index] + k not in visited:\\n                visited[nums[index]] += 1\\n                self.ans += 1\\n                recur(index + 1)\\n                visited[nums[index]] -= 1\\n                if visited[nums[index]] == 0:\\n                    del visited[nums[index]]\\n                    \\n            recur(index + 1)\\n            \\n        recur(0)\\n        \\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        visited = defaultdict(int)\\n        self.ans = 0\\n        def recur(index):\\n            if index >= n:\\n                return \\n            if nums[index] - k not in visited and nums[index] + k not in visited:\\n                visited[nums[index]] += 1\\n                self.ans += 1\\n                recur(index + 1)\\n                visited[nums[index]] -= 1\\n                if visited[nums[index]] == 0:\\n                    del visited[nums[index]]\\n                    \\n            recur(index + 1)\\n            \\n        recur(0)\\n        \\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336033,
                "title": "simple-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void func(vector<int>& nums, int& k, int index, int last, unordered_map<int,int>& amap, int& ans){\\n        if(index==last){\\n            ans++;\\n            return;\\n        }\\n        else{\\n            int curr=nums[index];\\n            int x=curr-k;\\n            int y=curr+k;\\n            if(!amap[x] && !amap[y]){\\n                amap[curr]++;\\n                func(nums,k,index+1,last,amap,ans);\\n                amap[curr]--;\\n            }\\n            func(nums,k,index+1,last,amap,ans);\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>amap;\\n        int ans=0;\\n        func(nums,k,0,nums.size(),amap,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void func(vector<int>& nums, int& k, int index, int last, unordered_map<int,int>& amap, int& ans){\\n        if(index==last){\\n            ans++;\\n            return;\\n        }\\n        else{\\n            int curr=nums[index];\\n            int x=curr-k;\\n            int y=curr+k;\\n            if(!amap[x] && !amap[y]){\\n                amap[curr]++;\\n                func(nums,k,index+1,last,amap,ans);\\n                amap[curr]--;\\n            }\\n            func(nums,k,index+1,last,amap,ans);\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>amap;\\n        int ans=0;\\n        func(nums,k,0,nums.size(),amap,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335749,
                "title": "c-2-power-n-back-tracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int diff;\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        diff=k;\\n        unordered_map<int,int> mp;\\n        int ans=solve(nums,0,mp);\\n        return ans-1;\\n    }\\n\\n    int solve(vector<int> &nums,int ind, unordered_map<int,int> &mp){\\n        //cout<<\"*\"<<endl;\\n        if(ind==nums.size()) return 1;\\n\\n        //1 we take num[ind]\\n        int taken=0;\\n        if( (mp[nums[ind]-diff]==0) && (mp[nums[ind]+diff]==0) ){\\n            mp[nums[ind]]++;\\n            taken=solve(nums,ind+1,mp);\\n            mp[nums[ind]]--;\\n        }\\n\\n        int nottaken=solve(nums,ind+1,mp);\\n\\n        return taken+nottaken;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int diff;\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        diff=k;\\n        unordered_map<int,int> mp;\\n        int ans=solve(nums,0,mp);\\n        return ans-1;\\n    }\\n\\n    int solve(vector<int> &nums,int ind, unordered_map<int,int> &mp){\\n        //cout<<\"*\"<<endl;\\n        if(ind==nums.size()) return 1;\\n\\n        //1 we take num[ind]\\n        int taken=0;\\n        if( (mp[nums[ind]-diff]==0) && (mp[nums[ind]+diff]==0) ){\\n            mp[nums[ind]]++;\\n            taken=solve(nums,ind+1,mp);\\n            mp[nums[ind]]--;\\n        }\\n\\n        int nottaken=solve(nums,ind+1,mp);\\n\\n        return taken+nottaken;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3331640,
                "title": "swift-solution",
                "content": "# Approach\\n1. Sort the array.\\n2. Do a DFS. Each time, take an element in the array, and decide whether to use it or not.\\n3. If we use it, we check if there are enough elements in the array that are smaller than the current element by k.\\n4. If yes, we can use it. We add 1 to the result and move on to the next element.\\n5. If no, we cannot use it. We just move on to the next element.\\n6. If we don\\'t use it, we just move on the next element.\\n7. We subtract 1 from the final result because we don\\'t want to include the empty set. \\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {\\n        var nums = nums.sorted()\\n        var seen = [Int: Int]()\\n        let n = nums.count\\n        return dfs(&nums, k, &seen, n, 0) - 1\\n    }\\n    \\n    private func dfs(_ nums: inout [Int], _ k: Int, _ seen: inout [Int: Int], _ n: Int, _ i: Int) -> Int {\\n        if i == n {\\n            return 1\\n        }\\n        var res = 0\\n        if seen[nums[i] - k, default: 0] == 0 {\\n            seen[nums[i], default: 0] += 1\\n            res += dfs(&nums, k, &seen, n, i + 1)\\n            seen[nums[i], default: 0] -= 1\\n        }\\n        res += dfs(&nums, k, &seen, n, i + 1)\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulSubsets(_ nums: [Int], _ k: Int) -> Int {\\n        var nums = nums.sorted()\\n        var seen = [Int: Int]()\\n        let n = nums.count\\n        return dfs(&nums, k, &seen, n, 0) - 1\\n    }\\n    \\n    private func dfs(_ nums: inout [Int], _ k: Int, _ seen: inout [Int: Int], _ n: Int, _ i: Int) -> Int {\\n        if i == n {\\n            return 1\\n        }\\n        var res = 0\\n        if seen[nums[i] - k, default: 0] == 0 {\\n            seen[nums[i], default: 0] += 1\\n            res += dfs(&nums, k, &seen, n, i + 1)\\n            seen[nums[i], default: 0] -= 1\\n        }\\n        res += dfs(&nums, k, &seen, n, i + 1)\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329623,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n\\n# Approach\\nThis problem is modification of find subset problem simple backtracking creating list and list of list and adding list into list of list when base case hit. a/c to question nums[i] - k should not be there into list then we will add into the list and .......\\n# Complexity\\n- Time complexity: O(nlogn)\\n> - Space complexity: O(2 power n) in worst case\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        findSubset(nums, 0, k, new ArrayList<>(), ans);\\n        \\n        return ans.size();\\n        \\n    }\\n    public void findSubset(int[] nums, int i, int k, List<Integer> ds, List<List<Integer>> ans){\\n        if(i == nums.length){\\n            if(ds.size() > 0){\\n                ans.add(new ArrayList<>(ds));\\n            }\\n            return;\\n        }\\n        if(!(ds.contains(nums[i] - k))){\\n            ds.add(nums[i]);\\n            findSubset(nums, i + 1, k, ds, ans);\\n            ds.remove(ds.size() - 1);\\n        }\\n        findSubset(nums, i + 1, k, ds, ans);\\n    }\\n}\\n# heading",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ans = new ArrayList<>();\\n        \\n        findSubset(nums, 0, k, new ArrayList<>(), ans);\\n        \\n        return ans.size();\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3329309,
                "title": "bitmask-recursion",
                "content": "# BitMask\\n```\\nclass Solution {\\nprivate:\\n    int n;\\n    int fn(vector<int>& nums,int i,int k,long long mask){\\n        if(i == -1) return mask != 0;\\n        int ans = fn(nums,i-1,k,mask);\\n        bool possible = true;\\n        for(int j=0; j<n; ++j){\\n            if(((mask>>j)&1) && abs(nums[j] - nums[i]) == k){\\n                possible = false;\\n                break;\\n            }\\n        }\\n        if(possible) ans += fn(nums,i-1,k,mask|(1ll<<i));\\n        return ans;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        n = size(nums);\\n        return fn(nums,n-1,k,0);\\n    }\\n};\\n```\\n# Recurison\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsetsCount = 0;\\n    \\n    void backtrack(int idx, vector<int>& currentSubset, vector<int>& nums, unordered_map<int, bool>& used, int k) {\\n        if (idx == nums.size()) {\\n            if (currentSubset.size() > 0) {\\n                beautifulSubsetsCount++;\\n            }\\n            return;\\n        }\\n        \\n        backtrack(idx + 1, currentSubset, nums, used, k);\\n        \\n        if (!used[nums[idx] - k]) {\\n            currentSubset.push_back(nums[idx]);\\n            used[nums[idx]] = true;\\n            backtrack(idx + 1, currentSubset, nums, used, k);\\n            currentSubset.pop_back();\\n            used[nums[idx]] = false;\\n        }\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> currentSubset;\\n        unordered_map<int, bool> used;\\n        backtrack(0, currentSubset, nums, used, k);\\n        return beautifulSubsetsCount;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int n;\\n    int fn(vector<int>& nums,int i,int k,long long mask){\\n        if(i == -1) return mask != 0;\\n        int ans = fn(nums,i-1,k,mask);\\n        bool possible = true;\\n        for(int j=0; j<n; ++j){\\n            if(((mask>>j)&1) && abs(nums[j] - nums[i]) == k){\\n                possible = false;\\n                break;\\n            }\\n        }\\n        if(possible) ans += fn(nums,i-1,k,mask|(1ll<<i));\\n        return ans;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        n = size(nums);\\n        return fn(nums,n-1,k,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsetsCount = 0;\\n    \\n    void backtrack(int idx, vector<int>& currentSubset, vector<int>& nums, unordered_map<int, bool>& used, int k) {\\n        if (idx == nums.size()) {\\n            if (currentSubset.size() > 0) {\\n                beautifulSubsetsCount++;\\n            }\\n            return;\\n        }\\n        \\n        backtrack(idx + 1, currentSubset, nums, used, k);\\n        \\n        if (!used[nums[idx] - k]) {\\n            currentSubset.push_back(nums[idx]);\\n            used[nums[idx]] = true;\\n            backtrack(idx + 1, currentSubset, nums, used, k);\\n            currentSubset.pop_back();\\n            used[nums[idx]] = false;\\n        }\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        vector<int> currentSubset;\\n        unordered_map<int, bool> used;\\n        backtrack(0, currentSubset, nums, used, k);\\n        return beautifulSubsetsCount;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3328580,
                "title": "simple-solution-backtracking-in-c",
                "content": "# Intuition\\nNotice that there are only 20 items, we can use dfs on a sorted list of numbers to find the result.\\n\\n# Approach\\nFirst we sort the numbers. Then for each number num[i] from idx 0 to n - 1, we only need to check if num[i] - k is in our selected number set. If num[i] - k has been selected, we skip num[i], otherwise we can either choose or skip num[i]. \\n\\nWe need an array to remember which numbers has been selected. Notice that if we use unordered_set, there will be an TLE error.\\n\\n# Code Explanation\\nThe algorithm used to solve this problem is a backtracking algorithm, implemented in the helper function. The helper function takes as input a vector of integers `num`, an integer `k`, and an integer `i` representing the current index in `num`. The purpose of the helper function is to recursively explore all possible subsets of num that satisfy the condition of being beautiful, and to update the res variable (which is a member variable of the Solution class) with the total number of beautiful subsets found.\\n\\nThe implementation of the helper function is as follows:\\n\\nThe function first checks if the current index i is greater than or equal to the size of the input vector num. If it is, then the function simply returns, since there are no more elements to consider.\\n\\nThe function then checks if the absolute difference between the current element `num[i]` and `k` is less than zero (i.e., if `num[i]-k` is negative). If it is, then the function moves on to the next index by calling itself recursively with the next index i+1.\\n\\nIf the absolute difference between `num[i]` and `k` is not less than zero, then the function checks if there exists an element in the s array (which is a member variable of the Solution class) that is equal to `num[i]-k`\\n\\nIf the index i is valid, the function checks if the difference between the current element num[i] and k is less than 0 or if the value of the element num[i]-k in the array s is 0. If either of these conditions is true, the function increments the value of s[num[i]], increments the value of res, and recursively calls itself with the updated values. After the recursive call, the function decrements the value of s[num[i]].\\n\\nIf neither of the conditions is true, the function simply calls itself recursively with the next index i + 1.\\n\\n# Code\\n```\\nclass Solution {\\n    int res = 0;\\n    int s[1010] = {0};\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        helper(nums, k, 0);\\n        return res;\\n    }\\n    \\n    void helper(vector<int>& num, int k, int i) {\\n        if (i >= num.size()) return;\\n        if (num[i] - k < 0 || s[num[i]-k] == 0) {\\n            s[num[i]]++;\\n            res++;\\n            helper(num, k, i + 1);\\n            s[num[i]]--;\\n        }\\n        helper(num, k, i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    int s[1010] = {0};\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        helper(nums, k, 0);\\n        return res;\\n    }\\n    \\n    void helper(vector<int>& num, int k, int i) {\\n        if (i >= num.size()) return;\\n        if (num[i] - k < 0 || s[num[i]-k] == 0) {\\n            s[num[i]]++;\\n            res++;\\n            helper(num, k, i + 1);\\n            s[num[i]]--;\\n        }\\n        helper(num, k, i + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324539,
                "title": "without-sort-using-simple-backtracking-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple back tracking algoritm applied \\nbut the same algorithm gives TLE when used with the statements written as comment...\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int helper(vector<int>& nums, int k,int idx,unordered_map<int,int>& mp)\\n    {\\n        if(idx==nums.size())\\n        {return(0);}\\n        int inc=0;\\n        // if(mp.find(nums[idx]-k)==mp.end() )\\n        if(mp[nums[idx]-k]<=0 && mp[nums[idx]+k]<=0)\\n        {\\n            mp[nums[idx]]++;\\n            inc+=1+helper(nums,k,idx+1,mp);\\n            mp[nums[idx]]--;\\n            // if(mp[nums[idx]]==0)\\n            //     mp.erase(nums[idx]);\\n                \\n        }\\n        \\n        int noninc=helper(nums,k,idx+1,mp);\\n        return(inc+noninc);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        // sort(nums.begin(),nums.end());\\n        return(helper(nums,k,0,mp));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res=0;\\n    int helper(vector<int>& nums, int k,int idx,unordered_map<int,int>& mp)\\n    {\\n        if(idx==nums.size())\\n        {return(0);}\\n        int inc=0;\\n        // if(mp.find(nums[idx]-k)==mp.end() )\\n        if(mp[nums[idx]-k]<=0 && mp[nums[idx]+k]<=0)\\n        {\\n            mp[nums[idx]]++;\\n            inc+=1+helper(nums,k,idx+1,mp);\\n            mp[nums[idx]]--;\\n            // if(mp[nums[idx]]==0)\\n            //     mp.erase(nums[idx]);\\n                \\n        }\\n        \\n        int noninc=helper(nums,k,idx+1,mp);\\n        return(inc+noninc);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n=nums.size();\\n        // sort(nums.begin(),nums.end());\\n        return(helper(nums,k,0,mp));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324421,
                "title": "python3-map-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        cntMap = defaultdict(int)\\n\\n        def solve(idx):\\n            nonlocal res, cntMap\\n\\n            if idx == n:\\n                return 1\\n            \\n            num = nums[idx]\\n            \\n            take = 0\\n            notTake = 0\\n\\n            if cntMap[num - k] == 0 and cntMap[num + k] == 0:\\n                cntMap[num] += 1\\n\\n                take = solve(idx + 1)\\n\\n                cntMap[num] -= 1\\n            \\n            notTake = solve(idx + 1)\\n\\n            return take + notTake\\n\\n        # As we have added the prev == -1 case, a valid case is generated if no value is selected in \\n        # our subset so we subtract 1\\n        return solve(0) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        res = 0\\n        cntMap = defaultdict(int)\\n\\n        def solve(idx):\\n            nonlocal res, cntMap\\n\\n            if idx == n:\\n                return 1\\n            \\n            num = nums[idx]\\n            \\n            take = 0\\n            notTake = 0\\n\\n            if cntMap[num - k] == 0 and cntMap[num + k] == 0:\\n                cntMap[num] += 1\\n\\n                take = solve(idx + 1)\\n\\n                cntMap[num] -= 1\\n            \\n            notTake = solve(idx + 1)\\n\\n            return take + notTake\\n\\n        # As we have added the prev == -1 case, a valid case is generated if no value is selected in \\n        # our subset so we subtract 1\\n        return solve(0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324282,
                "title": "simple-c-solution-backtracking",
                "content": "# Complexity\\n- Time complexity:\\n*O(2^N)*\\n\\n- Space complexity:\\n*O(N)*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint ans=0;\\n    void f(vector<int>&nums,int k,int idx,map<int,int>&m){\\n       if(idx==nums.size()){\\n           ans++;\\n       }\\n    else {if (!m[nums[idx]+k] && !m[nums[idx]-k]){\\n           m[nums[idx]]++;\\n           f(nums,k,idx+1,m);\\n           m[nums[idx]]--;\\n       }\\n       f(nums,k,idx+1,m);\\n    }}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        map<int,int>m;\\n         f(nums,k,0,m);\\n         return ans-1;\\n    }\\n};\\n```\\n**Please, UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint ans=0;\\n    void f(vector<int>&nums,int k,int idx,map<int,int>&m){\\n       if(idx==nums.size()){\\n           ans++;\\n       }\\n    else {if (!m[nums[idx]+k] && !m[nums[idx]-k]){\\n           m[nums[idx]]++;\\n           f(nums,k,idx+1,m);\\n           m[nums[idx]]--;\\n       }\\n       f(nums,k,idx+1,m);\\n    }}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        map<int,int>m;\\n         f(nums,k,0,m);\\n         return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324030,
                "title": "simple-backtracking-approach-using-arrays-as-map",
                "content": "```\\nclass Solution {\\n    vector<int> mp;\\npublic:\\n    int solver(int ind,vector<int>& a,int d){\\n        if(ind>=a.size())\\n            return 1;\\n        int next=solver(ind+1,a,d);\\n        if(a[ind]<d or (a[ind]>=d and !mp[a[ind]-d])){\\n            mp[a[ind]]++;\\n            next+=solver(ind+1,a,d);\\n            mp[a[ind]]--;\\n        }\\n        return next;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        mp.resize(a.back()+10,0);\\n        return solver(0,a,k)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> mp;\\npublic:\\n    int solver(int ind,vector<int>& a,int d){\\n        if(ind>=a.size())\\n            return 1;\\n        int next=solver(ind+1,a,d);\\n        if(a[ind]<d or (a[ind]>=d and !mp[a[ind]-d])){\\n            mp[a[ind]]++;\\n            next+=solver(ind+1,a,d);\\n            mp[a[ind]]--;\\n        }\\n        return next;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& a, int k) {\\n        sort(a.begin(),a.end());\\n        mp.resize(a.back()+10,0);\\n        return solver(0,a,k)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323729,
                "title": "accepted-c-solution-using-backtracking",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> cur;\\n    int cnt=0;\\n    void solve(int i,int k,vector<int>& nums){\\n        if(i==nums.size()){\\n            if(cur.size()) {\\n                cnt++;\\n            }\\n            return;\\n        }\\n        bool f=0;\\n        if(cur.size()){\\n            if(find(cur.begin(),cur.end(),-k+nums[i])==cur.end()){\\n                f=1;\\n            }\\n        }\\n        else f=1;\\n        if(f){\\n            cur.push_back(nums[i]);\\n            solve(i+1,k,nums);\\n            cur.pop_back();\\n        }\\n        solve(i+1,k,nums);\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k){\\n        vector<int> v=nums;\\n        sort(v.begin(),v.end());\\n        solve(0,k,v);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> cur;\\n    int cnt=0;\\n    void solve(int i,int k,vector<int>& nums){\\n        if(i==nums.size()){\\n            if(cur.size()) {\\n                cnt++;\\n            }\\n            return;\\n        }\\n        bool f=0;\\n        if(cur.size()){\\n            if(find(cur.begin(),cur.end(),-k+nums[i])==cur.end()){\\n                f=1;\\n            }\\n        }\\n        else f=1;\\n        if(f){\\n            cur.push_back(nums[i]);\\n            solve(i+1,k,nums);\\n            cur.pop_back();\\n        }\\n        solve(i+1,k,nums);\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k){\\n        vector<int> v=nums;\\n        sort(v.begin(),v.end());\\n        solve(0,k,v);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323433,
                "title": "python-dfs",
                "content": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = [0]\\n        self.helper([], 0, nums, res, k)\\n        return res[0]\\n    \\n    def helper(self, curr, index, nums, res, k):\\n        if curr:\\n            res[0] += 1\\n        if index == len(nums):\\n            return        \\n        for i in range(index, len(nums)):\\n            if nums[i] - k in curr:\\n                continue\\n            curr.append(nums[i])\\n            self.helper(curr, i + 1, nums, res, k)\\n            curr.pop()\\n\\t\\t\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res = [0]\\n        self.helper([], 0, nums, res, k)\\n        return res[0]\\n    \\n    def helper(self, curr, index, nums, res, k):\\n        if curr:\\n            res[0] += 1\\n        if index == len(nums):\\n            return        \\n        for i in range(index, len(nums)):\\n            if nums[i] - k in curr:\\n                continue\\n            curr.append(nums[i])\\n            self.helper(curr, i + 1, nums, res, k)\\n            curr.pop()\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3323405,
                "title": "typescript-time-complexity-o-nlogn-space-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction beautifulSubsets(nums: number[], k: number): number {\\n   // Create a Map to group the elements of nums into subsets based on their remainders when divided by k\\n   const mp = new Map<number, number[]>();\\n   for (let i = 0; i < nums.length; i++) {\\n      const el = nums[i];\\n      const modVal = el % k;\\n      if (!mp.has(modVal)) {\\n         mp.set(modVal, []);\\n      }\\n      mp.get(modVal)!.push(el); // Add the element to the corresponding subset in mp\\n   }\\n\\n   let ans = 1;\\n   // Loop through each subset in mp\\n   for (const [modVal, v] of mp) {\\n      // Sort the elements in ascending order\\n      v.sort((a, b) => a - b);\\n      // Create another Map to count the frequency of each element\\n      const mp2 = new Map<number, number>();\\n      for (let i = 0; i < v.length; i++) {\\n         const el = v[i];\\n         if (!mp2.has(el)) {\\n            mp2.set(el, 0);\\n         }\\n         mp2.set(el, mp2.get(el)! + 1); // Increment the frequency of the element in mp2\\n      }\\n\\n      // Initialize variables for dynamic programming\\n      let prevEl = Number.MIN_SAFE_INTEGER, prevNotTaken = 1, prevTaken = 0, nowNotTaken = 0, nowTaken = 0;\\n      // Iterate over each element in the subset and compute the number of beautiful subsets that can be formed using it\\n      for (const [el, freq] of mp2) {\\n         const possSubsets = (1 << freq) - 1; // Compute the number of possible subsets that can be formed using the element\\n         if (prevEl + k === el) { // If the element and the previous element form a beautiful pair\\n            nowNotTaken = prevNotTaken + prevTaken; // The current element can be either taken or not taken\\n            nowTaken = prevNotTaken * possSubsets; // The current element can be taken, combined with any previous not-taken elements\\n         } else { // If the element and the previous element don\\'t form a beautiful pair\\n            nowNotTaken = prevNotTaken + prevTaken; // The current element can be either taken or not taken\\n            nowTaken = (prevNotTaken + prevTaken) * possSubsets; // The current element can be taken, combined with any previous elements\\n         }\\n         prevNotTaken = nowNotTaken;\\n         prevTaken = nowTaken;\\n         prevEl = el;\\n      }\\n\\n      ans *= nowNotTaken + nowTaken; // Multiply the number of beautiful subsets for the current subset\\n   }\\n\\n   return ans - 1; // Return the total number of beautiful subsets, minus one to exclude the empty subset\\n}\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction beautifulSubsets(nums: number[], k: number): number {\\n   // Create a Map to group the elements of nums into subsets based on their remainders when divided by k\\n   const mp = new Map<number, number[]>();\\n   for (let i = 0; i < nums.length; i++) {\\n      const el = nums[i];\\n      const modVal = el % k;\\n      if (!mp.has(modVal)) {\\n         mp.set(modVal, []);\\n      }\\n      mp.get(modVal)!.push(el); // Add the element to the corresponding subset in mp\\n   }\\n\\n   let ans = 1;\\n   // Loop through each subset in mp\\n   for (const [modVal, v] of mp) {\\n      // Sort the elements in ascending order\\n      v.sort((a, b) => a - b);\\n      // Create another Map to count the frequency of each element\\n      const mp2 = new Map<number, number>();\\n      for (let i = 0; i < v.length; i++) {\\n         const el = v[i];\\n         if (!mp2.has(el)) {\\n            mp2.set(el, 0);\\n         }\\n         mp2.set(el, mp2.get(el)! + 1); // Increment the frequency of the element in mp2\\n      }\\n\\n      // Initialize variables for dynamic programming\\n      let prevEl = Number.MIN_SAFE_INTEGER, prevNotTaken = 1, prevTaken = 0, nowNotTaken = 0, nowTaken = 0;\\n      // Iterate over each element in the subset and compute the number of beautiful subsets that can be formed using it\\n      for (const [el, freq] of mp2) {\\n         const possSubsets = (1 << freq) - 1; // Compute the number of possible subsets that can be formed using the element\\n         if (prevEl + k === el) { // If the element and the previous element form a beautiful pair\\n            nowNotTaken = prevNotTaken + prevTaken; // The current element can be either taken or not taken\\n            nowTaken = prevNotTaken * possSubsets; // The current element can be taken, combined with any previous not-taken elements\\n         } else { // If the element and the previous element don\\'t form a beautiful pair\\n            nowNotTaken = prevNotTaken + prevTaken; // The current element can be either taken or not taken\\n            nowTaken = (prevNotTaken + prevTaken) * possSubsets; // The current element can be taken, combined with any previous elements\\n         }\\n         prevNotTaken = nowNotTaken;\\n         prevTaken = nowTaken;\\n         prevEl = el;\\n      }\\n\\n      ans *= nowNotTaken + nowTaken; // Multiply the number of beautiful subsets for the current subset\\n   }\\n\\n   return ans - 1; // Return the total number of beautiful subsets, minus one to exclude the empty subset\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323373,
                "title": "c-nlogn",
                "content": "# Observation \\n- If the two element have same value after doing mod with k ao it is only possible they have absolute diffrence of k and remember that there only have possibility not surity\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> mp;     //[[elm%k]-> [e1,e2,e3,.....en]]\\n\\n        for(auto x:nums){\\n            mp[x%k].push_back(x);\\n        }\\n        \\n        int ans=1;\\n        for(auto [_,v]:mp){\\n            map<int,int> mp1;\\n            for(auto x:v){\\n                mp1[x]++;\\n            }\\n\\n            int prev_elm=INT_MIN, prevElmNotTaken=1,prevElmTaken=0,currElmNotTaken=0,currElmTaken=0;\\n\\n            for(auto [elm,freq]:mp1){\\n                int poss_sub=pow(2,freq)-1;\\n                \\n                if(prev_elm+k==elm){\\n                    currElmNotTaken=prevElmNotTaken+prevElmTaken;\\n                    currElmTaken=prevElmNotTaken*poss_sub;\\n                }   \\n                else{\\n                    currElmNotTaken=prevElmNotTaken+prevElmTaken;\\n                    currElmTaken=(prevElmNotTaken+prevElmTaken)*poss_sub;\\n                }\\n\\n                prevElmNotTaken=currElmNotTaken;\\n                prevElmTaken=currElmTaken;\\n                prev_elm=elm;\\n            }\\n            ans*=(currElmNotTaken+currElmTaken);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,vector<int>> mp;     //[[elm%k]-> [e1,e2,e3,.....en]]\\n\\n        for(auto x:nums){\\n            mp[x%k].push_back(x);\\n        }\\n        \\n        int ans=1;\\n        for(auto [_,v]:mp){\\n            map<int,int> mp1;\\n            for(auto x:v){\\n                mp1[x]++;\\n            }\\n\\n            int prev_elm=INT_MIN, prevElmNotTaken=1,prevElmTaken=0,currElmNotTaken=0,currElmTaken=0;\\n\\n            for(auto [elm,freq]:mp1){\\n                int poss_sub=pow(2,freq)-1;\\n                \\n                if(prev_elm+k==elm){\\n                    currElmNotTaken=prevElmNotTaken+prevElmTaken;\\n                    currElmTaken=prevElmNotTaken*poss_sub;\\n                }   \\n                else{\\n                    currElmNotTaken=prevElmNotTaken+prevElmTaken;\\n                    currElmTaken=(prevElmNotTaken+prevElmTaken)*poss_sub;\\n                }\\n\\n                prevElmNotTaken=currElmNotTaken;\\n                prevElmTaken=currElmTaken;\\n                prev_elm=elm;\\n            }\\n            ans*=(currElmNotTaken+currElmTaken);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323284,
                "title": "c-solution-using-the-concept-of-subset-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void subset(int index, vector<int>& nums, int k, vector<int>& v, int& cnt) {\\n        if(index == nums.size()) return;\\n\\n        int flag = 0;\\n        for(int i=0;i<v.size();i++) {\\n            if(abs(v[i] - nums[index]) == k) flag = 1;\\n        }\\n\\n        if(!flag) {\\n            cnt++;\\n            v.push_back(nums[index]);\\n            subset(index+1, nums, k, v, cnt);\\n            v.pop_back();\\n            subset(index+1, nums, k, v, cnt);\\n        } else {\\n            subset(index+1, nums, k, v, cnt);\\n        }\\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> v;\\n        int res = 0;\\n        subset(0, nums, k, v, res);\\n        return res;\\n    }\\n};\\n```\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int subset(int index, vector<int>& nums, int k, \\n        unordered_map<int,int>& mp) {\\n        if(index == nums.size()) return 1;\\n\\n        int option1 = 0;\\n        if(!mp[nums[index] - k] && !mp[nums[index] + k]) {\\n            mp[nums[index]]++;\\n            option1 = subset(index+1, nums, k, mp);\\n            mp[nums[index]]--;\\n        }\\n        \\n        int option2 = subset(index+1, nums, k, mp);\\n        \\n        return option1 + option2;\\n\\n    }\\n        \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int res = subset(0, nums, k, mp);\\n        return res - 1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subset(int index, vector<int>& nums, int k, vector<int>& v, int& cnt) {\\n        if(index == nums.size()) return;\\n\\n        int flag = 0;\\n        for(int i=0;i<v.size();i++) {\\n            if(abs(v[i] - nums[index]) == k) flag = 1;\\n        }\\n\\n        if(!flag) {\\n            cnt++;\\n            v.push_back(nums[index]);\\n            subset(index+1, nums, k, v, cnt);\\n            v.pop_back();\\n            subset(index+1, nums, k, v, cnt);\\n        } else {\\n            subset(index+1, nums, k, v, cnt);\\n        }\\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> v;\\n        int res = 0;\\n        subset(0, nums, k, v, res);\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int subset(int index, vector<int>& nums, int k, \\n        unordered_map<int,int>& mp) {\\n        if(index == nums.size()) return 1;\\n\\n        int option1 = 0;\\n        if(!mp[nums[index] - k] && !mp[nums[index] + k]) {\\n            mp[nums[index]]++;\\n            option1 = subset(index+1, nums, k, mp);\\n            mp[nums[index]]--;\\n        }\\n        \\n        int option2 = subset(index+1, nums, k, mp);\\n        \\n        return option1 + option2;\\n\\n    }\\n        \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int res = subset(0, nums, k, mp);\\n        return res - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322915,
                "title": "easy-backtracking-count-map-java",
                "content": "# Complexity\\n2^n\\n# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        count(nums, new int[1001], 0, k);\\n        return count;\\n    }\\n\\n    public void count(int[] nums, int[] map, int start, int k) {\\n        for (int i = start; i < nums.length; i++) {\\n\\n            if ((nums[i] > k) && (map[nums[i]-k] > 0)) {\\n                continue;\\n            }\\n            map[nums[i]]++;\\n            count++;\\n            count(nums, map, i+1, k);\\n            map[nums[i]]--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        count(nums, new int[1001], 0, k);\\n        return count;\\n    }\\n\\n    public void count(int[] nums, int[] map, int start, int k) {\\n        for (int i = start; i < nums.length; i++) {\\n\\n            if ((nums[i] > k) && (map[nums[i]-k] > 0)) {\\n                continue;\\n            }\\n            map[nums[i]]++;\\n            count++;\\n            count(nums, map, i+1, k);\\n            map[nums[i]]--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322601,
                "title": "backtracking-using-an-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse an Array to store whatever you have previously stored\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThink about Backtracking, as the input size of the array will be smaller or equal to 20\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1001)\\n\\n# Code\\n```\\nclass Solution {\\n    int ans;\\npublic:\\n    void calc(vector<int>&v, vector<int>& nums, int i, int k)\\n    {\\n        if(i==nums.size())\\n        {\\n            ++ans;\\n            return;\\n        }\\n        if((nums[i]-k<0 || v[nums[i]-k]==0) && (nums[i]+k>1000 || v[nums[i]+k]==0))\\n        {\\n            v[nums[i]]++;\\n            calc(v,nums,i+1,k);\\n            v[nums[i]]--;\\n        }\\n        calc(v,nums,i+1,k);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ans=0;\\n        vector<int>v(1001,0);\\n        calc(v,nums,0,k);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int ans;\\npublic:\\n    void calc(vector<int>&v, vector<int>& nums, int i, int k)\\n    {\\n        if(i==nums.size())\\n        {\\n            ++ans;\\n            return;\\n        }\\n        if((nums[i]-k<0 || v[nums[i]-k]==0) && (nums[i]+k>1000 || v[nums[i]+k]==0))\\n        {\\n            v[nums[i]]++;\\n            calc(v,nums,i+1,k);\\n            v[nums[i]]--;\\n        }\\n        calc(v,nums,i+1,k);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        ans=0;\\n        vector<int>v(1001,0);\\n        calc(v,nums,0,k);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322553,
                "title": "c-easy-dfs-subset",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int freq[1001];\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        memset(freq,0,sizeof(freq));\\n        sort(nums.begin(),nums.end());\\n        return dfs(nums,0,k)-1; // minus empty set\\n    }\\n\\n    int dfs(vector<int>& nums, int index, int k){\\n        if(index>=nums.size()) return 1;\\n        int subset = 0;\\n        if(nums[index]-k<0 || freq[nums[index]-k]==0){\\n            freq[nums[index]]++;\\n            subset+=dfs(nums,index+1,k);\\n            freq[nums[index]]--;\\n        }\\n        subset+=dfs(nums,index+1,k);\\n        return subset;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int freq[1001];\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        memset(freq,0,sizeof(freq));\\n        sort(nums.begin(),nums.end());\\n        return dfs(nums,0,k)-1; // minus empty set\\n    }\\n\\n    int dfs(vector<int>& nums, int index, int k){\\n        if(index>=nums.size()) return 1;\\n        int subset = 0;\\n        if(nums[index]-k<0 || freq[nums[index]-k]==0){\\n            freq[nums[index]]++;\\n            subset+=dfs(nums,index+1,k);\\n            freq[nums[index]]--;\\n        }\\n        subset+=dfs(nums,index+1,k);\\n        return subset;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321870,
                "title": "a-few-solutions",
                "content": "Perform DFS + BT to count subsets via a 0-1 knapsack, ie. we `include` + `exclude` each `A[i]`<sup>th</sup> item and use a map `m` to count each `A[i]`<sup>th</sup> item included in the knapsack.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun beautifulSubsets(A: IntArray, K: Int): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (i == A.size)\\n                return 1\\n            var (include, exclude) = Pair(0, go(i + 1))\\n            if (m[A[i] - K] ?: 0 == 0 && m[A[i] + K] ?: 0 == 0) {\\n                m[A[i]] = (m[A[i]] ?: 0) + 1\\n                include = go(i + 1)\\n                m[A[i]] = (m[A[i]] ?: 0) - 1\\n            }\\n            return include + exclude\\n        }\\n        return go() - 1  // -1 to exclude the empty set\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet beautifulSubsets = (A, K, m = new Map()) => {\\n    let go = (i = 0) => {\\n        if (i == A.length)\\n            return 1;\\n        let [include, exclude] = [0, go(i + 1)];\\n        if (!(m.get(A[i] - K) || 0) && !(m.get(A[i] + K) || 0)) {\\n            m.set(A[i], (m.get(A[i]) || 0) + 1);\\n            include = go(i + 1);\\n            m.set(A[i], (m.get(A[i]) || 0) - 1);\\n        }\\n        return include + exclude;\\n    };\\n    return go() - 1;  // -1 to exclude the empty set\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], K: int) -> int:\\n        m = Counter()\\n        def go(i = 0):\\n            if i == len(A):\\n                return 1\\n            include, exclude = 0, go(i + 1)\\n            if not m[A[i] - K] and not m[A[i] + K]:\\n                m[A[i]] += 1\\n                include = go(i + 1)\\n                m[A[i]] -= 1\\n            return include + exclude\\n        return go() - 1  # -1 to exclude the empty set\\n```\\n\\n*Rust*\\n```\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\ntype Map = HashMap<i32, i32>;\\nimpl Solution {\\n    pub fn beautiful_subsets(A: VI, K: i32) -> i32 {\\n        let mut m = Map::new();\\n        fn go(A: &VI, K: i32, i: usize, m: &mut Map) -> i32 {\\n            if i == A.len() {\\n                return 1;\\n            }\\n            let (mut include, exclude) = (0, go(A, K, i + 1, m));\\n            if *m.entry(A[i] - K).or_insert(0) == 0 && *m.entry(A[i] + K).or_insert(0) == 0 {\\n                *m.entry(A[i]).or_insert(0) += 1;\\n                include = go(A, K, i + 1, m);\\n                *m.entry(A[i]).or_insert(0) -= 1;\\n            }\\n            include + exclude\\n        }\\n        go(&A, K, 0, &mut m) - 1  // -1 to exclude the empty set\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int beautifulSubsets(VI& A, int K, Map m = {}) {\\n        fun go = [&](auto i) {\\n            if (i == A.size())\\n                return 1;\\n            auto [include, exclude] = make_pair(0, go(i + 1));\\n            if (!m[A[i] - K] && !m[A[i] + K]) {\\n                ++m[A[i]];\\n                include = go(i + 1);\\n                --m[A[i]];\\n            }\\n            return include + exclude;\\n        };\\n        return go(0) - 1;  // -1 to exclude the empty set\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun beautifulSubsets(A: IntArray, K: Int): Int {\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (i == A.size)\\n                return 1\\n            var (include, exclude) = Pair(0, go(i + 1))\\n            if (m[A[i] - K] ?: 0 == 0 && m[A[i] + K] ?: 0 == 0) {\\n                m[A[i]] = (m[A[i]] ?: 0) + 1\\n                include = go(i + 1)\\n                m[A[i]] = (m[A[i]] ?: 0) - 1\\n            }\\n            return include + exclude\\n        }\\n        return go() - 1  // -1 to exclude the empty set\\n    }\\n}\\n```\n```\\nlet beautifulSubsets = (A, K, m = new Map()) => {\\n    let go = (i = 0) => {\\n        if (i == A.length)\\n            return 1;\\n        let [include, exclude] = [0, go(i + 1)];\\n        if (!(m.get(A[i] - K) || 0) && !(m.get(A[i] + K) || 0)) {\\n            m.set(A[i], (m.get(A[i]) || 0) + 1);\\n            include = go(i + 1);\\n            m.set(A[i], (m.get(A[i]) || 0) - 1);\\n        }\\n        return include + exclude;\\n    };\\n    return go() - 1;  // -1 to exclude the empty set\\n};\\n```\n```\\nclass Solution:\\n    def beautifulSubsets(self, A: List[int], K: int) -> int:\\n        m = Counter()\\n        def go(i = 0):\\n            if i == len(A):\\n                return 1\\n            include, exclude = 0, go(i + 1)\\n            if not m[A[i] - K] and not m[A[i] + K]:\\n                m[A[i]] += 1\\n                include = go(i + 1)\\n                m[A[i]] -= 1\\n            return include + exclude\\n        return go() - 1  # -1 to exclude the empty set\\n```\n```\\nuse std::collections::HashMap;\\ntype VI = Vec<i32>;\\ntype Map = HashMap<i32, i32>;\\nimpl Solution {\\n    pub fn beautiful_subsets(A: VI, K: i32) -> i32 {\\n        let mut m = Map::new();\\n        fn go(A: &VI, K: i32, i: usize, m: &mut Map) -> i32 {\\n            if i == A.len() {\\n                return 1;\\n            }\\n            let (mut include, exclude) = (0, go(A, K, i + 1, m));\\n            if *m.entry(A[i] - K).or_insert(0) == 0 && *m.entry(A[i] + K).or_insert(0) == 0 {\\n                *m.entry(A[i]).or_insert(0) += 1;\\n                include = go(A, K, i + 1, m);\\n                *m.entry(A[i]).or_insert(0) -= 1;\\n            }\\n            include + exclude\\n        }\\n        go(&A, K, 0, &mut m) - 1  // -1 to exclude the empty set\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, int>;\\n    using fun = function<int(int)>;\\n    int beautifulSubsets(VI& A, int K, Map m = {}) {\\n        fun go = [&](auto i) {\\n            if (i == A.size())\\n                return 1;\\n            auto [include, exclude] = make_pair(0, go(i + 1));\\n            if (!m[A[i] - K] && !m[A[i] + K]) {\\n                ++m[A[i]];\\n                include = go(i + 1);\\n                --m[A[i]];\\n            }\\n            return include + exclude;\\n        };\\n        return go(0) - 1;  // -1 to exclude the empty set\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321769,
                "title": "classic-backtracking-java",
                "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n\\n        // This sort is doing magic \\n        Arrays.sort(nums);\\n\\n        solve(0 , new ArrayList<>() , nums , k);\\n        return count;\\n    }\\n\\n    public void solve(int index ,\\n     List<Integer> list , \\n     int[] arr , \\n     int k){\\n\\n        if(index == arr.length){\\n            if(list.size()>0){\\n                count++;\\n            }\\n            return;\\n        }\\n\\n        if(!list.contains(arr[index]-k)){\\n            list.add(arr[index]);\\n            solve(index + 1, list , arr , k);\\n            list.remove(list.size()-1);\\n        }\\n        solve(index + 1, list , arr , k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) {\\n\\n        // This sort is doing magic \\n        Arrays.sort(nums);\\n\\n        solve(0 , new ArrayList<>() , nums , k);\\n        return count;\\n    }\\n\\n    public void solve(int index ,\\n     List<Integer> list , \\n     int[] arr , \\n     int k){\\n\\n        if(index == arr.length){\\n            if(list.size()>0){\\n                count++;\\n            }\\n            return;\\n        }\\n\\n        if(!list.contains(arr[index]-k)){\\n            list.add(arr[index]);\\n            solve(index + 1, list , arr , k);\\n            list.remove(list.size()-1);\\n        }\\n        solve(index + 1, list , arr , k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320508,
                "title": "c-easy-solution-using-recursion-and-binary-search-runtime-faster-than-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a modified version of recursive problems depending on pick and not pick elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, we have to find number of subsets does not containining two integers having absolute difference equal to k. For finding such subsets we have to traverse through the `nums` and store elements in a result vector following two paths either pick or not pick element at given index. We will pick the element at given index `(nums[ind])` only if `nums[ind]-k` is not present in the result vector. We will use Binary Search in order to find `nums[ind]-k` in result vector.\\n\\nFor applying Binary Search, we have to first sort the given vector `nums`. Then in the recursive function when index reaches end of nums we will check if the result vector contains any element or not. If it does we return 1 else we return 0.\\n\\nWe will proceed with **not_pick** case every time but wiil consider **pick** case only when `nums[ind]-k` is not present in result vector.\\n\\nAt the end, we will return the value of `pick+not_pick`.\\n\\n# Complexity\\n- Time complexity: $$O(2^N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int BinarySearch(vector<int>& arr,int x){\\n        int start=0, end=arr.size()-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid]==x) return true;\\n            else if(arr[mid]>x) end=mid-1;\\n            else start=mid+1;\\n        }\\n        return false;\\n    }\\n\\n    int recf(int ind,vector<int>& nums,vector<int>& ds,int k){\\n        if(ind==nums.size()){\\n            if(ds.size()) return 1;\\n            return 0;\\n        }\\n        int pick=0, not_pick=0;\\n        not_pick=recf(ind+1,nums,ds,k);\\n        if(!BinarySearch(ds,nums[ind]-k)){\\n            ds.push_back(nums[ind]);\\n            pick=recf(ind+1,nums,ds,k);\\n            ds.pop_back();\\n        }\\n        return pick+not_pick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> ds;\\n        sort(nums.begin(),nums.end());\\n        return recf(0,nums,ds,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int BinarySearch(vector<int>& arr,int x){\\n        int start=0, end=arr.size()-1;\\n        while(start<=end){\\n            int mid=start+(end-start)/2;\\n            if(arr[mid]==x) return true;\\n            else if(arr[mid]>x) end=mid-1;\\n            else start=mid+1;\\n        }\\n        return false;\\n    }\\n\\n    int recf(int ind,vector<int>& nums,vector<int>& ds,int k){\\n        if(ind==nums.size()){\\n            if(ds.size()) return 1;\\n            return 0;\\n        }\\n        int pick=0, not_pick=0;\\n        not_pick=recf(ind+1,nums,ds,k);\\n        if(!BinarySearch(ds,nums[ind]-k)){\\n            ds.push_back(nums[ind]);\\n            pick=recf(ind+1,nums,ds,k);\\n            ds.pop_back();\\n        }\\n        return pick+not_pick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> ds;\\n        sort(nums.begin(),nums.end());\\n        return recf(0,nums,ds,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320491,
                "title": "c-solution-using-simple-backtracking-and-a-compare-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe need to calculate the number of subsets so our minds should move towards concepts like recursion and backtracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nbefore adding an element to the subset we check whether it follows the given property. the check function checks whether there is an element already present int the subset that has differnce to the current element as k if yes we do not take the element in the subset . if no then we include the current element\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince each element in nums has 2 choices whether to be included in the subset or not. time complexity is O(2^n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using a output vector to keep track of the elements in the subset we are using at max O(n) extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(int key,vector<int> &output,int diff)\\n    {\\n        for(auto x:output)\\n        {\\n            if(abs(x-key)==diff)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int rec(vector<int> &nums,int k,int i,vector<int> &output)\\n    {\\n        \\n        if(i>=nums.size() &&output.size()!=0)\\n            return 1;\\n         else if(i>=nums.size())\\n            return 0;\\n        //take\\n        int take=0;\\n        if(check(nums[i],output,k))\\n        {\\n            output.push_back(nums[i]);\\n            take =rec(nums,k,i+1,output);\\n            output.pop_back();\\n        }\\n        int notTake= rec(nums,k,i+1,output);\\n        return (take+notTake);\\n        \\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> output;\\n        return rec(nums,k,0,output);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(int key,vector<int> &output,int diff)\\n    {\\n        for(auto x:output)\\n        {\\n            if(abs(x-key)==diff)\\n                return false;\\n        }\\n        return true;\\n    }\\n    int rec(vector<int> &nums,int k,int i,vector<int> &output)\\n    {\\n        \\n        if(i>=nums.size() &&output.size()!=0)\\n            return 1;\\n         else if(i>=nums.size())\\n            return 0;\\n        //take\\n        int take=0;\\n        if(check(nums[i],output,k))\\n        {\\n            output.push_back(nums[i]);\\n            take =rec(nums,k,i+1,output);\\n            output.pop_back();\\n        }\\n        int notTake= rec(nums,k,i+1,output);\\n        return (take+notTake);\\n        \\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        vector<int> output;\\n        return rec(nums,k,0,output);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319861,
                "title": "c-using-recursion",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int a[1001];\\n    int solve(int i,vector<int>&nums,int k){\\n\\n        if(i==nums.size()){\\n            return 1;\\n        }\\n\\n        int taken=0,notTaken=0;\\n         \\n         if((nums[i]-k)<0 ||(a[nums[i]-k]==0)){\\n             a[nums[i]]++;\\n             taken+=solve(i+1,nums,k);\\n             a[nums[i]]--;\\n         }\\n\\n         notTaken+=solve(i+1,nums,k);\\n\\n         return taken+notTaken;\\n\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        memset(a,0,sizeof(a));\\n\\n        return solve(0,nums,k)-1; // Minus 1 due to empty subset\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int a[1001];\\n    int solve(int i,vector<int>&nums,int k){\\n\\n        if(i==nums.size()){\\n            return 1;\\n        }\\n\\n        int taken=0,notTaken=0;\\n         \\n         if((nums[i]-k)<0 ||(a[nums[i]-k]==0)){\\n             a[nums[i]]++;\\n             taken+=solve(i+1,nums,k);\\n             a[nums[i]]--;\\n         }\\n\\n         notTaken+=solve(i+1,nums,k);\\n\\n         return taken+notTaken;\\n\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        memset(a,0,sizeof(a));\\n\\n        return solve(0,nums,k)-1; // Minus 1 due to empty subset\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319721,
                "title": "java-knapsack-solution-easy-to-read",
                "content": "# Code\\n```\\nclass Solution {\\n    int count = 0;\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        helper(nums, k, 0, new HashSet<>());\\n        return count;\\n    }   \\n    void helper(int[] nums, int k, int i, HashSet<Integer> curr){\\n        if(i == nums.length){\\n            if(curr.size() > 0) count++;\\n            \\n            return;\\n        }\\n        \\n        //Include the element\\n        boolean canInclude = !curr.contains(nums[i] - k);\\n        if(canInclude){\\n            if(curr.contains(nums[i])){\\n                helper(nums, k, i + 1, curr);\\n            } else {\\n                curr.add(nums[i]);\\n                helper(nums, k, i + 1, curr);\\n                curr.remove(nums[i]);\\n            }\\n        }\\n        \\n        //Exclude the element\\n        helper(nums, k, i + 1, curr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int count = 0;\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        helper(nums, k, 0, new HashSet<>());\\n        return count;\\n    }   \\n    void helper(int[] nums, int k, int i, HashSet<Integer> curr){\\n        if(i == nums.length){\\n            if(curr.size() > 0) count++;\\n            \\n            return;\\n        }\\n        \\n        //Include the element\\n        boolean canInclude = !curr.contains(nums[i] - k);\\n        if(canInclude){\\n            if(curr.contains(nums[i])){\\n                helper(nums, k, i + 1, curr);\\n            } else {\\n                curr.add(nums[i]);\\n                helper(nums, k, i + 1, curr);\\n                curr.remove(nums[i]);\\n            }\\n        }\\n        \\n        //Exclude the element\\n        helper(nums, k, i + 1, curr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319498,
                "title": "simple-c-solution-using-hashmap-knapsack",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int help(int i,unordered_map<int,bool> &m,vector<int>&nums,int k){\\n        if(i<0){\\n            if(!m.size())    return 0;  //only if we have some values\\n            return 1;\\n        } \\n        int take=0;\\n        int nottake=help(i-1,m,nums,k); \\n        if(!m[nums[i]+k] && !m[nums[i]-k]){\\n            m[nums[i]]=true;        \\n            take=help(i-1,m,nums,k);         \\n            m[nums[i]]=false;\\n        }   \\n        return take+nottake;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,bool> m;\\n        return help(n-1,m,nums,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int help(int i,unordered_map<int,bool> &m,vector<int>&nums,int k){\\n        if(i<0){\\n            if(!m.size())    return 0;  //only if we have some values\\n            return 1;\\n        } \\n        int take=0;\\n        int nottake=help(i-1,m,nums,k); \\n        if(!m[nums[i]+k] && !m[nums[i]-k]){\\n            m[nums[i]]=true;        \\n            take=help(i-1,m,nums,k);         \\n            m[nums[i]]=false;\\n        }   \\n        return take+nottake;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,bool> m;\\n        return help(n-1,m,nums,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319396,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        HashSet<Integer> map = new HashSet<>();\\n        return getAns(0 , arr , map , k);\\n        \\n    }\\n    private int getAns(int i , int[] arr , HashSet<Integer> map , int k){\\n        if(i >= arr.length) return 0;\\n        int cur = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if(!map.contains(arr[j] - k)){\\n                cur++;\\n                map.add(arr[j]);\\n                cur += getAns(j+1 , arr , map , k);\\n                map.remove(arr[j]);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```\\n**Please UpVote, if found useful :)**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] arr, int k) {\\n        Arrays.sort(arr);\\n        HashSet<Integer> map = new HashSet<>();\\n        return getAns(0 , arr , map , k);\\n        \\n    }\\n    private int getAns(int i , int[] arr , HashSet<Integer> map , int k){\\n        if(i >= arr.length) return 0;\\n        int cur = 0;\\n        for(int j = i ; j < arr.length ; j++){\\n            if(!map.contains(arr[j] - k)){\\n                cur++;\\n                map.add(arr[j]);\\n                cur += getAns(j+1 , arr , map , k);\\n                map.remove(arr[j]);\\n            }\\n        }\\n        return cur;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319135,
                "title": "o-2-n-time-complexity-optimized-solution-accepted-with-complete-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to count all the subsets in which the condition given in the problem is satisfied for that we use recursion to generate all the subsets by simply using the concept of take and not take .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nimplementing the brute force approach is tricky and let me tell you one thing if you use map or set this will result in tle because of the usage of find and erase function which will be used while solving the question using map or set . \\n\\nSo to solve this problem in the given constraints first sort the array\\nthen while we are generating the subsets the only condition to check will be if(nums[i]-k) exists in the subset or not. Now we have to check only a single condition and we will check this in O(1) because for solving this problem we will take a simple vector of size max ele +1 where each index denotes frequency of the number, the maximum size of the vector can be 1000 acc to the constraints .\\n\\nso by using vector or array we can check the condition in O(1) and thus solving the problem in given constraints.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)// as we are checking/generating all the subsets  \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(Maxelement in the array)===O(max(nums)) \\n\\nUpvote if you like it...\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int solution(int i,int n,int k,vector<int>&nums,vector<int>&temp)\\n     {\\n       if(i==n)\\n       {\\n        return 1;\\n       }\\n       int notTaken=solution(i+1,n,k,nums,temp);\\n       int taken=0;\\n       if((nums[i]-k<0)||(temp[nums[i]-k]==0))\\n       {\\n           temp[nums[i]]++;\\n           taken=solution(i+1,n,k,nums,temp);\\n           temp[nums[i]]--;\\n       }\\n       return taken+notTaken;\\n     }\\n    int beautifulSubsets(vector<int>& nums, int k)\\n    {\\n      int n=nums.size();;\\n      unordered_map<int,int> m;\\n      sort(nums.begin(),nums.end());\\n      vector<int> temp(nums[n-1]+1,0);\\n      int i;\\n      return solution(0,n,k,nums,temp)-1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int solution(int i,int n,int k,vector<int>&nums,vector<int>&temp)\\n     {\\n       if(i==n)\\n       {\\n        return 1;\\n       }\\n       int notTaken=solution(i+1,n,k,nums,temp);\\n       int taken=0;\\n       if((nums[i]-k<0)||(temp[nums[i]-k]==0))\\n       {\\n           temp[nums[i]]++;\\n           taken=solution(i+1,n,k,nums,temp);\\n           temp[nums[i]]--;\\n       }\\n       return taken+notTaken;\\n     }\\n    int beautifulSubsets(vector<int>& nums, int k)\\n    {\\n      int n=nums.size();;\\n      unordered_map<int,int> m;\\n      sort(nums.begin(),nums.end());\\n      vector<int> temp(nums[n-1]+1,0);\\n      int i;\\n      return solution(0,n,k,nums,temp)-1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319035,
                "title": "java-2-n-hashset-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n=nums.length;\\n        return  subset(nums,0,n,k,new HashSet<>())-1;  \\n    }\\n \\n    public int subset(int[] nums,int i,int n,int k,HashSet<Integer> hm) {\\n        if(i==n)\\n        { \\n            return 1;\\n        }\\n        int k1=0,k2=0;\\n        if(!hm.contains(nums[i]+k) && !hm.contains(nums[i]-k))\\n        {\\n        boolean isCont=false;\\n        if(hm.contains(nums[i]))\\n        isCont=true;\\n        hm.add(nums[i]);\\n        k1=subset(nums,i+1,n,k,hm);\\n        if(!isCont)\\n        hm.remove(nums[i]);\\n        }\\n        k2=subset(nums,i+1,n,k,hm);\\n        return k1+k2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n=nums.length;\\n        return  subset(nums,0,n,k,new HashSet<>())-1;  \\n    }\\n \\n    public int subset(int[] nums,int i,int n,int k,HashSet<Integer> hm) {\\n        if(i==n)\\n        { \\n            return 1;\\n        }\\n        int k1=0,k2=0;\\n        if(!hm.contains(nums[i]+k) && !hm.contains(nums[i]-k))\\n        {\\n        boolean isCont=false;\\n        if(hm.contains(nums[i]))\\n        isCont=true;\\n        hm.add(nums[i]);\\n        k1=subset(nums,i+1,n,k,hm);\\n        if(!isCont)\\n        hm.remove(nums[i]);\\n        }\\n        k2=subset(nums,i+1,n,k,hm);\\n        return k1+k2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318940,
                "title": "c-backtracking-solution",
                "content": "# Approach\\nSimple backtracking where we check for current element whether another element with difference k exists in the current subset or not.\\n\\n# Complexity\\n- Time complexity: O(2^n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    \\n    int f(int index, vector<int>& nums, int k){\\n        if(index >= nums.size()){\\n            return 1;\\n        }\\n        int ans = 0;\\n        if(!mp[nums[index] - k]){\\n            mp[nums[index]]++;\\n            ans += f(index + 1, nums, k);\\n            mp[nums[index]]--;\\n        }\\n        ans += f(index + 1, nums, k);\\n        return ans;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        for(int i = 0, n = nums.size(); i < n;  i++){\\n            mp[nums[i]]++;\\n            cnt += f(i + 1, nums, k);\\n            mp[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int, int> mp;\\n    \\n    int f(int index, vector<int>& nums, int k){\\n        if(index >= nums.size()){\\n            return 1;\\n        }\\n        int ans = 0;\\n        if(!mp[nums[index] - k]){\\n            mp[nums[index]]++;\\n            ans += f(index + 1, nums, k);\\n            mp[nums[index]]--;\\n        }\\n        ans += f(index + 1, nums, k);\\n        return ans;\\n    }\\n    \\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int cnt = 0;\\n        for(int i = 0, n = nums.size(); i < n;  i++){\\n            mp[nums[i]]++;\\n            cnt += f(i + 1, nums, k);\\n            mp[nums[i]]--;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3318132,
                "title": "93-faster-backtracking",
                "content": "# Intuition\\nThe given problem requires us to find the number of beautiful subsets in the given array. A beautiful subset is a subset of array elements such that the absolute difference between any two elements of that subset is not equal to k.\\n\\nWe can solve this problem recursively using a backtracking approach. We can start by selecting the elements of the array one by one, and check if we can include them in our subset or not. If we can include the element, we move on to the next element, and if we cannot include the element, we backtrack and try with the next element. We keep a count of the number of beautiful subsets we find.\\n\\n# Approach\\nWe can use the backtracking approach to solve the problem. We will start with an empty subset and try to add elements one by one. For each element, we will check if it satisfies the condition of a beautiful subset. If it does, we will add it to our subset and continue recursively to add more elements. If it does not, we will backtrack and try with the next element. We will keep a count of the number of beautiful subsets we find.\\n\\n# Complexity\\n# Time complexity:\\n The time complexity of the algorithm depends on the number of beautiful subsets in the given array. Since we are checking each element for inclusion in the subset, the time complexity will be O(2^n), where n is the size of the input array.\\n\\n# Space complexity:\\n The space complexity of the algorithm is O(n), where n is the size of the input array. This is because we are using a vector to store the current subset we are working with.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int n = 0;\\n    bool check(vector<int>& nums, int x,int k)\\n    {\\n        int m = nums.size();\\n        if(m == 0)\\n            return 1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(abs(x-nums[i]) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void fun(vector<int>& nums,vector<int> &dp, int i,int k)\\n    {\\n        if(i >= n)\\n            return ;\\n        fun(nums,dp,i+1,k);\\n        if(i < n and check(dp,nums[i],k))\\n        {\\n            cnt++;\\n            dp.push_back(nums[i]);\\n            fun(nums,dp,i+1,k);\\n           dp.pop_back();\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        n = nums.size();\\n        vector<int> dp;\\n        fun(nums,dp,0,k);\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt = 0;\\n    int n = 0;\\n    bool check(vector<int>& nums, int x,int k)\\n    {\\n        int m = nums.size();\\n        if(m == 0)\\n            return 1;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            if(abs(x-nums[i]) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n    void fun(vector<int>& nums,vector<int> &dp, int i,int k)\\n    {\\n        if(i >= n)\\n            return ;\\n        fun(nums,dp,i+1,k);\\n        if(i < n and check(dp,nums[i],k))\\n        {\\n            cnt++;\\n            dp.push_back(nums[i]);\\n            fun(nums,dp,i+1,k);\\n           dp.pop_back();\\n        }\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        n = nums.size();\\n        vector<int> dp;\\n        fun(nums,dp,0,k);\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317955,
                "title": "easy-js-bruteforce-solution",
                "content": "Time complexity:\\nO(2^N)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar beautifulSubsets = function(nums, k) {\\n     //Inc Order\\n     nums.sort(function (a, b) {\\n       if (a > b) {\\n           return 1;\\n       }\\n       if (b > a) {\\n           return -1;\\n       }\\n       return 0;\\n      });\\n\\n     function helper(i, prev, beautiful, set) {\\n      if (i >= nums.length) {\\n        if(beautiful) {\\n          return 1;\\n        }\\n        return 0;\\n      }\\n      let count = helper(i+1, prev, beautiful, set);\\n      //Check Condition\\n      if(Math.abs(nums[i] - prev) !== k && !set.has(nums[i] - k)) {\\n        set.add(nums[i]);\\n        count += helper(i+1, nums[i], true, set);\\n        set.delete(nums[i]);\\n      }\\n      return count;\\n    }\\n    let res = helper(0, -Infinity, false, new Set());\\n    return res;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar beautifulSubsets = function(nums, k) {\\n     //Inc Order\\n     nums.sort(function (a, b) {\\n       if (a > b) {\\n           return 1;\\n       }\\n       if (b > a) {\\n           return -1;\\n       }\\n       return 0;\\n      });\\n\\n     function helper(i, prev, beautiful, set) {\\n      if (i >= nums.length) {\\n        if(beautiful) {\\n          return 1;\\n        }\\n        return 0;\\n      }\\n      let count = helper(i+1, prev, beautiful, set);\\n      //Check Condition\\n      if(Math.abs(nums[i] - prev) !== k && !set.has(nums[i] - k)) {\\n        set.add(nums[i]);\\n        count += helper(i+1, nums[i], true, set);\\n        set.delete(nums[i]);\\n      }\\n      return count;\\n    }\\n    let res = helper(0, -Infinity, false, new Set());\\n    return res;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3317918,
                "title": "c-recursion-backtracking",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nRecursion + Backtracking\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n```\\nO((2^N))\\n```\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nO(N)\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int v[1001]={0};\\n    int solve(int index,vector<int>& nums,int k){\\n        if(index==nums.size()){\\n            return 1;\\n        }\\n        int taken=0;\\n        if((nums[index]-k)<0 || v[nums[index]-k]==0){\\n            v[nums[index]]++;\\n            taken=solve(index+1,nums,k);\\n            v[nums[index]]--;\\n        }\\n        int not_taken=solve(index+1,nums,k);\\n        return taken+not_taken;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        return solve(0,nums,k)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nRecursion + Backtracking\\n```\n```\\nO((2^N))\\n```\n```\\nO(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int v[1001]={0};\\n    int solve(int index,vector<int>& nums,int k){\\n        if(index==nums.size()){\\n            return 1;\\n        }\\n        int taken=0;\\n        if((nums[index]-k)<0 || v[nums[index]-k]==0){\\n            v[nums[index]]++;\\n            taken=solve(index+1,nums,k);\\n            v[nums[index]]--;\\n        }\\n        int not_taken=solve(index+1,nums,k);\\n        return taken+not_taken;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        return solve(0,nums,k)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317751,
                "title": "python-8-line-solution-bottom-up-dp-method",
                "content": "```\\ndef beautifulSubsets(self, nums: List[int], k: int) -> int:\\n    cnter, ans = Counter(nums), 1\\n    for i in sorted(cnter):\\n        dp0, dp1 = 1, 0\\n        while(cnter[i]>0):\\n            dp0, dp1 = dp0+dp1, dp0*(2**(cnter[i])-1)\\n            cnter[i], i = 0, i+k\\n        ans *= (dp0+dp1)\\n    return ans-1\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulSubsets(self, nums: List[int], k: int) -> int:\\n    cnter, ans = Counter(nums), 1\\n    for i in sorted(cnter):\\n        dp0, dp1 = 1, 0\\n        while(cnter[i]>0):\\n            dp0, dp1 = dp0+dp1, dp0*(2**(cnter[i])-1)\\n            cnter[i], i = 0, i+k\\n        ans *= (dp0+dp1)\\n    return ans-1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3317511,
                "title": "very-simple-c-solution-using-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\nvoid  f(int ind,vector<int> &nums,int k,unordered_set<int> &s,int &count){\\n  count++;\\n  for(int j=ind;j<nums.size();j++){\\n      if(s.find(nums[j]-k)==s.end()){\\n         s.insert(nums[j]);\\n    f(j+1,nums,k,s,count);\\n    s.erase(nums[j]);\\n      }\\n  }\\n  \\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_set<int> s;\\n       sort(nums.begin(),nums.end());\\n        int count=-1;\\n        f(0,nums,k,s,count);\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\nvoid  f(int ind,vector<int> &nums,int k,unordered_set<int> &s,int &count){\\n  count++;\\n  for(int j=ind;j<nums.size();j++){\\n      if(s.find(nums[j]-k)==s.end()){\\n         s.insert(nums[j]);\\n    f(j+1,nums,k,s,count);\\n    s.erase(nums[j]);\\n      }\\n  }\\n  \\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_set<int> s;\\n       sort(nums.begin(),nums.end());\\n        int count=-1;\\n        f(0,nums,k,s,count);\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317396,
                "title": "c-dfs-hashset-o-2-n",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hashset in standard DFS to traverse the pre-sorted array.\\n# Complexity\\n- Time complexity: $$O(2^n)$$\\nAt each element of the array, there are 2 decisions: include or not include in the final subset.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ to store the values of the hash set.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int BeautifulSubsets(int[] nums, int k) {\\n        Array.Sort(nums);\\n        var res  = new int[1];\\n        dfs(nums, k, 0, new HashSet<int>(), res);\\n\\n        return res[0];\\n    }\\n\\n    private void dfs(int[] nums, int k, int idx, HashSet<int> cur, int[] res)\\n    {\\n        if (idx >= nums.Length)\\n        {\\n            return;\\n        }\\n\\n        if (!cur.Contains(nums[idx]-k))\\n        {\\n            cur.Add(nums[idx]);\\n            res[0]++;\\n            dfs(nums, k, idx+1, cur, res);\\n            cur.Remove(nums[idx]);\\n        }\\n\\n        dfs(nums, k, idx+1, cur, res);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int BeautifulSubsets(int[] nums, int k) {\\n        Array.Sort(nums);\\n        var res  = new int[1];\\n        dfs(nums, k, 0, new HashSet<int>(), res);\\n\\n        return res[0];\\n    }\\n\\n    private void dfs(int[] nums, int k, int idx, HashSet<int> cur, int[] res)\\n    {\\n        if (idx >= nums.Length)\\n        {\\n            return;\\n        }\\n\\n        if (!cur.Contains(nums[idx]-k))\\n        {\\n            cur.Add(nums[idx]);\\n            res[0]++;\\n            dfs(nums, k, idx+1, cur, res);\\n            cur.Remove(nums[idx]);\\n        }\\n\\n        dfs(nums, k, idx+1, cur, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317367,
                "title": "3-recursive-approaches-pick-and-not-pick-discussed",
                "content": "# Solution 1 Code WORKS\\n- Here we add a guy if we don\\'t see arr[i]-k guy already\\n- So we make only valid examples\\n- 2^N * Log N Operation\\n- Works out No TLE\\n```\\nclass Solution {\\n\\nint helper(int idx, int k, vector<int>& nums, vector<int>& ds){\\n    int N = nums.size();\\n    if(idx == N)\\n        return 0; // we explored pick and notpick for all 0 to n-1 eles\\n\\n    int notpick = helper(idx+1, k, nums, ds);\\n\\n    int pick = 0;\\n    if(!binary_search(ds.begin(), ds.end(), nums[idx] -k)){\\n        //no item that is violating cond\\n        //sorted so no need to check for +k cond\\n        ds.push_back(nums[idx]); // we can pick this now\\n        pick = 1 + helper(idx+1, k, nums, ds);\\n        ds.pop_back();\\n    }\\n\\n    return pick + notpick;\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n\\n        int ans = helper(0, k, nums, ds);\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n# Solution 2 Code  TLE\\n- Generate all 2^N Subsets \\n- Then check with a N^2 cond\\n- TLE\\n- As 2^N * N^2 exceeds 1e8\\n```\\nclass Solution {\\n\\nvoid helper(int idx, vector<int>& nums, vector<int>& ds, vector<vector<int>> &subs){\\n    subs.push_back(ds);\\n\\n    for(int i=idx; i<nums.size(); i++){\\n        ds.push_back(nums[i]);\\n        helper(i+1, nums, ds, subs);\\n        ds.pop_back();\\n    }\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n        vector<vector<int>> subs;\\n\\n        helper(0, nums, ds, subs);\\n\\n        int ctr = 0; //non beatutiful ctr\\n        for(auto s : subs){\\n            bool fg =  true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++){\\n                    if(abs(s[i] - s[j]) == k){\\n                        fg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(fg) ctr++;\\n        }    \\n        \\n        return ctr-1;\\n        \\n    }\\n};\\n```\\n\\n# Solution 3 Code TLE\\n- Tried to replace the O(N) internal j loop with bin search\\n- Still TLE\\n- As now its 2^n * n*logn\\n```\\nclass Solution {\\n\\nvoid helper(int idx, vector<int>& nums, vector<int>& ds, vector<vector<int>> &subs){\\n    subs.push_back(ds);\\n\\n    for(int i=idx; i<nums.size(); i++){\\n        ds.push_back(nums[i]);\\n        helper(i+1, nums, ds, subs);\\n        ds.pop_back();\\n    }\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n        vector<vector<int>> subs;\\n\\n        helper(0, nums, ds, subs);\\n\\n        int ctr = 0; //non beatutiful ctr\\n        for(auto s : subs){\\n            bool fg =  true;\\n            for(int i=0; i<s.size(); i++){\\n                if(binary_search(s.begin(), s.end(), s[i]-k) ||\\n                binary_search(s.begin(), s.end(), s[i]+k)){\\n                    fg = false;\\n                    break;\\n                }\\n            }\\n            if(fg) ctr++;\\n        }    \\n        \\n        return ctr-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\nint helper(int idx, int k, vector<int>& nums, vector<int>& ds){\\n    int N = nums.size();\\n    if(idx == N)\\n        return 0; // we explored pick and notpick for all 0 to n-1 eles\\n\\n    int notpick = helper(idx+1, k, nums, ds);\\n\\n    int pick = 0;\\n    if(!binary_search(ds.begin(), ds.end(), nums[idx] -k)){\\n        //no item that is violating cond\\n        //sorted so no need to check for +k cond\\n        ds.push_back(nums[idx]); // we can pick this now\\n        pick = 1 + helper(idx+1, k, nums, ds);\\n        ds.pop_back();\\n    }\\n\\n    return pick + notpick;\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n\\n        int ans = helper(0, k, nums, ds);\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n\\nvoid helper(int idx, vector<int>& nums, vector<int>& ds, vector<vector<int>> &subs){\\n    subs.push_back(ds);\\n\\n    for(int i=idx; i<nums.size(); i++){\\n        ds.push_back(nums[i]);\\n        helper(i+1, nums, ds, subs);\\n        ds.pop_back();\\n    }\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n        vector<vector<int>> subs;\\n\\n        helper(0, nums, ds, subs);\\n\\n        int ctr = 0; //non beatutiful ctr\\n        for(auto s : subs){\\n            bool fg =  true;\\n            for(int i=0; i<s.size(); i++){\\n                for(int j=i+1; j<s.size(); j++){\\n                    if(abs(s[i] - s[j]) == k){\\n                        fg = false;\\n                        break;\\n                    }\\n                }\\n            }\\n            if(fg) ctr++;\\n        }    \\n        \\n        return ctr-1;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n\\nvoid helper(int idx, vector<int>& nums, vector<int>& ds, vector<vector<int>> &subs){\\n    subs.push_back(ds);\\n\\n    for(int i=idx; i<nums.size(); i++){\\n        ds.push_back(nums[i]);\\n        helper(i+1, nums, ds, subs);\\n        ds.pop_back();\\n    }\\n}\\n\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int N = nums.size();\\n        sort(nums.begin(), nums.end());\\n        vector<int> ds;\\n        vector<vector<int>> subs;\\n\\n        helper(0, nums, ds, subs);\\n\\n        int ctr = 0; //non beatutiful ctr\\n        for(auto s : subs){\\n            bool fg =  true;\\n            for(int i=0; i<s.size(); i++){\\n                if(binary_search(s.begin(), s.end(), s[i]-k) ||\\n                binary_search(s.begin(), s.end(), s[i]+k)){\\n                    fg = false;\\n                    break;\\n                }\\n            }\\n            if(fg) ctr++;\\n        }    \\n        \\n        return ctr-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317362,
                "title": "backtracking-code-c",
                "content": "Backtracking the solns and returning the number -1 to account for the empty set. \\nAs n<20 we can use backtracking (DFS)\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int res;\\n    void backtrack(vector<int>& nums,int k,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            res++;\\n            return;\\n        }\\n        if(m[nums[index]-k] == 0 && m[nums[index]+k]==0)\\n        {\\n            m[nums[index]]++;\\n            backtrack(nums,k,index+1);\\n            m[nums[index]]--;\\n        }\\n        backtrack(nums,k,index+1);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        m.clear();\\n        res=0;\\n        backtrack(nums,k,0);\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,int> m;\\n    int res;\\n    void backtrack(vector<int>& nums,int k,int index)\\n    {\\n        if(index==nums.size())\\n        {\\n            res++;\\n            return;\\n        }\\n        if(m[nums[index]-k] == 0 && m[nums[index]+k]==0)\\n        {\\n            m[nums[index]]++;\\n            backtrack(nums,k,index+1);\\n            m[nums[index]]--;\\n        }\\n        backtrack(nums,k,index+1);\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        m.clear();\\n        res=0;\\n        backtrack(nums,k,0);\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317280,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<Integer>();\\n        return find(nums,set,0,k);\\n    }\\n    \\n    public int find(int[] nums, Set<Integer> set, int i, int k)\\n    {\\n        if(i>=nums.length)\\n            return 0;\\n        int count = 0;\\n\\n        for(int j =i;j<nums.length;j++)\\n        {\\n            if(!set.contains(nums[j]-k))\\n            {\\n                set.add(nums[j]);\\n                count = count + 1 +find(nums,set,j+1,k);\\n                set.remove(nums[j]);\\n            }\\n        }    \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> set = new HashSet<Integer>();\\n        return find(nums,set,0,k);\\n    }\\n    \\n    public int find(int[] nums, Set<Integer> set, int i, int k)\\n    {\\n        if(i>=nums.length)\\n            return 0;\\n        int count = 0;\\n\\n        for(int j =i;j<nums.length;j++)\\n        {\\n            if(!set.contains(nums[j]-k))\\n            {\\n                set.add(nums[j]);\\n                count = count + 1 +find(nums,set,j+1,k);\\n                set.remove(nums[j]);\\n            }\\n        }    \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3317089,
                "title": "java-dp-soln-o-n-4ms",
                "content": "inspired by @lee215 without sort\\nLook for the start of a chain of values with k difference put them in an array and do dynamic programining on them\\n# Code\\nO(N)\\n```\\npublic int beautifulSubsets(int[] nums, int k) {\\n    //maps number to frequency\\n    Map < Integer, Integer > numToFreq = new HashMap < > ();\\n    for (int num: nums) {\\n        numToFreq.put(num, numToFreq.getOrDefault(num, 0) + 1);\\n    }\\n    int res = 1;\\n    for (Map.Entry< Integer, Integer> entry: numToFreq.entrySet()) {\\n        int key = entry.getKey();\\n        //checks if value starts chain of k difference values\\n        if (!numToFreq.containsKey(key - k)) {\\n            //speed up for lone values\\n            if (!numToFreq.containsKey(key + k)) {\\n                res *= (1 << numToFreq.get(key));\\n                continue;\\n            }\\n            //list of k difference values frequencies\\n            List<Integer> kDiff = new ArrayList<>();\\n            kDiff.add(numToFreq.get(key));\\n            //adds freqs to list in ascending order\\n            while (numToFreq.containsKey(key + k)) {\\n                key += k;\\n                kDiff.add(numToFreq.get(key));\\n            }\\n            int subsetWithout = 0, subsetWith = 0;\\n            //dynamic programming\\n            for (int freq: kDiff) {\\n                //subsets from 0..i-2\\n                subsetWithout = subsetWith + subsetWithout;\\n                //subsets of current value * (subsets 0..i-2 + subset of self)\\n                subsetWith = ((1 << freq) - 1) * ((subsetWithout - subsetWith) + 1 );\\n            }\\n            //plus one to add empty subset\\n            res *= (subsetWith + subsetWithout + 1);\\n        }\\n    }\\n    //remove set of empty values\\n    return res - 1;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Counting"
                ],
                "code": "```\\npublic int beautifulSubsets(int[] nums, int k) {\\n    //maps number to frequency\\n    Map < Integer, Integer > numToFreq = new HashMap < > ();\\n    for (int num: nums) {\\n        numToFreq.put(num, numToFreq.getOrDefault(num, 0) + 1);\\n    }\\n    int res = 1;\\n    for (Map.Entry< Integer, Integer> entry: numToFreq.entrySet()) {\\n        int key = entry.getKey();\\n        //checks if value starts chain of k difference values\\n        if (!numToFreq.containsKey(key - k)) {\\n            //speed up for lone values\\n            if (!numToFreq.containsKey(key + k)) {\\n                res *= (1 << numToFreq.get(key));\\n                continue;\\n            }\\n            //list of k difference values frequencies\\n            List<Integer> kDiff = new ArrayList<>();\\n            kDiff.add(numToFreq.get(key));\\n            //adds freqs to list in ascending order\\n            while (numToFreq.containsKey(key + k)) {\\n                key += k;\\n                kDiff.add(numToFreq.get(key));\\n            }\\n            int subsetWithout = 0, subsetWith = 0;\\n            //dynamic programming\\n            for (int freq: kDiff) {\\n                //subsets from 0..i-2\\n                subsetWithout = subsetWith + subsetWithout;\\n                //subsets of current value * (subsets 0..i-2 + subset of self)\\n                subsetWith = ((1 << freq) - 1) * ((subsetWithout - subsetWith) + 1 );\\n            }\\n            //plus one to add empty subset\\n            res *= (subsetWith + subsetWithout + 1);\\n        }\\n    }\\n    //remove set of empty values\\n    return res - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3316865,
                "title": "simple-backtracking-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(2^N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) + O(N) -> space for map and a auxiliary stack space of recursion\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(vector<int> &nums, int i, int k, unordered_map<int,int> &mp) {\\n        if(i == nums.size()) return 1;\\n        int notPick = solve(nums,i+1,k,mp);\\n        int pick = 0;\\n        if(mp[k+nums[i]] == 0 && mp[nums[i]-k] == 0) {\\n            mp[nums[i]]++;\\n            pick = solve(nums,i+1,k,mp);\\n            mp[nums[i]]--;\\n        }\\n        return pick + notPick;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        return solve(nums,0,k,mp)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(vector<int> &nums, int i, int k, unordered_map<int,int> &mp) {\\n        if(i == nums.size()) return 1;\\n        int notPick = solve(nums,i+1,k,mp);\\n        int pick = 0;\\n        if(mp[k+nums[i]] == 0 && mp[nums[i]-k] == 0) {\\n            mp[nums[i]]++;\\n            pick = solve(nums,i+1,k,mp);\\n            mp[nums[i]]--;\\n        }\\n        return pick + notPick;\\n    }\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        return solve(nums,0,k,mp)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316857,
                "title": "dfs-in-python",
                "content": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        def dfs(idx,temp):\\n            if idx >= n:\\n                return \\n            # if temp and nums[idx] == temp[-1] + k:\\n            #     return \\n            for nxt in range(idx,n):\\n                if temp and (nums[nxt] + k in temp or nums[nxt] - k in temp):\\n                    continue\\n                temp.append(nums[nxt])\\n                res.append(list(temp))\\n                dfs(nxt+1,temp)\\n                temp.pop()\\n\\n        dfs(0,[])\\n        # print(res)\\n        return len(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = []\\n        def dfs(idx,temp):\\n            if idx >= n:\\n                return \\n            # if temp and nums[idx] == temp[-1] + k:\\n            #     return \\n            for nxt in range(idx,n):\\n                if temp and (nums[nxt] + k in temp or nums[nxt] - k in temp):\\n                    continue\\n                temp.append(nums[nxt])\\n                res.append(list(temp))\\n                dfs(nxt+1,temp)\\n                temp.pop()\\n\\n        dfs(0,[])\\n        # print(res)\\n        return len(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316754,
                "title": "2597-the-number-of-beautiful-subsets-java-solution",
                "content": "# Intuition\\nThis Java code implements a recursive solution to count the number of beautiful subsets in an array of integers nums with a given integer k. A subset is considered beautiful if for each element a in the subset, there is an element b in the subset such that a - b = k. The code stores all the beautiful subsets in an ArrayList of ArrayLists of integers arr.\\n\\n# Approach\\nThe $$find$$ function is a recursive function that takes the current index ind, the temporary ArrayList $$ temp $$, the array nums, and the integer k. If the current index is equal to the length of the array nums, it means we have reached the end of the array, so we add the temporary ArrayList to the arr ArrayList and return. Otherwise, we have two options: we can either include the current element in the temporary ArrayList temp, or we can skip it. If we decide to include it, we check if there is an element in the temporary ArrayList that is k less than the current element. If there is, we don\\'t include the current element, as it would violate the condition that the subset must be beautiful. Otherwise, we add the current element to the temporary ArrayList and call the find function recursively with the next index and the updated temporary ArrayList. After we finish with the recursive call, we remove the current element from the temporary ArrayList to backtrack and try the other option. If we decide to skip the current element, we call the find function recursively with the next index and the original temporary ArrayList.\\n\\nThe beautifulSubsets function is the main function that is called to count the number of beautiful subsets. If the length of the array nums is 0 or 1, we return the length of the array. Otherwise, we sort the array in ascending order, initialize an empty temporary ArrayList, and call the find function with the starting index, the temporary ArrayList, the sorted array, and the integer k. Finally, we retur\\n\\n# Complexity\\n- Time complexity:\\n$$ O(2^n) $$\\n\\n- Space complexity:\\n$$ O(2^n) $$\\n\\n# Code\\n```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> arr = new ArrayList<ArrayList<Integer>>();\\n    public void find(int ind,ArrayList<Integer> temp,int[] nums,int k)\\n    {\\n        if(ind==nums.length)\\n        {\\n            arr.add(temp);\\n            return;\\n        }\\n        //want to keep so check the condition\\n        if(temp.indexOf(nums[ind]-k)<0)\\n        {\\n            temp.add(nums[ind]);\\n            find(ind+1,temp,nums,k);\\n            temp.remove(temp.size()-1);\\n        }\\n        \\n        //dont wanna keep so no need to check the condition\\n        find(ind+1,temp,nums,k);\\n    }\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length==0 || nums.length==1)\\n            return nums.length;\\n        Arrays.sort(nums);\\n        ArrayList<Integer> temp = new ArrayList<Integer>();\\n        find(0,temp,nums,k);\\n        return arr.size()-1;\\n    }   \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> arr = new ArrayList<ArrayList<Integer>>();\\n    public void find(int ind,ArrayList<Integer> temp,int[] nums,int k)\\n    {\\n        if(ind==nums.length)\\n        {\\n            arr.add(temp);\\n            return;\\n        }\\n        //want to keep so check the condition\\n        if(temp.indexOf(nums[ind]-k)<0)\\n        {\\n            temp.add(nums[ind]);\\n            find(ind+1,temp,nums,k);\\n            temp.remove(temp.size()-1);\\n        }\\n        \\n        //dont wanna keep so no need to check the condition\\n        find(ind+1,temp,nums,k);\\n    }\\n    public int beautifulSubsets(int[] nums, int k) {\\n        if(nums.length==0 || nums.length==1)\\n            return nums.length;\\n        Arrays.sort(nums);\\n        ArrayList<Integer> temp = new ArrayList<Integer>();\\n        find(0,temp,nums,k);\\n        return arr.size()-1;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316698,
                "title": "groups-fibonacci",
                "content": "# Intuition\\nWe can sort the array and put numbers in groups based on the increment by k. Then in each group we will select numbers in a way that we never take 2 neighbor elements. Then we will multiply the number of selections in each groups with each other and reduce the final result by 1 (that is, the empty set). \\nThe calculation of the \"not neighbor\" selections is a known problem in combinatorics, and it equals the i-th Fibonacci number (if we start from 2).\\nWe will have to use a supporting map to handle duplicates. The array we use in the grouping will not contain any duplicates, and instead we will handle duplicates in the last step. We can shuffle the duplicates any way we want, so it\\'s the usual 2^n-1 number of subsets in a set.\\n\\n# Complexity\\n- Time complexity:\\nO(n log(n)) for sorting\\n\\n- Space complexity:\\nO(n) for supporting counting map and groups\\n\\n# Code\\n```\\nclass Solution {\\n    fun beautifulSubsets(nums: IntArray, k: Int): Int {\\n        val fib = mutableListOf<Int>(2,3)\\n        for (i in 2..1000) fib.add(fib[i-2] + fib[i-1])\\n\\n        val counts = HashMap<Int, Int>();\\n        nums.forEach { counts.merge(it, 1, Int::plus) }\\n        val nums1 = counts.keys.toList().sorted()\\n\\n        val groups = HashMap<Int, MutableSet<Int>>()\\n        nums1.forEach {\\n            groups.computeIfAbsent(it) {groups[it-k] ?: HashSet<Int>()}.add(it)\\n            groups.remove(it-k)\\n        }\\n        var result = 1\\n        groups.values.forEach {\\n            result *= fib[it.size-1]\\n            it.forEach {\\n                if (counts[it]!! > 1) result *= (2 shl (counts[it]!! - 1) - 1)\\n            }\\n        }\\n        return result - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun beautifulSubsets(nums: IntArray, k: Int): Int {\\n        val fib = mutableListOf<Int>(2,3)\\n        for (i in 2..1000) fib.add(fib[i-2] + fib[i-1])\\n\\n        val counts = HashMap<Int, Int>();\\n        nums.forEach { counts.merge(it, 1, Int::plus) }\\n        val nums1 = counts.keys.toList().sorted()\\n\\n        val groups = HashMap<Int, MutableSet<Int>>()\\n        nums1.forEach {\\n            groups.computeIfAbsent(it) {groups[it-k] ?: HashSet<Int>()}.add(it)\\n            groups.remove(it-k)\\n        }\\n        var result = 1\\n        groups.values.forEach {\\n            result *= fib[it.size-1]\\n            it.forEach {\\n                if (counts[it]!! > 1) result *= (2 shl (counts[it]!! - 1) - 1)\\n            }\\n        }\\n        return result - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316653,
                "title": "simple-c-solution-using-hasharray",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:2^(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1000)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0,n,k1;\\n    int mp[1001];\\n    int f(int i,vector<int>&nums){\\n        if(i>=n) {\\n          return 1;\\n        } \\n       int ntake= f(i+1,nums),take=0;\\n       if(((nums[i]+k1>=n||mp[nums[i]+k1]==0)&&(nums[i]-k1<0||mp[nums[i]-k1]==0))){ \\n        mp[nums[i]]++;\\n        take+= f(i+1,nums);\\n           mp[nums[i]]--;\\n        }\\n       return take+ntake; \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n         n=nums.size();\\n        k1=k;\\n        sort(nums.begin(),nums.end());\\n        memset(mp,0,sizeof(mp));\\n        return f(0,nums)-1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0,n,k1;\\n    int mp[1001];\\n    int f(int i,vector<int>&nums){\\n        if(i>=n) {\\n          return 1;\\n        } \\n       int ntake= f(i+1,nums),take=0;\\n       if(((nums[i]+k1>=n||mp[nums[i]+k1]==0)&&(nums[i]-k1<0||mp[nums[i]-k1]==0))){ \\n        mp[nums[i]]++;\\n        take+= f(i+1,nums);\\n           mp[nums[i]]--;\\n        }\\n       return take+ntake; \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n         n=nums.size();\\n        k1=k;\\n        sort(nums.begin(),nums.end());\\n        memset(mp,0,sizeof(mp));\\n        return f(0,nums)-1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316633,
                "title": "rust-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nimpl Solution {\\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut count = 0;\\n        let mut data = vec![];\\n        \\n        Self::backtracking(&mut data, &nums, k, 0, &mut count);\\n\\n        count\\n    }\\n\\n    fn backtracking(data: &mut Vec<i32>, nums: &Vec<i32>, k: i32, i: usize, count: &mut i32) {\\n        if i == nums.len() { return }\\n\\n        Self::backtracking(data, nums, k, i + 1, count);\\n\\n        let mut good = true;\\n        for j in 0 .. data.len() {\\n            if i32::abs(data[j] - nums[i]) != k { continue }\\n\\n            good = false;\\n            break \\n        }\\n        if good == false { return }\\n\\n        *count += 1; \\n        data.push(nums[i]);\\n        Self::backtracking(data, nums, k, i + 1, count);\\n        data.pop();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\\n        let mut count = 0;\\n        let mut data = vec![];\\n        \\n        Self::backtracking(&mut data, &nums, k, 0, &mut count);\\n\\n        count\\n    }\\n\\n    fn backtracking(data: &mut Vec<i32>, nums: &Vec<i32>, k: i32, i: usize, count: &mut i32) {\\n        if i == nums.len() { return }\\n\\n        Self::backtracking(data, nums, k, i + 1, count);\\n\\n        let mut good = true;\\n        for j in 0 .. data.len() {\\n            if i32::abs(data[j] - nums[i]) != k { continue }\\n\\n            good = false;\\n            break \\n        }\\n        if good == false { return }\\n\\n        *count += 1; \\n        data.push(nums[i]);\\n        Self::backtracking(data, nums, k, i + 1, count);\\n        data.pop();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3316579,
                "title": "go-python-o-n-log-n-k-time-o-n-k-space",
                "content": "# DFS with backtracking\\n- Time complexity: $$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc beautifulSubsets(nums []int, k int) int {\\n    visited := make(map[int]int)\\n    return dfs(0,&nums,visited,k)-1\\n}\\n\\nfunc dfs(idx int,nums *[]int,visited map[int]int,k int) int{\\n    if idx == len(*nums){\\n        return 1\\n    }\\n    num := (*nums)[idx]\\n    answer := 0\\n    if visited[num+k]==0 && visited[num-k]==0{\\n        visited[num]+=1\\n        answer+=dfs(idx+1,nums,visited,k)\\n        visited[num]-=1\\n    }\\n    answer+=dfs(idx+1,nums,visited,k)\\n    return answer\\n}\\n```\\n```python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        visited = defaultdict(int)\\n        return dfs(0,nums,visited,k)-1\\n\\ndef dfs(idx,nums,visited,k):\\n    if idx == len(nums):\\n        return 1\\n    num = nums[idx]\\n    answer = 0\\n    if visited[num+k]==0 and visited[num-k]==0:\\n        visited[num]+=1\\n        answer+=dfs(idx+1,nums,visited,k)\\n        visited[num]-=1\\n    answer+=dfs(idx+1,nums,visited,k)\\n    return answer\\n```\\n\\n# Dynamic programming\\n- Time complexity: $$O(n*log(n)+k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n+k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc beautifulSubsets(nums []int, k int) int {\\n    counter := make(map[int]int)\\n    array := []int{}\\n    for _,num := range(nums){\\n        if _,ok := counter[num]; !ok{\\n            array = append(array,num)\\n        }\\n        counter[num]++\\n    }\\n    sort.Ints(array)\\n    groups :=make(map[int][]int)\\n    for _,x :=range(array){\\n        groups[x],groups[x-k] = groups[x-k],groups[x]\\n        groups[x] = append(groups[x],x)\\n    }\\n    answer := 1\\n    for _,value := range(groups){\\n        prev := 1 \\n        curr := 1\\n        for _,x := range(value){\\n            prev, curr = curr, prev*(power_2(counter[x])-1) + curr\\n        }\\n        answer *= curr\\n    }\\n    return answer-1\\n}\\n\\nfunc power_2(i int) int{\\n    return int(math.Pow(2,float64(i)))\\n}\\n```\\n```python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        counter = Counter(nums)\\n        groups = defaultdict(list)\\n        for x in sorted(counter):\\n            groups[x],groups[x-k] = groups[x-k],groups[x]\\n            groups[x].append(x)\\n        answer = 1\\n        for value in groups.values(): \\n            prev = 1 \\n            curr = 1\\n            for x in value:\\n                prev, curr = curr, prev*(2**counter[x]-1) + curr\\n            answer *= curr\\n        return answer-1\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```golang []\\nfunc beautifulSubsets(nums []int, k int) int {\\n    visited := make(map[int]int)\\n    return dfs(0,&nums,visited,k)-1\\n}\\n\\nfunc dfs(idx int,nums *[]int,visited map[int]int,k int) int{\\n    if idx == len(*nums){\\n        return 1\\n    }\\n    num := (*nums)[idx]\\n    answer := 0\\n    if visited[num+k]==0 && visited[num-k]==0{\\n        visited[num]+=1\\n        answer+=dfs(idx+1,nums,visited,k)\\n        visited[num]-=1\\n    }\\n    answer+=dfs(idx+1,nums,visited,k)\\n    return answer\\n}\\n```\n```python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        visited = defaultdict(int)\\n        return dfs(0,nums,visited,k)-1\\n\\ndef dfs(idx,nums,visited,k):\\n    if idx == len(nums):\\n        return 1\\n    num = nums[idx]\\n    answer = 0\\n    if visited[num+k]==0 and visited[num-k]==0:\\n        visited[num]+=1\\n        answer+=dfs(idx+1,nums,visited,k)\\n        visited[num]-=1\\n    answer+=dfs(idx+1,nums,visited,k)\\n    return answer\\n```\n```golang []\\nfunc beautifulSubsets(nums []int, k int) int {\\n    counter := make(map[int]int)\\n    array := []int{}\\n    for _,num := range(nums){\\n        if _,ok := counter[num]; !ok{\\n            array = append(array,num)\\n        }\\n        counter[num]++\\n    }\\n    sort.Ints(array)\\n    groups :=make(map[int][]int)\\n    for _,x :=range(array){\\n        groups[x],groups[x-k] = groups[x-k],groups[x]\\n        groups[x] = append(groups[x],x)\\n    }\\n    answer := 1\\n    for _,value := range(groups){\\n        prev := 1 \\n        curr := 1\\n        for _,x := range(value){\\n            prev, curr = curr, prev*(power_2(counter[x])-1) + curr\\n        }\\n        answer *= curr\\n    }\\n    return answer-1\\n}\\n\\nfunc power_2(i int) int{\\n    return int(math.Pow(2,float64(i)))\\n}\\n```\n```python []\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        counter = Counter(nums)\\n        groups = defaultdict(list)\\n        for x in sorted(counter):\\n            groups[x],groups[x-k] = groups[x-k],groups[x]\\n            groups[x].append(x)\\n        answer = 1\\n        for value in groups.values(): \\n            prev = 1 \\n            curr = 1\\n            for x in value:\\n                prev, curr = curr, prev*(2**counter[x]-1) + curr\\n            answer *= curr\\n        return answer-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316513,
                "title": "memoizing-bitsets-in-top-down-dp",
                "content": "# Intuition\\nBreak down the problem into smaller recursive subproblems. For each element `nums[i]`, count the number of beautiful subsets that:\\n- Do include `nums[i]`: This must exclude any subsets containing `nums[i] + k`  and `nums[i] - k`. We can find these indices efficiently by maintaining a reverse map `m` of values to indices: `m[nums[i]] -> {i, ...}`, and we can keep track of banned indices efficiently using a bitset. We need to also count empty beautiful subsets since we already have at least one element. Thus: `count(start=i+1, banned = banned |= newlyBanned, emptyOk = true)`\\n- Don\\'t include `nums[i]`: `count(start=i+1, banned=banned, emptyOk=emptyOk)`\\n\\n# Complexity\\n- Time complexity:\\n`O(2^n)`\\n\\n- Space complexity:\\n`O(2^n)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        k_ = k;\\n        for(int i=0;i<nums.size();++i){\\n            // m_ maps values to indices of nums\\n            m_[nums[i]].push_back(i);\\n        }\\n        if(nums.empty()) return 0;\\n        return count(nums, 0, 0, false);\\n    }\\nprivate:\\n    // Counts the number of beautiful subsets of num \\n    // starting at index and excluding banned indices.\\n    // If empty ok, empty subsets are included in the count.\\n    int count(const vector<int>& nums, int i, int banned, bool emptyOk){\\n        // if(i==nums.size()) return 0;\\n        assert(i<nums.size()); // precondition\\n        // base case, the last element:\\n        // - use the last element if it\\'s not banned\\n        // - skip it if it\\'s ok to count the empty subarray\\n        if (i==nums.size()-1) return ((banned&(1<<i))==0) + emptyOk;\\n\\n        // 5 bits should be enough since i <= nums.size() <= 20 < 2^5\\n        assert((i&31)==i); \\n        // the memo key should encode all the factors that can influence the result:\\n        // - banned indices\\n        // - the start position\\n        // - whether it\\'s ok to count an empty subarray\\n        long long key = banned << 6 | i<<1 | emptyOk;\\n        auto it = memo_.find(key);\\n        if (it != memo_.end()) return it->second;\\n        int ans = 0;\\n        if(((1<<i)&banned)==0){\\n            // include index i\\n            int n = nums[i];\\n            int bannedNew = banned;\\n            for(int ii: m_[n+k_]) bannedNew |= 1<<ii;\\n            for(int ii: m_[n-k_]) bannedNew |= 1<<ii;\\n            // it\\'s ok to count empty subarrays now since we have at least one element\\n            ans += count(nums, i+1, bannedNew, true);\\n        }\\n        // exclude i\\n        ans += count(nums, i+1, banned, emptyOk);\\n        // avoid recomputing the same result in the future.\\n        memo_[key] = ans;\\n        return ans;\\n    }\\n    map<int, vector<int>> m_;\\n    map<long long, int> memo_;\\n    int k_;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        k_ = k;\\n        for(int i=0;i<nums.size();++i){\\n            // m_ maps values to indices of nums\\n            m_[nums[i]].push_back(i);\\n        }\\n        if(nums.empty()) return 0;\\n        return count(nums, 0, 0, false);\\n    }\\nprivate:\\n    // Counts the number of beautiful subsets of num \\n    // starting at index and excluding banned indices.\\n    // If empty ok, empty subsets are included in the count.\\n    int count(const vector<int>& nums, int i, int banned, bool emptyOk){\\n        // if(i==nums.size()) return 0;\\n        assert(i<nums.size()); // precondition\\n        // base case, the last element:\\n        // - use the last element if it\\'s not banned\\n        // - skip it if it\\'s ok to count the empty subarray\\n        if (i==nums.size()-1) return ((banned&(1<<i))==0) + emptyOk;\\n\\n        // 5 bits should be enough since i <= nums.size() <= 20 < 2^5\\n        assert((i&31)==i); \\n        // the memo key should encode all the factors that can influence the result:\\n        // - banned indices\\n        // - the start position\\n        // - whether it\\'s ok to count an empty subarray\\n        long long key = banned << 6 | i<<1 | emptyOk;\\n        auto it = memo_.find(key);\\n        if (it != memo_.end()) return it->second;\\n        int ans = 0;\\n        if(((1<<i)&banned)==0){\\n            // include index i\\n            int n = nums[i];\\n            int bannedNew = banned;\\n            for(int ii: m_[n+k_]) bannedNew |= 1<<ii;\\n            for(int ii: m_[n-k_]) bannedNew |= 1<<ii;\\n            // it\\'s ok to count empty subarrays now since we have at least one element\\n            ans += count(nums, i+1, bannedNew, true);\\n        }\\n        // exclude i\\n        ans += count(nums, i+1, banned, emptyOk);\\n        // avoid recomputing the same result in the future.\\n        memo_[key] = ans;\\n        return ans;\\n    }\\n    map<int, vector<int>> m_;\\n    map<long long, int> memo_;\\n    int k_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316494,
                "title": "java-easy-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSorting is first, and build solution from previous one step by step. For example, starting with subset with size 1, then building subset with size 2 based on previous subset with size 1, by checking if the HashSet contains the newly *adding element - k*.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    private int res;\\n    private int diff;\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        res = 0;\\n        diff = k;\\n        \\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        \\n        backtrack(nums, 0, new HashSet<Integer>(), -1);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, int start, Set<Integer> path, int last) {\\n        \\n        if (path.size() == 1) {\\n            res += 1;\\n        } else if (path.size() > 1) {\\n            if (last != -1 && !path.contains(last - diff)) {\\n                res += 1;\\n            }\\n            else return;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            path.add(nums[i]);\\n            backtrack(nums, i+1, path, nums[i]);\\n            path.remove(nums[i]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int res;\\n    private int diff;\\n    \\n    public int beautifulSubsets(int[] nums, int k) {\\n        res = 0;\\n        diff = k;\\n        \\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        \\n        backtrack(nums, 0, new HashSet<Integer>(), -1);\\n        \\n        return res;\\n    }\\n    \\n    private void backtrack(int[] nums, int start, Set<Integer> path, int last) {\\n        \\n        if (path.size() == 1) {\\n            res += 1;\\n        } else if (path.size() > 1) {\\n            if (last != -1 && !path.contains(last - diff)) {\\n                res += 1;\\n            }\\n            else return;\\n        }\\n        \\n        for (int i = start; i < nums.length; i++) {\\n            path.add(nums[i]);\\n            backtrack(nums, i+1, path, nums[i]);\\n            path.remove(nums[i]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316455,
                "title": "c-o-n-logn-order-by-quotient-and-count-iteratively",
                "content": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        //order numbers by remainder of k, so we can incremently build/count subset\\n        unordered_map<int, multiset<int>> rq; // remainder -> quotient when divide by k\\n        for(auto n : nums)\\n            rq[n%k].insert(n/k);\\n        \\n        int count = 1;// base: 1 empty subset\\n\\n        for(auto const& [r, qs] : rq) {\\n            int prevq = -2, curq = -2; // previous and current quotient values\\n            int prevqcount = 0, curqcount = 0; // #subsets containing prevq/curq\\n            for(auto q : qs) {\\n                if(q != curq) { // advance states\\n                    prevq = curq;\\n                    curq = q;\\n                    prevqcount = curqcount;\\n                    curqcount = 0;\\n                }\\n                // add curq to subset, excluding violation\\n                int qcount = count - (curq == prevq + 1 ? prevqcount : 0);\\n                count = count + qcount; //recursive step\\n\\n                curqcount += qcount; //update #subset containing curq\\n            }\\n        }\\n        return count - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        //order numbers by remainder of k, so we can incremently build/count subset\\n        unordered_map<int, multiset<int>> rq; // remainder -> quotient when divide by k\\n        for(auto n : nums)\\n            rq[n%k].insert(n/k);\\n        \\n        int count = 1;// base: 1 empty subset\\n\\n        for(auto const& [r, qs] : rq) {\\n            int prevq = -2, curq = -2; // previous and current quotient values\\n            int prevqcount = 0, curqcount = 0; // #subsets containing prevq/curq\\n            for(auto q : qs) {\\n                if(q != curq) { // advance states\\n                    prevq = curq;\\n                    curq = q;\\n                    prevqcount = curqcount;\\n                    curqcount = 0;\\n                }\\n                // add curq to subset, excluding violation\\n                int qcount = count - (curq == prevq + 1 ? prevqcount : 0);\\n                count = count + qcount; //recursive step\\n\\n                curqcount += qcount; //update #subset containing curq\\n            }\\n        }\\n        return count - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316425,
                "title": "beats-100-java-solution-using-disjoint-set-union",
                "content": "We have to create sets of items in such a way that each set contains those elements where difference between some two elements will be k. Suppose k = 1 and nums = [3, 2, 4, 1, 9, 10]. Then we will have two such sets namely [1, 2, 3, 4] and [9, 10].\\n\\nWe use DSU to find all such sets.\\n\\nThere is no problem when we choose elements across sets, ie. we can safely choose an element from set 1 and another from set 2. Problem occurs when we have to choose elements in the same set. \\n\\nConsider set [2, 4, 6].\\n0 elements = 1 way\\n1 elements = 3 ways\\n2 elements = 1 way\\nTotal = 1 + 3 + 1 ways = 5 ways.\\n\\nTo find the number of ways we can form a subset from each set we can use this method:\\nfibo(n) = fibo(n-1) + fibo(n-2) where fibo(0) == 1 and fibo(1) = 2.\\nThus we find a fibonacci series and it can be solved using DP as well which I chose to ignore.\\n\\nFinally we find product of contributions from each set and subtract by 1 as we can not include the empty set.\\n```\\nclass Solution {\\n    int[] parent;\\n    int[] size;\\n    int find(int i){\\n        if(parent[i] == i)\\n            return i;\\n        return parent[i] = find(parent[i]);\\n    }\\n    int fibo(int n){\\n        if(n == 0)\\n            return 1;\\n        if(n == 1)\\n            return 2;\\n        return fibo(n-1) + fibo(n-2);\\n    }\\n    void union(int i, int j){\\n        int leaderI = find(i);\\n        int leaderJ = find(j);\\n        if(leaderI == leaderJ)\\n            return;\\n        parent[leaderI] = leaderJ;\\n        size[leaderJ] += size[leaderI];\\n    }\\n    public int beautifulSubsets(int[] nums, int k) {\\n        int n = nums.length;\\n        parent = new int[n];\\n        size = new int[n];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0;i<n;i++){\\n            size[i] = 1;\\n            parent[i] = i;\\n            map.put(nums[i], i);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(map.containsKey(nums[i]-k)){\\n                int j = map.get(nums[i]-k);\\n                union(i, j);\\n            }\\n            if(map.containsKey(nums[i]+k)){\\n                int j = map.get(nums[i]+k);\\n                union(i, j);\\n            }\\n        }\\n        int result = 1;\\n        for(int i=0;i<n;i++)\\n            if(parent[i] == i)\\n                result *= fibo(size[i]);\\n        return result-1;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\n    int[] parent;\\n    int[] size;\\n    int find(int i){\\n        if(parent[i] == i)\\n            return i;\\n        return parent[i] = find(parent[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3316388,
                "title": "java-for-those-who-struggling-with-tle",
                "content": "# Intuition\\n\\nI have been struggling with TLE up to the end of the contest! Hate that!\\n\\nFew minutes ago I slightly changed the code which made it able to pass TLE. I\\'ve added sorting and this helps me to avoid checking `x+k` in subsets, I only left `x-k` check.\\n\\nThanks to https://leetcode.com/kalinga/ for the inspiration!\\n\\n# Approach\\n\\nGenerating all possible subsets adding new number only if they has no `x-k` number yet.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<>());\\n        for (int x : nums) {\\n            int ls = res.size();\\n            for (int i = 0; i < ls; i++) {\\n                if (res.get(i).contains(x - k))\\n                    continue;\\n                List<Integer> newlist = new ArrayList<>(res.get(i));\\n                newlist.add(x);\\n                res.add(newlist);\\n            }\\n        }\\n        return res.size() - 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        res.add(new ArrayList<>());\\n        for (int x : nums) {\\n            int ls = res.size();\\n            for (int i = 0; i < ls; i++) {\\n                if (res.get(i).contains(x - k))\\n                    continue;\\n                List<Integer> newlist = new ArrayList<>(res.get(i));\\n                newlist.add(x);\\n                res.add(newlist);\\n            }\\n        }\\n        return res.size() - 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316152,
                "title": "c-backtracking-time-o-n-2-n",
                "content": "# Intuition\\n`n <= 20` is relatively small, we can try to brute force (backtracking) it.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach 1\\nFor backtracking, we can decide to or not to include the `nums[i]` in our subset.\\nWe can always choose not to include a number.\\nBut we have to check if we are able to include a number based on the given condition (`abs(a - b) != k`)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n * 2^n)$$, runtime 4xx ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int res = 0;\\n        vector<int> subset;\\n        solve(nums, k, subset, res, 0);\\n        return res;\\n    }\\n\\nprivate:    \\n    void solve(vector<int>& nums, int k, vector<int>& subset, int& res, int i) {\\n        if (i == nums.size()) {\\n            res += subset.size() > 0;\\n            return;\\n        }\\n        \\n        solve(nums, k, subset, res, i + 1);\\n        if (canAdd(subset, nums[i], k)) {\\n            subset.emplace_back(nums[i]);\\n            solve(nums, k, subset, res, i + 1);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    bool canAdd(vector<int>& subset, int num, int k) {\\n        for (int ss : subset) {\\n            if (abs(ss - num) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n# Approach 2\\nUse bit mask to save the memory of `subset`,\\nbut the `canAdd()` would consume more time because it always runs `n` iterations.\\n\\n# Complexity\\n- Time complexity: $$O(n * 2^n)$$, runtime 7xx ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int res = 0;\\n        solve(nums, k, 0, res, 0);\\n        return res;\\n    }\\n\\nprivate: \\n    void solve(vector<int>& nums, int k, int mask, int& res, int i) {\\n        if (i == nums.size()) {\\n            res += mask > 0;\\n            return;\\n        }\\n        \\n        solve(nums, k, mask, res, i + 1);\\n        if (canAdd(nums, mask, nums[i], k)) {\\n            solve(nums, k, mask | (1 << i), res, i + 1);\\n        }\\n    }\\n   \\n    bool canAdd(vector<int>& nums, int mask, int num, int k) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if ((mask & (1 << i)) and abs(num - nums[i]) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int res = 0;\\n        vector<int> subset;\\n        solve(nums, k, subset, res, 0);\\n        return res;\\n    }\\n\\nprivate:    \\n    void solve(vector<int>& nums, int k, vector<int>& subset, int& res, int i) {\\n        if (i == nums.size()) {\\n            res += subset.size() > 0;\\n            return;\\n        }\\n        \\n        solve(nums, k, subset, res, i + 1);\\n        if (canAdd(subset, nums[i], k)) {\\n            subset.emplace_back(nums[i]);\\n            solve(nums, k, subset, res, i + 1);\\n            subset.pop_back();\\n        }\\n    }\\n    \\n    bool canAdd(vector<int>& subset, int num, int k) {\\n        for (int ss : subset) {\\n            if (abs(ss - num) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int res = 0;\\n        solve(nums, k, 0, res, 0);\\n        return res;\\n    }\\n\\nprivate: \\n    void solve(vector<int>& nums, int k, int mask, int& res, int i) {\\n        if (i == nums.size()) {\\n            res += mask > 0;\\n            return;\\n        }\\n        \\n        solve(nums, k, mask, res, i + 1);\\n        if (canAdd(nums, mask, nums[i], k)) {\\n            solve(nums, k, mask | (1 << i), res, i + 1);\\n        }\\n    }\\n   \\n    bool canAdd(vector<int>& nums, int mask, int num, int k) {\\n        for (int i = 0; i < nums.size(); i++) {\\n            if ((mask & (1 << i)) and abs(num - nums[i]) == k)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316056,
                "title": "java-simple-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> hSet = new HashSet<>();\\n        return solve(nums, k, 0, hSet);\\n    }\\n\\n    private int solve(int[] nums, int k, int ind, Set<Integer> hSet) {\\n        if (ind == nums.length) {\\n            if (hSet.size() > 0) return 1;\\n            return 0;\\n        }\\n\\n        int take = 0, nottake = 0;\\n        nottake += solve(nums, k, ind + 1, hSet);\\n\\n        if (!hSet.contains(nums[ind] - k)) {\\n            hSet.add(nums[ind]);\\n            take += solve(nums, k, ind + 1, hSet);\\n            // backtrack\\n            hSet.remove(nums[ind]);\\n        }\\n\\n        return take + nottake;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        Set<Integer> hSet = new HashSet<>();\\n        return solve(nums, k, 0, hSet);\\n    }\\n\\n    private int solve(int[] nums, int k, int ind, Set<Integer> hSet) {\\n        if (ind == nums.length) {\\n            if (hSet.size() > 0) return 1;\\n            return 0;\\n        }\\n\\n        int take = 0, nottake = 0;\\n        nottake += solve(nums, k, ind + 1, hSet);\\n\\n        if (!hSet.contains(nums[ind] - k)) {\\n            hSet.add(nums[ind]);\\n            take += solve(nums, k, ind + 1, hSet);\\n            // backtrack\\n            hSet.remove(nums[ind]);\\n        }\\n\\n        return take + nottake;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315977,
                "title": "easy-to-understand-with-approach",
                "content": "# Intuition\\nShould i pick or skip\\n\\n# Approach\\n-> the total number of subset in = 2^n\\n\\nfor eg {2 , 4 , 6}\\n\\n{} , {2} , {4} , {6} , {2 ,4} , {4, 6} , {2 ,6} , {2 , 4 ,6} = 8 \\n\\nbut what we want that only beautiful ones which define in such a way\\nans = (Total no. of subset) - (no of subset having any ele with k abs diff) - (empty subset)\\n\\nfrom above eg if k = 2\\neg = 8 - 3 ({2 ,4} , {4, 6} , {2 , 4 ,6}) - 1( {} ) = 4\\n\\nwe find the -> no of subset not having any ele with k abs diff we are using map\\n\\n* for every idx we have a choice that should i pick aur not \\n* and if you notice care fully through dry run not pick is always available \\n* pick call is depend upon the prev pick (ki isse past mai humane kahi yaisa ele tho nhi pick kiya jiska\\nabs diff k ho).\\nthen simply call recursion and in last sub 1 for null subset.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    unordered_map<int, int>mp;\\n\\n    int helper(int idx , vector<int>&nums , int n , int k )\\n    {\\n        if(idx == n)\\n            return 1;\\n        \\n        int pick = 0;\\n\\n        if(mp[nums[idx] - k] == 0 && mp[nums[idx] + k] == 0)\\n        {\\n            mp[nums[idx]]++;\\n            pick = helper(idx+1 , nums , n , k);\\n            mp[nums[idx]]--;\\n        }    \\n\\n        int not_pick = helper(idx+1 , nums , n , k);\\n\\n        return pick + not_pick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        return helper(0 , nums , n , k) - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    unordered_map<int, int>mp;\\n\\n    int helper(int idx , vector<int>&nums , int n , int k )\\n    {\\n        if(idx == n)\\n            return 1;\\n        \\n        int pick = 0;\\n\\n        if(mp[nums[idx] - k] == 0 && mp[nums[idx] + k] == 0)\\n        {\\n            mp[nums[idx]]++;\\n            pick = helper(idx+1 , nums , n , k);\\n            mp[nums[idx]]--;\\n        }    \\n\\n        int not_pick = helper(idx+1 , nums , n , k);\\n\\n        return pick + not_pick;\\n    }\\n\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        return helper(0 , nums , n , k) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315959,
                "title": "java-optimal-solution-using-backtracking",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        backTrack(new HashSet<>(), 0, nums, k);\\n        return count - 1;\\n    }\\n    private void backTrack(Set<Integer> element ,int i, int[] nums, int k)\\n    {\\n        count++;\\n        for(int j=i; j<nums.length; j++)\\n        {\\n            if( !element.contains(nums[j] - k ))\\n            {\\n                element.add(nums[j]);\\n                backTrack(element, j+1, nums, k);\\n                element.remove(nums[j]);//remove current elem before backtracking\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution \\n{\\n    int count = 0;\\n    public int beautifulSubsets(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        backTrack(new HashSet<>(), 0, nums, k);\\n        return count - 1;\\n    }\\n    private void backTrack(Set<Integer> element ,int i, int[] nums, int k)\\n    {\\n        count++;\\n        for(int j=i; j<nums.length; j++)\\n        {\\n            if( !element.contains(nums[j] - k ))\\n            {\\n                element.add(nums[j]);\\n                backTrack(element, j+1, nums, k);\\n                element.remove(nums[j]);//remove current elem before backtracking\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315680,
                "title": "java-recursion-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    int ans = 0;\\n    int K;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        K = k;\\n        solve(new HashSet<Integer>(), 0, nums);\\n        return ans;\\n    }\\n\\n    void solve(Set<Integer> set, int index, int[] nums) {\\n        if (index == nums.length) {\\n            if (set.size() > 0)\\n                ans++;\\n            return;\\n        }\\n\\n        int cur = nums[index];\\n\\n        solve(set, index + 1, nums);\\n        int neg = cur - K;\\n        int pos = cur + K;\\n        if (!set.contains(neg) && !set.contains(pos)) {\\n            set.add(cur);\\n            solve(set, index + 1,nums);\\n            set.remove(cur);\\n        }\\n\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    int K;\\n    public int beautifulSubsets(int[] nums, int k) {\\n        K = k;\\n        solve(new HashSet<Integer>(), 0, nums);\\n        return ans;\\n    }\\n\\n    void solve(Set<Integer> set, int index, int[] nums) {\\n        if (index == nums.length) {\\n            if (set.size() > 0)\\n                ans++;\\n            return;\\n        }\\n\\n        int cur = nums[index];\\n\\n        solve(set, index + 1, nums);\\n        int neg = cur - K;\\n        int pos = cur + K;\\n        if (!set.contains(neg) && !set.contains(pos)) {\\n            set.add(cur);\\n            solve(set, index + 1,nums);\\n            set.remove(cur);\\n        }\\n\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315528,
                "title": "the-number-of-beautiful-subsets-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGroup all the element in sequence having difference of k. and then apply combinatorics for each group using dp and multipy of result of each group. for removing empty subset reduce the result by 1 and then return.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor grouping here I use DSU which takes O(max(nums)) and then perfrom dp for each group.\\n\\n# Complexity\\n- Time complexity: O(max(nums))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(max(nums))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\nvector<int> Parent, Rank;\\npublic:\\nvoid Init(int n)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        Parent[i] = i;\\n        Rank[i] = 1;\\n    }\\n}\\nint Root(int x)\\n{\\n    if (Parent[x] != x)\\n        Parent[x] = Root(Parent[x]);\\n    return Parent[x];\\n}\\nvoid Union(int x, int y)\\n{\\n    int rx = Root(x), ry = Root(y);\\n    if (rx == ry)\\n        return;\\n    if (Rank[rx] >= Rank[ry])\\n    {\\n        Parent[ry] = rx;\\n        Rank[rx] += Rank[ry];\\n    }\\n    else\\n    {\\n        Parent[rx] = ry;\\n        Rank[ry] += Rank[rx];\\n    }\\n    return;\\n}\\n\\npair<int, int> solve(int n, vector<int> &arr, vector<int> &cnt, vector<pair<int, int>> &dp)\\n{\\n    if (n == 0)\\n        return {((1ll << cnt[arr[n]]) - 1), 1};\\n    if (dp[n] != make_pair(-1, -1))\\n        return dp[n];\\n    pair<int, int> ans = solve(n - 1, arr, cnt, dp);\\n    int x = ans.first + ans.second;\\n    int y = ((1ll << cnt[arr[n]]) - 1) * ans.second;\\n    return dp[n] = {y, x};\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    Parent = vector<int>(1001);\\n    Rank = vector<int>(1001);\\n    Init(1001);\\n    vector<int> cnt(1001, 0);\\n    cnt[nums[0]]++;\\n    map<int, set<int>> mp;\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (nums[i] - k >= 0 && cnt[nums[i] - k])\\n        {\\n            Union(nums[i] - k, nums[i]);\\n        }\\n        cnt[nums[i]]++;\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n        mp[Root(nums[i])].insert(nums[i]);\\n    }\\n    int res = 1;\\n    for (auto it = mp.begin(); it != mp.end(); it++)\\n    {\\n        set<int> st = it->second;\\n        vector<int> arr(st.begin(), st.end());\\n        int sz = arr.size();\\n        vector<pair<int, int>> dp(sz, {-1, -1});\\n        pair<int, int> ans = solve(sz - 1, arr, cnt, dp);\\n        res *= (ans.first + ans.second);\\n    }\\n    return res - 1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Union Find",
                    "Memoization",
                    "Combinatorics"
                ],
                "code": "```\\nclass Solution {\\n\\nvector<int> Parent, Rank;\\npublic:\\nvoid Init(int n)\\n{\\n    for (int i = 0; i < n; i++)\\n    {\\n        Parent[i] = i;\\n        Rank[i] = 1;\\n    }\\n}\\nint Root(int x)\\n{\\n    if (Parent[x] != x)\\n        Parent[x] = Root(Parent[x]);\\n    return Parent[x];\\n}\\nvoid Union(int x, int y)\\n{\\n    int rx = Root(x), ry = Root(y);\\n    if (rx == ry)\\n        return;\\n    if (Rank[rx] >= Rank[ry])\\n    {\\n        Parent[ry] = rx;\\n        Rank[rx] += Rank[ry];\\n    }\\n    else\\n    {\\n        Parent[rx] = ry;\\n        Rank[ry] += Rank[rx];\\n    }\\n    return;\\n}\\n\\npair<int, int> solve(int n, vector<int> &arr, vector<int> &cnt, vector<pair<int, int>> &dp)\\n{\\n    if (n == 0)\\n        return {((1ll << cnt[arr[n]]) - 1), 1};\\n    if (dp[n] != make_pair(-1, -1))\\n        return dp[n];\\n    pair<int, int> ans = solve(n - 1, arr, cnt, dp);\\n    int x = ans.first + ans.second;\\n    int y = ((1ll << cnt[arr[n]]) - 1) * ans.second;\\n    return dp[n] = {y, x};\\n}\\n\\nint beautifulSubsets(vector<int> &nums, int k)\\n{\\n    sort(nums.begin(), nums.end());\\n    int n = nums.size();\\n    Parent = vector<int>(1001);\\n    Rank = vector<int>(1001);\\n    Init(1001);\\n    vector<int> cnt(1001, 0);\\n    cnt[nums[0]]++;\\n    map<int, set<int>> mp;\\n    for (int i = 1; i < n; i++)\\n    {\\n        if (nums[i] - k >= 0 && cnt[nums[i] - k])\\n        {\\n            Union(nums[i] - k, nums[i]);\\n        }\\n        cnt[nums[i]]++;\\n    }\\n    for (int i = 0; i < n; i++)\\n    {\\n        mp[Root(nums[i])].insert(nums[i]);\\n    }\\n    int res = 1;\\n    for (auto it = mp.begin(); it != mp.end(); it++)\\n    {\\n        set<int> st = it->second;\\n        vector<int> arr(st.begin(), st.end());\\n        int sz = arr.size();\\n        vector<pair<int, int>> dp(sz, {-1, -1});\\n        pair<int, int> ans = solve(sz - 1, arr, cnt, dp);\\n        res *= (ans.first + ans.second);\\n    }\\n    return res - 1;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315440,
                "title": "dp",
                "content": "# Intuition\\nIf you group all the elements in which adjacent elements have difference equal to k, then the problem boils down into : Find the number of subsets such that no two elements are adjacent.\\nSince two groups are independent of each each other, we can solve the problems for each group independently.\\n\\n# Approach\\nSort the array and store all the ranges. This can be done using a map to store [last, start], where the range is start, start+k, start + 2*k, .... end.\\n\\nFor all the ranges, find the valid number of subsets using dp.\\nFor every index i, we have two options: \\n1. Choose the current element and solve rec(i-2);\\n2. Don\\'t choose i and move to rec(i-1).\\n3. Add both ways.\\nNumber of ways to choose a[i] is (1 << freq[a[i]]) - 1.\\n\\nHow to add all ranges:\\nLet x be the total answer till now and y be be count for current range. Since x and y are independent, the answer will be increased by x*y.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int beautifulSubsets(vector<int>& a, int k) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        // Store ranges and frequency of every element\\n        map<int,int> range, cnt;\\n        for(auto it: a) {\\n            if(range.count(it - k)) {\\n                range[it] = range[it - k];\\n                range.erase(it - k);\\n            }\\n            else range[it] = it;\\n            \\n            cnt[it]++;\\n        }\\n\\n        ll ans = 0;\\n        \\n        for(auto it: range) {\\n            int start = it.second;\\n            int end = it.first;\\n\\n            vector<int> x;\\n            for(int i=start; i<=end; i+=k) x.push_back(i);\\n\\n            vector<ll> dp(x.size(),0); \\n\\n            for(int i=0; i<x.size(); i++) {\\n                // No. of ways to choose x[i]\\n                dp[i] = (1<<cnt[x[i]]) - 1;\\n\\n                // Don\\'t take x[i]\\n                if(i-1 >= 0) dp[i] += dp[i-1];\\n                // Take x[i]\\n                if(i-2 >= 0) dp[i] += dp[i-2];\\n            }\\n                 \\n            ans += (ans * dp[x.size()-1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    int beautifulSubsets(vector<int>& a, int k) {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        // Store ranges and frequency of every element\\n        map<int,int> range, cnt;\\n        for(auto it: a) {\\n            if(range.count(it - k)) {\\n                range[it] = range[it - k];\\n                range.erase(it - k);\\n            }\\n            else range[it] = it;\\n            \\n            cnt[it]++;\\n        }\\n\\n        ll ans = 0;\\n        \\n        for(auto it: range) {\\n            int start = it.second;\\n            int end = it.first;\\n\\n            vector<int> x;\\n            for(int i=start; i<=end; i+=k) x.push_back(i);\\n\\n            vector<ll> dp(x.size(),0); \\n\\n            for(int i=0; i<x.size(); i++) {\\n                // No. of ways to choose x[i]\\n                dp[i] = (1<<cnt[x[i]]) - 1;\\n\\n                // Don\\'t take x[i]\\n                if(i-1 >= 0) dp[i] += dp[i-1];\\n                // Take x[i]\\n                if(i-2 >= 0) dp[i] += dp[i-2];\\n            }\\n                 \\n            ans += (ans * dp[x.size()-1]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315339,
                "title": "tc-o-2-n-n-space-o-n-n",
                "content": "# Intuition\\nWe simply can use recursion to generate all posibilities .But we also must check all elements in the DS before adding. Now my DS has stored all the possibility.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n                   O(2^(n*n)) +O(nlogn)\\n\\n- Space complexity:\\n                   O(n*n)+O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> al=new ArrayList<>();\\n        ArrayList<Integer>l=new ArrayList<>();\\n        subsum(nums,nums.length,k,al,l,0);\\n        return al.size()-1;\\n    }\\n    public void subsum(int[] nums,int n,int k, ArrayList<ArrayList<Integer>>al,ArrayList<Integer>l,int i)\\n    {\\n        if(i>=n)\\n        {\\n            al.add(new ArrayList<>(l));\\n            return;\\n        }\\n         boolean flag=true;\\n         int a=nums[i];\\n         for(int j=0;j<l.size();j++)\\n         {\\n          int c=l.get(j);\\n          int g=Math.abs(c-a);\\n          if(g==k){flag=false;break;}\\n         }\\n         if(flag)\\n         { \\n         l.add(a);\\n         subsum(nums,n,k,al,l,i+1);\\n         l.remove(l.size()-1);\\n         }\\n         subsum(nums,n,k,al,l,i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int beautifulSubsets(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        ArrayList<ArrayList<Integer>> al=new ArrayList<>();\\n        ArrayList<Integer>l=new ArrayList<>();\\n        subsum(nums,nums.length,k,al,l,0);\\n        return al.size()-1;\\n    }\\n    public void subsum(int[] nums,int n,int k, ArrayList<ArrayList<Integer>>al,ArrayList<Integer>l,int i)\\n    {\\n        if(i>=n)\\n        {\\n            al.add(new ArrayList<>(l));\\n            return;\\n        }\\n         boolean flag=true;\\n         int a=nums[i];\\n         for(int j=0;j<l.size();j++)\\n         {\\n          int c=l.get(j);\\n          int g=Math.abs(c-a);\\n          if(g==k){flag=false;break;}\\n         }\\n         if(flag)\\n         { \\n         l.add(a);\\n         subsum(nums,n,k,al,l,i+1);\\n         l.remove(l.size()-1);\\n         }\\n         subsum(nums,n,k,al,l,i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315290,
                "title": "c-knapsack-pattern-backtracking-90-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums, int k,vector<int>&dp,int ind,vector<int>&v){\\n        int n=nums.size();\\n        if(ind>=n){\\n            return 0;\\n        }\\n       \\n        int nottake=solve(nums,k,dp,ind+1,v);\\n        int take=0;\\n        int a=nums[ind];\\n        bool f=true;\\n        for(auto x: v){\\n            if(abs(x-a)==k){\\n                f=false;\\n            }\\n        }\\n        if(f){\\n            v.push_back(a);\\n            take=1+solve(nums,k,dp,ind+1,v);\\n            v.pop_back();\\n        }\\n        return take+nottake;\\n        \\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        vector<int> v;\\n        return solve(nums,k,dp,0,v);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(vector<int>& nums, int k,vector<int>&dp,int ind,vector<int>&v){\\n        int n=nums.size();\\n        if(ind>=n){\\n            return 0;\\n        }\\n       \\n        int nottake=solve(nums,k,dp,ind+1,v);\\n        int take=0;\\n        int a=nums[ind];\\n        bool f=true;\\n        for(auto x: v){\\n            if(abs(x-a)==k){\\n                f=false;\\n            }\\n        }\\n        if(f){\\n            v.push_back(a);\\n            take=1+solve(nums,k,dp,ind+1,v);\\n            v.pop_back();\\n        }\\n        return take+nottake;\\n        \\n        \\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        vector<int>dp(n,-1);\\n        vector<int> v;\\n        return solve(nums,k,dp,0,v);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315281,
                "title": "easy-solution-in-c-backtracking",
                "content": "# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k,unordered_map<int,int>& mp,int i){\\n        if(i==nums.size())\\n            return 1;\\n        int lft=0,rgt=0;\\n        if(!mp[nums[i] - k]){\\n            mp[nums[i]]++;\\n            lft=helper(nums,k,mp,i+1);\\n            mp[nums[i]]--;\\n        }\\n        rgt=helper(nums,k,mp,i+1);\\n        return lft+rgt;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> mp;\\n        return helper(nums,k,mp,0)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums,int k,unordered_map<int,int>& mp,int i){\\n        if(i==nums.size())\\n            return 1;\\n        int lft=0,rgt=0;\\n        if(!mp[nums[i] - k]){\\n            mp[nums[i]]++;\\n            lft=helper(nums,k,mp,i+1);\\n            mp[nums[i]]--;\\n        }\\n        rgt=helper(nums,k,mp,i+1);\\n        return lft+rgt;\\n    }\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> mp;\\n        return helper(nums,k,mp,0)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315257,
                "title": "python-tc-100-non-distinct-allowed",
                "content": "# Code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if(n==1): return 1\\n        cnt = defaultdict(Counter)\\n        for x in nums:\\n            cnt[x%k][x] +=1\\n        res = 1\\n        for v,x in cnt.items():\\n            dp0,dp1 = 1,0\\n            ls = sorted(x.keys())\\n            for p in range(0,len(ls)): \\n                dp0,dp1 = dp1+dp0,(dp0 + (dp1*(ls[p]!=ls[p-1]+k)))*((1<<x[ls[p]]) - 1)\\n            res *= ((dp1+dp0))\\n        return res-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        if(n==1): return 1\\n        cnt = defaultdict(Counter)\\n        for x in nums:\\n            cnt[x%k][x] +=1\\n        res = 1\\n        for v,x in cnt.items():\\n            dp0,dp1 = 1,0\\n            ls = sorted(x.keys())\\n            for p in range(0,len(ls)): \\n                dp0,dp1 = dp1+dp0,(dp0 + (dp1*(ls[p]!=ls[p-1]+k)))*((1<<x[ls[p]]) - 1)\\n            res *= ((dp1+dp0))\\n        return res-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315223,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(dp: &mut Vec<Vec<i32>>, i: usize, last_i: usize, gs: &Vec<i32>, k: i32) -> i32 {\\n            if i == gs.len() {\\n                return 1;\\n            }\\n            let ugly = gs[i] - gs[last_i] == k;\\n            if dp[i][ugly as usize] == 0 {\\n                dp[i][ugly as usize] = dfs(dp, i + 1, last_i, gs, k)\\n                    + if ugly { 0 } else { dfs(dp, i + 1, i, gs, k) };\\n            }\\n            dp[i][ugly as usize]\\n        }\\n    \\n        let mut dp = vec![vec![0; 2]; 21];\\n        let mut gs = vec![];\\n        let mut m = std::collections::HashMap::new();\\n        for n in nums {\\n            m.entry(n % k).or_insert(vec![]).push(n);\\n        }\\n        for (_, mut g) in m {\\n            g.sort();\\n            gs.append(&mut g);\\n        }\\n        dfs(&mut dp, 0, gs.len() - 1, &gs, k) - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn beautiful_subsets(nums: Vec<i32>, k: i32) -> i32 {\\n        fn dfs(dp: &mut Vec<Vec<i32>>, i: usize, last_i: usize, gs: &Vec<i32>, k: i32) -> i32 {\\n            if i == gs.len() {\\n                return 1;\\n            }\\n            let ugly = gs[i] - gs[last_i] == k;\\n            if dp[i][ugly as usize] == 0 {\\n                dp[i][ugly as usize] = dfs(dp, i + 1, last_i, gs, k)\\n                    + if ugly { 0 } else { dfs(dp, i + 1, i, gs, k) };\\n            }\\n            dp[i][ugly as usize]\\n        }\\n    \\n        let mut dp = vec![vec![0; 2]; 21];\\n        let mut gs = vec![];\\n        let mut m = std::collections::HashMap::new();\\n        for n in nums {\\n            m.entry(n % k).or_insert(vec![]).push(n);\\n        }\\n        for (_, mut g) in m {\\n            g.sort();\\n            gs.append(&mut g);\\n        }\\n        dfs(&mut dp, 0, gs.len() - 1, &gs, k) - 1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1836968,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836885,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836820,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837056,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836977,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842946,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1839812,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838799,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1970581,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913969,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836968,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836885,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836820,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1837056,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1836977,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1842946,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1839812,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1838799,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1970581,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1913969,
                "content": [
                    {
                        "username": "Diamantis",
                        "content": "Bad constraints. Some brute force solutions worked while others barely didn\\'t. The problem author should have added different input constraints whether he meant for brute force to be accepted or not."
                    },
                    {
                        "username": "Harshit_9436",
                        "content": "[@cartesPerforees](/cartesPerforees) my n*2^n solution is showing tle, by both bitmasking and recursion...while someone\\'s same solution just doing the same thing in a different way got accepted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't necessarily have a problem with that.\n You call them all brute force solutions cause they explore all subsets, but depending on the way you do it, they could actually be either $O(n^2 2^n)$, $O(n 2^n)$, (and maybe $O(2^n)$ but I don't see a way to do that rn).\nThey are not all created equal. The first one will definitely get you a TLE, while I got  $O(n 2^n)$ accepted with a comfortable margin. You can see that ahead of time based on the constraint (20^2 * 2^20 is 22 billions, that's too much). If that's the bar they want to set, why not? \nBasing your choice of approach on the constraints is always a bit cheesy anyway, in real life nobody will tell you the optimal complexity in advance (but that's what I did too, that's why I went for an brute-forcish approach right away rather than the optimal; not always a smart thing to do!)\n\nThey could also make sure to accept only polynomial solutions, but that would just be a slightly different problem. Maybe they could make beautiful subsets II. with stricter constraints!"
                    },
                    {
                        "username": "HarshitNTiwari",
                        "content": "In my naive backtracking solution, it is showing that 1294/1294 testcases are passed. Still it is giving TLE. Can anyone explain the possible reason?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That is an annoying bug in Leetcodes output. I have faced it in other questions and posted on the forum. Leetcode replied that it should be treated as any other TLE. It is just unfortunate that you don\\'t get the actual testcase and they are working on improving it."
                    },
                    {
                        "username": "nirajthakare",
                        "content": "[@NekoShadow](/NekoShadow) how did you know that it will solve the issue??\\n"
                    },
                    {
                        "username": "d_arnav",
                        "content": "That\\'s leetcode technical fault... i\\'ve faced this once"
                    },
                    {
                        "username": "NekoShadow",
                        "content": "Same here. During contest I have to replace the counter I used with a fixed size array to get AC."
                    },
                    {
                        "username": "Ouskit",
                        "content": "same here"
                    },
                    {
                        "username": "rockmattesharma",
                        "content": "It might have given TLE on 1294th test case"
                    },
                    {
                        "username": "suck_77",
                        "content": "The time limit is too strict. When I see n <= 20, my intuition is that I can solve this problem with backtracking which the time complexity is O(1 << 20). But I got TLE with naive backtracking method.\nIf I am correct, please rejudge all TLE submissions, thanks."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@karankc23](/karankc23) Depends. The brutish brute force is gonna actually be $O(n^2 2^n)$, which will definitely give you TLE\nYou could have an $O(n2^n)$ as well, which can pass (mine got accepted).\nI don't actually see an obvious way to brute force it in $O(2^n)$ only"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "how did you figure out the tc will you please tell ??\\n"
                    },
                    {
                        "username": "karankc23",
                        "content": "[@Taswell](/Taswell) its 2^20 only\\n"
                    },
                    {
                        "username": "Taswell",
                        "content": "it\\'s 20! dude"
                    },
                    {
                        "username": "then00bprogrammer",
                        "content": "Why you would give exponential time constraints on an easy linear time question and then accept some exponential solution and give TLE on some.seriously what the f"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "The fact that you're calling a linear solution easy suggests that you're either a genius, or you have just read it without trying to figure it out yourself. Especially because I'm not aware of any linear solution. But even the nlogn DP is nowhere near easy for mere mortals like us all\n\nAlso, $O(n^2 2^n)$, $O(n 2^n)$, $O(2^n)$ are not the same thing. I don't think it's unacceptable to set the bar somewhere between them. Based on the constraints, you can see before writing your solution that the first will give you a TLE while the others likely won't.\nIt's just like any other problem, you just have to pick the complexity of your solution a bit more carefully than usual\n"
                    },
                    {
                        "username": "tr1ten",
                        "content": "constraints are kinda decieving..."
                    },
                    {
                        "username": "paramkumar1",
                        "content": "Hi i am using bit mask to genertate all the possible subsets and checking if each is valid. But it is still giving wrong answer. \\nCan anyone tell me what is the problem with the code\\n```\\nclass Solution:\\n    def beautifulSubsets(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        val = pow(2,n)-1\\n        res = 0\\n        invalidset = defaultdict(int)\\n        while(val):\\n            x  = val  ;\\n            invalidset.clear()\\n            i = 0\\n            while(i<n):\\n                if(x&1 ):\\n                    if(invalidset[ nums[i]-k ] == 0 and invalidset[ k-nums[i] ] == 0 ) :\\n                        invalidset[nums[i]] = 1;\\n                    else:break;\\n                x >>=1\\n                i+=1\\n            if(i==n): res += 1\\n            val -=1\\n        \\n        return res;\\n```"
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sort the array before using backtracking. It won\\'t give TLE."
                    },
                    {
                        "username": "lu6007",
                        "content": "For nums = [2,2,2], should be answer be 3 or 7? "
                    },
                    {
                        "username": "_tofu_",
                        "content": "Simple backtracking solutions:\\n\\n```\\nclass Solution {\\npublic:\\n    int beautifulSubsets(vector<int> &nums, int k) {\\n        int res = 0;\\n        vector<int> path;\\n        sort(nums.begin(), nums.end());\\n        backtracking(nums, res, path, 0, k);\\n\\n        return res;\\n    }\\n\\n    void backtracking(vector<int> &nums, int &res, vector<int> &path, int start, int k) {\\n        if (!path.empty()) res++;\\n\\n        for (int i = start; i < nums.size(); i++) {\\n            if (path.empty()) {\\n                path.push_back(nums[i]);\\n                backtracking(nums, res, path, i + 1, k);\\n                path.pop_back();\\n            } else {\\n                int insert = 1;\\n                for (const auto x: path) {\\n                    if ((nums[i] - x) == k) {\\n                        insert = 0;\\n                        break;\\n                    }\\n                }\\n                if (insert) {\\n                    path.push_back(nums[i]);\\n                    backtracking(nums, res, path, i + 1, k);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Code_With_Gurnoor_Chhabra",
                        "content": "please tell me error ?? \\nwhy giving TLE\\nT.C : O(n.2^n)\\n\\nclass Solution {\\npublic:\\nint ct=0;\\nvoid subs(vector<int>&nums,unordered_map<int,int>&a,int i,int k)\\n{\\n    if(i==nums.size()) {\\n        if(a.size()>0)\\n        {\\n         int f=0;\\n            for(auto x : a)\\n            {\\n                int i = x.first;\\n                a[i]=1;\\n                if(a.count(i-k) || a.count(i+k)) {f=1;break;}\\n            }\\n            if(!f) {ct++;}\\n        }\\n        return;\\n    }\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]++;\\n    subs(nums,a,i+1,k);\\n    a[nums[i]]--;\\n    if(a[nums[i]]==0) {a.erase(nums[i]);}\\n    return;\\n}\\n    int beautifulSubsets(vector<int>& nums, int k) {\\n        unordered_map<int,int>a;\\n        subs(nums,a,0,k);\\n        return ct;\\n    }\\n};"
                    }
                ]
            }
        ]
    }
]