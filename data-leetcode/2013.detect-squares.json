[
    {
        "title": "Prime Palindrome",
        "question_content": "Given an integer n, return the smallest prime palindrome greater than or equal to n.\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n\tFor example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n\tFor example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n&nbsp;\nExample 1:\nInput: n = 6\nOutput: 7\nExample 2:\nInput: n = 8\nOutput: 11\nExample 3:\nInput: n = 13\nOutput: 101\n&nbsp;\nConstraints:\n\n\t1 <= n <= 108",
        "solutions": [
            {
                "id": 146798,
                "title": "java-c-python-all-even-length-palindrome-are-divisible-by-11",
                "content": "# **Intuition**\\nWrite some example, you find all even length palindromes are divisible by 11.\\nSo we need to search only palindrome with odd length.\\n\\nWe can prove as follow:\\n11 % 11 = 0\\n1111 % 11 = 0\\n111111 % 11 = 0\\n11111111 % 11 = 0\\n\\n**So:**\\n1001 % 11 = (1111 - 11 * 10) % 11 = 0\\n100001 % 11 = (111111 - 1111 * 10) % 11 = 0\\n10000001 % 11 = (11111111 - 111111 * 10) % 11 = 0\\n\\nFor any palindrome with even length:\\nabcddcba % 11\\n= (a * 10000001 + b * 100001 * 10 + c * 1001 * 100 + d * 11 * 1000) % 11\\n= 0\\n\\nAll palindrome with even length is multiple of `11`.\\nSo among them, 11 is the only one prime\\n`if (8 <= N <= 11) return 11`\\n\\nFor other cases, **we consider only palindrome with odd dights.**\\n<br>\\n\\n# More Generally\\nExplanation from @chuan-chih:\\nA number is divisible by 11 if `sum(even digits) - sum(odd digits)` is divisible by 11.\\n**Base case: 0**\\n**Inductive step:**\\nIf there is no carry when we add 11 to a number, both sums +1.\\nWhenever carry happens, one sum -10 and the other +1.\\nThe invariant holds in both cases.\\n<br>\\n\\n# **Time Complexity**\\n`O(10000)` to check all numbers 1 - 10000.\\n`isPrime` function is `O(sqrt(x))` in worst case.\\nBut only `sqrt(N)` worst cases for `1 <= x <= N`\\nIn general it\\'s `O(logx)`\\n<br>\\n\\n**C++:**\\n```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n**Java:**\\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\\n\\n\\n**Python:**\\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; ++x) {\\n            string s = to_string(x), r(s.rbegin(), s.rend());\\n            int y = stoi(s + r.substr(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n    bool isPrime(int num) {\\n        if (num < 2 || num % 2 == 0) return num == 2;\\n        for (int i = 3; i * i <= num; i += 2)\\n            if (num % i == 0) return false;\\n        return true;\\n    }\\n```\n```java\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n```\n```py\\n    def primePalindrome(self, N):\\n        def isPrime(x):\\n            if x < 2 or x % 2 == 0: return x == 2\\n            for i in xrange(3, int(x**0.5) + 1, 2):\\n                if x % i == 0: return False\\n            return True\\n        if 8 <= N <= 11: return 11\\n        for x in xrange(10 ** (len(str(N)) / 2), 10**5):\\n            y = int(str(x) + str(x)[-2::-1])\\n            if y >= N and isPrime(y): return y\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 146766,
                "title": "c-o-1-0ms",
                "content": "base on exp, it should not be a big table; \\n\\n    class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            };\\n            return *lower_bound(tab.begin(), tab.end(), N);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int primePalindrome(int N) {\\n            static vector<int> tab{\\n                2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, \\n                353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, \\n                10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, \\n                14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, \\n                18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, \\n                31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, \\n                35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, \\n                70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, \\n                74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, \\n                79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, \\n                94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, \\n                98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, \\n                1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, \\n                1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, \\n                1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, \\n                1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, \\n                1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, \\n                1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, \\n                1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, \\n                1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, \\n                1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, \\n                1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, \\n                1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, \\n                1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, \\n                1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, \\n                1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, \\n                1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, \\n                1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, \\n                1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, \\n                1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, \\n                1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, \\n                3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, \\n                3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, \\n                3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, \\n                3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, \\n                3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, \\n                3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, \\n                3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, \\n                3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, \\n                3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, \\n                3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, \\n                3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, \\n                3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, \\n                3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, \\n                3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, \\n                3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, \\n                3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, \\n                3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, \\n                7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, \\n                7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, \\n                7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, \\n                7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, \\n                7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, \\n                7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, \\n                7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, \\n                7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, \\n                7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, \\n                7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, \\n                7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, \\n                7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, \\n                7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, \\n                7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, \\n                7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, \\n                9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, \\n                9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, \\n                9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, \\n                9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, \\n                9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, \\n                9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, \\n                9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, \\n                9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, \\n                9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, \\n                9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, \\n                9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, \\n                9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, \\n                9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, \\n                9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, \\n                9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, \\n                100030001\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 146788,
                "title": "getting-one-over-the-system-o-1-solution-in-java",
                "content": "So I spend 30 mins (and 5 bugs) trying to get my O(N^2) solution to work. It doesn\\'t. So I get mad and rage-generate an array of all the palindromic primes using 1553 ms. Next, I put them into my revenge array.\\n\\n```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\\nYou get the idea.\\nO(1) solution I got after brute-forcing all the primes I needed.\\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nIt didn\\'t nab me for memory usage LOL. Check out the C++ one also, its faster (coder used binary search) and was posted first.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final int[] hehehe = new int[]{2, 3, 5, 7, 11, 101, 131, 151, 181, 191, \\n\\t\\t313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, \\n\\t\\t11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, \\n\\t\\t15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, \\n\\t\\t19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, \\n\\t\\t32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, \\n\\t\\t36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, \\n\\t\\t71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, \\n\\t\\t76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, \\n\\t\\t79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, \\n\\t\\t94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, \\n\\t\\t1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, \\n\\t\\t1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, \\n\\t\\t1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311...};\\n```\n```\\n    public final int[] hehehe; //(see above)\\n    public int primePalindrome(int N) {\\n        //2lazE to implement binary search\\n        for(int i = 0; i < hehehe.length; i++){\\n            if(N <= hehehe[i]){\\n                return hehehe[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 158439,
                "title": "c-even-odd-length-palindrome-merge-sort-like-solution-interviewer-really-loves-it-kiss",
                "content": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string>\\n#include <algorithm>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int evenPalindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1;\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    int oddPlaindrome(int num) {\\n        string str1 = to_string(num);\\n        string str2 = str1.substr(0, str1.length() - 1);\\n        reverse(str2.begin(), str2.end());\\n        return stoi(str1 + str2);\\n    }\\n\\n    bool isPrime(int num) {\\n        if (num == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i * i <= num; ++i) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        int even = 1;\\n        int odd = 1;\\n\\n        int cur = 0;\\n        do {\\n            int evenp = evenPalindrome(even);\\n            int oddp = oddPlaindrome(odd);\\n            cur = min(evenp, oddp);\\n            if (evenp < oddp) {\\n                ++even;\\n            } else {\\n                ++odd;\\n            }\\n        } while (!(cur >= N && isPrime(cur)));\\n\\n        return cur;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 146950,
                "title": "python-3-construct-palindromes-first-and-then-check-if-prime",
                "content": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        ndigits = len(str(N))\\n        while True:\\n            for x in self.palindromes(ndigits):\\n                if x >= N and self.isPrime(x):\\n                    return x\\n            ndigits += 1\\n            \\n    def palindromes(self, n):\\n        if n == 1:\\n            for i in range(10):\\n                yield i\\n        elif n % 2 == 0:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                yield int(s + s[::-1])\\n        else:\\n            d = n // 2\\n            for i in range(10**(d-1), 10**d):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n                    \\n    def isPrime(self, x):\\n        if x == 1:\\n            return False\\n        if x == 2:\\n            return True\\n        for i in range(2, int(x**0.5+1)):\\n            if x % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212297,
                "title": "why-even-number-of-digit-prime-palindromes-are-not-possible",
                "content": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "solutionTags": [],
                "code": "```\\nBecause even length prime digit numbers are divisible by 11 therefore are not prime.\\nIt\\'s a trick that has to do powers of 10 and mod 11.\\nEx: 10 = 10^1 mod 11 = -1 mod 11\\n      100 = 10^2 = 1 mod 11\\n      1000 = 10^3 = -1 mod 11\\n      10000 = 10^4 = 1 mod 11\\nSee the pattern? \\nEven exponent powers of 10 are 1 mod 11 \\nOdd exponent powers of 10 are -1 mod 11.\\n\\nWe also know decimal numbers are just base 10 expansion of the digits.\\n\\nSo   1225 = (10^3*)1 + 2*(10^2) + 2*(10^1) + 5*(10^0).\\n        using modular arithmetic we can say,\\n \\n        1225 MOD 11 = (-1)*1 + 2*(1) + 2*(-1) + 5*(1) = -1 + 2 - 2 + 5 = 4.\\n\\n        In other words, in MOD 11 we calculate what a decimal number is by just alternating the addition and subtraction across the digits.\\n\\nAnother example.\\n\\n    1323412 MOD 11 =   1 -3  +2 -3 +4 -1 +2 MOD 11 = 0. (x MOD 11 == 0) => 11 \\'divides\\' x\\nThen it becomes quite obvious why the above logic works for even palindromes.\\n\\nExample: \\n\\n321123 =      -3 + 2 - 1 + 1 -2 + 3 = 0. All the numbers cancel out with each other.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 146888,
                "title": "java-solution-building-closest-palindrome",
                "content": "Inspired by [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/description/)\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (N < Integer.MAX_VALUE) {\\n            N = nextPalin(\"\" + N);\\n            if (isPrime(N)) {\\n                return N;\\n            }\\n            N++;\\n        }\\n        return -1;\\n    }\\n    private int nextPalin(String n) {\\n        int l = n.length();\\n        List<Integer> cands = new LinkedList<>();\\n        int half = Integer.valueOf(n.substring(0, (l + 1) / 2));\\n        for (int i = half; i <= half + 1; i++) {\\n            String halfString = \"\" + i;\\n            if (l % 2 == 1) {\\n                halfString = halfString.substring(0, halfString.length() - 1);\\n            }\\n            String newString = \"\" + i + new StringBuilder(halfString).reverse().toString();\\n            cands.add(Integer.valueOf(newString));\\n        }\\n        int ori = Integer.valueOf(n), result = Integer.MAX_VALUE;\\n        for (int cand : cands) {\\n            if (cand >= ori && cand < result) {\\n                result = cand;\\n            }\\n        }\\n        return result;\\n    }\\n    private boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        long l = (long)n;\\n        for (long i = 2; i * i <= l; i++) {\\n            if (l % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146835,
                "title": "java-solution-6ms",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N == 1 || N == 2) return 2;\\n        if (N % 2 == 0) N++;\\n        while (true) {\\n            if (isPalindrome(N) && isPrime(N)) return N;\\n            N += 2;\\n            if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int n) {\\n        if (n % 10 == 0 && n != 0) return false;\\n        int n1 = 0;\\n        while (n > n1) {\\n            n1 = n1 * 10 + (n % 10);\\n            n /= 10;\\n        }\\n        return n1 == n || n == n1 / 10;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = 3; i <= end; i += 2) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 146930,
                "title": "faster-way-to-find-palindrome-accepted-c-solution",
                "content": "My solution is based on Finding a palindrome number (`>=N`)first and then I will check it for a prime or not.\\nGiven a number `N`, I will check it for a palindrome, if not - then I find the closest palindrome (`>N`)\\nTo find the closest palindrome is the hardest part of this program. Here is the whole discussion. The discussion based on \"array int\" but I implemented the number considering a string.\\n\\nIf you have any **question** regarding my **code**, please **comment**. I will try to answer.\\n\\nFor example, if the input number is \\u201C2 3 5 4 5\\u201D, the output should be \\u201C2 3 6 3 2\\u201D. And if the input number is \\u201C9 9 9\\u201D, the output should be \\u201C1 0 0 1\\u201D.\\n\\nThere can be three different types of inputs that need to be handled separately.\\n\\n1) The input number has all 9s. For example \\u201C9 9 9\\u201D. Output should be \\u201C1 0 0 1\\u201D i, e., `answer = input+2`\\n\\n2) For input \\u201C1 2 3 4\\u201D. Output should be \\u201C1 3 3 1\\u201D\\n\\nHow to convert a given number to a greater palindrome? To understand the solution, let us first define the following two terms:\\nLeft Side: The left half of given number. Left side of \\u201C1 2 3 4 5 6\\u201D is \\u201C1 2 3\\u201D and left side of \\u201C1 2 3 4 5\\u201D is \\u201C1 2\\u201D\\nRight Side: The right half of given number. Right side of \\u201C1 2 3 4 5 6\\u201D is \\u201C4 5 6\\u201D and right side of \\u201C1 2 3 4 5\\u201D is \\u201C4 5\\u201D\\nTo convert to palindrome, we can either take the mirror of its left side or take mirror of its right side. However, if we take the mirror of the right side, then the palindrome so formed is not guaranteed to be next larger palindrome. So, we must take the mirror of left side and copy it to right side. But there are some cases that must be handled in different ways. See the following steps.\\n\\nWe will start with two indices i and j. i pointing to the two middle elements (or pointing to two elements around the middle element in case of n being odd). We one by one move i and j away from each other.\\n\\n\\nStep 1. Initially, ignore the part of left side which is same as the corresponding part of right side. For example, if the number is \\u201C8 3 4 2 2 4 6 9\\u2033, we ignore the middle four elements. i now points to element 3 and j now points to element 6.\\n\\nStep 2. After step 1, following cases arise:\\n\\nCase 1: Indices i & j cross the boundary.\\nThis case occurs when the input number is palindrome. In this case, we just add 1 to the middle digit (or digits in case n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\nFor example, if the given number is \\u201C1 2 9 2 1\\u201D, we increment 9 to 10 and propagate the carry. So the number becomes \\u201C1 3 0 3 1\\u201D\\n\\nCase 2: There are digits left between left side and right side which are not same. So, we just mirror the left side to the right side & try to minimize the number formed to guarantee the next smallest palindrome.\\nIn this case, there can be two sub-cases.\\n\\n2.1) Copying the left side to the right side is sufficient, we don\\u2019t need to increment any digits and the result is just mirror of left side. Following are some examples of this sub-case.\\nNext palindrome for \\u201C7 8 3 3 2 2\\u2033 is \\u201C7 8 3 3 8 7\\u201D\\nNext palindrome for \\u201C1 2 5 3 2 2\\u2033 is \\u201C1 2 5 5 2 1\\u201D\\nNext palindrome for \\u201C1 4 5 8 7 6 7 8 3 2 2\\u2033 is \\u201C1 4 5 8 7 6 7 8 5 4 1\\u201D\\nHow do we check for this sub-case? All we need to check is the digit just after the ignored part in step 1. This digit is highlighted in above examples. If this digit is greater than the corresponding digit in right side digit, then copying the left side to the right side is sufficient and we don\\u2019t need to do anything else.\\n\\n2.2) Copying the left side to the right side is NOT sufficient. This happens when the above defined digit of left side is smaller. Following are some examples of this case.\\nNext palindrome for \\u201C7 1 3 3 2 2\\u2033 is \\u201C7 1 4 4 1 7\\u201D\\nNext palindrome for \\u201C1 2 3 4 6 2 8\\u2033 is \\u201C1 2 3 5 3 2 1\\u201D\\nNext palindrome for \\u201C9 4 1 8 7 9 7 8 3 2 2\\u2033 is \\u201C9 4 1 8 8 0 8 8 1 4 9\\u201D\\nWe handle this subcase like Case 1. We just add 1 to the middle digit (or digits in ase n is even) propagate the carry towards MSB digit of left side and simultaneously copy mirror of the left side to the right side.\\n\\nRef: www.geeksforgeeks.org.\\n\\nThis is the way to get **all palindrome** number. For this problem to solve you can consider only **odd palindrome** for fast result.\\n\\nHere is my implementation, \\n\\n```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    int getNextPalindrome( int nn )\\n    {\\n        string ss = to_string(nn);\\n        int i, j, len = ss.length();\\n\\n        for(i=0; i<len; i++) if(ss[i] != \\'9\\') break;\\n\\n        if(i==len) return (nn+2);       //  all are 9\\'s\\n\\n        //  when not all are 9\\'s\\n\\n        int mid = len/2;        // find the index of mid digit\\n\\n        // A bool variable to check if copy of left side to right is sufficient or not\\n        bool leftIsLess = false;\\n\\n        i = mid - 1;\\n\\n        if(len%2) j = mid+1;    //  for odd length palindrome\\n        else j = mid;           //  for even length palindrome\\n\\n        // Initially, ignore the middle same digits\\n        while (i >= 0 && ss[i] == ss[j]) i--,j++;\\n        \\n\\n        // Find if the middle digit(s) need to be incremented or not (or copying left\\n        // side is not sufficient)\\n        if ( i < 0 || ss[i] < ss[j]) leftIsLess = true;\\n        \\n        \\n        // Copy the mirror of left to right\\n    \\n        while (i >= 0) ss[j++] = ss[i--];\\n       \\n\\n        // Handle the case where middle digit(s) must be incremented.\\n        // This part of code is for CASE 1 and CASE 2.2\\n        \\n        if (leftIsLess == true)\\n        {\\n            int carry = 1;\\n            i = mid - 1;\\n\\n            // If there are odd digits, then increment\\n            // the middle digit and store the carry\\n            if (len%2 == 1)\\n            {\\n                j = mid+1;\\n                \\n                if(ss[mid]<=\\'8\\') {ss[mid]++; carry=0;}\\n                \\n                else ss[mid] = \\'0\\';               \\n            }\\n\\n            else j = mid;\\n         \\n            // Add 1 to the rightmost digit of the left side, propagate the carry\\n            // towards MSB digit and simultaneously copying mirror of the left side\\n            // to the right side.\\n            \\n            while (i >= 0 && carry)\\n            {\\n                if(ss[i]<=\\'8\\') {ss[i]++; ss[j++] = ss[i--]; break;} \\n\\n                else { \\n                    ss[i] = \\'0\\';     \\n                                    \\n                    ss[j++] = ss[i--]; \\n                }\\n            }\\n        }\\n        \\n        return stoi(ss);\\n}\\n\\nbool isprime(int num)\\n{\\n\\n    int j=sqrt((double)(num));\\n\\n    for(int i=2; i<=j; i++) if(!(num%i)) return false;\\n\\n    return true;\\n\\n}\\n   \\n    \\npublic:\\n       \\n    int primePalindrome(int N) {\\n\\n        if(N==1) return 2;\\n        \\n        \\n        string ss = to_string(N);\\n        int i, j, len = ss.length();\\n        \\n        int num=N;\\n        \\n        bool palindrome=true;\\n        \\n        for(i=0, j=len-1; i<j; i++, j--) if(ss[i]!=ss[j]) {palindrome=false; break;}\\n                   \\n        if(!palindrome) num = getNextPalindrome(num);\\n            \\n        while(!isprime(num)) num = getNextPalindrome(num);\\n            \\n\\n    return num;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2018872,
                "title": "c-easy-to-understand-math",
                "content": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool ispalindrom(int n)\\n    {\\n        int n1=n;\\n        int n2=0;\\n        while(n1>0){\\n            int a=n1%10;\\n            n2=n2*10+a;\\n            n1/=10;\\n        }\\n        if(n2==n)\\n            return true;\\n        return false;\\n    }\\n    int smallestno(int n)\\n    {\\n        if(ispalindrom(n))\\n            if(isprime(n))\\n                return n;\\n        return smallestno(n+1);\\n    }\\n\\n    int primePalindrome(int n) {\\n        \\n        if (1e7 <= n && n <= 1e8)\\n            return 100030001;\\n        int a=smallestno(n);\\n        return a;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    bool isprime(int n)\\n    {\\n        if(n==1)\\n            return false;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1291185,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```\\nIF YOU LIKE THE SOLUTION, UPVOTE IT AND ENCOURAGE ME.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314332,
                "title": "python-code-summarizing-several-posts",
                "content": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "solutionTags": [],
                "code": "Below code summarized several posts\\' algorithms: SolaAoi, EddieCarrillo, ivschukin.\\n\\nThe idea is we handle the case where return value is less than 100. \\n\\nThen all the rest of the cases, we only need to consider palindromes with lengths larger than 2.\\n\\nFrom SolaAoi\\'s post, we only need to generate odd-length palindromes.\\n\\nFrom EddieCarrillo\\'s, we can ensure the generated palindromes are sorted.\\n\\nAs we know the palindromes cannot end with even digits and \\'5\\', so we can only pick the seeds starting with \\'1\\',\\'3\\',\\'7\\',\\'9\\'.\\n\\nSince all palindromes ends with odd numbers, we only need to consider odd numbers starting from 3 to check if prime.\\n\\n```\\nclass Solution(object):\\n    def primePalindrome(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: int\\n        \"\"\"\\n        # Create a palindrome, then check prime\\n        \\n        # First digit and (last) can only be [1, 3, 7, 9]\\n        # Even-length palindromes (length longer than 2) are divisible by 11\\n        \\n        # Create a list of prime numbers\\n\\n        \\n        # Handle the case that returned value is less than 100\\n        \\n        if N >= 9989900:\\n            return 100030001\\n        if len(str(N)) <= 2:\\n            for c in [2,3,5,7,11]:\\n                if c >= N:\\n                    return c\\n        \\n                \\n        def isPrime(n):\\n            i = 3\\n            while i*i <= n:\\n                if n % i == 0:\\n                    return False\\n                i += 2\\n            return True\\n        \\n        # Generate odd-length (length > 2) palindrome\\n        def genOdd(seedint):\\n            seed = str(seedint)\\n            return int(seed + seed[:len(seed)-1][::-1])\\n        \\n        # Starting with length > 2 palindrome\\n        seed = 10\\n        \\n        while True:\\n            if str(seed)[0] in [\\'1\\',\\'3\\',\\'7\\',\\'9\\']:\\n                cur = genOdd(seed)\\n                if cur >= N and isPrime(cur):\\n                    return cur\\n            seed += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 179678,
                "title": "a-fast-way-to-check-is-prime-python",
                "content": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "solutionTags": [],
                "code": "```python\\ndef is_prime(n):\\n            if n < 2:\\n                return False\\n            if n in [2, 3]:\\n                return True\\n            if n % 6 != 5 and n % 6 != 1:\\n                return False\\n            for i in range(5, int(math.sqrt(n)) + 1, 6):\\n                if (n % i == 0) or (n % (i + 2) == 0):\\n                    return False\\n            return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 147065,
                "title": "javascript-solution-128ms",
                "content": "It\\'s tempted to **get stuck** in javascript when you only focus on how to find a prime quicker, because in that case your code will always **time out**. The only way to avoid time out when you focus on prime is to find all the solutions and then **save them as a const** to refer to.(then you\\'ll have no fun programming)\\n**The right way** to think of this problem is to `find the next palindrome`. There are big gaps between two close palindrome, and we can use those gaps to save time. So the key point of this solution lies in finding the next palindrome based on the palindrome we dealt before.\\n```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```\\nThe part of my code to find the next palindrome is not elegant. I tried to cut the code but failed. If you have any good idea about making it shorter, please let me know. Thanks `:)`",
                "solutionTags": [],
                "code": "```\\nvar primePalindrome = function(N) {\\n\\tif(N<=2) return 2;\\n\\tlet cur = N;\\n\\twhile(!isPal(cur)) cur++;\\n\\twhile(true){\\n\\t\\tif(isPrime(cur)) return cur;\\n\\t\\tcur = nextPal(cur);\\n\\t}\\n};\\nfunction isPal(n){\\n\\treturn (\\'\\'+n)===(\\'\\'+n).split(\\'\\').reverse().join(\\'\\');\\n}\\nfunction nextPal(n){\\n\\tlet s = (\\'\\'+n), len = s.length, half = Math.ceil(len/2);\\n\\tlet left=s.slice(0,half);\\n\\tlet tmp = (+left+1)+\\'\\';\\n\\tif(half===len-half){\\n\\t\\treturn +(tmp+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\')); //66->77 99->101\\n\\t}else{\\n\\t\\tif(tmp.length===half) return +(tmp+tmp.slice(0,len-half).split(\\'\\').reverse().join(\\'\\'));// 888->898\\n\\t\\telse return +(tmp.slice(0,half)+tmp.slice(0,half).split(\\'\\').reverse().join(\\'\\'));// 999->1001\\n\\t}\\n}\\nfunction isPrime(n){\\n\\tif(n%2===0) return false;\\n\\tfor(let i=3; i*i<=n; i+=2){\\n\\t\\tif(n%i===0) return false;\\n\\t}\\n\\treturn true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433138,
                "title": "easy-solution-full-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can divide it into 4 parts:-\\n    1.Find if the number is palindrome or not.\\n    2.Find if the number is prime or not.\\n    3.If it satisfy both prime and palindrome than we return n.\\n    4.Else while(true) -> If n satisfy both prime and Palindrome -> return n. Else -> n++.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlssssss Up Vote! -> \\uD83D\\uDE2D\\n# Code\\n```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean isPalindrome(int x) {\\n        int r,s=0,c=x;\\n        while(x>0){\\n            r=x%10;\\n            s=(s*10)+r;\\n            x = x/10;\\n        }\\n        if(c==s) return true; \\n        else return false;\\n    }\\n    public static boolean isPrime(int num){\\n        boolean isPrime = true;\\n        if (num < 2) isPrime = false;\\n        else for (int i = 2; i <= Math.sqrt(num); i++) \\n               if (num % i == 0) {\\n                    isPrime = false;\\n                    break;\\n                }\\n        if (isPrime) return true;\\n        else return false;\\n    }\\n    public int primePalindrome(int n) {\\n        if(isPrime(n) && isPalindrome(n)) return n;\\n        else{\\n            while(true){\\n                if(isPrime(n) && isPalindrome(n)) return n;\\n                n++;\\n                if (10_000_000 < n && n < 100_000_000) n = 100_000_000;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158651,
                "title": "c-using-prime-sieve-and-palindromic-check",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359417,
                "title": "java-iterate-odd-length-palindromes-generate-next-palindrome-beats-100",
                "content": "**Iterate odd-length palindromes**\\n\\nPrerequisite knowledge: [Divisibility Rule of 11](https://en.wikipedia.org/wiki/Divisibility_rule)\\nA number is divisible by 11 iff difference between sum of its odd digits (i.e. digits at odd places) and sum of its even digits is divisible by 11.\\n\\nThis implies that all even-length palindromes are divisible by 11 since sum(odd digits) = sum(even digits). So even-length palindromes can not be primes except the number 11 itself.\\n\\nSo we skip even-length palindromes and iterate only over odd-length palindromes to look for primes. Iterating palindromes sequentially means iterating over their left half and appending the reverse of the left half as right half to construct the palindrome.\\n\\n```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Generate next palindrome**\\n\\nWe can borrow our knowledge from [564. Find the Closest Palindrome](https://leetcode.com/problems/find-the-closest-palindrome/discuss/960052/Find-previous-and-next-palindromes-detailed-explanation) to calculate next palindrome from a number. Another problem that can be solved using next palindrome idea: [906. Super Palindromes](https://leetcode.com/problems/super-palindromes/discuss/1198415/Java-Build-next-palindrome-Solve-2-Hards)\\n\\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\\n\\nNote that ``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ``` is just an optimization to skip over even-length numbers of length 8. Even if we remove these lines, the code runs in ```8 ms. 97.10%``` which isn\\'t too bad.",
                "solutionTags": [],
                "code": "```\\n// 5 ms. 99.03%\\nclass Solution {\\n    private int makePalindrome(int n) {\\n        int p = n;\\n        while((n /= 10) != 0)\\n            p = p * 10 + n % 10;\\n        return p;\\n    }\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N >= 8 && N <= 11) return 11;\\n        for(int i = 2; i < 100000; i++) {\\n            int p = makePalindrome(i);\\n            if(p >= N && isPrime(p)) return p;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\n// 1 ms. 100%\\nclass Solution {\\n    private boolean isPrime(int n) {\\n        if(n % 2 == 0) return n == 2;\\n        for(int i = 3, s = (int) Math.sqrt(n); i <= s; i += 2)\\n            if(n % i == 0) return false;\\n        return true;\\n    }\\n    private int next(int num) {\\n        char[] s = String.valueOf(num + 1).toCharArray();\\n        for(int i = 0, n = s.length; i < (n >> 1); i++) {\\n            while(s[i] != s[n - 1 - i]) {\\n                increment(s, n - 1 - i);\\n            }\\n        }\\n        return Integer.parseInt(new String(s));\\n    }\\n    private void increment(char[] s, int i) {\\n        while(s[i] == \\'9\\') s[i--] = \\'0\\';\\n        s[i]++;\\n    }\\n    public int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        int p = next(N - 1);\\n        while(!isPrime(p)) {\\n            if(10_000_000 <= p && p < 100_000_000)\\n                p = 100_000_000;\\n            p = next(p);\\n        }\\n        return p;\\n    }\\n}\\n```\n``` if(10_000_000 <= p && p < 100_000_000) p = 100_000_000; ```\n```8 ms. 97.10%```",
                "codeTag": "Java"
            },
            {
                "id": 147740,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int is_prime(int n) {\\n        if (n <= 1)\\n            return 0; \\n        int m = (int)(sqrt(n));\\n        for (int i = 2; i <= m; i++)\\n            if (n % i == 0)\\n                return 0;\\n        return 1;\\n    }\\n    \\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    int is_palindrome(int n){\\n        return n == reverse(n);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (1e7 <= N and N <= 1e8)\\n            N = 100030001;\\n        while(1){\\n            while(is_palindrome(N) == 0) N++;\\n            if (is_prime(N))\\n                return N;\\n            N++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354439,
                "title": "100-faster-c-improved-brute-force",
                "content": "## Improved Brute Force\\n\\n```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```C++\\n    bool isPrime(int n){\\n        if(n%2 == 0) return false;\\n        for(int i = 3; i <= pow(n, 0.5); i++){\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int n){\\n        int num = n,rev = 0;\\n        while(num > 0){\\n            rev  = rev*10 + num % 10;\\n            num /= 10;\\n        };\\n        return n==rev;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPalindrome(i) && isPrime(i)) return i;\\n            i += 2;     // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// all even pallindromes are divided by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1121912,
                "title": "python-100-faster-without-cheating-fully-commented",
                "content": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "So there\\'s definitely a lot that can be improved here, but it\\'s late and I\\'m not going to. There are a few tricks here I want to explain though. \\n\\nThe first is that every palindromic number with an even length is a multiple of 11. This means that 11 is the only even-length palindromic prime. So rather than write code that can handle small values of N in general, I decided to write code that assumed that N > 11, and then I did use a lookup table for the smaller values. (The sample solutions for the top-speed all seem to use a lookup table which contains every prime palindrome less than 2*10^8, and then they lookup the answer with a binary search. So when I say I don\\'t use a lookup table what I\\'m really reffering to is that I didn\\'t just do that)\\n\\nThe second trick I used is that I though of the palindromes as vectors, which I could write using linear combinations of easilly-constructible basis vectors. For example, the basis vectors for 5-digit palindromic numbers are:\\n[10001, 01010, 00100] -> [10001, 1010, 100]\\nWe can construct every 5-digit palindrome with a linear combination of these vectors. So if the digits of N are abcba, then we note that:\\nN = a x 10001 + b x 1010 + c x 100\\nTo be 5-digits, \\'a\\' cannot be 0. Furthermore, for \\'N\\' to have a chance of being prime, it must end with one of the digits (1, 3, 7, 9). This means that when we\\'re generating palindromes which we want to be prime, we can restrict a to just those digits. (Notably, if the number \\'abcba\\' is greater than the number \\'xyzyx\\', then the number \\'abc\\' is greater than \\'xyz\\' and vice versa - this allowed me to easilly generate the palindromic numbers in ascending order)\\n\\nFinally, I did a little work to figure out lower bounds on where to start searching for palindromes. It\\'s not perfect, but it\\'s good enough to significantly reduce the computation time (mostly by not generating palindromes the same length as N that are way less than N).\\n\\n(also, I am fully aware that there\\'s a lot of code here; this is not my most elegant solution ever, but beating a binary search of hard-coded answers was difficult)\\n\\nBest Performance: 28 ms/14.3 MB : 100%/32%\\n\\n\\'\\'\\'\\n\\n    #Check if a Number is Prime (Trial Division - So this is definitely improvable)\\n    def isPrime(self, n:int) -> bool:\\n        #Check Edge Cases and Division by 2 and 3\\n        if n == 2 or n == 3:\\n            return True\\n        elif n < 2 or n%2 == 0 or n%3 == 0:\\n            return False\\n        else:\\n            #Check Division by Odd Numbers (6*k +/- 1)\\n            return all(n%p != 0 != n%(p + 2) for p in range(5, int(n**0.5) + 1, 6))\\n    \\n    #Generate Prime Palindromes of Length D (d initially equals D)\\n    def primePalindromes(self, D:int, d:int) -> int:\\n        #Check the Base/Recursive Cases\\n        if d == 1:\\n            #If this is the Highest Level, Only Yield Primes\\n            if D == 1:\\n                #Yield Primes\\n                yield from (p for p in [2,3,5,7])\\n            else:\\n                #Yield Every Digit\\n                yield from range(10)\\n        elif d == D:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Since this is the Top Level, Only Check Candidate Primes\\n            for n in (1, 3, 7, 9):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble the Palindrome\\n                    p = n*v + 10*p\\n                    \\n                    #Check if it\\'s Prime\\n                    if self.isPrime(p):\\n                        #Yield the Prime Palindrome\\n                        yield p\\n        else:\\n            #Compute the Basis Vector for this Level of the Recursion\\n            v = 10**(d - 1) + 1\\n            \\n            #Try Every Digit\\n            for n in range(10):\\n                #Recursive Call\\n                for p in self.primePalindromes(D, d - 2):\\n                    #Assemble/Yield the Palindrome (This isn\\'t the top level, so it isn\\'t generally prime)\\n                    yield n*v + 10*p\\n    \\n    #Generate Odd Palindromes the Same Length as N Which are Greater than N\\n    def oddPalindromes(self, N:int) -> int:\\n        #Cast N to a String for Easier Digit Manipulation\\n        S = str(N)\\n        \\n        #Count the Number of Digits, and Compute the Number of Basis \"Vectors\" Required (Again, I know)\\n        d = len(S)\\n        D = d//2 + 1\\n        \\n        #Make the Basis Vectors (Ex: D = 5: basis = [10001, 01010, 00100])\\n        basis = []\\n        for i in range(D - 1):\\n            basis.append(10**(d - i - 1) + 10**(i))\\n        basis.append(10**(D - 1))\\n        \\n        #Yield Palindromes\\n        for i in range(int(S[:D]), 10**D):\\n            #Cast i to a String\\n            s = str(i)\\n            \\n            #Add Leading Zeros\\n            s = \\'0\\'*(D - len(s)) + s\\n            \\n            #Check if the Palindrome Might Be Prime\\n            if s[0] in (\\'1\\', \\'3\\', \\'7\\', \\'9\\'):\\n                #Assemble the Palindrome\\n                p = sum(b*int(c) for b, c in zip(basis, s))\\n                \\n                #Check the Size\\n                if p >= N:\\n                    yield p\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Check if N is Small (11 is Special Since All Even Palindromic Numbers are Multiples of 11)\\n        if N < 12:\\n            #Use a Lookup Table\\n            return [2, 2, 2, 3, 5, 5, 7, 7, 11, 11, 11, 11][N]\\n        else:\\n            #Generate Odd Palindromes Until the Solution is Either Found or Not Found\\n            d = len(str(N))\\n            if d%2 == 1:\\n                for p in self.oddPalindromes(N):\\n                    #Check if it\\'s a Solution\\n                    if self.isPrime(p):\\n                        return p\\n            else:\\n                #Decrement d (So that it will be accurate when we increment it later)\\n                d -= 1\\n            \\n            #Keep Generating Longer and Longer Prime Palindromes Until a Solution is Found\\n            while True:\\n                #Increment the Length of the Palindromes\\n                d += 2\\n                \\n                #Generate Palindromes Greater than N\\n                for p in self.primePalindromes(d, d):\\n                    #Return the Solution\\n                    return p\\n\\'\\'\\'\\n\\nAlso, for what it\\'s worth, there\\'s actually a slightly faster cheating solution. Instead of organizing all the primes in a single list, you can organize then in buckets based on the number of digits they have (plus a sentinel from the next bucket up). I didn\\'t save a huge amount of time, but it\\'s still significant since the solutions were already so quick to begin with! It is possible that this could be further improved by checking if N is odd and bigger than the biggest length-d solution before doing the binary search, but I doubt that\\'d be enough to get the run time down to 20 ms, and I\\'m not going to bother trying it.\\n\\nBest Performance: 24 ms/14.5 MB : 100%/14%\\n\\n\\'\\'\\'\\n\\n\\t#All the Solution Arranged by the Number of Digits\\n    primes = {1:[2,3,5,7,11],\\n              2:[11,101],\\n              3:[101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301],\\n              4:[10301],\\n              5:[10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,\\n                 15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,\\n                 30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,\\n                 36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,\\n                 72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,\\n                 78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,\\n                 95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001],\\n              6:[1003001],\\n              7:[1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,\\n                 1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,\\n                 1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,\\n                 1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,\\n                 1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,\\n                 1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,\\n                 1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,\\n                 1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,\\n                 1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,\\n                 1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,\\n                 1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,\\n                 1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,\\n                 1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,\\n                 1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,\\n                 1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,\\n                 1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,\\n                 1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,\\n                 1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,\\n                 1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,\\n                 3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,\\n                 3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,\\n                 3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,\\n                 3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,\\n                 3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,\\n                 3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,\\n                 3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,\\n                 3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,\\n                 3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,\\n                 3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,\\n                 3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,\\n                 3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,\\n                 3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,\\n                 3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,\\n                 3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,\\n                 3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,\\n                 3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,\\n                 3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,\\n                 7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,\\n                 7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,\\n                 7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,\\n                 7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,\\n                 7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,\\n                 7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,\\n                 7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,\\n                 7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,\\n                 7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,\\n                 7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,\\n                 7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,\\n                 7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,\\n                 7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,\\n                 7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,\\n                 7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,\\n                 9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,\\n                 9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,\\n                 9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,\\n                 9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,\\n                 9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,\\n                 9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,\\n                 9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,\\n                 9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,\\n                 9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,\\n                 9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,\\n                 9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,\\n                 9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,\\n                 9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,\\n                 9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,\\n                 9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001],\\n              8:[100030001],\\n              9:[100030001]}\\n    \\n    #Solve the Puzzle\\n    def primePalindrome(self, N: int) -> int:\\n        #Get the Number of Digits\\n        d = len(str(N))\\n        \\n        #Binary Search the Appropriate List\\n        return self.primes[d][bisect_left(self.primes[d], N)]\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 887035,
                "title": "fermat-s-little-theorem-to-check-odd-palindrome-for-prime-in-o-log-n-time",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    int oddPal(int num){\\n        int n=num;\\n        n/=10;\\n        while (n){\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        return num;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        set<int> tab;\\n        for (int i=1;i<=2*1e4+7;i++){\\n            if (i==11){\\n                tab.insert(11);\\n                continue;\\n            }\\n            int p=oddPal(i);\\n            if (fermatPrime(p)) tab.insert(p);\\n        }\\n        auto idx=tab.lower_bound(N);\\n        return *idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 767277,
                "title": "c",
                "content": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\n#define ll int\\nclass Solution {\\npublic:\\n    bool isPrime(ll n){\\n    if(n==1)return false;\\n    for(ll i=2;i*i<=n;i++)\\n        if(n%i==0)return false;\\n    return true;\\n    }\\n    int primePalindrome(int n) {\\n        if(n>=8 and n<=11){\\n            return 11;\\n        }\\n    for(ll i=1;i<=1000000;i++){\\n        string s=to_string(i);\\n        string r(s.rbegin(),s.rend());\\n        string y=s+r.substr(1);\\n        ll y1=stoi(y);\\n        if(y1>=n and isPrime(y1))\\n            return y1;\\n        }\\n    return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475536,
                "title": "java-solution-beats-99-93-time",
                "content": "The idea is to maintain an array of the digits of N (actually only the first half of them) and increase them to form valid palindromes. Then we check if they are also a prime number.\\n\\nThe solution is arguably a bit convoluted because of all the low-level operations, but fast due to the fact that it doesn\\'t rely on string operations.\\n\\nI also added skipping even-digit palindromes after I read that they cannot be prime numbers ( -_-\\' ), which makes it even faster. \\n\\n````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        if (N > 7 && N <= 11) return 11;\\n\\n        int digitsCount = (int)Math.floor(Math.log10(N)) + 1; // number of digits of N\\n        if (digitsCount % 2 == 0) { N = (int)Math.pow(10, digitsCount); digitsCount++; } // skip even-digits palindromes\\n        int[] digits = new int[(digitsCount + 1) / 2]; // array of half the length of the number of digits\\n        // put the first half of the digits of N in the array\\n        int n = N, count = 0;\\n        while (n > 0) {\\n            if (++count > (digitsCount + 1) / 2) digits[digitsCount - count] = n % 10;\\n            n /= 10;\\n        }\\n\\n        while (true) {\\n            // create a palindrome number based on the current digits and check if it\\'s a prime\\n            int number = 0;\\n            for (int i = 0; i < digitsCount; i++) {\\n                int index = i < digits.length ? i : digitsCount - i - 1;\\n                number = number * 10 + digits[index];\\n            }\\n            if (number >= N && isPrime(number)) return number;\\n            \\n            // if not, increment the digits to generate the next valid palindrome\\n            boolean increment = true;\\n            for (int i = digits.length - 1; increment && i >= 0; i--) {\\n                if (i == 0) {\\n                    if ((digits[0] & 1) != 1) digits[0]++;\\n                    else if (digits[0] == 9) {\\n                        digitsCount += 2;\\n                        digits = new int[(digitsCount + 1) / 2];\\n                        digits[0] = 1;\\n                    } else {\\n                        digits[0] += 2;\\n                    }\\n                } else if (digits[i] == 9) {\\n                    digits[i] = 0;\\n                    increment = true;\\n                } else {\\n                    digits[i] += 1;\\n                    increment = false;\\n                }\\n            }\\n        }\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        \\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148253,
                "title": "straightforward-c-solutions-with-detailed-explanations",
                "content": "**Solution #1:** For small values of N less than or equal to ```11```, simply return the smallest prime value.  For values of N greater than ```11```, the next prime palindrome is ```101```.  Use the value ```i``` from ```[10:999999]``` to represent the first \"half\" of a candidate integer palindrome.  The value ```i``` is converted to a string order to construct the odd length palindrome ```101``` ( by pushing ```1``` onto the end of ```10``` ) and to construct the even length palindrome ```1001``` ( by pusing ```01``` onto the end of ```10``` ).  Always check if the odd length integer palindrome is prime first (since it has a smaller value than the even length integer palindrome) and check if the even length integer palindrome is prime second.  Return the integer value of the first found prime integer palindrome in this order.\\n\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**Note:** If this code looks strange, then just try stepping through the code for the first few values of ```i```.  As you can see, the integer value ```i``` is the first \"half\" of the palindrome:\\n\\n```i=10    odd=101    even=1001```\\n```i=11    odd=111    even=1111```\\n```i=12    odd=121    even=1221```\\n\\n```etc...```\\n\\n**Solution #2:** there are 782 prime palindrome (```PP```) candidates for the range ```1 <= N <= 10^8``` simply return the ```lower_bound``` of this ordered set ```PP```.  \\n**Note:** I printed this set as output from solution #1 above, so it is in ascending order.  I used ```iomanip``` to write to the ostream in hex left-padded with zeros so that the integer values are uniformly distributed along columns for enhanced readability.\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "solutionTags": [],
                "code": "```11```\n```11```\n```101```\n```i```\n```[10:999999]```\n```i```\n```101```\n```1```\n```10```\n```1001```\n```01```\n```10```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N<12) return N<=2 ? 2 : N<4 ? 3 : N<6 ? 5 : N<8 ? 7 : 11;\\n        for (int i=10; i<1000000; ++i){\\n            string odd=to_string(i),even(odd+odd.back());\\n            for (int j=int(odd.size())-2; j>=0; --j){\\n                odd.push_back(odd[j]);\\n                even.push_back(odd[j]);\\n            }\\n            int p=stoi(odd),q=stoi(even);\\n            if (p>=N && isPrime(p))\\n                return p;\\n            if (q>=N && isPrime(q))\\n                return q;\\n        }\\n        return -1;\\n    }\\nprivate:\\n    bool isPrime(int x) {\\n        for (int i=2,M=(int)ceil(sqrt(x)); i<=M; ++i)\\n            if (x%i==0)\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```i```\n```i```\n```i=10    odd=101    even=1001```\n```i=11    odd=111    even=1111```\n```i=12    odd=121    even=1221```\n```etc...```\n```PP```\n```1 <= N <= 10^8```\n```lower_bound```\n```PP```\n```iomanip```\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        return *lower_bound(PP.begin(),PP.end(),N);\\n    }\\nprivate:\\n    const set<int> PP{\\n 0x00000002,0x00000003,0x00000005,0x00000007,0x0000000b,0x00000065,0x00000083,0x00000097,0x000000b5,0x000000bf,\\n 0x00000139,0x00000161,0x00000175,0x0000017f,0x000002d7,0x000002f5,0x00000313,0x0000031d,0x00000397,0x000003a1,\\n 0x0000283d,0x00002905,0x00002969,0x00002c2f,0x00002c93,0x00003085,0x000031b1,0x00003215,0x00003413,0x00003607,\\n 0x0000366b,0x00003805,0x00003995,0x00003c5b,0x00003cbf,0x00003ebd,0x00003fe9,0x000040b1,0x00004115,0x0000443f,\\n 0x00004633,0x00004705,0x00004831,0x00004bbf,0x00004db3,0x00004e17,0x00007597,0x000075fb,0x000076c3,0x000077ef,\\n 0x00007853,0x00007925,0x00007b19,0x00007e43,0x00007ea7,0x000082fd,0x000086ef,0x0000881b,0x000088ed,0x00008951,\\n 0x00008a19,0x00008ba9,0x00008da7,0x00008ed3,0x00009199,0x000092c5,0x000094c3,0x00009527,0x0000977f,0x0000997d,\\n 0x0001123f,0x0001136b,0x000113cf,0x00011695,0x000118ed,0x00011a23,0x00011c17,0x00011d4d,0x00011e15,0x00011fa5,\\n 0x0001213f,0x000123fb,0x00012725,0x00012a4f,0x00012b7b,0x00012e41,0x00012ea5,0x00013099,0x00013297,0x000133c3,\\n 0x00013427,0x00013625,0x00013751,0x0001387d,0x00016255,0x0001638b,0x00016bd3,0x00016c37,0x00016e2b,0x00016f61,\\n 0x0001708d,0x000171b9,0x00017281,0x000172e5,0x000176d7,0x0001780d,0x000178d5,0x00017a01,0x00017c63,0x00017d2b,\\n 0x00017e57,0x00018055,0x00018181,0x000f4df9,0x000f6181,0x000f98f9,0x000fb069,0x000fcc25,0x000febc9,0x00101b0d,\\n 0x001036c9,0x00104281,0x0010660d,0x001085b1,0x00109169,0x0010ad25,0x0010b10d,0x0010ffff,0x00110bb7,0x001117d3,\\n 0x0011238b,0x00112f43,0x00113afb,0x00114ee7,0x00117a43,0x00118e2f,0x001199e7,0x0011b5a3,0x0011c15b,0x0011f09f,\\n 0x0011f86f,0x0011fc57,0x0012048b,0x00121043,0x00121bfb,0x00122bff,0x001237b7,0x0012436f,0x0012537d,0x00126ed5,\\n 0x00127ed9,0x00128a91,0x00129649,0x0012a265,0x0012d979,0x0012f535,0x0012f91d,0x001300ed,0x001314d9,0x00132091,\\n 0x00133031,0x0013441d,0x00135b8d,0x00136f79,0x00137b31,0x00138301,0x00138b35,0x00138f1d,0x0013a2a5,0x0013a68d,\\n 0x0013d63f,0x0013e1f7,0x0014019b,0x0014190b,0x0014407f,0x00144467,0x00145853,0x00146023,0x00146bdb,0x00147fc7,\\n 0x0014c2f7,0x0014cac7,0x0014ceaf,0x0014ee53,0x0014fa0b,0x00153953,0x00157841,0x00158011,0x00158845,0x00158c2d,\\n 0x0015b3a1,0x0015ee9d,0x00160a59,0x00161611,0x001629fd,0x0016399d,0x00164d89,0x00165559,0x00165941,0x00166cc9,\\n 0x0016aff9,0x0016bbb1,0x0016bffd,0x0016d76d,0x001702d3,0x001716bf,0x0017327b,0x001761bf,0x00176d77,0x00178933,\\n 0x0017a0a3,0x0017a8d7,0x0017acbf,0x0017c047,0x0017c42f,0x0017e3d3,0x0017ff8f,0x00181ae7,0x00181f33,0x00182aeb,\\n 0x0018425b,0x00185647,0x001861ff,0x001865e7,0x00186a3d,0x00188d65,0x00189599,0x0018a921,0x0018d865,0x0018e099,\\n 0x0018ec51,0x0019080d,0x001913c5,0x00191f7d,0x00193f21,0x00194ad9,0x00194ec1,0x001956f5,0x00197e69,0x0019b57d,\\n 0x0019b965,0x0019c51d,0x0019e0d9,0x0019fc9f,0x001a0c3f,0x001a202b,0x001a27fb,0x001a6743,0x001a76e3,0x001a829b,\\n 0x001aadf7,0x001ac9b3,0x001ae187,0x001aed3f,0x001b206b,0x001b5fb3,0x001b7f61,0x001b8b19,0x001bc679,0x001bd231,\\n 0x001bd619,0x001bdde9,0x001be9a1,0x001bf1d5,0x001bf5bd,0x001c1d31,0x001c40bd,0x001c488d,0x001c5445,0x001c77d1,\\n 0x001ca32d,0x001caafd,0x001caee5,0x001cb331,0x001cb719,0x001cbee9,0x001cc2d1,0x001cee2d,0x001d09f3,0x001d1d7b,\\n 0x001d2163,0x001d4107,0x001d5cc3,0x001d7497,0x001d8c07,0x001d9ff3,0x001dc767,0x001dcb4f,0x001dded7,0x001de2bf,\\n 0x001df6ab,0x001e0a33,0x001e0e1b,0x001e1267,0x001e29d7,0x001e3dc3,0x001e41ab,0x001e497b,0x001e5533,0x001e591b,\\n 0x001e6d07,0x001e74d7,0x001e808f,0x002dcaab,0x002dce93,0x002de21b,0x002e05a7,0x002e2d1b,0x002ec31b,0x002ec703,\\n 0x002ee2bf,0x002ee6a7,0x002eee77,0x002f0e1b,0x002f258b,0x002f2dbf,0x002f3d5f,0x002f5925,0x002f64dd,0x002fb7ad,\\n 0x002fd751,0x002feb3d,0x00302639,0x003031f1,0x00303a25,0x00305195,0x00308cf5,0x0030a465,0x0030bc39,0x0030c7f1,\\n 0x0030cfc1,0x0030ff73,0x0031035b,0x00311acb,0x00312acf,0x00312eb7,0x0031423f,0x0031562b,0x003161e3,0x003175cf,\\n 0x0031856f,0x0031a12b,0x0031b0cb,0x0031b89b,0x0031c0cf,0x0031dc27,0x0031f013,0x00321b6f,0x0032233f,0x00322727,\\n 0x00322ef7,0x00323b13,0x003242e3,0x00326a61,0x00326e49,0x00327619,0x00328235,0x003295bd,0x0032a55d,0x0032ad91,\\n 0x0032ccd1,0x0032d505,0x0032ec75,0x00330449,0x00332bbd,0x00334f49,0x00335719,0x00335b01,0x003366b9,0x00339661,\\n 0x0033c1bd,0x0033c5a5,0x0033e16b,0x00340cc7,0x00342437,0x00343ff3,0x003443db,0x00344bab,0x00347aef,0x00348323,\\n 0x00348af3,0x00348edb,0x00349a93,0x0034a263,0x0034ae7f,0x0034ce23,0x0034e593,0x0034f597,0x003518bf,0x00353093,\\n 0x00353863,0x003573cd,0x0035a311,0x0035aae1,0x0035d63d,0x003609cd,0x00363911,0x00364c99,0x00366085,0x003677f5,\\n 0x0036bb25,0x0036c6dd,0x0036cb29,0x0036cf11,0x0036dac9,0x0036f2a7,0x00370a17,0x00373573,0x0037418f,0x003758ff,\\n 0x003778a3,0x00379847,0x0037a3ff,0x003802eb,0x00380ea3,0x00382a5f,0x00384d87,0x00387113,0x003894a9,0x00389891,\\n 0x0038b44d,0x0038b835,0x0038c839,0x0038cc21,0x0038e391,0x0038f395,0x00391ef1,0x00392aa9,0x003969f1,0x00396dd9,\\n 0x003975a9,0x00398161,0x00398549,0x0039954d,0x00399935,0x0039b4f1,0x0039c0a9,0x0039e04d,0x0039e435,0x0039fba5,\\n 0x003a0bb3,0x003a1383,0x003a2b57,0x003a3327,0x003a626b,0x003a6e23,0x003a89df,0x003aa1b3,0x003acd0f,0x003ae097,\\n 0x003af483,0x003af86b,0x003b0423,0x003b0bf3,0x003b1427,0x003b2f7f,0x003b6adf,0x003b824f,0x003bb5e9,0x003bc1a1,\\n 0x003bc971,0x003be145,0x003becfd,0x003bfd01,0x003c1859,0x003c285d,0x003c37fd,0x003c3fcd,0x003c7f15,0x003c96e9,\\n 0x003cca15,0x003ce9b9,0x003cf571,0x003d0129,0x003d0511,0x006b06db,0x006b59ab,0x006b5d93,0x006b717f,0x006b8507,\\n 0x006bb063,0x006bd007,0x006bdfa7,0x006befab,0x006c071b,0x006c1337,0x006c1b07,0x006c26bf,0x006c3e93,0x006c4a4b,\\n 0x006c5671,0x006c8d85,0x006c916d,0x006c9d25,0x006cc881,0x006cdc6d,0x006ce43d,0x006cf829,0x006d07c9,0x006d2f3d,\\n 0x006d3325,0x006d3af5,0x006d3edd,0x006d85f5,0x006db985,0x006dc925,0x006e1817,0x006e4373,0x006e925b,0x006e9e13,\\n 0x006ea25f,0x006eb9cf,0x006ebdb7,0x006ecdbb,0x006ee52b,0x006f08b7,0x006f1087,0x006f4417,0x006f63c5,0x006f6b95,\\n 0x006f8b39,0x006f9ad9,0x006fc24d,0x006fce05,0x00701ced,0x007030d9,0x007038a9,0x0070584d,0x00706405,0x0070a34d,\\n 0x0070bea5,0x0070cea9,0x0070ee57,0x0070f627,0x00710d97,0x0071256b,0x0071706b,0x0071783b,0x007183f3,0x0071b783,\\n 0x0071db0f,0x0071ee97,0x0072066b,0x00721223,0x00723997,0x00723d7f,0x00724937,0x0072593b,0x00728c71,0x00729059,\\n 0x0072b7cd,0x0072bbb5,0x0072c3e9,0x0072db59,0x00730ee9,0x007365a1,0x00736d71,0x00739cb5,0x0073c429,0x0073dbfd,\\n 0x0073e3cd,0x0073f7c3,0x0074231f,0x0074425f,0x00744e7b,0x00746e1f,0x007475ef,0x0074a533,0x0074cca7,0x0074ec4b,\\n 0x0074f803,0x0074fbeb,0x007503bb,0x007507a3,0x00751b8f,0x0075374b,0x00755ad7,0x0075668f,0x00757247,0x0075b969,\\n 0x0075c521,0x0075d525,0x0075f07d,0x00760081,0x0076240d,0x00763795,0x007643b1,0x007662f1,0x00767ac5,0x00769a69,\\n 0x0076a239,0x0076b1d9,0x0076c1dd,0x0076c5c5,0x0076e569,0x0076f121,0x0077206f,0x00774fb3,0x007753ff,0x007757e7,\\n 0x00777f5b,0x00778343,0x00779ab3,0x0077ae9f,0x0077ca5b,0x0077e1cb,0x00780557,0x00780d27,0x0078110f,0x007824fb,\\n 0x00785057,0x00786c13,0x00788383,0x0078beed,0x0078caa5,0x0079021d,0x00790dd5,0x007915a5,0x0079215d,0x00792d79,\\n 0x00793549,0x00794cb9,0x00796c5d,0x00797045,0x00797879,0x0079bb45,0x0079d701,0x0079dae9,0x0079e2b9,0x007a0645,\\n 0x00895c19,0x00898f45,0x0089b2d1,0x0089e5fd,0x0089f9e9,0x0089fdd1,0x008a05a1,0x008a0989,0x008a1541,0x008a5c59,\\n 0x008a742d,0x008a7fe5,0x008a87b5,0x008abb45,0x008acae5,0x008ae6ab,0x008afe1b,0x008b0267,0x008b4533,0x008b491b,\\n 0x008b68bf,0x008b9beb,0x008bead3,0x008bfad7,0x008bfebf,0x008c1247,0x008c2a1b,0x008c5577,0x008c612f,0x008c619d,\\n 0x008c84c5,0x008c90e1,0x008ca469,0x008cb855,0x008cbc3d,0x008cd7f9,0x008cdbe1,0x008d3a69,0x008d717d,0x008d79b1,\\n 0x008d9121,0x008d9d3d,0x008db4ad,0x008dc065,0x008e2efb,0x008e372f,0x008e46cf,0x008e5a57,0x008e6673,0x008e7de3,\\n 0x008eb173,0x008ec8e3,0x008f0ffb,0x008f3387,0x008f66b3,0x008f6ef1,0x008fa605,0x008fb98d,0x008ff105,0x00900875,\\n 0x00900cc1,0x00902431,0x0090381d,0x0090831d,0x00909e75,0x0090d9d5,0x0090ddbd,0x0090e58d,0x0091053b,0x00912caf,\\n 0x00915bf3,0x009167ab,0x0091aec3,0x0091d24f,0x0091da1f,0x0091e63b,0x0092251f,0x00923cf3,0x009244c3,0x009248ab,\\n 0x0092802d,0x00928415,0x00928be5,0x0092a3b9,0x0092cb2d,0x0092dacd,0x0092e29d,0x0092fa71,0x00930241,0x00932d9d,\\n 0x00934189,0x00935ce1,0x00939071,0x0093cf55,0x009402ef,0x00942617,0x00942e4b,0x00943a03,0x00946177,0x00946d2f,\\n 0x0094811b,0x00948503,0x0094ac77,0x0094c3e7,0x0094d003,0x0094d7d3,0x0094e773,0x0094f777,0x0095171b,0x00952e8b,\\n 0x00953a43,0x00954277,0x0095465f,0x009559e7,0x00955dcf,0x0095798b,0x00958d81,0x0095a4f1,0x0095acc1,0x0095cc65,\\n 0x0095d04d,0x0095d881,0x0095e051,0x00961765,0x00961b4d,0x00963af1,0x009656ad,0x0096a1ad,0x0096e479,0x0096e861,\\n 0x0097041d,0x00971813,0x00972b9b,0x00972f83,0x00974f27,0x009756f7,0x00975adf,0x00976313,0x00976ae3,0x0097769b,\\n 0x00977a83,0x00978a87,0x00978e6f,0x00979a27,0x0097a5df,0x0097f0df,0x00981083,0x009843af,0x00984be3,0x00984fcb,\\n 0x00986f0b,0x05f65631,};\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553716,
                "title": "explained-fastest-solution-c-odd-length-palindromes",
                "content": "# Brute Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn brute force algorithm, we will iterate over all $i$ for $>=n$ && $<=2*10^8$ and check if that is prime and is palindrome or not. \\nAs soon as some i satisfies this equation, we will return the i.\\n\\nTime complexity to find if n is prime or not $O(sqrt(n))$\\nTime complexity to find if n is palindrome or not $O(log(n))$\\n\\nOverall this brute approach will take too much time complexity.\\n\\nThe optimized solution is deduced from one fact ------\\nAll even length palindrome are divisble by 11.\\nAnd among all even length palindrome only 11 is prime. \\nSo now we have to worry about only odd length palindrome.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow, we make such algorithm which only checks for odd length palindrome and checks if that is prime or not.\\n\\nThis question also teaches us how to print all odd length palindrome efficiently.\\n\\nBrute way would be to iterate over all possibilities and check if it is odd or not. \\n\\nThe optimised solution to get only odd length palindrome is by making odd length palindrome.\\n\\nNow we need to see that the answer lies between $[2,2*10^8]$. \\n200000000 ---It is of length 9.\\nSo the palindrome will be abcdedcba.\\nSo, if we iterate over all abcde, we can make a corresponding palindrome and it will be a odd length too.\\nSo by just iterating over abcde, i.e. 10^5. We can create all palindromes less than $2*10^8$ without iteration.\\n\\n# Individual Complexity\\n- Time complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere \\ni will be $1<=i<=1e5$\\nI checked time complexities of the inbuilt functions also ans \\nto_string(i)-------------------->$O(log(i))$\\nas there are $log(i)$ digits in integer $i$\\nreverse(s.begin(),s.end())-----> $O(log(i))$\\nstoi(s)-------------------------> $O(2*(log(i))-1)$ \\nas the total length will $log(i)+log(i)-1$\\nisprime(x)---------------------> $O(sqrt(x))$\\n\\n# Overall  Complexity\\nTime complexity: $O(100000)*[O(log(i)) + O(log(i)) + O(2*log(i)-1) + sqrt(x)]$\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n    \\n    bool isprime(int n)\\n    {\\n        if(n==0 || n==1) return false;\\n        for(int i =2;i*i<=n;i++)\\n        {\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) \\n    {\\n        std::ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        if(n>=8 && n<=11) return 11;\\n        for(int i =1;i<=100000;i++)\\n        {\\n            string s = to_string(i); //convert int to string\\n            string r =s; \\n            reverse(r.begin(),r.end()); //reverse the string and store in r\\n            int y = stoi(s+r.substr(1)); //  adding r in s except first character and convering to integer\\n            if(y>=n && isprime(y)) return y; // checking if it is prime or not.\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3499365,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\\n\\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t(s.rbegin(), s.rend()) ;\\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n```\n```Java []\\nclass Solution {\\n    private int n;\\n    private int numDigits;\\n    private static ArrayList<Integer> primes;\\n    private static int lastChecked = 1;\\n    public int primePalindrome(int nInput) {\\n        n = nInput;\\n        if (n==1 || n==2){\\n            return 2;\\n        }\\n        if (n==4 || n==5){\\n            return 5;\\n        }\\n        if (primes == null){\\n            primes = new ArrayList<Integer>();\\n            primes.add(2);\\n        }\\n        numDigits = 1;\\n        while (n >= Math.pow(10, numDigits)){\\n            numDigits++;\\n        }\\n        if (numDigits%2 == 0 && n > 11){\\n            n = (int)Math.pow(10, numDigits)+1;\\n            numDigits++;\\n        }\\n        int msd = getDigit(numDigits);\\n        if (msd%2 == 0 || msd == 5){\\n            if (msd >= 4 && msd <= 6){\\n                msd = 7;\\n            } else {\\n                msd++;\\n            }\\n            n = msd;\\n            if (numDigits!=1){\\n                n+=msd * (int)Math.pow(10, numDigits-1);\\n            }\\n        } else {\\n            for (int i = (numDigits+1)/2; i > 0; i--){\\n                setDigit(i, getDigit(numDigits-i+1));\\n            }\\n            if (n < nInput){\\n                increment();\\n            }\\n        }\\n        while (!isPrime()){\\n            increment();\\n        }\\n        return n;\\n    }\\n    private int getDigit(int i) {\\n        return (n%(int)Math.pow(10, i))/(int)Math.pow(10, i-1);\\n    }\\n    private void setDigit(int i, int m) {\\n        int first = n-n%(int)Math.pow(10, numDigits-i+1);\\n        int middle = Math.max(0, n%(int)Math.pow(10, numDigits-i)\\n            - n%(int)Math.pow(10, i));\\n        int last = n%(int)Math.pow(10, i-1);\\n        n = first + middle + last + m*(int)Math.pow(10, i-1);\\n        if (i != numDigits-i+1){\\n            n += m*(int)Math.pow(10, numDigits-i);\\n        }\\n    }\\n    private void increment(){\\n        for (int i = (numDigits+1)/2; i > 0; i--){\\n            int curDigit = getDigit(i);\\n            if (i == 1 && curDigit == 9){\\n                if (numDigits == 1){\\n                    n = 11;\\n                    numDigits = 2;\\n                    return;\\n                } else {\\n                    n = (int)Math.pow(10, numDigits+1)+1;\\n                    numDigits+=2;\\n                    return;\\n                }\\n            } else if (curDigit == 9){\\n                setDigit(i, 0);\\n            } else {\\n                curDigit++;\\n                if (i == 1){\\n                    if (curDigit%2 == 0 || curDigit == 5){\\n                        if (curDigit >= 4 && curDigit <= 6){\\n                            curDigit = 7;\\n                        } else {\\n                            curDigit++;\\n                        }\\n                    }\\n                }\\n                setDigit(i, curDigit);\\n                return;\\n            }\\n        }\\n    }\\n    private boolean isPrime() {\\n        int end = (int)Math.sqrt(n);\\n        for (int i = lastChecked+2; i <= end; i+=2){\\n            if (isPrimeLookup(i)){\\n                primes.add(i);\\n            }\\n            lastChecked = i;\\n        }\\n        return isPrimeLookup(n);\\n    }\\n    private boolean isPrimeLookup(int m){\\n        int end = (int)Math.sqrt(m);\\n        for (int i = 0; i < primes.size() && primes.get(i) <= end; i++){\\n            if (m%primes.get(i) == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359291,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1>Check if n is a palindrome. If it is, check if it is a prime number. If it is, return n.\\n2>Otherwise, increment n by 1 and repeat step 1 until a palindrome prime is found.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this algorithm depends on the number of steps it takes to find a palindrome prime greater than or equal to n. The worst-case scenario is when n is a large prime number and the next palindrome prime is much large.\\n\\n- Space complexity:\\nThe space complexity of this algorithm is O(1) .\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n#1 best \\n        def is_palindrome(x):\\n            return str(x) == str(x)[::-1]\\n        \\n        def is_prime(x):\\n            if x < 2:\\n                return False\\n            for i in range(2, int(x ** 0.5) + 1):\\n                if x % i == 0:\\n                    return False\\n            return True\\n        \\n        while True:\\n            if is_palindrome(n) and is_prime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n        #2 TLE\\n        # def is_prime(number):\\n        #     if number > 1:\\n        #         for num in range(2, number):\\n        #             if number % num == 0:\\n        #                 return False\\n        #         return True\\n        #     return False\\n\\n        # n_str = str(n)\\n        # l = len(n_str)        \\n        # for k in range(max(0, l//2-1), 5):\\n        #     for i in range(10**k, 10**(k+1)):                            # odd length\\n        #         i_str = str(i)\\n        #         if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n        #         cur = i_str + i_str[-2::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n                \\n        #     for i in range(10**k, 10**(k+1)):                            # even length\\n        #         i_str = str(i)\\n        #         if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n        #         cur = i_str + i_str[::-1]\\n        #         cur_int = int(cur)\\n        #         if cur_int >= n and is_prime(cur_int): \\n        #             return cur_int\\n        # return -1\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #3 TLE\\n        # if 8 <= n <= 11: return 11\\n        # for x in range(10 ** (len(str(n))// 2), 10**5):\\n        #     y = int(str(x) + str(x)[-2::-1])\\n        #     if y >= n and is_prime(y): return y\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        # #4 it gives TLE\\n        # res=n\\n        # c=1\\n        # while c:\\n        #     if str(res)==str(res)[::-1] and is_prime(res)==True:\\n        #         c=0\\n        #     else:\\n        #         res+=1\\n        # return res\\n            \\n\\n     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056719,
                "title": "intuitive-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n == 0 || n == 1) return 2;\\n        return helper(n); \\n    }\\n\\n    int helper(int n) {\\n        if (10_000_000 < n && n < 100_000_000) return helper(100_000_000);\\n        if(isPrime(n) && isPal(n)) return n;\\n        if(n % 2 == 0) {\\n            return helper(n+1);\\n        }else{\\n            return helper(n+2);\\n        }\\n    }\\n\\n    boolean isPrime(int n) {\\n\\n        for(int i = 2; i<=(int) Math.sqrt(n); i++) {\\n            if(n%i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n\\n    boolean isPal(int n) {\\n        int rev = 0;\\n        int temp = n;\\n        while(n != 0) {\\n            int r = n%10;\\n            rev = rev*10+r;\\n            n = n/10;\\n        }\\n        return rev == temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783372,
                "title": "c-faster-than-all-easy",
                "content": "\\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    bool ispalin(int z)\\n    {\\n        string s=to_string(z);\\n        int i=0,j=s.length()-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    bool sieve(int n)\\n    {\\n        if(n==1)\\n        return false;\\n        for(ll i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            return false;\\n        }\\n        return true;\\n    }\\n    int primePalindrome(int n) {\\n        if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for(int j=n;j<1e8;j++)\\n        {\\n           if(sieve(j))\\n          {\\n               if(ispalin(j))\\n               {\\n                    return j;\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416992,
                "title": "python-very-fast-solution",
                "content": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrime(self, num):\\n        from math import sqrt\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            limit = pow(10, len(str(n)) // 2)\\n        else:\\n            n_string = str(n)\\n            limit = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(limit), 20000):\\n            y = int(str(i) + str(i)[:-1][::-1])\\n            if y >= n and self.isPrime(y):\\n                return y\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283352,
                "title": "easy-to-understand-java",
                "content": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int primePalindrome(int N)\\n    {\\n        int result = 0 ;\\n        if( N == 2 || N == 0 || N == 1 )\\n        {\\n            return 2 ;\\n        }\\n        if( N % 2 == 0 )\\n        {\\n            N++ ;\\n        }            \\n        while( true )\\n        {\\n            StringBuilder sb = new StringBuilder(Integer.toString(N));            \\n            if( N == Integer.parseInt( new String( sb.reverse()) ) && isPrime(N) )\\n            {\\n                return N ;\\n            }            \\n            N = N + 2 ;\\n            if( N > 11 && N < 100 )\\n            {\\n                N = 101 ;\\n            }\\n            if( N > 999 && N < 10000 )\\n            {\\n                N = 10001 ;\\n            }\\n            if( N > 99999 && N < 1000000 )\\n            {\\n                N = 1000001 ;\\n            }\\n            if( N > 9999999 && N < 100000000 )\\n            {\\n                N = 100000001 ;\\n            }\\n        }\\n    } \\n    boolean isPrime( int N )\\n    {\\n        int i ;                    \\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }                    \\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n        return true ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216347,
                "title": "c-8-12-ms-with-5-8-5-9-mb",
                "content": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }\\n\\n        // Search until the prime palindrome is returned\\n        while(true)\\n        {         \\n            // Reset the mirrored nmb\\n            mirroredNmb = 0;\\n            // Set the current number which is to be checked if it\\'s palindrome\\n            temp = n;\\n\\n            // While there are digits to read...store them in mirroredNmb\\n            do\\n            {\\n                mirroredNmb = mirroredNmb * 10 + temp % 10;\\n                temp /= 10;\\n            }while(temp > 0);\\n            \\n            // Check if it\\'s a palindrome\\n            if(mirroredNmb == n)\\n            {\\n                // Store the limit to which the number the palindrome number can be checked if prime\\n                temp = sqrt(n);\\n                for(x=2;x<=temp;++x)\\n                {\\n                    // In case this is true then this number is not prime\\n                    if((n % x) == 0)\\n                    {\\n                        break;\\n                    }\\n                }\\n\\n                // If the iterator has gone above the limit then this is a prime\\n                if(x > temp)\\n                {\\n                    return n;    \\n                }                    \\n            }\\n            \\n            ++n;\\n            \\n            // After some time in which I couldn\\'t get it why the solution is not accepted...I\\'ve read their \\n\\t\\t\\t// solution and saw that in this interval there are no prime palindromes....\\n            // Therefore, set it to the next palindrome prime number :) All this I see it more like a hack...but whatevs\\n            if(n >= 10000000 && n <= 100000000)\\n            {\\n                n = 100030001;\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int n)\\n    {        \\n        \\n\\t\\t// Used for iterating to see if it\\'s a prime number\\n        int x;\\n        // Used to store the current number, mirrored..as to check if it\\'s palindrome\\n        int mirroredNmb;\\n        // Temporary variable used for different calculations\\n        int temp;\\n        \\n        // Just in case, set to 2\\n        if(n <= 1)\\n        {\\n            n = 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1178225,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n1. \\u8D28\\u6570\\u7684\\u68C0\\u67E5\\uFF0C\\u53EA\\u68C0\\u67E5\\u4ECE2\\u5230sqrt(x)\\uFF0C\\u4F1A\\u4E0D\\u4F1A\\u6709\\u53EF\\u4EE5\\u6574\\u9664x\\u7684\\u6570\\u5B58\\u5728\\uFF0C\\u56E0\\u4E3A\\u540E\\u4E00\\u534A\\u80AF\\u5B9A\\u4E0D\\u4F1A\\uFF1B\\n2. \\u53EA\\u68C0\\u67E5\\u957F\\u5EA6\\u662F\\u5947\\u6570\\u7684\\u56DE\\u6587\\u6570\\uFF0C\\u56E0\\u4E3A\\u957F\\u5EA6\\u662F\\u5076\\u6570\\u7684\\u56DE\\u6587\\u6570\\u4E00\\u5B9A\\u4F1A\\u88AB11\\u6574\\u9664\\uFF1B\\n3. \\u7279\\u6B8A\\u60C5\\u51B5\\uFF1A\\u5728[8, 11]\\u8303\\u56F4\\u5185\\uFF0C\\u8FD4\\u56DE11\\uFF1B\\n4. \\u91C7\\u7528\\u5148\\u62FC\\u63A5\\u51FA\\u56DE\\u6587\\u6570\\uFF0C\\u518D\\u5224\\u65AD\\u662F\\u5426\\u6EE1\\u8DB3\\u8981\\u6C42\\uFF0C\\u4E0D\\u5C0F\\u4E8EN\\u4E14\\u662F\\u8D28\\u6570\\u3002",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int x)\\n    {\\n        if (x <= 2)\\n        {\\n            return (x == 2);\\n        }\\n        int upper_limit = sqrt(x);\\n        for (int i = 2; i <= upper_limit; ++i)\\n        {\\n            if (x % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11)\\n        {\\n            return 11;\\n        }\\n        int res;\\n        for (int i = 1; i < 1e5; ++i)\\n        {\\n            std::string s = to_string(i);\\n            std::string t(s.rbegin(), s.rend());\\n            s += t.substr(1);\\n            int tmp_num = stoi(s);\\n            if (tmp_num >= N && isPrime(tmp_num))\\n            {\\n                res = tmp_num;\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845960,
                "title": "prime-palindrome",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def getPalindromes(n: int) -> int:\\n            length = n // 2\\n            for i in range(10**(length - 1), 10**length):\\n                s = str(i)\\n                for j in range(10):\\n                    yield int(s + str(j) + s[::-1])\\n\\n        def isPrime(num: int) -> bool:\\n            return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\\n\\n        if N <= 2:\\n            return 2\\n        if N == 3:\\n            return 3\\n        if N <= 5:\\n            return 5\\n        if N <= 7:\\n            return 7\\n        if N <= 11:\\n            return 11\\n\\n        n = len(str(N))\\n\\n        while True:\\n            for num in getPalindromes(n):\\n                if num >= N and isPrime(num):\\n                    return num\\n            n += 1\\n            \\n\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 707393,
                "title": "python3-check-next-palindrome-prime-palindrome",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(N):\\n            return N > 1 and all(N % d for d in range(2, int(N**0.5)+1))\\n        \\n        # N must be a palindrome with odd number of digits.\\n        # The return value will have odd number of digits too.\\n        def nextPalindrome(N):\\n            if N in [999, 99999, 9999999]:\\n                return (N + 1) * 10 + 1\\n            n = str(N // 10 ** (len(str(N))//2) + 1)\\n            return int(n + n[-2::-1])\\n        \\n        if N <= 11: \\n            while not isPrime(N):\\n                N += 1\\n            return N\\n        \\n        if (digits := len(str(N))) % 2 == 0:\\n            N = 10 ** digits + 1\\n        else:\\n            n = str(N // 10 ** (len(str(N))//2))\\n            if (p := int(n + n[-2::-1])) >= N:\\n                N = p\\n            else:\\n                N = nextPalindrome(p)\\n                \\n        while not isPrime(N):\\n            N = nextPalindrome(N)\\n        return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 706379,
                "title": "866-prime-palindrome-c-innovative-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n        return 0;\\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 662232,
                "title": "python3-cheating-solution-there-s-only-782-prime-palindromes-less-than-100030002",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        nums =[2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001]\\n        return nums[bisect_left(nums, N)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 464397,
                "title": "ultra-fast-solution-beat-99-no-string-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    char notprime[15000]={0};\\n    vector<int> primes;\\n    // pow10(i) == 10^i\\n    int pow10[9];\\n    \\n    Solution(){\\n        primes.push_back(2);\\n        for (int i=3;i < 15000;i+=2){\\n            if (notprime[i]) continue;\\n            primes.push_back(i);\\n            for (int j=i+i; j < 15000; j+=i)\\n                notprime[j] = 1;\\n        }\\n        \\n        for (int i=0, d=1;i<9;i++, d*=10){\\n            pow10[i]=d;\\n        }\\n    }\\n    \\n    int revdigits(int a, int ndigits){\\n        int b = 0;\\n        while (ndigits--){\\n            b = b*10 + a%10;\\n            a /= 10;\\n        }\\n        return b;\\n    }\\n    \\n    bool isprime(int a){\\n        int limit = ceil(sqrt(a));\\n        for (int i=0 ; i < primes.size() && primes[i] <=limit ;i++)\\n            if (a%primes[i] == 0)\\n                return false;\\n        return true;\\n    }\\n    \\n    inline int numdigits(int a){\\n        return floor(1+ log10(a));\\n    }\\n    \\n    // ndigits: number of digits in \"a\"\\n    inline int makepalin(int a,int ndigits, bool even){\\n         if (even){\\n             return a * pow10[ndigits] + revdigits(a,ndigits);\\n         }\\n         return a * pow10[ndigits-1] + revdigits(a/10,ndigits-1);\\n    }\\n    \\n    int primePalindrome(int N) {\\n        if (N <= 2) return 2;\\n        \\n        for (int nd = numdigits(N); ; nd ++){\\n            int first = pow10[(nd-1)/2];\\n            int last = pow10[(nd-1)/2+1] ;\\n            for (int i= nd==numdigits(N)? N / pow10[nd/2] : first; i < last;i++){\\n                // check whether start with even digit, if so, \\n                // it will also end with even digit, hence skip to the next batch \\n                if ((i/first) % 2 == 0) {\\n                    i += first-1;\\n                    continue;\\n                }\\n                // make palindrome of length \"nd\"\\n                int palin=makepalin(i, (nd+1)/2, nd%2==0);\\n                if (palin >= N && isprime(palin)) return palin;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421006,
                "title": "java",
                "content": "\\tclass Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tN++;\\n\\t\\t\\t\\tif (10_000_000 < N && N < 100_000_000)\\n\\t\\t\\t\\t\\tN = 100_000_000;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic boolean checkPalindrome(int N) {\\n\\t\\t\\tchar[] arr = Integer.toString(N).toCharArray();\\n\\t\\t\\tint len = arr.length;\\n\\t\\t\\tint i;\\n\\t\\t\\tint j;\\n\\t\\t\\tint mid = len / 2;\\n\\t\\t\\tif (len % 2 == 0) {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\ti = mid - 1;\\n\\t\\t\\t\\tj = mid + 1;\\n\\t\\t\\t}\\n\\t\\t\\twhile (i < j && i >= 0) {\\n\\t\\t\\t\\tif (arr[i--] != arr[j++]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\t// public int reverse(int x) {\\n\\t\\t//     int rev= 0;\\n\\t\\t//     while( x > 0){\\n\\t\\t//         rev= rev * 10 + x % 10;\\n\\t\\t//         x= x / 10;\\n\\t\\t//     }\\n\\t\\t//     return rev;\\n\\t\\t// }\\n\\n\\t\\tpublic boolean checkPrime(int N) {\\n\\t\\t\\tboolean flag = true;\\n\\t\\t\\tif (N < 2) return false;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tfor (int i = 2; i <= (int)Math.sqrt(N); i++) {\\n\\t\\t\\t\\t\\tif (N % i == 0) {\\n\\t\\t\\t\\t\\t\\tflag = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn flag;\\n\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int primePalindrome(int N) {\\n\\t\\t\\tif (N == 1) return 2;\\n\\t\\t\\twhile (true) {\\n\\t\\t\\t\\tif (checkPalindrome(N) && checkPrime(N)) {\\n\\t\\t\\t\\t\\treturn N;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 407131,
                "title": "python-faster-than-99-22-and-memory-usage-less-than-100-00",
                "content": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import trunc\\nclass Solution:\\n    def primePalindrome(self, k: int) -> int:\\n\\t\"\"\"\\n\\tFind the closest root from the number and start from there rather than start from the first for all numbers\\n\\t\"\"\"\\n        if k < 12:\\n            for i in range(1, 12):\\n                if self.__is_prime(i) and i >= k:\\n                    return i\\n        else:\\n            string_k = str(k)\\n            string_length = len(string_k)\\n            if string_length % 2 == 0:\\n                starting_root = str(10**(string_length-trunc(string_length/2)))\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(starting_root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n            else:\\n                starting_root = string_k[:string_length-trunc(string_length/2)]\\n                for root in range(int(starting_root), 10**6):\\n                    palindrome_gen = int(str(root) + str(root)[-2::-1])\\n                    if self.__is_prime(palindrome_gen) and palindrome_gen >= k:\\n                        return palindrome_gen\\n\\n\\n    def __is_prime(self, num):\\n        if num == 1:\\n            return False\\n        for i in range(2, int(num**0.5)+1):\\n            if num % i == 0:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395539,
                "title": "o-lgn-solution-joke",
                "content": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    static boolean[] prime;\\n    public int primePalindrome(int n) {\\n       String str = \"2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001,100050001,100060001,100111001,100131001,100161001,100404001,100656001,100707001,100767001,100888001,100999001,101030101,101060101,101141101,101171101,101282101,101292101,101343101,101373101,101414101,101424101,101474101,101595101,101616101,101717101,101777101,101838101,101898101,101919101,101949101,101999101,102040201,102070201,102202201,102232201,102272201,102343201,102383201,102454201,102484201,102515201,102676201,102686201,102707201,102808201,102838201,103000301,103060301,103161301,103212301,103282301,103303301,103323301,103333301,103363301,103464301,103515301,103575301,103696301,103777301,103818301,103828301,103909301,103939301,104000401,104030401,104040401,104111401,104222401,104282401,104333401,104585401,104616401,104787401,104838401,104919401,104949401,105121501,105191501,105202501,105262501,105272501,105313501,105323501,105343501,105575501,105616501,105656501,105757501,105818501,105868501,105929501,106060601,106111601,106131601,106191601,106222601,106272601,106353601,106444601,106464601,106545601,106555601,106717601,106909601,106929601,107000701,107070701,107121701,107232701,107393701,107414701,107424701,107595701,107636701,107646701,107747701,107757701,107828701,107858701,107868701,107888701,107939701,107949701,108070801,108101801,108121801,108151801,108212801,108323801,108373801,108383801,108434801,108464801,108484801,108494801,108505801,108565801,108686801,108707801,108767801,108838801,108919801,108959801,109000901,109101901,109111901,109161901,109333901,109404901,109434901,109444901,109474901,109575901,109656901,109747901,109777901,109797901,109818901,109909901,109929901,110111011,110232011,110252011,110343011,110424011,110505011,110565011,110676011,110747011,110757011,110909011,110949011,110999011,111010111,111020111,111050111,111070111,111181111,111191111,111262111,111272111,111454111,111484111,111515111,111616111,111686111,111757111,111848111,112030211,112060211,112111211,112161211,112171211,112212211,112434211,112494211,112545211,112636211,112878211,112959211,112969211,112989211,113030311,113090311,113111311,113262311,113282311,113474311,113535311,113565311,113616311,113636311,113888311,113939311,114040411,114191411,114232411,114353411,114383411,114484411,114494411,114535411,114727411,114808411,114818411,114848411,114878411,114898411,115000511,115020511,115060511,115111511,115141511,115191511,115212511,115222511,115404511,115464511,115545511,115636511,115737511,115767511,115797511,115828511,115959511,116000611,116010611,116040611,116424611,116505611,116646611,116696611,116757611,116777611,116828611,116868611,116919611,117070711,117101711,117262711,117272711,117323711,117484711,117505711,117515711,117616711,117686711,117757711,117767711,117797711,117818711,117959711,118252811,118272811,118414811,118464811,118525811,118626811,118686811,118696811,118717811,118818811,118848811,118909811,118959811,119010911,119171911,119202911,119343911,119363911,119454911,119585911,119595911,119646911,119676911,119696911,119717911,119787911,119868911,119888911,119969911,120191021,120242021,120434021,120454021,120494021,120535021,120565021,120646021,120808021,120868021,120989021,121080121,121111121,121131121,121161121,121272121,121282121,121393121,121414121,121555121,121747121,121818121,121878121,121939121,121989121,122040221,122232221,122262221,122292221,122333221,122363221,122373221,122393221,122444221,122484221,122535221,122696221,122787221,122858221,122919221,123161321,123292321,123424321,123484321,123494321,123575321,123767321,123838321,123989321,124000421,124080421,124101421,124131421,124252421,124323421,124333421,124434421,124515421,124525421,124626421,124656421,124717421,124737421,124959421,124989421,125000521,125010521,125232521,125252521,125292521,125343521,125474521,125505521,125565521,125606521,125616521,125757521,125838521,125939521,125979521,125999521,126101621,126161621,126181621,126202621,126212621,126323621,126424621,126484621,126535621,126595621,126616621,126676621,126686621,126727621,126737621,126757621,126878621,127060721,127090721,127131721,127212721,127383721,127494721,127545721,127636721,127656721,127686721,127717721,127747721,127828721,127909721,127929721,128070821,128090821,128121821,128181821,128202821,128252821,128262821,128282821,128444821,128474821,128525821,128535821,128595821,128646821,128747821,128787821,128868821,128919821,128939821,129080921,129202921,129292921,129323921,129373921,129484921,129494921,129535921,129737921,129919921,129979921,130020031,130030031,130060031,130141031,130171031,130222031,130333031,130444031,130464031,130545031,130555031,130585031,130606031,130636031,130717031,130767031,130818031,130828031,130858031,130969031,131030131,131111131,131121131,131222131,131252131,131333131,131555131,131565131,131585131,131646131,131676131,131828131,132010231,132191231,132464231,132535231,132595231,132646231,132676231,132757231,133020331,133060331,133111331,133161331,133252331,133474331,133494331,133575331,133686331,133767331,133818331,133909331,134090431,134181431,134232431,134424431,134505431,134525431,134535431,134616431,134757431,134808431,134858431,134888431,134909431,134919431,134979431,135010531,135040531,135101531,135121531,135161531,135262531,135434531,135494531,135515531,135626531,135646531,135707531,135838531,135868531,135878531,135929531,135959531,135979531,136090631,136171631,136222631,136252631,136303631,136363631,136474631,136545631,136737631,136797631,136818631,136909631,136969631,137030731,137040731,137060731,137090731,137151731,137171731,137232731,137282731,137333731,137363731,137424731,137474731,137606731,137636731,137696731,137757731,137808731,137838731,137939731,137999731,138040831,138131831,138242831,138292831,138313831,138383831,138454831,138575831,138616831,138646831,138757831,138898831,138959831,138989831,139131931,139161931,139222931,139252931,139282931,139383931,139474931,139515931,139606931,139626931,139717931,139848931,139959931,139969931,139999931,140000041,140030041,140151041,140303041,140505041,140565041,140606041,140777041,140787041,140828041,140868041,140898041,141020141,141070141,141131141,141151141,141242141,141262141,141313141,141343141,141383141,141484141,141494141,141575141,141595141,141616141,141767141,141787141,141848141,142000241,142030241,142080241,142252241,142272241,142353241,142363241,142464241,142545241,142555241,142686241,142707241,142797241,142858241,142888241,143090341,143181341,143262341,143303341,143454341,143474341,143585341,143636341,143787341,143828341,143919341,143969341,144010441,144020441,144202441,144212441,144313441,144353441,144404441,144434441,144484441,144505441,144707441,144757441,144808441,144818441,144848441,144878441,144898441,144979441,144989441,145020541,145030541,145090541,145353541,145363541,145393541,145464541,145494541,145575541,145666541,145767541,146030641,146040641,146181641,146222641,146252641,146313641,146363641,146505641,146555641,146565641,146676641,146858641,146909641,147191741,147232741,147242741,147313741,147343741,147373741,147434741,147515741,147565741,147616741,147686741,147707741,147757741,147838741,147929741,148020841,148060841,148080841,148414841,148444841,148525841,148545841,148585841,148666841,148686841,148707841,148818841,148858841,148888841,148969841,149000941,149333941,149343941,149484941,149535941,149555941,149616941,149646941,149696941,149858941,149888941,149909941,149919941,149939941,150070051,150151051,150181051,150202051,150272051,150434051,150494051,150505051,150626051,150686051,150727051,150808051,150818051,150979051,151080151,151161151,151212151,151222151,151282151,151353151,151545151,151585151,151656151,151737151,151777151,151858151,151878151,151888151,151959151,151969151,151999151,152090251,152111251,152171251,152181251,152252251,152363251,152393251,152454251,152505251,152565251,152616251,152646251,152666251,152696251,152888251,152939251,153212351,153272351,153292351,153313351,153323351,153404351,153424351,153454351,153484351,153494351,153626351,153808351,153818351,153838351,153979351,154030451,154191451,154252451,154272451,154303451,154323451,154383451,154393451,154474451,154494451,154555451,154575451,154989451,155060551,155141551,155171551,155292551,155313551,155333551,155373551,155424551,155474551,155535551,155646551,155666551,155676551,155808551,155828551,155868551,156151651,156262651,156343651,156424651,156434651,156494651,156545651,156595651,156656651,156707651,156727651,156757651,156848651,156878651,156949651,157090751,157101751,157161751,157252751,157393751,157444751,157555751,157717751,157878751,157888751,157939751,157959751,157989751,158090851,158111851,158222851,158252851,158363851,158474851,158595851,158676851,158696851,158747851,158808851,158858851,158898851,158909851,159020951,159040951,159050951,159121951,159181951,159191951,159202951,159232951,159262951,159292951,159323951,159404951,159464951,159565951,159595951,159646951,159757951,159808951,159919951,159929951,159959951,160020061,160050061,160080061,160101061,160131061,160141061,160161061,160171061,160393061,160545061,160696061,160707061,160717061,160797061,160878061,161171161,161282161,161313161,161363161,161474161,161484161,161535161,161585161,161636161,161787161,161838161,161969161,162040261,162232261,162404261,162464261,162484261,162565261,162686261,162707261,162757261,162898261,162919261,162949261,162959261,162979261,162989261,163101361,163333361,163434361,163464361,163474361,163494361,163515361,163555361,163606361,163686361,163696361,163878361,163959361,164000461,164070461,164151461,164292461,164333461,164454461,164484461,164585461,164616461,164696461,164717461,164727461,164838461,165101561,165161561,165191561,165212561,165343561,165515561,165535561,165808561,165878561,165898561,165919561,165949561,166000661,166080661,166171661,166191661,166404661,166545661,166555661,166636661,166686661,166818661,166828661,166878661,166888661,166929661,167000761,167111761,167262761,167393761,167454761,167474761,167484761,167636761,167646761,167787761,167888761,167898761,167979761,168151861,168191861,168232861,168404861,168505861,168515861,168565861,168818861,168898861,168929861,168949861,169060961,169131961,169141961,169282961,169333961,169383961,169464961,169555961,169606961,169656961,169666961,169686961,169777961,169797961,169858961,169999961,170040071,170060071,170232071,170303071,170333071,170414071,170424071,170484071,170606071,170616071,170646071,170828071,170838071,170909071,170979071,171080171,171262171,171292171,171343171,171565171,171575171,171767171,171919171,171959171,172060271,172090271,172161271,172353271,172363271,172393271,172474271,172585271,172656271,172747271,172767271,172797271,172878271,172909271,172959271,173000371,173030371,173090371,173252371,173373371,173454371,173525371,173585371,173696371,173757371,173777371,173828371,173868371,173888371,173898371,173919371,174080471,174121471,174131471,174181471,174313471,174343471,174595471,174646471,174676471,174919471,174949471,174979471,174989471,175000571,175090571,175101571,175111571,175353571,175444571,175555571,175626571,175747571,175777571,175848571,175909571,176090671,176111671,176141671,176181671,176232671,176313671,176333671,176373671,176393671,176414671,176585671,176636671,176646671,176666671,176696671,176757671,176787671,176888671,176898671,176939671,177121771,177161771,177202771,177242771,177323771,177565771,177616771,177707771,177757771,177868771,178101871,178131871,178141871,178161871,178353871,178414871,178515871,178525871,178656871,178717871,178747871,178878871,178969871,178989871,178999871,179010971,179060971,179222971,179232971,179262971,179414971,179454971,179484971,179717971,179777971,179808971,179858971,179868971,179909971,179969971,179999971,180070081,180101081,180161081,180292081,180515081,180535081,180545081,180565081,180616081,180757081,180959081,181111181,181515181,181545181,181666181,181737181,181797181,181888181,182010281,182202281,182373281,182585281,182616281,182636281,182777281,182858281,182949281,183232381,183626381,183656381,183737381,183898381,183979381,183989381,184030481,184212481,184222481,184303481,184393481,184414481,184545481,184585481,184606481,184636481,184747481,184818481,184878481,185232581,185373581,185393581,185525581,185555581,185595581,185676581,185757581,185838581,185858581,185868581,185999581,186010681,186040681,186050681,186070681,186101681,186131681,186151681,186161681,186424681,186484681,186505681,186565681,186656681,186676681,186787681,186898681,187090781,187101781,187111781,187161781,187272781,187404781,187434781,187444781,187525781,187767781,187909781,187939781,187999781,188010881,188060881,188141881,188151881,188303881,188373881,188414881,188454881,188505881,188525881,188535881,188616881,188636881,188646881,188727881,188777881,188868881,188888881,188898881,188979881,189080981,189131981,189262981,189292981,189464981,189535981,189595981,189727981,189787981,189838981,189898981,189929981,190000091,190020091,190080091,190101091,190252091,190404091,190434091,190464091,190494091,190656091,190696091,190717091,190747091,190777091,190858091,190909091,191090191,191171191,191232191,191292191,191313191,191565191,191595191,191727191,191757191,191838191,191868191,191939191,191969191,192101291,192191291,192202291,192242291,192313291,192404291,192454291,192484291,192767291,192797291,192898291,193000391,193030391,193191391,193212391,193282391,193303391,193383391,193414391,193464391,193555391,193686391,193858391,193888391,194000491,194070491,194121491,194222491,194232491,194292491,194303491,194393491,194505491,194595491,194606491,194787491,194939491,194999491,195010591,195040591,195070591,195151591,195202591,195242591,195353591,195505591,195545591,195707591,195767591,195868591,195878591,195949591,195979591,196000691,196090691,196323691,196333691,196363691,196696691,196797691,196828691,196878691,197030791,197060791,197070791,197090791,197111791,197121791,197202791,197292791,197343791,197454791,197525791,197606791,197616791,197868791,197898791,197919791,198040891,198070891,198080891,198131891,198292891,198343891,198353891,198383891,198454891,198565891,198656891,198707891,198787891,198878891,198919891,199030991,199080991,199141991,199171991,199212991,199242991,199323991,199353991,199363991,199393991,199494991,199515991,199545991,199656991,199767991,199909991,199999991\";\\n\\t\\tString[] tr = str.split(\",\");\\n        int[] a = new int[tr.length];\\n        for(int i=0;i<a.length;i++) a[i] = Integer.parseInt(tr[i]);\\n        \\n        //find the first\\n        int lo=0;\\n        int hi = a.length;\\n        while(lo < hi){\\n            int mid = lo+hi>>1;\\n            if(a[mid] < n){\\n                lo=mid+1;\\n            }else{\\n                hi=mid;\\n            }\\n        }\\n        return a[lo];\\n        \\n    }\\n    \\n    private boolean isPrime(int n){\\n        if( n <= 1) return false;\\n        for(int i=2;i*i<=n;i++){\\n            if(n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243195,
                "title": "20ms-c-solution",
                "content": "1. find the first palindrome number by N++;\\n2. return if prime, or generate the next palindrome\\n\\nhere is the way to generate number:\\n1. start from the inner position, like number `3` in `123321` and `12321`;\\n2. if the number<9, add it, like `123321` -> `124421` or `12321` -> `12421`;\\n3. find < 9 number, like `2` in  `12999921`and add it, remember calculate the step careful\\n4. if all is 9, like `9999`, just add `2` and get `10001`\\n\\nthe following is my code\\n```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int x) {\\n        int reverse = 0, src = x;\\n        while (x) {\\n            reverse = reverse * 10 + x % 10;\\n            x /= 10;\\n        }\\n        return reverse == src;\\n    }\\n    \\n    int nextPal(int x) {\\n        int n = 0, m, tmp;\\n        while(pow(10, n) <= x) n ++;\\n        for (m = (n - 1) / 2; m >= 0; m --) {\\n            tmp = x / (int)pow(10, m) % 10;\\n            if (tmp < 9) {\\n                if (n % 2 && m == (n-1)/2) return x + pow(10, m);\\n                return x + pow(10, m+1) + pow(10, m);\\n            }\\n        }\\n        return x + 2;\\n    }\\n    \\n    bool isPrime(int x) {\\n        if (x < 2) return false;\\n        int s = sqrt(x);\\n        for (int i = 2; i <= s; i ++) {\\n            if (x % i == 0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int N) {\\n        while (!isPal(N)) N ++;\\n        while(!isPrime(N)) N = nextPal(N);\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208246,
                "title": "c-20-line",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }        \\n    }\\n    \\n    int palinize(int x){\\n        auto s = to_string(x), t = s;\\n        reverse(t.begin(), t.end());\\n        s.pop_back();\\n        return stoi(s+t);\\n    }\\n    \\n    bool isPrime(int x){\\n        if(x%2==0) return false;\\n        int sq = int(sqrt(x)) + 1;\\n        for(int i = 3; i<=sq; i+= 2)\\n            if(x % i == 0) return false;\\n        return true;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <= 2) return 2;\\n        if(N>7 && N<=11) return 11;\\n        for(int i = 1; i < 999999; i++){\\n            auto palin = palinize(i);\\n            if(palin >= N && isPrime(palin)) return palin;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 146770,
                "title": "java-clear-solution-46ms",
                "content": "find the next Palindrome and check whether it\\'s Prime or not\\n\\nI find the next Palindrome code in https://stackoverflow.com/questions/7934519/a-better-algorithm-to-find-the-next-palindrome-of-a-number-string\\n\\n```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.math.BigInteger;\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(N==1){\\n            return 2;\\n        }\\n        \\n        while(!isPalin(N)){\\n            N++;\\n        }\\n        \\n        if(isPrime(N)){\\n            return N;\\n        }\\n        \\n        while(true){\\n            N = Integer.parseInt(nextPalindrome(Integer.toString(N)));\\n            if(isPrime(N)){\\n                return N;\\n            }\\n        }\\n\\n    }\\n    \\n    public String nextPalindrome(String num) {\\n        int len = num.length();\\n        String left = num.substring(0, len / 2);\\n        String middle = num.substring(len / 2, len - len / 2);\\n        String right = num.substring(len - len / 2);\\n\\n        if (right.compareTo(reverse(left)) < 0)\\n            return left + middle + reverse(left);\\n\\n        String next = new BigInteger(left + middle).add(BigInteger.ONE).toString();\\n        return next.substring(0, left.length() + middle.length())\\n             + reverse(next).substring(middle.length());\\n    }\\n\\n    private String reverse(String s) {\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n    \\n    private boolean isPalin(int num){\\n        if(num<10) return true;\\n        String str = Integer.toString(num);\\n        int i = 0;\\n        int j = str.length()-1;\\n        while(i<j){\\n            if(str.charAt(i)!=str.charAt(j)){\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isPrime(int num){\\n        if(num==1) return false;\\n        if(num==2 || num==3 || num==5 || num==7) return true;\\n        for(int i = 2;i<(int)Math.sqrt(num)+1;i++){\\n            if(num%i==0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4104344,
                "title": "c-fast-no-table-lookup-reduce-search-space",
                "content": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  inline int generatePalindrome(int x) const {\\n    string str = to_string(x);\\n    string revStr = string(str.rbegin(), str.rend());\\n    return stoi(str + revStr.substr(1));\\n  }\\n  \\n  inline bool isPrime(int x) const {\\n    if (x < 2) return false;\\n    for (int i = 2; i*i <= x; i++)\\n      if (x % i == 0) \\n        return false;\\n    return true;\\n  } \\n  \\n  inline int ndigits(int x) const {\\n    int digits = 1;\\n    while (x /= 10)\\n      digits++;\\n    return digits;\\n  }\\n  \\n  inline int powi(int x, int k) const {\\n    if (k == 0) return 1;\\n    if (k == 1)\\n      return x;\\n    int res = powi(x, k / 2);\\n    res *= res;\\n    if (k & 1)\\n      res *= x;\\n    return res;\\n  }\\npublic:    \\n    int primePalindrome(int n) {\\n\\t // only palindrome with even length that is prime is 11\\n      if (n >= 8 && n <= 11) \\n        return 11;\\n      \\n      // Find a good starting point so we aren\\'t checking palindromes that are obviously too small\\n      int digits = ndigits(n), start;\\n      if (digits & 1) {\\n        start = n / powi(10, digits / 2);\\n      } else {\\n        // For example: n = 3044 -> the first possible palindrome that has 5 digits to check is 10001\\n        start = powi(10, digits / 2);\\n      }\\n\\n      for (int i = start; i < 1e5; ++i) {\\n        int palindrome = generatePalindrome(i);\\n        if (palindrome >= n && isPrime(palindrome)) \\n          return palindrome;\\n      }\\n\\n      return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050066,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```java []\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```python3 []\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981167,
                "title": "python-solution",
                "content": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```\\n\\t\\t1.check only palindrome integers\\n\\t\\t2.time complexity is O(nXsqrt(n))\\n\\t\\t3.since constriant of n is 10^8 .return 100030001 if n>=9989900",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def primePalindrome(self, n: int) -> int:\\n        if n >= 9989900:\\n            return 100030001\\n        import math\\n        def p(n):\\n            if(n<=1):\\n                return False\\n            if(n<=3):\\n                return True\\n            if(n%2==0):\\n                return False\\n            if(n%3==0):\\n                return False\\n            sq=int(math.sqrt(n))\\n            for i in range(5,sq+1,2):\\n                if(n%i==0):\\n                    return False\\n            return True\\n        i=n\\n        while 1:\\n            if(str(i)==str(i)[::-1] and p(i)):\\n                return i\\n            i+=1\\n        ```",
                "codeTag": "Python3"
            },
            {
                "id": 3969487,
                "title": "golang-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Whatever lee215 said. Truly the legend of this website.](https://leetcode.com/problems/prime-palindrome/solutions/146798/java-c-python-all-even-length-palindrome-are-divisible-by-11/)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\n\\tfor x := 3; x*x <= n; x += 2 {\\n\\t\\tif n%x == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\n\\treturn true\\n}\\n\\n\\nfunc reverseString(s string) string {\\n\\tr := []rune(s)\\n\\tfor i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {\\n\\t\\tr[i], r[j] = r[j], r[i]\\n\\t}\\n\\treturn string(r)\\n}\\n\\nfunc primePalindrome(n int) int {\\n\\tif 8 <= n && n <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor x := 1; x < 100000; x++ {\\n\\t\\ts := strconv.Itoa(x)\\n\\t\\tr := reverseString(s)\\n\\t\\ty, _ := strconv.Atoi(s + r[1:])\\n\\t\\tif y >= n && isPrime(y) {\\n\\t\\t\\treturn y\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3942893,
                "title": "python-100-light",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import sqrt\\nclass Solution:\\n    def isPrime(self, num):\\n        if num < 2 or num % 2 == 0:\\n            return num == 2\\n        for i in range(3, int(sqrt(num)) + 1, 2):\\n            if num % i == 0:\\n                return False\\n        return True\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11:\\n            return 11\\n        if len(str(n)) % 2 == 0:\\n            l = pow(10, len(str(n))//2)\\n        else:\\n            n_string = str(n)\\n            l = n_string[:len(str(n)) // 2 + 1]\\n        for i in range(int(l), 20000):\\n            tr = int(str(i)+ str(i)[:-1][::-1])\\n            if tr >= n and self.isPrime(tr):\\n                return tr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928627,
                "title": "c-solution-using-basic-loops",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        for (long long i = 2; i * i <= n; i++) {\\n            if (n % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    bool isPali(int n) {\\n        string s = to_string(n);\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s[i] != s[j]) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    int primePalindrome(int n) {\\n             if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n        for (long long i = n; i < 1e8; i++) {\\n            if (isPrime(i)) {\\n                if (isPali(i)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914488,
                "title": "by-prodonik-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def isPrime(num: int) -> bool:\\n            if num < 2:\\n                return False\\n            for i in range(2, int(num ** 0.5) + 1):\\n                if num % i == 0:\\n                    return False\\n            return True\\n        def reversion(num: int) -> bool:\\n            return str(num)[::-1] == str(num)\\n        if n <= 2:\\n            return 2\\n        while True:\\n            if reversion(n) and isPrime(n):\\n                return n\\n            n += 1\\n            if 10**7 < n < 10**8:\\n                n = 10**8\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888084,
                "title": "fastest-python-solution-using-a-bit-of-number-theory",
                "content": "# Intuition\\nThe difficulty with this problem was essentially to find a number that was both palindrome and prime. At this point I decided to divide the problem into 3 functions: one to form the palindrome number closest to n, one to create palindrome numbers that are bigger and closer to other palindromic numbers that have odd digits (to find out why I\\'ll write it later) and one to verify that they were prime numbers.\\n\\n# Approach\\nFirst I created a function which, taking n, returned a palindromic number that was the palindromic number immediately before n or immediately after. To do it was simple: I took the first half of the digits of n and flipped them to create a number. (it is not difficult to prove that this number is the largest but smallest palindrome with to n or the smallest but largest respect to n). This function is the def generate_special_palindrome(self, number). Then I created a function that took a plaindrome number and creates the one immediately following. If it was an even number however, it creates the smallest odd-digits palindrome bigger than the palindrome gave as input to the function. It does this because we know that every palindrome with even digits is divisible by 11 (see the divisibility test by 11 https://en.wikipedia.org/wiki/11_(number)#Divisibility_tests). To create the next palindrome with odd digits it takes the middle digit and it increases it by 1. if the middle digit becames 10 though, it just increas by 1 the mirror part and the middle digit becames 0. To see if our number is prime we can use a clever trick: for the people who studied a bit of number theory, we know that all the primes number (except 2 and 3), are 1 or 5 (modulo 6), (it\\'s just a fancy way to say that the residue of p/6 is either 1 or 5). So we can just verify that the number is 2 or 3, or not divisible by 2 or 3, and then we can just verify that all the numbers that are 1 or 5 (modulo 6) and that are less or equal to the sqrt(n) of the number, do not divide the number, and we know for sure that the number is prime. \\n# Complexity\\n- Time complexity:\\nUnfortunally, since we are working with primes, we can\\'t know for sure it\\'s time complexity, but we can set a lower bound!: Time complexity >= O(2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPrime(self, num):\\n        if num <= 1:\\n            return False\\n        if num <= 3:\\n            return True\\n\\n        if num % 2 == 0 or num % 3 == 0:\\n            return False\\n\\n        i = 5\\n        while i*i <= num:\\n            if num % i == 0 or num % (i + 2) == 0:\\n                return False\\n            i += 6\\n        \\n        return True\\n\\n    def generate_special_palindrome(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"-1\"\\n        else:\\n            middle_digit = num_str[leng // 2]\\n    \\n        first_half = num_str[:leng // 2]\\n        if middle_digit != \"-1\":\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        else:\\n            palindrome = int(first_half +\\n            first_half[::-1])\\n    \\n        return palindrome\\n\\n    def nextPal(self, number):\\n        num_str = str(number)\\n        leng = len(num_str)\\n        if leng % 2 == 0:\\n            middle_digit = \"0\"\\n            first_half = \"1\" + \"0\" * (leng/2 - 1)\\n        else:\\n            middle_digit = str(int(num_str[leng // 2]) + 1)\\n            first_half = num_str[:leng // 2]\\n\\n        if middle_digit == \"10\":\\n            middle_digit = \"0\"\\n            first_half = str(int(first_half) + 1)\\n            palindrome = int(first_half + middle_digit +\\n            first_half[::-1])\\n        \\n        palindrome = int(first_half + middle_digit +\\n        first_half[::-1])\\n\\n        return palindrome\\n\\n    def primePalindrome(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        z = self.generate_special_palindrome(n)\\n        if len(str(z)) == 1 or z == 10:\\n            while self.isPrime(z) == False:\\n                z += 1\\n            return z\\n        if z < n:\\n            z = self.nextPal(z)\\n        \\n        while self.isPrime(z) == False:\\n            z = self.nextPal(z)\\n        \\n        return z\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869484,
                "title": "next-largest-prime-palindrome-c-did-not-see-another-solution-so-posting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the next palindrome and check if its prime.\\n\\niterate from both sides, if end < start then make end and start index values same since that is a larger number.\\n\\nIf end > start then make them same but pass a carry of 1 left of end index, process carry and check again if its a palindrome. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFind next palindrome and check if its prime. Mostly we need to do some manipulation to find the next smallest palindrome\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nFind palindrome O(Length(num) * 9) = O(Length(num))\\n\\nCheck Palindrome O(Length(num))\\n\\nIsPrime(O(sqrt(num)))\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nO(Length(n))\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        int numAttempts = 1000000;\\n        int curr = IsPalindrome(n) ? n : NextPalindrome(n);\\n        while(numAttempts > 0){\\n            if(IsPrime(curr)){\\n                return curr;\\n            }\\n\\n            //Console.WriteLine(\"next palindrome \" + curr);\\n            curr = NextPalindrome(curr);\\n            numAttempts--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static bool IsPrime(int n ){\\n        int divisor = Convert.ToInt32(Math.Floor(Math.Sqrt((double)n)));\\n        for(int i = 2; i <= divisor; i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    private static int NextPalindrome(int n){\\n        int nextNum = n + 1;\\n        string str = nextNum.ToString();\\n        char[] cArray = str.ToCharArray();\\n\\n        int pendingIndex = ConvertToPalindrome(cArray);\\n        int numAttempts = 1000;\\n        while(pendingIndex != -1 && numAttempts > 0){\\n            //Console.WriteLine($\"Failed : {new string(cArray)} at {pendingIndex}\");\\n            ProcessCarry(ref cArray, pendingIndex);\\n           // Console.WriteLine($\"checking : {new string(cArray)}\");\\n            pendingIndex = ConvertToPalindrome(cArray);\\n            numAttempts--;\\n             //Console.WriteLine($\"pending index : {new string(cArray)} is {pendingIndex}\");\\n        }\\n\\n        return int.Parse(new string(cArray));\\n    }\\n\\n    private static void ProcessCarry(ref char[] cArray, int index){\\n        while(index >= 0){\\n            int newVal = IntVal(cArray[index]) + 1;\\n            if(newVal < 10){\\n                cArray[index] = CharVal(newVal);\\n                return;\\n            }\\n\\n            newVal -= 10;\\n            cArray[index] = CharVal(newVal);\\n            index--;\\n        }\\n\\n        char[] newCArray = new char[cArray.Length + 1];\\n        newCArray[0] = \\'1\\';\\n        for(int i = 0; i < cArray.Length; i++){\\n            newCArray[i + 1] = cArray[i];\\n        }\\n\\n        cArray = newCArray;\\n    }\\n\\n    private static int ConvertToPalindrome(char[]  cArray){\\n        int start = 0;\\n        int end = cArray.Length - 1;\\n        while(start < end){\\n            \\n            if(cArray[start] == cArray[end]){\\n                start++;\\n                end--;\\n                continue;\\n            }\\n\\n            if((int)cArray[start] >= (int)cArray[end]){\\n                cArray[end] = cArray[start];\\n            }else {\\n                cArray[end] = cArray[start];\\n                return end - 1;\\n            }\\n\\n            start++;\\n            end--;\\n        }\\n\\n        return -1;\\n    }\\n\\n    private static char CharVal(int v){\\n        return (char)(v + 48);\\n    }\\n    private static int IntVal(char c){\\n        return (int)c - 48;\\n    }\\n    private static bool IsPalindrome(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n\\n        string s = n.ToString();\\n        string reverse = new string(s.ToCharArray().Reverse().ToArray());\\n        return s.Equals(reverse);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3832207,
                "title": "ruby-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nrequire \\'prime\\'\\n\\n# A palprime has only odd number of digits \\n# (otherwise it is divisible by 11)\\n@pals = [*\"0\"..\"9\"]\\n\\n4.times do # 1, 3, 5, 7, 9 digits\\n  nxt = @pals.dup\\n  (0..9).each do |digit|\\n    @pals.each do |pal|\\n      nxt << digit.to_s + pal + digit.to_s\\n    end\\n  end\\n  \\n  @pals = nxt\\nend\\n\\n@pals.insert(10, \"11\")\\n@pals = @pals.map(&:to_i).select(&:prime?)\\n\\ndef prime_palindrome(n)\\n  # Optimization 1\\n  n = 1e8 if 1e7 < n && n < 1e8\\n\\n  @pals.find do |pal|\\n    pal >= n\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3809835,
                "title": "typecript-easy-solution",
                "content": "# Code\\n```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction isPrime(n: number): boolean {\\n    for(let i = 2, s = Math.sqrt(n); i <= s; i++) {\\n        if(n % i === 0) return false;\\n    }\\n    return n > 1;\\n}\\n\\nfunction isPal(s: string): boolean {\\n    let l: number = 0\\n    let r: number = s.length - 1\\n    while (l < r) {\\n        if (s[l] !== s[r]) return false\\n        l++;\\n        r--;\\n    }\\n    return true\\n}\\n\\nfunction primePalindrome(n: number): number {\\n    if (99899*1e2 <= n && n <= 1e8)\\n        return 100030001;\\n\\n    for(let i:number = n;i<1e8;i++) {\\n        if (isPrime(i) && isPal(i.toString())) {\\n            return i\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3794047,
                "title": "easy-and-acceptable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    bool prime(int n)\\n    {\\n        if(n<=2)\\n            return true;\\n        for(int i=2; i<=sqrt(n); i++)\\n            if(n%i==0)\\n                return false;\\n        return true;\\n    }\\n    bool palindrome(int n)\\n    {\\n        \\n        int x=n;\\n        int num=0;\\n        while(n)\\n        {\\n            int rem=n%10;\\n            num=num*10+rem;\\n            n/=10;\\n        }\\n        if(x==num)\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(99899*1e2 <=n && n<=1e8)\\n            return 100030001;\\n        if(n==1)\\n            return 2;\\n        if(n==0)\\n            return 1;\\n        while(n<1e8)\\n        {\\n            if(prime(n) && palindrome(n))\\n                return n;\\n            n++;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3709363,
                "title": "my-c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPrime(int n){\\n    if(n<2){\\n        return false;\\n    }\\n    for(int i=2;i*i<=n;i++){\\n        if(n%i==0){\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\n    int primePalindrome(int n) {\\n        int ans=0,rev=0;\\n        // if (1e7 <= n && n <= 1e8)\\n        // return 100030001;\\n        for(int i=n;i<10000000;i++){\\nif(isPrime(i)){\\n    ans=i;\\nint k=i;\\nwhile(k!=0){\\n    int rem=k%10;\\n    rev=rev*10+rem;\\n    k/=10;\\n}\\nif(rev==ans){\\n    return ans;\\n}\\nelse{\\n    rev=0;\\n}\\n        }\\n       }\\n        \\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3696111,
                "title": "highly-efficient-concise-solution",
                "content": "# Intuition\\nThe brute-force method is just to check every integer after n. However, very few of these integers are palindromes. If we only check the palindromes, it will be much more efficient.\\n\\n# Approach\\nFor n<=100, we check from a very short list of prime palindromes. Otherwise, we generate palindromes for the bigger n values, and check if they are prime.\\n\\nAn important optimization is that we only need to check palindromes with an odd number of digits. Any palindrome with an even number of digits is a multiple of 11, per divisibility rules. They would all not be prime (except 11).\\n\\n# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            for f in range(2, int(n**0.5)+1):\\n                if n % f == 0:\\n                    return False\\n            return True\\n        \\n        if n <= 100:\\n            return min(i for i in [2, 3, 5, 7, 11, 101] if i >= n)\\n        \\n        for half_l in range(len(str(n))//2-1, 5):\\n            for h in range(10**half_l, 10**(half_l+1)):\\n                half = str(h)\\n                test_n = int(half + half[-2::-1])  # Construct palindrome\\n                if test_n >= n and is_prime(test_n):\\n                    return test_n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694954,
                "title": "java",
                "content": "based on lee\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n<=11) {\\n            if (n<=2) return 2;\\n            if (n<=3) return 3;\\n            if (n<=5) return 5;\\n            if (n<=7) return 7;\\n            return 11;\\n        }\\n\\n        String s = \"\" + n; \\n        int guess = 1;\\n        while (true){\\n            for (char mid = \\'0\\' ; mid<=\\'9\\'; mid++){\\n                StringBuilder pal = (new StringBuilder(\"\" + guess)).append(mid).append((new StringBuilder(\"\" + guess)).reverse().toString());\\n                int cur = Integer.parseInt(pal.toString());\\n                if (cur >= n && isPrime(cur)) return cur;   \\n            }\\n            guess++;\\n        }\\n    }\\n\\n    private boolean isPrime(int n){\\n        for (int i=2; i<=Math.sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685475,
                "title": "beginners-friendly-code-java",
                "content": "# Code\\n```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int primePalindrome(int p) {\\n        if(p<=9981899){\\n            while(true){            \\n            if(isPrime(p)==1 && palindrome(p)==1){\\n            return p;\\n        }\\n        p++;\\n    }\\n        }else{\\n            return 100030001;\\n        }\\n        \\n}\\n    static int palindrome(int p){\\n        String s =String.valueOf(p);\\n        String n = \"\";\\n        for (int i = 0; i < s.length(); i++) {\\n            n= s.charAt(i)+n;\\n            int rev =Integer.parseInt(n);\\n            if(p==rev){\\n                return 1;\\n            }\\n\\n        }\\n        return 0;\\n    }\\n    static int isPrime(int n) {  \\n        if (n <= 1) {  \\n            return 0;  \\n        }  \\n        for (int i = 2; i*i <= n; i++) {  \\n            if (n % i == 0) {  \\n                return 0;  \\n            }\\n            \\n        }\\n        return 1;  \\n        \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614274,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==1){\\n            return 2;\\n        }\\n    int i = n - 1;\\n    while (true) {\\n        i++;\\n        int temp = i;\\n        int rev = 0;\\n        while (temp > 0) {\\n            rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n        }\\n        if (rev == i) {\\n            int k = 2;\\n            int x = sqrt(i);\\n            while (k <= x) {\\n                if (i % k == 0) {\\n                    break;\\n                }\\n                k++;\\n            }\\n            if (k > x) {\\n                return i;\\n            }\\n        }\\n    }\\n    return -1;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607188,
                "title": "2ms-96-39-5mb-73-iterate-only-palindrome-very-detailed-explanation",
                "content": "# Intuition\\nJust need to iterate only palindrome, so \\n1st step: find the bigger nearest palindrome\\n2nd step: generate next palindrome\\n3rd step: check is this palindrome is prime, else repeat from 2nd step\\n\\n# Implementation\\n- just hardcode for n <= 100\\n- Skip all even length palindrome, because its proved to be dividable by 11.\\n\\n\\n**1st Step:**\\n- Split n into left & right side, **example 435679328 (odd length of 9)**, split to **43567(left)** & **9328(right)**\\n- find the bigger nearest palindrome :\\n    **ignore the middle digit, which is 7**, and compare both side, for left side start from behind, for right side start from front:\\n\\ncompare 6 vs 9, if right side(9) is bigger, then increase the middle digit by 1 \\nand the **nearest parlindrom will be**\\nleftSide+1 concatenate reverse of leftSide.substring(0, leftSide.length-1) = \\n(43567+1) concatenate reverse of 4356 =\\n43568 concatenate 6534 = **435686534**\\n\\n**another example 754312609** , ignore the middle digit (1)\\ncompare 3 vs 2, if left side(3) is bigger, \\nthen **the nearest parlindrom will be**\\n75431 + reverse of 7543 = **754313457**\\n\\n**another example 961303782**, ignore the middle digit (0)\\nif both side are equal, compare the next digit\\ncompare 1(left) vs 7(right), if rightSide bigger, increase middle digit and you get the nearest parlindrom, else if leftSide is bigger, just concat leftSide & reverse of leftSide, if they are same again, compare next next digit, and so on... \\n**if all digits are same, then itself is palindrome.**\\n\\n\\n**2nd Step:**\\nOk, now we can start from the nearest palindrome we\\'ve found in step 1.\\nRemember we split number into leftSide and rightSide? But now we only need to increment leftSide by 1 , then it is the next nearest palindrome!! so discard rightSide, its useless now.\\n\\n**Using first example 435686534**, leftSide = 43568, \\nwhile true iteration :\\n\\ncheck if 435686534 is prime? \\nyes -> return;\\nno -> \\n    1. leftSide += 1 (43568 + 1 = 43569)\\n    2. form a new palindrome ( 435696534 )\\n\\nend while\\n\\n***Thats it!!***\\n\\n**Note**: Example n = 990, \\nleftSide = 99, palindrome = 99 concat 9, = 999\\nand when leftSide + 1 (=100)\\nsince we concat leftSide + reverse of leftSide.substring(0, leftSide.length-1), \\n= 100 concat 01 = 10001\\nthat means we are always concatenating evenLength + oddLength OR oddLength + evenLength, so it is always equal to oddLength (skipping evenLength palindrome.)\\n\\n# Complexity\\n- Time complexity:\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if(n <= 2) return 2;\\n        if(n <= 3) return 3;\\n        if(n <= 5) return 5;\\n        if(n <= 7) return 7;\\n        if(n <= 11) return 11;\\n        if(n <= 100) return 101;\\n\\n        int len = getNumLength(n);\\n        if(len % 2 == 0) \\n            n = (int)Math.pow(10, len++);   //  len increase 1 after this line\\n\\n        int startLeftPart, palindrome = 0;\\n        String vLeftPart;     //  reverse of startLeftPart, so it becomes rightPart\\n        startLeftPart = findFirstPalindrome(n, len);\\n        \\n        while(true){\\n            String tempLeft = String.valueOf(startLeftPart);\\n            vLeftPart = strReverse(tempLeft.substring(0, tempLeft.length()-1));\\n            palindrome = Integer.parseInt(tempLeft + vLeftPart);\\n            if( isPrime(palindrome) ) return palindrome;\\n            \\n            startLeftPart++;\\n        }\\n    }\\n\\n    int findFirstPalindrome(int n, int len){\\n        String leftPart = String.valueOf(n).substring( 0, ((len+1)/2) );\\n        String rightPart = String.valueOf(n).substring( ((len+1)/2), len);\\n\\n        for(int i=0; i<rightPart.length(); ++i)\\n            if(leftPart.charAt(leftPart.length()-2-i) > rightPart.charAt(i))\\n                break;\\n\\n            else if(leftPart.charAt(leftPart.length()-2-i) < rightPart.charAt(i)){\\n                leftPart = String.valueOf(Integer.parseInt(leftPart) + 1);\\n                break;\\n            }\\n\\n        return Integer.parseInt(leftPart);\\n    }\\n\\n    int getNumLength(int x){\\n        int length = 0;\\n        long temp = 1;\\n        while (temp <= x) {\\n            length++;\\n            temp *= 10;\\n        }\\n        return length;\\n    }\\n\\n    String strReverse(String s){\\n        return new StringBuilder(s).reverse().toString();\\n    }\\n\\n    boolean isPrime(int x){\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566299,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\nif( n <= 2) return 2; \\n\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\nif (n % 2 === 0 ){\\n    n ++;\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v = v + 2){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566230,
                "title": "easy-to-understand-and-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n\\n// there is no prime palindrome between this 1e7 & 1e8\\nif(n>=1e7 && n<=1e8) {\\n    return 100030001\\n}\\n\\nfor(let v = n ; v < 99999999999 ; v ++){\\nlet z = v.toString();\\nlet x = 0;\\nlet c = z.length-1;\\nlet isPal = true;\\nlet isPrime = true;\\n    if(v > 1){\\n        while(x < c){\\n        if(z[x] !== z[c]){\\n            isPal = false;\\n            break;\\n        }else{\\n            x ++;\\n            c --;\\n        }\\n    }\\n    }else{\\n        isPal = false;\\n    }\\n\\n    if(isPal){\\n        for(let b = 2 ; b <= Math.sqrt(v); b++){\\n            if(v % b === 0 ){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n    }else{\\n        isPrime = false;\\n    }\\n    \\n    if(isPrime){\\n        return v\\n    }\\n}\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3512734,
                "title": "maybe-i-m-just-dumb-well-commented-solution-kind-of-sort-of-cheating-with-the-final-max-num",
                "content": "Picture of my cat to make everything better. \\n\\n![20211003_173451.jpg](https://assets.leetcode.com/users/images/0cadf77c-6d75-419d-83cb-0b445925a599_1683814982.5276306.jpeg)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI figured just creating one list of all the prime-palindromes would reduce re-work, setup the list on solution creation, then all calls to PrimePalindrome(int n) just need to do one lookup in Log(n) time right? \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Sieve of Eratosthenes and an Is Palindrome function to populate our memory cache of valid possible numbers. \\n\\nMy sieveRange is actually incorrect as that\\'s just the range of input N being checked, had to manually add the max possible num to the list as this solution timed out if I increased the range to include that prime palindrome. \\n\\nThat misunderstanding of the range caused a lot of pain debugging. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI should quit to become a sheep herder in the Alps. \\n\\nSieve of Eratosthenes is typically considreed O(n log log n) so final for this solution is something like O(n * (Log(Log(n))) + Log(m)),\\nwhere m is size of the primePalindromes list. and that\\'s ignoring the time of palindrome check, but I\\'m too damn dumb to get this exactly right.\\n \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nShould be something like O(n + m), where n is the sieveRange (for the primes array in the SieveOfEratosthenes function) and m is the size of the primePalindromes\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    // List to store prime palindromes\\n    List<int> primePalindromes = new List<int>();\\n    \\n    // The maximum number we will check for prime palindrome\\n    const int sieveRange = 10000000; \\n\\n    // Constructor: when a new solution object is created, it populates the primePalindromes list\\n    public Solution()\\n    {\\n        // Populate all primes in testing range\\n        SieveOfEratosthenes();\\n        // Max item that could be found within range\\n        // Honestly just found this in the editorial write up, times out if I try to calculate with sieve\\n        primePalindromes.Add(100030001);\\n    }\\n\\n    // Method to find all prime numbers up to sieveRange using the Sieve of Eratosthenes algorithm\\n    private void SieveOfEratosthenes()\\n    {\\n        // Boolean array to mark prime and composite numbers\\n        bool[] primes = new bool[sieveRange];\\n        \\n        // Initially set all numbers as prime\\n        Array.Fill(primes, true);\\n        \\n        // 0 and 1 are not prime\\n        primes[0] = primes[1] = false;\\n\\n        // Main loop to mark composites. If i is prime, then i*i to sieveRange are not prime.\\n        for (int i = 2; i * i < sieveRange; i++)\\n        {\\n            if (primes[i])\\n            {\\n                for (int j = i * i; j < sieveRange; j += i)\\n                {\\n                    primes[j] = false;\\n                }\\n            }\\n        }\\n\\n        // Loop through all numbers and add the primes that are also palindrome to primePalindromes list\\n        for (int i = 2; i < sieveRange; i++)\\n        {\\n            if (primes[i] && IsPalindrome(i))\\n            {\\n                primePalindromes.Add(i);\\n            }\\n        }\\n    }\\n\\n    // Method to check if a number is palindrome or not\\n    private bool IsPalindrome(int num)\\n    {\\n        // Single digit numbers are always palindrome\\n        if (num < 10) return true;\\n\\n        // Reverse the number\\n        int reversed = 0;\\n        int original = num;\\n\\n        while (num > 0)\\n        {\\n            int digit = num % 10;\\n            reversed = reversed * 10 + digit;\\n            num /= 10;\\n        }\\n\\n        // If the reversed number is same as original, it is a palindrome\\n        return original == reversed;\\n    }\\n\\n    public int PrimePalindrome(int n)\\n    {\\n        // Use binary search to find the index of the smallest prime palindrome >= n\\n        int idx = primePalindromes.BinarySearch(n);\\n        \\n        if (idx < 0)\\n        {\\n            // If the exact value is not found, BinarySearch returns the bitwise    complement of the index of the next larger element\\n            idx = ~idx;\\n        }     \\n        \\n        // Return the prime palindrome at the found index\\n        return primePalindromes[idx];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441070,
                "title": "208-ms",
                "content": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\nrequire \\'prime\\'\\n\\n@r, b = Prime.each(11).to_a, 1\\nfor z in 1..3\\n    b *= 10\\n    for a in [1, 3, 5, 7, 9]\\n        for f in a * b...a.succ * b\\n            x = ((s = f.to_s) + s[0, z].reverse!).to_i\\n            @r << x if Prime.prime? x\\n        end\\n    end\\nend\\nf = 10_000\\nloop do\\n    x = ((s = f.to_s) + s[0, 4].reverse!).to_i\\n    next f += 1 unless Prime.prime? x\\n    @r << x\\n    break\\nend\\n\\ndef prime_palindrome(n) = @r.bsearch { _1 >= n }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3419172,
                "title": "prime-palindrome",
                "content": "---------------------- Easy C++ Solution -------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n bool isPrime(int n) {\\n        for(int i=2; i<=sqrt(n);i++) {\\n            if(n%i==0) return 0;\\n        }\\n        return 1;\\n    }\\n    int reverse(int n){\\n        int m = 0;\\n        while (n) {\\n            m = m*10 + n % 10;\\n            n /= 10;\\n        }\\n        return m;\\n    }\\n    \\n    int isPalindrome(int n){\\n        return n == reverse(n);\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if( n <= 2) return 2;\\n        \\n        if(n>=1e7 && n<=1e8) {\\n            n=100030001;\\n        }\\n        \\n        if(n%2==0) n++;\\n        \\n        for(int i=n; i>=n; i+=2){\\n            if(isPalindrome(i)) {\\n                if(isPrime(i)) return i;\\n            } \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339781,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if(n==2|| n==1)return 2;\\n         if(n>=9989900)return 100030001;\\n        if(n%2==0)n++;\\n        while(!palin(n) ||!prime(n))n+=2;\\n        return n;\\n    }\\n    bool palin(int n){\\n        string s=to_string(n);\\n        int i=0,j=s.length();\\n        while(i<j){\\n            if(s[i]!=s[j-1])return false;\\n            i++;j--;\\n        }\\n        return true;\\n    }\\n    bool prime(int n){\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319724,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool isPrime(int val){\\n        if(val == 1 ) \\n            return false ;\\n        if(val == 2)\\n            return true ;\\n        int limit = sqrt(val) ;\\n        for(int i = 2; i <= limit; i++){\\n            if(val % i == 0)\\n                return false ;\\n        }\\n        return true ;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        if(n >= 8  && n <= 11)\\n            return 11 ;\\n        for(int i = 1; i <= 1e5; i++){\\n            string s = to_string(i) ;\\n            string t = s ;\\n            reverse(t.begin(),t.end());  \\n            int val = stoi(s + t.substr(1)) ;\\n            if(val >= n && isPrime(val))\\n                return val ;\\n        }\\n        return -1 ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306862,
                "title": "very-basic-approch-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int palindrome(int y){\\n        int sum=0;\\n        int x=y;\\n        while(y){\\n            int a=y%10;\\n            y=y/10;\\n            sum+=a;\\n            if(sum==x){\\n                \\n                return 1;\\n            }\\n            sum*=10;\\n        }\\n        return 0;\\n    }\\n    int prime(int y){\\n        for(int i=2;i<=sqrt(y);i++){\\n            if(y%i==0){\\n                return 0;\\n            }\\n        }\\n        return 1;\\n    }\\n    int primePalindrome(int n) {\\n        if(n==0){\\n            return 0;\\n        }\\n        else if(99899*1e2 <= n && n <= 1e8){\\n             return 100030001;\\n        }\\n        else if(n==1){\\n            return n+1;\\n        }\\n        else if(prime(n)&&palindrome(n)){\\n            return n;\\n        }\\n        else {\\n            if(n%2==0){\\n                n+=1;\\n                if(prime(n)&&palindrome(n)){\\n                    return n;\\n                }\\n            } \\n            while(!prime(n) || !palindrome(n)){\\n                if(prime(n+2)&&palindrome(n+2)){\\n                    return n+2;\\n                }\\n                else if(prime(n+4)&&palindrome(n+4)){\\n                    return n+4;\\n                }\\n                else if(prime(n+6)&&palindrome(n+6)){\\n                    return n+6;\\n                }\\n                n=n+8;\\n            }    \\n            \\n\\n        }\\n       \\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301385,
                "title": "solution",
                "content": "# Intuition\\nTo solve this problem, we need to find the smallest prime palindrome greater than or equal to a given number n. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n One approach is to start checking numbers from n and incrementing by 1 until we find a number that is both a palindrome and a prime. We can use helper methods to check whether a number is a palindrome and a prime. Another approach is to exploit the patterns in the problem and optimize the algorithm, such as by narrowing down the search space to odd-digit palindromes and skipping even-length palindromes.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the input value n and the efficiency of the prime and palindrome checking algorithms. In the worst case, we may need to check all numbers up to 10^8, which would take O(10^8) time. However, with the optimizations mentioned earlier, we reduce the search space and improve the performance. The isPalindrome() method takes O(log n) time, since it checks each digit of the number. The isPrime() method takes O(sqrt(n)) time, since it checks all divisors up to the square root of n. Therefore, the overall time complexity is roughly O(n * sqrt(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1), since we only need to store a few integer variables. The space used by the helper methods is also O(1), since they don\\'t use any additional data structures.\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        if (n <= 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n++;\\n        }\\n        while (true) {\\n            if (isPalindrome(n) && isPrime(n)) {\\n                return n;\\n            }\\n            n += 2; // only check odd numbers\\n            if (n > 10_000_000 && n < 100_000_000) { // skip even-length palindromes\\n                n = 100_000_001; // jump to next odd-length palindrome\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int num) {\\n        int reversed = 0, remainder, original = num;\\n        while (num != 0) {\\n            remainder = num % 10;\\n            reversed = reversed * 10 + remainder;\\n            num /= 10;\\n        }\\n        return reversed == original;\\n    }\\n    \\n    private boolean isPrime(int num) {\\n        if (num < 2) {\\n            return false;\\n        }\\n        int sqrt = (int) Math.sqrt(num);\\n        for (int i = 2; i <= sqrt; i++) {\\n            if (num % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141927,
                "title": "iterating-over-palindromes-c-runtime-beats-100",
                "content": "# Intuition\\nSome points to note:\\n- Far fewer numbers are palindrome than not\\n- Palindromes can easily be generated from their first half (for palindromes of odd length, including their middle digit)\\n- The numerical order of (odd length) palindromes is equal to the order of their first halves. Therefore, it is easy to iterate over all palindromes in ascending order by iterating over their first halves.\\n\\n# Approach\\n`oddPalindrome` generates an odd-length palindrome from the integer representing its first half (inclunding middle digit) by adding the string representation and its reverse, excluding the duplicate middle digit. \\n`IsPrime` is used to check whether the generated number is a prime number.\\n\\n# Complexity\\n- Time complexity:\\nChecking primeness: $$O(\\\\sqrt{n})$$ \\nFinding prime palindrome: Unknown, as palindromes can not be regarded as random integers and therefore, the density of prime palindromes is not equal to that of primes in general.\\n\\n- Space complexity:\\n$$O(log(n))$$, the extra memory increases with the length of the result in decimal representation.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PrimePalindrome(int n) {\\n        string Reverse(string text) {\\n            char[] array = text.ToCharArray();\\n            Array.Reverse(array);\\n            return new String(array);\\n        }\\n        int oddPalindrome(int a) {\\n            return int.Parse(a.ToString() + Reverse(a.ToString()).Substring(1));\\n        }\\n        bool isPrime(int a) {\\n            if(a < 2 || a == 9)\\n                return false;\\n            if(a == 2 || a == 3 || a == 5 || a == 7)\\n                return true;\\n            int sqrt = (int)Math.Sqrt(a)+1;\\n            if(a%2 == 0)\\n                return false;\\n            for(int i = 3; i < sqrt; i+=2)\\n            {\\n                if(a%i==0)\\n                    return false;\\n            }\\n            return true;\\n        }\\n\\n        if(n >= 8 && n <= 11) // The only numbers resulting in 11, the only palindrome prime with an even number of digtis\\n            return 11;\\n\\n        int x = int.Parse(n.ToString().Substring(0,(n.ToString().Length + 1) / 2) );\\n        while(x < 100000) //some upper limit\\n        {\\n            int p = oddPalindrome(x);\\n            if(p >= n && isPrime(p))\\n                return p;\\n            x++;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060479,
                "title": "kotlin-beats-100-simple-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\nfun primePalindrome(n: Int): Int {\\n            var i = n\\n\\n            while (!isPalindrome(i) || !isPrime(i)) {\\n                i++\\n\\n                if (i in 10000001..99999999)\\n                    i = 100_000_000\\n            }\\n\\n            return i\\n        }\\n\\n        private fun isPrime(number: Int): Boolean {\\n            if (number < 2) return false\\n            if (number <= 3) return true\\n            if (number % 2 == 0 || number % 3 == 0) return false\\n\\n            for (i in 2..Math.sqrt(number.toDouble()).toInt()) {\\n                if (number % i == 0) {\\n                    return false\\n                }\\n            }\\n            return true\\n        }\\n\\n        private fun isPalindrome(number: Int): Boolean {\\n            return number.toString() == number.toString().reversed()\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993336,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isPalindrome_(int n)\\n    {\\n        if(n < 10)\\n        {\\n            return true;\\n        }\\n        string a=to_string(n);\\n        int i=0;\\n        int j=a.size()-1;\\n        while(i <= j )\\n        {\\n            if(a[i]!=a[j])\\n            {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n\\n    bool isPrime(int n)\\n    {\\n        if(n <= 1)\\n        {\\n            return false;\\n        }\\n\\n        for(int i=2;i*i<=n;i++)\\n        {\\n            if(n%i==0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n\\n    int primePalindrome(int n) {\\n        if(n==1){return 2;}\\n        if (99899*1e2 <= n && n <= 1e8)\\n        {\\n             return 100030001;\\n        }\\n       \\n        for(long long i=n;i<1e7;i++)\\n        {\\n            if(isPrime(i) && isPalindrome_(i))\\n            {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2983531,
                "title": "100-fastest-and-easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (n == palindrome(n) && prime(n))\\n                return n;\\n            n++;\\n            if (10_000_000 < n && n < 100_000_000)\\n                n= 100_000_000;\\n        }\\n    }\\n    public boolean prime(int n) {\\n        if (n < 2)\\n        {\\n            return false;\\n        } \\n        int r = (int) Math.sqrt(n);\\n        for (int i = 2; i <= r; ++i)\\n        {\\n            if (n % i == 0)\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public int palindrome(int n) {\\n        int r = 0;\\n        while (n > 0) \\n        {\\n            int c=n%10;\\n            r=r*10+c;\\n            n/= 10;\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2965600,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn prime_palindrome(n: i32) -> i32 {\\n        fn is_prime(n: i32) -> bool {\\n            if n == 1 {\\n                return false;\\n            }\\n            for i in 2..=(n as f64).sqrt() as i32 {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        let n_str = n.to_string();\\n        let len = n_str.len() as i32;\\n\\n        for k in std::cmp::max(0, len / 2 - 1)..5 {\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if k > 0 && \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().skip(1).collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n\\n            for i in 10_i32.pow(k as u32)..10_i32.pow(k as u32 + 1) {\\n                let i_str = i.to_string();\\n                if \"24658\".contains(i_str.chars().next().unwrap()) {\\n                    continue;\\n                }\\n\\n                let cur = format!(\"{}{}\", i_str, i_str.chars().rev().collect::<String>());\\n                let cur_int = cur.parse::<i32>().unwrap();\\n                if cur_int >= n && is_prime(cur_int) {\\n                    return cur_int;\\n                }\\n            }\\n        }\\n\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2950329,
                "title": "python3-concise-solution-beats-99",
                "content": "# Code\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924931,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        \\n  \\n  boolean l=false;\\n\\n        if(n==1||n==0)\\n            return 2;\\n\\n\\n       while(l!=true)\\n        {\\n\\n            if( n > 11 && n < 100 )\\n            {\\n                n = 101 ;\\n            }\\n            if( n > 999 && n < 10000 )\\n            {\\n                n = 10001 ;\\n            }\\n            if( n > 99999 && n < 1000000 )\\n            {\\n                n = 1000001 ;\\n            }\\n            if( n > 9999999 && n < 100000000 )\\n            {\\n                n = 100000001 ;\\n            }\\n\\n            else if(pal(n)&&prime(n))\\n                break;\\n\\n            else\\n                n++;\\n\\n        }\\n\\n       return n;\\n\\n    }\\n\\n    public static boolean prime(int N)\\n    {\\n\\n        int i ;\\n\\n        if( ( N & 1 ) == 0 && N != 2 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 3 == 0 && N != 3 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 11 == 0 && N != 11 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 13 == 0 && N != 13 )\\n        {\\n            return false ;\\n        }\\n\\n        else if( N % 17 == 0 && N != 17 )\\n        {\\n            return false ;\\n        }\\n\\n        else\\n        {\\n            for( i = 3 ; i <= Math.sqrt(N) ; i += 2 )\\n            {\\n                if( N % i == 0 )\\n                {\\n                    return false ;\\n                }\\n            }\\n        }\\n\\n        return true ;\\n\\n    }\\n    public static boolean pal(int u)\\n    {\\n\\n        int z=Integer.toString(u).length()-1;\\n        int w=0;\\n        int ans=u;\\n\\n        while(u>0)\\n        {\\n\\n            int k=u%10;\\n            w=w+k*(int)Math.pow(10,z);\\n            z--;\\n            u=u/10;\\n\\n        }\\n\\n        if(w==ans)\\n            return true;\\n\\n        else\\n            return false;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891591,
                "title": "java-it-s-easy-solution-but-low-speed-took-it-n-n-from-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic static boolean getPalindrome(String  candidateForSearch) {\\n        char[] charFromString = candidateForSearch.toCharArray();\\n        for (int i = 0; i < charFromString.length; i++) {\\n            if (charFromString[i] != charFromString[charFromString.length - 1 - i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public static int primePalindrome(int n) {\\n        int secondNumber = n + 2;\\n        int countDivider = 0;\\n        boolean endNumber;\\n        if (n == 1) {\\n            return 2;\\n        }\\n        if (n == 2) {\\n            return 2;\\n        }\\n        if (n % 2 == 0) {\\n            n = n+1;\\n        }\\n\\n        for ( ; n <= secondNumber; n+=2 ) {\\n            if (10000000 < n && n < 100000000) {\\n                n = 99999999;\\n                secondNumber = n + 2;\\n            }\\n            String exchangeFromInteger = String.valueOf(n);\\n            endNumber = getPalindrome(exchangeFromInteger);\\n            if (!endNumber) {\\n                secondNumber+=2;\\n                continue;\\n            }\\n            for (int i = 3; i < n ; i+=2) {\\n                if (n % i == 0) {\\n                    countDivider++;\\n                    break;\\n                }\\n            }\\n            if (countDivider == 0) {\\n                return n; //\\n            }\\n\\n            countDivider = 0;\\n            secondNumber+=2;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831041,
                "title": "o-1-solution",
                "content": "# Intuition\\n##### We know there are pretty limited number of prim numbers in a  range, and palindromes are also rare , so , primepalindrome are even rarer...\\n##### we can just precompute the prime Palindromes and then Find the lowerbound of whatever number is asked in the testcase .\\n##### I have attached program I used to generate the list.\\n\\n# Code\\n```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\\n# This is the code that I used to geneerate the primepalindrome list.\\n\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic :\\nconst vector<int> pp = { 2,3,5,7,11,101,131,151,181,191,313,353,373,383,727,757,787,797,919,929,10301,10501,10601,11311,11411,12421,12721,12821,13331,13831,13931,14341,14741,15451,15551,16061,16361,16561,16661,17471,17971,18181,18481,19391,19891,19991,30103,30203,30403,30703,30803,31013,31513,32323,32423,33533,34543,34843,35053,35153,35353,35753,36263,36563,37273,37573,38083,38183,38783,39293,70207,70507,70607,71317,71917,72227,72727,73037,73237,73637,74047,74747,75557,76367,76667,77377,77477,77977,78487,78787,78887,79397,79697,79997,90709,91019,93139,93239,93739,94049,94349,94649,94849,94949,95959,96269,96469,96769,97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,9938399,9957599,9965699,9978799,9980899,9981899,9989899,100030001} ;\\n\\n    int primePalindrome(int n) {\\n        auto lb = lower_bound(pp.begin() , pp.end() , n ) ;\\n        if( lb != pp.end()) return *lb ;\\n        return 0 ;\\n    }\\n};\\n```\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\nbool isPalindrome(int n)\\n{\\n    string s = to_string(n);\\n    int l = 0, r = s.length() - 1;\\n    while (l <= r)\\n    {\\n        if (s[l] == s[r])\\n            l++, r--;\\n        else\\n            return false;\\n    }\\n    return true;\\n}\\nvoid generatePrimePalindrome()\\n{\\n    vector<int> primePalindromes;\\n    int rr = 2 * 1e8; // this range is not quite needed , as the next prime palindrome after 1e8 is 100030001. and there is no need to find more of them.\\n    vector<bool> notprime(rr + 1);\\n\\n    for (int i = 2; i * i <= rr; i++)\\n    {\\n        for (int j = 2; i * j <= rr; j++)\\n        {\\n            notprime[i * j] = true;\\n        }\\n    }\\n\\n    for (int i = 2; i <= rr; i++)\\n    {\\n        if (!notprime[i] and isPalindrome(i))\\n            primePalindromes.push_back(i);\\n    }\\n    for (auto pp : primePalindromes)\\n    {\\n        cout << pp << \",\";\\n    }\\n\\n}\\n\\nint main()\\n{\\n    generatePrimePalindrome();\\n    return 0;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2710531,
                "title": "easy-java-solution-all-even-length-pallindrome-are-divisble-by-11",
                "content": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }\\n        for(int i = 3;i*i <= n;i++){\\n            if(n % i == 0)\\n               return false;\\n        }\\n        return true;\\n    }\\n    public int primePalindrome(int n) {\\n        if(n >= 8 && n <= 11)\\n            return 11;\\n         for (int i = 1; i < 100000; i++) {\\n            String s = Integer.toString(i);\\n            String r = new StringBuilder(s).reverse().toString(); \\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= n && isPrime(y)) \\n                return y;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Boolean isPrime(int n){\\n          if(n < 2 || n % 2 == 0){\\n            return n == 2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2699888,
                "title": "python3-generating-palindromes-neglecting-4-6-8-digit-palindromes-checking-for-prime",
                "content": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}\\n        \\n        while True:\\n            x = nextPalindrome(x)\\n            intX = int(\\'\\'.join(x))\\n            if len(x) not in invalidLengths and intX>=n:\\n                if isPrime(intX):\\n                    return intX",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def primePalindrome(self, n: int) -> int:\\n        def nextPalindrome(x):\\n            lenX = len(x)\\n            n = lenX//2\\n            for i in range(n,lenX):\\n                if int(x[i])+1<10:\\n                    x[i] = x[~i] = str(int(x[i])+1)\\n                    for j in range(n,i):\\n                        x[j] = x[~j] = \\'0\\'\\n                    return x\\n            return [\\'1\\']+[\\'0\\']*(lenX-1)+[\\'1\\']               \\n        \\n        def isPrime(x):\\n            if x == 1:\\n                return False\\n            if x == 2:\\n                return True\\n            ul = int(sqrt(x)) + 1\\n            for i in range(2,ul):\\n                if x%i==0:\\n                    return False\\n            return True\\n        \\n        x = [\"0\"]\\n        invalidLengths = {4,6,8}",
                "codeTag": "Java"
            },
            {
                "id": 2673013,
                "title": "my-simple-python3-solution",
                "content": "For me, the main insight that fixed the excessive computation time for my code was this line: if 10\\\\**7 < n < 10**8 (which was taken from the formal solution). \\n\\nRuntime: 644 ms  (Beats 15%)\\nMemory : 13.9 MB (Beats 77.14%)\\n\\n# Code\\n```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef isPalindrome(m:int) -> bool:\\n    mstr = list(str(m))\\n    return mstr == mstr[::-1]\\n\\ndef isPrime(m:int):\\n    if 1==m:\\n        return False\\n    elif 2==m:\\n        return True\\n        \\n    for k in range(2, 1+int(m**0.5)):\\n        if 0 == m % k:\\n            return False\\n    return True\\n\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n                \\n        OK = True\\n        while OK:\\n            if 10**7 < n < 10**8:  \\n                # Any even length palindrome must be divisble by 11\\n                # so we will skip numbers N = [10,000,000, 99,999,999]                \\n                n = 10**8\\n                                \\n            if (isPalindrome(n) and isPrime(n)):\\n                OK = False\\n            else:\\n                n = n + 1\\n\\n        return int(n)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618816,
                "title": "o-n-time-o-1-space-clear-explanation-only-odd-palindromes",
                "content": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/a5d25f3f-530d-455d-8405-a2a6127c40ec_1664034864.259861.png)\\n\\n\\n    def primePalindrome(self, n: int) -> int:\\n        \"\"\" O(N)T O(1)S \"\"\"\\n        if n <= 1:\\n            return 2 # 2 is the first prime number\\n\\n        if 8 <= n <= 11:\\n            return 11 # 11 is only one even palindrome\\n\\n        for i in range(1, 90000):\\n            if (j := int(str(i)[:-1] + str(i)[::-1])) >= n and not any(j % d == 0 for d in range(2, math.isqrt(j) + 1)):\\n                return j",
                "codeTag": "Python3"
            },
            {
                "id": 2567161,
                "title": "php-solution",
                "content": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution\\n{\\n    /**\\n     * @param int $n\\n     * @return int\\n     */\\n    function primePalindrome(int $n): int {\\n        while (true) {\\n            if ($n > 11 && strlen((string)$n) % 2 === 0) {\\n                $n = pow(10, ceil(log10($n + 1)));\\n                continue;\\n            }\\n\\n            if ($this->isPalindrome($n) && $this->isPrime($n)) {\\n                break;\\n            }\\n\\n            $n++;\\n        }\\n\\n        return $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPalindrome(int $n): bool\\n    {\\n        return (int)strrev((string)$n) === $n;\\n    }\\n\\n    /**\\n     * @param int $n\\n     * @return bool\\n     */\\n    private function isPrime(int $n): bool {\\n        if ($n <= 3) {\\n            if ($n <= 1) {\\n                return false;\\n            }\\n\\n            return true;\\n        }\\n\\n        if ($n % 2 === 0 || $n % 3 === 0) {\\n            return false;\\n        }\\n\\n        for ($i = 3;  pow($i, 2) <= $n; $i += 2) {\\n            if ($n % $i === 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519791,
                "title": "c-ispalindrome-and-prime-check-easy",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```\\n**If helpful Please Like Or Upvoke**",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        bool isPrime(int n)\\n        {\\n            if (n <= 1) return false;\\n            if (n <= 3) return true;\\n            if (n % 2 == 0 || n % 3 == 0) return false;\\n            for (int i = 5; i * i <= n; i = i + 6)\\n                if (n % i == 0 || n % (i + 2) == 0) return false;\\n            return true;\\n        }\\n\\n    bool isPalindrome(string S)\\n    {\\n        string P = S;\\n        reverse(P.begin(), P.end());\\n        if (S == P)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n    int primePalindrome(int n)\\n    {\\n        if (99899 * 1e2 <= n && n <= 1e8)\\n            return 100030001;\\n        for (int j = n; j < 1e8; j++)\\n        {\\n            if (isPrime(j))\\n            {\\n                if (isPalindrome(to_string(j)))\\n                    {\\n                        return j;\\n                    }\\n                }\\n            }\\n            return 0;\\n        }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465618,
                "title": "javascript-easy-solution",
                "content": "\\n\\n```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar primePalindrome = function(n) {\\n    let i ;\\n    if (n == 1 || n ==2) return 2;\\n    if(n%2 == 0) i = n+1;\\n    else         i=n;\\n    while (true) {\\n        if ( isPalind(i) && isPrime(i) ) {\\n            return i;\\n        }\\n        i+=2\\n        if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n        if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n        if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n        if(i > 11 && i < 100) i = 101;\\n    }\\n    return -1;\\n};//9989900\\n\\n\\n\\nfunction isPrime(num) {\\n    for ( var i = 2; i < num; i++ ) {\\n        if ( num % i === 0 ) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\nfunction isPalind(n){\\n    return  n.toString() === n.toString().split(\"\").reverse().join(\"\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464988,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPal(int n){\\n        int rev = 0;\\n        int temp = n;\\n        while(temp!=0){\\n            int ld = temp%10;\\n            rev = rev*10+ld;\\n            temp /=10;\\n        }\\n        return (rev==n);\\n    }\\n    \\n    bool isPrime(int n){\\n        if(n==1) return false;\\n        for(int i=2; i*i<=n; i++){\\n            if(n%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n==1 || n==2) return 2;\\n        int i;\\n        if(n%2 == 0) i = n+1;\\n        else i=n;\\n        while(true){\\n            if(isPal(i) and isPrime(i)) \\n                return i;\\n            i += 2; // even numbers aren\\'t prime, so skip.\\n\\t\\t\\t\\n\\t\\t\\t// Any even length palindrome must be divisble by 11 so skip them.\\n            if(i > 1e7 && i < 1e8) i = 1e8 + 1;\\n            if(i > 1e5 && i < 1e6) i = 1e6 + 1;\\n            if(i > 1e3 && i < 1e4) i = 1e4 + 1;\\n            if(i > 11 && i < 100) i = 101;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423771,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    \\n    int count_digits(int N){\\n        int count = 0;\\n        do{\\n            N /= 10;\\n            count++;\\n        }while(N);\\n        return count;\\n    }\\n    \\n    int is_prime(int N){\\n        int i = 2;\\n        while(i * i <= N){\\n            if(N % i == 0) return false;\\n            ++i;\\n        }\\n        return i;\\n    }\\n    \\n    void gen(string& str, int idx, int min){\\n        if(idx > str.size()/2){\\n            int val = stoi(str);\\n            if(val >= min && is_prime(val)) ans = val;\\n            return;\\n        };\\n        for(int i = 0; i <= 9 && ans == -1; ++i){\\n            str[idx] = str[str.size() - idx - 1] = (\\'0\\' + i);\\n            gen(str, idx + 1, min);\\n        }\\n    }\\n    int primePalindrome(int N) {\\n        N = max(2, N);  \\n        int cd = count_digits(N);\\n        while(ans == -1){\\n            string s(cd, \\' \\');\\n            gen(s, 0, N);\\n            cd++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326905,
                "title": "c-100",
                "content": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\npublic int PrimePalindrome(int n)\\n    {\\n       int result = 0;\\n        int flag1 = 1;\\n        int flag2 = 1;\\n        int max1stList = 1;\\n        int max2ndList = 1;\\n        for (int j = 0; j < 2; j++)\\n        {\\n            result = 0;\\n            int i = 1;\\n            do\\n            {\\n                result = CreatePalindrome(i++, 10, j % 2);\\n                if (result >= n)\\n                {\\n                    if (j == 0)\\n                    {\\n                        max1stList = result;\\n                        flag1 = i - 1;\\n                    }\\n                    if (j == 1)\\n                    {\\n                        max2ndList = result;\\n                        flag2 = i - 1;\\n                    }\\n                    break;\\n                }\\n            } while (true);\\n        }\\n\\n        for (int j = 0; j < 2; j++)\\n        {\\n            do\\n            {\\n                if (max1stList > max2ndList)\\n                {\\n                    int l = flag2;\\n                    while ((result = CreatePalindrome(l++, 10, 1)) < max1stList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max1stList)) return max1stList;\\n                }\\n                else if (max1stList < max2ndList)\\n                {\\n                    int l = flag1;\\n                    while ((result = CreatePalindrome(l++, 10, 0)) < max2ndList)\\n                    {\\n                        if (IsPrime(result)) return result;\\n                    }\\n                    if (IsPrime(max2ndList)) return max2ndList;\\n                }\\n                \\n                if (j == 0)\\n                {\\n                    result = CreatePalindrome(++flag1, 10, j % 2);\\n                    max1stList = result;\\n                }\\n                if (j == 1)\\n                {\\n                    result = CreatePalindrome(++flag2, 10, j % 2);\\n                    max2ndList = result;\\n                    j = -1;\\n                }\\n                break;\\n            } while (true);\\n        }\\n        return 0;\\n    }\\n    \\n    public bool IsPrime(int n)\\n    {\\n        if (n <= 1) return false;\\n        if (n <= 3) return true;\\n\\n        // This is checked so that we can skip\\n        // middle five numbers in below loop\\n        if (n % 2 == 0 || n % 3 == 0) return false;\\n\\n        for (int i = 5; i * i <= n; i = i + 6)\\n            if (n % i == 0 || n % (i + 2) == 0) return false;\\n\\n        return true;\\n    }\\n    \\n    public int CreatePalindrome(int input, int b, int isOdd)\\n    {\\n        int n = input;\\n        int palin = input;\\n\\n        if (isOdd == 1)\\n            n /= b;\\n\\n        // Creates palindrome by just appending\\n        // reverse of number to itself\\n        while (n > 0)\\n        {\\n            palin = palin * b + (n % b);\\n            n /= b;\\n        }\\n        return palin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282027,
                "title": "no-math-all-logic-python",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n<3:return 2\\n\\t\\t#generating palindrome less than 10**8\\n        l=[\"\"]+[*\"1234567890\"]\\n        for i in l:\\n            if len(i)<7:\\n                for j in \"1234567890\":\\n                    l+=[j+i+j]\\n\\t\\t#finding prime from generated palindrome\\n        q=[]\\n        for i in l[2:]:\\n            if i[0]!=\"0\":\\n                i=int(i)\\n                t=i%2\\n                if t:\\n                    for j in range(3,int(i**.5)+1,2):\\n                        if i%j==0:\\n                            t=0\\n                            break\\n                if t:q+=[i]\\n        q.sort()\\n        q+=[100030001]\\n        return q[bisect_left(q,n)]",
                "codeTag": "Java"
            },
            {
                "id": 2259031,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int n) \\n    {\\n       while(true)\\n       {\\n            if(palindrome(n) && prime(n))\\n            {\\n                return n;\\n            }\\n            n++;\\n            if (n > 10_000_000  && n < 100_000_000)\\n            {\\n                n = 100_000_001;\\n            }\\n       }  \\n    }\\n    \\n    public static boolean prime(int no)\\n    {\\n        boolean flag = false;\\n        if(no == 0 || no == 1)\\n        {\\n            return flag;\\n        }\\n        for(int i = 2 ; i <= no / 2 ; i++)\\n        {\\n            if(no % i == 0)\\n            {\\n                return flag;\\n            }\\n        }\\n        if(!flag)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    public static boolean palindrome(int no)\\n    {\\n        int rem = 0 ;\\n        int rev = 0 ;\\n        int temp = no;\\n        while(no != 0)\\n        {\\n            rem = no % 10 ;\\n            rev = (rev * 10) + rem ;\\n            no = no / 10;\\n        }\\n        if(temp == rev)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207599,
                "title": "2-different-java-solution",
                "content": "### 68ms runtime.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\\n\\n### Time Limit Exceeded.\\n\\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if (8 <= N && N <= 11) return 11;\\n        for (int x = 1; x < 100000; x++) {\\n            String s = Integer.toString(x), r = new StringBuilder(s).reverse().toString();\\n            int y = Integer.parseInt(s + r.substring(1));\\n            if (y >= N && isPrime(y)) return y;\\n        }\\n        return -1;\\n    }\\n\\n    public Boolean isPrime(int x) {\\n        if (x < 2 || x % 2 == 0) return x == 2;\\n        for (int i = 3; i * i <= x; i += 2)\\n            if (x % i == 0) return false;\\n        return true;\\n    }\\n}\\n```\n```\\n// Prime Palindrome\\n// Leetcode problem: https://leetcode.com/problems/prime-palindrome/\\n\\nclass Solution {\\n    public int primePalindrome(int n) {\\n        while (true) {\\n            if (isPrime(n) && isPalindrome(n)) {\\n                return n;\\n            }\\n            n++;\\n        }       \\n    }\\n    private boolean isPrime(int n) {\\n        if (n == 1) {\\n            return false;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n); i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    private boolean isPalindrome(int n) {\\n        String s = String.valueOf(n);\\n        int i = 0;\\n        int j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i) != s.charAt(j)) {\\n                return false;\\n            }\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2190884,
                "title": "prime-palindrome-java-easy-solution-brute-force",
                "content": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }\\n        for(int i = n;i <= (int)2*Math.pow(10,8);i++){\\n            if(isPrime(i) && isPalindrome(i)){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    public boolean isPrime(int n) {\\n        if (n <= 1) {\\n            return false;\\n        }\\n        if (n == 2) {\\n            return true;\\n        }\\n        for (int i = 2; i <= Math.sqrt(n) + 1; i++) {\\n            if (n % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPalindrome(int n)\\n    {\\n          \\n        // Find reverse of n\\n        int rev = 0;\\n        for (int i = n; i > 0; i /= 10)\\n            rev = rev * 10 + i % 10;\\n              \\n        // If n and rev are same, \\n        // then n is palindrome\\n        return(n == rev) ? true : false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int primePalindrome(int n) {\\n        //corner case :)\\n        if(n >= 9989900 && n < 100030001){\\n            return 100030001;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2161839,
                "title": "javascript-easy-to-understand-explained-in-comments",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function (n) {\\n  if (n < 3) return 2\\n\\n  // iterator for next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\u7684\\u8FED\\u4EE3\\u5668\\n  let it = nextPalindrome(n)\\n\\n  while (true) {\\n    let num = it.next().value // next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n    if (isPrime(num)) return num // is prime and return | \\u5982\\u679C\\u662F\\u8D28\\u6570\\u5219\\u8FD4\\u56DE\\n  }\\n\\n  /**\\n   * is prime | \\u5224\\u65AD\\u8D28\\u6570\\n   * @param {number} n \\n   * @returns {boolean} \\n   */\\n  function isPrime(n) {\\n    if (n % 2 === 0) return false\\n    for (let i = 3; i < n / 2; i += 2) {\\n      if (n % i === 0) return false\\n    }\\n    return true\\n  }\\n\\n  /**\\n   * next palindrome | \\u4E0B\\u4E00\\u4E2A\\u5BF9\\u79F0\\u6570\\n   * @param {number} n\\n   */\\n  function* nextPalindrome(n) {\\n    // \\u627E\\u5230\\u4E00\\u534A\\u957F\\u5EA6\\u7684\\u6570\\u5B57\\uFF0C371=>37, 3772=>7, find first half number \\n    let length = (\\'\\' + n).length \\n    let halfLength = Math.floor(length / 2) \\n    let halfNum = Math.floor(n / Math.pow(10, halfLength))\\n\\n    // \\u53EF\\u80FDn\\u5C31\\u662F\\u5BF9\\u79F0\\u7684 | case n is palindrome\\n    let first = half2full(halfNum, halfLength)\\n    if (first >= n) yield first\\n\\n    // \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n    while (true) yield nextNum()\\n\\n    /**\\n     * \\u66F4\\u5927\\u7684\\u5BF9\\u79F0\\u6570 | larger palindromes\\n     * @returns {number}\\n     */\\n    function nextNum() {\\n      // 37(3)=>38(3)\\uFF0C37(73)=>38(83)\\n      halfNum++\\n\\n      // 9=>11 (9=>10(/10)=>1=>1(1))\\n      // 99=>1001 (9=>10=>10(01))\\n      if (Math.log10(halfNum) % 1 === 0) {\\n        if (length % 2) halfNum /= 10\\n        length++\\n        halfLength = Math.floor(length / 2)\\n      }\\n\\n      // 37=>373 | 37=>3773  \\n      return half2full(halfNum, halfLength)\\n    }\\n\\n    function half2full(halfNum, halfLength) {\\n      return halfNum * Math.pow(10, halfLength) + getReversed(halfNum, halfLength)\\n\\n      function getReversed(num, length) {\\n        let arr = []\\n        while (num) {\\n          let v = num % 10\\n          num -= v\\n          num /= 10\\n          arr.push(v)\\n        }\\n        let rtn = 0\\n        for (let i = 0; i < length; i++) {\\n          rtn *= 10\\n          rtn += arr[arr.length - length + i]\\n        }\\n        return rtn\\n      }\\n    }\\n  }\\n};\\n\\nconsole.log(primePalindrome(1)) //2\\nconsole.log(primePalindrome(2)) //2\\nconsole.log(primePalindrome(3)) //3\\nconsole.log(primePalindrome(4)) //5\\n\\nconsole.log(primePalindrome(6)) //7\\nconsole.log(primePalindrome(8)) //11\\nconsole.log(primePalindrome(13)) //101\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111308,
                "title": "javascript-iterate-palindromes-clean-and-simple-code-faster-than-90",
                "content": "High-level explanation:\\n\\n- This is an implementation of the \"iterate palindromes\" solution\\n- At the top level, we will iterate over the number of digits in the palindrome, starting with the number of digits in n (if n = 13, digits = 2, 3, 4, ...)\\n- Inside the loop, we will iterate palindromes (1001, 1111, 1221, ..., 9999). To do this, we generate the first half of the palindrome and double it.\\n- There are special cases depending on whether digits is even or odd (palindrome = 1001, 1111, ... vs palindrome = 10001, 10101, ...)\\n\\n```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPrime = (n) => {\\n  if (n <= 1) {\\n    return false;\\n  }\\n\\n  if (n === 2) {\\n    return true;\\n  }\\n\\n  // we are doing this up front so we can increment by 2\\n  if (n % 2 === 0) {\\n    return false;\\n  }\\n\\n  // check up to and include the square root of the number\\n  // if we ever passed the square root, we would have already\\n  // seen that divisor up to and including the square root\\n  for (let i = 3; i * i <= n; i += 2) {\\n    // we found a divisor\\n    if (n % i === 0) {\\n      return false;\\n    }\\n  }\\n\\n  // we did not find a divisor\\n  return true;\\n};\\n\\nconst reverseStr = (s) => {\\n  return s.split(\"\").reverse().join(\"\");\\n};\\n\\nconst getPalindromeWithDigits = ({ digits, n }) => {\\n  // for digits=4, we want to generate palindromes from 1001 to 9999 inclusive\\n  // let\\'s generate the first half of the palindrome\\n  // even case (digits=4): genDigits=2\\n  // odd case (digits=5): genDigits=3\\n  const genDigits = Math.floor((digits + 1) / 2);\\n\\n  const start = Math.pow(10, genDigits - 1);\\n  const end = 10 * start - 1;\\n  \\n  for (let i = start; i <= end; i++) {\\n    let palindromeStr;\\n    if (digits % 2 === 0) {\\n      // even case\\n      // double the string\\n      palindromeStr = `${`${i}`}${reverseStr(`${i}`)}`;\\n    } else {\\n      // odd case\\n      // we want to keep the middle digit from the first part,\\n      // and exclude the middle digit from the second part\\n      palindromeStr = `${`${i}`.slice(0, genDigits)}${reverseStr(\\n        `${i}`.slice(0, genDigits - 1)\\n      )}`;\\n    }\\n    const palindrome = parseInt(palindromeStr, 10);\\n\\n    // check if prime palindrome\\n    if (palindrome >= n && isPrime(palindrome)) {\\n      return palindrome;\\n    }\\n  }\\n  return null;\\n};\\n\\nconst primePalindrome = (n) => {\\n  const digits = `${n}`.length;\\n\\n  // check for palindromes of length i\\n  let i = digits;\\n  while (true) {\\n    if (i >= 10) {\\n      throw new Error(\"max digits exceeded\");\\n    }\\n\\n    const palindrome = getPalindromeWithDigits({ digits: i, n });\\n    if (palindrome) {\\n      return palindrome;\\n    }\\n    i++;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045085,
                "title": "c-code-100",
                "content": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){    \\n    unsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;    \\n    if(N==1) return 2;\\n    for(i=N;;i++){\\n        s=0;\\n        rev=0;\\n        rem=0;\\n        dummy=i;\\n        if(dummy<=11||\\n           dummy%2!=0 && \\n           dummy%3!=0 && \\n           dummy%5!=0 &&\\n           dummy%7!=0 &&\\n           dummy%11!=0){\\n            while(dummy>0){\\n                rem = dummy%10;\\n                s = s + rem;\\n                rev = rev*10 + rem;\\n                dummy = dummy/10;\\n            }\\n            if(rev == i){\\n                s=0;\\n                for(j=2;j<=sqrt(i);j++){\\n                    if(i%j == 0){\\n                        ++s;\\n                        break;\\n                    }\\n                }  \\n                if(s == 0){\\n                    return i;\\n                }\\n            }\\n        }\\n    }\\n    return 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980487,
                "title": "python-my-ugly-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1][1:])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1][1:])\\n        else:\\n            if set(str(int_val)) == {\\'9\\'}:\\n                return \\'\\'.join(nex[:-1] + nex[::-1])\\n            else:\\n                return \\'\\'.join(nex + nex[::-1])\\n    \\n    def isPrime(self, n):\\n        if n == 1: return False\\n        for i in range(2, int(sqrt(n))+1):\\n            if n % i == 0:\\n                return False\\n        return True",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        val = \\'\\'.join([\\'1\\'] + [\\'0\\'] * (len(str(n)) - 2) + [\\'1\\'])\\n        if n < 10: val = str(n)\\n        \\n        while not self.isPrime(int(val)) or int(val) < n:\\n            val = self.getNextPalindrome(val)\\n        \\n        return int(val)\\n        \\n    def getNextPalindrome(self, cur):\\n        cur = list(cur)\\n        int_val = int(\\'\\'.join(cur[:(len(cur)+1)//2]))\\n        nex = list(str(int_val+1))\\n        \\n        if len(cur) % 2 == 1:\\n            if set(str(int_val)) == {\\'9\\'}",
                "codeTag": "Java"
            },
            {
                "id": 1930920,
                "title": "c-solution-a-discussion",
                "content": "Well, the multiplicative inverse for 10 (mod 11) is -1, because 1 = 11 * 1 - 10 * 1, \\nwhich means 1 (mod 11) = (0) (mod 11) - 1 * 10 (mod 11)\\nso, 1 = -1 * (10) (mod 11)\\nso, 10^-1 = -1 (#_#)/\\n\\nTherefore, for 8-digit palindrome, the equation of summation of ai(10^(7-i) + 10^i) can be replaced by -1 (mod 11)... skip all those 8-digit palindrome...\\n\\n... and in here, there is a way to check primality:\\n1. if n == 1, not prime\\n2. else if n < 4, prime\\n3. else if n % 2 == 0, not prime...\\n4. else if n < 9, prime\\n5. else if n % 3 == 0, not prime...\\n6. else\\n7. set f as next prime after 2, 3 = 5, upper bound = sqrt(n), while f <= upper bound do,\\n\\t8. if n % f == 0, there exist a factor, nope\\n\\t9. if n % (f + 2) == 0, nope\\n\\t10. f += 6 (so, all the multiples of 2, 3 = ignore)\\n\\nSo, that\\'s it...\\n\\n```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```\\n*Side-notes: I always feel like I cannot do mathy problems, it always sounds like an act of logical thinking only... the ability to connecting the dots, connecting different pieces of information together is important... that means \\'talent\\' right... the faster you can think, more talented you are right... yea, in this regard, I am average (or slightly below average). Nonetheless, I enjoyed my time doing all these stuff        \\\\\\\\(^_^)/*",
                "solutionTags": [],
                "code": "```cpp\\ntypedef long long int lld;\\n\\nclass Solution {\\npublic:\\n    lld revI(int v) {\\n        lld val = 0;\\n        while (v > 0) {\\n            val *= 10;\\n            val += v % 10;\\n            v /= 10;\\n        }\\n        return val;\\n    }\\n    \\n    bool isP(int v) {\\n        if (v == 1)\\n            return false;\\n        if (v < 4)\\n            return true;\\n        if ((v % 2) == 0)\\n            return false;\\n        if (v < 9)\\n            return true;\\n        if ((v % 3) == 0)\\n            return false;\\n        else {\\n            int r = sqrt(v);\\n            int f = 5;\\n            while (f <= r) {\\n                if ((v % f) == 0)\\n                    return false;\\n                if ((v % (f + 2)) == 0)\\n                    return false;\\n                f = f + 6;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    // well, precompute = time-consuming\\n    int primePalindrome(int n) {\\n        while (1) {\\n            if ((lld)n == (lld)revI(n) && isP(n)) {\\n                return n;\\n            }\\n            n++;\\n            if (10000000 < n && n <= 99999999) {\\n                n = 100000000;  // just skip to 9 digits.\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921422,
                "title": "python3-brute-force",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if n <= 2:\\n            return 2\\n        if n <= 3:\\n            return 3\\n        if n <= 5:\\n            return 5\\n        if n <= 7:\\n            return 7\\n        if n <= 11:\\n            return 11\\n        string = str(n)\\n        length = len(string)\\n        \\n        low = 10 ** (length // 2)\\n        for i in range(low, 2 * 10**4 + 1):\\n            string = str(i)\\n            reversestring = string[:len(string) - 1]\\n            reversestring = reversestring[::-1]\\n            newstring = string + reversestring\\n            newnumber = int(newstring)\\n            \\n            if newnumber >= n and self.isPrime(newnumber):\\n                return newnumber\\n            \\n        return -1\\n    \\n    \\n    def isPrime(self,number):\\n        if number % 2 == 0:\\n            return number == 2\\n        for i in range(3, int(sqrt(number)) + 1, 2):\\n            if number % i == 0:\\n                return False\\n            \\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 1830732,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def nextPalindrome(self,N):\\n        num = [int(x) for x in str(N)]\\n        n = len(num)\\n        mid = n//2\\n        i = mid-1\\n        j = mid+1 if n%2 else mid\\n        leftsmaller = False\\n        while i>=0 and num[i] == num[j]:\\n            i-=1\\n            j+=1\\n        if i<0 or num[i] < num[j]:leftsmaller = True\\n        while i>=0:\\n            num[j] = num[i]\\n            i-=1\\n            j+=1\\n        if leftsmaller == True:\\n            i = mid-1\\n            carry=1\\n            if n%2==0:\\n                j = mid\\n            else:\\n                num[mid] += 1\\n                carry = 1 if num[mid] == 10 else 0\\n                num[mid]%=10\\n                j = mid+1\\n            while i>=0:\\n                if carry==0:break\\n                num[i]+=carry\\n                carry = 1 if num[i]==10 else 0\\n                num[i]%=10\\n                num[j]=num[i]\\n                i-=1\\n                j+=1\\n        if num[0] == 0:\\n            num.insert(0,1)\\n            num[-1] = 1\\n        ans = 0\\n        for i in num:ans = ans*10+i\\n        return ans\\n            \\n    def primePalindrome(self, N: int) -> int:\\n        N=N-1\\n        while True:\\n            N = self.nextPalindrome(N)\\n            lt = int(N**0.5)+1\\n            if N==1:continue\\n            flag = True\\n            for i in range(2,lt):\\n                if N%i == 0:\\n                    flag = False\\n                    break\\n            if flag:return N\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764561,
                "title": "c-solution-prime-palindrome",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    bool isPrime(int N) {\\n    if (N < 2) return false;\\n    int R = (int)sqrt(N);\\n    for (int d = 2; d <= R; ++d)\\n        if (N % d == 0) return false;\\n    return true;\\n    }\\n\\npublic:\\n    int reverse(int N) {\\n    int ans = 0;\\n    while (N > 0) {\\n        ans = 10 * ans + (N % 10);\\n           N /= 10;\\n        }\\n    return ans;\\n    }\\npublic:\\n    int primePalindrome(int n) {\\n        while (true) {\\n            if (n == reverse(n) && isPrime(n))\\n                return n;\\n            n++;\\n            \\n            // Any even length palindrome must be divisble by 11\\n            // so we will skip numbers N = [10,000,000, 99,999,999]\\n            if (10000000 < n && n < 100000000)\\n                n = 100000000;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704938,
                "title": "simple-solution-c",
                "content": "# Following is my approach :\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```\\n#  Please upvote",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrime(long long x){\\n        if(x==0||x==1)\\n            return false;\\n        if(x==2||x==3)\\n            return true;\\n        if(x%2==0||x%3==0)\\n            return false;\\n        for(long long i=5;i*i<=x;i=i+6){\\n            if(x%i==0||x%(i+2)==0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool pal(long long x){\\n        long long num=0;\\n        long long n=x;\\n        while(n){\\n        num=num*10+(n%10);\\n            n=n/10;\\n        }\\n        if(x==num)\\n            return true;\\n        else\\n            return false;\\n    }\\n    \\n    int primePalindrome(int n) {\\n        if(n>9989899)\\n            return 100030001;\\n        for(long long i=n;;i++){\\n            if(pal(i)&&isPrime(i)){\\n                return i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694137,
                "title": "c-simple-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int isPrime(int n){\\n        if(n<=1)\\n            return 0;\\n        for(int i=2;i<=sqrt(n);i++){\\n            if(n%i==0)\\n                return 0;//means n is not prime\\n        }\\n        return 1;//means n is prime\\n    }\\n    int reverse(int n){\\n        long long rev1=0;\\n        while(n>0){\\n            int a=n%10;\\n            // if(rev1>INT_MAX/10||rev1<INT_MIN/10)\\n            //     return 0;\\n            rev1=rev1*10+a;\\n            n/=10;\\n        }\\n        return rev1;\\n    }\\n    int isPalindrome(int n){\\n        return n==reverse(n);\\n    }\\n    int primePalindrome(int n) {\\n        if (1e7 <= n and n <= 1e8)\\n            n = 100030001;\\n        // There is no prime palindrome of length 8. (because abcddcba is always a multiple of 11) and the smallest prime palindrome greater than or equal to 1e8 is 100030001.\\n        while(true){\\n            while(isPalindrome(n)==false)\\n                n++;\\n            \\n            \\n                if(isPrime(n))\\n                    return n;\\n            n++;\\n            \\n            \\n        }\\n        //return n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646496,
                "title": "0ms-c-faster-than-100",
                "content": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    vector<int> prime{\\n2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001\\n};\\n    \\n\\n    public:\\n    \\n    int primePalindrome(int n) {\\n        \\n        \\n        int idx = lower_bound(prime.begin() , prime.end() , n) - prime.begin();\\n        return prime[idx];\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1546567,
                "title": "easy-java-solution",
                "content": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int n) {\\n         boolean flag=false;\\n        while(flag==false){\\n\\n            if(isPalindrome(n)){\\n\\n                if(isPrime(n)){\\n                    flag=true;\\n                    return n;\\n                }\\n            }\\n            else\\n                flag=false;\\n                n++;\\n        }\\n\\n        return n;\\n    }\\n      public static boolean isPrime(int n){\\n        int count=0;\\n        for(int i=1;i<=n;i++){\\n\\n            if(n%i==0)count++;\\n        }\\n\\n        return count==2;\\n    }  \\n     public static boolean isPalindrome(int n) {\\n        int rev = 0;\\n        int temp=n;\\n        while (temp > 0){\\n           rev = rev * 10 + temp % 10;\\n            temp = temp / 10;\\n    }\\n        return rev==n;\\n    }   \\n        \\n        \\n        \\n        \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1522120,
                "title": "table-generation-concept",
                "content": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nOnly One time calculating the entire table and then its log(n).\\n\\nvector<int> V;\\nbool flag = false;\\nclass Solution {\\npublic:\\n \\nbool isPrime(int num){\\n     if(num<=3) return num>1;\\n     if(num % 2 == 0 || num % 3 == 0) return false;\\n     int i = 5;\\n     while(i*i <=num){\\n           if(num % i == 0 || num % (i+2) == 0) return false;\\n           i += 6;\\n     }\\n     return true;\\n}\\n    \\n    \\nvoid gen(string s,int i,bool flag,string t=\"\"){\\n    \\n     if(i == s.size()){\\n           int i = 0;\\n           while(i<s.size() && t[i]==\\'0\\')\\n                  i++;\\n\\n           t =string(t.begin()+i,t.end());\\n           string tr= t;\\n           reverse(tr.begin(),tr.end());\\n           \\n            if(isPrime(atoi((t + tr).c_str()))){\\n                  V.push_back(atoi((t + tr).c_str()));\\n            }\\n\\n           for(int i = 0;i<=9;i++)\\n            if(isPrime(atoi((t + to_string(i) + tr).c_str())))\\n                  V.push_back(atoi((t + to_string(i) + tr).c_str()));\\n\\n           return;\\n     }\\n\\n     int limit  = flag ? (s[i]-\\'0\\'):9;\\n     for(int num = 0;num<=limit;num++){\\n         flag = ( limit!=9 && num ==limit);\\n         t += to_string(num);\\n         gen(s,i+1,flag,t);\\n         t.pop_back();\\n     }\\n}\\n      \\n    int primePalindrome(int n) {\\n        if(!flag){\\n            gen(\"2001\",0,true);\\n            flag = true;\\n        }   \\n        return *(lower_bound(V.begin(),V.end(),n));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488677,
                "title": "python-3-brute-force-math-pruning-explanation",
                "content": "### Explanation\\n- Filtering out palindrome is very simple, but instead of filtering, we need to make up palindrome in order, so that we don\\'t waste on trying definitely useless numbers.\\n\\t- Make sure odd digits palindrome and even digits palindrome are both included.\\n- Other than making up palindrome, we can use **math** to filter values, below are not prime for sure\\n\\t- Have factor `5`: `5xxx5`, `5xx5`, everything start with `5`\\n\\t- Have factor `2`: `2xx2`, `4xx4`, `6xx6`, `8xx8` everything starts with `2, 4, 6, 8`\\n### Implementation\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        def is_prime(n):\\n            if n == 1: return False\\n            for i in range(2, int(n**0.5)+1):\\n                if n % i == 0: return False\\n            return True                \\n        \\n        n_str = str(n)\\n        l = len(n_str)        \\n        for k in range(max(0, l//2-1), 5):\\n            for i in range(10**k, 10**(k+1)):                            # odd length\\n                i_str = str(i)\\n                if k > 0 and i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue # pruning\\n                cur = i_str + i_str[-2::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n                \\n            for i in range(10**k, 10**(k+1)):                            # even length\\n                i_str = str(i)\\n                if i_str[0] in [\\'2\\',\\'4\\',\\'5\\',\\'6\\',\\'8\\']: continue           # pruning\\n                cur = i_str + i_str[::-1]\\n                cur_int = int(cur)\\n                if cur_int >= n and is_prime(cur_int): \\n                    return cur_int\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458153,
                "title": "python3-brute-force",
                "content": "\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        if 8 <= n <= 11: return 11 # edge case \\n        \\n        def fn(n): \\n            \"\"\"Return next palindromic number greater than x.\"\"\"\\n            digits = [int(x) for x in str(n)]\\n            for i in reversed(range(len(digits)//2+1)): \\n                if digits[i] < 9: break \\n            else: return 10*n + 11\\n            digits[i] = digits[~i] = digits[i] + 1\\n            for ii in range(i): \\n                digits[~ii] = digits[ii]\\n            for ii in range(i+1, len(digits)//2+1): \\n                digits[ii] = digits[~ii] = 0\\n            return int(\"\".join(map(str, digits)))\\n        \\n        def isprime(x): \\n            \"\"\"Return True if x is prime.\"\"\"\\n            if x <= 1: return False \\n            if x % 2 == 0: return x == 2\\n            for k in range(3, int(sqrt(x))+1, 2): \\n                if x % k == 0: return False\\n            return True \\n        \\n        nn = n \\n        k = 0\\n        while nn: \\n            nn //= 10\\n            k += 1\\n            \\n        if not k&1: n = 10**k + 1\\n        elif str(n) != str(n)[::-1]: n = fn(n)\\n        \\n        while True: \\n            if isprime(n): return n\\n            n = fn(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1345879,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool ispal(int n){\\n        string s=to_string(n);\\n        int low=0,high=s.length()-1;\\n        while(low<high){\\n            if(s[low]!=s[high]){\\n                return false;\\n            }\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    bool isPrime(int n) {   \\n    if (n <= 1) return false;\\n    for (int i = 2; i <= sqrt(n); i++)\\n        if (n % i == 0)\\n            return false;\\n    return true;\\n}\\n    \\n    int primePalindrome(int n) {\\n        for(int i=n;i<10000000;i++){\\n            if(isPrime(i) && ispal(i)){\\n                return i;\\n            }\\n        }\\n        return 100030001;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308204,
                "title": "find-next-palindrome",
                "content": "The idea is simple, for given n, we first find a palindrom p greater than n, then we check whether it\\'s prime, if it\\'s a prime, we get the result, otherwise, we find next palindrome greater than p\\n\\nfor example\\n```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isPrime(n):\\n            if n<=2 or n&1==0:\\n                return n==2\\n            for i in range(3, int(n**0.5)+1, 2):\\n                if n%i==0:return False\\n            return True\\n        \\n        def nextPalindrome(n):\\n            s = str(n)\\n            l = len(s)\\n            if n < 10:\\n                return n+1\\n            # 123 12+1 ->131\\n\\t\\t\\t# if left half is smaller than right half, increase left help by one\\n            if s[:l//2]<=s[(l+1)//2:]:\\n                head = str(int(s[:(l+1)//2])+1)\\n            else:\\n                head = s[:(l+1)//2]\\n            ans = head+head[:l//2][::-1]\\n\\t\\t\\t# if the palindrom is the same, increase left halp by 1\\n            if ans==str(n):\\n                head = str(int(s[:(l+1)//2])+1)\\n                ans = head+head[:l//2][::-1]\\n            return int(ans)\\n\\t\\t# in case N is already a result, we start with N-1\\n        n = N-1\\n        while True:\\n            p = nextPalindrome(n)\\n            if isPrime(p):\\n                return p\\n            else:\\n                n = p\\n",
                "solutionTags": [],
                "code": "```python\\nn = 723\\nthen it will iterately generate following palindromes until getting one prime palindrome\\n747   # first palindrome greater than n\\n757 # second palindrome greater than n, and this is also a prime number\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1306489,
                "title": "js-faster-than-98",
                "content": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} N\\n * @return {number}\\n */\\nvar primePalindrome = function(N) {\\n    if (N <= 2) return 2\\n    if (N <= 3)  return 3\\n    if (N <= 5) return 5\\n    if (N <= 7) return 7\\n    \\n    \\n    const tails = [1, 3, 7, 9]\\n    function isPrime(num) {\\n        for (let modMe = 2, sq = Math.sqrt(num);\\n            modMe <= sq; modMe++) {\\n            if (num % modMe === 0)  return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    \\n    for (let digitC = Math.max(String(N).length, 2); ; digitC++) {\\n        const halfC = digitC >> 1\\n        const isOdd = Boolean(digitC & 1)\\n        const anyC = -1 + halfC\\n        const valLimit = 10 ** anyC\\n        \\n        let midFrom = 0, midTo = 9\\n        if (!isOdd) {\\n            midTo = 0\\n        }\\n        \\n        for (const tail of tails.values()) {\\n            for (let val = 0; val < valLimit; val++) {\\n                let valStr = String(val)\\n                valStr = valStr.padStart(anyC, \\'0\\')\\n                const sub = [...valStr]\\n                const subReverse = [...sub].reverse()\\n                \\n                for (let mid = midFrom; mid <= midTo; mid++) {\\n                    const chs = [tail]\\n                    \\n                    if (anyC !== 0) chs.push(...sub)\\n                    if (isOdd)  chs.push(mid)\\n                    if (anyC !== 0) chs.push(...subReverse)\\n                    chs.push(tail)\\n                    \\n                    const str = chs.join(\\'\\')\\n                    const num = Number(str)\\n                    if (num < N)    continue\\n                    \\n                    if (isPrime(num)) return num\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238364,
                "title": "javascript-faster-than-100",
                "content": "Although the memory efficiency could be better, but the speed was very good. Here it is. If there is any room for improvement, please comment below\\n\\n```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {number}\\n */\\nvar primePalindrome = function(n) {\\n    \\n    while (true){\\n        let str = String(n)\\n        if (String(n).length % 2 == 0 && n > 11){\\n\\t\\t\\tn = Math.pow(10, Math.ceil(Math.log10(n+1)))\\n\\t\\t\\t// or n = 1 + Array(str.length).fill(0).join(\"\")\\n            continue\\n        }\\n        if (!isPalindrome(str)) {\\n            n++\\n            continue\\n        }\\n        if (isPrime(n)) return n\\n        n++\\n    }\\n    \\n};\\n\\nfunction isPrime(n){\\n    if (n <= 1) return false\\n    if (n <= 3) return true\\n    if (n % 2 == 0 || n % 3 == 0) return false\\n    \\n    for (let i = 3; i <= Math.floor(Math.sqrt(n)) + 1;i+=2){\\n        if (n % i == 0) return false      \\n    }\\n    return true\\n}\\n\\nfunction isPalindrome(str){\\n    let l = 0, r = str.length-1\\n    while (l < r){\\n        if (str[l] != str[r]) return false\\n        l++\\n        r--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174370,
                "title": "python-3-solution",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        n=N\\n        def prime(n):\\n            if n <= 1:\\n                return False\\n            if n == 2:\\n                return True\\n            if n > 2 and n % 2 == 0:\\n                return False\\n \\n            max_div = math.floor(math.sqrt(n))\\n            for i in range(3, 1 + max_div, 2):\\n                if n % i == 0:\\n                    return False\\n            return True\\n        def reverse(n):\\n            n=str(n)\\n            return (n==n[::-1])\\n        while True:\\n            if prime(n) and reverse(n):\\n                return n\\n                \\n            n+=1\\n            if 10**7 < n < 10**8:\\n                n=10**8\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161034,
                "title": "python3-easy-solution-with-explanation-and-comments-100-faster",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2} is 2 which is palindrome\\n            return 2\\n        \\n        elif N==3:                                                                                  #3 is a prime palindrome\\n            return 3\\n        \\n        elif N==4 or N==5:                                                                          #nearest prime number of N in {4,5} is 5 which is palindrome\\n            return 5\\n        \\n        elif N==6 or N==7:                                                                          #nearest prime number of N in {6,7} is 7 which is palindrome\\n            return 7\\n        \\n        elif N>7 and N<=11:                                                                         #nearest prime number of N greater than 7 is 11 which is palindrome\\n            return 11\\n        \\n        elif N>11 and N<=101:                                                                       #for all two digit numbers greater than 11, and for 100,101\\n            return 101                                                                              #nearest prime palindrome is 101\\n        \\n        start=(N+1)*(N%2==0)+N*(N%2==1)                                                             #prime number must be odd, so start checking from the odd number nearest to N\\n        len_string =len(str(start))\\n        str_N = str(start)\\n        \\n        if str_N==str_N[::-1] and isPrime(start):                                                   #if N or (N+1) is prime, then don\\'t need to check further\\n            return start\\n                \\n        else:    \\n            while(True):\\n                if len_string%2==0:\\n                    start=10**(len_string)                                                          #convert even length starting number to odd length\\n                    str_N=str(start)                                                                #store the string representation of starting number\\n                \\n                if int(str_N[0])%2==0:                                                              #if the first digit is even, then the palindrome will also be even\\n                    start+=10**(len_string-1)                                                       #start from the nearest number whose first digit is odd                                          \\n                    str_N=str(start)\\n                    \\n                if int(str_N[0])==5:                                                                #if the first digit is 5, then the palindrome is divisible by 5\\n                    start=7*(10**(len_string-1))                                                    #the nearest prime palindrome starts with 7                                          \\n                    str_N=str(start)\\n                                                                                                    \\n                str_N = str_N[0:len_string//2]+str_N[len_string//2]+str_N[0:len_string//2][::-1]    #create palindrome closest to starting number\\n                    \\n                if int(str_N)>=N and isPrime(int(str_N)):\\n                    return int(str_N)                                                               #got a palindrome greater than or equal N, return the palindrome\\n                else:\\n                    start=int(str_N[0:len_string//2+1])+1                                           #increase the value of starting floor(len_string//2) digits by one   \\n                    start*=10**(len_string//2)                                                      #append necessary 0\\'s to start and this will be the new starting position\\n                    \\n                    str_N=str(start)                                                                #convert start to string\\n                    len_string=len(str_N)                                                           #store the length",
                "solutionTags": [
                    "Python3"
                ],
                "code": "class Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\'\\'\\'\\n        1. If N<=11, then the result is the first prime number greater than or equal N\\n        2. If 11<N<=101, then the result is 101\\n        3. Otherwise, there are no prime palindromes of even length\\n        4. Let N is a x\\' digit number. If x\\' is even, then set N=10^x\\'. Now N is x=x\\'+1 digit number where x is odd. If x\\' is odd, then don\\'t change N and here x=x\\'.\\n        5. Starting from N, generate palindromes and check if it is prime\\n        6. If not, then set N = value of first floor(x//2) digits + 1, and go back to step 4 and generate new palindromes from new N.\\n        \\'\\'\\'\\n        \\n        def isPrime(n):                             \\n            i=3                                                                                     #don\\'t need to check any even number, so start checking from 3\\n            while i*i<=n:                                                                           #if n is not prime, then it will be divisible by a number at most sqrt(n)\\n                if n%i==0:\\n                    return False                                                                    #has divisor, so not prime\\n                i+=2                                                                                #only check if there are odd divisors, as n is odd\\n                \\n            return True                                                                             #n is prime\\n        \\n        if N==1 or N==2:                                                                            #nearest prime number of N in {1,2}",
                "codeTag": "Java"
            },
            {
                "id": 1158279,
                "title": "swift-236ms",
                "content": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func primePalindrome(_ N: Int) -> Int {\\n        let str = String(N)\\n        var digits = str.count\\n        \\n        if isPrime(N) && isPalindrome(N) {\\n            return N\\n        }\\n        \\n        var found = -1\\n        while found == -1 {\\n            palindromes(digits, N, &found)\\n            digits += 1\\n        }\\n        return found\\n    }\\n    \\n    func isPalindrome(_ num: Int) -> Bool {\\n        let str = String(num)\\n        return str == String(str.reversed())\\n    }\\n    \\n    func isPrime(_ num: Int) -> Bool {\\n        if num == 1 { return false }\\n        var division = 2\\n        while true {\\n            if division * division > num {\\n                // we checked all candidates\\n                return true\\n            }\\n            \\n            if num % division == 0 {\\n                return false\\n            }\\n            division += 1\\n        }\\n        return false\\n    }\\n    \\n    func palindromes(_ digit: Int, _ N: Int, _ found: inout Int) -> [String] {\\n        let nums = (0...9).map { String($0) }\\n        if digit == 0 { return [\"\"] }\\n        if digit == 1 {\\n            for i in 1...9 where i >= N && isPrime(i) {\\n                found = i\\n                break\\n            }\\n            return nums\\n        }\\n        \\n        var results = [String]()\\n        let prev = palindromes(digit-2, N, &found)\\n        \\n        for num in nums {\\n            for val in prev {\\n                let str = num+val+num\\n                results.append(str)\\n                \\n                if num != \"0\", let int_val = Int(str), int_val >= N, isPrime(int_val) {\\n                    found = int_val\\n                    return results\\n                }\\n            }\\n        }\\n        return results\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146586,
                "title": "c-without-generating-prime-numbers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool prime(long n)\\n    {\\n        if(n%2==0)\\n            return 0;\\n        for(long i=3;i*i<=n;i+=2)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        \\n        if(N==3 or N==2 or N==5 or N==7)\\n            return N;\\n        if(N==1) return 2;\\n        if(N==4) return 5;\\n        if(N==6) return 7;\\n        if(N<=11) return 11;\\n            \\n        \\n        string s=to_string(N);\\n        string sn;\\n        int len=s.length();\\n       \\n        sn=s.substr(0,ceil(len/2.0));\\n        int k=len/2;\\n        \\n        \\n        while(1)\\n        {\\n            string temp;\\n            if(sn.length()>k)\\n                temp=sn.substr(0,sn.length()-1);\\n            else\\n                temp=sn;\\n            \\n            reverse(temp.begin(),temp.end());\\n            \\n            long n=stol(sn+temp);\\n            if(prime(n) and n>=N)\\n                return n;\\n            if(sn[sn.length()-1]<57)\\n                sn[sn.length()-1]+=1;\\n            else\\n            {\\n                long l=stoll(sn)+1;\\n                sn=to_string(l);  \\n            }  \\n        }\\n        return 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1136411,
                "title": "simplest-algorithm-but-without-primes-generator",
                "content": "it\\'s working on small range of numbers but i need to complete it with primes generator that got accepted without run time error\\n```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, n: int) -> int:\\n        \\n        primes.append(n)\\n        primes = sorted(primes)\\n\\n        primes.index(n)\\n\\n        return primes[primes.index(n)+1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046663,
                "title": "swift-solution-with-comments",
                "content": "According to one of the 11\\'s divisibility rule, form the alternating sum of the digits.\\nIf the result can be divisible by 11, the original number must be 11\\'s multiple. \\nex. 2486 => 2 - 4 + 8 - 6 = 0 * 11\\n\\nSo we can know: **any palindrome with even number of digits must be divisible by 11**\\nex. abba => a - b + b - a = 0 * 11\\n\\nThat is, any palindrome with even number of digits is not a prime. Then we can skip them.\\n\\n```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc primePalindrome(_ N: Int) -> Int {\\n\\t// edge case (11 is the only prime palindrome with even number of digits)\\n\\tif 8 <= N && N <= 11 { return 11 }\\n\\n\\tvar _N = N\\n\\twhile true {\\n\\t\\tif isPrime(_N) && isPalindrome(String(_N)) { return _N }\\n\\t\\tlet digits = String(_N).count\\n\\t\\t_N = digits % 2 == 0 ? Int(pow(10, Double(digits)) + 1) : _N + 1\\n\\t}\\n}\\n\\nfunc isPrime(_ n: Int) -> Bool {\\n\\tguard n > 1 else { return false }\\n\\tguard n != 2 else { return true }\\n\\tguard n % 2 != 0 else { return false }\\n\\n\\tvar i = 3\\n\\twhile i * i <= n {\\n\\t\\tif n % i == 0 { return false }\\n\\t\\ti += 1\\n\\t}\\n\\treturn true\\n}\\n        \\nfunc isPalindrome(_ s: String) -> Bool {\\n\\treturn s == String(s.reversed())\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037653,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n     if(N==1 ||N==2)\\n         return 2;\\n     \\n    if(N%2==0)\\n        N=N+1;\\n        \\n     while(true){\\n           if( palindrome(N) && prime(N) ){\\n               return N;\\n           } \\n         N+=2;\\n         \\n         if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_001;\\n     }  \\n    }\\n    \\n    \\n    public boolean palindrome(int N){\\n        if(N%10==0 && N!=0)\\n            return false;\\n        \\n        int reverseNumber=0;\\n        int num=N;\\n        while(num>0){\\n            reverseNumber=reverseNumber*10+num%10;\\n            num/=10;    \\n        }\\n        return reverseNumber==N || N== reverseNumber / 10;\\n    }\\n    \\n    \\n    \\n    public boolean prime(int N){\\n        if(N%2==0) return false;\\n        \\n        for(int i=3;i<N/2+1; i+=2)\\n              if(N%i==0)\\n                  return false;\\n          \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028591,
                "title": "java-solution-with-comments",
                "content": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n\\n  public int primePalindrome(int N) {\\n    // Even digits palindrome number is divisible by 11, so they are not prime, exception is 11.\\n    if (8 <= N && N <= 11) return 11;\\n    // Odd digit palindrome number. checking by root.\\n    //  \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n    //   so use endless loop and break once find the answer\\n    for (int r = getInitialRoot(N); ; r++) { // let r start from 1 is okay\\n      String l = String.valueOf(r);\\n      StringBuilder sb = new StringBuilder(l);\\n      for (int index = l.length() - 2; 0 <= index; index--) {\\n        sb.append(l.charAt(index));\\n      }\\n\\n      // odd digits palindrome number\\n      int n = Integer.valueOf(sb.toString());\\n      if (N <= n && isPrime(n)) {\\n        return n;\\n      }\\n    }\\n  }\\n\\n  // \\'1 <= N <= 10^8\\'\\n  // \\'The answer is guaranteed to exist and be less than 2 * 10^8.\\'\\n  //  so use int array is enough\\n  // root of minimum palindrome number of odd digits i\\n  static int[] mRoot = new int[10];\\n\\n  static {\\n    mRoot[1] = 1;\\n    mRoot[3] = 10; // 101\\n    mRoot[5] = 100; // 10001\\n    mRoot[7] = 1000; // 1000001\\n    mRoot[9] = 10000; // 100000001\\n  }\\n\\n  private static int getInitialRoot(int N) {\\n    int l = String.valueOf(N).length();\\n    if ((l & 1) == 0) {\\n      l++;\\n    }\\n    // even N is one of the minimum palindrome number, it could not be prime\\n    return mRoot[l];\\n  }\\n  // assume i is positive integer\\n  public static boolean isPrime(int N) {\\n    if (N < 2) return false;\\n    if (N == 2) return true;\\n    // N > 2\\n    if (N % 2 == 0) return false;\\n    int to = (int) Math.pow(N, 0.5);\\n    for (int i = 3; i <= to; i += 2) {\\n      if (N % i == 0) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1011850,
                "title": "go",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    a := getPaliFromN(N)\\n    for {\\n        if !isPrime(a) {\\n            a = nextPali(a)\\n        } else {\\n            break\\n        }\\n    }\\n    return a\\n}\\n\\nfunc getPaliFromN(n int) int {\\n    a := strconv.Itoa(n)    \\n    b := a[:(len(a) + 1) / 2]\\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        b += string(a[i])\\n    }\\n    m, _ := strconv.Atoi(b)\\n    if m >= n {\\n        return m\\n    } else {\\n        return nextPali(m)\\n    }\\n}\\n\\nfunc nextPali(n int) int {\\n    a := strconv.Itoa(n)\\n    b := a[:(len(a) + 1) / 2]\\n    bnum, _ := strconv.Atoi(b)\\n    bnum++\\n    bs := strconv.Itoa(bnum)\\n    if len(bs) != len(b) {\\n        bs := \"1\"\\n        for i := 0; i < len(a) - 1; i++ {\\n            bs += \"0\"\\n        }\\n        bs += \"1\"\\n        res, _ := strconv.Atoi(bs)\\n        return res\\n    }\\n    \\n    for i := len(a) / 2 - 1; i >= 0; i-- {\\n        bs += string(bs[i])\\n    }\\n    res, _ := strconv.Atoi(bs)\\n    return res\\n}\\n\\nfunc isPrime(n int) bool {\\n    if n <= 1 {\\n        return false\\n    }\\n    for i := 2; i * i <= n; i++ {\\n        if n % i == 0 {\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 995044,
                "title": "python3-find-palindromes-first-and-then-check-if-it-s-prime",
                "content": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    primes = [2]\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        # Find palindrome number first, then check it is a prime number.\\n        \\n        # Elimiate special case 2 and 11.\\n        if N < 3: return 2\\n        elif 7 < N <= 11: return 11\\n\\n        # Record the number of digits.\\n        num, digitLen = N, 0\\n        while num > 0:\\n            num = num // 10\\n            digitLen += 1\\n\\n        # Even length palindromes are divisible by 11,\\n        # it will be non-prime number except for 11 itself.\\n        if digitLen % 2 == 0:\\n            return self.primePalindrome(10**(digitLen))\\n        else:\\n            halfDigitLen = digitLen//2\\n            # All number which length is one, is palindrome number.\\n            if halfDigitLen == 0:\\n                for num in range(N, 10):\\n                    if self.isPrime(num):\\n                        return num\\n            # If length is bigger than one.\\n            # Split the palindrome number into three part, left, middle, right\\n            # We need to find palindrome number in ascending way.\\n            # So first decide left side number then middle number.(right number don\\'t matter if it\\'s palindrome number)\\n            else:\\n                # first digit of left side number has to be 1, otherwise it would not be the same number of digits.\\n                # If 7 digits number => left side number is 100 ~ 999\\n                leftSideNum = 10**(halfDigitLen-1)\\n                while leftSideNum < 10**halfDigitLen:\\n\\n                    # Caculate right side number\\n                    rightSideNum = 0\\n                    for digit in range(halfDigitLen):\\n                        rightSideNum += (leftSideNum%(10**(digit+1))//(10**digit))*(10**(halfDigitLen-digit-1))\\n                    \\n                    # middle number is 0 ~ 9\\n                    for middleNum in range(10):\\n                        num = rightSideNum + leftSideNum*(10**(halfDigitLen+1)) + middleNum*(10**halfDigitLen)\\n                        if num >= N:\\n                            if self.isPrime(num): \\n                                return num\\n\\n                    leftSideNum += 1\\n                    # The while statement just to elimiate last digit is multiple of 2 or 5\\n                    # which definitely not the prime number.\\n                    firstNum = leftSideNum//(10**(halfDigitLen-1))\\n                    while firstNum % 2 == 0 or firstNum % 5 == 0:\\n                        leftSideNum += 10**(halfDigitLen-1)\\n                        firstNum = leftSideNum//(10**(halfDigitLen-1))\\n\\n                # If can not find prime with current length \\n                # then add 2 to length. 999 -> 10000 (3->5)\\n                return self.primePalindrome(10**(digitLen+1))\\n\\n    def isPrime(self, x: int) -> bool:\\n        notEnoughPrime = True\\n        for prime in self.primes:\\n            if prime*prime > x: \\n                notEnoughPrime = False\\n                break\\n            if x % prime == 0: \\n                return False\\n            \\n        if notEnoughPrime:\\n            num = self.primes[-1] + 1\\n            while num*num <= x:\\n                if self.isPrime(num):\\n                    self.primes.append(num)\\n                num += 1\\n            for prime in self.primes:\\n                if x % prime == 0: \\n                    return False\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990925,
                "title": "time-limit-exceeded",
                "content": "The following code runs fine in my pc with build time of around 700-900ms but leetcode says time limit exceeded.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        int result = N;\\n        for(int i=N; i>=N; i++){\\n            //System.out.print(i);\\n            if(isPrime(i) && isPalindrome(i)){\\n                //System.out.println(\"   \"+isPrime(i)+\"   \"+isPalindrome(i));\\n                result = i;\\n                break;\\n            }\\n        }\\n        return result;\\n    }\\n    static boolean isPrime(int N){\\n        boolean isPrime = true;\\n        if(N==2) return true;\\n        else if(N==1 || N==0) return false;\\n        for(int i=2; i<=Math.ceil((Math.sqrt(N))); i++){\\n            if(N%i == 0){\\n                isPrime = false;\\n                break;\\n            }\\n        }\\n        return isPrime;\\n    }\\n\\n    static boolean isPalindrome(int num){\\n        String numText = String.valueOf(num);\\n        boolean isPalindrome = true;\\n        for(int i=0, j=numText.length()-1; i<numText.length(); i++, j--){\\n            if(numText.charAt(i) == numText.charAt(j)){\\n                continue;\\n            }else{\\n                isPalindrome = false;\\n                break;\\n            }\\n        }\\n        return isPalindrome;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886996,
                "title": "fermat-s-little-theorem-and-euler-theorem",
                "content": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int binPow(int num, int p, int m){\\n        long long int ans=1;\\n        long long int n=num;\\n        while (p){\\n            if (p&1) ans=((1LL*ans%m)*(n%m))%m;\\n            n = ((1LL*n%m)*(n%m))%m;\\n            p/=2;\\n        }\\n        return ans;\\n    }\\n    bool fermatPrime(int p){\\n        if (p<=1) return false;\\n        if (p==2 || p==3 || p==5 or p==7 or p==11) return true;\\n        for (int i=1;i<=5;i++){\\n            int a=2+rand()%(p-3);\\n            if (binPow(a,p-1,p)!=1) return false;\\n        }\\n        return true;\\n    }\\n    bool pal(int n){\\n        int num=n;\\n        int ret=0;\\n        while (num){\\n            int rem=num%10;\\n            ret=ret*10+rem;\\n            num/=10;\\n        }\\n        return ret==n;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        for (int i=N;i<=1e9;i++){\\n            if (pal(i) and fermatPrime(i)) return i;\\n            if (i>1e7 and i<1e8) i=1e8;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881250,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        if(reverse(N) == N && isPrime(N))\\n            return N;\\n        int next = N;\\n        while (true) {\\n            String nextString = findNext(next);\\n            next = Integer.parseInt(nextString);\\n            if(next == 11)\\n                return next;\\n            if(nextString.length()%2 == 0){\\n                int length = nextString.length();\\n                nextString = \"1\";\\n                while(length-- > 0)\\n                    nextString += \"0\";\\n                next = Integer.parseInt(nextString);\\n            }\\n            else if(isPrime(next))\\n                return next;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n    private String findNext(int num){\\n        String s = Integer.toString(num);\\n        char [] n = s.toCharArray();\\n        int start = 0;\\n        int end = n.length - 1;\\n        boolean reverse = true;\\n        while(start <= end){\\n            if(n[start] < n[end]){\\n                n[end] = n[start];\\n                reverse = true;\\n            }\\n            else if(n[start] > n[end]){\\n                n[end] = n[start];\\n                reverse = false;\\n            }\\n            start++;\\n            end --;\\n        }\\n        if(!reverse)\\n            return new String(n);\\n        start--;\\n        end++;\\n        while(start >=0 && n[start] == \\'9\\'){\\n            n[start] = \\'0\\';\\n            n[end] = \\'0\\';\\n            start--;\\n            end++;\\n        }\\n        if(start < 0){\\n            n[end-1] = \\'1\\';\\n            return \"1\"+new String(n);\\n        }\\n        else{\\n            char temp  = (char)(n[start] +1);\\n            n[start] = temp;\\n            n[end] = temp;\\n            return new String(n);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868157,
                "title": "python-creating-palindrome-list",
                "content": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        def isprime(x):\\n            if x <= 1:\\n                return False\\n            i = 2\\n            while i*i <= x:\\n                if x%i == 0:\\n                    return False\\n                i += 1\\n            return True\\n        \\n        pals = [[] for i in range(9)]\\n        pals[0] = [\\'0\\',\\'1\\',\\'2\\',\\'3\\',\\'4\\',\\'5\\',\\'6\\',\\'7\\',\\'8\\',\\'9\\']\\n        pals[1] =[\\'00\\',\\'11\\',\\'22\\',\\'33\\',\\'44\\',\\'55\\',\\'66\\',\\'77\\',\\'88\\',\\'99\\']\\n        for i in range(2,8):\\n            pals[i] = [x[0]+y+x[1] for y in pals[i-2] for x in pals[1]]\\n        pals[8] = [\\'1\\'+y+\\'1\\' for y in pals[6]]\\n        nums = sorted(int(x) for y in pals for x in y)\\n        for x in nums[bisect.bisect_left(nums,N):]:\\n            if isprime(x):\\n                return(x)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803639,
                "title": "go-0ms-solution",
                "content": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc primePalindrome(N int) int {\\n\\tnumberInStr := strconv.Itoa(N)\\n\\tnumberInBytes := []byte(numberInStr)\\n\\tfor i := 0; i < len(numberInBytes)/2; i++ {\\n\\t\\tnumberInBytes[len(numberInBytes)-1-i] = numberInBytes[i]\\n\\t}\\n\\tif string(numberInBytes) < numberInStr {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tfor !isPrime(string(numberInBytes)) {\\n\\t\\tnumberInBytes = next(numberInBytes)\\n\\t}\\n\\tv, _ := strconv.Atoi(string(numberInBytes))\\n\\treturn v\\n}\\n\\nfunc next(number []byte) []byte {\\n\\tm := len(number) / 2\\n\\tif len(number)%2 == 0 {\\n\\t\\tm--\\n\\t}\\n\\tfor m >= 0 {\\n\\t\\tif number[m] != \\'9\\' {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tm--\\n\\t}\\n\\tif m < 0 {\\n\\t\\tnumber[0] = \\'1\\'\\n\\t\\tfor i := 1; i < len(number); i++ {\\n\\t\\t\\tnumber[i] = \\'0\\'\\n\\t\\t}\\n\\t\\tnumber = append(number, \\'1\\')\\n\\t\\treturn number\\n\\t}\\n\\tnumber[m]++\\n\\tif len(number)-1-m != m {\\n\\t\\tnumber[len(number)-1-m]++\\n\\t}\\n\\tfor i := m + 1; i < len(number)/2; i++ {\\n\\t\\tnumber[i] = \\'0\\'\\n\\t\\tnumber[len(number)-1-i] = \\'0\\'\\n\\t}\\n\\tif len(number)%2 != 0 {\\n\\t\\tif m != len(number)/2 {\\n\\t\\t\\tnumber[len(number)/2] = \\'0\\'\\n\\t\\t}\\n\\t}\\n\\treturn number\\n}\\n\\nfunc isPrime(v string) bool {\\n\\tif v == \"1\" {\\n\\t\\treturn false\\n\\t}\\n\\tif v == \"2\" {\\n\\t\\treturn true\\n\\t}\\n\\tvi, _ := strconv.Atoi(v)\\n\\tif vi%2 == 0 {\\n\\t\\treturn false\\n\\t}\\n\\tm := int(math.Sqrt(float64(vi)))\\n\\tfor i := 3; i <= m; i += 2 {\\n\\t\\tif vi%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792259,
                "title": "get-the-set-of-palindromes-first-and-filter-out-non-prime-and-smaller-ones",
                "content": "With one optimization that cuts the search space by removing the even palindrome\\n```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N) {\\n        if (N <= 11) {\\n            for (int i = 2; i <= 11; ++i) {\\n                if (i >= N && (i == 2 || i == 3 || i == 5 || i == 7 || i == 11)) {\\n                    return i;\\n                }\\n            }\\n        }\\n        for (int i = 10; i < 100000; ++i) {\\n            string leftAndMid = to_string(i);\\n            string right = to_string(i / 10);\\n            right = string(rbegin(right), rend(right));\\n            int palindrome = stoi(leftAndMid + right);\\n            if (palindrome >= N && isPrime(palindrome)) {\\n                return palindrome;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nprivate:\\n    bool isPrime(int palindrome) {\\n        for (int i = 2; i <= int(sqrt(palindrome)); ++i) {\\n            if (palindrome % i == 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 774233,
                "title": "go-100-8ms",
                "content": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n    if N<=2{\\n        return 2\\n    }\\n    number:=N\\n    for {\\n        adjustNumber(&number)\\n        if isPalindrome(number) && isPrime(number){\\n           return number\\n        }\\n        number+=2\\n    }\\n    return -1\\n}\\n\\nfunc adjustNumber(number *int){\\n    /* \\n\\t   Even digits palindrome property:  Always divisible by 11\\n\\t   \\n\\t   1st digit(odd th) == last digit(even th)\\n\\t   2nd digit(even th) == last 2nd digit(odd th)\\n\\t   \\n\\t   11 Divisibility Test : <https://www.math.hmc.edu/funfacts>.\\n\\t   \\n\\t   Take the alternating sum of the digits in the number, read from left to right. \\n\\t   If that is divisible by  11, so is the original number\\n\\t   \\n\\t   22 --> 2-2 = 0\\n\\t   1221 --> 1-2+2-1 = 0 \\n\\t   134431 --> 1-3+4-4+3-1=0\\n\\t   \\n\\t   Now since 11 is a prime number itself ; it will qualify but others will not\\n\\t*/\\n\\t\\n\\t// 11 divisibility test and adjustment\\n    inputNumber:=*number\\n    digits:=0\\n    for inputNumber>0{\\n        digits++\\n        inputNumber/=10\\n    }\\n    if digits%2==0 && *number>11{\\n        newNumber:=1\\n        for i:=0;i<digits;i++{\\n            newNumber*=10\\n        }\\n        *number=newNumber+1\\n    }\\n    // 2 divisibility test and adjustment\\n    if *number%2==0{\\n        *number++\\n    }\\n\\t\\n\\t//Note : Can probably add tests and adjustments for other prime numbers but need draw a line somewhere\\n}\\n\\nfunc isPrime(number int)bool{\\n    root:=int(math.Sqrt(float64(number)))\\n    for i:=2; i<=root;i++{\\n        if number%i==0{\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc isPalindrome(number int)bool{\\n    s:=strconv.Itoa(number)\\n    i:=0\\n    j:=len(s)-1\\n    for i<j{\\n        if s[i]!=s[j]{\\n            return false\\n        }\\n        i++\\n        j--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 770493,
                "title": "c-solution-using-next-palindrome-method",
                "content": "Idea is to generate the next smallest palindrome in O(length(N)) time and then check if it is a prime number or not.\\n\\n```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int nextpalin(int t)\\n    {\\n        vector<int> nums;\\n        bool an=true;\\n        while(t)\\n        {\\n            nums.push_back(t%10);\\n            t/=10;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]!=9)\\n            {\\n                an=false;\\n                break;\\n            }\\n        }\\n        if(an)\\n        {\\n            string temp=\"1\";\\n            for(int i=0;i<nums.size()-1;i++)\\n                temp+=\\'0\\';\\n            temp+=\\'1\\';\\n            return stoi(temp);\\n        }\\n        reverse(nums.begin(),nums.end());\\n        int size=nums.size();\\n        int mid=size/2;\\n        int i=mid-1,j;\\n        if(size%2!=0)\\n        j=mid+1;\\n        else\\n        j=mid;\\n        while(i>=0 and j<size and nums[i]==nums[j])\\n        {\\n            i--;\\n            j++;\\n        }\\n        if(i<0 or nums[i]<nums[j])\\n        {\\n            int i=mid-1,j,k;\\n            int carry=1;\\n            if(size%2)\\n            {\\n                k=size/2;\\n                nums[k]+=carry;\\n                carry=nums[k]/10;\\n                nums[k]%=10;\\n                j=mid+1;\\n            }\\n            else\\n                j=mid;\\n            while (i >= 0) \\n            { \\n            nums[i] += carry; \\n            carry = nums[i] / 10; \\n            nums[i] %= 10; \\n            nums[j++] = nums[i--]; \\n            } \\n        }\\n        else\\n        {\\n        while(i>=0)\\n        nums[j++]=nums[i--];\\n        }\\n        string ans=\"\";\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans+=to_string(nums[i]);\\n        }\\n        return stoi(ans);\\n    }\\npublic:\\n    bool ispalin(int num)\\n    {\\n        string g=to_string(num);\\n        int l=0,h=g.length()-1;\\n        while(l<h)\\n        {\\n            if(g[l]!=g[h])\\n                return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\npublic:\\n    bool isprime(int num)\\n    {\\n        if(num==1)return false;\\n        int s=sqrt(num);\\n        for(int i=2;i<=s;i++)\\n        {\\n            if(num%i==0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(ispalin(N) and isprime(N))\\n            return N;\\n        int ans=-1;\\n        while(true)\\n        {   \\n            int np=nextpalin(N);\\n            // cout<<\"Next palindrome \"<<np<<endl;\\n            if(isprime(np))\\n            {\\n                ans=np;\\n                break;\\n            }\\n            N=np;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 748585,
                "title": "scalable-and-comprehensible-solution-in-python-construct-palindrome",
                "content": "This solution is constructing palindrome, checking whether it is prime, and tail recurse with 1 more digit. Skip numbers with even digits, because lee215 proved that all palindrome with even length is multiple of 11. This is scalable when the number larger than 10 ** 8, as it iterate only on palindromes.\\n\\n```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrime(self, n: int) -> bool:\\n        return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5 + 1)))\\n    \\n    def primePalindrome(self, N: int) -> int:\\n        length = len(strN := str(N))\\n        firstHalf = strN[: int((length + 1) / 2)]\\n        firstHalfLength = len(firstHalf)\\n                \\n        # All palindrome with even length is multiple of 11\\n        if 8 <= N <= 11:\\n            return 11\\n        if length > 2 and length % 2 == 0:\\n            return self.primePalindrome(10 ** length)\\n        \\n        while len(firstHalf) <= firstHalfLength:\\n            pali = int(firstHalf + firstHalf[-2::-1]) # construct palindrome\\n            if pali >= N and self.isPrime(pali):\\n                return pali\\n            firstHalf = str(int(firstHalf) + 1)\\n        else:\\n            return self.primePalindrome(10 ** length)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744904,
                "title": "standard-java-solution",
                "content": "### Theory\\nSo apparently for some reason we can exclude 8 digit numbers. We can start from N, and scan our way up to a valid palindrome. Its important we check for palindrome competency first, vs doing the heavy lifting to determine if the candidate number is prime.\\n\\n### Solution\\n```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int primePalindrome(int N) {\\n        while (true) {\\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n            if (10000000 < N && N < 100000000) N = 100000000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        for (int i = 2; i * i <= N; i++) {\\n            if (N % i == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int num = 0;\\n        while (N > 0) {\\n            num = 10 * num + (N % 10);\\n            N /= 10;\\n        }\\n        return num;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 730083,
                "title": "rust-translated",
                "content": "Runtime: 24 ms, faster than 100.00% of Rust online submissions for Prime Palindrome.\\nMemory Usage: 2.1 MB, less than 100.00% of Rust online submissions for Prime Palindrome.\\n\\n```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn prime_palindrome(mut n: i32) -> i32 {\\n        fn sqrt(x: i32) -> i32 {\\n            if x < 2 {\\n                return x;\\n            };\\n            let mut left = 1;\\n            let mut right = x;\\n            let mut middle = 1;\\n            loop {\\n                middle = (left + right) / 2;\\n                if middle > x / middle {\\n                    right = middle - 1;\\n                } else {\\n                    left = middle + 1;\\n                    if left > x / left {\\n                        return middle;\\n                    }\\n                }\\n            }\\n        }\\n\\n        fn is_prime(n: i32) -> bool {\\n            if n < 2 {\\n                return false;\\n            } else if n == 2 {\\n                return true;\\n            }\\n            if n % 2 == 0 {\\n                return false;\\n            }\\n            for i in (3..sqrt(n) + 1).step_by(2) {\\n                if n % i == 0 {\\n                    return false;\\n                }\\n            }\\n            true\\n        }\\n\\n        match n {\\n            1 => 2,\\n            2 => 2,\\n            3 => 3,\\n            4 => 5,\\n            5 => 5,\\n            6 => 7,\\n            7 => 7,\\n            8..=11 => 11,\\n            _ => {\\n                for x in 1..100000 {\\n                    let mut s = x.to_string();\\n                    let len = s.len();\\n                    let r = s.chars().rev().skip(1).collect::<String>();\\n                    s.push_str(&r);\\n                    let y = s.parse::<i32>().unwrap();\\n                    if y >= n && is_prime(y) {\\n                        return y;\\n                    }\\n                }\\n                std::i32::MIN // unreachable!()\\n            }\\n        }\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_prime_palindrome() {\\n        assert_eq!(Solution::prime_palindrome(6), 7)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_02() {\\n        assert_eq!(Solution::prime_palindrome(8), 11)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_03() {\\n        assert_eq!(Solution::prime_palindrome(13), 101)\\n    }\\n\\n    #[test]\\n    fn test_prime_palindrome_04() {\\n        assert_eq!(Solution::prime_palindrome(45887963), 100030001)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 726410,
                "title": "solution-based-on-mapping-numbers-to-odd-and-even-length-palindromes",
                "content": "Every number can be used to construct two palindromes.\\n\\n1. Odd-length palindrome by concating the sequence of digits in the number with the reverse of the digits in the quotient from dividing the number by 10, e.g., \"897\" + \"98\" = \"89798\"\\n2. Even-length palindrome by concating the sequence of digits in the number with the reverse of the same sequence, e.g., \"897\" + \"798\" = \"897798\".\\n\\nThe special cases can help simplify the logic in the main loop.\\n\\n```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        \\n        def is_prime(n: int) -> bool:\\n            import math\\n            \\n            return n > 1 and all(n%i for i in range(2, int(math.sqrt(n))+1))\\n\\n        def palindromes(n: int) -> int:\\n            import itertools\\n            \\n\\t\\t\\t# Special odd-length cases\\n            yield from range(10)  \\n\\t\\t\\t\\n\\t\\t\\t# Since there is no corresponding odd-length cases to generate in the loop, extract these even-length cases out of the loop\\n            yield from range(11, 100, 11) \\n            \\n            for half_length in itertools.count(2):\\n                halves = range(int(10**(half_length-1)), int(10**half_length))\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# odd length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[-2::-1])\\n                    \\n\\t\\t\\t\\t# even length palindromes\\n                for half in (str(x) for x in halves):\\n                    yield int(half + half[::-1])\\n                \\n        for i in palindromes(N):\\n            if i >= N and is_prime(i):\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698063,
                "title": "bruteforce-approach",
                "content": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }\\n        return temp;\\n    }\\n    bool isPrime(int N){\\n        if(N<2) return false;\\n        for(int i=2;i*i<=N;i++){\\n            if(N%i==0) return false; \\n        }\\n        return true;\\n    }\\n    bool isPalindrome(int N){\\n        long long int ans=0;\\n        int p=N;\\n        if(N<10) return true;\\n        while(N>0){\\n            int rem=N%10;\\n            ans=ans*10+rem;\\n                N=N/10;\\n        }\\n        if(p==ans) return true;\\n            else return false;\\n    }\\n    int primePalindrome(int N) {\\n        \\n        while(true){\\n            if(N>=8 && N<=11) return 11;\\n        if(isPrime(N)&&isPalindrome(N)){\\n            return N;\\n        }\\n        int count=digit_count(N);\\n            if(count & 1){\\n                N++;\\n            }\\n            else{\\n                N=pow(10,count)+1;\\n            }\\n        \\n    }\\n        return N;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int digit_count(int N){\\n        int temp=0;\\n        while(N){\\n        N=N/10;\\n            temp++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 683142,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool is_palin(string str) {\\n        int len = str.length();\\n        int count = 0;\\n        for (int i = 0; i < len / 2; i++) {\\n            if (str[i] == str[len - i - 1]) count++;\\n            else   break;\\n        }\\n        if (count == (len / 2)) return true;\\n        return false;\\n    }\\n    int primePalindrome(int N) {\\n        int val, i = N;\\n        if (N <= 2) return 2;\\n        while(i <= INT_MAX) {\\n            //cout << i << endl;\\n            int start;\\n            if (i % 2)  start = 3;\\n            else    start = 2;\\n            bool prime = true;\\n            if (10000000 < i && i < 100000000)\\n                i = 100000000;\\n            if (!is_palin(to_string(i)))  {\\n                i++;\\n                continue;\\n            }\\n            for (int j = start; j < sqrt(i) + 1; j += 2) {\\n                if (i != j && i % j == 0) {\\n                    prime = false;\\n                    break;\\n                }\\n            }\\n            if (prime) {\\n                val = i;\\n                break;\\n            }\\n            i++;\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 681686,
                "title": "pre-calculated-all-the-palindromes-in-a-list",
                "content": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int primePalindrome(int N) {\\n        List<Integer> list[] = new ArrayList[10];\\n        for(int i=1;i<10;i++){\\n            list[i] = new ArrayList();\\n        }\\n        for(int i=1;i<=9;i++){\\n            list[1].add(i);\\n            list[2].add(10*i + i);\\n        }\\n        int ten = 10;\\n        for(int i=3;i<=9;i++){\\n            if(i % 2 == 1){\\n                for(int j=0;j<list[i-1].size();j++){\\n                    int val = list[i-1].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 10 + k * ten + val % ten);\\n                    }\\n                }\\n            }else{\\n                for(int j=0;j<list[i-2].size();j++){\\n                    int val = list[i-2].get(j);\\n                    for(int k=0;k<=9;k++){\\n                        list[i].add((val/ten) * ten * 100 + (10 * k + k) * ten + val % ten);\\n                    }\\n                }\\n                ten *= 10;\\n            }\\n        }\\n        for(int i=1;i<=9;i++){\\n            for(int j=0;j<list[i].size();j++){\\n                if(list[i].get(j) >= N && isPrime(list[i].get(j))){\\n                    return list[i].get(j);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n){\\n        if(n == 1){\\n            return false;\\n        }\\n        for(int i=2;i*i<=n;i++){\\n            if(n % i == 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643102,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int n) {\\n        if (n<12){\\n            for (int i=n; i<12; i++){\\n                if (prime(i)) return i;\\n            }\\n        }\\n        vector<int> origin = num2vec(n);\\n        int l = origin.size();\\n        int i = l/2-1;\\n        bool changed = false;\\n        for (int i=0; i<l/2; i++){\\n            if (origin[l-1-i]>origin[i]){\\n                origin[i] = origin[l-1-i];\\n                changed = true;\\n            }else{\\n                origin[l-1-i] = origin[i];\\n            }\\n        }\\n        if (l%2==1){\\n            origin[l/2] = 0;\\n        }\\n        int res = vec2num(origin);\\n        while (!prime(res)){\\n            next(origin, l);\\n            res = vec2num(origin);\\n        }\\n        return res;\\n    }\\n    \\n    int findfirst(vector<int> res, int l){\\n        bool changed = false;\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]<res[l-1-i]){\\n                if (changed){\\n                    res[l-1-i] = res[i];\\n                }else{\\n                    res[i] = res[l-i-1];\\n                    changed = true;   \\n                }\\n            }else if (changed){\\n                \\n            }\\n        }\\n    }\\n    \\n    void next(vector<int>& res, int& l){\\n        for (int i=l/2-1; i>=0; i--){\\n            if (res[i]==9){\\n                res[i] = 0; res[l-i-1] = 0;\\n            }else{\\n                res[i]++; res[l-i-1]++; return;\\n            }\\n        }\\n        res[l/2] = 0;\\n        res.push_back(1);\\n        res[0] = 1;\\n        l++;\\n    }\\n    \\n    bool prime(int n){\\n        for (int i=2; i<=sqrt(n); i++){\\n            if (n%i==0) return false;\\n        }\\n        return true;\\n    }\\n    \\n    vector<int> num2vec(int n){\\n        vector<int> res;\\n        while (n>0){\\n            res.push_back(n%10);\\n            n /= 10;\\n        }\\n        reverse(res.begin(), res.end());\\n        return res;\\n    }\\n    \\n    int vec2num(vector<int> res){\\n        int n = 0;\\n        for (int r:res){\\n            n = 10*n + r;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621473,
                "title": "cheap-solution-faster-than-100-and-less-memory-than-100-python-3",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def primePalindrome(self, N: int) -> int:\\n        legalprimes = [2, 3, 5, 7, 11, 101, 131, 151, 181, 191, 313, 353, 373, 383, 727, 757, 787, 797, 919, 929, 10301, 10501, 10601, 11311, 11411, 12421, 12721, 12821, 13331, 13831, 13931, 14341, 14741, 15451, 15551, 16061, 16361, 16561, 16661, 17471, 17971, 18181, 18481, 19391, 19891, 19991, 30103, 30203, 30403, 30703, 30803, 31013, 31513, 32323, 32423, 33533, 34543, 34843, 35053, 35153, 35353, 35753, 36263, 36563, 37273, 37573, 38083, 38183, 38783, 39293, 70207, 70507, 70607, 71317, 71917, 72227, 72727, 73037, 73237, 73637, 74047, 74747, 75557, 76367, 76667, 77377, 77477, 77977, 78487, 78787, 78887, 79397, 79697, 79997, 90709, 91019, 93139, 93239, 93739, 94049, 94349, 94649, 94849, 94949, 95959, 96269, 96469, 96769, 97379, 97579, 97879, 98389, 98689, 1003001, 1008001, 1022201, 1028201, 1035301, 1043401, 1055501, 1062601, 1065601, 1074701, 1082801, 1085801, 1092901, 1093901, 1114111, 1117111, 1120211, 1123211, 1126211, 1129211, 1134311, 1145411, 1150511, 1153511, 1160611, 1163611, 1175711, 1177711, 1178711, 1180811, 1183811, 1186811, 1190911, 1193911, 1196911, 1201021, 1208021, 1212121, 1215121, 1218121, 1221221, 1235321, 1242421, 1243421, 1245421, 1250521, 1253521, 1257521, 1262621, 1268621, 1273721, 1276721, 1278721, 1280821, 1281821, 1286821, 1287821, 1300031, 1303031, 1311131, 1317131, 1327231, 1328231, 1333331, 1335331, 1338331, 1343431, 1360631, 1362631, 1363631, 1371731, 1374731, 1390931, 1407041, 1409041, 1411141, 1412141, 1422241, 1437341, 1444441, 1447441, 1452541, 1456541, 1461641, 1463641, 1464641, 1469641, 1486841, 1489841, 1490941, 1496941, 1508051, 1513151, 1520251, 1532351, 1535351, 1542451, 1548451, 1550551, 1551551, 1556551, 1557551, 1565651, 1572751, 1579751, 1580851, 1583851, 1589851, 1594951, 1597951, 1598951, 1600061, 1609061, 1611161, 1616161, 1628261, 1630361, 1633361, 1640461, 1643461, 1646461, 1654561, 1657561, 1658561, 1660661, 1670761, 1684861, 1685861, 1688861, 1695961, 1703071, 1707071, 1712171, 1714171, 1730371, 1734371, 1737371, 1748471, 1755571, 1761671, 1764671, 1777771, 1793971, 1802081, 1805081, 1820281, 1823281, 1824281, 1826281, 1829281, 1831381, 1832381, 1842481, 1851581, 1853581, 1856581, 1865681, 1876781, 1878781, 1879781, 1880881, 1881881, 1883881, 1884881, 1895981, 1903091, 1908091, 1909091, 1917191, 1924291, 1930391, 1936391, 1941491, 1951591, 1952591, 1957591, 1958591, 1963691, 1968691, 1969691, 1970791, 1976791, 1981891, 1982891, 1984891, 1987891, 1988891, 1993991, 1995991, 1998991, 3001003, 3002003, 3007003, 3016103, 3026203, 3064603, 3065603, 3072703, 3073703, 3075703, 3083803, 3089803, 3091903, 3095903, 3103013, 3106013, 3127213, 3135313, 3140413, 3155513, 3158513, 3160613, 3166613, 3181813, 3187813, 3193913, 3196913, 3198913, 3211123, 3212123, 3218123, 3222223, 3223223, 3228223, 3233323, 3236323, 3241423, 3245423, 3252523, 3256523, 3258523, 3260623, 3267623, 3272723, 3283823, 3285823, 3286823, 3288823, 3291923, 3293923, 3304033, 3305033, 3307033, 3310133, 3315133, 3319133, 3321233, 3329233, 3331333, 3337333, 3343433, 3353533, 3362633, 3364633, 3365633, 3368633, 3380833, 3391933, 3392933, 3400043, 3411143, 3417143, 3424243, 3425243, 3427243, 3439343, 3441443, 3443443, 3444443, 3447443, 3449443, 3452543, 3460643, 3466643, 3470743, 3479743, 3485843, 3487843, 3503053, 3515153, 3517153, 3528253, 3541453, 3553553, 3558553, 3563653, 3569653, 3586853, 3589853, 3590953, 3591953, 3594953, 3601063, 3607063, 3618163, 3621263, 3627263, 3635363, 3643463, 3646463, 3670763, 3673763, 3680863, 3689863, 3698963, 3708073, 3709073, 3716173, 3717173, 3721273, 3722273, 3728273, 3732373, 3743473, 3746473, 3762673, 3763673, 3765673, 3768673, 3769673, 3773773, 3774773, 3781873, 3784873, 3792973, 3793973, 3799973, 3804083, 3806083, 3812183, 3814183, 3826283, 3829283, 3836383, 3842483, 3853583, 3858583, 3863683, 3864683, 3867683, 3869683, 3871783, 3878783, 3893983, 3899983, 3913193, 3916193, 3918193, 3924293, 3927293, 3931393, 3938393, 3942493, 3946493, 3948493, 3964693, 3970793, 3983893, 3991993, 3994993, 3997993, 3998993, 7014107, 7035307, 7036307, 7041407, 7046407, 7057507, 7065607, 7069607, 7073707, 7079707, 7082807, 7084807, 7087807, 7093907, 7096907, 7100017, 7114117, 7115117, 7118117, 7129217, 7134317, 7136317, 7141417, 7145417, 7155517, 7156517, 7158517, 7159517, 7177717, 7190917, 7194917, 7215127, 7226227, 7246427, 7249427, 7250527, 7256527, 7257527, 7261627, 7267627, 7276727, 7278727, 7291927, 7300037, 7302037, 7310137, 7314137, 7324237, 7327237, 7347437, 7352537, 7354537, 7362637, 7365637, 7381837, 7388837, 7392937, 7401047, 7403047, 7409047, 7415147, 7434347, 7436347, 7439347, 7452547, 7461647, 7466647, 7472747, 7475747, 7485847, 7486847, 7489847, 7493947, 7507057, 7508057, 7518157, 7519157, 7521257, 7527257, 7540457, 7562657, 7564657, 7576757, 7586857, 7592957, 7594957, 7600067, 7611167, 7619167, 7622267, 7630367, 7632367, 7644467, 7654567, 7662667, 7665667, 7666667, 7668667, 7669667, 7674767, 7681867, 7690967, 7693967, 7696967, 7715177, 7718177, 7722277, 7729277, 7733377, 7742477, 7747477, 7750577, 7758577, 7764677, 7772777, 7774777, 7778777, 7782877, 7783877, 7791977, 7794977, 7807087, 7819187, 7820287, 7821287, 7831387, 7832387, 7838387, 7843487, 7850587, 7856587, 7865687, 7867687, 7868687, 7873787, 7884887, 7891987, 7897987, 7913197, 7916197, 7930397, 7933397, 7935397, 7938397, 7941497, 7943497, 7949497, 7957597, 7958597, 7960697, 7977797, 7984897, 7985897, 7987897, 7996997, 9002009, 9015109, 9024209, 9037309, 9042409, 9043409, 9045409, 9046409, 9049409, 9067609, 9073709, 9076709, 9078709, 9091909, 9095909, 9103019, 9109019, 9110119, 9127219, 9128219, 9136319, 9149419, 9169619, 9173719, 9174719, 9179719, 9185819, 9196919, 9199919, 9200029, 9209029, 9212129, 9217129, 9222229, 9223229, 9230329, 9231329, 9255529, 9269629, 9271729, 9277729, 9280829, 9286829, 9289829, 9318139, 9320239, 9324239, 9329239, 9332339, 9338339, 9351539, 9357539, 9375739, 9384839, 9397939, 9400049, 9414149, 9419149, 9433349, 9439349, 9440449, 9446449, 9451549, 9470749, 9477749, 9492949, 9493949, 9495949, 9504059, 9514159, 9526259, 9529259, 9547459, 9556559, 9558559, 9561659, 9577759, 9583859, 9585859, 9586859, 9601069, 9602069, 9604069, 9610169, 9620269, 9624269, 9626269, 9632369, 9634369, 9645469, 9650569, 9657569, 9670769, 9686869, 9700079, 9709079, 9711179, 9714179, 9724279, 9727279, 9732379, 9733379, 9743479, 9749479, 9752579, 9754579, 9758579, 9762679, 9770779, 9776779, 9779779, 9781879, 9782879, 9787879, 9788879, 9795979, 9801089, 9807089, 9809089, 9817189, 9818189, 9820289, 9822289, 9836389, 9837389, 9845489, 9852589, 9871789, 9888889, 9889889, 9896989, 9902099, 9907099, 9908099, 9916199, 9918199, 9919199, 9921299, 9923299, 9926299, 9927299, 9931399, 9932399, 9935399, 9938399, 9957599, 9965699, 9978799, 9980899, 9981899, 9989899, 100030001]\\n        for p in legalprimes:\\n            if p >= N:\\n                return p\\n\\'\\'\\'\\nbrute forced with a sieve and a palindrome checker\\nmore of a project euler style solution\\nI think its interesting to note that all prime palindromes seem to have an odd number of digits with the only exception being 11.\\nevery other even repunit is divisible by eleven but i would be interested to see a proof as to why only odd digit prime palindromes seem to exist, if there is a proof.\\n\\t\\t\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 587818,
                "title": "ultra-simple-c-solution-suggestions-for-optimization-are-welcomed-100",
                "content": "Runtime: 884 ms, faster than 100.00% of C online submissions \\nMemory Usage: 5.1 MB, less than 100.00% of C online submissions\\n\\n```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nint primePalindrome(int N){\\n\\n    \\nunsigned long long int dummy=0,i,j,s=0,rem=0,rev=0;\\n    \\nif(N==1)\\nreturn 2;\\n\\n\\nfor(i=N;;i++)\\n{\\n\\ns=0;\\nrev=0;\\nrem=0;\\n    \\ndummy=i;\\nif(dummy<=11||dummy%2!=0&&dummy%3!=0&&dummy%5!=0&&dummy%7!=0&&dummy%11!=0)\\n{\\nwhile(dummy>0)\\n{\\nrem=dummy%10;\\ns=s+rem;\\nrev=rev*10+rem;\\ndummy=dummy/10;\\n}\\n    \\nif(rev==i)\\n{   \\ns=0;\\nfor(j=2;j<=sqrt(i);j++)\\n{\\nif(i%j==0)\\n{\\n++s;\\nbreak;\\n}\\n}  \\nif(s==0)\\nreturn i;\\n}\\n}\\n}\\nreturn 0;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 578941,
                "title": "c-solution-faster-than-89-and-space-less-than-100",
                "content": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic auto func = [](){\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\nclass Solution {\\npublic:\\n    bool is_prime(int n)\\n    {\\n        if(n<2)\\n            return 0;\\n        for(int i=2;i*i<=n;i++)\\n            if(n%i==0)\\n                return 0;\\n        return 1;\\n    }\\n    int reverse(int n)\\n    {\\n        int ret = 0;\\n        int tmp = n;\\n        while(tmp)\\n        {\\n            int rem = tmp%10;\\n            ret = ret*10 + rem;\\n            tmp /= 10;\\n        }\\n        return ret;\\n    }\\n    int digit_count(int n)\\n    {\\n        int ret = 0;\\n        while(n)\\n        {\\n            n/=10;\\n            ret++;\\n        }\\n        return ret;\\n    }\\n    int primePalindrome(int N) {\\n        while(true)\\n        {\\n            if(N>=8 && N<=11)\\n                return 11;\\n            if(reverse(N)==N && is_prime(N))\\n                return N;\\n            int cnt = digit_count(N);\\n            if(cnt&1)\\n                N++;\\n            else\\n                N = pow(10,cnt)+1;\\n        }\\n        return N;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 553261,
                "title": "faster-than-81-50-of-java-online-submissions",
                "content": "# Runtime: 29 ms, faster than 81.50% of Java online submissions for Prime Palindrome.\\n\\n```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int primePalindrome(int N) {\\n        while (true) {\\n             \\n            if(N%2==0 && N>2){\\n               ++ N;\\n            }\\n         \\n            if (N == reverse(N) && isPrime(N))\\n                return N;\\n            N++;\\n           // all 8 digit palindromes are not prime\\n           if (10_000_000 < N && N < 100_000_000)\\n                N = 100_000_000;\\n        }\\n    }\\n\\n    public boolean isPrime(int N) {\\n        if (N < 2) return false;\\n        int R = (int) Math.sqrt(N);\\n        for (int d = 2; d <= R; ++d)\\n            if (N % d == 0) return false;\\n        return true;\\n    }\\n\\n    public int reverse(int N) {\\n        int ans = 0;\\n        while (N > 0) {\\n            ans = 10 * ans + (N % 10);\\n            N /= 10;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537994,
                "title": "this-is-an-tricky-question-not-good-for-interview",
                "content": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nRef: https://leetcode.com/problems/prime-palindrome/discuss/146798/JavaC%2B%2BPython-All-Even-Length-Palindrome-are-Divisible-by-11\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // pali must be odd, since even pali can be devided by 11, if it is not 11.\\n    public int primePalindrome(int N) {\\n        if (N >= 8 && N <= 11) return 11;\\n        for (int i = 1; i < 100000; i++) {\\n            String l = String.valueOf(i), r = new StringBuilder(l).reverse().toString();\\n            String cand = l + r.substring(1);\\n            int n = Integer.parseInt(cand);\\n            if (n >= N && isPrime(n)) return n;\\n        }\\n        return -1;\\n    }\\n    \\n    private boolean isPrime(int n) {\\n        if (n == 1) return false;\\n        if (n % 2 == 0) return n == 2;\\n        for (int i = 3; i * i <= n; i++) {\\n            if (n % i == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 518737,
                "title": "solution-c-faster-than-66-and-space-less-than-100",
                "content": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n   Allah always watching\\n*/\\nclass Solution {\\npublic:\\nbool prime(int n){\\n              n = abs(n);\\n              if(n < 2) return false;\\n              if(n == 2) return true;\\n              if(n%2 == 0) return false;\\n              for(int i = 3;i<(sqrt(n)+1);i+=2){\\n                            if(n%i == 0) return false;\\n              }\\n              return true;\\n}\\nint cmp(string && s1,string && s2){\\n              if(s1.length() > s2.length()) return 1;\\n              if(s1.length() < s2.length()) return -1;\\n              for(int i = 0;i<s1.length();++i){\\n                            if(s1[i] > s2[i]) return 1;\\n                            if(s1[i] < s2[i]) return -1;\\n              }\\n              return 0;\\n}\\nstring jack(string s,string ss){\\n              if(s.length() == 1){\\n                            while(s[0] <= \\'9\\'){\\n                                          //cout<<s<<endl;\\n                                          if(prime(stoi(s))){\\n                                                        if(cmp(move(s),move(ss)) >= 0)  return s;\\n                                          }\\n                                          s[0] += 1;\\n                            }\\n              }\\n              s = \"11\";\\n              //cout<<s<<endl;\\n              if(cmp(move(s),move(ss)) >= 0)  return s;\\n              while(s.length() < 20){\\n                            int middle = s.length()/2,\\n                                left,\\n                                right;\\n                            if(s.length()%2 == 0){\\n                                       if(s[middle] == \\'9\\'){\\n                                                 s[middle] = \\'0\\';\\n                                                 s[middle-1] = \\'0\\';\\n                                                 left = middle-2;\\n                                                 right = middle+1;\\n                                                 while(left > -1){\\n                                                               if(s[left] != \\'9\\'){\\n                                                                             s[left] += 1;\\n                                                                             s[right] += 1;\\n                                                                             break;\\n                                                               }else{\\n                                                                             s[left] = \\'0\\';\\n                                                                             s[right] = \\'0\\';\\n                                                               }\\n                                                               --left;\\n                                                               ++right;\\n                                                 }\\n                                                 if(left <= -1){\\n                                                               int n = s.length()+1;\\n                                                               s = \"\";\\n                                                               for(int i = 0;i<n;++i){\\n                                                                             if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                             else s+=\\'0\\';\\n                                                               }\\n                                                 }\\n                                       }else{\\n                                                     s[middle]+=1;\\n                                                     s[middle-1]+=1;\\n                                       }\\n                            }else{\\n                                       if(s[middle] == \\'9\\'){\\n                                                     s[middle] = \\'0\\';\\n                                                     left = middle-1;\\n                                                     right = middle+1;\\n                                                     while(left > -1){\\n                                                                   if(s[left] != \\'9\\'){\\n                                                                                 s[left] += 1;\\n                                                                                 s[right] += 1;\\n                                                                                 break;\\n                                                                   }else{\\n                                                                                 s[left] = \\'0\\';\\n                                                                                 s[right] = \\'0\\';\\n                                                                   }\\n                                                                   --left;\\n                                                                   ++right;\\n                                                     }\\n                                                     if(left <= -1){\\n                                                                   int n = s.length()+1;\\n                                                                   s = \"\";\\n                                                                   for(int i = 0;i<n;++i){\\n                                                                                 if(i == 0 || i == (n-1)) s+=\\'1\\';\\n                                                                                 else s+=\\'0\\';\\n                                                                   }\\n                                                     }\\n                                       }else{\\n                                                s[middle] += 1;\\n                                       }\\n                            }\\n                            //cout<<s<<endl;\\n                            if(prime(stoi(s))){\\n                                          if(cmp(move(s),move(ss)) >= 0)  return s;\\n                            }\\n              }\\n              return \"0\";\\n}\\nint primePalindrome(int r) {\\n      string s = to_string(r),\\n             ss;\\n      for(int i = 0;i<s.length();++i) ss += \\'1\\';\\n      return stoi(jack(ss,s));\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 513998,
                "title": "c-simple",
                "content": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    int createPalindrome(int i, bool odd, int m) {\\n       stringstream ss;\\n       ss << i;\\n       string s = ss.str();\\n       reverse(s.begin(),s.end());\\n       if(odd) \\n           ss << m;\\n       ss << s;\\n       return stoi(ss.str()); \\n    }\\n    \\n    bool isPrime(int N) {\\n        if (N == 1)\\n            return false;\\n        for (int i=2; i<N; i++) {\\n            if (N % i == 0)\\n                return false;\\n        }\\n        return true;\\n    }\\npublic:\\n    int primePalindrome(int N) {\\n        if(N <10)\\n            for(int i=N; i<10;i++) {\\n                if(isPrime(i))\\n                    return i;\\n            }\\n        \\n        for(int i=1; i<=N;i++) {\\n            int p = createPalindrome(i, false, 0);\\n            if(p >= N && isPrime(p))\\n                return p;\\n            \\n            for (int j=0; j<=9; j++) {\\n                int f = createPalindrome(i, true, j);\\n                if(f >= N && isPrime(f))\\n                    return f;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484821,
                "title": "accepted-straightforward-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        private bool IsPrime(int num)\\n        {\\n            if (num <= 1)\\n            {\\n                return false;\\n            }\\n\\n            for (int i = 2; i * i <= num; i++)\\n            {\\n                if (num % i == 0)\\n                {\\n                    return false;\\n                }\\n            }\\n            return true;\\n        }\\n\\n        private int Helper(List<int> nDigits, int n, int idx)\\n        {\\n            checked\\n            {\\n                if (idx > (nDigits.Count - 1) / 2)\\n                {\\n                    int number = 0;\\n                    foreach (var nDigit in nDigits)\\n                    {\\n                        number *= 10;\\n                        number += nDigit;\\n                    }\\n\\n                    if (number >= n && IsPrime(number))\\n                    {\\n                        return number;\\n                    }\\n\\n                    return -1;\\n                }\\n\\n\\n                int start = nDigits[idx];\\n                for (int i = start; i <= 9; i++)\\n                {\\n                    nDigits[idx] = i;\\n                    nDigits[nDigits.Count - 1 - idx] = i;\\n                    var res = Helper(nDigits, n, idx + 1);\\n                    if (res > 0)\\n                    {\\n                        return res;\\n                    }\\n                }\\n\\n                nDigits[idx] = 0;\\n                nDigits[nDigits.Count - 1 - idx] = 0;\\n                return -1;\\n            }\\n        }\\n\\n        public int PrimePalindrome(int n)\\n        {\\n            List<int> nDigits = new List<int>((int)Math.Floor(Math.Log10(n))+1);\\n            var num = n;\\n            while (n != 0)\\n            {\\n                nDigits.Add(n % 10);\\n                n /= 10;\\n            }\\n            nDigits.Reverse();\\n\\n            for (int i = 0; i <= (nDigits.Count - 1) / 2; i++)\\n            {\\n                nDigits[nDigits.Count - 1 - i] = nDigits[i];\\n            }\\n\\n            do\\n            {\\n                var res = Helper(nDigits, num, 0);\\n\\n                if (res > 0)\\n                {\\n                    return res;\\n                }\\n\\n                for (int i = 0; i < nDigits.Count; i++)\\n                {\\n                    nDigits[i] = 0;\\n                }\\n                nDigits[0] = 1;\\n                nDigits.Add(1);\\n\\n            } while (true);\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468244,
                "title": "python-recursive-method",
                "content": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def primePalindrome(self, n):\\n        if Solution().palindrome(n) == True:\\n            if Solution().prime(n) == True:\\n                return n\\n            else:\\n                Solution().primePalindrome(n+1)\\n        else:\\n            Solution().primePalindrome(n + 1)\\n\\n    def prime(self,n):\\n        for i in range(2,n-1):\\n            if n%i == 0:\\n                return False\\n        return True\\n\\n    def palindrome(self,n):\\n        if str(n)== str(n)[::-1]:\\n            return True\\n        else:\\n            return False\\n",
                "codeTag": "Java"
            },
            {
                "id": 457047,
                "title": "go-build-odd-length-prime-solution",
                "content": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc primePalindrome(N int) int {\\n\\tif N >= 8 && N <= 11 {\\n\\t\\treturn 11\\n\\t}\\n\\n\\tfor i := 1; i <= 20000; i++ {\\n\\t\\tnumStr := strconv.Itoa(i)\\n\\t\\tnumStr += reverseStr(numStr)[1:]\\n\\t\\tnum, _ := strconv.Atoi(numStr)\\n\\t\\tif num >= N && isPrime(num) {\\n\\t\\t\\treturn num\\n\\t\\t}\\n\\t}\\n\\treturn -1\\n}\\n\\nfunc reverseStr(s string) string {\\n\\tstr := []byte(s)\\n\\tfor i := 0; i < len(str)/2; i++ {\\n\\t\\tstr[i], str[len(str)-i-1] = str[len(str)-i-1], str[i]\\n\\t}\\n\\treturn string(str)\\n}\\n\\nfunc isPrime(n int) bool {\\n\\tif n < 2 || n%2 == 0 {\\n\\t\\treturn n == 2\\n\\t}\\n\\tfor i := 3; i*i <= n; i++ {\\n\\t\\tif n%i == 0 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442570,
                "title": "c-first-palindrome-next-palindrome",
                "content": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int primePalindrome(int N);\\n    bool isPrime(int n);\\n    bool isPalindrome(int n);\\n    int nextPalindrome(int n);\\n    int firstPalindrome(int n);\\n};\\n\\nbool Solution::isPrime(int n)\\n{\\n\\tfor (int i = 2; i*i <= n; i++) {\\n\\t\\tif (n % i == 0) \\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nbool Solution::isPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\tint i = 0, j = str.size()-1;\\n\\twhile (i < j) {\\n\\t\\tif (str[i++] != str[j--])\\n\\t\\t\\treturn false;\\n\\t}\\n\\treturn true;\\n}\\n\\nint Solution::nextPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[i] = str[j] = \\'0\\';\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tstr[j] = str[i];\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\tif (i < 0) {\\n\\t\\tstr += \\'1\\';\\n\\t\\tstr[0] = \\'1\\';\\n\\t}\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::firstPalindrome(int n)\\n{\\n\\tstringstream ss;\\n\\tss << n;\\n\\tstring str = ss.str();\\n\\t\\n\\tint i, j;\\n\\ti = j = str.size()/2;\\n\\tif (str.size() % 2 == 0) {\\n\\t\\ti--;\\n\\t} \\n\\t\\n\\twhile (i > 0) {\\n\\t\\tif (str[i] == \\'9\\') {\\n\\t\\t\\tstr[j++] = str[i--] = \\'0\\';\\n\\t\\t\\tcontinue;\\n\\t\\t} else {\\n\\t\\t\\tstr[i]++;\\n\\t\\t\\tbreak;\\n\\t\\t}\\t\\n\\t}\\n\\t\\n\\twhile (i >= 0) {\\n\\t\\tstr[j] = str[i];\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n\\t\\n\\treturn atoi(str.c_str());\\n}\\n\\nint Solution::primePalindrome(int N)\\n{\\n\\tint n = N;\\n\\tif (n == 1)  n = 2;\\n\\t\\n\\tif (!isPalindrome(n)) \\n\\t\\tn = firstPalindrome(n);\\n\\t\\t\\n\\twhile (true) {\\n\\t\\t//cout << n << endl;\\n\\t\\tif (n >= N)\\n\\t\\t\\tif (isPrime(n))\\n\\t\\t\\t\\tbreak;\\n\\t\\tn = nextPalindrome(n);\\n\\t}\\n\\t\\n\\treturn n;\\n}\\n```",
                "codeTag": "C++"
            }
        ],
        "discussions": [
            {
                "id": 1907331,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1868032,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 2069858,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            },
            {
                "id": 1926163,
                "content": [
                    {
                        "username": "Zoro_de_luffy",
                        "content": "just hate this question \\n"
                    },
                    {
                        "username": "No_one_can_stop_me",
                        "content": "This is question is way different -> I think we find the next prime number something related to next greater element -> Not sure! -> Comment below if you know what to do ?"
                    },
                    {
                        "username": "satyam_kathait",
                        "content": "you have to find a prime number that is also palindrome and is greater to equals to n"
                    },
                    {
                        "username": "patrick_problem_solver",
                        "content": "testcase 36/61, how is 2 a prime number :D"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Why so many VD?"
                    },
                    {
                        "username": "hanselkane",
                        "content": "wtf is VD ?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Check If It Is a Good Array",
        "question_content": "<p>Given an array <code>nums</code> of&nbsp;positive integers. Your task is to select some subset of <code>nums</code>, multiply each element by an integer and add all these numbers.&nbsp;The array is said to be&nbsp;<strong>good&nbsp;</strong>if you can obtain a sum of&nbsp;<code>1</code>&nbsp;from the array by any possible subset and multiplicand.</p>\n\n<p>Return&nbsp;<code>True</code>&nbsp;if the array is <strong>good&nbsp;</strong>otherwise&nbsp;return&nbsp;<code>False</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [12,5,7,23]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 5 and 7.\n5*3 + 7*(-2) = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [29,6,10]\n<strong>Output:</strong> true\n<strong>Explanation:</strong> Pick numbers 29, 6 and 10.\n29*1 + 6*(-3) + 10*(-1) = 1\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6]\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10^5</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10^9</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 419368,
                "title": "java-c-python-chinese-remainder-theorem",
                "content": "## **Intuition**\\nThis problem is realated a Chinese theorem:\\nChinese remainder theorem, created in 5th centry.\\nAlso well known as Hanson Counting.\\n<br>\\n\\n## **Explanation**\\nIf `a % x = 0` and `b % x = 0`,\\nappareantly we have `(pa + qb) % x == 0`\\nIf `x > 1`, making it impossible `pa + qb = 1`.\\n\\nWell, I never heard of Bezout\\'s identity.\\nEven though the intuition only proves the necessary condition,\\nit\\'s totally enough.\\n\\nThe process of gcd,\\nis exactly the process to get the factor.\\nThe problem just doesn\\'t ask this part.\\n<br>\\n\\n## **Complexity**\\nOf course you can return true as soon as `gcd = 1`\\nI take gcd calculate as `O(1)`.\\n\\nTime `O(N)`\\uFF0C\\nSpace `O(1)`\\n\\n<br>\\n\\n**Java:**\\n```java\\n    public boolean isGoodArray(int[] A) {\\n        int x = A[0], y;\\n        for (int a: A) {\\n            while (a > 0) {\\n                y = x % a;\\n                x = a;\\n                a = y;\\n            }\\n        }\\n        return x == 1;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a:\\n                gcd, a = a, gcd % a\\n        return gcd == 1\\n```\\n\\n**Python, 1-line using fractions**\\n```python\\nimport fractions\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        return reduce(fractions.gcd, A) < 2\\n```",
                "solutionTags": [],
                "code": "```java\\n    public boolean isGoodArray(int[] A) {\\n        int x = A[0], y;\\n        for (int a: A) {\\n            while (a > 0) {\\n                y = x % a;\\n                x = a;\\n                a = y;\\n            }\\n        }\\n        return x == 1;\\n    }\\n```\n```cpp\\n    bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n```\n```python\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a:\\n                gcd, a = a, gcd % a\\n        return gcd == 1\\n```\n```python\\nimport fractions\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        return reduce(fractions.gcd, A) < 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419324,
                "title": "bezout-s-identity",
                "content": "Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t  a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) .  e.g.  if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n\\n```\\nclass Solution {\\n\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0] == 1;\\n        \\n        int a = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (__gcd(a, nums[i]) == 1) return true;\\n            a = __gcd(a, nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 1) return nums[0] == 1;\\n        \\n        int a = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (__gcd(a, nums[i]) == 1) return true;\\n            a = __gcd(a, nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422624,
                "title": "the-whole-logic",
                "content": "The solution should be clear at this point. Here I\\'d like to tidy up the whole logic to have a better understanding of the solution.\\n1. \"B\\xE9zout\\'s identity:  (the GCD of a and b) is the smallest positive linear combination of non-zero a and b\"[1]\\n2.  For this problem, if we can find any subset, which can generate gcd(subset) = 1, it is true. Otherwise, the gcd will be greater than 1, it is obvious that it is false.\\n3.  If **any subset** of the whole nums list has a gcd(subset)=1, then gcd(nums)=1 as:\\n    a) The gcd is a commutative function: gcd(a, b) = gcd(b, a) [2]\\n    b) The gcd is an associative function: gcd(a, gcd(b, c)) = gcd(gcd(a, b), c). [2]\\n    c) If none of a1, a2, . . . , ar is zero, then gcd( a1, a2, . . . , ar ) = gcd( gcd( a1, a2, . . . , ar-1 ), ar ) [2]\\n    d) It should be trival that gcd(1, n) where n is a non negative interger to be 1.\\n4. based on 3, we change check \\'whether we have gcd of **any subset** to be 1\\' to \\'check whether the gcd of the whole nums list is 1\\' as: if we have a subset {**a, e, f**} and gcd(a, e, f)=1, and the whole list contains {**a,** b, c, d, **e, f**}. Based on 3a), we will have gcd(a, b, c) = gcd( gcd(a,b), c)  based on 3b)  gcd(a,gcd(b,c))=gcd(gcd(a,b),c). Based on 3a)and 3b) gcd(gcd(a,b),c) = gcd(c, gcd(a,b)) = gcd(gd(c, a), b). We can get general assocation by changing gcd(**a,** b, c, d, **e, f**)  to gcd(gcd(b,c,d), gcd(a,e,f))=1.\\n\\n**Reference**\\n[1] https://eli.thegreenplace.net/2009/07/10/the-gcd-and-linear-combinations\\n[2] https://en.wikipedia.org/wiki/Greatest_common_divisor",
                "solutionTags": [],
                "code": "The solution should be clear at this point. Here I\\'d like to tidy up the whole logic to have a better understanding of the solution.\\n1. \"B\\xE9zout\\'s identity:  (the GCD of a and b) is the smallest positive linear combination of non-zero a and b\"[1]\\n2.  For this problem, if we can find any subset, which can generate gcd(subset) = 1, it is true. Otherwise, the gcd will be greater than 1, it is obvious that it is false.\\n3.  If **any subset** of the whole nums list has a gcd(subset)=1, then gcd(nums)=1 as:\\n    a) The gcd is a commutative function: gcd(a, b) = gcd(b, a) [2]\\n    b) The gcd is an associative function: gcd(a, gcd(b, c)) = gcd(gcd(a, b), c). [2]\\n    c) If none of a1, a2, . . . , ar is zero, then gcd( a1, a2, . . . , ar ) = gcd( gcd( a1, a2, . . . , ar-1 ), ar ) [2]\\n    d) It should be trival that gcd(1, n) where n is a non negative interger to be 1.\\n4. based on 3, we change check \\'whether we have gcd of **any subset** to be 1\\' to \\'check whether the gcd of the whole nums list is 1\\' as: if we have a subset {**a, e, f**} and gcd(a, e, f)=1, and the whole list contains {**a,** b, c, d, **e, f**}. Based on 3a), we will have gcd(a, b, c) = gcd( gcd(a,b), c)  based on 3b)  gcd(a,gcd(b,c))=gcd(gcd(a,b),c). Based on 3a)and 3b) gcd(gcd(a,b),c) = gcd(c, gcd(a,b)) = gcd(gd(c, a), b). We can get general assocation by changing gcd(**a,** b, c, d, **e, f**)  to gcd(gcd(b,c,d), gcd(a,e,f))=1.\\n\\n**Reference**\\n[1] https://eli.thegreenplace.net/2009/07/10/the-gcd-and-linear-combinations\\n[2] https://en.wikipedia.org/wiki/Greatest_common_divisor",
                "codeTag": "Unknown"
            },
            {
                "id": 419619,
                "title": "c-3-lines",
                "content": "```\\nbool isGoodArray(vector<int>& nums) {\\n    auto gcd = nums[0];\\n    for (auto n : nums) gcd = __gcd(gcd, n);\\n    return gcd == 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n    auto gcd = nums[0];\\n    for (auto n : nums) gcd = __gcd(gcd, n);\\n    return gcd == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 438263,
                "title": "trivial-is-the-new-hard",
                "content": "```\\ndef is_good_array(nums)\\n  nums.reduce(:gcd) == 1\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_good_array(nums)\\n  nums.reduce(:gcd) == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2072260,
                "title": "rigorous-proof-for-solving-the-problem",
                "content": "Note: In this proof, a notable amount of subscript is used. However since it is not exactly feasible to properly format the subscript, instead array index is used in place of subscript. For example, `t[i]` will be used instead of t<sub>i</sub>.\\n \\n **Foundation**\\n ___\\n\\nTo begin, the foundation for the proof is to be laid out. First, the congruence relation (`\\u2261`) and some of its properties are presented\\n\\n**Definition:** `a \\u2261 r (mod d)` is an expression equivalent to the equation `a = qd + r` where:\\n- `q` (quotient) is an integer that follows `q = floor(a / d)`,\\n- `d` (divisor) is a variable integer\\n- `r` (remainder) is an integer that follows `r = a modulo d`, `0 \\u2264 r, < d`\\n- `a` is variable integer, particularly serves as dividend.\\n\\nThis expression and equation stems from a division operation: `a / d`.\\n\\n**Example:** Suppose a division operation is given as follows:\\n```c\\n29 / 8\\n```\\nBy definition, the quotient and remainder can be found:\\n```c\\nq = floor(29 / 8)\\nq = 3\\n\\nr = 29 modulo 8\\nr = 5\\n```\\nEquivalently, this can be represented as:\\n```c\\n29 = 3(q) * 8(d) + 5(r)\\n```\\nor\\n```\\n29 \\u2261 5 (mod 8)\\n```\\n\\n**Definition:** Addition, subtraction, and multiplication operation on integers preserves their congruence relation.\\n\\n**Example:** Addition. Suppose the following equation in a congruence system of 4 (i.e. `... \\u2261 ... (mod 4)`:\\n```c\\n5 + 10\\n```\\nThe congruence relation of the equation\\'s outcome is equal to adding each of the element\\'s congruence in the equation.\\n```\\nThe congruence relation of the equation\\'s outcome\\n5 + 10 = 15\\n15 \\u2261 3 (mod 4)\\n\\nAdding each of the element\\'s congruence\\n5 \\u2261 1 (mod 4)\\n10 \\u2261 2 (mod 4)\\n1 (mod 4) + 2 (mod 4) = 3 (mod 4)\\n```\\n\\n**Example:** Subtraction. Suppose the following equation in a congruence system of 7 i.e. (`... \\u2261 ... (mod 7)`:\\n```c\\n16 - 3\\n```\\nThe congruence relation of the equation\\'s outcome is equal to subtracting the element\\'s congruence in the equation.\\n```\\nThe congruence relation of the equation\\'s outcome\\n16 - 3 = 13\\n13 \\u2261 6 (mod 7)\\n\\nSubtracting each of the element\\'s congruence\\n16 \\u2261 2 (mod 7)\\n3 \\u2261 3 (mod 7)\\n2 (mod 7) - 3 (mod 7) = -1 (mod 7)\\n2 (mod 7) - 3 (mod 7) = 6 (mod 7)\\n```\\nIn the last line, the equation underflows back to positive because `r` is limited to be `0 \\u2264 r < d`.\\n\\n**Example:** Multiplication. Suppose the following equation in a congruence system of 9 i.e. (... \\u2261 ... (mod 9)`):\\n```c\\n20 * 16\\n```\\nThe congruence relation of the equation\\'s outcome is equal to multiplying each of the element\\'s congruence in the equation.\\n```c\\nThe congruence relation of the equation\\'s outcome\\n20 * 16 = 320\\n320 \\u2261 5 (mod 9)\\n\\nMultiplying each of the element\\'s congruence in the equation.\\n20 \\u2261 2 (mod 9)\\n16 \\u2261 7 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 14 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 5 (mod 9)\\n```\\nIn the last line, the answer is reduced down so that 14 is under 9, because `r` is limited to be `0 \\u2264 r < d)`.\\n\\n**Theorem I: Bezout Identity (special case, reworded).** There exists some pair of integer `(p, q)` such that given two integer `a` and `b` where both are coprime (i.e. `gcd(a, b) = 1`), the equation `1 = ab + pq` can be made. [1, with modification]\\n\\n*Proof*\\nFirst, the following equation is formally presented, By definition,\\n```\\ngcd(a, b) = 1\\n1 = ab + pq, for some integer pair (p, q)\\n```\\nTherefore,\\n```\\ngcd(a, b) = ab + pq, for some integer pair (p, q)    -- (1)\\n```\\nThe only time two positive integers namely `a` and `b`, and for the sake of proof, `a > b`, can result in 1 by following the equation `ap + bq` for some variable `p` and `q`, is when `a` and `b` are coprime i.e. `gcd(a, b) = 1`. It is impossible to create 1 if this condition is not met, because when `g = gcd(a, b)` and `g != 1` that means `a \\u2261 0 (mod g)` and `b \\u2261 0 (mod g)`. It follows that when a number `n \\u2261 0 (mod g)`, its multiple will also be `0 (mod g)` i.e.\\n\\n```\\nn \\u2261 0 (mod g)\\nn * x \\u2261 0 * x (mod g), for some integer x\\nnx \\u2261 0 (mod g), for some integer x\\n```\\nTherefore both `a` and `b` will not have any multiple that when divided by `g` will result in some remainder.\\n\\nAdding (and subtracting) `a` and `b` will also result in `0 (mod g)` i.e.\\n\\n```\\na + b \\u2261 (0 + 0) (mod g)\\na + b \\u2261 0 (mod g)\\n```\\n```\\na - b \\u2261 (0 - 0) (mod g)\\na - b \\u2261 0 (mod g)\\n```\\nAll of this lead to the conclusion that all arithmetical operation except division using `a` and `b` all will result in a number multiple of `g`. This implies that it is impossible to generate a number other than `g` and its multiple. And since `g != 1` it is impossible to generate an integer 1 altogether. Therefore, it is necessary for `g = 1`, where `g = gcd(a, b)`, holds true to generate 1. \\u25A0\\n\\n**Proof**\\n___\\n\\n**Hypothesis I:** Solving for `gcd` function(s) is equivalent to solving the problem.\\n\\n*Proof*\\nThe `gcd` of any two number can be used in the process of determining if it is possible to reach an integer 1 i.e. it is possible to do something along the line of\\n```\\nv = c[1] * a + c[2] * gcd(m, n)    -- (2)\\n```\\nwhere `c` are free variable. This is allowed because that expression can be expanded to the expression stated in the problem i.e. \"multiply each element by an integer and add all these numbers.\" which when formulated can be represented as follows:\\n\\n**Problem Function Statement**\\n```\\nv = c[1] * i[1] + c[2] * i[2] + ... + c[n] * i[n]\\nv = sum(c[x] * i[x]) for 1 \\u2264 x \\u2264 n    -- (3)\\n```\\nwhere `c` are free variables and `i` are some selected number from `nums`.\\n\\nThe expansion of equation (2) follows the equations below.\\n```\\nv = c[1] * a + c[2] * gcd(m, n)\\nv = c[1] * a + c[2] * (mp + nq)   -- (applying (1))\\nv = c[1] * a + (p * c[2]) * m + (q * c[2]) * n\\nv = c[1] * a + p\\' * m + q\\' * n    -- (4)\\n```\\nwhere `c`, `p`, `q` are some free variables and `p\\' = p * c[2]` and `q\\' = q * c[2]`. Both `p\\'` and `q\\'` are actually free variables too as both can be manipulated such that `p\\'` and `q\\'` are determined first, then `p`, `q`, and `c[2]` is determined to suit the equation. It can be seen easily that equation (4) follows the form of problem function statement (equation (3)).\\n\\nThe `gcd` of some numbers can be used as input to `gcd` function when finding the solution i.e.\\n\\n```\\nv = gcd(gcd(m, n), gcd(o, p))\\nv = gcd((c[m] * m + c[n] * n),(c[o] * o, c[p] * p))    -- (applying(1))\\nv = c[mn] * (c[m] * m + c[n] * n) + c[op] * (c[o] * o + c[p] * p) -- (applying (1))\\nv = c[mn] * c[m] * m + c[mn] * c[n] * n + c[op] * c[o] * o + c[op] * c[p] * p\\nv = (c[mn] * c[m]) * m + (c[mn] * c[n]) * n + (c[op] * c[o]) * o + (c[op] * c[p]) * p\\nv = c[mn,m] * m + c[mn,n] * n + c[op,o] * o + c[op,p] * p    -- (5)\\n```\\nwhere `c[x]` is a free variable. Once again, equation (5) follows the form of problem function statement (equation (2)). This shows that solving `gcd(gcd(a, b), gcd(c, d))` for some `a`, `b`, `c`, and `d` is equivalent to solving the problem function statement (equation (2)). Therefore, arriving to the solution in the problem function statement can be done by using `gcd` function, which proves the hypothesis true. \\u25A0\\n\\n**Corollary I:** The variant where one of the parameter in the outer `gcd` function is an integer (instead of `gcd` function) e.g. `gcd(a, gcd(b, c))` follows the same process and therefore the conclusion also holds in this variation.\\n\\n**Corollary II:** `gcd` of two number can be used as an intermediary value for some next iteration of `gcd` function when solving the problem.\\n\\nIt has been established that the solution to the problem can be reduced to whether it is possible to find any set of number in `nums` such that their `gcd` is 1. From previous explanation it should be relatively easy to intuitively deduce that the value `v` from equation (5) is in fact the `gcd` to all input in question. For the sake of completeness of the proof along with providing the correctness of the algorithm that can be used to solve the problem, the next section will discuss the correctness of the following hypothesis.\\n\\n**Hypothesis II:** `gcd` function with more than two parameters can be built on `gcd` function with two parameters.\\n\\n*Proof*\\nThe hypothesis will be proved using two lemmata:\\n\\n*Lemma I: Given `w = gcd(gcd(a, b), c)`, `w` divides `a`, `b`, and `c`.*\\n\\nPreviously it has been stated that the `gcd` of two input can be used as the input of another `gcd` function. This finding can be utilized to find the `gcd` of a set of number, instead of only two.  Consider the following equation.\\n```\\ngcd(a, b) = v\\n```\\nBy definition, this means that:\\n(1) `v|a` (read: `v` divides `a`)\\n(2) `v \\u2264 a` as direct consequence of (1)\\n(3) `v|b` (read: `v` divides `b`)\\n(4) `v \\u2264 b` as direct consequence of (2)\\n(5) There is no `n > v` such that `n|a` and `n|b`\\n\\nNext, consider the following equation.\\n```\\ngcd(v, c) = w\\n```\\nBy definition, this means that:\\n(6) `w|v`\\n(7) `w \\u2264 v` as direct consequence of (6)\\n(8) `w|c`\\n(9) `w \\u2264 c` as direct conseuquence of (9)\\n(10) There is no `m > w` such that `m|v` and `m|c`\\n\\nOne property of divisibility states that if `x|y` and `y|z`, that means `x|z` (for additional reading material, see [2]). Returning to the previous findings,\\n\\n(6) `w|v` + (1) `v|a` \\u2192 (11) `w|a`\\n(6) `w|v` + (3) `v|b` \\u2192 (12) `w|b`\\n\\nCombining (8), (11) and (12) shows that `w = gcd(v, c)` where `v = gcd(a, b)`, `w` divides all the input namely `a`, `b`, and `c`. This proves that `w` is a common divisor of `a`, `b`, and `c`.\\n\\n*Lemma II: Given `w = gcd(gcd(a, b), c)`, there can be no `x > w` such that `x` divides `a`, `b`, and `c`.*\\n\\nWhat is left to do now is to show that `w` is in fact the greatest value possible for `a`, `b`, and `c`. This easily follows using the definition of `gcd`:\\n\\n(5) There is no `n > v` such that `n|a` and `n|b` (from `v = gcd(a, b)`)\\n(7) `w \\u2264 v` as direct consequence of (6) (from `w = gcd(v, c)`)\\n(10) There is no `m > w` such that `m|v` and `m|c` (from `w = gcd(v, c)`)\\n\\nThese statement holds true by definition. Using these statements, the following premises can be derived:\\n\\n- Applying the boundary in (7) to (5) gives: (13) There is no `n > w` such that `n|a` and `n|b`\\n- Combining premise (13) with (10) gives: (14) **There is no `m > w` such that `m|v`, `m|a`, `m|b`, and `m|c`**\\n\\nTherefore, `w` is in fact the biggest value possible that can factor `a`, `b`, and `c`. \\u25A0\\n\\nBy combining the two lemma:\\nLemma I: Given `w = gcd(gcd(a, b), c)`, `w` divides `a`, `b`, and `c`.\\nLemma II: Given `w = gcd(gcd(a, b), c)`, there can be no `x > w` such that `x` divides `a`, `b`, and `c`.\\nit can be concluded that chaining 2-ary `gcd` function will output the greatest common divisor for all the input in question. That is,\\n\\n```\\ngcd(a, b, c, ...) = gcd(gcd(a, b), c, ...)\\n```\\n\\nUsing Hypothesis II, the core algorithm to solve the problem can be constructed by means of the following pseudocode,\\n\\n```c++\\nInput: nums - an array of integers\\n\\nlet hcf \\u2190 gcd(nums[1], nums[2])\\nfor i from 3 to nums.length:\\n\\thcf \\u2190 gcd(hcf, nums[i])\\nif hcf equal to 1:\\n\\treturn true\\nelse:\\n\\treturn false\\n```\\nVariation can be made, for example, to quit early when at one point it has been established that `hcf` is 1. The `gcd` function implementation can use the Euclidean Algorithm [4].\\n\\nReference:\\n[1] Bezout\\'s Identity, https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity (accessed at 24th May 2022)\\n[2] Properties of Divisibility, https://ccssmathanswers.com/properties-of-divisibility/ (accessed at 24th May 2022)\\n[3] Greatest Common Divisor, https://en.wikipedia.org/wiki/Greatest_common_divisor (accessed at 25th May 2022)\\n[4] Euclidean Algorithm, https://en.wikipedia.org/wiki/Euclidean_algorithm#Procedure (accessed at 25th May 2022)\\n\\n<small>Here\\'s hoping for LaTeX typesetting support</small>",
                "solutionTags": [],
                "code": "```c\\n29 / 8\\n```\n```c\\nq = floor(29 / 8)\\nq = 3\\n\\nr = 29 modulo 8\\nr = 5\\n```\n```c\\n29 = 3(q) * 8(d) + 5(r)\\n```\n```\\n29 \\u2261 5 (mod 8)\\n```\n```c\\n5 + 10\\n```\n```\\nThe congruence relation of the equation\\'s outcome\\n5 + 10 = 15\\n15 \\u2261 3 (mod 4)\\n\\nAdding each of the element\\'s congruence\\n5 \\u2261 1 (mod 4)\\n10 \\u2261 2 (mod 4)\\n1 (mod 4) + 2 (mod 4) = 3 (mod 4)\\n```\n```c\\n16 - 3\\n```\n```\\nThe congruence relation of the equation\\'s outcome\\n16 - 3 = 13\\n13 \\u2261 6 (mod 7)\\n\\nSubtracting each of the element\\'s congruence\\n16 \\u2261 2 (mod 7)\\n3 \\u2261 3 (mod 7)\\n2 (mod 7) - 3 (mod 7) = -1 (mod 7)\\n2 (mod 7) - 3 (mod 7) = 6 (mod 7)\\n```\n```c\\n20 * 16\\n```\n```c\\nThe congruence relation of the equation\\'s outcome\\n20 * 16 = 320\\n320 \\u2261 5 (mod 9)\\n\\nMultiplying each of the element\\'s congruence in the equation.\\n20 \\u2261 2 (mod 9)\\n16 \\u2261 7 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 14 (mod 9)\\n2 (mod 9) * 7 (mod 9) = 5 (mod 9)\\n```\n```\\ngcd(a, b) = 1\\n1 = ab + pq, for some integer pair (p, q)\\n```\n```\\ngcd(a, b) = ab + pq, for some integer pair (p, q)    -- (1)\\n```\n```\\nn \\u2261 0 (mod g)\\nn * x \\u2261 0 * x (mod g), for some integer x\\nnx \\u2261 0 (mod g), for some integer x\\n```\n```\\na + b \\u2261 (0 + 0) (mod g)\\na + b \\u2261 0 (mod g)\\n```\n```\\na - b \\u2261 (0 - 0) (mod g)\\na - b \\u2261 0 (mod g)\\n```\n```\\nv = c[1] * a + c[2] * gcd(m, n)    -- (2)\\n```\n```\\nv = c[1] * i[1] + c[2] * i[2] + ... + c[n] * i[n]\\nv = sum(c[x] * i[x]) for 1 \\u2264 x \\u2264 n    -- (3)\\n```\n```\\nv = c[1] * a + c[2] * gcd(m, n)\\nv = c[1] * a + c[2] * (mp + nq)   -- (applying (1))\\nv = c[1] * a + (p * c[2]) * m + (q * c[2]) * n\\nv = c[1] * a + p\\' * m + q\\' * n    -- (4)\\n```\n```\\nv = gcd(gcd(m, n), gcd(o, p))\\nv = gcd((c[m] * m + c[n] * n),(c[o] * o, c[p] * p))    -- (applying(1))\\nv = c[mn] * (c[m] * m + c[n] * n) + c[op] * (c[o] * o + c[p] * p) -- (applying (1))\\nv = c[mn] * c[m] * m + c[mn] * c[n] * n + c[op] * c[o] * o + c[op] * c[p] * p\\nv = (c[mn] * c[m]) * m + (c[mn] * c[n]) * n + (c[op] * c[o]) * o + (c[op] * c[p]) * p\\nv = c[mn,m] * m + c[mn,n] * n + c[op,o] * o + c[op,p] * p    -- (5)\\n```\n```\\ngcd(a, b) = v\\n```\n```\\ngcd(v, c) = w\\n```\n```\\ngcd(a, b, c, ...) = gcd(gcd(a, b), c, ...)\\n```\n```c++\\nInput: nums - an array of integers\\n\\nlet hcf \\u2190 gcd(nums[1], nums[2])\\nfor i from 3 to nums.length:\\n\\thcf \\u2190 gcd(hcf, nums[i])\\nif hcf equal to 1:\\n\\treturn true\\nelse:\\n\\treturn false\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 419532,
                "title": "b-zout-s-identity-gcd-calculation",
                "content": "Based on [B\\xE9zout\\'s identity](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity),\\nFor ints a and b, if gcd(a,b) = d, then there exists some x, y with a * x + b * y = d;\\n\\n```csharp\\npublic bool IsGoodArray(int[] nums) \\n{\\n\\tif(nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(nums.Length == 1)\\n\\t{\\n\\t\\treturn nums[0] == 1;\\n\\t}\\n\\n\\tint gcdResult = nums[0];        \\n\\tfor(int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tgcdResult = gcd(nums[i], gcdResult);\\n\\t\\tif(gcdResult == 1)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;        \\n}\\n\\nint gcd(int a, int b)\\n{\\n\\twhile(b != 0)\\n\\t{\\n\\t\\tint t = b;\\n\\t\\tb = a % b;\\n\\t\\ta = t;            \\n\\t}\\n\\n\\treturn a;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool IsGoodArray(int[] nums) \\n{\\n\\tif(nums == null || nums.Length == 0)\\n\\t{\\n\\t\\treturn true;\\n\\t}\\n\\n\\tif(nums.Length == 1)\\n\\t{\\n\\t\\treturn nums[0] == 1;\\n\\t}\\n\\n\\tint gcdResult = nums[0];        \\n\\tfor(int i = 1; i < nums.Length; i++)\\n\\t{\\n\\t\\tgcdResult = gcd(nums[i], gcdResult);\\n\\t\\tif(gcdResult == 1)\\n\\t\\t{\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t}\\n\\n\\treturn false;        \\n}\\n\\nint gcd(int a, int b)\\n{\\n\\twhile(b != 0)\\n\\t{\\n\\t\\tint t = b;\\n\\t\\tb = a % b;\\n\\t\\ta = t;            \\n\\t}\\n\\n\\treturn a;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314149,
                "title": "python-diophantine-equation",
                "content": "This is a multivariate linear [Diophantine equation](https://en.wikipedia.org/wiki/Diophantine_equation) with 1 on the right hand side. It has solution if and only if the gcd of all the numbers in nums divides 1, which means it must be 1. See [this math stack exchange post](https://math.stackexchange.com/questions/145346/diophantine-equations-with-multiple-variables) for detailed proof.\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1071677,
                "title": "simple-c-with-explanation",
                "content": "According to Euclid\\'s Theorem,\\n***If the GCD of two integers (a,b) is d, then there exists two integers x and y such that ax + by = d.***\\n\\nIf a,b,c... are the elements of the array we are calculating ax + by + cz...which gives hint that we have to use the above theorem.\\n\\nNow in this problem the d is given to be 1, which means the GCD should be 1.\\nSo instead of checking for all posiible subsets of the given array it is enough to check every pair (a,b).\\n***\"Does the array contain two integers a and b such that ax + by = 1 for some integers x,y ?\"***\\nOr the same question can be asked as\\n***\"Does the array contain two co-prime integers?\"***\\n\\nBut checking all pairs will have quadratic time complexity. We have to optimize it.\\n\\nNow what happens if we calculate the GCD of all the integers in the array ?\\nIf the array contains co-prime integers then the GCD of those two will become 1 and the GCD of 1 with the remaining n-2 integers will be 1 only.\\nBut if the array does not contain coprime integers then the GCD of all the integers will be greater than 1.\\n\\nSo the question reduces to\\n***\"Is the GCD of all the number in the array equal to 1?\"***\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        int GCD = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            GCD = __gcd(GCD, nums[i]);\\n        }\\n        \\n        return GCD == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        int GCD = nums[0];\\n        \\n        for (int i = 1; i < nums.size(); i++)\\n        {\\n            GCD = __gcd(GCD, nums[i]);\\n        }\\n        \\n        return GCD == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420523,
                "title": "c-explained-briefly",
                "content": "```\\nclass Solution {\\npublic:\\n /*   \\n    Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout\\'s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) . e.g. if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n */   \\n     bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n /*   \\n    Read (https://brilliant.org/wiki/bezouts-identity/, https://en.wikipedia.org/wiki/B\\xE9zout\\'s_identity)\\n\\nThe basic idea is that for integers a and b, if gcd(a,b) = d, then there exist integers x and y, s.t a * x + b * y = d;\\n\\nThis can be generalized for (n >= 2) . e.g. if gcd(a,b,c) = d, then there exist integers x, y, and z, s.t, a* x + b*y + c * z = d.\\n\\nNow this problem is just asking if gcd(x1, ......, xn) = 1\\n */   \\n     bool isGoodArray(vector<int>& A) {\\n        int res = A[0];\\n        for (int a: A)\\n            res = gcd(res, a);\\n        return res == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718093,
                "title": "java-gcd-solution",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1170548,
                "title": "c-explained-faster-than-90",
                "content": "In order to solve the problem, we need to search more about the **first** hint:\\n```\\nEq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\n```\\nif we found **ANY two numbers** that has a ` gcd(a,b)=1`, then ANY added numbers won\\'t change the fact that gcd will results at max of 1! \\nthat is :`gcd(a,b,c,d,e)=1 if gcd(a,e)=1`\\nSo find If that\\'s possible and **return if that\\'s possible**.\\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b%a, a);\\n}\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int prevGCD=nums[0];\\n        for(int i=1;i<n;i++)\\n        {prevGCD=gcd(prevGCD,nums[i]);\\n        }\\n        return prevGCD==1;\\n    }\\n```\\nIf you **like** my explanation, **hit** the **Upvote**  button and If you **don\\'t**, **hit** the **Downvote** \\uD83E\\uDD73\\nand If you have ANY questions, feel free to ask them down below \\uD83D\\uDC47",
                "solutionTags": [],
                "code": "```\\nEq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\n```\n```\\nint gcd(int a, int b)\\n{\\n    if (a == 0)\\n        return b;\\n    return gcd(b%a, a);\\n}\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int prevGCD=nums[0];\\n        for(int i=1;i<n;i++)\\n        {prevGCD=gcd(prevGCD,nums[i]);\\n        }\\n        return prevGCD==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621142,
                "title": "return-gcd-nums-1-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for(auto &i: nums){\\n            g = __gcd(i,g);\\n            if(g==1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for(auto &i: nums){\\n            g = __gcd(i,g);\\n            if(g==1)return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716855,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```\\n**Please upvote if u like it**",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554007,
                "title": "math-fact-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcd(b, a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        // if there are 2 integers, a and b such that gcd(a, b) = d, then there exists integers x, y, such that a*x + b*y = d;\\n        int g = nums[0];\\n        for(auto it:nums)\\n            g = gcd(g, it);\\n        return g == 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int gcd(int a, int b)\\n    {\\n        if(b == 0)\\n            return a;\\n        return gcd(b, a%b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2393710,
                "title": "c-solution-simple-and-easy",
                "content": "class Solution {\\npublic:\\n\\n    // if we choose any two elements from the array:\\n\\t// if the gcd is 1 then the required condition is true and\\n\\t// if gcd is not equal to 1 then the condition will never satisfy\\n\\t// its an observation, so don\\'t get confused ( like an AXIOM )\\n\\t// you can dry run the given test cases to confirm\\n\\t\\n    int gcd(int a, int b){\\n        while (a%b != 0){\\n            int rem=a%b;\\n            a=b;\\n            b=rem;\\n        }\\n        return b;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = 0;\\n        for(int i=0; i<n; i++){\\n            a = gcd(a,nums[i]);\\n            if(a==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    // if we choose any two elements from the array:\\n\\t// if the gcd is 1 then the required condition is true and\\n\\t// if gcd is not equal to 1 then the condition will never satisfy\\n\\t// its an observation, so don\\'t get confused ( like an AXIOM )\\n\\t// you can dry run the given test cases to confirm\\n\\t\\n    int gcd(int a, int b){\\n        while (a%b != 0){\\n            int rem=a%b;\\n            a=b;\\n            b=rem;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1387290,
                "title": "solution-with-derivation-and-explaination",
                "content": "consider ax + by = 1\\nAssuming integer solution exists then \\n\\nwe can take out the common divisor of a and b. \\nThe gcf is the greatest common divisor of a and b.\\n\\ntherefor ax + by = gcf(a,b) * ( (a/gcf) * x + (b/gcf) * y ) = 1\\n\\nsince gcf divides a we can rewrite a as a = gcf * a1 .. where a1 is some integer\\nsimilarly b = gcf * b1.. where b1 is some integer\\n\\nso ax + by = gcf * ( a1 * x + b1 * y ) = 1\\n\\ndividing both sides by gcf we get\\n\\na1 * x + b1 * y = 1 / gcf\\n\\nNow LHS is a integer because (a1, b1, x, y ) are all integer values. and LHS = RHS. Therefore 1/gcf should also be an integer. This is only possible when gcf = 1. For all other values 1/gcf will not be an integer.\\nAlso if (x,y) integer solutions don\\'t exist the condition won\\' t be valid.\\n\\nTherefor ax + by = 1 only if gcf(a,b) = 1\\n\\nFor n variables as given in the question similar logic can be used to take out gcf( a, b, c , d .... ) common from LHS and we get gcf(a,b,c,d ... ) = 1 as the condition.\\n\\nOne must realise that the subarray simply means taking the 0 as the multiplicative coefficients for number not included.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd = nums[0];\\n        for( auto e : nums ){\\n            gcd = __gcd( gcd, e );\\n        }\\n        \\n        return gcd == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd = nums[0];\\n        for( auto e : nums ){\\n            gcd = __gcd( gcd, e );\\n        }\\n        \\n        return gcd == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1376227,
                "title": "c-simple-soln-4-lines",
                "content": "```\\n  //aX + bY = k has __integer solution__ (X, Y) if k is multiple of gcd(a, b)\\n    //here k=1 so __gcd should be 1\\n    //Subset has gcd 1 == whole array should have 1\\n    bool isGoodArray(vector<int>& nums) {\\n        int k=nums[0];\\n        for(auto i:nums){\\n            k=__gcd(k,i);\\n        }\\n        return k==1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  //aX + bY = k has __integer solution__ (X, Y) if k is multiple of gcd(a, b)\\n    //here k=1 so __gcd should be 1\\n    //Subset has gcd 1 == whole array should have 1\\n    bool isGoodArray(vector<int>& nums) {\\n        int k=nums[0];\\n        for(auto i:nums){\\n            k=__gcd(k,i);\\n        }\\n        return k==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309095,
                "title": "1250-true-if-gcd-array-is-1-use-co-primes-existence-for-early-exit",
                "content": "---\\n\\nHard to see at first, and its pure math\\nA long one coming, below :)\\n\\n---\\n\\n**Algo**\\n\\n- `1 <= nums[i] <= 10^9` So array elements are always +ve\\n- For `[1]` or `[1,2,3]` or `[1,5,10,15,20]` array is good\\n  - because we have  subset as `[ 1 ]` & multiplicand as `1`, so our sum (after multiplying with each element of array with some multiplicand is `1*1`) is `1`\\n- For `[5,10,15,20]`, array is not good\\n  - because we dont have 1 as element\\n  - so some of elements must have `-ve` numbers as `multiplicand`\\n    - but even after having them, for example `5*-2 + 10*1`, it comes to `0`\\n    - this is because they are all multiples of a number (`5` in this case)\\n      - but we need `1`\\n      - so picking multiples of number won\\'t help\\n      - and picking `co-primes` will help\\n  - Now we know `co-primes` will help\\n   - Some exampels are `[5,7]` , `[5,11]` , `[7,37]`\\n     - It\\'s easy to see that the gcd of 1st two is `1`, also it is also for last one\\n       - But is it working really? `5*3 + 7*-2 = 1`, `5*-2 + 11*1 = 1`, `-7*21 + 4*37 = 1`, yes, it is working\\n  - So, we know that if `gcd` is 1 then it is working\\n- But what about `[5,10,15,20, 7]`?\\n  - Here there some numbers are multiples of `5`, also `5 & 7` are `co-prime`\\n    - Since we can take subset, we can take `[5,7]` and they are co-prime (`gcd = 1`), we its good\\n      - How? Same as above `5*3 + 7*-2 = 1`\\n      - So, effectively both `[5,10,15,20, 7]` and `[5,7]` are same\\n        - In other words, if we have 2 prime numbers, then we are done, or if we have two co-primes we are good\\n        - Is `[5,7]` is good - yes, why? `5 & 7 are co-prime` (that is `gcd = 1`)\\n        - Is `[3,4]` is good - yes, why? `3 & 4 are co-prime` (that is `gcd = 1`)\\n        - Is `[10,8]` is good - No, why? `10 & 8 are Not co-prime`, because they have a prime number `2` as common factor (that is `gcd = 2`)\\n- So can I stop going ahead once I found 2 co-primes? yes\\n  - `[8,9,100,200,300,400,500,600]` is same as `[8,9]`, as 8 & 9 are co-prime we don\\'t need to look at `100, 200..`\\n  - [9,100,200,300,400,500,600] is same as `[9,100]` yes they are `3*3` and `2*2*5*5` but there are no common factors with each other (`co-prime`), their only common factor is `1` (`gcd=1`), (`gcf=hcf=gcd=1`)\\n    - So we can exit as soon as we find `two co-primes` (`gcd=1`)\\n      - see last solution below for early exit\\n- Why is `[6,10,15]` a kind of special test case?\\n    - But `6*1 + 10*-2 + 15*1 = 1`\\n    - gcd of 6, 10, and 15 is 1\\n    - but there are no `co-primes`\\n      - `co-primes` if present then good, but may not present too but good array for our question\\n      - so `gcd is 1` can be trusted always, use and `co-primes` existence can be used for early exit\\n- Want more? :)\\n  - Check gcd properties here - https://en.wikipedia.org/wiki/Greatest_common_divisor#Properties\\n    - Especially, see the closest one - 2nd property in above link - `B\\xE9zout\\'s identity`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n    return A.reduce((g, n) => gcd(g, n)) === 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/78b5db46-0a7e-4363-8dcc-c8a64de61bcc_1625144278.6591823.png)\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    return A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c3f41dd7-ca8a-4da5-9663-5b428cb47bbd_1625144313.7914488.png)\\n\\n---\\n\\n```\\nvar isGoodArray = (A) => A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93ab86ee-88be-4323-8f1a-6c8ac1e948ba_1625144355.069614.png)\\n\\n---\\n\\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n\\n    let g = A[0];\\n    for (let n of A) {\\n        g = gcd(g, n);\\n        if (g === 1)\\n            return true;    // early exit\\n    }\\n    return false;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/aafe287e-a5ce-43e1-be5a-86fd66a49161_1625146895.2639222.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n    return A.reduce((g, n) => gcd(g, n)) === 1;\\n};\\n```\n```\\nvar isGoodArray = function (A) {\\n    return A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n};\\n```\n```\\nvar isGoodArray = (A) => A.reduce((gcd = (a, b) => (b ? gcd(b, a % b) : a))) === 1;\\n```\n```\\nvar isGoodArray = function (A) {\\n    const gcd = (a, b) => (b ? gcd(b, a % b) : a);\\n\\n    let g = A[0];\\n    for (let n of A) {\\n        g = gcd(g, n);\\n        if (g === 1)\\n            return true;    // early exit\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669614,
                "title": "java-solution-0ms",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int t = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            t = gcd(nums[i], t);\\n            if (t == 1)\\n                return true;\\n            \\n        }\\n        return false;\\n    }\\n\\n    public int gcd(int a, int b) {\\n        if (a < b)\\n            return gcd(b, a);\\n        return a % b == 0 ? b : gcd(b, a % b);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int t = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            t = gcd(nums[i], t);\\n            if (t == 1)\\n                return true;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 665035,
                "title": "c-simple-gcd-solution-60",
                "content": "Uses inbuilt GCD function and checks if the gcd of array is 1 or not.\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 0) return false;\\n        else {\\n            int g = nums[0];\\n            for(int i=1; i<nums.size(); i++) {\\n                g = __gcd(g, nums[i]);\\n            }\\n            if (g == 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n        if (nums.size() == 0) return false;\\n        else {\\n            int g = nums[0];\\n            for(int i=1; i<nums.size(); i++) {\\n                g = __gcd(g, nums[i]);\\n            }\\n            if (g == 1) return true;\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3418220,
                "title": "hand-written-easy-explanation-with-b-zout-s-lemma",
                "content": "\\n![image.png](https://assets.leetcode.com/users/images/71d340ad-c7ae-4256-940b-799a2ffd6ae5_1681532564.9413595.png)\\n![image.png](https://assets.leetcode.com/users/images/4a52e4c5-59ed-4bed-9e2d-557a9669e1ae_1681532580.7018669.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        ans=nums[0]\\n        for i in range (1,len(nums)):\\n            ans=math.gcd(ans,nums[i])\\n        return ans==1\\n```\\n\\nPlease Upvote the solution is you like it.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        ans=nums[0]\\n        for i in range (1,len(nums)):\\n            ans=math.gcd(ans,nums[i])\\n        return ans==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864105,
                "title": "java-solution-easy-to-understand-code",
                "content": "\\nSimple gcd calculation program.\\n\\n\\n```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689665,
                "title": "java-sol-using-bezout-s-identity",
                "content": "# Explanation:\\n\\n*Bezout\\'s Identity*\\n        \\n        let a and b be integers with greatest common divisor as d\\n        then there exist integers x and y such that ax + by = d\\n        \\n        In Example 1,\\n\\n        a=5, x=3, b=7, y=-2\\n        So, 5*3 + 7*(-2) = 1\\n        \\n        \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       \\n\\n        //Basically check for GCD and return true if its 1\\n\\n        int x = nums[0], y;\\n        for(int a : nums){\\n        while(a > 0){\\n          y = x%a;\\n          x = a;\\n          a = y;\\n         }\\n    }\\n\\n        return x == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       \\n\\n        //Basically check for GCD and return true if its 1\\n\\n        int x = nums[0], y;\\n        for(int a : nums){\\n        while(a > 0){\\n          y = x%a;\\n          x = a;\\n          a = y;\\n         }\\n    }\\n\\n        return x == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473760,
                "title": "linear-diophantine-equation",
                "content": "Read the first answer and you can solve this problem.\\nhttps://math.stackexchange.com/questions/145346/diophantine-equations-with-multiple-variables\\n\\nAs a side note, this equation is also used in the two water jars problem (https://leetcode.com/problems/water-and-jug-problem/). Also, this is one of the most frequently used mathematics concept (along with sieve) in Codeforces/coding contests in general, so it\\'s worth learning. \\n\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int hcf = nums[0];\\n        for (auto x: nums)\\n            hcf = gcd(x, hcf);\\n        return hcf == 1;\\n    }\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nbool isGoodArray(vector<int>& nums) {\\n        int hcf = nums[0];\\n        for (auto x: nums)\\n            hcf = gcd(x, hcf);\\n        return hcf == 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080282,
                "title": "not-to-worry-about",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& a) \\n    {\\n        int g=0;\\n        for(int i=0;i<(int)a.size();i++)\\n            g=__gcd(g,a[i]);\\n        if(g>1) return 0;\\n        else return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& a) \\n    {\\n        int g=0;\\n        for(int i=0;i<(int)a.size();i++)\\n            g=__gcd(g,a[i]);\\n        if(g>1) return 0;\\n        else return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1851649,
                "title": "c-one-line-o-n-bezout-s-lemma",
                "content": "We just need to check that GCD of all numbers is 1 (follows from Bezout\\'s Lemma).\\n```C++\\nbool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [] (int a, int b) {return __gcd(a, b);}) == 1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```C++\\nbool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [] (int a, int b) {return __gcd(a, b);}) == 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1797525,
                "title": "java-solution-gcd-approach",
                "content": "```\\nclass Solution {\\n    \\n    public int gcd(int a, int b) {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int ans = nums[0];\\n        for (int element: nums){\\n            ans = gcd(ans, element);\\n            if(ans == 1){\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int gcd(int a, int b) {\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int ans = nums[0];\\n        for (int element: nums){\\n            ans = gcd(ans, element);\\n            if(ans == 1){\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638131,
                "title": "simple-explanation-for-noobs-like-me",
                "content": "in this problem i simply thought that we have to select some elements and after some interger multipication my result should be 1  now let say we have selected some elements\\n\\n\\n\\n\\n\\nnow we have 2 cases\\ncase1: -hcf of selected elements==1\\n\\ncase2:- hcf of selected elements!=1\\n\\nin case 2 we can take some intezer common let set we select \\n(a,b,c,d)\\nafter taking hcf common let say h\\nh(a1,b1,c1,d1)   here h !=1(case2) \\'\\nwe can easily say that whatever multiplication(with int) we make on a1,b1,c1,d1 we can\\'t make it a fraction (as the result  is always intezer) so the expression we can,t make it 1 as h>1 \\n\\nlow let say we are given an arr\\narr={ 6, 8, 12, 14, 3,  9, 15}\\'\\n\\'\\nnow let say we select element 6 8 and 12 we can easily see hcf is 2\\nso we can write it as  2( 3 , 4,  6) now whatever operation we make on 3,4,6  we can,t make it 1/2 for sure so we can\\'t make the expression as 1\\n\\n\\n\\n\\nbut in case 1 we can make it 1 i don\\'t know the reason for this !!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int hcf(int a,int b)\\n    {\\n        if(a==0)return b;\\n        \\n        if(a>b)return hcf(b,a);\\n        \\n        return hcf(b%a,a);   \\n    }\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n       \\n        bool ans=false;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums[0]==1;\\n        }\\n        \\n        \\n        \\n        \\n        int h=hcf(nums[0],nums[1]);\\n        \\n        if(h==1)return true;\\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            h=hcf(h,nums[i]);\\n            \\n            if(h==1)\\n            {\\n                ans=true;\\n                break;\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int hcf(int a,int b)\\n    {\\n        if(a==0)return b;\\n        \\n        if(a>b)return hcf(b,a);\\n        \\n        return hcf(b%a,a);   \\n    }\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n       \\n        bool ans=false;\\n        \\n        if(nums.size()==1)\\n        {\\n            return nums[0]==1;\\n        }\\n        \\n        \\n        \\n        \\n        int h=hcf(nums[0],nums[1]);\\n        \\n        if(h==1)return true;\\n        \\n        for(int i=2;i<nums.size();i++)\\n        {\\n            h=hcf(h,nums[i]);\\n            \\n            if(h==1)\\n            {\\n                ans=true;\\n                break;\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577844,
                "title": "c-o-n-with-explanations",
                "content": "Since the GCD is an associative function, we have\\n* gcd(a<sub>0</sub>, a<sub>1</sub>,...,a<sub>n - 1</sub>) = gcd(a<sub>0</sub>, gcd(a<sub>1</sub>,...,a<sub>n-1</sub>) = gcd(gcd(a<sub>0</sub>, a<sub>1</sub>), gcd(a<sub>2</sub>,...,a<sub>n-1</sub>)) = ...\\n\\nand so on, every possible combination is included. So we just have to iterate through `nums` until we find a gcd of `1`. In other world, if gcd(a<sub>0</sub>, a<sub>1</sub>,...,a<sub>n - 1</sub>) = 1, there exist a subsequence a<sub>i<sub>j</sub></sub> with #{a<sub>i<sub>0</sub></sub>,...,a<sub>i<sub>k</sub></sub>} = k, 1 <= k <= n, that give a gcd of `1.`\\n\\n```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 and nums[0] == 1) return true;\\n        int gcd = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(i == 0) gcd = nums[i];\\n            else {\\n                gcd = __gcd(gcd, nums[i]);\\n                if(gcd == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 and nums[0] == 1) return true;\\n        int gcd = 0;\\n        for(int i = 0; i < nums.size(); ++i) {\\n            if(i == 0) gcd = nums[i];\\n            else {\\n                gcd = __gcd(gcd, nums[i]);\\n                if(gcd == 1) return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489417,
                "title": "this-problem-is-about-chinese-remainder-theorem",
                "content": "If gcd(a1, a2, ..., an) =1, there exist integers x1, ..., xn such that a1*x1 + .... + an *xn = 1\\nhttps://en.wikipedia.org/wiki/Chinese_remainder_theorem\\n\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        import math \\n        n = len(nums)\\n        if n ==1:\\n            return nums[0] ==1\\n        d = math.gcd(nums[0], nums[1])\\n        for i in range(n):\\n            d = math.gcd(nums[i], d)\\n        return d ==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        import math \\n        n = len(nums)\\n        if n ==1:\\n            return nums[0] ==1\\n        d = math.gcd(nums[0], nums[1])\\n        for i in range(n):\\n            d = math.gcd(nums[i], d)\\n        return d ==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081527,
                "title": "solution-in-java-100-faster",
                "content": "hint - Finding gcd of numbers in the given array, if (gcd==1) then return true.(i.e. it is a good array); else return false.\\n```\\nclass Solution {\\n    public int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length==1){\\n            if(nums[0]!=1)\\n                return false;\\n            else\\n                return true;\\n        }\\n        int res=gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            res=gcd(res,nums[i]);\\n        }\\n        return (res==1)?true:false;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int gcd(int a, int b){\\n        if(a==0)\\n            return b;\\n        return gcd(b%a,a);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length==1){\\n            if(nums[0]!=1)\\n                return false;\\n            else\\n                return true;\\n        }\\n        int res=gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            res=gcd(res,nums[i]);\\n        }\\n        return (res==1)?true:false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526154,
                "title": "python-sol-by-g-c-d-b-zout-lemma-90-w-hint",
                "content": "Python sol by Greatest Common Divisor & B\\xE9zout Lemma\\n\\n---\\n\\n**Hint**:\\n\\nRecall that for integer a, b\\naX + bY = k has integer solution (X, Y) if k is multiple of gcd(a, b) from **[B\\xE9zout lemma](https://proofwiki.org/wiki/B\\xE9zout\\'s_Lemma)**\\n\\nIn addition, [description](https://leetcode.com/problems/check-if-it-is-a-good-array/) sets k = 1, which means gcd(a,b) | 1.\\ngcd(a,b) | 1\\n=> gcd(a,b) = 1\\n=> **a, b** is **co-prime**.\\n\\nNow, back to question itself.\\n\\nIf **gcd( all integers in given array) = 1**, then there exist at least one subset (a, b) satisfies aX + bY = 1. \\nTherefore, input is a **good array**.\\n\\nOtherwise, there is no solution.\\nAnd input is Not a good Array.\\n\\n---\\n\\n**Bezout Lemma**:\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1583116964.png)\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        \\n        # ax + by = 1 has integer solution only when gcd(a, b) == 1\\n        \\n        x = nums[0]\\n        \\n\\t\\t# compute the greatest common divisor for all input integers\\n        for number in nums:\\n            \\n            x = gcd(x, number)\\n            \\n        \\n        return x == 1\\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki Proof: B\\xE9zout\\'s Lemma](https://proofwiki.org/wiki/B\\xE9zout\\'s_Lemma)\\n\\n[2] [Python official docs about math.gcd()](https://docs.python.org/3/library/math.html?highlight=gcd#math.gcd)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        \\n        # ax + by = 1 has integer solution only when gcd(a, b) == 1\\n        \\n        x = nums[0]\\n        \\n\\t\\t# compute the greatest common divisor for all input integers\\n        for number in nums:\\n            \\n            x = gcd(x, number)\\n            \\n        \\n        return x == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268418,
                "title": "java-beginner-friendly-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930567,
                "title": "easiest-one-liner-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the GCD of all the elements of the array is equal to 1, return **True**\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\n- Space complexity: **O(1)**\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if math.gcd(*nums)==1 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if math.gcd(*nums)==1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496784,
                "title": "c-gcd-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        //using diophantine equation approach\\n        //we have to select subset which has gcd of 1\\n        //so we have to give only whether we are able to select such subset that has gcd=1\\n        //so if such subset has gcd = 1 so the all element has also gcd having 1. if all element having gcd than only can return true otherwise return false\\n        int g = nums[0];\\n        for(auto i:nums){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        //using diophantine equation approach\\n        //we have to select subset which has gcd of 1\\n        //so we have to give only whether we are able to select such subset that has gcd=1\\n        //so if such subset has gcd = 1 so the all element has also gcd having 1. if all element having gcd than only can return true otherwise return false\\n        int g = nums[0];\\n        for(auto i:nums){\\n            g = __gcd(g,i);\\n        }\\n        if(g==1) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250203,
                "title": "c-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            n = __gcd(n,nums[i]);\\n            if(n == 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = 0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            n = __gcd(n,nums[i]);\\n            if(n == 1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243805,
                "title": "fully-explained-gcd-co-prime-cpp",
                "content": "Intuition here is to get a set from nums whose gcd=1 as if gcd(a,b)==1 then there exist atleast one multiple of a & b whose difference is 1:)\\n\\nSo in order to check this, we can simply check the gcd of whole list because if there exist a single co-prime pair then gcd of list will be 1.\\n\\nPFB my code for your reference:\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n \\xA0 \\xA0 \\xA0 \\xA0/// if(n==1) return nums[0]==1;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n            ans=__gcd(ans,nums[i]);\\n        return ans==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n \\xA0 \\xA0 \\xA0 \\xA0/// if(n==1) return nums[0]==1;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n            ans=__gcd(ans,nums[i]);\\n        return ans==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2179378,
                "title": "bezout-s-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //bezout\\'s algorithm\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==1){\\n            return true;\\n        }\\n        int num = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            num = __gcd(num,nums[i]);\\n            if(num==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //bezout\\'s algorithm\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 && nums[0]==1){\\n            return true;\\n        }\\n        int num = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            num = __gcd(num,nums[i]);\\n            if(num==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957874,
                "title": "java-best-approach",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n            if(gcd==1)return true;\\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int a, int b) {\\n   if (b==0) return a;\\n   return gcd(b,a%b);\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n            if(gcd==1)return true;\\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int a, int b) {\\n   if (b==0) return a;\\n   return gcd(b,a%b);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713329,
                "title": "linear-combination-possible-if-subset-with-gcd-1-exists",
                "content": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        curr = nums[0]\\n        for i in range(1, n):\\n            curr = self.gcd(curr, nums[i])\\n            if curr == 1:\\n                return True\\n        return curr == 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        while b:\\n            a, b = b, a % b\\n        return a\\n    \\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        curr = nums[0]\\n        for i in range(1, n):\\n            curr = self.gcd(curr, nums[i])\\n            if curr == 1:\\n                return True\\n        return curr == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648447,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    // O(N) Time | O(1) Space\\n    // If GCD of all the elements is 1, the array is a good array\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int result = 0;\\n        for (int element: nums){\\n            result = gcd(result, element);\\n            if(result == 1)\\n            {\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // O(N) Time | O(1) Space\\n    // If GCD of all the elements is 1, the array is a good array\\n    \\n    public boolean isGoodArray(int[] nums) {\\n        int result = 0;\\n        for (int element: nums){\\n            result = gcd(result, element);\\n            if(result == 1)\\n            {\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    int gcd(int a, int b) {\\n        if(a == 0) {\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629347,
                "title": "python3-one-liner",
                "content": "The minimum difference that can be created by manipulating two numbers in a way given by the question is equal to the greatest common divisor of the two numbers. \\n\\nFor example : \\n```\\nnums = [12,18]\\ngcd(12,18) = 6\\n```\\nTherefore the minimum difference after manipulating the numbers would be 6.\\n\\nFor this problem, we need to find whether the gcd of any two numbers in `nums`  is 1\\n--> gcd(nums) == 1\\n\\n**Python3 One Liner:**\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums) == 1\\n```",
                "solutionTags": [],
                "code": "```\\nnums = [12,18]\\ngcd(12,18) = 6\\n```\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1459690,
                "title": "c-easy-solution-space-lesser-than-97",
                "content": "We know there exists a solution for `ax+by =1` when there exists a , b such that their hcf is 1.\\nIf we find 2 nums whose hcf is 1 we `return true;` else `return false;` .\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(!n) return false;\\n        int hcf=nums[0];\\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            hcf=__gcd(hcf,nums[i]);\\n        }\\n\\t\\t\\n        return hcf==1;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "We know there exists a solution for `ax+by =1` when there exists a , b such that their hcf is 1.\\nIf we find 2 nums whose hcf is 1 we `return true;` else `return false;` .\\n```\\nbool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        if(!n) return false;\\n        int hcf=nums[0];\\n\\t\\t\\n        for(int i=1;i<n;i++){\\n            hcf=__gcd(hcf,nums[i]);\\n        }\\n\\t\\t\\n        return hcf==1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1008334,
                "title": "c-1-line",
                "content": "```\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), nums[0], gcd<int,int>) == 1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), nums[0], gcd<int,int>) == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980100,
                "title": "python-3-9-solution",
                "content": "Python 3.9 allows math.gcd() to take an iterable: \\nmath.gcd(*integers)\\nReturn the greatest common divisor of the specified integer arguments. If any of the arguments is nonzero, then the returned value is the largest positive integer that is a divisor of all arguments. If all arguments are zero, then the returned value is 0. gcd() without arguments returns 0.\\n\\nNew in version 3.5.\\nChanged in version 3.9: Added support for an arbitrary number of arguments. Formerly, only two arguments were supported.\\n\\nLeetcode has been using Python 3.9 since 2020-10-20.\\n\\nSo, Python 3.9 solution is the simplest code that you may have for a \"hard\" problem:\\n```\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return math.gcd(*nums) == 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return math.gcd(*nums) == 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 928490,
                "title": "go-gcd",
                "content": "Runtime: 36 ms, faster than 100.00% of Go online submissions for Check If It Is a Good Array.\\nMemory Usage: 8.8 MB, less than 100.00% of Go online submissions for Check If It Is a Good Array.\\n\\n```\\nfunc isGoodArray(nums []int) bool {\\n    t := nums[0]\\n    \\n    for _, num := range nums{\\n        t = gcd(num, t)\\n        if t == 1{\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc gcd (a,b int) int{\\n    if a < b{\\n        return gcd(b,a)\\n    }\\n    \\n    if a % b == 0{\\n        return b\\n    }\\n    \\n    return gcd(b, a%b)\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "Runtime: 36 ms, faster than 100.00% of Go online submissions for Check If It Is a Good Array.\\nMemory Usage: 8.8 MB, less than 100.00% of Go online submissions for Check If It Is a Good Array.\\n\\n```\\nfunc isGoodArray(nums []int) bool {\\n    t := nums[0]\\n    \\n    for _, num := range nums{\\n        t = gcd(num, t)\\n        if t == 1{\\n            return true\\n        }\\n    }\\n    \\n    return false\\n}\\n\\nfunc gcd (a,b int) int{\\n    if a < b{\\n        return gcd(b,a)\\n    }\\n    \\n    if a % b == 0{\\n        return b\\n    }\\n    \\n    return gcd(b, a%b)\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 895652,
                "title": "c-just-find-two-co-primes-bezout-s-identity-explained",
                "content": "```\\n// Bezout\\'s identity\\n// Let a and b be integers with greatest common divisor d.\\n// Then, there exist integers x and y such that ax + by = d.\\n// In our case, we just have two find two numbers such that they are co-prime, i.e. their gcd=1\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int g=nums[0];\\n        for (int i=1;i<n;i++){\\n            g=__gcd(g,nums[i]);\\n\\t\\t\\t// If there are two co-primes then the entire array is co-prime\\n            if (g==1) return true;\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Bezout\\'s identity\\n// Let a and b be integers with greatest common divisor d.\\n// Then, there exist integers x and y such that ax + by = d.\\n// In our case, we just have two find two numbers such that they are co-prime, i.e. their gcd=1\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int g=nums[0];\\n        for (int i=1;i<n;i++){\\n            g=__gcd(g,nums[i]);\\n\\t\\t\\t// If there are two co-primes then the entire array is co-prime\\n            if (g==1) return true;\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 665610,
                "title": "very-easy-solution-c-with-explanation",
                "content": "Firstly if we have a subset with gcd 1 then we can find the proper multiplicand which will make that subset equal to 1, so we need to check whether there exists a subset with gcd equal to 1 or not... Now if a subset has gcd 1 then if we add an element to it, it\\'s gcd remains 1  so that means if a subset has gcd 1 then whole array has also gcd 1,  so check the gcd of whole array if it\\'s 1 then possible otherwise not possible..\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(!nums.size()) return false;\\n        if(nums.size()==1) return nums[0]==1;\\n        int g=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            g=gcd(g,nums[i]);\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a,int b){\\n        if(b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(!nums.size()) return false;\\n        if(nums.size()==1) return nums[0]==1;\\n        int g=nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            g=gcd(g,nums[i]);\\n        }\\n        return g==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590623,
                "title": "javascript-and-c-solutions",
                "content": "**Thoughts and Intuition:**\\n\\nWhen I first read this problem, I thought there\\'s no way I can check every possible combination without TLE.  So I started looking for a pattern for a potential math solution.  I first noticed example 1 results in `true` with prime numbers `5` and `7` as input, and example 3 results in `false` with non-prime numbers `3` and `6` as input.  However, example 2 results in `true` with non-prime numbers also.  So I thought maybe GCD would work, and indeed it did!  After I solved this problem, I read about [Bezout\\'s Identity in this post](https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419324/Bezout\\'s-Identity).\\n\\n---\\n\\n*Javascript*\\n```\\nlet isGoodArray = (A, gcd = (a, b) => !b ? a : gcd(b, a % b)) => {\\n    let x = A.shift();\\n    A.forEach(y => x = gcd(x, y));\\n    return x == 1;\\n};\\n```\\n\\n---\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isGoodArray(VI& A, bool good = false) {\\n        auto x = A.back(); A.pop_back();\\n        for_each(A.begin(), A.end(), [&](auto y) { x = gcd(x, y); });\\n        return x == 1;\\n    }\\nprivate:\\n    int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet isGoodArray = (A, gcd = (a, b) => !b ? a : gcd(b, a % b)) => {\\n    let x = A.shift();\\n    A.forEach(y => x = gcd(x, y));\\n    return x == 1;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    bool isGoodArray(VI& A, bool good = false) {\\n        auto x = A.back(); A.pop_back();\\n        for_each(A.begin(), A.end(), [&](auto y) { x = gcd(x, y); });\\n        return x == 1;\\n    }\\nprivate:\\n    int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538995,
                "title": "java-100-time-and-space-with-solution-explanation",
                "content": "Let a[] be the array of values and b[] be the array of constants such that\\nsigma( a[i]*b[i] ) =1 for 0 <= i < n.\\n\\nThis is equivalent to solving gcd( a[0], a[1] )*Y + sigma( a[i]*b[i]) = 1 for 2 <= i < n for some constant Y.\\n\\nWe simply reduced the problem from N to N-1. You can apply this recursively to solve the problem.\\n\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] a) {\\n        int ans=a[0];\\n        for(int t : a){\\n            if(ans==1) break;\\n            ans = gcd(ans, t);\\n        }\\n        return ans==1 ? true: false;\\n    }\\n    \\n    private int gcd( int a, int b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] a) {\\n        int ans=a[0];\\n        for(int t : a){\\n            if(ans==1) break;\\n            ans = gcd(ans, t);\\n        }\\n        return ans==1 ? true: false;\\n    }\\n    \\n    private int gcd( int a, int b) {\\n        if( a < b) return gcd(b,a);\\n        if( b == 0 ) return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489065,
                "title": "scala-explained-by-by-chinese-remainder-theorem-additive-property",
                "content": "Additive property: if a==f (mod d), b==f (mod d), then it must be true that (x*a + y*b)==f (mod d)\\n\\nSo when we think of (x*a + y*b) mod d, and set the f ==0, then, there must be k=[1...d-1] ranges, which can map (x*a + y*b)/k to this range. Thus there must be a (x\\'*a + y\\'*b)==1 always existed. \\n\\n\\n```\\n  def isGoodArray(nums: Array[Int]): Boolean = {\\n    var res = nums(0)\\n\\n    def gcd(a: Int, b: Int): Int = {\\n      if (b == 0) return a\\n      gcd(b, a % b)\\n    }\\n\\n    for (i <- 1 to nums.length - 1) res = gcd(res, nums(i))\\n    res == 1\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def isGoodArray(nums: Array[Int]): Boolean = {\\n    var res = nums(0)\\n\\n    def gcd(a: Int, b: Int): Int = {\\n      if (b == 0) return a\\n      gcd(b, a % b)\\n    }\\n\\n    for (i <- 1 to nums.length - 1) res = gcd(res, nums(i))\\n    res == 1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 422940,
                "title": "java",
                "content": "```\\n// O(n)\\n// O(1)\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0 || nums == null) {\\n            return false;\\n        }\\n        \\n        int k = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            k = GCD(k, nums[i]);\\n            if (k == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int GCD(int m, int n) {\\n        if (m < n) {\\n            return GCD(n, m);\\n        }\\n        \\n        while (n != 0) {\\n            int k = m % n;\\n            m = n;\\n            n = k;        \\n        }\\n        return m;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// O(n)\\n// O(1)\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if (n == 0 || nums == null) {\\n            return false;\\n        }\\n        \\n        int k = nums[0];\\n        for (int i = 0; i < nums.length; i++) {\\n            k = GCD(k, nums[i]);\\n            if (k == 1) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    public int GCD(int m, int n) {\\n        if (m < n) {\\n            return GCD(n, m);\\n        }\\n        \\n        while (n != 0) {\\n            int k = m % n;\\n            m = n;\\n            n = k;        \\n        }\\n        return m;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 420007,
                "title": "python3-one-line",
                "content": "Calculate the GCD of all numbers in this array.\\n```\\nfrom math import gcd\\nfrom functools import reduce\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nfrom functools import reduce\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419415,
                "title": "c-gcd-of-all-numbers",
                "content": "[Small Improvement] As long as we the gcd becomes 1, we can return true.\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g(nums[0]);\\n        for (const int& n: nums)\\n            if ((g = gcd(g, n)) == 1)\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g(nums[0]);\\n        for (const int& n: nums)\\n            if ((g = gcd(g, n)) == 1)\\n                return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 419329,
                "title": "o-n-solution",
                "content": "Any linear combination of some subset of numbers is divisible by their greatest common divisor and GCD can be obtained as some linear combination. Thus, an array is good if and only if GCD of its values is 1.\\n\\n\\n```\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        if (nums.empty()) return false;\\n        int d = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            d = gcd(d, nums[i]);\\n        return d == 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    bool isGoodArray(vector<int>& nums)\\n    {\\n        if (nums.empty()) return false;\\n        int d = nums[0];\\n        for (int i = 1; i < nums.size(); i++)\\n            d = gcd(d, nums[i]);\\n        return d == 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057149,
                "title": "recursively",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        //gcd of numbers\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025478,
                "title": "simple-approach-using-gcd-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFrom gcd property we know , ax + by = gcd(a,b) ,  if a and b are coprime then gcd(a,b) == 1.\\nNow in this arry we need to find a subset whose gcd is equal to 1 , and it is always optimal to check the gcd of whole array , if we have the gcd equal to 1 then its possible otherwise its not possilbe\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N log(max(nums)))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        gc = 0\\n        for num in nums:\\n            gc = gcd(gc,num)\\n            if gc == 1:\\n                return True\\n        return False\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        gc = 0\\n        for num in nums:\\n            gc = gcd(gc,num)\\n            if gc == 1:\\n                return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025328,
                "title": "easy-to-understand-c-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf GCD of all numbers != 1, the answer is false\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind GCD of 2 numbers at a time and use that value to check for GCD of the rest of the array\\n\\nIf the GCD ever becomes 1, you return true, else you keep going\\nafter loop is finished you check if gcd is 1, if not you return false\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n Logn)\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int Gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return Gcd(b%a, a);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int size = nums.size();        \\n        int gcd = nums[0];\\n        for (int i = 1; i < size; i++)\\n        {\\n            gcd = Gcd(gcd, nums[i]);        \\n            if(gcd == 1) {\\n                return 1;\\n            }\\n        }\\n        return (gcd==1);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int Gcd(int a, int b) {\\n        if (a == 0)\\n            return b;\\n        return Gcd(b%a, a);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        int size = nums.size();        \\n        int gcd = nums[0];\\n        for (int i = 1; i < size; i++)\\n        {\\n            gcd = Gcd(gcd, nums[i]);        \\n            if(gcd == 1) {\\n                return 1;\\n            }\\n        }\\n        return (gcd==1);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020882,
                "title": "python-gcd-sum-simple",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return nums[0]==1\\n        g=gcd(nums[0],nums[1])\\n        for i in range(2,len(nums)):\\n            g=gcd(g,nums[i])\\n            if g==1:return True\\n        return g==1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)<2:return nums[0]==1\\n        g=gcd(nums[0],nums[1])\\n        for i in range(2,len(nums)):\\n            g=gcd(g,nums[i])\\n            if g==1:return True\\n        return g==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019428,
                "title": "simple-gcd-based-solution-in-o-n-time-and-o-1-space",
                "content": "# Intuition\\nIf there are two co-primes found in the list, then it\\'s possible to multiply by integer followed by sum to produce outcome of 1.\\n\\n# Approach\\nCompute the gcd value of the list. If it\\'s 1, then you found atleast two integers that are co-primes. Return true if the gcd value of the list is 1.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * math.gcd O())$$ - \\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gcd_val = nums[0]\\n        for n in nums:\\n            gcd_val = math.gcd(gcd_val, n)\\n        return gcd_val == 1\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gcd_val = nums[0]\\n        for n in nums:\\n            gcd_val = math.gcd(gcd_val, n)\\n        return gcd_val == 1\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009049,
                "title": "very-easy-gcd-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Leetcode Hint\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O[n*log(min(a,b))]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[1]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int gcd(int a, int b)\\n    {\\n        if (b==0) return a;\\n\\n        if (a>b)\\n        return gcd(b , a%b);\\n\\n        else \\n        return gcd(a, b%a);\\n    }\\n\\n\\n    public boolean isGoodArray(int[] nums) {\\n        \\n        int result = nums[0];\\n\\n        for (int i=1;i<nums.length;i++)\\n        {\\n            if (result==1) return true;\\n\\n            else result = gcd(result, nums[i]);\\n        }\\n\\n        if (result==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int gcd(int a, int b)\\n    {\\n        if (b==0) return a;\\n\\n        if (a>b)\\n        return gcd(b , a%b);\\n\\n        else \\n        return gcd(a, b%a);\\n    }\\n\\n\\n    public boolean isGoodArray(int[] nums) {\\n        \\n        int result = nums[0];\\n\\n        for (int i=1;i<nums.length;i++)\\n        {\\n            if (result==1) return true;\\n\\n            else result = gcd(result, nums[i]);\\n        }\\n\\n        if (result==1) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006162,
                "title": "unbelievable-java-solution-beats-100-explained-in-comments",
                "content": "# Complexity\\n- Time complexity:$$O(n * log(min(a, b)))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    // \\uD83D\\uDE80 Super-efficient algorithm that BEATS 100% of the competition! \\uD83C\\uDF89\\n    public boolean isGoodArray(int[] nums) {\\n        // \\uD83D\\uDCA1 Initialize \\'answer\\' with the first element of \\'nums\\'.\\n        int answer = nums[0];\\n        \\n        // \\uD83D\\uDD04 Loop through the array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // \\u2728 If \\'answer\\' is already 1, return true immediately since GCD can\\'t be less than 1.\\n            if (answer == 1) {\\n                return true;\\n            } else {\\n                // \\uD83D\\uDD0D Calculate the GCD of \\'answer\\' and the current element in \\'nums\\'.\\n                answer = gcd(answer, nums[i]);\\n            }\\n        }\\n        \\n        // \\uD83C\\uDFC6 Check if \\'answer\\' is 1 and return true, otherwise return false.\\n        return answer == 1;\\n    }\\n    \\n    // \\uD83D\\uDCAA This method calculates the greatest common divisor (GCD) of two integers \\'a\\' and \\'b\\'.\\n    public int gcd(int a, int b) {\\n        // \\uD83E\\uDDEE Using Euclidean algorithm to calculate GCD recursively.\\n        if (b == 0) {\\n            return a;\\n        }\\n        if (a > b) {\\n            return gcd(b, a % b);\\n        } else {\\n            return gcd(a, b % a);\\n        }\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // \\uD83D\\uDE80 Super-efficient algorithm that BEATS 100% of the competition! \\uD83C\\uDF89\\n    public boolean isGoodArray(int[] nums) {\\n        // \\uD83D\\uDCA1 Initialize \\'answer\\' with the first element of \\'nums\\'.\\n        int answer = nums[0];\\n        \\n        // \\uD83D\\uDD04 Loop through the array starting from the second element.\\n        for (int i = 1; i < nums.length; i++) {\\n            // \\u2728 If \\'answer\\' is already 1, return true immediately since GCD can\\'t be less than 1.\\n            if (answer == 1) {\\n                return true;\\n            } else {\\n                // \\uD83D\\uDD0D Calculate the GCD of \\'answer\\' and the current element in \\'nums\\'.\\n                answer = gcd(answer, nums[i]);\\n            }\\n        }\\n        \\n        // \\uD83C\\uDFC6 Check if \\'answer\\' is 1 and return true, otherwise return false.\\n        return answer == 1;\\n    }\\n    \\n    // \\uD83D\\uDCAA This method calculates the greatest common divisor (GCD) of two integers \\'a\\' and \\'b\\'.\\n    public int gcd(int a, int b) {\\n        // \\uD83E\\uDDEE Using Euclidean algorithm to calculate GCD recursively.\\n        if (b == 0) {\\n            return a;\\n        }\\n        if (a > b) {\\n            return gcd(b, a % b);\\n        } else {\\n            return gcd(a, b % a);\\n        }\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993707,
                "title": "easy-c-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(N log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n\\n        for(int i=0; i<n; i++){\\n            num = solve(num, nums[i]);\\n            if(num == 1)\\n                return true;\\n        }   \\n        return false;\\n    }\\n\\n    int solve(int a, int b){\\n        while(a % b != 0){\\n            int rem = a % b;\\n            a = b;\\n            b = rem;\\n        }\\n        return b;\\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/0bb48aee-c53f-463a-99c4-32d40955bb7a_1692653715.6692786.png)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int num = 0;\\n\\n        for(int i=0; i<n; i++){\\n            num = solve(num, nums[i]);\\n            if(num == 1)\\n                return true;\\n        }   \\n        return false;\\n    }\\n\\n    int solve(int a, int b){\\n        while(a % b != 0){\\n            int rem = a % b;\\n            a = b;\\n            b = rem;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927548,
                "title": "calculating-gcd-of-array-bezout-s-theorem",
                "content": "# Intuition\\n    Bezout\\'s Identity Theorem\\n\\n# Approach\\n    if g = gcd(a, b) then \\n        ax + by = g \\n        (for any (x, y) pairs)\\n\\n    so required g is 1\\n    so if whole array gcd is 1 then its True else False\\n\\n# Complexity\\n- Time complexity:\\n    0(n*log(min(a, b)))\\n    n for traversing array and log(min(a, b)) for calculating gcd of two numbers\\n\\n- Space complexity:\\n    0(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        g = nums[0]\\n        for i in range(1, n):\\n            g = gcd(g, nums[i])\\n        \\n        return True if g == 1 else False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self, a, b):\\n        if b == 0:\\n            return a\\n        return self.gcd(b, a%b)\\n\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        n = len(nums)\\n        g = nums[0]\\n        for i in range(1, n):\\n            g = gcd(g, nums[i])\\n        \\n        return True if g == 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894403,
                "title": "smalled-positive-linear-combination",
                "content": "```\\nTheorem: Let a and b be two integers (not both zero). Then any linear combination of a\\nand b is a multiple of gcd(a, b). In particular, splc(a, b) \\u2265 gcd(a, b).\\nProof: (Michael) Let d = gcd(a, b). Then a = dp and b = dq for some integers p and\\nq. Let m be a linear combination of a and b. Then m = ax + by for some x, y \\u2208 Z. Then\\nm = ax + by = dpx + dqy = d(px + qy), which shows d divides m. This proves the first\\nstatement. For the second statement, since splc(a, b) is a linear combination of a and b, the\\nfirst statement says that splc(a, b) is a multiple of d. Since the smallest positive multiple of\\nd is d, this shows that splc(a, b) \\u2265 d\\n```\\nI got this by reading: https://www.cmi.ac.in/~prajakta/courses/f2017/notes.pdf\\n\\n**Time: O(n), assuming gcd operation is O(1)\\nSpace: O(1)**\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        splc = nums[0]\\n        for n in nums:\\n            splc = gcd(splc, n)\\n            if splc == 1: return True\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nTheorem: Let a and b be two integers (not both zero). Then any linear combination of a\\nand b is a multiple of gcd(a, b). In particular, splc(a, b) \\u2265 gcd(a, b).\\nProof: (Michael) Let d = gcd(a, b). Then a = dp and b = dq for some integers p and\\nq. Let m be a linear combination of a and b. Then m = ax + by for some x, y \\u2208 Z. Then\\nm = ax + by = dpx + dqy = d(px + qy), which shows d divides m. This proves the first\\nstatement. For the second statement, since splc(a, b) is a linear combination of a and b, the\\nfirst statement says that splc(a, b) is a multiple of d. Since the smallest positive multiple of\\nd is d, this shows that splc(a, b) \\u2265 d\\n```\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        splc = nums[0]\\n        for n in nums:\\n            splc = gcd(splc, n)\\n            if splc == 1: return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866093,
                "title": "easy-c-solution-simple-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            x=gcd(nums[i],x);\\n            if(x==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\nPLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F IF YOU LIKE THE SOLUTION !!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int x=0;\\n        for(int i=0;i<nums.size();i++){\\n            x=gcd(nums[i],x);\\n            if(x==1){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3840761,
                "title": "gcd-python3",
                "content": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        x = nums[0]\\n        for num in nums:\\n            x = math.gcd(x,num)\\n        return x==1\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nimport math\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        x = nums[0]\\n        for num in nums:\\n            x = math.gcd(x,num)\\n        return x==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801964,
                "title": "basic-maths-solved-using-c-better-approach-and-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nI used this approach to solve this problem if the gcd of any subarray is 1 then it\\'s a good array because according to Bezout\\'s identity gcd(a,b) =d then\\nax+by=d.\\naccording to this,if gcd(a,b)=1 then ax+by=1\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792294,
                "title": "beginners-level-question-very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n            ans=gcd(ans,nums[i]);\\n            if(ans==1)\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3701102,
                "title": "python-one-line",
                "content": "# Intuition\\ngcd all numbers and if 1 you are good\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, A: List[int]) -> bool:\\n        return reduce(gcd, A) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, A: List[int]) -> bool:\\n        return reduce(gcd, A) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649906,
                "title": "short-sweet-swift",
                "content": "```\\nclass Solution {\\n    func isGoodArray(_ nums: [Int]) -> Bool {\\n        nums.reduce(0, { gcd($0, $1) }) == 1\\n    }\\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        b == 0 ? a : gcd(b, a % b)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func isGoodArray(_ nums: [Int]) -> Bool {\\n        nums.reduce(0, { gcd($0, $1) }) == 1\\n    }\\n    func gcd(_ a: Int, _ b: Int) -> Int {\\n        b == 0 ? a : gcd(b, a % b)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3610733,
                "title": "easiest-solution-py",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return nums[0]==1\\n        div = gcd(nums[0], nums[1])\\n\\n        if len(nums) == 2:\\n            return div==1\\n\\n        for i in range(1, len(nums) - 1):\\n            div = gcd(div, nums[i + 1])\\n        return div == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        if len(nums)==1:\\n            return nums[0]==1\\n        div = gcd(nums[0], nums[1])\\n\\n        if len(nums) == 2:\\n            return div==1\\n\\n        for i in range(1, len(nums) - 1):\\n            div = gcd(div, nums[i + 1])\\n        return div == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592869,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif the gcd of any subarray is 1 then the gcd of entire array is also 1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used this approach to solve this problem if the gcd of any subarray is 1 then it\\'s a good array because according to Bezout\\'s identity gcd(a,b) =d then \\nax+by=d.\\naccording to this,if  gcd(a,b)=1 then ax+by=1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {  \\n    int gcd(int a,int b){   \\n        int maximum= max(a,b);\\n        int minimum= min(a,b);\\n        if(minimum==0){\\n            return maximum;\\n        }\\n        while(maximum%minimum!=0){    \\n            int temp = maximum;    \\n            maximum=minimum;\\n            minimum = temp%minimum;\\n        }\\n        return minimum;\\n    } \\npublic:\\n    bool isGoodArray(vector<int>& nums) {   \\n        if(nums.size()==1){\\n            if(nums[0]==1){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int GCD = gcd(nums[0],nums[1]);\\n        for(int i =2;i<nums.size();i++){\\n            GCD=gcd(GCD,nums[i]);\\n        }\\n        if(GCD==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {  \\n    int gcd(int a,int b){   \\n        int maximum= max(a,b);\\n        int minimum= min(a,b);\\n        if(minimum==0){\\n            return maximum;\\n        }\\n        while(maximum%minimum!=0){    \\n            int temp = maximum;    \\n            maximum=minimum;\\n            minimum = temp%minimum;\\n        }\\n        return minimum;\\n    } \\npublic:\\n    bool isGoodArray(vector<int>& nums) {   \\n        if(nums.size()==1){\\n            if(nums[0]==1){\\n                return true;\\n            }\\n            else{\\n                return false;\\n            }\\n        }\\n        int GCD = gcd(nums[0],nums[1]);\\n        for(int i =2;i<nums.size();i++){\\n            GCD=gcd(GCD,nums[i]);\\n        }\\n        if(GCD==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592217,
                "title": "fastest-java-solution-easiest-approach-most-easily-understandable",
                "content": "# Intuition\\nBy looking at the test case I got to find out that if every number are propotional to each other than it is always false\\n\\n# Approach\\nTo find whether all the elements are proportional to each other we calculate all of thier gcd.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);    \\n        \\n    \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if(nums.length == 0){\\n            return false;\\n        }\\n        int ans = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            ans = gcd(ans, nums[i]);\\n        }\\n        if(ans == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);    \\n        \\n    \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582484,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n        {\\n            return nums[0]==1 ? true : false;\\n        }\\n        int a = nums[0];\\n        int b = nums[1];\\n        int g = gcd(a,b);\\n        int i = 2;\\n        while(g!=1&&i<n)\\n        {\\n            g = gcd(g, nums[i]);\\n            i++;\\n        }\\n        return g==1 ? true : false;\\n    }\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        from functools import reduce\\n\\n        array_gcd = reduce(gcd, nums)\\n        \\n        return array_gcd == 1\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            result=GCD(nums[i],result);\\n            if (result==1) return true;\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n        {\\n            return nums[0]==1 ? true : false;\\n        }\\n        int a = nums[0];\\n        int b = nums[1];\\n        int g = gcd(a,b);\\n        int i = 2;\\n        while(g!=1&&i<n)\\n        {\\n            g = gcd(g, nums[i]);\\n            i++;\\n        }\\n        return g==1 ? true : false;\\n    }\\n};\\nstatic bool     _foo = ios::sync_with_stdio(false);\\nstatic ostream* _bar = cin.tie(NULL);\\n```\n```Python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        from math import gcd\\n        from functools import reduce\\n\\n        array_gcd = reduce(gcd, nums)\\n        \\n        return array_gcd == 1\\n```\n```Java []\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            result=GCD(nums[i],result);\\n            if (result==1) return true;\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3570915,
                "title": "simple-solution-gcd-o-1-space",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo satisfy the condition the greatest common factor(gcd) of the array should be one.Also if any two number has gcd 1 then also we can return true because overall gcd become 1.\\nIf only one element in array then if it is one then true else false. \\n\\n# Complexity\\n- Time complexity:O(nLogA) , A = shows the element of array . LogA is because gcd function will give result in LogA \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int overallgcd=0;\\n     if(nums.length==1)\\n           {\\n           if(nums[0]==1)return true;\\n           return false;\\n            }\\n        overallgcd=gcd(nums[0],nums[1]);\\n        for(int t=2;t<nums.length;t++)\\n        {\\n          overallgcd=gcd(nums[t],overallgcd);\\n        }\\n        if(overallgcd==1)return true;\\n        return false;\\n    }\\n    int gcd(int t,int k){\\n        if(t==0)return k;\\n        return gcd(k%t,t);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int overallgcd=0;\\n     if(nums.length==1)\\n           {\\n           if(nums[0]==1)return true;\\n           return false;\\n            }\\n        overallgcd=gcd(nums[0],nums[1]);\\n        for(int t=2;t<nums.length;t++)\\n        {\\n          overallgcd=gcd(nums[t],overallgcd);\\n        }\\n        if(overallgcd==1)return true;\\n        return false;\\n    }\\n    int gcd(int t,int k){\\n        if(t==0)return k;\\n        return gcd(k%t,t);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565465,
                "title": "java-solution-by-recursive-method-0-ms-time-complexity",
                "content": "# Intuition\\ncalling the function goodCount recursively \\n\\n# Approach\\nRecursive Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {     \\n    public boolean isGoodArray(int[] nums) {\\n            if(nums.length == 0) return false; \\n            int ans = nums[0];         \\n            for(int i = 1 ; i< nums.length ; i++){             \\n                    ans = goodCount(ans , nums[i]);         \\n            }         \\n            if(ans == 1) return true;         \\n            else return false;     \\n        }      \\n    public int goodCount(int a, int b){        \\n        if(a == 0){           \\n             return b;           \\n        }         \\n        return goodCount(b%a , a);     \\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {     \\n    public boolean isGoodArray(int[] nums) {\\n            if(nums.length == 0) return false; \\n            int ans = nums[0];         \\n            for(int i = 1 ; i< nums.length ; i++){             \\n                    ans = goodCount(ans , nums[i]);         \\n            }         \\n            if(ans == 1) return true;         \\n            else return false;     \\n        }      \\n    public int goodCount(int a, int b){        \\n        if(a == 0){           \\n             return b;           \\n        }         \\n        return goodCount(b%a , a);     \\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563471,
                "title": "check-weather-the-array-is-a-good-array-or-not-beginner-friendly-java-solution",
                "content": "# Intuition:-\\nThe intuition behind this problem is that by if the GCD of all the elements of the array comes out to be 1 then it is said that the array is a good array.\\n\\n# Approach\\nFlow of the code:-\\n1. If the length of the array is 0 then return false.\\n2. Now we will make a function for calculating the GCD.\\n3. We will initialise an integer flag to nums[0].\\n4. Now we will execute a for loop from i = 1 to i < nums.length.\\n5. When the loop will be getting executed then we will call our function gcd where one input will be flag and nums[i].\\n6. At the last when the loop will be executed the flag will give its output.\\n7. If this output turns out to be equal to one then boolean true will be returned otherwise false will  be returned.\\n8. This is the very best explanation that you are looking for, no complex bezout lemma just pure and simple solution.\\n9. Please upvote my solution. \\n# Complexity\\n- Time complexity:\\nThe time complexity for this solution  is O(N).\\n\\n- Space complexity:\\nThe space complexity for this solution is 0(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n           if(nums.length == 0){\\n            return false;\\n        }\\n        int flag = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            flag = gcd(flag, nums[i]);\\n        }\\n        if(flag == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n           if(nums.length == 0){\\n            return false;\\n        }\\n        int flag = nums[0];\\n        for(int i = 1;i < nums.length;i++){\\n            flag = gcd(flag, nums[i]);\\n        }\\n        if(flag == 1) return true;\\n        else return false;\\n    }\\n    public int gcd(int a, int b){\\n        if(a == 0){\\n            return b;\\n        }\\n        return gcd(b % a, a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555844,
                "title": "discrete-math-ftw-bezout-s-identity",
                "content": "# Intuition\\nWe learned about this in Discrete Math I (shoutout Dr. Bereg). Basically, Bezout\\'s identity states that for any pair of numbers x, y, it is possible to always get solutions (a, b) such that ax + by = GCD(x, y) (and nothing smaller).\\n\\n# Approach\\nAll we do is check if we can get a GCD of 1 from any given pair.\\n\\n# Complexity\\nThe time complexity of this problem is O(N), as evidenced by the single for loop. This is kind of like a nested GCD as we traverse across which looks something like GCD(xn, GCD(xn-1, GCD(... , GCD(x0)))). As long as we hit 1, we know that the number we hit is relatively prime with some other number that came before it, and we don\\'t care which one. All we need to do is return a boolean, so we\\'re done.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1) {\\n            return (nums[0] == 1 || nums[0] == -1);\\n        } else {\\n            int gee = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                gee = gcd(gee, nums[i]);\\n            }\\n            return gee==1;\\n        }\\n    }\\n\\n    static int gcd(int a, int b) {\\n        while (b != 0) {\\n            int t = a;\\n            a = b;\\n            b = t % b;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1) {\\n            return (nums[0] == 1 || nums[0] == -1);\\n        } else {\\n            int gee = nums[0];\\n            for (int i = 1; i < nums.length; i++) {\\n                gee = gcd(gee, nums[i]);\\n            }\\n            return gee==1;\\n        }\\n    }\\n\\n    static int gcd(int a, int b) {\\n        while (b != 0) {\\n            int t = a;\\n            a = b;\\n            b = t % b;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519562,
                "title": "c-solution-using-gcd",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N log max)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\npublic class Solution {\\n    public bool IsGoodArray(int[] nums) {\\n        int gcd(int a,int b) => (a == 0) ? b : gcd(b % a, a);\\n        int curGcd = nums[0];\\n        for(int i = 1; i < nums.Length;i++){\\n            curGcd = gcd(curGcd,nums[i]);\\n            if(curGcd == 1) return true;\\n        } \\n        return curGcd == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Number Theory"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsGoodArray(int[] nums) {\\n        int gcd(int a,int b) => (a == 0) ? b : gcd(b % a, a);\\n        int curGcd = nums[0];\\n        for(int i = 1; i < nums.Length;i++){\\n            curGcd = gcd(curGcd,nums[i]);\\n            if(curGcd == 1) return true;\\n        } \\n        return curGcd == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466331,
                "title": "chinese-remainder-theorem",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a: gcd, a = a, gcd % a\\n        return gcd == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def isGoodArray(self, A):\\n        gcd = A[0]\\n        for a in A:\\n            while a: gcd, a = a, gcd % a\\n        return gcd == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425548,
                "title": "euclid-s-algorithm-gcd-easy-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis Java code defines a class named \"Solution\" with a method \"isGoodArray\" that takes an integer array \"nums\" as input and returns a boolean value. The method calculates the greatest common divisor (GCD) of all the elements in the array using a recursive \"gcd\" function and stores the result in the variable \"ans\". If the value of \"ans\" is equal to 1, the method returns true; otherwise, it returns false.\\n\\nThe \"gcd\" function uses the Euclidean algorithm to calculate the GCD of two numbers \"a\" and \"b\" by finding the remainder of \"b\" divided by \"a\" and recursively calling itself with the arguments \"b%a\" and \"a\" until \"a\" becomes zero. If \"a\" is zero, the function returns \"b\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. First, we define a class named \"Solution\" with a method \"isGoodArray\" that takes an integer array \"nums\" as input and returns a boolean value.\\n\\n2. We initialize two variables, \"n\" to hold the length of the array \"nums\", and \"ans\" to hold the first element of the array.\\n\\n3. We then loop through the remaining elements of the array, starting from the second element, and calculate the GCD of each element with the previous GCD value stored in the \"ans\" variable, using the \"gcd\" function.\\n\\n4. Finally, we check if the value of \"ans\" is equal to 1, and return true if it is, and false otherwise.\\n\\n$$Conclusion:$$\\nThe given code is used to determine if an array is \"good\" or not. An array is considered \"good\" if there exists a non-empty subarray (consecutive elements of the array) such that the GCD of all the elements in the subarray is equal to 1. The code achieves this by calculating the GCD of all the elements in the array and checking if the final GCD value is equal to 1. The GCD calculation is performed using the recursive \"gcd\" function, which uses the Euclidean algorithm to compute the GCD of two numbers.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int n = nums.length;\\n       int ans = nums[0] ;\\n\\n       for( int i = 1; i < n; i++) {\\n           ans = gcd( ans, nums[i] );\\n       }\\n\\n       return ans == 1;\\n    }\\n\\n    //  greatest common divisor (gcd) function\\n    public int gcd( int a, int b ) {\\n        // check\\n        if( a == 0 ) {\\n            return b;\\n        }\\n\\n        return gcd( b%a, a );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int n = nums.length;\\n       int ans = nums[0] ;\\n\\n       for( int i = 1; i < n; i++) {\\n           ans = gcd( ans, nums[i] );\\n       }\\n\\n       return ans == 1;\\n    }\\n\\n    //  greatest common divisor (gcd) function\\n    public int gcd( int a, int b ) {\\n        // check\\n        if( a == 0 ) {\\n            return b;\\n        }\\n\\n        return gcd( b%a, a );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416472,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums):\\n        return reduce(gcd,nums) == 1\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums):\\n        return reduce(gcd,nums) == 1\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406634,
                "title": "python3-o-n-complexity",
                "content": "# Intuition\\nWe are trying to obtain a sum of 1 using a subset of nums and multiplying each element by an integer, we need to find out if the GCD of the numbers in the array is 1. If the GCD is 1, that means there is a combination of elements in the array that can be multiplied by some integers and added together to give a sum of 1.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:   \\n        if len(nums) == 0:\\n            return False\\n\\n        current_gcd = nums[0]\\n\\n        for num in nums:\\n            current_gcd = gcd(current_gcd, num)\\n            if current_gcd == 1:\\n                return True\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:   \\n        if len(nums) == 0:\\n            return False\\n\\n        current_gcd = nums[0]\\n\\n        for num in nums:\\n            current_gcd = gcd(current_gcd, num)\\n            if current_gcd == 1:\\n                return True\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3397829,
                "title": "easy-100-100-ruby-solution-using-gcd",
                "content": "# Intuition\\nAny two relatively prime numbers can be used to make one, so any array is \"good\" unless all numbers share a prime factor.\\n\\n# Approach\\nFind the greatest common factor of all numbers in the array and check if it\\'s 1.\\n\\n# Complexity\\n- Time complexity:\\nI think $$O(n)$$, but I\\'m not sure about the time complexity of repeated GCD.\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef is_good_array(nums)\\n    return nums[0] == 1 if nums.length == 1\\n    current = nums.shift\\n    until nums.empty?\\n        current = current.gcd(nums.shift)\\n    end\\n    current == 1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Boolean}\\ndef is_good_array(nums)\\n    return nums[0] == 1 if nums.length == 1\\n    current = nums.shift\\n    until nums.empty?\\n        current = current.gcd(nums.shift)\\n    end\\n    current == 1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3346863,
                "title": "c-solution",
                "content": "Eq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\nB\\xE9zout\\'s lemma\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        int gcd=nums[0];\\n        for(int x=1; x<nums.size(); x++) gcd=__gcd(gcd,nums[x]);\\n        return gcd==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        int gcd=nums[0];\\n        for(int x=1; x<nums.size(); x++) gcd=__gcd(gcd,nums[x]);\\n        return gcd==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3319854,
                "title": "check-if-it-is-a-good-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        int n= nums.length;\\n        for(int num : nums){\\n            gcd = gcd(gcd,num);\\n            if(gcd==1){\\n                return true;\\n            }\\n        }\\n        return gcd==1;\\n\\n    }\\n\\n    public static int gcd(int a, int b){\\n        while(b!=0){\\n            int temp =b;\\n            b = a%b;\\n            a=temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        int n= nums.length;\\n        for(int num : nums){\\n            gcd = gcd(gcd,num);\\n            if(gcd==1){\\n                return true;\\n            }\\n        }\\n        return gcd==1;\\n\\n    }\\n\\n    public static int gcd(int a, int b){\\n        while(b!=0){\\n            int temp =b;\\n            b = a%b;\\n            a=temp;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313047,
                "title": "very-easy-solution-just-gcd",
                "content": "# Intuition\\nWe do not have to to check all subsequnces we just have to check if the the GCD of all elements of the array is 1 or not\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int gcd_all(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            cur = gcd(cur, nums[i]);\\n        }\\n        return cur;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        return gcd_all(nums) == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd_all(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int cur = nums[0];\\n        for (int i = 1; i < n; i++)\\n        {\\n            cur = gcd(cur, nums[i]);\\n        }\\n        return cur;\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        return gcd_all(nums) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307004,
                "title": "fastest-java-solution-with-3lines-of-code",
                "content": "\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i:nums){\\n            gcd = GCD(i,gcd);\\n        }\\n        return gcd==1;\\n    }\\n    int GCD(int x, int y)\\n    {\\n        if (y == 0)\\n            return x;\\n        return GCD(y, x % y);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i:nums){\\n            gcd = GCD(i,gcd);\\n        }\\n        return gcd==1;\\n    }\\n    int GCD(int x, int y)\\n    {\\n        if (y == 0)\\n            return x;\\n        return GCD(y, x % y);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301332,
                "title": "java-ax-by-1-using-hint",
                "content": "# Intuition\\nWe can think of each element in the array as a factor that we can use to obtain the desired sum of 1. to obtain a sum of 1, we need to find a combination of factors , to do this is to choose a subset of the factors whose greatest common divisor is 1, and then multiply each element in the subset by an integer such that the sum of the resulting products is 1. ( credit hint ) \\n\\n        ************----------------****************\\n                            \\nThe reason why we choose a subset of factors whose greatest common divisor is 1 is that if the greatest common divisor is not 1, then the factors have a common factor other than 1, which means that we cannot obtain a sum of 1 using only integer multiplication of the factors. This is because any integer multiplication of the factors would also include the common factor, which would prevent us from obtaining a sum of 1.\\n\\n# Approach\\nInitialize a variable gcd to the first element of the array.\\n\\nIterate over the rest of the elements in the array, and for each element num, compute the GCD of gcd and num using the Euclidean algorithm. Update gcd to the resulting GCD.\\n\\nAfter iterating over all the elements in the array, check if gcd is equal to 1. If gcd is equal to 1, then the array is good and we return true, otherwise it is not good and we return false.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n          int gcd = nums[0]; // Greatest common factor \\n    for (int i = 1; i < nums.length; i++) {\\n        gcd = gcd(gcd, nums[i]);\\n    }\\n    return gcd == 1;\\n    }\\n    public static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n          int gcd = nums[0]; // Greatest common factor \\n    for (int i = 1; i < nums.length; i++) {\\n        gcd = gcd(gcd, nums[i]);\\n    }\\n    return gcd == 1;\\n    }\\n    public static int gcd(int a, int b) {\\n    if (b == 0) {\\n        return a;\\n    } else {\\n        return gcd(b, a % b);\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255640,
                "title": "python-math-solution",
                "content": "# Intuition\\nif a,b,c, .. are elements of array we need to find if equation \\nax+by+cz+...= 1 is solvable.\\n\\nWe know ax+by=1 is solvable only if a & b are co-prime by Bezout\\'s identity theorem. Can we extend it to solve it ?\\n\\n# Approach\\nax+by=1 is solvable only if a & b are co-prime by Bezout\\'s identity theorem (ax+by=GCD(a,b)). Can we extend it to solve it ?\\n\\nLet\\'s check if we can extend to more than one coefficient i.e. ax+by+cz=1\\nIs ax+by=1 => ax+by+cz=1 true ?\\n    \\n    ax+by=1 => n(ax+by) = n where n is any integer\\n    a(nx) + b(ny) = n => ax`+by` = n , so I can choose ax`+by` \\n        expression to be any integer\\n    if I choose ax+by = (-cz+1) (x` and y` are arbitrary values similar to \\n            x and y) \\n    => ax+by+cz = (-cz+1)+cz = 1\\n    => ax+by+cz = 1\\n\\nI can extend this argument to any number of coefficients \\ni.e. ax+by+cz+.... = 1\\n\\nSolution:\\nif there are two numbers in array (a, b, c, ..) which are co-prime then the array is good.\\nWe can find all the pairs in the array in order to check it, Time complexity - O(n^2). Can we do better than that ?\\n\\nGiven GCD(a, b) = 1 then GCD(a, b, c) should be 1 because 1 is the lowest common factor. if we can find the GCD of the array and if its equal to 1 then the array is good\\n\\n    GCD(a, b, c, d, ....) = GCD(GCD(GCD(GCD(a,b), c),d)....\\n\\nPseudocode:\\n\\n    g = nums[0]\\n    for n in nums starting at position 1:\\n        g = GCD(g, n)\\n    if g==1:\\n        then array is good\\n    else:\\n        array is not good.\\n\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n    GCD function takes logx(m) where m is max of two numbers\\n    $$O(nlogx(m))$$ where m is max number in array and n is length of array.\\n\\n\\n- Space complexity:\\n$$O(1)$$ - constant space\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        g = nums[0]\\n        for i in range(1, len(nums)):\\n            g = math.gcd(nums[i], g)\\n        if g == 1:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        g = nums[0]\\n        for i in range(1, len(nums)):\\n            g = math.gcd(nums[i], g)\\n        if g == 1:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205019,
                "title": "check-if-it-is-a-good-array-easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& num) {\\n        int gk = num[0];\\n                for(auto i:num){\\n                            gk = __gcd(gk,i);\\n                                    }\\n                                            if(gk==1) return true;\\n                                                    else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& num) {\\n        int gk = num[0];\\n                for(auto i:num){\\n                            gk = __gcd(gk,i);\\n                                    }\\n                                            if(gk==1) return true;\\n                                                    else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203080,
                "title": "bezout-s-identity",
                "content": "Essentially, this is an application of Bezout\\'s identity: \\n**Lemma**: $$\\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i = k\\\\gcd(x_0, x_1, ...x_n)$$\\n**Proof**: \\n(1) When $$n = 1$$, this is Bezout\\'s identity.\\n(2) Assume this is true for $n$, then \\n\\n$$\\\\displaystyle\\\\sum_{i=0}^{n+1} c_i x_i = \\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i + c_{n+1}x_{n+1} = k\\\\gcd(x_0, ...,x_n) + c_{n+1}x_{n+1} = k\\'\\\\gcd(\\\\gcd(x_0, ..., x_n), x_{n+1}) = k\\'\\\\gcd(x_0, ..., x_{n+1})$$\\n\\nTherefore, the array is good iff the GCD of some subset is $$1$$, which is true iff the GCD of the entire array is $$1$$.",
                "solutionTags": [
                    "C++"
                ],
                "code": "Essentially, this is an application of Bezout\\'s identity: \\n**Lemma**: $$\\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i = k\\\\gcd(x_0, x_1, ...x_n)$$\\n**Proof**: \\n(1) When $$n = 1$$, this is Bezout\\'s identity.\\n(2) Assume this is true for $n$, then \\n\\n$$\\\\displaystyle\\\\sum_{i=0}^{n+1} c_i x_i = \\\\displaystyle\\\\sum_{i=0}^{n} c_i x_i + c_{n+1}x_{n+1} = k\\\\gcd(x_0, ...,x_n) + c_{n+1}x_{n+1} = k\\'\\\\gcd(\\\\gcd(x_0, ..., x_n), x_{n+1}) = k\\'\\\\gcd(x_0, ..., x_{n+1})$$\\n\\nTherefore, the array is good iff the GCD of some subset is $$1$$, which is true iff the GCD of the entire array is $$1$$.",
                "codeTag": "Unknown"
            },
            {
                "id": 3189040,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n      int ans=nums[0];\\n      for(int i=1;i<nums.size();i++){\\n          ans=__gcd(ans,nums[i]);\\n      }   \\n      if(ans==1) return true;\\n      return false;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n      int ans=nums[0];\\n      for(int i=1;i<nums.size();i++){\\n          ans=__gcd(ans,nums[i]);\\n      }   \\n      if(ans==1) return true;\\n      return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186966,
                "title": "lc-1250-h-python3-one-liner",
                "content": "If `gcd(*nums) == 1`, then there exists a subset `s` of `nums` such that `gcd(*s) == 1`. By the generailzed B\\xE9zout\\'s identity for multiple integers, we know that `nums` is a good array.\\n\\n```python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if gcd(*nums) == 1 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return True if gcd(*nums) == 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169532,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0], y;\\n        for(int a : nums){\\n            while(a > 0){\\n                y = x%a;\\n                x = a;\\n                a = y;\\n            }\\n         }\\n        return x == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0], y;\\n        for(int a : nums){\\n            while(a > 0){\\n                y = x%a;\\n                x = a;\\n                a = y;\\n            }\\n         }\\n        return x == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155541,
                "title": "easiest-solution-for-hard-problem-c-begginer-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n    int n = nums.size();\\n    int a = 0;\\n    for(int i=0; i<n; i++){\\n        a = gcd(a,nums[i]);\\n        if(a==1)\\n            return true;\\n    }\\n    return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n    int n = nums.size();\\n    int a = 0;\\n    for(int i=0; i<n; i++){\\n        a = gcd(a,nums[i]);\\n        if(a==1)\\n            return true;\\n    }\\n    return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152455,
                "title": "simple-solution-using-gcd-using-b-zout-s-identity-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI first thought if we have 2 prime numbers then we can have a solution then i thought what else i can do if we have other numbers then i came to know about B\\xE9zout\\'s identity theorem . This question is example of this theorem .\\nWe only have to check for all numbers gcd and see if we get 1 if we get 1 then we can have a multiple that can make total sum = 1 .\\n# Complexity\\n- Time complexity: O(NlogN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int no = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            no = gcd(no,nums[i]);\\n            if(no == 1) return 1;\\n        }\\n        return no == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int no = nums[0];\\n        for(int i=1;i<nums.size();i++){\\n            no = gcd(no,nums[i]);\\n            if(no == 1) return 1;\\n        }\\n        return no == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115621,
                "title": "scala-2-lines-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def isGoodArray(nums: Array[Int]): Boolean = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        nums.reduce(gcd) == 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def isGoodArray(nums: Array[Int]): Boolean = {\\n        @annotation.tailrec\\n        def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\\n        nums.reduce(gcd) == 1\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3074590,
                "title": "python-solution-beats-99-w-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition\\nMy first thought on how to solve this problem is to use the concept of greatest common divisor (GCD) to check if all the elements in the given array have a GCD of 1. If so, then it is a good array as per the problem statement.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach to solving this problem is to use the built-in function gcd() from the math module to calculate the GCD of all the elements in the given array. I will use the reduce() function from the functools module to iterate through the array and calculate the GCD of all the elements in one go. I will then compare the calculated GCD with 1 and return True if they are equal, False otherwise.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom math import gcd\\n\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd, nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068769,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_good_array(nums: Vec<i32>) -> bool {\\n        let mut res = nums[0];\\n        for i in nums.iter() {\\n            res = Self::gcd(res, *i);\\n        }\\n        res == 1\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if b == 0 {\\n            a\\n        } else {\\n            Self::gcd(b, a % b)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_good_array(nums: Vec<i32>) -> bool {\\n        let mut res = nums[0];\\n        for i in nums.iter() {\\n            res = Self::gcd(res, *i);\\n        }\\n        res == 1\\n    }\\n\\n    fn gcd(a: i32, b: i32) -> i32 {\\n        if b == 0 {\\n            a\\n        } else {\\n            Self::gcd(b, a % b)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3067037,
                "title": "check-if-it-is-a-good-array-c-4lines-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe array will be good only if there exists a subset whose gcd is 1.\\n\\n# Approach\\nWe find the gcd of the whole array. If the gcd is 1 we can say that there exist a subset whose gcd is 1. For that subset it is always possible to have a number such that final number is 1.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        gd=__gcd(nums[i],gd);\\n        return (gd==1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        gd=__gcd(nums[i],gd);\\n        return (gd==1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051254,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int result=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n                result=GCD(nums[i],result);\\n        }\\n        return result==1;\\n    }\\n    static int GCD(int i,int j){\\n        if(j==0) return i;\\n        return GCD(j,i%j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046759,
                "title": "c-1-liner-easy",
                "content": "By bezout\\'s lemma, if 2 numbers x and y are co prime, then we can find integers m and n such that mx + ny = 1, so the problems boils to checking if there is a co-prime pair in the array or not. This is always true if the GCD of the  entire array is 1.\\n\\nMy code below:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [&](const int &x, const int &y) {\\n            return __gcd(x, y);\\n        }) == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        return accumulate(nums.begin(), nums.end(), 0, [&](const int &x, const int &y) {\\n            return __gcd(x, y);\\n        }) == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014387,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014386,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i = 1; i<nums.length; i++){\\n            gcd = gcd(gcd, nums[i]);\\n            if(gcd == 1)\\n                return true;\\n        }\\n        return gcd==1;\\n    }\\n    public int gcd(int a, int b){\\n        if(b==0)\\n            return a;\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008301,
                "title": "c-gcd",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ans=nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            ans=__gcd(ans,nums[i]);\\n        }\\n       \\n       return ans==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        \\n        int n=nums.size();\\n\\n        int ans=nums[0];\\n\\n        for(int i=1; i<n; i++){\\n            ans=__gcd(ans,nums[i]);\\n        }\\n       \\n       return ans==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007805,
                "title": "fastest-java-solution-gcd-greedy-100-time-and-99-25-space",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(res==1){\\n                return true;\\n            }\\n            else{\\n                res=gcd(res,nums[i]);\\n            }\\n        }\\n        if(res==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public static int gcd(int n1,int n2){\\n\\t    if(n2==0){\\n\\t        return n1;\\n\\t    }\\n\\t    if(n1>n2){\\n\\t        return gcd(n2,n1%n2);\\n\\t    }\\n\\t    else{\\n\\t        return gcd(n1,n2%n1);\\n\\t    }\\n\\t    \\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            \\n            if(res==1){\\n                return true;\\n            }\\n            else{\\n                res=gcd(res,nums[i]);\\n            }\\n        }\\n        if(res==1){\\n            return true;\\n        }\\n        return false;\\n    }\\n    public static int gcd(int n1,int n2){\\n\\t    if(n2==0){\\n\\t        return n1;\\n\\t    }\\n\\t    if(n1>n2){\\n\\t        return gcd(n2,n1%n2);\\n\\t    }\\n\\t    else{\\n\\t        return gcd(n1,n2%n1);\\n\\t    }\\n\\t    \\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2999871,
                "title": "java-beats-almost-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    static int gcd(int n,int m){\\n        if(m==0)\\n            return n;\\n        else\\n            return gcd(m,n%m);\\n    }\\n    public boolean isGoodArray(int[] nums) {\\n        int res=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n            res=gcd(res,nums[i]);\\n        return res==1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968527,
                "title": "easy-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n         int valid = nums[0];\\n     \\n     // get GCD between all elements in Vector\\n       for(auto& i : nums )\\n            valid= __gcd( valid , i) ;\\n       \\n       return valid==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n         int valid = nums[0];\\n     \\n     // get GCD between all elements in Vector\\n       for(auto& i : nums )\\n            valid= __gcd( valid , i) ;\\n       \\n       return valid==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941830,
                "title": "c-simple-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)* O(log(a+b))\\nO(n) : Since we are traversing the array once.\\nO(log(a + b)): Since we are computing gcd.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = nums[0];\\n        for (int i=1; i<n; i++)\\n            a =__gcd(a, nums[i]); // __gcd() is C++17 feature\\n        return a == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int a = nums[0];\\n        for (int i=1; i<n; i++)\\n            a =__gcd(a, nums[i]); // __gcd() is C++17 feature\\n        return a == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941083,
                "title": "easy-python-1-liner-using-bezout-s-lemma-faster-than-70",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI applied Bezout\\'s Lemma: https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity. It\\'s easy once you know about it.\\n\\n# Complexity\\n- Time complexity: $$O(n * log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return gcd(*nums) == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2931442,
                "title": "c-is-equation-diophantine-bezout-s-lemma-o-n-logm-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nAn equation \\n$$a_1x_1+a_2x_2+...a_kx_k=d$$\\n\\nHas integer solutions $x_1\\\\in \\\\mathbb{Z}, x_2\\\\in \\\\mathbb{Z},...x_k\\\\in\\\\mathbb{Z}$ if and only if $d$ divides $gcd(a_1,a_2,...a_k)$.\\n\\nSince here in this case $d=1$, then it is equivalent to asking is \\n$$gcd(a_1,a_2,...a_k) = 1$$ \\n(since only 1 divides 1).\\n\\nNow, the gcd can only ever get smaller when you add more numbers to the set of numbers to analyze the gcd() of. I.e.\\n\\n$$gcd(a_1,a_2,...a_{k-1}) \\\\geq gcd(a_1,a_2,...a_k)$$\\n\\nSo, although the questions asks for if there are any *subsets* of the provided array that fulfil the above property, the easier thing to do actually is to just, take the gcd() of the entire array in a rolling-basis, and return true the moment that rolling gcd() is equal to 1.\\n\\nWe don\\'t need to individually trial each possible subset, because of the property above that the gcd() only gets smaller with each element added. So, effectively, the gcd() of the whole array is the *minimum possible gcd* of the entire array. \\n\\nSo, if even *that* doesn\\'t get us down to 1, then the answer return should be false.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of a gcd operations is O(log(min(a, b))), for some gcd(a,b) operation. Since we analyze the gcd across all elements in the vector, the time complexity is in the order of O(n logm), with m being the average \\'magnitude\\' of the numbers of the array, of size n.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant space O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        /* linear diophantine equations */\\n\\n        if (nums.size() == 1) return (nums[0] == 1);\\n\\n        int currgcd = nums[0];\\n        if (currgcd == 1) return true;\\n\\n        for (int i=1;i<nums.size();i++){\\n            currgcd = __gcd(currgcd, nums[i]);\\n            if (currgcd == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        /* linear diophantine equations */\\n\\n        if (nums.size() == 1) return (nums[0] == 1);\\n\\n        int currgcd = nums[0];\\n        if (currgcd == 1) return true;\\n\\n        for (int i=1;i<nums.size();i++){\\n            currgcd = __gcd(currgcd, nums[i]);\\n            if (currgcd == 1) return true;\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895910,
                "title": "c-simple-solution",
                "content": "# Intuition\\nTo use the concept of Linear Diophantine Equation.\\n\\n# Approach\\nLinear Diophantine Equation is a equation that can be written in the form ax + by = c  where c is the gcd of a and b.\\nSo as per the question we just need to check if the gcd of two numbers leads to 1 (any two) then after any array element with gcd 1 will give 1 so the overall is 1.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(Log(N))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans = __gcd(ans, nums[i]);\\n        }\\n        if(ans == 1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int ans = nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            ans = __gcd(ans, nums[i]);\\n        }\\n        if(ans == 1)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869969,
                "title": "1250-check-for-good-array-c-easiest-solution",
                "content": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/71223fda-af0c-4be5-ab0a-f7af5d5365bc_1669989430.722525.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "**If You Like, Please Upvote.**\\n\\n![image](https://assets.leetcode.com/users/images/71223fda-af0c-4be5-ab0a-f7af5d5365bc_1669989430.722525.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2815805,
                "title": "c-solution-easy-explaination-short-and-simple-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        // Bezout Lemma\\n        // If GCD(a,b) = d\\n        // Then there will exist x,y such that (ax + by = d)\\n\\n        int gc = 0;\\n        for(int i=0;i<nums.size();i++){\\n            gc = gcd(gc,nums[i]);\\n            if(gc == 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        // Bezout Lemma\\n        // If GCD(a,b) = d\\n        // Then there will exist x,y such that (ax + by = d)\\n\\n        int gc = 0;\\n        for(int i=0;i<nums.size();i++){\\n            gc = gcd(gc,nums[i]);\\n            if(gc == 1) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803451,
                "title": "easy-approach-with-gcd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif ax+by = 1 where x and y are integer. then gcd(a,b) = 1.\\nthen for n numbers gcd(a,b,c,d, ......., n) = 1.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ncalculate gcd for every element in nums array.\\nif that is 1 return true.\\n\\n# Complexity\\n- Time complexity:O(nlog(min(a,nums[i]))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a = 0;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            a = __gcd(a,nums[i]);\\n        }\\n        return a == 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a = 0;\\n\\n        for(int i = 0 ; i < nums.size() ; i++){\\n            a = __gcd(a,nums[i]);\\n        }\\n        return a == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777568,
                "title": "python-easy-solution-using-euclidean-algorithm",
                "content": "-approch: finding the gcd of the whole numbers of the array check if it is 1 return True\\n```\\nclass Solution:\\n    def gcd(self,a,b):\\n        while a%b != 0:\\n            mod = a%b\\n            a = b\\n            b = mod \\n        return b\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gc = nums[0]\\n        for i in range(1,len(nums)):\\n            gc = self.gcd(gc,nums[i])\\n        return True if gc == 1 else False\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def gcd(self,a,b):\\n        while a%b != 0:\\n            mod = a%b\\n            a = b\\n            b = mod \\n        return b\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        gc = nums[0]\\n        for i in range(1,len(nums)):\\n            gc = self.gcd(gc,nums[i])\\n        return True if gc == 1 else False\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773745,
                "title": "easiest-ever-of-all-solutions-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a=__gcd(a,nums[i]);\\n            \\n        }\\n        if(a==1)\\n            return true;\\n        else\\n            return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int a=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            a=__gcd(a,nums[i]);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2773604,
                "title": "easy-to-understand-3-line-python-solution-math",
                "content": "\"\"\" In order for two numbers to be multiplied by any number and give a sum of 1 they must have no common factor except one \"\"\"\\n\\nclass Solution: \\n\\tdef isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        cur = nums[0]\\n        for i in range(1, len(nums)):\\n           cur = math.gcd(cur, nums[i])\\n        \\n        return cur == 1",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "\"\"\" In order for two numbers to be multiplied by any number and give a sum of 1 they must have no common factor except one \"\"\"\\n\\nclass Solution: \\n\\tdef isGoodArray(self, nums: List[int]) -> bool:\\n        \\n        cur = nums[0]\\n        for i in range(1, len(nums)):\\n           cur = math.gcd(cur, nums[i])\\n        \\n        return cur == 1",
                "codeTag": "Java"
            },
            {
                "id": 2739714,
                "title": "python-easy-and-well-explain-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:nlogx(m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        #note: math.gcd function only used in Python3\\n        #Using *nums we can pass full array as a argument \\n        if math.gcd(*nums) == 1:\\n            return True\\n        else:\\n            return False\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        #note: math.gcd function only used in Python3\\n        #Using *nums we can pass full array as a argument \\n        if math.gcd(*nums) == 1:\\n            return True\\n        else:\\n            return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717864,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        a = nums[0]\\n        for i in range(len(nums)):\\n            while nums[i]:\\n                a, nums[i] =nums[i], a % nums[i]\\n        return a == 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        a = nums[0]\\n        for i in range(len(nums)):\\n            while nums[i]:\\n                a, nums[i] =nums[i], a % nums[i]\\n        return a == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697627,
                "title": "easy-solution-python-clear-code-gcd",
                "content": "Check this easy solution by using GCD=>\\n\\n\\'\\'\\'\\nclass Solution:\\n     def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1\\n\\t\\t\\'\\'\\'\\n",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "Check this easy solution by using GCD=>\\n\\n\\'\\'\\'\\nclass Solution:\\n     def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1\\n\\t\\t\\'\\'\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 2672439,
                "title": "java-solution-simple-and-easy",
                "content": "Just an observartion :\\n\\nStart finding gcd of all the elements as you traverse the array ****(gcd_till_now : gcd from 0th index to ith index)****, if at any point **gcd_till_now becomes 1 return true**.\\n\\n**Otherwise return false**.\\n\\n**JAVA**\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n\\n        int n=nums.length;\\n        int gcd_till_now=0;\\n        for(int i=0;i<n;i++){\\n            gcd_till_now=gcd(gcd_till_now,nums[i]);\\n            if(gcd_till_now==1) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    static int gcd(int a, int b){\\n\\n        //Euclid Algo to find GCD of two numbers\\n        if(b==0) return a;\\n\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n\\n        int n=nums.length;\\n        int gcd_till_now=0;\\n        for(int i=0;i<n;i++){\\n            gcd_till_now=gcd(gcd_till_now,nums[i]);\\n            if(gcd_till_now==1) return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    static int gcd(int a, int b){\\n\\n        //Euclid Algo to find GCD of two numbers\\n        if(b==0) return a;\\n\\n        return gcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2650425,
                "title": "very-nice-question",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0] == 1;\\n        return f(nums) == 1;\\n    }\\n    private int gcd(int a, int b){\\n        if(a%b==0) return b;\\n        return gcd(b,a%b);\\n    }\\n    private int f(int[] nums){\\n        int g = gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            if(g == 1) return 1;\\n            g = gcd(nums[i],g);\\n        }\\n        return g;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n = nums.length;\\n        if(n == 1) return nums[0] == 1;\\n        return f(nums) == 1;\\n    }\\n    private int gcd(int a, int b){\\n        if(a%b==0) return b;\\n        return gcd(b,a%b);\\n    }\\n    private int f(int[] nums){\\n        int g = gcd(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            if(g == 1) return 1;\\n            g = gcd(nums[i],g);\\n        }\\n        return g;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635347,
                "title": "c-solution-gcd",
                "content": "Eq. ax+by=1 has solution x, y if gcd(a,b) = 1.\\nCan you generalize the formula?. Check B\\xE9zout\\'s lemma.\\n\\nSolution : ax + by + cz + ... = d\\nso gcd(a,b,c,...) = d\\n```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n    while (a%b != 0){\\n        int rem=a%b;\\n        a=b;\\n        b=rem;\\n    }\\n    return b;\\n}\\n\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcds = 0;\\n        for(int i= 0; i < nums.size();i++){\\n            gcds = gcd(gcds,nums[i]);\\n        }\\n        return gcds==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int gcd(int a, int b){\\n    while (a%b != 0){\\n        int rem=a%b;\\n        a=b;\\n        b=rem;\\n    }\\n    return b;\\n}\\n\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcds = 0;\\n        for(int i= 0; i < nums.size();i++){\\n            gcds = gcd(gcds,nums[i]);\\n        }\\n        return gcds==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629091,
                "title": "java-using-gcd-method-o-n",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int g = nums[0];\\n        if(nums.length == 0)\\n            return true;\\n        if(nums.length == 1 && nums[0] == 1)\\n            return true;\\n        for(int  i = 1 ;i < nums.length ;i++)\\n        {\\n            g = Gcd(g,nums[i]);\\n            if(g == 1)\\n                return true;\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public int Gcd(int num1,int num2){\\n        while(num1 % num2 != 0){\\n            int remainder = num1 % num2;\\n            num1 = num2;\\n            num2 = remainder;\\n        }\\n        return num2;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n       int g = nums[0];\\n        if(nums.length == 0)\\n            return true;\\n        if(nums.length == 1 && nums[0] == 1)\\n            return true;\\n        for(int  i = 1 ;i < nums.length ;i++)\\n        {\\n            g = Gcd(g,nums[i]);\\n            if(g == 1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2614668,
                "title": "simple-math-problem-c",
                "content": "The key idea is **B\\xE9zout\\'s identity**.\\n\\n[check wikipedia](https://en.wikipedia.org/wiki/B\\xE9zout%27s_identity)\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for (auto & e : nums){\\n            g = __gcd(g, e);    \\n        }\\n        return (g == 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = 0;\\n        for (auto & e : nums){\\n            g = __gcd(g, e);    \\n        }\\n        return (g == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2543689,
                "title": "c-easy-solution-math-dp-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>&nums,int index, int curr,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 0;\\n        }\\n        if(__gcd(curr,nums[index])==1){\\n            return dp[index]=1;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index]=fun(nums,index+1,__gcd(curr,nums[index]),dp)|fun(nums,index+1,curr,dp);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        if(nums.size()==1)return 0;\\n        vector<int>dp(nums.size()+1,-1);\\n        return fun(nums,1,nums[0],dp);\\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>&nums,int index, int curr,vector<int>&dp){\\n        if(index==nums.size()){\\n            return 0;\\n        }\\n        if(__gcd(curr,nums[index])==1){\\n            return dp[index]=1;\\n        }\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index]=fun(nums,index+1,__gcd(curr,nums[index]),dp)|fun(nums,index+1,curr,dp);\\n    }\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()==1 and nums[0]==1)return 1;\\n        if(nums.size()==1)return 0;\\n        vector<int>dp(nums.size()+1,-1);\\n        return fun(nums,1,nums[0],dp);\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519436,
                "title": "simple-solution-using-loops-bezout-s-identity",
                "content": "public boolean isGoodArray(int[] nums) {\\n        \\n        // this the base case\\n        if(nums.length == 0 || nums == null) return true;\\n        if(nums.length == 1) return nums[0] == 1;\\n        \\n        int gcdResult = nums[0];\\n        \\n        // storing GCD of two numbers and then finding new GCD with GCD of previous two numbers and next number and so on.\\n        //And where we find GCD = 1 we return true and if we not we just return false.\\n        for(int i = 1; i < nums.length; i++){\\n            gcdResult = gcd(gcdResult, nums[i]);\\n            if(gcdResult == 1) return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    //method to find GCD of two numbers\\n    public int gcd(int num1, int num2){\\n    \\n            while(num1 % num2 != 0){\\n                int remainder = num1 % num2;\\n                num1 = num2;\\n                num2 = remainder;\\n            }\\n            return num2;\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public boolean isGoodArray(int[] nums) {\\n        \\n        // this the base case\\n        if(nums.length == 0 || nums == null) return true;\\n        if(nums.length == 1) return nums[0] == 1;\\n        \\n        int gcdResult = nums[0];\\n        \\n        // storing GCD of two numbers and then finding new GCD with GCD of previous two numbers and next number and so on.\\n        //And where we find GCD = 1 we return true and if we not we just return false.\\n        for(int i = 1; i < nums.length; i++){\\n            gcdResult = gcd(gcdResult, nums[i]);\\n            if(gcdResult == 1) return true;\\n        }\\n        return false;\\n        \\n    }\\n    \\n    //method to find GCD of two numbers\\n    public int gcd(int num1, int num2){\\n    \\n            while(num1 % num2 != 0){\\n                int remainder = num1 % num2;\\n                num1 = num2;\\n                num2 = remainder;\\n            }\\n            return num2;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2481750,
                "title": "c-number-theory",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            if(nums.size()==1){\\n                if(nums[0]==1)return true;\\n                else return false;\\n            }\\n            if(__gcd(nums[0],nums[1])==1){\\n                return true;\\n            }\\n            return false;\\n        }\\n        else{\\n            int x=__gcd(nums[0],nums[1]);\\n            for(int i=2;i<nums.size();i++){\\n                x=__gcd(x,nums[i]);\\n            }\\n            if(x==1)return true;\\n            else return false;\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size()<=2){\\n            if(nums.size()==1){\\n                if(nums[0]==1)return true;\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2435203,
                "title": "c-easy-to-understand",
                "content": "~~~\\nclass Solution {\\npublic:\\n   \\nint gcd(int a,int b){\\n    if(a<b){\\n        swap(a,b);\\n    }\\n    if(b==0){\\n        return a;\\n    }\\n    return gcd(b,a%b);\\n}\\nbool isGoodArray(vector<int> nums) {\\n    int ans=0;\\n    for(auto i:nums)\\n    {\\n        ans=gcd(i,ans);\\n    }\\n    return ans==1;\\n}\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\nint gcd(int a,int b){\\n    if(a<b){\\n        swap(a,b);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2416970,
                "title": "c-explained-beginner",
                "content": "Extended Eucild theorem:  **ax+by = gcd(a,b)**\\nTo get ax+by=1 , we need to get two integer a , b in array such that their gcd(Greatest common divisor) is equal to 1. \\n**GCD(a,b)=1**\\n\\n\\tint gcd(int a , int b)\\n    {\\n        if (b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    int gcd_arr(vector<int> & v1)\\n    {\\n        int ans=v1[0];\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=gcd(v1[i],ans);\\n        }\\n        return ans;\\n    }\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        return gcd_arr(nums)==1 ? true:false;\\n    }",
                "solutionTags": [],
                "code": "Extended Eucild theorem:  **ax+by = gcd(a,b)**\\nTo get ax+by=1 , we need to get two integer a , b in array such that their gcd(Greatest common divisor) is equal to 1. \\n**GCD(a,b)=1**\\n\\n\\tint gcd(int a , int b)\\n    {\\n        if (b==0) return a;\\n        return gcd(b,a%b);\\n    }\\n    int gcd_arr(vector<int> & v1)\\n    {\\n        int ans=v1[0];\\n        for (int i=0;i<v1.size();i++)\\n        {\\n            ans=gcd(v1[i],ans);\\n        }\\n        return ans;\\n    }\\n    bool isGoodArray(vector<int>& nums) \\n    {\\n        return gcd_arr(nums)==1 ? true:false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2329587,
                "title": "fundamental-approach-c-gcd-math",
                "content": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = nums[0];\\n        for(auto i:nums) {\\n            g = gcd(g, i);\\n        }\\n        return (g == 1);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int g = nums[0];\\n        for(auto i:nums) {\\n            g = gcd(g, i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2317234,
                "title": "check-if-its-a-good-array",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i =1; i<nums.length; i++){\\n           gcd = GCD(gcd, nums[i]);\\n            if (gcd==1)\\n                return true;\\n        }\\n        return gcd ==1;\\n        \\n    }\\n    int GCD(int a, int b){\\n        if(b==0){\\n            return a;\\n        }\\n        else{\\n            return GCD(b, a%b);\\n        }\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int gcd = nums[0];\\n        for(int i =1; i<nums.length; i++){\\n           gcd = GCD(gcd, nums[i]);\\n            if (gcd==1)\\n                return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2307248,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0];\\n        if(nums.length == 1 && x==1)\\n            return true;\\n        for(int y : nums)\\n        {\\n            if (GCD(x,y)==1)\\n                return true;\\n            x = GCD(x,y);\\n        }\\n        return false;\\n    }\\n    public int GCD(int x,int y)\\n    {\\n        if(x==0)\\n            return y;\\n        return GCD(y%x,x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int x = nums[0];\\n        if(nums.length == 1 && x==1)\\n            return true;\\n        for(int y : nums)\\n        {\\n            if (GCD(x,y)==1)\\n                return true;\\n            x = GCD(x,y);\\n        }\\n        return false;\\n    }\\n    public int GCD(int x,int y)\\n    {\\n        if(x==0)\\n            return y;\\n        return GCD(y%x,x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2305986,
                "title": "easy-to-understand-4-line-c-code",
                "content": "**The only reason I\\'m posting this is because I solved my 2nd hard problem of the day.**\\nSo, something that I was able to deduce from the testcases was the prevalance of prime numbers in the solution array. And an array of composite numbers will automatically yield a \\'false\\' output.\\nProof-  Input array- [a,b]. Let\\'s assume a and b are composite in nature\\n\\t\\t\\ttherefore a=GCD*x and b=GCD*y\\n\\t\\t\\tsum= m*a + n*b = m*GCD*x + n*GCD*y = GCD(m*x + n*y)\\n\\t\\t\\tThe only way sum=1 is if GCD=1 (and m*x + n*y=1). Else sum=0 or some other value.\\n\\t\\t\\t***This contradicts our assumption of a and b being composite is nature, hence they must be prime i.e GCD=1***\\n\\t\\t\\t\\n\\n```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd=0;\\n        for(int i=0; i<nums.size(); i++){\\n            gcd=__gcd(gcd,nums[i]);\\n        }return gcd==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gcd=0;\\n        for(int i=0; i<nums.size(); i++){\\n            gcd=__gcd(gcd,nums[i]);\\n        }return gcd==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2304951,
                "title": "python-gcd-100-memory-usage",
                "content": "def isGoodArray(self, nums):\\n\\n        if len(nums) == 1:\\n            return nums[0] == 1\\n\\t\\t\\t\\n        def gcd(a, b):\\n            if a == 0 :\\n                return b\\n\\n            return gcd(b%a, a)\\n        \\n        for i in range(1,len(nums)):\\n            greatest_denom = gcd(nums[i-1],nums[i])\\n            if greatest_denom == 1:\\n                return True\\n            nums[i] = greatest_denom\\n        return False",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "def isGoodArray(self, nums):\\n\\n        if len(nums) == 1:\\n            return nums[0] == 1\\n\\t\\t\\t\\n        def gcd(a, b):\\n            if a == 0 :\\n                return b\\n\\n            return gcd(b%a, a)\\n        \\n        for i in range(1,len(nums)):\\n            greatest_denom = gcd(nums[i-1],nums[i])\\n            if greatest_denom == 1:\\n                return True\\n            nums[i] = greatest_denom\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2281234,
                "title": "python-for-beginners-with-explanation",
                "content": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums)==1\\n\\n    # Reduce function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along\\n    \"\"\"\\n    Working:\\n    (1)At first step, first two elements of sequence are picked and the result is obtained.\\n    (2)Next step is to apply the same function to the previously attained result and the number just succeeding the second element and the result is again stored.\\n    (3)This process continues till no more elements are left in the container.\\n    \\n    To find Highest Common Factor (H.C.F) python has built-in functions (GCD) \\n    \"\"\"\\n           \\n```",
                "solutionTags": [],
                "code": "```\\nfrom math import gcd\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        return reduce(gcd,nums)==1\\n\\n    # Reduce function is used to apply a particular function passed in its argument to all of the list elements mentioned in the sequence passed along\\n    \"\"\"\\n    Working:\\n    (1)At first step, first two elements of sequence are picked and the result is obtained.\\n    (2)Next step is to apply the same function to the previously attained result and the number just succeeding the second element and the result is again stored.\\n    (3)This process continues till no more elements are left in the container.\\n    \\n    To find Highest Common Factor (H.C.F) python has built-in functions (GCD) \\n    \"\"\"\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186811,
                "title": "easy-explaination",
                "content": "If we can find a subset with gcd as 1, it would be possible to attain the answer. \\n\\n```\\nclass Solution {\\n    int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currGcd = nums[0];\\n        for(int i=1;i<n;i++){\\n            currGcd = gcd(currGcd, nums[i]);\\n        }\\n        return currGcd == 1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    int gcd(int a, int b){\\n        if(b==0) return a;\\n        return gcd(b, a%b);\\n    }\\n    \\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int n = nums.size();\\n        int currGcd = nums[0];\\n        for(int i=1;i<n;i++){\\n            currGcd = gcd(currGcd, nums[i]);\\n        }\\n        return currGcd == 1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2181400,
                "title": "check-common-divisor",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    bool isGoodArray(vector<int>& nums){\\n        \\n        sort(nums.begin(),nums.end());\\n        int num = nums[0];\\n        if(nums.size() == 1) return nums[0] == 1;\\n        \\n        // finding the divisor of nums[0];\\n        int g = nums[0];\\n        for(int i = 1;i < nums.size() ; i++){\\n             g = gcd(g,nums[i]);\\n        }\\n        if(g == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int gcd(int a, int b){\\n        if (a == 0)\\n            return b;\\n        return gcd(b % a, a);\\n    }\\n    \\n    bool isGoodArray(vector<int>& nums){\\n        \\n        sort(nums.begin(),nums.end());\\n        int num = nums[0];\\n        if(nums.size() == 1) return nums[0] == 1;\\n        \\n        // finding the divisor of nums[0];\\n        int g = nums[0];\\n        for(int i = 1;i < nums.size() ; i++){\\n             g = gcd(g,nums[i]);\\n        }\\n        if(g == 1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139601,
                "title": "euler-s-theorem",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd = nums[0];\\n        for (int i = 1, ed = nums.size(); i < ed; i ++) {\\n            gd = __gcd(gd, nums[i]);\\n        }\\n        return gd == 1;\\n    }\\n};\\n```\\n\\nEuler\\'s theorem: for every two numbers **a** and **b** where gcd(a, b) = 1, a^(\\u03C6(b)) = 1 (mod b), where \\u03C6(b) is the number of integers coprime to b in [1, b-1]. Therefore, only if there exists coprime numbers in nums, there has answer",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        int gd = nums[0];\\n        for (int i = 1, ed = nums.size(); i < ed; i ++) {\\n            gd = __gcd(gd, nums[i]);\\n        }\\n        return gd == 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117457,
                "title": "java-easy-solution-check-if-it-is-a-good-array",
                "content": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n          \\n        }\\n        return gcd==1;\\n}\\n        public int gcd(int n1, int n2) {\\n   if (n2==0) return n1;\\n   return gcd(n2,n1%n2);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isGoodArray(int[] nums) {\\n    int gcd=nums[0];\\n        for(int i=1; i<nums.length; i++){\\n            gcd=gcd(gcd, nums[i]);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2096387,
                "title": "simple-javascript-solution-easy-to-understand",
                "content": "```\\nfunction isGoodArray(n, ans = n.shift()) {\\n    for (let i of n) {\\n        while (i) [ans, i] = [i, ans % i]\\n    }\\n    return ans === 1\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isGoodArray(n, ans = n.shift()) {\\n    for (let i of n) {\\n        while (i) [ans, i] = [i, ans % i]\\n    }\\n    return ans === 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2087411,
                "title": "simple-java-solution",
                "content": "Basically, 1 can be achieved if the numbers do not have common divisors, so their greatest common divisor must be 1. C++ gives an inbuilt function to find gcd, but for java we gotta do it ourselves.\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1 && nums[0] == 1)\\n            return true;\\n        \\n        int gcd = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int a = (nums[i] > gcd) ? nums[i] : gcd;\\n            int b = (nums[i] < gcd) ? nums[i] : gcd;\\n            int r = b;\\n            while (a % b != 0) {\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            \\n            gcd = r;\\n            if (gcd == 1) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        if (nums.length == 1 && nums[0] == 1)\\n            return true;\\n        \\n        int gcd = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            \\n            int a = (nums[i] > gcd) ? nums[i] : gcd;\\n            int b = (nums[i] < gcd) ? nums[i] : gcd;\\n            int r = b;\\n            while (a % b != 0) {\\n                r = a % b;\\n                a = b;\\n                b = r;\\n            }\\n            \\n            gcd = r;\\n            if (gcd == 1) {\\n                return true;\\n            }\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2082496,
                "title": "5-lines-python-solution-beats-93",
                "content": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isGoodArray(self, nums: List[int]) -> bool:\\n        def gcd(a,b):\\n            while a:\\n                a, b = b%a, a\\n            return b\\n        return reduce(gcd,nums)==1",
                "codeTag": "Java"
            },
            {
                "id": 2068849,
                "title": "c-solution-using-gcd",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 && nums[0] == 1) return true;\\n        \\n        int tmp = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            tmp = __gcd(tmp, nums[i]);\\n            if(tmp == 1) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool isGoodArray(vector<int>& nums) {\\n        if(nums.size() == 1 && nums[0] == 1) return true;\\n        \\n        int tmp = nums[0];\\n        for(int i=1; i<nums.size(); i++){\\n            tmp = __gcd(tmp, nums[i]);\\n            if(tmp == 1) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1985871,
                "title": "javascript-simple-and-direct-solution",
                "content": "```\\nvar isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isGoodArray = function(nums) {\\n    let gcd = nums[0]\\n    \\n    for(let n of nums){while(n){[gcd, n] = [n, gcd % n]}}\\n    \\n    return (gcd === 1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1984412,
                "title": "simple-gcd-approach-java",
                "content": "The diffrence can only be 1 if and only if there are 2  numbers whose GCD is 1 \\neg 2 4 7 11\\ngcd of (2,4)=2\\ngcd of(2,7)=1 \\nso it is possible 2*(-3)-7*(-1)=1\\n```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n=nums.length;\\n        if(n==1&&nums[0]==1)\\n            return true;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=fnGcd(ans,nums[i]);\\n            if(ans==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n    public int fnGcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return fnGcd(b,a%b);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isGoodArray(int[] nums) {\\n        int n=nums.length;\\n        if(n==1&&nums[0]==1)\\n            return true;\\n        int ans=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            ans=fnGcd(ans,nums[i]);\\n            if(ans==1)\\n                return true;\\n        }\\n        return false;\\n    }\\n    public int fnGcd(int a,int b)\\n    {\\n        if(b==0)\\n            return a;\\n        return fnGcd(b,a%b);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565240,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565996,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566586,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566585,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1569672,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1781708,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1573164,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2045382,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2012469,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1930957,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565240,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1565996,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566586,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1566585,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1569672,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1781708,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1573164,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2045382,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 2012469,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            },
            {
                "id": 1930957,
                "content": [
                    {
                        "username": "kkkkcom",
                        "content": "It is not that hard to figure out if GCD is not 1, you won\\'t be able to get a sum of 1. Becuase:\\n\\na = GCD * n\\nb = GCD * m\\n\\nsum = p * a + q * b = p * GCD * n + q * GCD * m = GCD * (pn+qm)\\n\\nSo sum will either be 0 or multiple of GCD.\\n\\nWhat was not clear to me was why the smallest sum can be 1 * GCD but not other multiple of k * GCD. I was not able to figure this out during contest, but my intuition was that this can be achieved, so I just submitted without clear formal proof in my head, and just luckily got accepted.\\n\\nBezout\\'s Identity is the answer to the above question. And my explanation below is more or less similar to what was stated on wiki page, but with some expasion for dumb people like me to better understand.\\n\\nLet\\'s assume d is the smallest sum of p * a + q * b, written as d = pp * a + qq * b\\na can be expressed as a = k * d + r\\nWhere k = a//d, r = a%d, so 0<=r<d\\n\\nRewrite r as\\nr = a - k * d\\nr = a - k * (pp * a + qq * b) = (1 - k * pp) * a + qq * b\\n\\nSo r is also one of the sums in the form of p * a + q * b\\nNow, since 0<=r<d, and we assume d is the smallest sum, so r has to be 0; otherwise, r will be a smaller sum than d, which contradicts our assumption.\\n\\nSo r=0 gives us a = k * d + r = k * d, and this gives us that d is a divisor of a. Similarly d is also a divisor of b. So d is a common divisor of both a and b.\\n\\nSo far up to here, it is already good enough for this problem, since in this problem, when we found GCD = 1, it will be the only common divisor, so we know d = 1 is the only option.\\n\\n*** Further more, if say GCD = 18, then above only shows d can be common divisor for a and b. So d can still be 2 or 3 or 6 or 9. Now assume c is another common divisor than d, we will see:\\na = c * aa\\nb = c * bb\\nd = pp * a + qq * b = pp * c * aa + qq * c * bb = c * (pp * aa + qq * bb)\\n\\nSo c must be a divisor of d. Since we can pick any common divisor for c, that means d has to be GCD, otherwise we can find a c = GCD which is not a divisor of d.\\n\\nI know my explanation may still seem hard to follow, but I\\'ve tried my best ...\\n\\n\\n"
                    },
                    {
                        "username": "liketheflower",
                        "content": "Lots of posts mentioned that GCD caculation is O(1). Why?\\nI\\'d like to share a detail analysis from a lecture note.  Also this lecture note is a good one if you want to understand more about number thoery required for a CS student.\\nFirst, GCD caculation is related to The Euclidean algorithm  \\n\"gcd(a0,a1) = gcd(a1,a2) = ... = gcd(ak\\u22121,ak) \"   (check the lecture notes 2. The Euclidean algorithm to get details)   \\nSecond, GCD caculation:\\n \"a_i is always an upper bound on some Fibonacci number  \"  \\n \"This shows that the number of steps in the Euclidean algorithm is logarithmic in a0, which means linear in the number of bits required to represent a0. \"  \\n  (check the lecture notes 3 Why not brute force?  to get details)   \\n  \\n Third, we have the constraints that 1 <= nums[i] <= 10^9, as math.log(10^9, 2)=29.897352853986263, we will have time complexity of GCD as O(30) in the worst case.  This explains why the time complexity of GCD is O(1)\\n \\n As far as I know, the following post gave a similar analysis, please also give credits to this post if you feel it is helpful.\\n https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419329/O(n)-solution/378434\\n \\n Lecture notes:\\n  http://www.cs.hunter.cuny.edu/~saad/courses/dm/notes/note7.pdf\\n"
                    },
                    {
                        "username": "harttle",
                        "content": "Here\\'s proofs for Bezout\\'s theorem for n = 2:\\n\\n![image](https://assets.leetcode.com/users/harttle/image_1572758497.png)\\n\\nkaiwensun gives a more detailed text version, see: https://leetcode.com/problems/check-if-it-is-a-good-array/discuss/419529/Why-GCD-Look-proof-here!Python2-1-line."
                    },
                    {
                        "username": "flyingpenguin",
                        "content": "I experimented during the contest that any two co prime number can make up 1 somehow but I can\\'t prove it mathematically....\\n\\nWould appreciate any proof..."
                    },
                    {
                        "username": "kathylin",
                        "content": "gcd(a, b) = minimum positive linear combination of a and b\\n\\nproof: https://math.stackexchange.com/questions/219941/is-greatest-common-divisor-of-two-numbers-really-their-smallest-linear-combinati"
                    },
                    {
                        "username": "Aditya_Kumdale",
                        "content": "Learn eucledian algorithm of gcd first rest of the part is easy"
                    },
                    {
                        "username": "hCaulfield",
                        "content": "(sufficient)\\nIf two number are coprime, then there exist their linear combination which has value 1 (by [Euler\\'s Theorem](https://en.wikipedia.org/wiki/Euler%27s_theorem)). So two number has a linear combination whose value is their gcd. (Coprime b and c has linear combination 1 then ab and ac can make a*1=a). It\\'s obviously to extend to finitely many numbers.\\n\\n(necessary)\\nThe numbers\\' linear combination must be a multipler of their gcd.\\n"
                    },
                    {
                        "username": "harshpreet931",
                        "content": "I feel like this question should be Medium or is it just me lol"
                    },
                    {
                        "username": "only_anagha",
                        "content": "why is it expecting the result to be true for nums = [6, 10, 15], when it\\'s clearly visible to be false?"
                    },
                    {
                        "username": "1rn21is163",
                        "content": "because the gcd of 6, 10 and 15 is 1"
                    },
                    {
                        "username": "AlexanderFadeev",
                        "content": "I am getting an error for \"empty\" solution\\n```\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```"
                    }
                ]
            }
        ]
    },
    {
        "title": "Delivering Boxes from Storage to Ports",
        "question_content": "<p>You have the task of delivering some boxes from storage to their ports using only one ship. However, this ship has a <strong>limit</strong> on the <strong>number of boxes</strong> and the <strong>total weight</strong> that it can carry.</p>\n\n<p>You are given an array <code>boxes</code>, where <code>boxes[i] = [ports<sub>​​i</sub>​, weight<sub>i</sub>]</code>, and three integers <code>portsCount</code>, <code>maxBoxes</code>, and <code>maxWeight</code>.</p>\n\n<ul>\n\t<li><code>ports<sub>​​i</sub></code> is the port where you need to deliver the <code>i<sup>th</sup></code> box and <code>weights<sub>i</sub></code> is the weight of the <code>i<sup>th</sup></code> box.</li>\n\t<li><code>portsCount</code> is the number of ports.</li>\n\t<li><code>maxBoxes</code> and <code>maxWeight</code> are the respective box and weight limits of the ship.</li>\n</ul>\n\n<p>The boxes need to be delivered <strong>in the order they are given</strong>. The ship will follow these steps:</p>\n\n<ul>\n\t<li>The ship will take some number of boxes from the <code>boxes</code> queue, not violating the <code>maxBoxes</code> and <code>maxWeight</code> constraints.</li>\n\t<li>For each loaded box <strong>in order</strong>, the ship will make a <strong>trip</strong> to the port the box needs to be delivered to and deliver it. If the ship is already at the correct port, no <strong>trip</strong> is needed, and the box can immediately be delivered.</li>\n\t<li>The ship then makes a return <strong>trip</strong> to storage to take more boxes from the queue.</li>\n</ul>\n\n<p>The ship must end at storage after all the boxes have been delivered.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of <strong>trips</strong> the ship needs to make to deliver all boxes to their respective ports.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [[1,1],[2,1],[1,1]], portsCount = 2, maxBoxes = 3, maxWeight = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The optimal strategy is as follows: \n- The ship takes all the boxes in the queue, goes to port 1, then port 2, then port 1 again, then returns to storage. 4 trips.\nSo the total number of trips is 4.\nNote that the first and third boxes cannot be delivered together because the boxes need to be delivered in order (i.e. the second box needs to be delivered at port 2 before the third box).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [[1,2],[3,3],[3,1],[3,1],[2,4]], portsCount = 3, maxBoxes = 3, maxWeight = 6\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal strategy is as follows: \n- The ship takes the first box, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the second, third and fourth boxes, goes to port 3, then returns to storage. 2 trips.\n- The ship takes the fifth box, goes to port 2, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> boxes = [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]], portsCount = 3, maxBoxes = 6, maxWeight = 7\n<strong>Output:</strong> 6\n<strong>Explanation:</strong> The optimal strategy is as follows:\n- The ship takes the first and second boxes, goes to port 1, then returns to storage. 2 trips.\n- The ship takes the third and fourth boxes, goes to port 2, then returns to storage. 2 trips.\n- The ship takes the fifth and sixth boxes, goes to port 3, then returns to storage. 2 trips.\nSo the total number of trips is 2 + 2 + 2 = 6.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= boxes.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= portsCount, maxBoxes, maxWeight &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= ports<sub>​​i</sub> &lt;= portsCount</code></li>\n\t<li><code>1 &lt;= weights<sub>i</sub> &lt;= maxWeight</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 969518,
                "title": "dp-sliding-window-o-n-time-and-space",
                "content": "**Observations:**\\n(1) Boxes must be handled in order from left to right, this is a signal to use DP.\\n(2)  Since it is 10^5. DP must be 1-dimension, i.e, for every index `i` we need to find a single index `j` and apply `DP[i] = f(DP[j])` for some DP function `f`. \\n\\nLet `dp[i+1]` be the minimum cost (# of ships) to process all boxes from 0 to i and return to the storage. \\n\\nFrom observation (2), we need to find the best position `start` where we can load up all boxes from `start` to `i` and then go in a single voyage, then `dp[i+1] = dp[start] + something`.\\n\\nTo find `start`, we use **sliding window**. We slide `start` forward for 3 reasons:\\n1. limit # of boxes in 1 voyage\\n2. limit total weight in 1 voyage\\n3. No benefit to load the box at position `start` (i.e `dp[start] == dp[start+1]`), because the cost to keep the box on the ship is at most 1. (More explanation for Policy 3 at the end of the post).\\n\\nMore details in the code. \\n\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] A, int portsCount, int m1, int m2) {\\n        int n = A.length;\\n        \\n        boolean[] C = new boolean[n]; // consecutive ports are different or not\\n        for (int i = 0; i< n-1; i++){\\n            if (A[i][0] != A[i+1][0]) C[i] = true;\\n        }\\n        \\n        int[] dp = new int[n+1];\\n        int sum = 0; // total current weight on the ship\\n        int start = 0; // load all boxes from start to i in one voyage\\n        int diff = 0; // # different consecutive ports between start and i\\n        \\n        for (int i = 0; i< n; i++){\\n            if (i-start == m1) { // drop 1 box because of # boxes constraint\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n            \\n            // Add box i, update current weight and diff\\n            sum+= A[i][1];\\n            if (i> 0 && C[i-1]) diff++;\\n            \\n            while (sum > m2){ // drop more boxex because of weight constraint\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n\\n            while(start < i && dp[start] == dp[start+1]){\\n                // drop more boxes if there is no point to carry them\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n            \\n            dp[i+1] = diff+2 + dp[start];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n\\nAnswer question `why we stop dropping when dp[start + 1] > dp[start]` by @cpcs:\\n\\nIn fact, every `j` from `start` onward (after applying 3 policies above) have the following properties:\\n(a) The cost to keep the box `j` on the ship is  0 if `A[j][0] = A[j+1][0]` (i.e. same ports), and is 1 if `A[j][0] != A[j+1][0]`.\\n(b) if `A[j][0] != A[j+1][0]` then  `dp[j + 2] >  dp[j+1]`.\\n\\nThis means that if we drop box j and save 1 cost thanks to Observation (a), we have to pay it back 1 step later if we continue to drop box j+1 thanks to Observation (b). Now you say \"yay, if I drop j but don\\'t drop j+1, then I save 1 cost\". But indeed we already pay upfront 1 cost for nothing because we drop `start` some moment ago. So all in all, we never save cost by continuing dropping boxes after satisfying all 3 policies above. This is why we stop dropping when `dp[start + 1] > dp[start]`.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int boxDelivering(int[][] A, int portsCount, int m1, int m2) {\\n        int n = A.length;\\n        \\n        boolean[] C = new boolean[n]; // consecutive ports are different or not\\n        for (int i = 0; i< n-1; i++){\\n            if (A[i][0] != A[i+1][0]) C[i] = true;\\n        }\\n        \\n        int[] dp = new int[n+1];\\n        int sum = 0; // total current weight on the ship\\n        int start = 0; // load all boxes from start to i in one voyage\\n        int diff = 0; // # different consecutive ports between start and i\\n        \\n        for (int i = 0; i< n; i++){\\n            if (i-start == m1) { // drop 1 box because of # boxes constraint\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n            \\n            // Add box i, update current weight and diff\\n            sum+= A[i][1];\\n            if (i> 0 && C[i-1]) diff++;\\n            \\n            while (sum > m2){ // drop more boxex because of weight constraint\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n\\n            while(start < i && dp[start] == dp[start+1]){\\n                // drop more boxes if there is no point to carry them\\n                sum-= A[start][1];\\n                if (C[start]) diff--;\\n                start++;\\n            }\\n            \\n            dp[i+1] = diff+2 + dp[start];\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969723,
                "title": "java-c-python-sliding-window-o-n-solution",
                "content": "# **Intuition**\\nUsually, we will greedily take as many boxes as possible.\\nBut in one case,\\nthe last several small boxes in this trip,\\nare going to the same port as the first box in the next trips.\\nWe may probably let it go in the next trip,\\nwe waste a little weight, but we can save a trip.\\n<br>\\n\\n# **Explanation**\\nThe overall solution is a sliding window problem.\\nSo you need to make sure you can understand basic sliding window solution.\\n\\nWe start to delievery boxes from each `A[i]`,\\nand we load boxes from `A[i]` to `A[j]` as many as possible.\\nAlso we record the biggest `lastj` that has the same port target,\\nthat is`A[lastj][0] = A[j][0]`.\\n\\n`dp[i]` means the number trips we need to finish the first `i` boxes.\\nNote that we can calulated `dp[i]` for each `i`,\\nbut here we apply a greediest solution and a second greediest solution,\\nwe don\\'t calculate and we don\\'t need all `dp[i]` in this process.\\n<br>\\n\\n# **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int boxDelivering(int[][] A, int portsCount, int B, int W) {\\n        int n = A.length, need = 0, j = 0, lastj = 0, dp[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && B > 0 && W >= A[j][1]) {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) {\\n                    lastj = j;\\n                    need++;\\n                }\\n                dp[++j] = 200000;\\n            }\\n            dp[j] = Math.min(dp[j], dp[i] + need + 1);\\n            dp[lastj] = Math.min(dp[lastj], dp[i] + need);\\n            B += 1;\\n            W += A[i][1];\\n            if (i == n - 1 || A[i][0] != A[i + 1][0]) {\\n                need--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int boxDelivering(vector<vector<int>>& A, int portsCount, int B, int W) {\\n        int n = A.size(), need = 0, j = 0, lastj = 0;\\n        vector<int> dp(n + 1, 200000);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && B > 0 && W >= A[j][1]) {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) {\\n                    lastj = j;\\n                    need++;\\n                }\\n                j++;\\n            }\\n            dp[j] = min(dp[j], dp[i] + need + 1);\\n            dp[lastj] = min(dp[lastj], dp[i] + need);\\n            B += 1;\\n            W += A[i][1];\\n            if (i == n - 1 || A[i][0] != A[i + 1][0]) {\\n                need--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def boxDelivering(self, A, portsCount, B, W):\\n        n = len(A)\\n        need = j = lastj = 0\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in xrange(n):\\n            while j < n and B > 0 and W >= A[j][1]:\\n                B -= 1\\n                W -= A[j][1]\\n                if j == 0 or A[j][0] != A[j - 1][0]:\\n                    lastj = j\\n                    need += 1\\n                j += 1\\n\\n            dp[j] = min(dp[j], dp[i] + need + 1)\\n            dp[lastj] = min(dp[lastj], dp[i] + need)\\n\\n            B += 1\\n            W += A[i][1]\\n            if i == n - 1 or A[i][0] != A[i + 1][0]:\\n                need -= 1\\n        return dp[-1]\\n```\\n<br>\\n\\n# More Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations and discussion.\\nGood luck and have fun.\\n\\n- 1687. Delivering Boxes from Storage to Ports\\n- 1493. Longest Subarray of 1\\'s After Deleting One Element\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/JavaC%2B%2BPython-Sliding-Window)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/523136/JavaC%2B%2BPython-Sliding-Window)\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public int boxDelivering(int[][] A, int portsCount, int B, int W) {\\n        int n = A.length, need = 0, j = 0, lastj = 0, dp[] = new int[n + 1];\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && B > 0 && W >= A[j][1]) {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) {\\n                    lastj = j;\\n                    need++;\\n                }\\n                dp[++j] = 200000;\\n            }\\n            dp[j] = Math.min(dp[j], dp[i] + need + 1);\\n            dp[lastj] = Math.min(dp[lastj], dp[i] + need);\\n            B += 1;\\n            W += A[i][1];\\n            if (i == n - 1 || A[i][0] != A[i + 1][0]) {\\n                need--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```cpp\\n    int boxDelivering(vector<vector<int>>& A, int portsCount, int B, int W) {\\n        int n = A.size(), need = 0, j = 0, lastj = 0;\\n        vector<int> dp(n + 1, 200000);\\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) {\\n            while (j < n && B > 0 && W >= A[j][1]) {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) {\\n                    lastj = j;\\n                    need++;\\n                }\\n                j++;\\n            }\\n            dp[j] = min(dp[j], dp[i] + need + 1);\\n            dp[lastj] = min(dp[lastj], dp[i] + need);\\n            B += 1;\\n            W += A[i][1];\\n            if (i == n - 1 || A[i][0] != A[i + 1][0]) {\\n                need--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n```\n```py\\n    def boxDelivering(self, A, portsCount, B, W):\\n        n = len(A)\\n        need = j = lastj = 0\\n        dp = [0] + [float(\\'inf\\')] * n\\n        for i in xrange(n):\\n            while j < n and B > 0 and W >= A[j][1]:\\n                B -= 1\\n                W -= A[j][1]\\n                if j == 0 or A[j][0] != A[j - 1][0]:\\n                    lastj = j\\n                    need += 1\\n                j += 1\\n\\n            dp[j] = min(dp[j], dp[i] + need + 1)\\n            dp[lastj] = min(dp[lastj], dp[i] + need)\\n\\n            B += 1\\n            W += A[i][1]\\n            if i == n - 1 or A[i][0] != A[i + 1][0]:\\n                need -= 1\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 969560,
                "title": "python-o-n-dp-monotonic-queue-sliding-window-with-full-explanation",
                "content": "## **Interpretation**:\\nLet\\'s think of **one single trip taking all boxes** as a start, then **separate it into small trips** that meet the limitation of `maxBoxes` and `maxWeight`. \\n\\nI will use **Example 2** to explain:\\n| Box Index | 0  | 1  | 2 | 3 | 4  |\\n|-----------|----|----|---|---|----|\\n| Port      | 1  | 3  | 3 | 3 | 2  |\\n| Weight    | 2  | 3  | 1 | 1 | 4  |\\n\\nNumber of trips of that *one single base trip* is easy to calculate:\\n| Box Index |    | 0 |    | 1 |   | 2 |   | 3 |    | 4 |   | Total Cost |\\n|-----------|----|---|----|---|---|---|---|---|----|---|---|-------|\\n| Port      |    | 1 |    | 3 |   | 3 |   | 3 |    | 2 |   |       |\\n| Weight    |    | 2 |    | 3 |   | 1 |   | 1 |    | 4 |   |       |\\n| Base Cost (go to different port)     | +1 |   | +1 |   | 0 |   | 0 |   | +1 |   |   | 3     |\\n\\nWhen separating this base trip into smaller trips, adding a division between `boxes[i]` and `boxes[i+1]` means going back to storage and take some boxes. **This travelling back is the cost of separating trips.** There are 2 types of divisions:\\n* Between boxes of **same port**, it costs **2 more trips** (going back to storage and then back to the same port).\\n* Between boxes of **different ports**, it costs only **1 more trip** (going back to storage), since we already count 1 trip for travelling between different ports.\\n* (For convenience, think of the final trip back to storage as a division costing 1 trip.)\\n\\nThe solution of **Example 2** is interpreted like this:\\n| Box Index     |    | 0 |    | 1 |   | 2 |   | 3 |    | 4 |    | Total Cost |\\n|---------------|----|---|----|---|---|---|---|---|----|---|----|-------|\\n| Port          |    | 1 |    | 3 |   | 3 |   | 3 |    | 2 |    |       |\\n| Weight        |    | 2 |    | 3 |   | 1 |   | 1 |    | 4 |    |       |\\n| Base Cost     | +1 |   | +1 |   | 0 |   | 0 |   | +1 |   |    | 3     |\\n| Division (Trip) Cost |    |   | +1 |   |   |   |   |   | +1 |   | +1 | 3     |\\n\\n## **Solution**:\\n\\nNow the problem is, what\\'s the minimal cost of inserting some divisions to make every trip within the limitation? \\n\\nThis is one typical structure of **dynamic programming**. Iterate through each `boxes[i]` as if it\\'s the last box of one trip, and calculate the minimal cost of shipping `boxes[0..i]`. I\\'d associate each division with its previous trip. In other words, `dp[i]` includes the cost of the division between `boxes[i]` and `boxes[i+1]` (the division between `boxes[n-1]` and `boxes[n]` is the final trip back to storage). Then we have: \\n\\n* `dp[i] = min{dp[j] | boxes[j..i] satisfy the limitation} + cost_between_boxes(i, i+1)`\\n\\nRegarding each `dp[i]`, we are looking for the minimum in a range of `j..i-1` where `boxes[j..i]` satisfy certain limitation. This part is the same with [**239. Sliding Window Maximum**](https://leetcode.com/problems/sliding-window-maximum/), a problem of **sliding window using monotonic queue**. **Please check it.**\\n\\nTime and space complexity: `O(n)`\\n\\nMy python 3 code:\\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        que = collections.deque([(-1,0)])  # monotonic queue. item: (division_position, trip_cost)\\n        pre = -1  # latest end of previous trip\\n\\t\\tws = 0  # maximal weights of current trip\\n        for i, (p, w) in enumerate(boxes):  # p: port; w: weight\\n            # update the earliest possible start of current trip:\\n            ws += w\\n            while i - pre > maxBoxes or ws > maxWeight:\\n                pre += 1\\n                ws -= boxes[pre][1]\\n            while que[0][0] < pre: que.popleft()  ## pop out the boxes out of range of current trip\\n            \\n            # min cost of current trip. front of monotonic queue is always the minimal cost that meets the limitation\\n            mn = (2 if i+1<n and p==boxes[i+1][0] else 1) + que[0][1]\\n            while que[-1][1] >= mn: que.pop()  # maintain the queue monotonic\\n            que.append((i, mn))\\n        \\n        base_trip = 1  # calc base trip cost\\n        for i in range(n-1):\\n            if boxes[i][0] != boxes[i+1][0]: base_trip += 1\\n        \\n        return base_trip + que[-1][1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        que = collections.deque([(-1,0)])  # monotonic queue. item: (division_position, trip_cost)\\n        pre = -1  # latest end of previous trip\\n\\t\\tws = 0  # maximal weights of current trip\\n        for i, (p, w) in enumerate(boxes):  # p: port; w: weight\\n            # update the earliest possible start of current trip:\\n            ws += w\\n            while i - pre > maxBoxes or ws > maxWeight:\\n                pre += 1\\n                ws -= boxes[pre][1]\\n            while que[0][0] < pre: que.popleft()  ## pop out the boxes out of range of current trip\\n            \\n            # min cost of current trip. front of monotonic queue is always the minimal cost that meets the limitation\\n            mn = (2 if i+1<n and p==boxes[i+1][0] else 1) + que[0][1]\\n            while que[-1][1] >= mn: que.pop()  # maintain the queue monotonic\\n            que.append((i, mn))\\n        \\n        base_trip = 1  # calc base trip cost\\n        for i in range(n-1):\\n            if boxes[i][0] != boxes[i+1][0]: base_trip += 1\\n        \\n        return base_trip + que[-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1022004,
                "title": "java-step-by-step-o-n3-o-n-explained",
                "content": "This problem took me a lot of time to understand and finally get an answer for. Sharing my journey here to help those who are also having a hard time.\\n\\nI started this question by using dp asking myself if there are `x1, x2, ... xn` boxes. My optimal answer `f(0, n)` will be sum  of `f(0,i) + f(i+1, n)` (optimal answer from 0 to i plus optimal from i+1 to n)\\n\\nThis landed me a simple 2d graph to explore\\nBasically the idea here is to calculate dp[i][j] - I check if \\u03A3(i-j) weights and (i-j+1) boxes fit the limitation of the problem. If fits, set `dp[i][j]` as `dp[i][i] + diffCity(i-j)` (diffCity from boxes i to boxes j). `dp[i][j] = dp[i][i] + diffCity[i] - diffCity[j]`\\nIf it does **not** fit, I then loop through from (i to j as k) to find `(Math.min(dp[i][j], dp[i][k] + dp[k+1][j])`\\n*note that computing the weight from i - j and differentCitys from i - j can be reduced to O(1) by using prefix*\\n```\\n\\t [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]]\\n[1,4]    2     2     3     4     5     6\\n[1,2]          2     3     3     4     5 \\n[2,1]                2     2     3     4\\n[2,1]                      2     3     3\\n[3,2]                            2     2\\n[3,4]                                  2\\n```\\n\\nThe complexity here is O(n^3).\\nThe probelm here is that I didn\\'t use the greedy nature of the problem. \\nThe greedy approach here guarantees that only by adding more boxes to my current trip can I then reduce the number of total trips.\\nSo reorganizing my approach... \\n\\nexample:\\n[[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]]\\nat [1,2] (index 1) I have two options: \\n1. ship [1,2] and take + 2 trips\\n2. ship [1,4] and [1,2] and take + 2 trips\\n--> `p[1] = min(dp[0] + 2, dp[-1] + 2)`\\n\\nsimiarily at the first [2,1] (index 2)\\n1. ship [2,1] and take + 2 trips\\n2. ship [1,2], [2,1] and take + 3 trips\\n3. ship [1,4], [1,2], [2,1] and take + 3 trips\\n--> `p[2] = min(dp[1] + 2 + 1, dp[0] + 2 + 1, dp[-1] + 2 + 1)`\\n\\nThen reduces the complexity of my dp from 2d to 1d.\\n\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        diffCity[0] = 1;\\n        for (int i = 1; i <= boxes.length; i++) { // offset by 1 since our above logic reaches dp[-1]\\n            for (int j = i - 1; j >= 0; j--) {\\n                int dC= diffCity[i] - diffCity[j+1]; // computes # of different cities from i to j. (add 1 to j is necessary here)\\n                int w = weights[i] - weights[j]; \\n                int b = i - j;\\n                if (b <= maxBoxes && w <= maxWeight) {\\n                    dp[i] = Math.min(dp[i], 2 + dC + dp[j]); \\n                }\\n            }\\n        }\\n        return dp[boxes.length];\\n    }\\n}\\n```\\n\\ntime: O(N^2) when maxBoxes and maxWeight is at max\\n\\nMoving from N^2 to N lg N solution here is bit tricky because you have multiple factors like weights, boxes, and differentCities that comes into play here.\\n\\nBut the idea is simple... Since we calculate dp[i] as `2 + dC + dp[j]`\\nWhen we are at dp[i] we want to find the minimum value of (dC + dp[j]) from dp[0] to dp[i-1].\\n\\nThis is the tricky part because dC relies on current index i and index j. \\nWe can split this apart and refine dp relationship as `2 + diffCity[i] - diffCity[j+1] + dp[j]`.\\nNotice that `diffCity[j+1] and dp[j]` is dependent on j, we can put them in a min heap to easily retrieve it later.\\n`diffCity[i] and 2` is a constant we can build at the start of every index i\\nto take care of limiting factors like weights and number of boxes, we can append the index at the beginning of an int array `[index, diffCity[j+1] and dp[j]]` so we can filter out those choices by arr[0] before polling our min at arr[1]\\n\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]); // {index, (dp[x] - c[x+1])}\\n        pq.offer(new int[] {0, -1}); // necessary offset for dp[1]\\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!pq.isEmpty() && (i - pq.peek()[0] > maxBoxes || weights[i] - weights[pq.peek()[0]] > maxWeight)) {\\n                pq.poll();  // filter out those mins values no longer in range\\n            }\\n            \\n            dp[i] = pq.peek()[1] + diffCity[i] + 2; // reassemble (dp[i] = min(2 + dC + dp[j])\\n            if (i != boxes.length) {\\n                pq.offer(new int[] {i, dp[i] - diffCity[i+1]}); // add current val into min heap\\n            }\\n        }\\n        return dp[boxes.length];\\n    }\\n}\\n```\\nTime: O(N lg N). \\nIts not easy to come up with dp[i] - diffCity[i+1] by just looking at this. \\n\\nLast optimization: Use Monoqueue \\nThe idea is simple. Just throw away values that are greater than current value you are able to put into the queue.\\n\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[] {0, -1});\\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!dq.isEmpty() && (i - dq.peek()[0] > maxBoxes || weights[i] - weights[dq.peek()[0]] > maxWeight)) { // filter values no longer can be used.\\n                dq.poll();\\n            }\\n            \\n            dp[i] = dq.peek()[1] + diffCity[i] + 2;\\n            if (i != boxes.length) {\\n                while (dq.peekLast()[1] >= dp[i] - diffCity[i+1]) { // throw away greater values than current value.\\n                    dq.pollLast();\\n                }\\n                dq.offer(new int[] {i, dp[i] - diffCity[i+1]});\\n            }\\n            \\n        return dp[boxes.length];\\n    }\\n}\\n```\\nO(N)\\n\\nThere are still few tips and tricks to impove the overall runtime #ms. But time complexity wise, this is the best we can do.",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Queue"
                ],
                "code": "```\\n\\t [[1,4],[1,2],[2,1],[2,1],[3,2],[3,4]]\\n[1,4]    2     2     3     4     5     6\\n[1,2]          2     3     3     4     5 \\n[2,1]                2     2     3     4\\n[2,1]                      2     3     3\\n[3,2]                            2     2\\n[3,4]                                  2\\n```\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        diffCity[0] = 1;\\n        for (int i = 1; i <= boxes.length; i++) { // offset by 1 since our above logic reaches dp[-1]\\n            for (int j = i - 1; j >= 0; j--) {\\n                int dC= diffCity[i] - diffCity[j+1]; // computes # of different cities from i to j. (add 1 to j is necessary here)\\n                int w = weights[i] - weights[j]; \\n                int b = i - j;\\n                if (b <= maxBoxes && w <= maxWeight) {\\n                    dp[i] = Math.min(dp[i], 2 + dC + dp[j]); \\n                }\\n            }\\n        }\\n        return dp[boxes.length];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((o1, o2) -> o1[1] - o2[1]); // {index, (dp[x] - c[x+1])}\\n        pq.offer(new int[] {0, -1}); // necessary offset for dp[1]\\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!pq.isEmpty() && (i - pq.peek()[0] > maxBoxes || weights[i] - weights[pq.peek()[0]] > maxWeight)) {\\n                pq.poll();  // filter out those mins values no longer in range\\n            }\\n            \\n            dp[i] = pq.peek()[1] + diffCity[i] + 2; // reassemble (dp[i] = min(2 + dC + dp[j])\\n            if (i != boxes.length) {\\n                pq.offer(new int[] {i, dp[i] - diffCity[i+1]}); // add current val into min heap\\n            }\\n        }\\n        return dp[boxes.length];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int[] diffCity = new int[boxes.length+1];\\n        int[] weights = new int[boxes.length+1];\\n        \\n        for (int i = 0; i < boxes.length; i++) {\\n            diffCity[i+1] = diffCity[i] + ((i != 0 && boxes[i][0] == boxes[i-1][0]) ? 0 : 1);\\n            weights[i+1] = weights[i] + boxes[i][1];\\n        }\\n        int[] dp = new int[boxes.length+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Deque<int[]> dq = new ArrayDeque<>();\\n        dq.offer(new int[] {0, -1});\\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!dq.isEmpty() && (i - dq.peek()[0] > maxBoxes || weights[i] - weights[dq.peek()[0]] > maxWeight)) { // filter values no longer can be used.\\n                dq.poll();\\n            }\\n            \\n            dp[i] = dq.peek()[1] + diffCity[i] + 2;\\n            if (i != boxes.length) {\\n                while (dq.peekLast()[1] >= dp[i] - diffCity[i+1]) { // throw away greater values than current value.\\n                    dq.pollLast();\\n                }\\n                dq.offer(new int[] {i, dp[i] - diffCity[i+1]});\\n            }\\n            \\n        return dp[boxes.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369248,
                "title": "c-dp-solution-with-thinking-process-brute-force-priority-queue-mono-queue",
                "content": "First define the DP problem and equation:\\n1. dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n2. dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]);\\nThe equation is a bit tricky: besides the previous trips dp[j], and 2 extra trips from and back to storage, we need to consider the extra trips required between i and j. This can easily obtained. \\n\\nThen we have a DP solution, which is sane but of course will TLE. Next we will improve it on getting min in past by using priority queue and mono queue. \\n \\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size());\\n        trips[0] = 0;\\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        // dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            dp[i+1] = INT_MAX;\\n            int sum_weights = 0;\\n            for (int j = i; j>=0 && i-j+1 <= maxBoxes; --j) {\\n                sum_weights += boxes[j][1];\\n                if (sum_weights > maxWeight) break;\\n                dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\n\\nNotice that min(dp[j]+2+trips[i]-trips[j]) can be reformulated as 2+trips[i]+min(dp[j]-trips[j]), therefore this problem is transformed to a standard problem: in a sliding window, how to find the minimum (dp[j]-trips[j]). A standard solution is of course priority queue. \\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size()+1);\\n        trips[0] = 0; \\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        trips.push_back(0);\\n        vector<long int> weights(boxes.size()+1);\\n        weights[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            weights[i+1] = weights[i]+boxes[i][1];\\n        }\\n        // dp[i] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        auto cmp = [](const pair<int, int>& lhs, const pair<int, int>& rhs) {\\n            return lhs.second > rhs.second;\\n        };\\n        std::priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        pq.push({-1, 0});\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            while (pq.size()) {\\n                int prev_box = pq.top().first;\\n                int num_boxes = i-prev_box;\\n                int num_weights = weights[i+1]-weights[prev_box+1];\\n                if (num_boxes > maxBoxes || num_weights > maxWeight) {\\n                    pq.pop(); continue;\\n                }\\n                break;\\n            }\\n            int prev_box = pq.top().first;\\n            dp[i+1] = 2+dp[prev_box+1]+trips[i]-trips[prev_box+1];\\n            pq.push({i, dp[i+1]-trips[i+1]});\\n        }\\n        return dp.back();\\n    }\\n};\\n```\\nMono queue is an effective way to get min/max value of a sliding window. In this case, it clearly has the pattern to use mono queue. Minor changes of above solution gives a mono queue solution. \\n\\nI find it\\'s really helpful to practice by topic. I praticed all questions under tag monotonic queue, and after practicing few, I actualy find this question is not that hard. For your reference, some leetcode questions under monotonic queue:\\n239. Sliding Window Maximum\\n862. Shortest Subarray with Sum at Least K\\n918. Maximum Sum Circular Subarray\\n1438. Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit\\n1499. Max Value of Equation\\n1425 Constrained Subsequence Sum\\n1687 Delivering Boxes from Storage to Ports\\n1696. Jump Game VI\\n\\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size()+1);\\n        trips[0] = 0; \\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        trips.push_back(0);\\n        vector<long int> weights(boxes.size()+1);\\n        weights[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            weights[i+1] = weights[i]+boxes[i][1];\\n        }\\n        // dp[i] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        deque<int> asc_dq;\\n        asc_dq.push_back(-1);\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            while (asc_dq.size()) {\\n                int prev_box = asc_dq.front();\\n                int num_boxes = i-prev_box;\\n                int num_weights = weights[i+1]-weights[prev_box+1];\\n                if (num_boxes > maxBoxes || num_weights > maxWeight) {\\n                    asc_dq.pop_front(); continue;\\n                }\\n                break;\\n            }\\n            int prev_box = asc_dq.front();\\n            dp[i+1] = 2+dp[prev_box+1]+trips[i]-trips[prev_box+1];\\n            while (asc_dq.size()) {\\n                int prev_box = asc_dq.back();\\n                int last = dp[prev_box+1]-trips[prev_box+1];\\n                if (dp[i+1]-trips[i+1] <= last) {\\n                    asc_dq.pop_back(); continue;\\n                }\\n                break;\\n            }\\n            asc_dq.push_back(i);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size());\\n        trips[0] = 0;\\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        // dp[i+1] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            dp[i+1] = INT_MAX;\\n            int sum_weights = 0;\\n            for (int j = i; j>=0 && i-j+1 <= maxBoxes; --j) {\\n                sum_weights += boxes[j][1];\\n                if (sum_weights > maxWeight) break;\\n                dp[i+1] = std::min(dp[i+1], dp[j]+2+trips[i]-trips[j]);\\n            }\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size()+1);\\n        trips[0] = 0; \\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        trips.push_back(0);\\n        vector<long int> weights(boxes.size()+1);\\n        weights[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            weights[i+1] = weights[i]+boxes[i][1];\\n        }\\n        // dp[i] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        auto cmp = [](const pair<int, int>& lhs, const pair<int, int>& rhs) {\\n            return lhs.second > rhs.second;\\n        };\\n        std::priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\\n        pq.push({-1, 0});\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            while (pq.size()) {\\n                int prev_box = pq.top().first;\\n                int num_boxes = i-prev_box;\\n                int num_weights = weights[i+1]-weights[prev_box+1];\\n                if (num_boxes > maxBoxes || num_weights > maxWeight) {\\n                    pq.pop(); continue;\\n                }\\n                break;\\n            }\\n            int prev_box = pq.top().first;\\n            dp[i+1] = 2+dp[prev_box+1]+trips[i]-trips[prev_box+1];\\n            pq.push({i, dp[i+1]-trips[i+1]});\\n        }\\n        return dp.back();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> trips(boxes.size()+1);\\n        trips[0] = 0; \\n        for (int i = 1; i < boxes.size(); ++i) {\\n            if (boxes[i][0] == boxes[i-1][0]) {\\n                trips[i] = trips[i-1];\\n            } else {\\n                trips[i] = trips[i-1]+1;\\n            }\\n        }\\n        trips.push_back(0);\\n        vector<long int> weights(boxes.size()+1);\\n        weights[0] = 0;\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            weights[i+1] = weights[i]+boxes[i][1];\\n        }\\n        // dp[i] is minimum trips assuming i is the last box to deliver and will return to port afterwards. \\n        vector<int> dp(boxes.size()+1);\\n        dp[0] = 0;\\n        deque<int> asc_dq;\\n        asc_dq.push_back(-1);\\n        for (int i = 0; i < boxes.size(); ++i) {\\n            while (asc_dq.size()) {\\n                int prev_box = asc_dq.front();\\n                int num_boxes = i-prev_box;\\n                int num_weights = weights[i+1]-weights[prev_box+1];\\n                if (num_boxes > maxBoxes || num_weights > maxWeight) {\\n                    asc_dq.pop_front(); continue;\\n                }\\n                break;\\n            }\\n            int prev_box = asc_dq.front();\\n            dp[i+1] = 2+dp[prev_box+1]+trips[i]-trips[prev_box+1];\\n            while (asc_dq.size()) {\\n                int prev_box = asc_dq.back();\\n                int last = dp[prev_box+1]-trips[prev_box+1];\\n                if (dp[i+1]-trips[i+1] <= last) {\\n                    asc_dq.pop_back(); continue;\\n                }\\n                break;\\n            }\\n            asc_dq.push_back(i);\\n        }\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974594,
                "title": "python-accepted-clean-greedy-backtracking-with-memoriztion",
                "content": "**Idea:**\\nStarting from box `i`, push `j` as far as boxes and weights permit, keep the last port change as `k`. Backtrack only `j` and `k` to see which choice is better, until we reach `n`.\\n\\n```python\\ndef boxDelivering(boxes, portsCount, maxBoxes, maxWeight):\\n\\tn = len(boxes)\\n\\n\\t@lru_cache(None)\\n\\tdef backtrack(i):\\n\\t\\tif i > n-1: return 0\\n\\t\\t\\n\\t\\tj = k = i\\n\\t\\tb = w = extra = 0\\n\\t\\twhile j < n and b < maxBoxes and w + boxes[j][1] <= maxWeight:\\n\\t\\t\\tb += 1\\n\\t\\t\\tw += boxes[j][1]\\n\\t\\t\\tif j != i and boxes[j][0] != boxes[j-1][0]:\\n\\t\\t\\t\\textra += 1\\n\\t\\t\\t\\tk = j\\n\\t\\t\\tj += 1\\n\\t\\t\\t\\n\\t\\ttrip = 2 + extra + backtrack(j)\\n\\t\\tif k != i:\\n\\t\\t\\ttrip = min(trip, 1 + extra + backtrack(k))\\n\\t\\treturn trip\\n\\n\\treturn backtrack(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Backtracking",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```python\\ndef boxDelivering(boxes, portsCount, maxBoxes, maxWeight):\\n\\tn = len(boxes)\\n\\n\\t@lru_cache(None)\\n\\tdef backtrack(i):\\n\\t\\tif i > n-1: return 0\\n\\t\\t\\n\\t\\tj = k = i\\n\\t\\tb = w = extra = 0\\n\\t\\twhile j < n and b < maxBoxes and w + boxes[j][1] <= maxWeight:\\n\\t\\t\\tb += 1\\n\\t\\t\\tw += boxes[j][1]\\n\\t\\t\\tif j != i and boxes[j][0] != boxes[j-1][0]:\\n\\t\\t\\t\\textra += 1\\n\\t\\t\\t\\tk = j\\n\\t\\t\\tj += 1\\n\\t\\t\\t\\n\\t\\ttrip = 2 + extra + backtrack(j)\\n\\t\\tif k != i:\\n\\t\\t\\ttrip = min(trip, 1 + extra + backtrack(k))\\n\\t\\treturn trip\\n\\n\\treturn backtrack(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 969708,
                "title": "7ms-java",
                "content": "Here\\'s a very pretty solution that I was too stupid to come up with during the contest.\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] box, int __, int max, int limit) {\\n        int n = box.length;\\n        int[] dp = new int[n+1];\\n        int weight = 0;\\n        int cost = 2;\\n        for (int l = 0, r = 0; r < n; r++){\\n            weight += box[r][1];\\n            if (r!=0 && box[r][0] != box[r-1][0]) cost++;\\n            while(r-l >= max || weight > limit || (l < r && dp[l] == dp[l+1])){\\n                weight -= box[l][1];\\n                if (box[l+1][0] != box[l][0]) cost--;\\n                l++;\\n            }\\n            dp[r+1] = cost + dp[l];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\\nCommented:\\n```\\nclass Solution {\\n    public int boxDelivering(int[][] box, int __, int max, int limit) {\\n        int n = box.length;\\n        int[] dp = new int[n+1]; // Minimum trips for first n boxes.\\n        int weight = 0; // cumulative weight\\n        int cost = 2; // cumulative cost\\n        \\n        int l = 0;  // left ptr\\n        for (int r = 0; r < n; r++){ // right ptr\\n            // New box\\n            weight += box[r][1];\\n            if (r!=0 && box[r][0] != box[r-1][0]) cost++;\\n            /* drop boxes iff:\\n                - There are too many boxes (r-l >= max)\\n                - The boxes are too heavy (weight > limit)\\n                - It is redundant to carry them (dp[l] == dp[l+1]).\\n            */\\n            while(r-l >= max || weight > limit || (l < r && dp[l] == dp[l+1])){\\n                weight -= box[l][1];\\n                if (box[l+1][0] != box[l][0]) cost--;\\n                l++;\\n            }\\n            dp[r+1] = cost + dp[l];\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int boxDelivering(int[][] box, int __, int max, int limit) {\\n        int n = box.length;\\n        int[] dp = new int[n+1];\\n        int weight = 0;\\n        int cost = 2;\\n        for (int l = 0, r = 0; r < n; r++){\\n            weight += box[r][1];\\n            if (r!=0 && box[r][0] != box[r-1][0]) cost++;\\n            while(r-l >= max || weight > limit || (l < r && dp[l] == dp[l+1])){\\n                weight -= box[l][1];\\n                if (box[l+1][0] != box[l][0]) cost--;\\n                l++;\\n            }\\n            dp[r+1] = cost + dp[l];\\n        }\\n        return dp[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int boxDelivering(int[][] box, int __, int max, int limit) {\\n        int n = box.length;\\n        int[] dp = new int[n+1]; // Minimum trips for first n boxes.\\n        int weight = 0; // cumulative weight\\n        int cost = 2; // cumulative cost\\n        \\n        int l = 0;  // left ptr\\n        for (int r = 0; r < n; r++){ // right ptr\\n            // New box\\n            weight += box[r][1];\\n            if (r!=0 && box[r][0] != box[r-1][0]) cost++;\\n            /* drop boxes iff:\\n                - There are too many boxes (r-l >= max)\\n                - The boxes are too heavy (weight > limit)\\n                - It is redundant to carry them (dp[l] == dp[l+1]).\\n            */\\n            while(r-l >= max || weight > limit || (l < r && dp[l] == dp[l+1])){\\n                weight -= box[l][1];\\n                if (box[l+1][0] != box[l][0]) cost--;\\n                l++;\\n            }\\n            dp[r+1] = cost + dp[l];\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 973310,
                "title": "not-greedy-dp-sliding-window-segmentree-monoqueue-sortedcontainers-redblacktree",
                "content": "I write this before I realized that the dp equation can be optimized use prefix sum.  You can read another post of mine. But it requires more insight.   https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/1180277/dp-%2B-sliding-window-prefix\\n\\n---\\n\\nHere I want to introduce SegmentTree, even if it\\'s slow, it can solve problems without too much technique.\\nAdditionally, the java version is much faster than c++, and the python3 version TLE.\\n\\n\\n###  SegmenTree in C++ (816ms)\\n<details><summary>my powerful segment tree implement </summary><p>\\n\\n```\\n#define INT_NONE -1\\n#define ll long long\\nstruct Data{\\n    ll sum;\\n    int ma,mi,add,prop;\\n    Data(ll sum=0,int ma=0,int mi=0,int add=0,int prop=INT_NONE):\\n    sum(sum),ma(ma),mi(mi),add(add),prop(prop){}\\n};\\n// index start from 0, tree root index from 0\\n// all use closed interval\\nclass SegmentTree{\\n    int n;\\n    vector<Data> seg;\\n    int LEFT=0;\\npublic:\\n    SegmentTree(int n):n(n),seg(1<<int(ceil(log2(n))+1)){}\\n    // void build(vector<int>&A){build(A,0,LEFT,n-1);}\\n    // void build(vector<int>&A,int i, int l, int r){\\n    //     if(r==l){seg[i]=Data(A[l],A[l],A[l]);return;}\\n    //     int m=l+(r-l)/2;\\n    //     build(A,i*2+1,l,m);\\n    //     build(A,i*2+2,m+1,r);\\n    //     pushup(i);\\n    // }\\n    int query_min(int Al, int Ar){return query_min(Al,Ar,0,LEFT,n-1);}\\n    int query_min(int Al, int Ar,int i, int l, int r){\\n        if(Al>Ar) return INT_MAX;\\n        else if(l==Al and r==Ar) return seg[i].mi;\\n        int m = l+(r-l)/2;\\n        pushdown(i,l,m,r);\\n        return min(query_min(Al,min(m,Ar),i*2+1,l,m),\\n            query_min(max(m+1,Al),Ar,i*2+2,m+1,r));\\n    }\\n    void addition(int Al, int Ar, int add){addition(Al,Ar,add,0,LEFT,n-1);}\\n    void addition(int Al, int Ar, int add, int i, int l, int r){\\n        if(Al>Ar) return;\\n        else if(l==Al and r==Ar) {\\n            // seg[i].sum+=add*(r-l+1);\\n            // seg[i].ma+=add;\\n            seg[i].mi+=add;\\n            seg[i].add+=add;\\n            return;}\\n        int m = l+(r-l)/2;\\n        pushdown(i,l,m,r);\\n        addition(Al,min(m,Ar),add,i*2+1,l,m);\\n        addition(max(m+1,Al),Ar,add,i*2+2,m+1,r);\\n        pushup(i);\\n    }\\n    void pushup(int i){\\n        // seg[i]=Data(seg[i*2+1].sum+seg[i*2+2].sum,\\n                    // max(seg[i*2+1].ma,seg[i*2+2].ma),\\n                    // min(seg[i*2+1].mi,seg[i*2+2].mi));\\n        seg[i].mi=min(seg[i*2+1].mi,seg[i*2+2].mi);\\n    }\\n    void pushdown(int i,int l,int m,int r){\\n        // if(seg[i].prop!=INT_NONE){\\n        //     auto prop = seg[i].prop;\\n        //     seg[i*2+1].prop=seg[i*2+2].prop=prop;\\n        //     seg[i*2+1].ma=seg[i*2+1].mi=seg[i*2+2].ma=seg[i*2+2].mi=prop;\\n        //     seg[i*2+1].add=seg[i*2+2].add=0;\\n        //     seg[i*2+1].sum=prop*(m-l+1);\\n        //     seg[i*2+2].sum=prop*(r-m);\\n        //     seg[i].prop=INT_NONE;\\n        // }\\n        if(seg[i].add!=0){\\n            auto add = seg[i].add;\\n            // seg[i*2+1].ma+=add;\\n            seg[i*2+1].mi+=add;\\n            // seg[i*2+1].sum+=add*(m-l+1);\\n            seg[i*2+1].add+=add;\\n            seg[i*2+2].add+=add;\\n            // seg[i*2+2].ma+=add;\\n            seg[i*2+2].mi+=add;\\n            // seg[i*2+2].sum+=add*(r-m);\\n            seg[i].add=0;\\n        }\\n    }\\n    // void subsegment(int Al, int Ar){subsegment(int Al, int Ar,0,LEFT,n-1);}\\n    // void subsegment(int Al, int Ar,int i, int l, int r){\\n    //     if(Al>Ar) return;\\n    //     else if(l==Al and r==Ar) return; //\\n    //     int m = l+(r-l)/2;\\n    //     pushdown(i,l,m,r);\\n    //     subsegment(Al,min(m,Ar),i*2+1,l,m);\\n    //     subsegment(max(m+1,Al),Ar,i*2+2,m+1,r);\\n    //     if(UPDATE)\\n    //         pushup(i);\\n    // }\\n};        \\n```\\n</p></details>\\n\\n```c++\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        auto seg = SegmentTree(n+1); // init all zeros\\n\\t\\t// all segmentree methods use closed interval\\n        int olddp=0;\\n        for(int r=0;r<n;r++){\\n            // loop invariant: olddp stores dp(0,r-1)\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            \\t\\t\\t\\n            if(r!=0)\\n                seg.addition(l,r-1,A[r][0]!=A[r-1][0]);\\n            seg.addition(r,r,olddp+2);\\n            olddp = seg.query_min(l,r);\\n        }\\n        return olddp;\\n    }\\n};\\n```\\n\\n## Explanation\\nfor convenience, I use `A` to alias `boxes`.\\n`dp(i,j)` means the problem#1687 answer by only replace the `A` argument with `A[i:j+1]`\\n\\nwe need to find  `dp(0,n-1)`.\\n\\nconsider the last trip, `left(r)` is the smallest index when bring `A[r]`\\n`dp(0,r)   = min( dp(0,k-1) + dp(k,r) for k in range(left(r),r+1) )`\\nfor convinience we use `f(k)` to represent `dp(0,k-1)+dp(k,r)`\\nso we have to find minimum of `f(k)` when `k` in an interval\\n\\nconsider transform from `dp(0,r-1)` to `dp(0,r)` ( classic dp thought )\\n`dp(0,r-1) = min( dp(0,k-1) + dp(k,r-1) for k in range(left(r-1),r) )`\\n\\n`for k in range(left(r-1), left(r))`, these `f(k)` should be dropped\\n`for k in range(r, r+1)`, these `f(k)` is newly added, `f(k) = dp(0,r-1)+dp(r,r) = dp(0,r-1) + 2`\\n`for k in range(left(r), r)`, `dp(k,r) = dp(k,r-1)+A[r-1]!=A[r]`, these `f(k)` should update from old values\\n\\nTo achieve this write a sliding window. Then maintain a data structure `ds` to store `f(k)`, \\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        int olddp;\\n        for(int r=0;r<n;r++){\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            // [l,r] is maximum window that ship can take if the last box it take is A[r]\\n\\t\\t\\t// calc olddp here\\n\\t\\t\\t// ...\\n        }\\n        return olddp;\\n    }\\n};\\n```\\nThe sliding window part run in time complexity O(n) with space O(1).\\nAs you can see, without data strucure, the code is very short. \\nAnd the fastest selection of `ds` is a `monotonic queue` where you can find it in leetcode#239, it can be change geniously to support value addition on the whole . Below is an example implementation.\\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n        self.add = 0\\n    def append(self, T):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<=T[1]-self.add:\\n            dq.pop()\\n        dq.append((T[0],T[1]-self.add))\\n    def getMin(self, l):\\n        \"\"\"l is leftborder of sliding window\"\"\"\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return dq[0][1]+self.add\\n    def addAll(self,add):\\n        self.add += add\\n```\\n\\nUse MonoQueue as `ds`, I think this code can mostly explain my explanation, the time complex is O(n) with space O(maxBoxes).\\n\\n### monoQueue in python (2500ms)\\n\\n```python\\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n        Seg=MonoQueue()\\n        olddp = 0\\n        for l,r in slidingWindow():\\n            if r!=0:\\n                Seg.addAll(A[r][0]!=A[r-1][0])\\n            Seg.append((r, olddp+2))\\n            olddp = Seg.getMin(l)\\n        return olddp\\n```\\n\\nAnother interestring candidate is sortedcontainer library, it\\'s similar to a B tree. In practice it\\'s quicker than many `O(nlgn)` data structure. Its time complexity is `O(nlg(n))` (estimation), with space `O(maxBoxes)`. \\n\\n### sortedcontainers in python3 (3500ms)\\n```\\nfrom sortedcontainers import SortedList as MonoQueue\\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n        Seg=MonoQueue(key=lambda t:t[1])\\n        addAll = 0\\n        olddp = 0\\n        for l,r in slidingWindow():\\n            if r!=0:\\n                addAll+= ( A[r][0]!=A[r-1][0] )\\n            Seg.add((r, olddp-addAll+2))\\n            while Seg[0][0]<l:\\n                Seg.pop(0)\\n            olddp = Seg[0][1]+addAll\\n        return olddp\\n```\\n\\nA built-in sorted container in c++ is multiset and multimap which is typically implemented as red black tree, and for java it\\'s treemap. Its time complex is `O(nlgn)` with space `O(maxBoxes)`.\\n\\n### c++ multiset 536 ms\\n\\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        // saves <value, index> so that it put min value before other value\\n        multiset<pair<int,int>> seg; \\n        int addAll = 0;\\n        int olddp=0;\\n        for(int r=0;r<n;r++){\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            if(r!=0)\\n                addAll += (A[r][0]!=A[r-1][0]);\\n            seg.insert(make_pair(olddp-addAll+2, r));\\n            while(seg.begin()->second<l){\\n                seg.erase(begin(seg));\\n            }\\n            olddp = (seg.begin()->first) + addAll;\\n        }\\n        return olddp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define INT_NONE -1\\n#define ll long long\\nstruct Data{\\n    ll sum;\\n    int ma,mi,add,prop;\\n    Data(ll sum=0,int ma=0,int mi=0,int add=0,int prop=INT_NONE):\\n    sum(sum),ma(ma),mi(mi),add(add),prop(prop){}\\n};\\n// index start from 0, tree root index from 0\\n// all use closed interval\\nclass SegmentTree{\\n    int n;\\n    vector<Data> seg;\\n    int LEFT=0;\\npublic:\\n    SegmentTree(int n):n(n),seg(1<<int(ceil(log2(n))+1)){}\\n    // void build(vector<int>&A){build(A,0,LEFT,n-1);}\\n    // void build(vector<int>&A,int i, int l, int r){\\n    //     if(r==l){seg[i]=Data(A[l],A[l],A[l]);return;}\\n    //     int m=l+(r-l)/2;\\n    //     build(A,i*2+1,l,m);\\n    //     build(A,i*2+2,m+1,r);\\n    //     pushup(i);\\n    // }\\n    int query_min(int Al, int Ar){return query_min(Al,Ar,0,LEFT,n-1);}\\n    int query_min(int Al, int Ar,int i, int l, int r){\\n        if(Al>Ar) return INT_MAX;\\n        else if(l==Al and r==Ar) return seg[i].mi;\\n        int m = l+(r-l)/2;\\n        pushdown(i,l,m,r);\\n        return min(query_min(Al,min(m,Ar),i*2+1,l,m),\\n            query_min(max(m+1,Al),Ar,i*2+2,m+1,r));\\n    }\\n    void addition(int Al, int Ar, int add){addition(Al,Ar,add,0,LEFT,n-1);}\\n    void addition(int Al, int Ar, int add, int i, int l, int r){\\n        if(Al>Ar) return;\\n        else if(l==Al and r==Ar) {\\n            // seg[i].sum+=add*(r-l+1);\\n            // seg[i].ma+=add;\\n            seg[i].mi+=add;\\n            seg[i].add+=add;\\n            return;}\\n        int m = l+(r-l)/2;\\n        pushdown(i,l,m,r);\\n        addition(Al,min(m,Ar),add,i*2+1,l,m);\\n        addition(max(m+1,Al),Ar,add,i*2+2,m+1,r);\\n        pushup(i);\\n    }\\n    void pushup(int i){\\n        // seg[i]=Data(seg[i*2+1].sum+seg[i*2+2].sum,\\n                    // max(seg[i*2+1].ma,seg[i*2+2].ma),\\n                    // min(seg[i*2+1].mi,seg[i*2+2].mi));\\n        seg[i].mi=min(seg[i*2+1].mi,seg[i*2+2].mi);\\n    }\\n    void pushdown(int i,int l,int m,int r){\\n        // if(seg[i].prop!=INT_NONE){\\n        //     auto prop = seg[i].prop;\\n        //     seg[i*2+1].prop=seg[i*2+2].prop=prop;\\n        //     seg[i*2+1].ma=seg[i*2+1].mi=seg[i*2+2].ma=seg[i*2+2].mi=prop;\\n        //     seg[i*2+1].add=seg[i*2+2].add=0;\\n        //     seg[i*2+1].sum=prop*(m-l+1);\\n        //     seg[i*2+2].sum=prop*(r-m);\\n        //     seg[i].prop=INT_NONE;\\n        // }\\n        if(seg[i].add!=0){\\n            auto add = seg[i].add;\\n            // seg[i*2+1].ma+=add;\\n            seg[i*2+1].mi+=add;\\n            // seg[i*2+1].sum+=add*(m-l+1);\\n            seg[i*2+1].add+=add;\\n            seg[i*2+2].add+=add;\\n            // seg[i*2+2].ma+=add;\\n            seg[i*2+2].mi+=add;\\n            // seg[i*2+2].sum+=add*(r-m);\\n            seg[i].add=0;\\n        }\\n    }\\n    // void subsegment(int Al, int Ar){subsegment(int Al, int Ar,0,LEFT,n-1);}\\n    // void subsegment(int Al, int Ar,int i, int l, int r){\\n    //     if(Al>Ar) return;\\n    //     else if(l==Al and r==Ar) return; //\\n    //     int m = l+(r-l)/2;\\n    //     pushdown(i,l,m,r);\\n    //     subsegment(Al,min(m,Ar),i*2+1,l,m);\\n    //     subsegment(max(m+1,Al),Ar,i*2+2,m+1,r);\\n    //     if(UPDATE)\\n    //         pushup(i);\\n    // }\\n};        \\n```\n```c++\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        auto seg = SegmentTree(n+1); // init all zeros\\n\\t\\t// all segmentree methods use closed interval\\n        int olddp=0;\\n        for(int r=0;r<n;r++){\\n            // loop invariant: olddp stores dp(0,r-1)\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            \\t\\t\\t\\n            if(r!=0)\\n                seg.addition(l,r-1,A[r][0]!=A[r-1][0]);\\n            seg.addition(r,r,olddp+2);\\n            olddp = seg.query_min(l,r);\\n        }\\n        return olddp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        int olddp;\\n        for(int r=0;r<n;r++){\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            // [l,r] is maximum window that ship can take if the last box it take is A[r]\\n\\t\\t\\t// calc olddp here\\n\\t\\t\\t// ...\\n        }\\n        return olddp;\\n    }\\n};\\n```\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n        self.add = 0\\n    def append(self, T):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<=T[1]-self.add:\\n            dq.pop()\\n        dq.append((T[0],T[1]-self.add))\\n    def getMin(self, l):\\n        \"\"\"l is leftborder of sliding window\"\"\"\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return dq[0][1]+self.add\\n    def addAll(self,add):\\n        self.add += add\\n```\n```python\\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n        Seg=MonoQueue()\\n        olddp = 0\\n        for l,r in slidingWindow():\\n            if r!=0:\\n                Seg.addAll(A[r][0]!=A[r-1][0])\\n            Seg.append((r, olddp+2))\\n            olddp = Seg.getMin(l)\\n        return olddp\\n```\n```\\nfrom sortedcontainers import SortedList as MonoQueue\\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n        Seg=MonoQueue(key=lambda t:t[1])\\n        addAll = 0\\n        olddp = 0\\n        for l,r in slidingWindow():\\n            if r!=0:\\n                addAll+= ( A[r][0]!=A[r-1][0] )\\n            Seg.add((r, olddp-addAll+2))\\n            while Seg[0][0]<l:\\n                Seg.pop(0)\\n            olddp = Seg[0][1]+addAll\\n        return olddp\\n```\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int __, int B, int W) {\\n        int n = A.size();\\n        int ans = INT_MAX;\\n        int l=0; \\n        int cW = 0;\\n        // saves <value, index> so that it put min value before other value\\n        multiset<pair<int,int>> seg; \\n        int addAll = 0;\\n        int olddp=0;\\n        for(int r=0;r<n;r++){\\n            cW+=A[r][1];\\n            while(cW>W or r-l+1>B){\\n                cW-=A[l][1];\\n                l+=1;\\n            }\\n            if(r!=0)\\n                addAll += (A[r][0]!=A[r-1][0]);\\n            seg.insert(make_pair(olddp-addAll+2, r));\\n            while(seg.begin()->second<l){\\n                seg.erase(begin(seg));\\n            }\\n            olddp = (seg.begin()->first) + addAll;\\n        }\\n        return olddp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115451,
                "title": "python3-dp-monotonic-queue-o-n",
                "content": "It is definitely another difficult problem in Leetcode. I\\'d like to share my consideration until I got accepted as an ordinary person and how I got inspired from the problems I have solved before. I\\'d appreciate it if you can get help from this post.\\n\\nAt the very beginning, I tried to find the reason why the total trips become less if transport more than one box within a single ship. It is clear that by this way, we save the cost by skipping the trip from storage to port. So, how about transport as many boxes as possible? The Example 2 is a counter-example. If we take such strategy, we transport first three boxes in one ship and the other two in the second ship, and we will get 2(storage to port) + 2 (port 2 to port 3 and port 3 to port 1) = 4 for the first ship and 2 (storage to port) + 1(port 1 to port 4) = 3 for the second ship, which the total trips is 7 greater than 6, the minimum. \\n\\nFrom the example above, I knew that a naive greedy strategy is not a proper solution for this problem. And the situation is similar with the [Jump Game](https://leetcode.com/problems/jump-game/) ; if we naively jump the  maximum length in each step, we may miss the correct answer. So I decided to consider this problem using dynamic programming (even though DP is not a clever choice for Jump Game). Since packing multiple boxes in a single ship can save the cost, the question become how many boxes should be packed. Inspired by the Jump Game (how large jump are supposed to be stepped), I roughly wrote the transition equation. \\n`dp[i] = min(dp[j] + ship(j+1, i))`\\nwhere dp[i] represents for the minimum total trips sending 0 to i-th box, dp[j] is the minimum total trips of 0 to j-th box, `ship(j + 1, i)` represents for the cost of one ship to transport from j + 1-th box to i - th box. If `ship(j + 1, i)` can be calculated, a possible solution is found. Of cource i - j are supposed to be less than or equal to `maxBoxes` and the sum of weights from j + 1-th box to i - th box should be less than or equal to `maxWeight`.\\n\\nAlso from the example above, I found that the total trips of one ship can be divided into two parts: 2 (storage to port) + `X`, where `X` represents for the number of pairs of two adjacent boxes which is expected to be sent to different ports. `X` can be calculated easily in a single for loop if we know the range of boxes within a specific ship. Moreover, we can preprocess it using prefix sum to implement a range query of `X` in `O(1)` time complexity.\\n```python\\npre_port_cost = [0] * len(boxes)\\nfor i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n\\tpre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n```\\n\\nUptil now, it seemed great, and I wrote the code fluently.\\n\\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] * (len(boxes) + 1)\\n\\n        pre_port_cost = [0] * len(boxes)\\n\\n        for i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n            pre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n\\n        for i in range(1, len(boxes) + 1):\\n            dp[i] = dp[i - 1] + 2\\n            weight = boxes[i - 1][1]\\n            for j in range(i - 1, max(i - maxBoxes, 0), -1):\\n                weight += boxes[j - 1][1]\\n                if weight <= maxWeight:\\n                    dp[i] = min(dp[i], dp[j - 1] + pre_port_cost[i - 1] - pre_port_cost[j - 1] + 2)\\n                else:\\n                    break\\n        return dp[-1]\\n```\\nAnother `O(n^2)` method finished! Wait. `O(n^2)`!?  1 <= boxes.length <= 10 ^ 5 ?\\nThus, I got TLE with no any single surprise. (35/39)\\n\\nFortunately, I immediately realized where to ask for help.\\n```python\\n if weight <= maxWeight:\\n\\tdp[i] = min(dp[i], dp[j - 1] + pre_port_cost[i - 1] - pre_port_cost[j - 1] + 2)\\n```\\nI came up with the [Best Sightseeing Pair](https://leetcode.com/problems/best-sightseeing-pair/) and [Max Value of Equation](https://leetcode.com/problems/max-value-of-equation/).\\nIn the statement about `dp[i]` above, for the `pre_port_cost[i - 1] + 2` can be considered as a constant number for `dp[i]`, and `dp[j - 1]` has the same index with `pre_port_cost[j - 1]`, I don\\'t really have to search all possible `j`. I can just use the minimum of `dp[j - 1] - pre_port_cost[j - 1]` as long as `i - j + 1 <= max_boxes and sum(weights(j, i)) <= maxWeight` .\\n\\nInspired by what I did in Max Value of Equation, a monotonic queue solution is come up with.\\n\\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] * (len(boxes) + 1)\\n\\n        pre_weight = list(itertools.accumulate((box[1] for box in boxes), initial=0))\\n        pre_port_cost = [0] * len(boxes)\\n        for i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n            pre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n\\n        queue = collections.deque()\\n\\n        for i in range(1, len(boxes) + 1):\\n            dp[i] = dp[i - 1] + 2\\n\\n            while queue and (pre_weight[i] - pre_weight[queue[0] - 1] > maxWeight or i - queue[0] + 1 > maxBoxes):\\n                queue.popleft()\\n\\n            if queue:\\n                idx = queue[0]\\n                dp[i] = min(dp[i], dp[idx - 1] - pre_port_cost[idx - 1] + pre_port_cost[i - 1] + 2)\\n\\n            while queue and dp[queue[-1] - 1] - pre_port_cost[queue[-1] - 1] > dp[i - 1] - pre_port_cost[i - 1]:\\n                queue.pop()\\n\\n            queue.append(i)\\n        return dp[-1]\\n```\\n`O(n)`\\nIt worked...",
                "solutionTags": [
                    "Dynamic Programming",
                    "Monotonic Queue"
                ],
                "code": "```python\\npre_port_cost = [0] * len(boxes)\\nfor i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n\\tpre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n```\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] * (len(boxes) + 1)\\n\\n        pre_port_cost = [0] * len(boxes)\\n\\n        for i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n            pre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n\\n        for i in range(1, len(boxes) + 1):\\n            dp[i] = dp[i - 1] + 2\\n            weight = boxes[i - 1][1]\\n            for j in range(i - 1, max(i - maxBoxes, 0), -1):\\n                weight += boxes[j - 1][1]\\n                if weight <= maxWeight:\\n                    dp[i] = min(dp[i], dp[j - 1] + pre_port_cost[i - 1] - pre_port_cost[j - 1] + 2)\\n                else:\\n                    break\\n        return dp[-1]\\n```\n```python\\n if weight <= maxWeight:\\n\\tdp[i] = min(dp[i], dp[j - 1] + pre_port_cost[i - 1] - pre_port_cost[j - 1] + 2)\\n```\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] * (len(boxes) + 1)\\n\\n        pre_weight = list(itertools.accumulate((box[1] for box in boxes), initial=0))\\n        pre_port_cost = [0] * len(boxes)\\n        for i, (pre, cur) in enumerate(zip(boxes, boxes[1:])):\\n            pre_port_cost[i + 1] = pre_port_cost[i] + (pre[0] != cur[0])\\n\\n        queue = collections.deque()\\n\\n        for i in range(1, len(boxes) + 1):\\n            dp[i] = dp[i - 1] + 2\\n\\n            while queue and (pre_weight[i] - pre_weight[queue[0] - 1] > maxWeight or i - queue[0] + 1 > maxBoxes):\\n                queue.popleft()\\n\\n            if queue:\\n                idx = queue[0]\\n                dp[i] = min(dp[i], dp[idx - 1] - pre_port_cost[idx - 1] + pre_port_cost[i - 1] + 2)\\n\\n            while queue and dp[queue[-1] - 1] - pre_port_cost[queue[-1] - 1] > dp[i - 1] - pre_port_cost[i - 1]:\\n                queue.pop()\\n\\n            queue.append(i)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969762,
                "title": "javascript-dynamic-programming-monoq-optimization-o-n-explanation",
                "content": "Although this problem may be confused with a greedy approach of always shipping the maximum amount of boxes that fit inside the boat, it is actually a DP problem, as it may be better to just omit some boxes that can be later shipped together, in order to reduce the total amount of trips. \\n\\n**Naive DP approach**: \\n```\\n\\tdp[i]=Minimum amount of trips needed to ship the i-th box. \\n```\\n\\n```\\n\\tfor(i=0;i<n;i++)// for every position\\n\\t\\tfor(k=0;k<i;k++) // consider the last shipping being [k-thbox,i-th box] inclusive\\n\\t\\t\\t\\tif( prTrips[i] - prTrips[k+1] <=maxTrips  ) //keep a tab prTrips[i]= the amount of trips needed from 0th to ith box\\n\\t\\t\\t\\tif( prWeight[i] - prWeight[k] <=maxWeight  ) //likewise for the weight\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[k]+ prTrips[i] -prTrips[k+1] +2) //+2 because I need to get to the k-th box and return from the i-th, to complete the last shipping\\n```\\nThe above approach will most likely TLE\\n**Key observation** : \\n```\\n\\tdp[i] always chooses the index k that minimizes dp[k]-prTrips[k+1] ,for a k<i that is valid \\n```\\nSo if we keep a queue, such  that it holds tuples of the form [ k, dp[k]-prTrips[k] ]  and we ensure that the beginning of the queue holds the minimum dp[k]-prTrips[k] that  is valid  ( abides by the maxWeight and maxTrips rules)  then the second loop of the naive approach will be redundant, because the answer for any given i will always be at the beginning of the queue.\\n\\n**DP+monotonic queue optimization**:\\n```\\nvar boxDelivering = function(B, P, mB, mW) {\\n    let prW=[0],n=B.length,prT=[0]\\n    for(let i=0;i<n;i++)\\n        prW.push(prW[prW.length-1]+B[i][1]),\\n        prT.push(prT[prT.length-1]+ (i==0?0:Number(B[i][0]!==B[i-1][0])))\\n\\n    let dp=[...Array(n+1)].map(d=>Infinity)\\n    dp[0]=0 //0 steps needed to get to the beginning\\n    q=[ [0,-prT[1] ]  // the 0-th index is a dummy element, however it does abide by the rules of my monoq, so when a next element considers 0, it needs -prT[1]\\n    for(let i=1;i<=n;i++){\\n        while(q.length&&prW[i]-prW[q[0][0]]>mW || i-q[0][0]>mB) // Ensure the first element abides by the constraints\\n            q.shift()\\n        dp[i]= q[0][1]+prT[i]+2 // the first element now holds the answer for dp[i]\\n        while( q.length&& q[q.length-1][1]>=dp[i]-prT[i+1]) //pop off the end anything that\\'s worse\\n            q.pop()\\n        q.push( [i, dp[i]-prT[i+1] ] ) // and push this value so that it may be used by the next elements\\n    }\\n    return dp[n] \\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\tdp[i]=Minimum amount of trips needed to ship the i-th box. \\n```\n```\\n\\tfor(i=0;i<n;i++)// for every position\\n\\t\\tfor(k=0;k<i;k++) // consider the last shipping being [k-thbox,i-th box] inclusive\\n\\t\\t\\t\\tif( prTrips[i] - prTrips[k+1] <=maxTrips  ) //keep a tab prTrips[i]= the amount of trips needed from 0th to ith box\\n\\t\\t\\t\\tif( prWeight[i] - prWeight[k] <=maxWeight  ) //likewise for the weight\\n\\t\\t\\t\\t\\tdp[i]=Math.min(dp[i],dp[k]+ prTrips[i] -prTrips[k+1] +2) //+2 because I need to get to the k-th box and return from the i-th, to complete the last shipping\\n```\n```\\n\\tdp[i] always chooses the index k that minimizes dp[k]-prTrips[k+1] ,for a k<i that is valid \\n```\n```\\nvar boxDelivering = function(B, P, mB, mW) {\\n    let prW=[0],n=B.length,prT=[0]\\n    for(let i=0;i<n;i++)\\n        prW.push(prW[prW.length-1]+B[i][1]),\\n        prT.push(prT[prT.length-1]+ (i==0?0:Number(B[i][0]!==B[i-1][0])))\\n\\n    let dp=[...Array(n+1)].map(d=>Infinity)\\n    dp[0]=0 //0 steps needed to get to the beginning\\n    q=[ [0,-prT[1] ]  // the 0-th index is a dummy element, however it does abide by the rules of my monoq, so when a next element considers 0, it needs -prT[1]\\n    for(let i=1;i<=n;i++){\\n        while(q.length&&prW[i]-prW[q[0][0]]>mW || i-q[0][0]>mB) // Ensure the first element abides by the constraints\\n            q.shift()\\n        dp[i]= q[0][1]+prT[i]+2 // the first element now holds the answer for dp[i]\\n        while( q.length&& q[q.length-1][1]>=dp[i]-prT[i+1]) //pop off the end anything that\\'s worse\\n            q.pop()\\n        q.push( [i, dp[i]-prT[i+1] ] ) // and push this value so that it may be used by the next elements\\n    }\\n    return dp[n] \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1333667,
                "title": "c-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> boxes;\\n    int ports , max_box , max_wt , n;\\n    vector<int> dp;\\n    \\n    int backtrack(int index) {\\n        if(index == n)\\n            return 0;\\n        if(dp[index] != 0)\\n            return dp[index];\\n        \\n        int start = index, end = index, currWt = boxes[index][1] , boxCount = 1 , lastPort = boxes[index][0] , ports_visited = 0;\\n        //as long as it\\'s possible to load the boxes load them into the ship so that the visit to the storage unit is minimised.\\n        while(end+1<n && currWt + boxes[end+1][1] <= max_wt && boxCount + 1 <=max_box) \\n        {\\n            end++;\\n            currWt += boxes[end][1];\\n            boxCount++;\\n            if(lastPort != boxes[end][0]){\\n                ports_visited++;\\n                lastPort = boxes[end][0];\\n            }\\n        }\\n        //2 - from the storage to the 1st port and then back to the storage from the last port either for loading the next set of boxes or returning after delivering all the boxes.         \\n        int trips = 2 + ports_visited + backtrack(end+1);\\n        \\n        //number of trips can still be minimised when a box going to port \\'j\\' can be included in the next trip if there are other boxes going to port \\'j\\'\\n        \\n        int x = -1;\\n        for(int i = end-1;i>=index;i--){\\n            if(boxes[i][0]!=lastPort) {\\n            cout<<end<<\"    end\\\\n\";                \\n                x = i;\\n                break;\\n            }\\n        }\\n        if(x!=-1){\\n            trips = min(trips , 2+ports_visited-1+backtrack(x+1));\\n        }\\n\\n        dp[index] = trips;        \\n        cout<<trips<<\" \"<<index<<\"\\\\n\";\\n        return trips;        \\n    }\\n    \\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        this->boxes = boxes;\\n        //ports,boxes\\n        n = boxes.size();\\n        dp.assign(n,0);\\n        ports = portsCount; \\n        max_box = maxBoxes;\\n        max_wt = maxWeight;\\n        return backtrack(0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<vector<int>> boxes;\\n    int ports , max_box , max_wt , n;\\n    vector<int> dp;\\n    \\n    int backtrack(int index) {\\n        if(index == n)\\n            return 0;\\n        if(dp[index] != 0)\\n            return dp[index];\\n        \\n        int start = index, end = index, currWt = boxes[index][1] , boxCount = 1 , lastPort = boxes[index][0] , ports_visited = 0;\\n        //as long as it\\'s possible to load the boxes load them into the ship so that the visit to the storage unit is minimised.\\n        while(end+1<n && currWt + boxes[end+1][1] <= max_wt && boxCount + 1 <=max_box) \\n        {\\n            end++;\\n            currWt += boxes[end][1];\\n            boxCount++;\\n            if(lastPort != boxes[end][0]){\\n                ports_visited++;\\n                lastPort = boxes[end][0];\\n            }\\n        }\\n        //2 - from the storage to the 1st port and then back to the storage from the last port either for loading the next set of boxes or returning after delivering all the boxes.         \\n        int trips = 2 + ports_visited + backtrack(end+1);\\n        \\n        //number of trips can still be minimised when a box going to port \\'j\\' can be included in the next trip if there are other boxes going to port \\'j\\'\\n        \\n        int x = -1;\\n        for(int i = end-1;i>=index;i--){\\n            if(boxes[i][0]!=lastPort) {\\n            cout<<end<<\"    end\\\\n\";                \\n                x = i;\\n                break;\\n            }\\n        }\\n        if(x!=-1){\\n            trips = min(trips , 2+ports_visited-1+backtrack(x+1));\\n        }\\n\\n        dp[index] = trips;        \\n        cout<<trips<<\" \"<<index<<\"\\\\n\";\\n        return trips;        \\n    }\\n    \\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        this->boxes = boxes;\\n        //ports,boxes\\n        n = boxes.size();\\n        dp.assign(n,0);\\n        ports = portsCount; \\n        max_box = maxBoxes;\\n        max_wt = maxWeight;\\n        return backtrack(0);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1180277,
                "title": "dp-sliding-window-minimum-prefix-sum-optimized",
                "content": "This is the follow up of another [post of mine](https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/973310/not-greedy-dp-sliding_window-segmentreemonoqueuesortedcontainersredblacktree).\\n\\n## Notations:\\n1. `cost(i,j)` the answer of this problem ( leetcode #1687 ) only replace `boxes` argument with `boxes[i:j+1]`\\n2. `C := [ boxes[i+1][0]!=boxes[i][0] for i in range(len(boxes)-1)]`\\n3. `n :=len(boxes)`\\n\\n## Intuition:\\n\\nThe problem have to divide `boxes` into some groups that the ship can take in one trip. We need to find the optimal divide method.\\nIf we discuss the \"rightmost\" group, then we can divide the original problem into subproblems.\\n\\n## core steps:\\n\\n1. we have to calculate `cost(0,n-1)`; And for any `k` that `i<=k<=j`, \\n    \\n    ```python\\n\\tcost(i,j)=cost(i,k)+cost(k+1,j)\\n\\t```\\n\\n\\n2. (from 1) for any `r` that `leftmost(r)>0`, where `leftmost(r)` return minimum index `i` that the  ship can take `boxes[i:r+1]`\\n    \\n\\t   cost(0,r)=min(cost(0,k-1)+cost(k,r) for k in range(leftmost(r),r+1) )\\n      \\n3. If ship can take  `boxes[k:r+1]`\\n     \\n\\t   cost(k,r)=2+sum(C[k:r])=2+sum(C[:r])-sum(C[:k])\\n4. (from 2,3) \\n\\n\\t    cost(0,r)=min( cost(0,k-1)+2+sum(C[:r])-sum(C[:k]) for k in range(leftmost(r),r+1) ) \\n\\t\\t# sum(C[:r]) is constant correspond to k\\n\\t\\t\\n\\t> this is the most important part, it tells us finding `cost(0,r)` means find minium of `cost(0,k-1)-sum(C[:k])` in a window. You can regard it as a function about k \\n\\n5. [monoqueue](https://cp-algorithms.com/data_structures/stack_queue_modification.html) is born to find max/min in sliding window. If you feel confused, I suggest you solve leetcode #239 firstly.\\n## code part\\n\\nFirstly you write some monoqueue support finding minium and lazy deletion.\\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n    def append(self, i, v):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<v:\\n            dq.pop()\\n        dq.append((i,v))\\n    def getMin(self, l):\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return self.dq[0][1]\\n```\\n\\nSecondly, you write a sliding window to traverse each pair of `leftmost(r),r` and calculate prefix sum of C:\\n\\n``` \\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n\\t\\t\\n\\t\\tC=[0]*(n-1)\\n        for i in range(n-1):\\n            if A[i+1][0]!=A[i][0]:\\n                C[i]=1\\n        preC = list(accumulate(C, initial=0)) # prefix sum of C\\n        # write code here\\n```\\n\\nFinally, you combine them together.\\nIt can be shorten a lot such as add a sentinel, but that\\'s not necessary.\\nTime O(n), space O(maxBoxes)\\n\\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n    def append(self, i, v):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<v:\\n            dq.pop()\\n        dq.append((i,v))\\n    def getMin(self, l):\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return self.dq[0][1]\\n    \\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n\\n        C=[ A[i+1][0]!=A[i][0] for i in range(n-1)]\\n        preC = list(accumulate(C, initial=0)) # prefix sum of C\\n        mdq = MonoQueue()\\n        \\n        for l,r in slidingWindow():\\n\\t\\t    # loop invariant: mdq stores all `cost(0,k-1)-sum(C[:k])` for 0<=k<=r\\n\\t\\t\\n            # calculate cost(0,r)\\n            if l==0: # directly\\n                cost_0_r = 2+preC[r]\\n            else: # use equation 4\\n                cost_0_r = mdq.getMin(l)+2+preC[r]\\n            if r==n-1:\\n                return cost_0_r\\n            \\n            mdq.append(r+1, cost_0_r-preC[r+1]) # store new `cost(0,k-1)-sum(C[:k])` where k=r+1\\n```\\n",
                "solutionTags": [],
                "code": "```python\\n\\tcost(i,j)=cost(i,k)+cost(k+1,j)\\n\\t```\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n    def append(self, i, v):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<v:\\n            dq.pop()\\n        dq.append((i,v))\\n    def getMin(self, l):\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return self.dq[0][1]\\n```\n``` \\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n\\t\\t\\n\\t\\tC=[0]*(n-1)\\n        for i in range(n-1):\\n            if A[i+1][0]!=A[i][0]:\\n                C[i]=1\\n        preC = list(accumulate(C, initial=0)) # prefix sum of C\\n        # write code here\\n```\n```\\nclass MonoQueue:\\n    def __init__(self):\\n        self.dq = deque()\\n    def append(self, i, v):\\n        dq = self.dq\\n        while dq and not dq[-1][1]<v:\\n            dq.pop()\\n        dq.append((i,v))\\n    def getMin(self, l):\\n        dq = self.dq\\n        while dq[0][0]<l:\\n            dq.popleft()\\n        return self.dq[0][1]\\n    \\nclass Solution:\\n    def boxDelivering(self, A, __, B, W):\\n        n = len(A)\\n        def slidingWindow():\\n            l=0\\n            cW = 0\\n            for r in range(n):\\n                cW+=A[r][1]\\n                while cW>W or r-l+1>B:\\n                    cW-=A[l][1]\\n                    l+=1\\n                yield l,r\\n\\n        C=[ A[i+1][0]!=A[i][0] for i in range(n-1)]\\n        preC = list(accumulate(C, initial=0)) # prefix sum of C\\n        mdq = MonoQueue()\\n        \\n        for l,r in slidingWindow():\\n\\t\\t    # loop invariant: mdq stores all `cost(0,k-1)-sum(C[:k])` for 0<=k<=r\\n\\t\\t\\n            # calculate cost(0,r)\\n            if l==0: # directly\\n                cost_0_r = 2+preC[r]\\n            else: # use equation 4\\n                cost_0_r = mdq.getMin(l)+2+preC[r]\\n            if r==n-1:\\n                return cost_0_r\\n            \\n            mdq.append(r+1, cost_0_r-preC[r+1]) # store new `cost(0,k-1)-sum(C[:k])` where k=r+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970664,
                "title": "python-dp-o-n",
                "content": "`DP[i] ` : min trips delivering i boxes ( from index 0 to i-1)\\n`DP[i+1] = DP[start_from] + port_count + 1 `\\n\\ntake `box[i]` at each iteration, discard `box[start_from]` when \\n`1. cur_b > maxBoxes`\\n`2. cur_w > maxWeight`\\n`3. DP[start_from] == DP[start_from+1]` and `start_from < i`\\n\\n3 is because `DP[start_from] == DP[start_from+1]` means we can start from same trips from `start_from `and `start_from + 1`, and it\\'s always better to delivery less boxes.\\n\\n```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        start_from = 0\\n        port_count = 0\\n        cur_w = 0\\n        cur_b = 0\\n        DP = [0] * (n+1)\\n\\n        for i in range(n):\\n            cur_w += boxes[i][1]\\n            cur_b += 1\\n            if i == 0 or boxes[i][0] != boxes[i-1][0]:\\n                port_count += 1\\n            while cur_b > maxBoxes or cur_w > maxWeight or (start_from < i and DP[start_from] == DP[start_from+1]):\\n                cur_b -= 1\\n                cur_w -= boxes[start_from][1]\\n                if boxes[start_from][0] != boxes[start_from+1][0]:\\n                    port_count -= 1\\n                start_from += 1\\n            DP[i+1] = DP[start_from]+port_count+1\\n        return DP[n]       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        start_from = 0\\n        port_count = 0\\n        cur_w = 0\\n        cur_b = 0\\n        DP = [0] * (n+1)\\n\\n        for i in range(n):\\n            cur_w += boxes[i][1]\\n            cur_b += 1\\n            if i == 0 or boxes[i][0] != boxes[i-1][0]:\\n                port_count += 1\\n            while cur_b > maxBoxes or cur_w > maxWeight or (start_from < i and DP[start_from] == DP[start_from+1]):\\n                cur_b -= 1\\n                cur_w -= boxes[start_from][1]\\n                if boxes[start_from][0] != boxes[start_from+1][0]:\\n                    port_count -= 1\\n                start_from += 1\\n            DP[i+1] = DP[start_from]+port_count+1\\n        return DP[n]       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971464,
                "title": "dp-topdown",
                "content": "In each trip, we try to load box as possible.  In last few box of each trip, there is a case we load partial of boxes to same port in this trip and left some in next trip. We need compare the result if we should left all of those boxes to next trip in that case.\\n```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<Integer, Integer>();\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        return dfs(boxes, 0, maxBoxes, maxWeight);\\n    }\\n    \\n    private int dfs(int[][] boxes, int start, int maxBoxes, int maxWeight) {\\n        if(dp.get(start) != null) return dp.get(start);\\n        if(start == boxes.length) return 0;\\n        \\n        int portCount = 1, prevPort = boxes[start][0], fullLoadedIndex = start, weight=0, i = start;\\n        for(; i < boxes.length && i < start + maxBoxes; i++) {\\n            weight += boxes[i][1];\\n            if(weight > maxWeight) break;\\n            \\n            if(boxes[i][0] != prevPort) {\\n                portCount++;\\n                fullLoadedIndex = i;\\n            }\\n            \\n            prevPort = boxes[i][0];\\n        }\\n        \\n        int result = dfs(boxes, i, maxBoxes, maxWeight) + portCount + 1;\\n        if(i < boxes.length && boxes[i][0] == prevPort && fullLoadedIndex > start) {\\n            result = Math.min(result, dfs(boxes, fullLoadedIndex, maxBoxes, maxWeight) + portCount);\\n        }\\n        \\n        dp.put(start, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> dp = new HashMap<Integer, Integer>();\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        return dfs(boxes, 0, maxBoxes, maxWeight);\\n    }\\n    \\n    private int dfs(int[][] boxes, int start, int maxBoxes, int maxWeight) {\\n        if(dp.get(start) != null) return dp.get(start);\\n        if(start == boxes.length) return 0;\\n        \\n        int portCount = 1, prevPort = boxes[start][0], fullLoadedIndex = start, weight=0, i = start;\\n        for(; i < boxes.length && i < start + maxBoxes; i++) {\\n            weight += boxes[i][1];\\n            if(weight > maxWeight) break;\\n            \\n            if(boxes[i][0] != prevPort) {\\n                portCount++;\\n                fullLoadedIndex = i;\\n            }\\n            \\n            prevPort = boxes[i][0];\\n        }\\n        \\n        int result = dfs(boxes, i, maxBoxes, maxWeight) + portCount + 1;\\n        if(i < boxes.length && boxes[i][0] == prevPort && fullLoadedIndex > start) {\\n            result = Math.min(result, dfs(boxes, fullLoadedIndex, maxBoxes, maxWeight) + portCount);\\n        }\\n        \\n        dp.put(start, result);\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209277,
                "title": "simplest-possible-code-using-dp-and-sliding-window-time-o-n-space-o-n",
                "content": "# Observation \\n(1) Boxes must be handled in order from left to right, this is a signal to use DP.\\n(2) Since it is 10^5. DP must be 1-dimension, i.e, for every index i we need to find a single index j and apply DP[i] = f(DP[j]) for some DP function f.\\n\\nIntution ->\\nWe can take as many boxes as possible using greedy approach.\\nBut in one case,\\nthe last several small boxes in this trip,\\nare going to the same port as the first box in the next trips.\\nWe may probably let it go in the next trip,\\nwe waste a little weight, but we can save a trip.\\n\\n\\n# Approach\\n\\nFirst we added the box at position i. Then we remove boxes at the starting poistion of ship based on following rules:\\n\\nThe shipload must be within max weight and max count of the boxes.\\nMake room for more boxes as long as the result at current position trips[i+1] won\\'t change. (This is greedy solution)\\nThe cases:\\n\\nbase case: for 1 box, we need 2 trips for one shipload to deliver it and return.\\ngeneral case: for 2 or more boxes case, adding one shipload would result in 2 trips + diff ports.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Conclusion \\n\\nThere are many ways to solve this problem. I felt sliding window is the simplest of all. But,someone may have contrasting view point. So,try other approaches and go for approach which comforts you the best. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int portsCount, int B, int W) \\n    {\\n        int n = A.size(); \\n        int need = 0;\\n        int j = 0;\\n        int lastj = 0;\\n        vector<int> dp(n + 1, 200000); \\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) \\n        {\\n            while (j < n && B > 0 && W >= A[j][1]) \\n            {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) \\n                {\\n                    lastj = j;\\n                    need++;\\n                }\\n                j++;\\n            }\\n            dp[j] = min(dp[j], dp[i] + need + 1);\\n            dp[lastj] = min(dp[lastj], dp[i] + need);\\n            B += 1;\\n            W += A[i][1];\\n            if (i == n - 1 || A[i][0] != A[i + 1][0]) \\n            {\\n                need--;\\n            }\\n        }\\n        return dp[n];\\n    }\\n};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& A, int portsCount, int B, int W) \\n    {\\n        int n = A.size(); \\n        int need = 0;\\n        int j = 0;\\n        int lastj = 0;\\n        vector<int> dp(n + 1, 200000); \\n        dp[0] = 0;\\n        for (int i = 0; i < n; ++i) \\n        {\\n            while (j < n && B > 0 && W >= A[j][1]) \\n            {\\n                B -= 1;\\n                W -= A[j][1];\\n                if (j == 0 || A[j][0] != A[j - 1][0]) \\n                {\\n                    lastj = j;\\n                    need++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1820732,
                "title": "java-sliding-window-dp-o-n-solution-clean-code-with-explanation",
                "content": "First we added the box at position i. Then we remove boxes at the starting poistion of ship based on following rules:\\n1. The shipload must be within max weight and max count of the boxes.\\n2. Make room for more boxes as long as the result at current position trips[i+1] won\\'t change. (This is greedy solution)\\n\\nThe cases: \\n1. base case: for 1 box, we need 2 trips for one shipload to deliver it and return.\\n2. general case: for 2 or more boxes case, adding one shipload would result in 2 trips + diff ports.\\n\\nWhy 2 trips? because the ship needs to return and come back at **this** same port at position \"start\".\\n\\n\\nCredit to @tien-nam. \\n\\n\\n\\n```\\npublic int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n    int n = boxes.length;\\n    int[] trips = new int[n + 1];\\n    int start = 0, diff = 0;\\n\\n    for(int i = 0; i < n; i++){\\n      maxWeight -= boxes[i][1];\\n      maxBoxes--;\\n      if(i > 0 && boxes[i][0] != boxes[i-1][0]) diff++;\\n\\n      while(maxWeight < 0 || maxBoxes < 0 || (start < i && trips[start + 1] == trips[start])){\\n        maxWeight += boxes[start++][1];\\n        maxBoxes++;\\n        if(boxes[start][0] != boxes[start-1][0]) diff--;\\n      }\\n      trips[i+1] = trips[start] + diff + 2;\\n    }\\n    return trips[n];\\n  }\\n",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "First we added the box at position i. Then we remove boxes at the starting poistion of ship based on following rules:\\n1. The shipload must be within max weight and max count of the boxes.\\n2. Make room for more boxes as long as the result at current position trips[i+1] won\\'t change. (This is greedy solution)\\n\\nThe cases: \\n1. base case: for 1 box, we need 2 trips for one shipload to deliver it and return.\\n2. general case: for 2 or more boxes case, adding one shipload would result in 2 trips + diff ports.\\n\\nWhy 2 trips? because the ship needs to return and come back at **this** same port at position \"start\".\\n\\n\\nCredit to @tien-nam. \\n\\n\\n\\n```\\npublic int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n    int n = boxes.length;\\n    int[] trips = new int[n + 1];\\n    int start = 0, diff = 0;\\n\\n    for(int i = 0; i < n; i++){\\n      maxWeight -= boxes[i][1];\\n      maxBoxes--;\\n      if(i > 0 && boxes[i][0] != boxes[i-1][0]) diff++;\\n\\n      while(maxWeight < 0 || maxBoxes < 0 || (start < i && trips[start + 1] == trips[start])){\\n        maxWeight += boxes[start++][1];\\n        maxBoxes++;\\n        if(boxes[start][0] != boxes[start-1][0]) diff--;\\n      }\\n      trips[i+1] = trips[start] + diff + 2;\\n    }\\n    return trips[n];\\n  }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1465884,
                "title": "python3-dp-greedy",
                "content": "\\n```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] + [inf]*len(boxes)\\n        trips = 2\\n        ii = 0\\n        for i in range(len(boxes)):\\n            maxWeight -= boxes[i][1]\\n            if i and boxes[i-1][0] != boxes[i][0]: trips += 1\\n            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:\\n                maxWeight += boxes[ii][1]\\n                if boxes[ii][0] != boxes[ii+1][0]: trips-=1\\n                ii += 1\\n            dp[i+1] = dp[ii] + trips\\n        return dp[-1] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        dp = [0] + [inf]*len(boxes)\\n        trips = 2\\n        ii = 0\\n        for i in range(len(boxes)):\\n            maxWeight -= boxes[i][1]\\n            if i and boxes[i-1][0] != boxes[i][0]: trips += 1\\n            while maxBoxes < i - ii + 1 or maxWeight < 0 or ii < i and dp[ii] == dp[ii+1]:\\n                maxWeight += boxes[ii][1]\\n                if boxes[ii][0] != boxes[ii+1][0]: trips-=1\\n                ii += 1\\n            dp[i+1] = dp[ii] + trips\\n        return dp[-1] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367397,
                "title": "proof-with-c-o-n-dp-greedy",
                "content": "This proof is based on the intuition provided by delphih in their solution [here](https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/discuss/969560/Python-O(n).-DP-%2B-Monotonic-Queue-(Sliding-Window)-with-Full-Explanation).\\n\\nTo reiterate what was explained in that post:\\n1. We have a base cost(total no. of trips) that will always be there independent of how we chose our round of trips.\\n2. There is a variable cost associated with the choice of the division and `finalCost = total base cost + variable cost` so if we minimise the `variable cost` the `final cost` will be minimised.\\n\\n**Observation for variable cost:**\\n1. If a division is made in chosing the boxes to deliver such that the first box chosen in the latest round is equal to the last box i.e. `boxes[start - 1][0] == boxes[start][0]`, then this adds `+1` to the total variable cost.\\n2. Whereas if `boxes[start-1][0] != boxes[start][0]`, no variable cost is added in making this division.\\n\\n\\nLet `dp[i]` represent the min. variable cost that can be introduced after delivering the first `i+1` boxes i.e. `boxes[0...i]` and returning back to the storage after delivering the `boxes[i]`.\\n\\n**Observations for** `dp[i]`:\\n\\n3. `dp[i]` is non-decreasing in `i` since adding one more box only increases the possibility of adding a variable cost.\\n\\n**Observations for the sliding window:**\\n\\n4. The largest sliding window of `boxes[i]` can\\'t extend farther than the largest sliding window of `boxes[i-1]` since `weights > 0`. Also since we always start searching with the previous `i\\'s` best value (`start`) means we never miss a more optimal solution.\\n\\n\\n**Proof**:\\nBefore the `ith` iteration.\\nLets assume we have found the value of all `dp[k]` for `0 <= k < i`.\\n\\n`start`: refers to the index `k` for which the variable cost `dp[i-1]` is minimised by making the latest round trip for `boxes[k...i-1]` i.e the  `k` for which the constraints are satisfied and\\n`dp[i-1] = dp[k-1] + (boxes[k-1][0] == boxes[k][0]) + 1` \\nis minimised.\\n\\n`sum`: refers to the summation `Sigma(boxes[k][1]) for start<=k<i`\\nThe above is true before we start the `ith` iteration.\\n\\nLet `newStart` be the min. `j >= start` for which the constraints for `boxes[i]` are satisfied.\\n\\n`newStart` is the value of `start` after the end of the while loop\\n```\\n\\t\\t\\tsum += boxes[i][1];\\n            while ((i - start +1 > mB) || (sum > mW)) {\\n                sum -= boxes[start++][1];\\n            }\\n\\t\\t\\t// newStart is the value of start at this point\\n```\\n\\n**Reducing the search space:**\\n\\nLet there be some `newStartLast in [newStart, i]` such that `dp[k - 1] == dp[newStart - 1] for all newStart <= k <= newStartLast <=i`.\\nNow since `dp[i]` is non-decreasing in `i` , and we want to minimise `dp[i] = dp[k-1] + (boxes[k - 1][0] == boxes[k][0]) + 1` for some k that satisfies the constraints i.e `newStart<=k<=i`.\\n\\nThen we have two choices:\\n\\n1. Pick our `k` in `[newStart, newStartLast]`, all values are `== dp[newStart - 1]` by definition.\\n2. Pick our `k` in `[newStartLast+1, i]`(might be empty), all values are ` >= dp[newStart - 1] +1 `.\\n\\nBut the value of `dp[k-1] + (boxes[k][0] == boxes[k+1][0])` for the first choice is in `{dp[newStart -1], dp[newStart-1] +1} <= any value in the second choice` . **So we only have to select k in [newStart, newStartLast].**\\n\\n**From observation(4) we can say that the optimal** `k` for `dp[i]` is `>=newStart`.**So we can be sure that we aren\\'t missing a better value by starting from where the last iteration ended**.\\n\\nThis means we can start with `newStart` and take the first `k` for which\\n\\n1. `(boxes[start-1][0] != boxes[start][0]) `, the best possible value we can have.\\n2. `dp[k] != dp[k -1]`, none better than `dp[newStart -1]` were found.\\n\\n\\n\\n```\\n\\t\\t\\tif (start > 0) {\\n                while((start < i) && (boxes[start-1][0] == boxes[start][0]) && (dp[start -1] == dp[start])) {\\n                    sum -= boxes[start++][1];\\n                }\\n            }\\n```\\n\\nC++ implementation\\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int mB, int mW) {\\n        int non_reducible = 1; // the base cost associated with the given boxes\\n        for (int i=1;i<boxes.size();i++) {\\n            non_reducible += boxes[i][0] != boxes[i-1][0];\\n        }\\n        \\n        int start = 0, sum =0;// we\\'ll be taking boxes[start...i] in the latest trip\\n        vector<int> dp(boxes.size(),0); // it will be non-decreasing\\n        for (int i =0;i<boxes.size();i++) {\\n            sum += boxes[i][1]; // admit boxes[i] in the sliding window\\n            while ((i - start +1 > mB) || (sum > mW)) {// keep increasing the sliding window tail till constraints are satisfied\\n                sum -= boxes[start++][1];\\n            }\\n            // newStart is the value of start at this point\\n            \\n            if (start > 0) {\\n                // the optimal start will be found before dp[start -1] == dp[start] becomes false\\n                while((start < i) && (boxes[start-1][0] == boxes[start][0]) && (dp[start -1] == dp[start])) {\\n                    sum -= boxes[start++][1];\\n                }\\n            }\\n            // we try and make  (boxes[start][0] == boxes[start-1][0]) == 0 while keeping dp[start-1] constant \\n            dp[i] = (start > 0 ? (dp[start -1] + (boxes[start][0] == boxes[start-1][0])) : 0) + 1;\\n        }\\n        \\n        return dp[boxes.size()-1] + non_reducible;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n\\t\\t\\tsum += boxes[i][1];\\n            while ((i - start +1 > mB) || (sum > mW)) {\\n                sum -= boxes[start++][1];\\n            }\\n\\t\\t\\t// newStart is the value of start at this point\\n```\n```\\n\\t\\t\\tif (start > 0) {\\n                while((start < i) && (boxes[start-1][0] == boxes[start][0]) && (dp[start -1] == dp[start])) {\\n                    sum -= boxes[start++][1];\\n                }\\n            }\\n```\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int mB, int mW) {\\n        int non_reducible = 1; // the base cost associated with the given boxes\\n        for (int i=1;i<boxes.size();i++) {\\n            non_reducible += boxes[i][0] != boxes[i-1][0];\\n        }\\n        \\n        int start = 0, sum =0;// we\\'ll be taking boxes[start...i] in the latest trip\\n        vector<int> dp(boxes.size(),0); // it will be non-decreasing\\n        for (int i =0;i<boxes.size();i++) {\\n            sum += boxes[i][1]; // admit boxes[i] in the sliding window\\n            while ((i - start +1 > mB) || (sum > mW)) {// keep increasing the sliding window tail till constraints are satisfied\\n                sum -= boxes[start++][1];\\n            }\\n            // newStart is the value of start at this point\\n            \\n            if (start > 0) {\\n                // the optimal start will be found before dp[start -1] == dp[start] becomes false\\n                while((start < i) && (boxes[start-1][0] == boxes[start][0]) && (dp[start -1] == dp[start])) {\\n                    sum -= boxes[start++][1];\\n                }\\n            }\\n            // we try and make  (boxes[start][0] == boxes[start-1][0]) == 0 while keeping dp[start-1] constant \\n            dp[i] = (start > 0 ? (dp[start -1] + (boxes[start][0] == boxes[start-1][0])) : 0) + 1;\\n        }\\n        \\n        return dp[boxes.size()-1] + non_reducible;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971299,
                "title": "greedy-o-n-time-and-o-1-space-c",
                "content": "**Idea**\\nIn a nutshell it is the same idea as any solution posted so far. When deciding on which ports to visit during the current ship voyage, one of two options is optimal:\\n1) Deliver as many boxes as you can given the problem constraints.\\n2) Same as 1 exept do not deliver to the last port `last_port` (viable only if not all boxes in the ship have the same destination) and only if the next box in queue needs to be delivered to the `last_port` as well.\\n\\nThe difference is that with a little bit more of additional work, we could decide which of two options is optimal. More precisely, for each time we are faced with the above choice:\\n1) Compute the number of extra ships needed (without counting the current ship) to deliver all consequent boxes to the `last_port`.\\n2) If the same amount of ships needed  in both cases then option 2 is optimal, otherwise option 1 is optimal.\\n\\n**Algorithm correctness**\\nIf the same number of trips needed to deliver consequent boxes to the `last_port` for both options, then it means that in the 2nd option we saved one trip (for not visiting `last_port` during the current ship voyage). So, we are \"weakly better\" in the second option, as even if we start a new ship voyage (using extra trip saved to return ship back to the storage), we still will use \"weekly less\" trips to deliver all the remaining boxes (as we have more space in this new ship than in the last ship used for option 1).\\n\\nSimilar logic could be applied to the case when more ships are needed to deliver consequent boxes to the `last_port` for  the 2nd option.\\n\\n**Complexity**\\nThere is only constant additional memory used, so space complexity is O(1).\\n\\nTime complexity is O(n). O(n) for all calls of the first subroutine -  count the maximum number of boxes to be delivered during current ship voyage. And additional O(n) for all calls of the second subroutine -  count number of ships needed to deliver consequtive boxes to the same port (at most `# Consequtive Same Port Boxes` `*` `# Cases of Consequitive Same Port Boxes`).\\n\\n**C++ Implementation**\\n```\\nclass Solution {\\n    // Subrutine to count the maximum number of boxes to be delivered during current ship voyage.\\n    // Returns index of the next box in the queue and number of trips taken during current voyage\\n    pair<int, int> try_deliver(vector<vector<int>>& boxes, int start, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n        int i(start);\\n        int cnt(0);\\n        int weight(0);\\n        int trips(1);\\n        while ((i != n) and (cnt < maxBoxes) and (weight + boxes[i][1] <= maxWeight)) {\\n            ++cnt;\\n            weight += boxes[i][1];\\n            if (i == start) {\\n                trips += 1;\\n            } else if (boxes[i][0] != boxes[i - 1][0]) {\\n                trips +=1;\\n            }\\n            ++i;\\n        }\\n        return make_pair(i, trips);\\n    }\\n    \\n    // Subroutine to count number of ships needed to deliver consequtive boxes to the same port\\n    int same_port_deliver(vector<vector<int>>& boxes, int start, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n        \\n        int ships(1);\\n        int cnt(0);\\n        int weight(0);\\n        int i(start);\\n        while ((i != n) and (boxes[i][0] == boxes[start][0])) {\\n        \\n            if ((cnt == maxBoxes) or (weight + boxes[i][1] > maxWeight)) {\\n                ++ships;\\n                cnt = 1;\\n                weight = boxes[i][1]; \\n            } else {\\n                ++cnt;\\n                weight += boxes[i][1];\\n            }\\n            ++i;\\n        }\\n        return ships;\\n    }\\n    \\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        \\n        int n = boxes.size();\\n        int start = 0;\\n        int trips = 0;\\n        \\n        while (start != n) {\\n            pair<int, int> a = try_deliver(boxes, start, maxBoxes, maxWeight);    \\n            \\n            if ((a.first != n) and \\n                (boxes[a.first][0] == boxes[a.first - 1][0]) and \\n                (boxes[a.first][0] != boxes[start][0])) {\\n                \\n                // check two options;\\n                int last_port(boxes[a.first][0]);\\n                int first(a.first);\\n                while (boxes[first][0] == last_port) --first;\\n                ++first;\\n                \\n                // option 1 - start = a.first\\n                int n1 = same_port_deliver(boxes, a.first, maxBoxes, maxWeight);\\n                \\n                // option 2 - start = first\\n                int n2 = same_port_deliver(boxes, first, maxBoxes, maxWeight);\\n                \\n                if (n1 == n2) {\\n                    start = first;\\n                    trips += a.second - 1;\\n                    continue;\\n                }\\n            } \\n            \\n            trips += a.second;\\n            start = a.first;\\n        }\\n        \\n        return trips;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Subrutine to count the maximum number of boxes to be delivered during current ship voyage.\\n    // Returns index of the next box in the queue and number of trips taken during current voyage\\n    pair<int, int> try_deliver(vector<vector<int>>& boxes, int start, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n        int i(start);\\n        int cnt(0);\\n        int weight(0);\\n        int trips(1);\\n        while ((i != n) and (cnt < maxBoxes) and (weight + boxes[i][1] <= maxWeight)) {\\n            ++cnt;\\n            weight += boxes[i][1];\\n            if (i == start) {\\n                trips += 1;\\n            } else if (boxes[i][0] != boxes[i - 1][0]) {\\n                trips +=1;\\n            }\\n            ++i;\\n        }\\n        return make_pair(i, trips);\\n    }\\n    \\n    // Subroutine to count number of ships needed to deliver consequtive boxes to the same port\\n    int same_port_deliver(vector<vector<int>>& boxes, int start, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n        \\n        int ships(1);\\n        int cnt(0);\\n        int weight(0);\\n        int i(start);\\n        while ((i != n) and (boxes[i][0] == boxes[start][0])) {\\n        \\n            if ((cnt == maxBoxes) or (weight + boxes[i][1] > maxWeight)) {\\n                ++ships;\\n                cnt = 1;\\n                weight = boxes[i][1]; \\n            } else {\\n                ++cnt;\\n                weight += boxes[i][1];\\n            }\\n            ++i;\\n        }\\n        return ships;\\n    }\\n    \\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        \\n        int n = boxes.size();\\n        int start = 0;\\n        int trips = 0;\\n        \\n        while (start != n) {\\n            pair<int, int> a = try_deliver(boxes, start, maxBoxes, maxWeight);    \\n            \\n            if ((a.first != n) and \\n                (boxes[a.first][0] == boxes[a.first - 1][0]) and \\n                (boxes[a.first][0] != boxes[start][0])) {\\n                \\n                // check two options;\\n                int last_port(boxes[a.first][0]);\\n                int first(a.first);\\n                while (boxes[first][0] == last_port) --first;\\n                ++first;\\n                \\n                // option 1 - start = a.first\\n                int n1 = same_port_deliver(boxes, a.first, maxBoxes, maxWeight);\\n                \\n                // option 2 - start = first\\n                int n2 = same_port_deliver(boxes, first, maxBoxes, maxWeight);\\n                \\n                if (n1 == n2) {\\n                    start = first;\\n                    trips += a.second - 1;\\n                    continue;\\n                }\\n            } \\n            \\n            trips += a.second;\\n            start = a.first;\\n        }\\n        \\n        return trips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363747,
                "title": "dynamic-programming-with-moving-window",
                "content": "# Intuition\\n\\nThis problem can almost be solved by a greedy approach. If we didnt have equal ports side by side the solution would be to allrays aim for the biggest window possible.\\n- This is because going back to storage without need would cause 1 extra trip that is not needed if you go directly without the storage.\\n\\nNow having a sequence of same ports breaks that logic as they have trip cost 0, so it is better to choose a smaller window that doesnt contain the sequence than one that interrupts the sequence.\\n\\nThis can easely be proven:\\n- If your window doesnt break a sequence the calculation is `memo[left-1]+1+trips`. and breaking in a further point will result in `memo[left-1+x]+trips-x+2`, but `memo[left-1+x]>=memo[left-1]+x` because we may have had breaks between `left-1+x` and `left-1`\\n- If your window breaks a sequence the calculation is `memo[left-1]+1+1+trips` (the plus one appears because the trip between `left-1` and `left` is 0, but breaking now add one trip to storage and one from storage to `left`). And adding a break after the sequence costs `memo[left-1+x]-x+1+1+trips` and as there is no extra cost between sequence of ports `memo[left-1+x]=memo[left-1]` and `x=0` then `memo[left-1+x]-x+1+1+trips=memo[left-1]+1+1+trips`, with the advantage that we can go further to the right.\\n\\n# Approach\\n- Moving Window\\n- Dynamic Programming\\n\\n# Complexity\\n- Time complexity:\\n$$O(boxes.length)$$\\n\\n- Space complexity:\\n$$O(boxes.length)$$\\n\\n# Code\\n![image.png](https://assets.leetcode.com/users/images/5c1598ad-e602-45a9-a022-13db7bd9f241_1680303070.2349668.png)\\n\\n```java\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        // memo[i] will contain the number of trips to go to port i\\n        int[] memo=new int[boxes.length];\\n        int weight=0, left=0, right=0, lastDiffCity=-1, trips=0;\\n        while(right<boxes.length) {\\n            weight+=boxes[right][1];\\n            // description contstraints\\n            while(weight>maxWeight||right-left+1>maxBoxes||\\n                // if two ports have the same cost to start, be greedy and\\n                // choose the rightmost\\n                (left>0&&left<right&&memo[left]==memo[left-1])) { \\n                // if the city removed had a trip to the next city we must\\n                // remove that trip. That trip is zero if its the same port\\n                if(boxes[left][0]!=boxes[left+1][0]) trips--;\\n                // remove the weight of the removed box\\n                weight-=boxes[left++][1];\\n            }\\n            // lets mark the last diff city we had. If it was not the last one\\n            // it means we have boxes in the same port\\n            if((right==0||boxes[right-1][0]!=boxes[right][0]))\\n                trips++;\\n            // Trips contains the trip from storage to start port, so we\\n            // only need to add one being the trip from the last post to\\n            // storage. If the start node is left the number of trips are\\n            // trips to left-1 + trip to storage + trip from storage to left\\n            // + left to right\\n            memo[right++]=left==0?trips:memo[left-1]+1+trips;\\n        }\\n        // +1 for trip to storage\\n        return memo[memo.length-1]+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        // memo[i] will contain the number of trips to go to port i\\n        int[] memo=new int[boxes.length];\\n        int weight=0, left=0, right=0, lastDiffCity=-1, trips=0;\\n        while(right<boxes.length) {\\n            weight+=boxes[right][1];\\n            // description contstraints\\n            while(weight>maxWeight||right-left+1>maxBoxes||\\n                // if two ports have the same cost to start, be greedy and\\n                // choose the rightmost\\n                (left>0&&left<right&&memo[left]==memo[left-1])) { \\n                // if the city removed had a trip to the next city we must\\n                // remove that trip. That trip is zero if its the same port\\n                if(boxes[left][0]!=boxes[left+1][0]) trips--;\\n                // remove the weight of the removed box\\n                weight-=boxes[left++][1];\\n            }\\n            // lets mark the last diff city we had. If it was not the last one\\n            // it means we have boxes in the same port\\n            if((right==0||boxes[right-1][0]!=boxes[right][0]))\\n                trips++;\\n            // Trips contains the trip from storage to start port, so we\\n            // only need to add one being the trip from the last post to\\n            // storage. If the start node is left the number of trips are\\n            // trips to left-1 + trip to storage + trip from storage to left\\n            // + left to right\\n            memo[right++]=left==0?trips:memo[left-1]+1+trips;\\n        }\\n        // +1 for trip to storage\\n        return memo[memo.length-1]+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2620185,
                "title": "java-solution-easy-to-understand-edge-case-explain",
                "content": "First, to solve this problem, we need to know that the answer to this problem is based on answers to many subproblems. \\n\\nThe subproblem we can refer to is: For ith box, dp[i] is the minimal number of trips needed that the cargo ship delivered 0-i boxes and returned to the storage homeport.\\n\\n\\tSuppose there are k boxes. The answer to the problem can be described as:\\n\\n\\tdp[k] = min(dp[i - 1] + trips needed to deliver box i to box k)\\n\\n\\tIn this equation, box i to box k are on the cargo ship at the same time. \\n\\nBut we need to guarantee that these boxes can be put on the cargo ship at the same time. Which is k - i + 1 <= maxBoxes and prefixWeight[k] - prefixWeight[i - 1] <= maxWeight. From here we can get a window where we store answers to subproblems in order to get answer to the subproblem at a moment when we want to solve it.\\n\\nOnce we get this window, we can utilize the monotonic deque to construct this window. It is a min heap, the peek of heap is the minimal number of trips so far and the box index to it. We can set a data structure to store it like (trips, index) \\n\\nTherefore, the rule to run this deque, also the main loop to our problem to calculate dp[k], is:\\n\\n\\tIterate through boxes, for kth box:\\n\\n\\t1) Keep popping the head of the deque until the index of current deque peek can satisify: k - index <= maxBoxes && prefixWeight[k] - prefixWeight[index] <= maxWeight\\n\\t2) Use the peek to calculate subproblem dp[k]: dp[k] = dp[index] + trips(index, k)\\n\\t3) Update dp[i] with the answer.\\n\\t4) Put dp[i] to deque\\n\\n\\t\\tOne of the edge case that we need to pay attention to is\\n\\t\\tindex: 0,1,2,3,4,5,6,7,8,9\\n\\t\\tports: 2,2,2,2,1,1,1,1,1,1\\n\\n\\t\\twhen we try to solve dp[5], at this moment the deque might be:\\n\\t\\t(trip, index)\\n\\t\\t[(2, 2), (2,3) ..... ]\\n\\n\\t\\tIf we use (2,2), the next box we want to pick up is 3, but it is heading to port 2, so to deliver box 3 to box 5, we need to go to two ports and the trip is 3. But if we pick (2, 3), the next box we want to pick up is 4 and in order to delivery box 4 and box 5 we only need to go to one port so it is 2 trips.\\n\\n\\t\\tHence we want to calculate all dp[i] for all min trips at this moment.\\n\\n\\nTo calculate the trips(index, k) we can also have a prefix array to help us. We can have an array diff that:\\n\\n\\tdiff[i] = 0 if index == 1\\n\\tdiff[i] = diff[i - 1] + 1 if port[i] != port[i - 1]\\n\\tdiff[i] = diff[i - 1] if port[i] == port[i - 1]\\n\\n\\tFor a single period, the ship always need a trip to get to the first port and an additional trip to storage port after we deliver all boxes. So we set first to zero is because we always want to find trip chanegs within a period.\\n\\n\\tFor example, if we have ports of boxes:\\n\\n\\tindex: 0 1 2 3 4 5 6 7 8 9\\n\\tports: 1 2 3 3 4 5 6 6 6 7\\n\\tdiff:  0 1 2 2 3 4 5 5 5 6\\n\\n\\tTo deliver box 0 to box 1, we need 1 + diff[1] - diff[0] + 1 = 3 trips. To deliver box from box 6 to box 8, we need 1 + diff[8] - diff[6] + 1 = 2 trips.\\n\\nFinally we have our solution.\\n\\n```\\nclass Solution {\\n    \\n    class Node {\\n        int trips;\\n        int idx;\\n        Node(int trips, int idx) {\\n            this.trips = trips;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    int maxBoxes;\\n    int maxWeight;\\n    int[] totalWeights;\\n    int[] diffs;\\n    \\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        this.maxBoxes = maxBoxes;\\n        this.maxWeight = maxWeight;\\n        \\n        Queue<Node> queue = new PriorityQueue<>(new Comparator<Node>(){\\n            public int compare(Node n1, Node n2) {\\n                return n1.trips - n2.trips;\\n            }\\n        });\\n        \\n        totalWeights = new int[boxes.length + 1];\\n        diffs = new int[boxes.length + 1];\\n        \\n        diffs[1] = 0;\\n        totalWeights[1] = boxes[0][1];\\n        for (int i = 2; i <= boxes.length; i++) {\\n            totalWeights[i] = boxes[i - 1][1] + totalWeights[i - 1];\\n            if (boxes[i - 1][0] == boxes[i - 2][0]) {\\n                diffs[i] = diffs[i - 1];\\n            } else {\\n                diffs[i] = diffs[i - 1] + 1;\\n            }\\n        }\\n        \\n        int[] dp = new int[boxes.length + 1];\\n        Node zero = new Node(0, 0);\\n        queue.offer(zero);\\n        \\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!queue.isEmpty() && shouldPop(queue.peek(), i)) {\\n                Node n = queue.poll();\\n            }\\n            Queue<Node> temp = new LinkedList<>();\\n            int trips = (i + 2) * 2;\\n            while (!queue.isEmpty() && (temp.isEmpty() || queue.peek().trips == temp.peek().trips)) {\\n                Node peek = queue.poll();\\n                if (!shouldPop(peek, i)) {\\n                    int ntrips = peek.trips + diffs[i] - diffs[peek.idx + 1] + 2;\\n                    trips = Math.min(trips, ntrips);\\n                    temp.offer(peek);\\n                }\\n            }\\n            \\n            dp[i] = trips;\\n            queue.offer(new Node(trips, i));\\n            while (!temp.isEmpty()) {\\n                queue.offer(temp.poll());\\n            }\\n        }\\n        \\n        return dp[boxes.length];\\n    }\\n    \\n    public boolean shouldPop(Node n, int idx) {\\n        int numOfBoxes = idx - n.idx;\\n        int weight = totalWeights[idx] - totalWeights[n.idx];\\n        return weight > maxWeight || numOfBoxes > maxBoxes;\\n    }\\n}\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Heap (Priority Queue)",
                    "Prefix Sum",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class Node {\\n        int trips;\\n        int idx;\\n        Node(int trips, int idx) {\\n            this.trips = trips;\\n            this.idx = idx;\\n        }\\n    }\\n    \\n    int maxBoxes;\\n    int maxWeight;\\n    int[] totalWeights;\\n    int[] diffs;\\n    \\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        this.maxBoxes = maxBoxes;\\n        this.maxWeight = maxWeight;\\n        \\n        Queue<Node> queue = new PriorityQueue<>(new Comparator<Node>(){\\n            public int compare(Node n1, Node n2) {\\n                return n1.trips - n2.trips;\\n            }\\n        });\\n        \\n        totalWeights = new int[boxes.length + 1];\\n        diffs = new int[boxes.length + 1];\\n        \\n        diffs[1] = 0;\\n        totalWeights[1] = boxes[0][1];\\n        for (int i = 2; i <= boxes.length; i++) {\\n            totalWeights[i] = boxes[i - 1][1] + totalWeights[i - 1];\\n            if (boxes[i - 1][0] == boxes[i - 2][0]) {\\n                diffs[i] = diffs[i - 1];\\n            } else {\\n                diffs[i] = diffs[i - 1] + 1;\\n            }\\n        }\\n        \\n        int[] dp = new int[boxes.length + 1];\\n        Node zero = new Node(0, 0);\\n        queue.offer(zero);\\n        \\n        for (int i = 1; i <= boxes.length; i++) {\\n            while (!queue.isEmpty() && shouldPop(queue.peek(), i)) {\\n                Node n = queue.poll();\\n            }\\n            Queue<Node> temp = new LinkedList<>();\\n            int trips = (i + 2) * 2;\\n            while (!queue.isEmpty() && (temp.isEmpty() || queue.peek().trips == temp.peek().trips)) {\\n                Node peek = queue.poll();\\n                if (!shouldPop(peek, i)) {\\n                    int ntrips = peek.trips + diffs[i] - diffs[peek.idx + 1] + 2;\\n                    trips = Math.min(trips, ntrips);\\n                    temp.offer(peek);\\n                }\\n            }\\n            \\n            dp[i] = trips;\\n            queue.offer(new Node(trips, i));\\n            while (!temp.isEmpty()) {\\n                queue.offer(temp.poll());\\n            }\\n        }\\n        \\n        return dp[boxes.length];\\n    }\\n    \\n    public boolean shouldPop(Node n, int idx) {\\n        int numOfBoxes = idx - n.idx;\\n        int weight = totalWeights[idx] - totalWeights[n.idx];\\n        return weight > maxWeight || numOfBoxes > maxBoxes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2149981,
                "title": "javascript-dp-sliding-window",
                "content": "```\\n/**\\n * @param {number[][]} boxes\\n * @param {number} portsCount\\n * @param {number} maxBoxes\\n * @param {number} maxWeight\\n * @return {number}\\n */\\nvar boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\\n    \\n    const trips = Array(boxes.length + 1).fill(0);\\n    let left = 0;\\n    let diff = 0;\\n    \\n    for (let right = 0; right < boxes.length; right++) {\\n        maxBoxes--;\\n        maxWeight -= boxes[right][1];\\n        if (right > 0 && boxes[right][0] !== boxes[right - 1][0]) diff++;\\n        \\n        while (maxBoxes < 0 || maxWeight < 0 || (left < right && trips[left + 1] === trips[left])) {\\n            maxBoxes++;\\n            maxWeight += boxes[left++][1];\\n            if (boxes[left][0] !== boxes[left - 1][0]) diff--;\\n        }\\n        \\n        trips[right + 1] = diff + 2 + trips[left];\\n    }\\n    \\n    return trips[boxes.length];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[][]} boxes\\n * @param {number} portsCount\\n * @param {number} maxBoxes\\n * @param {number} maxWeight\\n * @return {number}\\n */\\nvar boxDelivering = function(boxes, portsCount, maxBoxes, maxWeight) {\\n    \\n    const trips = Array(boxes.length + 1).fill(0);\\n    let left = 0;\\n    let diff = 0;\\n    \\n    for (let right = 0; right < boxes.length; right++) {\\n        maxBoxes--;\\n        maxWeight -= boxes[right][1];\\n        if (right > 0 && boxes[right][0] !== boxes[right - 1][0]) diff++;\\n        \\n        while (maxBoxes < 0 || maxWeight < 0 || (left < right && trips[left + 1] === trips[left])) {\\n            maxBoxes++;\\n            maxWeight += boxes[left++][1];\\n            if (boxes[left][0] !== boxes[left - 1][0]) diff--;\\n        }\\n        \\n        trips[right + 1] = diff + 2 + trips[left];\\n    }\\n    \\n    return trips[boxes.length];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2117792,
                "title": "dp-two-pointer-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& a, int portsCount, int mxb, int mxw) \\n    {\\n        int n=a.size();\\n        bool add[n+5]; memset(add,0,sizeof(add));\\n        for(int i=0;i<n-1;i++)\\n            if(a[i][0]!=a[i+1][0])\\n                add[i]=1;\\n        \\n        int w=0,j=0,trip=0,dp[n+5]; memset(dp,0,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            w+=a[i][1];\\n            if(i) trip+=add[i-1];\\n            \\n            while(i-j>=mxb)\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            while(w>mxw)\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            while(j<i && dp[j]==dp[j+1])\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            dp[i+1]=dp[j]+trip+2;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& a, int portsCount, int mxb, int mxw) \\n    {\\n        int n=a.size();\\n        bool add[n+5]; memset(add,0,sizeof(add));\\n        for(int i=0;i<n-1;i++)\\n            if(a[i][0]!=a[i+1][0])\\n                add[i]=1;\\n        \\n        int w=0,j=0,trip=0,dp[n+5]; memset(dp,0,sizeof(dp));\\n        for(int i=0;i<n;i++)\\n        {\\n            w+=a[i][1];\\n            if(i) trip+=add[i-1];\\n            \\n            while(i-j>=mxb)\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            while(w>mxw)\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            while(j<i && dp[j]==dp[j+1])\\n                w-=a[j][1],trip-=add[j],j++;\\n            \\n            dp[i+1]=dp[j]+trip+2;\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567706,
                "title": "java-solution-with-explanation-dp-greedy-sliding-window",
                "content": "```\\nclass Solution {\\n    /**\\n    1. [a ,  b, c,  d,  e,  f]\\n           left=1       right=4\\n        0    1   2   3   4   5\\n    2. So, min. trips upto right = min trips upto left + trips need from left to right \\n    3. dp[4] = dp[1] + trips(from 1 to 4)\\n    4. initial left, and right will be 0th index\\n    5. Right will move to capture upto max boxes and max weight.\\n    6. When maxWeight or maxBoxes are achieved then we will shift left toward right, so get boxes within the \\n       constraint, weight < maxWeight, and right - left <= maxBoxes\\n    7. While increase left (means shifting toward right), we will decrease trips\\n        left and left+1 both are NOT same\\n        because we they are same, then no trips will be done/added.\\n    8. Suppose dp[left] === dp[left+1], then left can be shifted to right, because it is not affecting the trips,          and also additional weight will be decrease as we move toward right.\\n    9. We have initialised trip = 2, as every break point, 2 trips will be added for going to storage and coming to        port again.\\n    10. dp[n] will contain min trips needed.\\n    */\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        \\n        int t = 2;\\n        int weight = 0;\\n        \\n        int n = boxes.length;\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        int left = 0;\\n        for(int right = 0; right < boxes.length; right++){\\n            weight += boxes[right][1];\\n            if(right > 0 && boxes[right][0] != boxes[right-1][0]) t++;\\n            \\n            // checking if weight, boxes are less than or equal to max contraint\\n            while(weight > maxWeight || right - left >= maxBoxes || (left < right && dp[left] == dp[left+1])){\\n                weight -= boxes[left][1];\\n                if(boxes[left][0] != boxes[left+1][0]) t--;\\n                left++;\\n            }\\n            // System.out.println(Arrays.toString(dp));\\n            dp[right+1] = dp[left] + t;\\n        }\\n        \\n        System.out.println(Arrays.toString(dp));\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n    1. [a ,  b, c,  d,  e,  f]\\n           left=1       right=4\\n        0    1   2   3   4   5\\n    2. So, min. trips upto right = min trips upto left + trips need from left to right \\n    3. dp[4] = dp[1] + trips(from 1 to 4)\\n    4. initial left, and right will be 0th index\\n    5. Right will move to capture upto max boxes and max weight.\\n    6. When maxWeight or maxBoxes are achieved then we will shift left toward right, so get boxes within the \\n       constraint, weight < maxWeight, and right - left <= maxBoxes\\n    7. While increase left (means shifting toward right), we will decrease trips\\n        left and left+1 both are NOT same\\n        because we they are same, then no trips will be done/added.\\n    8. Suppose dp[left] === dp[left+1], then left can be shifted to right, because it is not affecting the trips,          and also additional weight will be decrease as we move toward right.\\n    9. We have initialised trip = 2, as every break point, 2 trips will be added for going to storage and coming to        port again.\\n    10. dp[n] will contain min trips needed.\\n    */\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        \\n        int t = 2;\\n        int weight = 0;\\n        \\n        int n = boxes.length;\\n        int[] dp = new int[n+1];\\n        dp[0] = 0;\\n        int left = 0;\\n        for(int right = 0; right < boxes.length; right++){\\n            weight += boxes[right][1];\\n            if(right > 0 && boxes[right][0] != boxes[right-1][0]) t++;\\n            \\n            // checking if weight, boxes are less than or equal to max contraint\\n            while(weight > maxWeight || right - left >= maxBoxes || (left < right && dp[left] == dp[left+1])){\\n                weight -= boxes[left][1];\\n                if(boxes[left][0] != boxes[left+1][0]) t--;\\n                left++;\\n            }\\n            // System.out.println(Arrays.toString(dp));\\n            dp[right+1] = dp[left] + t;\\n        }\\n        \\n        System.out.println(Arrays.toString(dp));\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268775,
                "title": "greedy-top-down-dp-easily-understandable",
                "content": "```\\n//Simple greedy solution would not work\\n//For example, boxes = [[2,1],[3,2],[3,5]], maxBoxes = 6, maxWeight = 7\\n//If completely greedy, then we would put [[2,1],[3,2]] on the same boat, [3,5] in the second boat\\n//but, this is not optimal, totally it would cost 3+2 = 5 trips\\n//However, if we put [2,1] on one boat and [[3,2],[3,5]] on the second boat,\\n//then, it only cost 2 + 2 = 4 trips\\n//Hence we are going to do greedy for two possible cases\\n//(1) case 1 : Simple greedy, maximum boxes and maximum weight\\n//(2) case 2 : Stop at the last box with idx where the ports between idx and idx+1 is different,\\n//For example, in the above example, we stop at [2,1] since [2,1] and [3,2] differ in port\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        size = boxes.size();\\n        dp.resize(size, -1);\\n        dfs(boxes, maxBoxes, maxWeight, size-1);\\n        return dp[size-1];\\n    }\\nprivate:\\n    int size;\\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& boxes, int maxBoxes, int maxWeight, int i) {\\n        if(i < 0) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ret = INT_MAX;\\n        int countWeight = 0; int countBox = 0; \\n        int lastPort = -1; int lastPortIdx = -1;\\n        int lastCountTrip = -1;\\n        int countTrip = 1; //1 means the back trip\\n        //transitions records how many transitions before the back trip\\n        int j, transitions = 0;\\n        for(j=i; j>=0; j--) {\\n            countWeight += boxes[j][1]; countBox += 1;\\n            if(countBox > maxBoxes || countWeight > maxWeight) {break;}\\n            if(boxes[j][0] != lastPort){\\n                transitions += 1;\\n                lastPort = boxes[j][0]; lastPortIdx = j;\\n                lastCountTrip = countTrip; countTrip += 1;\\n            }\\n        }\\n        //greedy case 1\\n        ret = min(ret, countTrip + dfs(boxes, maxBoxes, maxWeight, j));\\n        //greedy case 2, if we see number of transitions that is more than 1\\n        if(transitions > 1) {\\n            ret = min(ret, lastCountTrip + dfs(boxes, maxBoxes, maxWeight, lastPortIdx));    \\n        }\\n        \\n        dp[i] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Simple greedy solution would not work\\n//For example, boxes = [[2,1],[3,2],[3,5]], maxBoxes = 6, maxWeight = 7\\n//If completely greedy, then we would put [[2,1],[3,2]] on the same boat, [3,5] in the second boat\\n//but, this is not optimal, totally it would cost 3+2 = 5 trips\\n//However, if we put [2,1] on one boat and [[3,2],[3,5]] on the second boat,\\n//then, it only cost 2 + 2 = 4 trips\\n//Hence we are going to do greedy for two possible cases\\n//(1) case 1 : Simple greedy, maximum boxes and maximum weight\\n//(2) case 2 : Stop at the last box with idx where the ports between idx and idx+1 is different,\\n//For example, in the above example, we stop at [2,1] since [2,1] and [3,2] differ in port\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        size = boxes.size();\\n        dp.resize(size, -1);\\n        dfs(boxes, maxBoxes, maxWeight, size-1);\\n        return dp[size-1];\\n    }\\nprivate:\\n    int size;\\n    vector<int> dp;\\n    int dfs(vector<vector<int>>& boxes, int maxBoxes, int maxWeight, int i) {\\n        if(i < 0) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        int ret = INT_MAX;\\n        int countWeight = 0; int countBox = 0; \\n        int lastPort = -1; int lastPortIdx = -1;\\n        int lastCountTrip = -1;\\n        int countTrip = 1; //1 means the back trip\\n        //transitions records how many transitions before the back trip\\n        int j, transitions = 0;\\n        for(j=i; j>=0; j--) {\\n            countWeight += boxes[j][1]; countBox += 1;\\n            if(countBox > maxBoxes || countWeight > maxWeight) {break;}\\n            if(boxes[j][0] != lastPort){\\n                transitions += 1;\\n                lastPort = boxes[j][0]; lastPortIdx = j;\\n                lastCountTrip = countTrip; countTrip += 1;\\n            }\\n        }\\n        //greedy case 1\\n        ret = min(ret, countTrip + dfs(boxes, maxBoxes, maxWeight, j));\\n        //greedy case 2, if we see number of transitions that is more than 1\\n        if(transitions > 1) {\\n            ret = min(ret, lastCountTrip + dfs(boxes, maxBoxes, maxWeight, lastPortIdx));    \\n        }\\n        \\n        dp[i] = ret;\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237675,
                "title": "c-memoization-greedy-beats-100-time-and-memory",
                "content": "```\\npublic class Solution {\\n    int[] dp ;\\n    int maxBoxes;\\n    int maxWeight;\\n    int n;\\n    public int Deliever(int start, int[][] boxes)\\n    {\\n        if(start==n) return 0;\\n        if(dp[start]!=0) return dp[start];\\n        List<int> ports = new List<int>();\\n        int noOfBoxes = 0;\\n        int weight = 0;\\n        int i=start;\\n        \\n         //fill the ship until maximum limit is reached\\n        while(i<n && noOfBoxes+1<=maxBoxes &&   weight+boxes[i][1]<=maxWeight)\\n        {\\n            noOfBoxes++;\\n            weight+=boxes[i][1];\\n            if(ports.Count()==0 || ports[ports.Count()-1]!=boxes[i][0])\\n            {\\n                ports.Add(boxes[i][0]);\\n            }\\n            i++;\\n            \\n        }\\n        dp[start] = 1 + ports.Count() + Deliever(i,boxes) ;\\n        \\n        //Now check if the ith port(not on ship) is same as imeediate previous box ports(loaded on ship) then try to send the continous same port boxes together or unload them from the ship and load them together with ith box after trip\\n        if(i<n)\\n        {\\n            while(i>start && boxes[i][0]==boxes[i-1][0])\\n            {\\n                if(ports.Count()>0 && ports[ports.Count()-1]==boxes[i][0])\\n                {\\n                    ports.RemoveAt(ports.Count()-1);\\n                }\\n                i--;\\n            }\\n            if(i>start)\\n            {\\n                dp[start] = Math.Min(dp[start],1 + ports.Count() + Deliever(i,boxes) );\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return dp[start] ;\\n    }\\n    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxe, int maxWeigh) {\\n        n = boxes.Count();\\n        maxBoxes = maxBoxe;\\n        maxWeight = maxWeigh;\\n        dp = new int[n];\\n        return Deliever(0,boxes);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] dp ;\\n    int maxBoxes;\\n    int maxWeight;\\n    int n;\\n    public int Deliever(int start, int[][] boxes)\\n    {\\n        if(start==n) return 0;\\n        if(dp[start]!=0) return dp[start];\\n        List<int> ports = new List<int>();\\n        int noOfBoxes = 0;\\n        int weight = 0;\\n        int i=start;\\n        \\n         //fill the ship until maximum limit is reached\\n        while(i<n && noOfBoxes+1<=maxBoxes &&   weight+boxes[i][1]<=maxWeight)\\n        {\\n            noOfBoxes++;\\n            weight+=boxes[i][1];\\n            if(ports.Count()==0 || ports[ports.Count()-1]!=boxes[i][0])\\n            {\\n                ports.Add(boxes[i][0]);\\n            }\\n            i++;\\n            \\n        }\\n        dp[start] = 1 + ports.Count() + Deliever(i,boxes) ;\\n        \\n        //Now check if the ith port(not on ship) is same as imeediate previous box ports(loaded on ship) then try to send the continous same port boxes together or unload them from the ship and load them together with ith box after trip\\n        if(i<n)\\n        {\\n            while(i>start && boxes[i][0]==boxes[i-1][0])\\n            {\\n                if(ports.Count()>0 && ports[ports.Count()-1]==boxes[i][0])\\n                {\\n                    ports.RemoveAt(ports.Count()-1);\\n                }\\n                i--;\\n            }\\n            if(i>start)\\n            {\\n                dp[start] = Math.Min(dp[start],1 + ports.Count() + Deliever(i,boxes) );\\n            }\\n        }\\n        \\n        \\n        \\n        \\n        return dp[start] ;\\n    }\\n    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxe, int maxWeigh) {\\n        n = boxes.Count();\\n        maxBoxes = maxBoxe;\\n        maxWeight = maxWeigh;\\n        dp = new int[n];\\n        return Deliever(0,boxes);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1062442,
                "title": "easy-to-understand-c-o-n-using-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n     \\n        vector<int> dp(boxes.size()+2),dp1(boxes.size()+2);\\n        \\n        for(int i = 2;i <= boxes.size(); i++){\\n            dp1[i] = dp1[i-1];\\n            if(boxes[i-1][0]  != boxes[i-2][0]) dp1[i]++;\\n        }\\n\\n        int weight = 0, j = 1;        \\n        deque<int> dq;\\n        dp[0] = -1;\\n        \\n        for(int i = 1; i <= boxes.size(); i++){\\n            weight += boxes[i-1][1];\\n            \\n            \\n            while(j < i && (weight > maxWeight || (i-j+1) > maxBoxes)){\\n                weight -= boxes[j-1][1];\\n                ++j;\\n            }\\n            \\n            while(!dq.empty() && dq.front() < j) dq.pop_front();\\n            \\n            while(!dq.empty() && dp[dq.back()-1] - dp1[dq.back()] > dp[i-1] - dp1[i]) dq.pop_back();\\n            dq.push_back(i);\\n           \\n            dp[i] = dp1[i] + dp[dq.front()-1] - dp1[dq.front()] + 2;\\n            \\n          }\\n         \\n        return dp[boxes.size()]+1;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n     \\n        vector<int> dp(boxes.size()+2),dp1(boxes.size()+2);\\n        \\n        for(int i = 2;i <= boxes.size(); i++){\\n            dp1[i] = dp1[i-1];\\n            if(boxes[i-1][0]  != boxes[i-2][0]) dp1[i]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1021980,
                "title": "additional-test-case-for-easy-debugging-read-if-test-39-fails",
                "content": "This problem can be solved optimally via a sliding window approach, as explained by others. Something I got stuck on is the optimal unloading of boxes, to me this seems the crux of the problem. Unfortunately for me, my code was wrong only on test case 39 (80000 boxes). I have made a simpler example producing the same error and am posting it here for your convenience:\\n```python\\nboxes = [[1, 2], [3, 2], [3, 1], [3, 2], [5, 4]]\\nportsCount = 6\\nmaxBoxes = 5\\nmaxWeight = 4\\n\\nExpected result: 7\\n```\\n\\nIn case it helps, I am stating my wrong delivery logic (this is not a full tutorial, have a look at other posts for that):\\n1. Fill the boat (= sliding window) with boxes until at least one of it\\'s capacities (maxBoxes or maxWeight) is reached --> the next box does not fit anymore\\n2. Make the smallest possible delivery to make the next box fit. This delivery is as small as possible for maximum flexibiliy: it is cheaper to transport the current box together with other boxes on the ship (extra cost 0 if the port is the same as the current last box on the ship, else extra cost of 1) than to start an additional delivery for this box (cost of 2).\\n3. Assume I needed to deliver __x__ boxes to make room for the next box, then I would deliver all consecutive boxes after the __xth__ box that needed to be delivered to the same port as __x__.\\n\\nPoint 3 above makes a mistake: it assumes that, just because two consecutive boxes are delivered to the same port, it will always be cheapest to also deliver them together. This is untrue, as you\\'ll see if you go through the example given above.\\nConcretely: It may be cheaper to split a consecutive series of boxes delivered to the same port. If it is cheapest to deliver them together, then their delivery price will be exactly the same (as there is no extra cost for dropping additional boxes on a port the ship is alrady at).\\nTherefore, we only deliver more boxes than necessary (more than __x__ in the rules above) if the additinal delivery is completely free, i.e. dp[x] == dp[x + 1].\\n\\nCorrect code, explicitly implementing what I outlined above in a separate (the second) while loop:\\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        left = 0  # idx of the box to be delivered first during the next run -> left idx in sliding window\\n        ports_on_route = 0\\n        weight_on_ship = 0\\n        dp = [0]\\n        for right in range(len(boxes)):\\n            while weight_on_ship + boxes[right][1] > maxWeight or right - left == maxBoxes:\\n                # ship is full --> deliver boxes until there is enough space for the new box\\n                weight_on_ship -= boxes[left][1]\\n                ports_on_route -= boxes[left][0] != boxes[left + 1][0]\\n                left += 1\\n                \\n            while left < right and dp[left] == dp[left + 1]:\\n\\t\\t\\t    # if some additional boxes can be delivered for free, deliver them as well\\n\\t\\t\\t    # (there can\\'t be a cheaper than free deliveray, plus we clear additional space on the boat)\\n                weight_on_ship -= boxes[left][1]\\n                ports_on_route -= boxes[left][0] != boxes[left + 1][0]\\n                left += 1\\n\\n            # load next box\\n            weight_on_ship += boxes[right][1]\\n            if right == 0 or boxes[right - 1][0] != boxes[right][0]:\\n                ports_on_route += 1\\n            dp.append(dp[left] + ports_on_route + 1)\\n            \\n        return dp[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nboxes = [[1, 2], [3, 2], [3, 1], [3, 2], [5, 4]]\\nportsCount = 6\\nmaxBoxes = 5\\nmaxWeight = 4\\n\\nExpected result: 7\\n```\n```python\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        left = 0  # idx of the box to be delivered first during the next run -> left idx in sliding window\\n        ports_on_route = 0\\n        weight_on_ship = 0\\n        dp = [0]\\n        for right in range(len(boxes)):\\n            while weight_on_ship + boxes[right][1] > maxWeight or right - left == maxBoxes:\\n                # ship is full --> deliver boxes until there is enough space for the new box\\n                weight_on_ship -= boxes[left][1]\\n                ports_on_route -= boxes[left][0] != boxes[left + 1][0]\\n                left += 1\\n                \\n            while left < right and dp[left] == dp[left + 1]:\\n\\t\\t\\t    # if some additional boxes can be delivered for free, deliver them as well\\n\\t\\t\\t    # (there can\\'t be a cheaper than free deliveray, plus we clear additional space on the boat)\\n                weight_on_ship -= boxes[left][1]\\n                ports_on_route -= boxes[left][0] != boxes[left + 1][0]\\n                left += 1\\n\\n            # load next box\\n            weight_on_ship += boxes[right][1]\\n            if right == 0 or boxes[right - 1][0] != boxes[right][0]:\\n                ports_on_route += 1\\n            dp.append(dp[left] + ports_on_route + 1)\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977657,
                "title": "c-topdown-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int i, vector<vector<int> >&boxes, vector<int>&dp, int mb, int mw) {\\n        if(i >= boxes.size())\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int j = i;\\n        int c = 0, w = 0; \\n        dp[i] = INT_MAX;\\n        vector<int> v;\\n        \\n        while((j < boxes.size()) && ((c+1) <= mb) && ((w + boxes[j][1]) <= mw)) {\\n            if(v.size() == 0 || v[v.size()-1] != boxes[j][0])\\n                v.push_back(boxes[j][0]);\\n \\n            w = w + boxes[j][1];\\n            j ++;\\n            c ++;\\n        }\\n        dp[i] = min(dp[i], 1 + (int)v.size() + find(j, boxes, dp, mb, mw));\\n        \\n        if(j != boxes.size()) {\\n            while(j>i && boxes[j][0] == boxes[j-1][0]) {\\n                if(v.size() > 0 && v[v.size()-1] == boxes[j][0])\\n                    v.pop_back();\\n                j--;\\n            }\\n            if(j > i)\\n                dp[i] = min(dp[i], 1 + (int)v.size() + find(j, boxes, dp, mb, mw));\\n        }        \\n        \\n        return dp[i];\\n    }\\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> dp(boxes.size(), -1);\\n        return find(0, boxes, dp, maxBoxes, maxWeight);\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int find(int i, vector<vector<int> >&boxes, vector<int>&dp, int mb, int mw) {\\n        if(i >= boxes.size())\\n            return 0;\\n        if(dp[i] != -1)\\n            return dp[i];\\n        \\n        int j = i;\\n        int c = 0, w = 0; \\n        dp[i] = INT_MAX;\\n        vector<int> v;\\n        \\n        while((j < boxes.size()) && ((c+1) <= mb) && ((w + boxes[j][1]) <= mw)) {\\n            if(v.size() == 0 || v[v.size()-1] != boxes[j][0])\\n                v.push_back(boxes[j][0]);\\n \\n            w = w + boxes[j][1];\\n            j ++;\\n            c ++;\\n        }\\n        dp[i] = min(dp[i], 1 + (int)v.size() + find(j, boxes, dp, mb, mw));\\n        \\n        if(j != boxes.size()) {\\n            while(j>i && boxes[j][0] == boxes[j-1][0]) {\\n                if(v.size() > 0 && v[v.size()-1] == boxes[j][0])\\n                    v.pop_back();\\n                j--;\\n            }\\n            if(j > i)\\n                dp[i] = min(dp[i], 1 + (int)v.size() + find(j, boxes, dp, mb, mw));\\n        }        \\n        \\n        return dp[i];\\n    }\\n    \\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<int> dp(boxes.size(), -1);\\n        return find(0, boxes, dp, maxBoxes, maxWeight);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971848,
                "title": "python-dp-short-solution-o-n-with-explanation",
                "content": "Instead of **splitting whenever could** thinking, we need to think it in **spliting only when have to**. The goal is to keep the optimal last portion in hold while refering/connecting to the best solution for the portion results calculated.\\nWhen we see the need for restricting each portion while trying to achieve best accumulated result, **sliding window** is a good way to go.\\n```\\n        dp = [0]*(len(boxes)+1)\\n        # step: steps for the holded portion, w: weight in hold, s: size in hold, i: end position for the last split, j: end position in hold\\n        step, s, i, w = 2, 0, -1, 0\\n        for j in xrange(len(boxes)): \\n            # split trip when have to, but always only hold minimun boxes that not escalating steps\\n            while (w+boxes[j][1] > maxWeight or s+1 > maxBoxes) or (i < j-1 and dp[i] == dp[i+1]):\\n                s, i, w = s-1, i+1, w-boxes[i+1][1] # i updated to the new end from here\\n                # on spliting, if the splitted 2 are different ports, we can save one step that is holding\\n\\t\\t\\t\\t# (eg. 2 boxes needed to go to 2 ports so the holded steps is 3, but after spliting from the first box, for the holded portion, we only need to go to 1 port which takes 2 steps)\\n                step -= 1 if boxes[i][0] != boxes[i+1][0] else 0\\n            \\n            w, s = w+boxes[j][1], s+1\\n            # different ports add 1 step (eg. only 1 port in hold needs 2 steps, but 2 ports need 3)\\n            step += 1 if j > 0 and boxes[j][0] != boxes[j-1][0] else 0\\n            dp[j] = dp[i]+step\\n        return dp[-2]\\n```",
                "solutionTags": [],
                "code": "```\\n        dp = [0]*(len(boxes)+1)\\n        # step: steps for the holded portion, w: weight in hold, s: size in hold, i: end position for the last split, j: end position in hold\\n        step, s, i, w = 2, 0, -1, 0\\n        for j in xrange(len(boxes)): \\n            # split trip when have to, but always only hold minimun boxes that not escalating steps\\n            while (w+boxes[j][1] > maxWeight or s+1 > maxBoxes) or (i < j-1 and dp[i] == dp[i+1]):\\n                s, i, w = s-1, i+1, w-boxes[i+1][1] # i updated to the new end from here\\n                # on spliting, if the splitted 2 are different ports, we can save one step that is holding\\n\\t\\t\\t\\t# (eg. 2 boxes needed to go to 2 ports so the holded steps is 3, but after spliting from the first box, for the holded portion, we only need to go to 1 port which takes 2 steps)\\n                step -= 1 if boxes[i][0] != boxes[i+1][0] else 0\\n            \\n            w, s = w+boxes[j][1], s+1\\n            # different ports add 1 step (eg. only 1 port in hold needs 2 steps, but 2 ports need 3)\\n            step += 1 if j > 0 and boxes[j][0] != boxes[j-1][0] else 0\\n            dp[j] = dp[i]+step\\n        return dp[-2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970741,
                "title": "java-o-nlog-n-dp-binary-search-without-monotonic-queue",
                "content": "Sorry for hard-reading code.\\nBase idea is similar with  Monotonic Queue. But this solution uses Binary Search to find the best start point.\\nI know it is not a good enouth solution. Just just for your reference.\\n```\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int len = boxes.length;\\n\\n        int[] dp = new int[len];\\n        int[] diff = new int[len];\\n\\n        int[] W = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (i == 0)\\n                W[i] = boxes[i][1];\\n            else {\\n                W[i] = W[i - 1] + boxes[i][1];\\n            }\\n\\n            if (i == 0)\\n                diff[i] = 1;\\n            else {\\n                if (boxes[i][0] != boxes[i - 1][0])\\n                    diff[i] = diff[i - 1] + 1;\\n                else {\\n                    diff[i] = diff[i - 1];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                dp[i] = 2;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n\\n                int left = 0;\\n                int right = i;\\n                int finalMid = -1;\\n                while (left <= right) {\\n                    int mid = (left + right) / 2;\\n                    int sumW = 0;\\n                    if (mid == 0) {\\n                        sumW = W[i];\\n                    } else {\\n                        sumW = W[i] - W[mid - 1];\\n                    }\\n                    int sumCount = i - mid + 1;\\n                    if (sumCount <= maxBoxes && sumW <= maxWeight) {\\n                        int cost = 2 + (diff[i] - diff[mid] + 1) - 1;\\n\\n                        if (mid - 1 < 0) {\\n                            dp[i] = Math.min(dp[i], cost);\\n                        } else {\\n                            dp[i] = Math.min(dp[i], dp[mid - 1] + cost);\\n                        }\\n                        finalMid = mid;\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n\\n                }\\n\\n                while (finalMid != 0 && boxes[finalMid][0] == boxes[finalMid - 1][0] && finalMid < i) {\\n                    finalMid++;\\n                    int cost = 2 + (diff[i] - diff[finalMid] + 1) - 1;\\n                    dp[i] = Math.min(dp[i], dp[finalMid - 1] + cost);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return dp[len - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int len = boxes.length;\\n\\n        int[] dp = new int[len];\\n        int[] diff = new int[len];\\n\\n        int[] W = new int[len];\\n        for (int i = 0; i < len; i++) {\\n            if (i == 0)\\n                W[i] = boxes[i][1];\\n            else {\\n                W[i] = W[i - 1] + boxes[i][1];\\n            }\\n\\n            if (i == 0)\\n                diff[i] = 1;\\n            else {\\n                if (boxes[i][0] != boxes[i - 1][0])\\n                    diff[i] = diff[i - 1] + 1;\\n                else {\\n                    diff[i] = diff[i - 1];\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < len; i++) {\\n            if (i == 0) {\\n                dp[i] = 2;\\n            } else {\\n                dp[i] = dp[i - 1] + 2;\\n\\n                int left = 0;\\n                int right = i;\\n                int finalMid = -1;\\n                while (left <= right) {\\n                    int mid = (left + right) / 2;\\n                    int sumW = 0;\\n                    if (mid == 0) {\\n                        sumW = W[i];\\n                    } else {\\n                        sumW = W[i] - W[mid - 1];\\n                    }\\n                    int sumCount = i - mid + 1;\\n                    if (sumCount <= maxBoxes && sumW <= maxWeight) {\\n                        int cost = 2 + (diff[i] - diff[mid] + 1) - 1;\\n\\n                        if (mid - 1 < 0) {\\n                            dp[i] = Math.min(dp[i], cost);\\n                        } else {\\n                            dp[i] = Math.min(dp[i], dp[mid - 1] + cost);\\n                        }\\n                        finalMid = mid;\\n                        right = mid - 1;\\n                    } else {\\n                        left = mid + 1;\\n                    }\\n\\n                }\\n\\n                while (finalMid != 0 && boxes[finalMid][0] == boxes[finalMid - 1][0] && finalMid < i) {\\n                    finalMid++;\\n                    int cost = 2 + (diff[i] - diff[finalMid] + 1) - 1;\\n                    dp[i] = Math.min(dp[i], dp[finalMid - 1] + cost);\\n                }\\n\\n            }\\n\\n        }\\n\\n        return dp[len - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970072,
                "title": "java-heap-solution",
                "content": "```\\nclass Solution {\\n    public int boxDelivering(int[][] A, int portsCount, int maxBoxes, int maxWeight) {\\n        Set<Integer>set=new HashSet<>();\\n        Queue<int[]>q=new LinkedList<>();\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->{\\n            return (a[1]+a[2])-(b[1]+b[2]);\\n        });\\n        \\n        int dp[]=new int[A.length];\\n        int d[]=new int[A.length];\\n        int sum=0;\\n        int p=-1;\\n        int deliver=0;\\n        \\n        for(int i=0;i<A.length;i++){\\n            if(A[i][0]!=p){\\n                deliver++;\\n                p=A[i][0];\\n            }\\n        }\\n        \\n        d[0]=deliver;//deliver time to end from index i\\n        for(int i=1;i<A.length;i++){\\n            if(A[i][0]==A[i-1][0]){\\n                d[i]=d[i-1];\\n            }\\n            else{\\n                if(i!=0)d[i]=d[i-1]-1;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            set.add(i);\\n            sum+=A[i][1];\\n            q.add(new int[]{A[i][0],A[i][1],i});\\n            \\n            while(q.size()>maxBoxes||sum>maxWeight){\\n                int top[]=q.poll();\\n                sum-=top[1];\\n                set.remove(top[2]);\\n            }\\n            \\n            while(pq.size()>0&&(!set.contains(pq.peek()[0])))pq.poll();\\n            \\n            \\n            //take all\\n            int dis1=get1(d,i-q.size()+1)-get1(d,i+1)+get1(dp,i-q.size());\\n            if(A[i][0]==get(A,i+1))dis1++;\\n            dp[i]=1+dis1;\\n            \\n            \\n            dp[i]=Math.min(dp[i],2+get1(dp,i-1));//take only one\\n            \\n            if(pq.size()>0){\\n                int peek[]=pq.peek();\\n                int dis2=d[peek[0]]-get1(d,i+1)+peek[1];\\n                if(A[i][0]==get(A,i+1))dis2++;\\n                dp[i]=Math.min(1+dis2,dp[i]);\\n            }\\n            pq.add(new int[]{i,get1(dp,i-1),d[i]});\\n            \\n            \\n        }\\n        return dp[A.length-1];\\n    }\\n    \\n    public int get(int A[][],int i){//port\\n        if(i>=A.length||i<0)return -1;\\n        return A[i][0];\\n    }\\n    \\n    public int get1(int A[],int i){\\n        if(i>=A.length||i<0)return 0;\\n        return A[i];\\n    }\\n}\\n\\n//2 2 3 3 3 3 4 1 5\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int boxDelivering(int[][] A, int portsCount, int maxBoxes, int maxWeight) {\\n        Set<Integer>set=new HashSet<>();\\n        Queue<int[]>q=new LinkedList<>();\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a,b)->{\\n            return (a[1]+a[2])-(b[1]+b[2]);\\n        });\\n        \\n        int dp[]=new int[A.length];\\n        int d[]=new int[A.length];\\n        int sum=0;\\n        int p=-1;\\n        int deliver=0;\\n        \\n        for(int i=0;i<A.length;i++){\\n            if(A[i][0]!=p){\\n                deliver++;\\n                p=A[i][0];\\n            }\\n        }\\n        \\n        d[0]=deliver;//deliver time to end from index i\\n        for(int i=1;i<A.length;i++){\\n            if(A[i][0]==A[i-1][0]){\\n                d[i]=d[i-1];\\n            }\\n            else{\\n                if(i!=0)d[i]=d[i-1]-1;\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<A.length;i++){\\n            set.add(i);\\n            sum+=A[i][1];\\n            q.add(new int[]{A[i][0],A[i][1],i});\\n            \\n            while(q.size()>maxBoxes||sum>maxWeight){\\n                int top[]=q.poll();\\n                sum-=top[1];\\n                set.remove(top[2]);\\n            }\\n            \\n            while(pq.size()>0&&(!set.contains(pq.peek()[0])))pq.poll();\\n            \\n            \\n            //take all\\n            int dis1=get1(d,i-q.size()+1)-get1(d,i+1)+get1(dp,i-q.size());\\n            if(A[i][0]==get(A,i+1))dis1++;\\n            dp[i]=1+dis1;\\n            \\n            \\n            dp[i]=Math.min(dp[i],2+get1(dp,i-1));//take only one\\n            \\n            if(pq.size()>0){\\n                int peek[]=pq.peek();\\n                int dis2=d[peek[0]]-get1(d,i+1)+peek[1];\\n                if(A[i][0]==get(A,i+1))dis2++;\\n                dp[i]=Math.min(1+dis2,dp[i]);\\n            }\\n            pq.add(new int[]{i,get1(dp,i-1),d[i]});\\n            \\n            \\n        }\\n        return dp[A.length-1];\\n    }\\n    \\n    public int get(int A[][],int i){//port\\n        if(i>=A.length||i<0)return -1;\\n        return A[i][0];\\n    }\\n    \\n    public int get1(int A[],int i){\\n        if(i>=A.length||i<0)return 0;\\n        return A[i];\\n    }\\n}\\n\\n//2 2 3 3 3 3 4 1 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969749,
                "title": "accepted-c-dp-solution-with-sorted-dictionary",
                "content": "```\\n      public class Solution\\n    {\\n\\n        public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight)\\n        {\\n            int[] dp = new int[boxes.Length];\\n            int right = boxes.Length - 1;\\n            int lastPort = -1;\\n            int[] diff = new int[boxes.Length];\\n            for (int i = 0; i < boxes.Length; i++)\\n            {\\n                if (i == 0)\\n                {\\n                    lastPort = boxes[i][0];\\n                }\\n                else\\n                {\\n                    if (lastPort != boxes[i][0])\\n                    {\\n                        lastPort = boxes[i][0];\\n                        diff[i] = diff[i - 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        diff[i] = diff[i - 1];\\n                    }\\n                }\\n            }\\n\\n            SortedDictionary<int, int> map = new SortedDictionary<int, int>();\\n            int bc = 0;\\n            int bw = 0;\\n\\n            for (int left = boxes.Length - 1 ; left >= 0; left--)\\n            {\\n\\n                bc++;\\n                bw += boxes[left][1];\\n\\n                var newSum = diff[left] + ((left == boxes.Length - 1) ? 1 : dp[left + 1] + 2);\\n                if (!map.ContainsKey(newSum))\\n                {\\n                    map[newSum] = 0;\\n                }\\n                map[newSum]++;\\n\\n                while (bw > maxWeight || bc > maxBoxes)\\n                {\\n                    bc--;\\n                    bw -= boxes[right][1];\\n\\n                    int remains = (right == boxes.Length - 1 ? 1 : dp[right + 1] + 2);\\n                    int curr = diff[right];\\n                    int sum = curr + remains;\\n                    map[sum]--;\\n                    if (map[sum] == 0)\\n                    {\\n                        map.Remove(sum);\\n                    }\\n\\n                    right--;\\n                }\\n\\n                dp[left] = map.First().Key - diff[left];\\n            }\\n\\n            return dp[0] + 1;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n      public class Solution\\n    {\\n\\n        public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight)\\n        {\\n            int[] dp = new int[boxes.Length];\\n            int right = boxes.Length - 1;\\n            int lastPort = -1;\\n            int[] diff = new int[boxes.Length];\\n            for (int i = 0; i < boxes.Length; i++)\\n            {\\n                if (i == 0)\\n                {\\n                    lastPort = boxes[i][0];\\n                }\\n                else\\n                {\\n                    if (lastPort != boxes[i][0])\\n                    {\\n                        lastPort = boxes[i][0];\\n                        diff[i] = diff[i - 1] + 1;\\n                    }\\n                    else\\n                    {\\n                        diff[i] = diff[i - 1];\\n                    }\\n                }\\n            }\\n\\n            SortedDictionary<int, int> map = new SortedDictionary<int, int>();\\n            int bc = 0;\\n            int bw = 0;\\n\\n            for (int left = boxes.Length - 1 ; left >= 0; left--)\\n            {\\n\\n                bc++;\\n                bw += boxes[left][1];\\n\\n                var newSum = diff[left] + ((left == boxes.Length - 1) ? 1 : dp[left + 1] + 2);\\n                if (!map.ContainsKey(newSum))\\n                {\\n                    map[newSum] = 0;\\n                }\\n                map[newSum]++;\\n\\n                while (bw > maxWeight || bc > maxBoxes)\\n                {\\n                    bc--;\\n                    bw -= boxes[right][1];\\n\\n                    int remains = (right == boxes.Length - 1 ? 1 : dp[right + 1] + 2);\\n                    int curr = diff[right];\\n                    int sum = curr + remains;\\n                    map[sum]--;\\n                    if (map[sum] == 0)\\n                    {\\n                        map.Remove(sum);\\n                    }\\n\\n                    right--;\\n                }\\n\\n                dp[left] = map.First().Key - diff[left];\\n            }\\n\\n            return dp[0] + 1;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043083,
                "title": "clean-simple-dp-with-multiset",
                "content": "solution was easy to come with but very hard to impliment correctly, implementing this in interview is challenging for anyone\\n```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n=boxes.size();\\n        map<int,int> dp;\\n        dp[-1]=0;\\n        multiset<int> s;\\n        vector<int> distinct={0};\\n        int wt=boxes[0][1];\\n        s.insert(dp[-1]-0);\\n        dp[0]=2;\\n        int l=0;\\n        for(int r=1;r<n;r++){\\n            distinct.push_back(\\n                (boxes[r][0]!=boxes[r-1][0])+distinct.back());\\n            wt+=boxes[r][1];\\n            while(wt>maxWeight or r-l+1>maxBoxes){\\n                s.erase(s.find(dp[l-1]-distinct[l]));\\n                wt-=boxes[l][1];\\n                l++;\\n                assert(l<=r);\\n            }\\n            s.insert(dp[r-1]-distinct[r]);\\n            dp[r]=*s.begin()+distinct.back()+2;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n=boxes.size();\\n        map<int,int> dp;\\n        dp[-1]=0;\\n        multiset<int> s;\\n        vector<int> distinct={0};\\n        int wt=boxes[0][1];\\n        s.insert(dp[-1]-0);\\n        dp[0]=2;\\n        int l=0;\\n        for(int r=1;r<n;r++){\\n            distinct.push_back(\\n                (boxes[r][0]!=boxes[r-1][0])+distinct.back());\\n            wt+=boxes[r][1];\\n            while(wt>maxWeight or r-l+1>maxBoxes){\\n                s.erase(s.find(dp[l-1]-distinct[l]));\\n                wt-=boxes[l][1];\\n                l++;\\n                assert(l<=r);\\n            }\\n            s.insert(dp[r-1]-distinct[r]);\\n            dp[r]=*s.begin()+distinct.back()+2;\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945417,
                "title": "simple-efficient-clean-code",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int pc, int mb, int mw) {\\n        int n = boxes.size();\\n        vector<int>dp(n, INT_MAX); // dp[i] = min trips required to deliver boxes [0, i]\\n        int cw=0, cb=0; // current ship weight & trips required for current window boxes\\n        for(int i=0, j=0; i<n; ++i){\\n            cw += boxes[i][1];\\n            cb += !(j<i && boxes[i-1][0]==boxes[i][0]); // could possibly be clubbed together with the previous box\\n            while(j<i && (cw>mw || i-j+1>mb || (j && dp[j]<=dp[j-1]))){\\n                cw-=boxes[j][1];\\n                cb-=boxes[j][0]!=boxes[j+1][0];\\n                ++j;\\n            }\\n            dp[i] = (j ? dp[j-1] : 0) + cb + 1; // deliver cb boxes + 1 return trip + cost from behind j\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int pc, int mb, int mw) {\\n        int n = boxes.size();\\n        vector<int>dp(n, INT_MAX); // dp[i] = min trips required to deliver boxes [0, i]\\n        int cw=0, cb=0; // current ship weight & trips required for current window boxes\\n        for(int i=0, j=0; i<n; ++i){\\n            cw += boxes[i][1];\\n            cb += !(j<i && boxes[i-1][0]==boxes[i][0]); // could possibly be clubbed together with the previous box\\n            while(j<i && (cw>mw || i-j+1>mb || (j && dp[j]<=dp[j-1]))){\\n                cw-=boxes[j][1];\\n                cb-=boxes[j][0]!=boxes[j+1][0];\\n                ++j;\\n            }\\n            dp[i] = (j ? dp[j-1] : 0) + cb + 1; // deliver cb boxes + 1 return trip + cost from behind j\\n        }\\n\\n        return dp.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937212,
                "title": "segment-tree-dp-binary-search",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> stree;\\n    void update(int tidx, int s, int e, int idx, int val){\\n        if(s == e){\\n            stree[tidx] = val;\\n            return;\\n        }\\n        int mid = (s + e)/2;\\n        if(idx <= mid) update(2*tidx, s, mid, idx, val);\\n        else update(2*tidx+1, mid+1, e, idx, val);\\n        stree[tidx] = min(stree[2*tidx], stree[2*tidx+1]);\\n    }\\n    int query(int tidx, int s, int e, int l, int r){\\n        if(s > r or e < l) return INT_MAX;\\n        else if(s >= l and e <= r) return stree[tidx];\\n        int mid = (s + e)/2;\\n        int left = query(2*tidx, s, mid, l, r);\\n        int right = query(2*tidx+1, mid+1, e, l, r);\\n        return min(left, right);\\n    }\\n    int boxDelivering(vector<vector<int>>& boxes, int port, int box, int weigh) {\\n        int n = boxes.size();\\n        vector<long long> trips(n+1), pref(n);\\n        trips[0] = 0, pref[0] = boxes[0][1];\\n        for(int i=1;i<n;i++){\\n            pref[i] = pref[i-1] + boxes[i][1];\\n            if(boxes[i][0] != boxes[i-1][0]){\\n                trips[i] = trips[i-1] + 1;\\n            }\\n            else{\\n                trips[i] = trips[i-1];\\n            }\\n        }\\n        trips[n] = trips[n-1];\\n        vector<long long> dp(n);\\n        stree = vector<int> (4*n + 1, INT_MAX);\\n        update(1, 0, n-1, 0, 0);\\n        // dp[i] = dp[j] + (trips[i] - trips[j+1]) + 2\\n        for(int i=0;i<n;i++){\\n            // L nikalo ?\\n            int l = 0, r = i;\\n            while(l < r){\\n                int mid = (l + r)/2;\\n                long long tot = pref[i] - ((mid-1>=0)?pref[mid-1]:0);\\n                if(tot <= weigh and i-mid+1 <= box){\\n                    r = mid;\\n                }\\n                else{\\n                    l = mid + 1;\\n                }\\n            }\\n            int mini = query(1, 0, n, l, i);\\n            dp[i] = mini + trips[i] + 2;\\n            update(1, 0, n, i+1, dp[i] - trips[i+1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> stree;\\n    void update(int tidx, int s, int e, int idx, int val){\\n        if(s == e){\\n            stree[tidx] = val;\\n            return;\\n        }\\n        int mid = (s + e)/2;\\n        if(idx <= mid) update(2*tidx, s, mid, idx, val);\\n        else update(2*tidx+1, mid+1, e, idx, val);\\n        stree[tidx] = min(stree[2*tidx], stree[2*tidx+1]);\\n    }\\n    int query(int tidx, int s, int e, int l, int r){\\n        if(s > r or e < l) return INT_MAX;\\n        else if(s >= l and e <= r) return stree[tidx];\\n        int mid = (s + e)/2;\\n        int left = query(2*tidx, s, mid, l, r);\\n        int right = query(2*tidx+1, mid+1, e, l, r);\\n        return min(left, right);\\n    }\\n    int boxDelivering(vector<vector<int>>& boxes, int port, int box, int weigh) {\\n        int n = boxes.size();\\n        vector<long long> trips(n+1), pref(n);\\n        trips[0] = 0, pref[0] = boxes[0][1];\\n        for(int i=1;i<n;i++){\\n            pref[i] = pref[i-1] + boxes[i][1];\\n            if(boxes[i][0] != boxes[i-1][0]){\\n                trips[i] = trips[i-1] + 1;\\n            }\\n            else{\\n                trips[i] = trips[i-1];\\n            }\\n        }\\n        trips[n] = trips[n-1];\\n        vector<long long> dp(n);\\n        stree = vector<int> (4*n + 1, INT_MAX);\\n        update(1, 0, n-1, 0, 0);\\n        // dp[i] = dp[j] + (trips[i] - trips[j+1]) + 2\\n        for(int i=0;i<n;i++){\\n            // L nikalo ?\\n            int l = 0, r = i;\\n            while(l < r){\\n                int mid = (l + r)/2;\\n                long long tot = pref[i] - ((mid-1>=0)?pref[mid-1]:0);\\n                if(tot <= weigh and i-mid+1 <= box){\\n                    r = mid;\\n                }\\n                else{\\n                    l = mid + 1;\\n                }\\n            }\\n            int mini = query(1, 0, n, l, i);\\n            dp[i] = mini + trips[i] + 2;\\n            update(1, 0, n, i+1, dp[i] - trips[i+1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666460,
                "title": "96-94-in-speed-and-memory-2023-1st-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int: \\n        num_boxes = len(boxes)\\n        left = -1 \\n        dp = [0 for _ in range(num_boxes)]\\n        res = 0\\n        for right in range(num_boxes): \\n            maxBoxes -= 1 \\n            maxWeight -= boxes[right][1]\\n            \\n            if right==left+1:\\n                res+=2 \\n            elif boxes[right][0] != boxes[right-1][0]:\\n                res+=1 \\n            \\n            while maxBoxes<0 or maxWeight<0 or (left<right-1 and dp[left]==dp[left+1]):  \\n                left += 1 \\n                maxBoxes += 1     \\n                maxWeight += boxes[left][1]\\n                if boxes[left][0] != boxes[left+1][0]:\\n                    res -= 1  \\n                 \\n            dp[right] = dp[left] + res   \\n        return dp[num_boxes-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int: \\n        num_boxes = len(boxes)\\n        left = -1 \\n        dp = [0 for _ in range(num_boxes)]\\n        res = 0\\n        for right in range(num_boxes): \\n            maxBoxes -= 1 \\n            maxWeight -= boxes[right][1]\\n            \\n            if right==left+1:\\n                res+=2 \\n            elif boxes[right][0] != boxes[right-1][0]:\\n                res+=1 \\n            \\n            while maxBoxes<0 or maxWeight<0 or (left<right-1 and dp[left]==dp[left+1]):  \\n                left += 1 \\n                maxBoxes += 1     \\n                maxWeight += boxes[left][1]\\n                if boxes[left][0] != boxes[left+1][0]:\\n                    res -= 1  \\n                 \\n            dp[right] = dp[left] + res   \\n        return dp[num_boxes-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3334580,
                "title": "c-solution-dp-monotonic-queue",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nRefer to [delphih\\'s explanation](https://leetcode.com/problems/delivering-boxes-from-storage-to-ports/solutions/969560/python-o-n-dp-monotonic-queue-sliding-window-with-full-explanation/?orderBy=most_votes). This is C# solution using LinkedList in System.Collection.Generics\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\nThis is a pretty hard question because we are using sliding window to break down the trip into segments and we need DP to memoise the subproblem answers. To achieve linear time solution, we need the monotonic queue to line up the dp values.\\r\\n\\r\\nBreak down the question into basics. If there are no limits on maxBoxes and maxWeight, the number of trips is 1 (start from storage) + number of transitions in boxes[:][0] + 1 (go back to storage).\\r\\nWhen we put in the constraints, we increase the minimum cost. We can break this problem into subproblems:\\r\\nLet dp(i) = minimum number of additional trips above base line the ship needs to make to deliver boxes[:i+1] to their respective ports. (returning back to the storage port at the end). We want to get dp(n-1). \\r\\nif we finished box[:i] and we want to deliver box[i], we can attempt the following: choose a port j (j + 1 <= i) in which we transport boxes[j + 1:i + 1] in one single trip. The additional cost we will add to the base cost is:\\r\\n1. if boxes[i][0] == boxs[i + 1][0], we add 2 (base case does not go back to storage port, we add 2 trips)\\r\\n2. else, just add 1 (as boxes[i][0] != boxes[i+1][0], instead of going directly from boxes[i][0] to boxes[i+1][0] we add 1 trip to go back to storage port)\\r\\nWe have the recursive relation: dp(i) = min(dp[j:i]) + 1(if boxes[i][0] != boxes[i+1][0]) else + 2 \\r\\nThere is no need to scan all the j-i pairs because if we know box[j:i+ 1] does not satisfy the constraint, box[j-1: i + 1] won\\'t either. Instead we use the monotonic increasing queue and to make sure the smallet dp value is always on the left end\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n$$O(n)$$\\r\\n# Code\\r\\n```\\r\\n\\r\\nusing System.Collections.Generic;\\r\\n\\r\\npublic class Solution \\r\\n{\\r\\n    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) \\r\\n    {\\r\\n        int n = boxes.Length;\\r\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\r\\n        queue.AddLast(new int[2]{-1, 1});\\r\\n\\r\\n        int left = -1;\\r\\n        int weight = 0;\\r\\n        int currentCost = 0;\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            weight += boxes[i][1];\\r\\n            while ((i - left) > maxBoxes || weight > maxWeight)\\r\\n            {\\r\\n                left++;\\r\\n                weight -= boxes[left][1];\\r\\n            }\\r\\n            while (queue.Count > 0 && queue.First.Value[0] < left)\\r\\n            {\\r\\n                queue.RemoveFirst();\\r\\n            }\\r\\n\\r\\n            currentCost = queue.First.Value[1] + 1;\\r\\n            if (i < n - 1 && boxes[i][0] == boxes[i + 1][0])\\r\\n            {\\r\\n                currentCost++;\\r\\n            }\\r\\n            while (queue.Count > 0 && queue?.Last.Value[1] >= currentCost)\\r\\n            {\\r\\n                queue.RemoveLast();\\r\\n            }\\r\\n            queue.AddLast(new int[2]{i, currentCost});\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n - 1; i++)\\r\\n        {\\r\\n            if (boxes[i][0] != boxes[i + 1][0])\\r\\n            {\\r\\n                currentCost++;\\r\\n            }\\r\\n        }\\r\\n        return currentCost;\\r\\n    }\\r\\n}\\r\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\r\\n\\r\\nusing System.Collections.Generic;\\r\\n\\r\\npublic class Solution \\r\\n{\\r\\n    public int BoxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) \\r\\n    {\\r\\n        int n = boxes.Length;\\r\\n        LinkedList<int[]> queue = new LinkedList<int[]>();\\r\\n        queue.AddLast(new int[2]{-1, 1});\\r\\n\\r\\n        int left = -1;\\r\\n        int weight = 0;\\r\\n        int currentCost = 0;\\r\\n        for (int i = 0; i < n; i++)\\r\\n        {\\r\\n            weight += boxes[i][1];\\r\\n            while ((i - left) > maxBoxes || weight > maxWeight)\\r\\n            {\\r\\n                left++;\\r\\n                weight -= boxes[left][1];\\r\\n            }\\r\\n            while (queue.Count > 0 && queue.First.Value[0] < left)\\r\\n            {\\r\\n                queue.RemoveFirst();\\r\\n            }\\r\\n\\r\\n            currentCost = queue.First.Value[1] + 1;\\r\\n            if (i < n - 1 && boxes[i][0] == boxes[i + 1][0])\\r\\n            {\\r\\n                currentCost++;\\r\\n            }\\r\\n            while (queue.Count > 0 && queue?.Last.Value[1] >= currentCost)\\r\\n            {\\r\\n                queue.RemoveLast();\\r\\n            }\\r\\n            queue.AddLast(new int[2]{i, currentCost});\\r\\n        }\\r\\n\\r\\n        for (int i = 0; i < n - 1; i++)\\r\\n        {\\r\\n            if (boxes[i][0] != boxes[i + 1][0])\\r\\n            {\\r\\n                currentCost++;\\r\\n            }\\r\\n        }\\r\\n        return currentCost;\\r\\n    }\\r\\n}\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238043,
                "title": "c-dp-two-pointers-prefix-sum-explanation",
                "content": "#### Bruteforce (TLE)\\n\\nThe idea is that **dynamic programming** is needed because we want to know the best possible answer if we start a new delivery at every `i`. This gives us a good insight for **O(N^2) TLE** pseudocode solution:\\n```\\nvector<int> dp(n+1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\tfor (int j = i; j < n; j++) {\\n\\t\\tif (/*we can take all the boxes within boxes[i,j] */) {\\n\\t\\t\\tdp[i] = min(dp[i], dp[j + 1] + /* number of different adjacent boxes in [i, j] */ + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nWe wish to improve our solution *by eliminating the process of inner loop*. But, how do we know which `j` to pick for every `i`? This is where our **greedy** part of the solution come in.\\n\\n---\\n\\n#### Greedy Speedup (Accepted)\\n\\nWe need to observe two **greedy** factors we want to maximize to get our best answer:\\n1. We want to take as many boxes as possible per trip\\n2. We want to take as many of the same boxes as possible\\n\\nThis gives us the **two pointer** part of the problem, where each pointer figures our the starting point that matches their corresponding factor. An example is shown below to demonstrate the concept further:\\n```\\nI labeled boxes by letters for convenience\\n\\nAAABBBCCCDDD[DD] <- cannot fit into one trip\\n---------+++\\n^         ^\\n^         only have enough room for 3 D boxes\\n^\\nfor sure can take with current trip\\n```\\n\\nWe can observe that if we decide to try to fit a group of same boxes into a trip but there is not enough room: we can pick one of the following:\\n1. If we decide to take some boxes anyway, **take as much as we can** and whatever is left is the starting point of a new trip\\n2. We abandon that group of boxes, so **leave them alone** and they become the starting point of a new trip\\n\\nThen we pick whichever one would give us the best answer. All we have to do now is update both pointers accordingly for the new starting point.\\n\\n---\\n\\n#### Number of Different Adjacent Boxes in Range\\n\\nThis information can be preprocessed in O(n) and calculated in O(1) afterwards. We will use **prefix sum**, which we will increase the current count by 1 if the current box is different from the last one.\\n\\nOne problem to watch out for is if the range corresponds to just a single box, then we will get `0` if we naively do the normal subtraction with prefix sum. I have created a new array called `pp` which corresponds to the first index of the range of a different boxes to the left. This way, we can subtract the count from different range of boxes instead of subtracting two of the same range.\\n\\n---\\n\\n**Time Complexity: O(N)**\\n**Space Complexity: O(N)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n\\n        vector<int> p(n + 1), pp(n);\\n        for (int i = 0, prev = -1, prev2 = 0; i < n; i++) {\\n            p[i + 1] = p[i];\\n            if (boxes[i][0] != prev) {\\n                p[i + 1]++;\\n                prev = boxes[i][0];\\n                prev2 = i;\\n            }\\n            pp[i] = prev2;\\n        }\\n        \\n        vector<int> dp(n + 1);\\n        int weight = 0, k = 0;\\n        for (int l = n - 1, r1 = n - 1, r2 = n - 1; l >= 0; l--) {\\n            weight += boxes[l][1];\\n            k++;\\n            while (weight > maxWeight || k > maxBoxes) {\\n                weight -= boxes[r2][1];\\n                k--;\\n                r2--;\\n            }\\n            r1 = min(r1, r2);\\n            while (r1 > l && p[r2 + 1] - p[pp[r1]] == 1 && boxes[r1][0] == boxes[r2][0]) {\\n                r1--;\\n            }\\n            assert(r1 >= l);\\n            assert(r1 <= r2);\\n            dp[l] = min(p[r1 + 1] - p[pp[l]] + dp[r1 + 1], p[r2 + 1] - p[pp[l]] + dp[r2 + 1]) + 1;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nvector<int> dp(n+1);\\nfor (int i = n - 1; i >= 0; i--) {\\n\\tfor (int j = i; j < n; j++) {\\n\\t\\tif (/*we can take all the boxes within boxes[i,j] */) {\\n\\t\\t\\tdp[i] = min(dp[i], dp[j + 1] + /* number of different adjacent boxes in [i, j] */ + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nI labeled boxes by letters for convenience\\n\\nAAABBBCCCDDD[DD] <- cannot fit into one trip\\n---------+++\\n^         ^\\n^         only have enough room for 3 D boxes\\n^\\nfor sure can take with current trip\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>> &boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n = boxes.size();\\n\\n        vector<int> p(n + 1), pp(n);\\n        for (int i = 0, prev = -1, prev2 = 0; i < n; i++) {\\n            p[i + 1] = p[i];\\n            if (boxes[i][0] != prev) {\\n                p[i + 1]++;\\n                prev = boxes[i][0];\\n                prev2 = i;\\n            }\\n            pp[i] = prev2;\\n        }\\n        \\n        vector<int> dp(n + 1);\\n        int weight = 0, k = 0;\\n        for (int l = n - 1, r1 = n - 1, r2 = n - 1; l >= 0; l--) {\\n            weight += boxes[l][1];\\n            k++;\\n            while (weight > maxWeight || k > maxBoxes) {\\n                weight -= boxes[r2][1];\\n                k--;\\n                r2--;\\n            }\\n            r1 = min(r1, r2);\\n            while (r1 > l && p[r2 + 1] - p[pp[r1]] == 1 && boxes[r1][0] == boxes[r2][0]) {\\n                r1--;\\n            }\\n            assert(r1 >= l);\\n            assert(r1 <= r2);\\n            dp[l] = min(p[r1 + 1] - p[pp[l]] + dp[r1 + 1], p[r2 + 1] - p[pp[l]] + dp[r2 + 1]) + 1;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3218484,
                "title": "c-segment-tree-dp-prefix-greedy",
                "content": "# Code\\n```\\n\\nclass SegmentTree {\\npublic:\\n\\tvector<int> seg;\\n\\tconst int INF = 1000000000;\\n\\tSegmentTree(int n) {\\n\\t\\tseg.resize(4 * n + 1, INF);\\n\\t}\\n\\tint query(int ind, int l, int r, int low, int high) {\\n\\t\\tif (l <= low && high <= r) {\\n\\t\\t\\treturn seg[ind];\\n\\t\\t}\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint c1 = ind * 2, c2 = c1 + 1;\\n\\t\\tint left = INF, right = INF;\\n\\t\\tif (l <= mid) {\\n\\t\\t\\tleft = min(left, query(c1, l, r, low, mid));\\n\\t\\t}\\n\\t\\tif (r > mid) {\\n\\t\\t\\tright = min(right, query(c2, l, r, mid + 1, high));\\n\\t\\t}\\n\\t\\treturn min(left, right);\\n\\t}\\n\\n\\tvoid update(int ind, int i, int val, int low, int high) {\\n\\t\\tif (low == high) {\\n\\t\\t\\tseg[ind] = val;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint c1 = ind * 2, c2 = c1 + 1;\\n\\t\\tif (i <= mid) {\\n\\t\\t\\tupdate(c1, i, val, low, mid);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tupdate(c2, i, val, mid + 1, high);\\n\\t\\t}\\n\\t\\tseg[ind] = min(seg[c1], seg[c2]);\\n\\t}\\n};\\nclass Solution {\\npublic:\\n\\tint boxDelivering(vector<vector<int>> &boxes, int portsCount,\\n                 int maxBoxes, int maxWeight) {\\n\\t\\tint n = boxes.size();\\n\\t\\tvector<int> min_l(n + 1);\\n\\t\\tint cur_l = n, cur_num_boxs = 0, cur_weight = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tcur_l = min(i + 1, cur_l);\\n\\t\\t\\twhile (\\n\\t\\t\\t\\tcur_l > 0 \\n\\t\\t\\t\\t&& cur_num_boxs + 1 <= maxBoxes \\n\\t\\t\\t\\t&& cur_weight + boxes[cur_l - 1][1] <= maxWeight\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\tcur_l--;\\n\\t\\t\\t\\tcur_num_boxs++;\\n\\t\\t\\t\\tcur_weight += boxes[cur_l][1];\\n\\t\\t\\t}\\n\\t\\t\\tmin_l[i] = cur_l;\\n\\t\\t\\tcur_num_boxs--;\\n\\t\\t\\tcur_weight -= boxes[i][1];\\n\\t\\t}\\n\\t\\tvector<int> diff_prefix(n + 1);\\n\\t\\tdiff_prefix[0] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdiff_prefix[i] = diff_prefix[i - 1];\\n\\t\\t\\tif (boxes[i][0] != boxes[i - 1][0]) {\\n\\t\\t\\t\\tdiff_prefix[i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tSegmentTree seg(n);\\n\\t\\tvector<int> dp(n + 1);\\n\\t\\tdp[0] = 0;\\n\\t\\tseg.update(1, 0, 0, 0, n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint min_dp_j = seg.query(1, min_l[i], i + 1, 0, n);\\n\\t\\t\\tdp[i] = min_dp_j + diff_prefix[i] + 2;\\n\\t\\t\\tif (i == n - 1) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tseg.update(1, i + 1, dp[i] - diff_prefix[i + 1], 0, n);\\n\\t\\t}\\n\\t\\treturn dp[n - 1];\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nclass SegmentTree {\\npublic:\\n\\tvector<int> seg;\\n\\tconst int INF = 1000000000;\\n\\tSegmentTree(int n) {\\n\\t\\tseg.resize(4 * n + 1, INF);\\n\\t}\\n\\tint query(int ind, int l, int r, int low, int high) {\\n\\t\\tif (l <= low && high <= r) {\\n\\t\\t\\treturn seg[ind];\\n\\t\\t}\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint c1 = ind * 2, c2 = c1 + 1;\\n\\t\\tint left = INF, right = INF;\\n\\t\\tif (l <= mid) {\\n\\t\\t\\tleft = min(left, query(c1, l, r, low, mid));\\n\\t\\t}\\n\\t\\tif (r > mid) {\\n\\t\\t\\tright = min(right, query(c2, l, r, mid + 1, high));\\n\\t\\t}\\n\\t\\treturn min(left, right);\\n\\t}\\n\\n\\tvoid update(int ind, int i, int val, int low, int high) {\\n\\t\\tif (low == high) {\\n\\t\\t\\tseg[ind] = val;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tint mid = low + (high - low) / 2;\\n\\t\\tint c1 = ind * 2, c2 = c1 + 1;\\n\\t\\tif (i <= mid) {\\n\\t\\t\\tupdate(c1, i, val, low, mid);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tupdate(c2, i, val, mid + 1, high);\\n\\t\\t}\\n\\t\\tseg[ind] = min(seg[c1], seg[c2]);\\n\\t}\\n};\\nclass Solution {\\npublic:\\n\\tint boxDelivering(vector<vector<int>> &boxes, int portsCount,\\n                 int maxBoxes, int maxWeight) {\\n\\t\\tint n = boxes.size();\\n\\t\\tvector<int> min_l(n + 1);\\n\\t\\tint cur_l = n, cur_num_boxs = 0, cur_weight = 0;\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tcur_l = min(i + 1, cur_l);\\n\\t\\t\\twhile (\\n\\t\\t\\t\\tcur_l > 0 \\n\\t\\t\\t\\t&& cur_num_boxs + 1 <= maxBoxes \\n\\t\\t\\t\\t&& cur_weight + boxes[cur_l - 1][1] <= maxWeight\\n\\t\\t\\t\\t) {\\n\\t\\t\\t\\tcur_l--;\\n\\t\\t\\t\\tcur_num_boxs++;\\n\\t\\t\\t\\tcur_weight += boxes[cur_l][1];\\n\\t\\t\\t}\\n\\t\\t\\tmin_l[i] = cur_l;\\n\\t\\t\\tcur_num_boxs--;\\n\\t\\t\\tcur_weight -= boxes[i][1];\\n\\t\\t}\\n\\t\\tvector<int> diff_prefix(n + 1);\\n\\t\\tdiff_prefix[0] = 0;\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\t\\t\\tdiff_prefix[i] = diff_prefix[i - 1];\\n\\t\\t\\tif (boxes[i][0] != boxes[i - 1][0]) {\\n\\t\\t\\t\\tdiff_prefix[i]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tSegmentTree seg(n);\\n\\t\\tvector<int> dp(n + 1);\\n\\t\\tdp[0] = 0;\\n\\t\\tseg.update(1, 0, 0, 0, n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tint min_dp_j = seg.query(1, min_l[i], i + 1, 0, n);\\n\\t\\t\\tdp[i] = min_dp_j + diff_prefix[i] + 2;\\n\\t\\t\\tif (i == n - 1) {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tseg.update(1, i + 1, dp[i] - diff_prefix[i + 1], 0, n);\\n\\t\\t}\\n\\t\\treturn dp[n - 1];\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189455,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn box_delivering(boxes: Vec<Vec<i32>>, ports_count: i32, max_boxes: i32, max_weight: i32) -> i32 {\\n        let n = boxes.len();\\n        let (mut need, mut j, mut lastj) = (0, 0, 0);\\n        let (mut max_boxes, mut max_weight) = (max_boxes, max_weight);\\n        let mut dp = vec![200000; n + 1];\\n        dp[0] = 0;\\n        for i in 0..n {\\n            while j < n && max_boxes > 0 && max_weight >= boxes[j][1] {\\n                max_boxes -= 1;\\n                max_weight -= boxes[j][1];\\n                if j == 0 || boxes[j][0] != boxes[j - 1][0] {\\n                    lastj = j;\\n                    need += 1;\\n                }\\n                j += 1;\\n            }\\n            dp[j] = dp[j].min(dp[i] + need + 1);\\n            dp[lastj] = dp[lastj].min(dp[i] + need);\\n            max_boxes += 1;\\n            max_weight += boxes[i][1];\\n            if i == n - 1 || boxes[i][0] != boxes[i + 1][0] {\\n                need -= 1;\\n            }\\n        }\\n        dp[n]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn box_delivering(boxes: Vec<Vec<i32>>, ports_count: i32, max_boxes: i32, max_weight: i32) -> i32 {\\n        let n = boxes.len();\\n        let (mut need, mut j, mut lastj) = (0, 0, 0);\\n        let (mut max_boxes, mut max_weight) = (max_boxes, max_weight);\\n        let mut dp = vec![200000; n + 1];\\n        dp[0] = 0;\\n        for i in 0..n {\\n            while j < n && max_boxes > 0 && max_weight >= boxes[j][1] {\\n                max_boxes -= 1;\\n                max_weight -= boxes[j][1];\\n                if j == 0 || boxes[j][0] != boxes[j - 1][0] {\\n                    lastj = j;\\n                    need += 1;\\n                }\\n                j += 1;\\n            }\\n            dp[j] = dp[j].min(dp[i] + need + 1);\\n            dp[lastj] = dp[lastj].min(dp[i] + need);\\n            max_boxes += 1;\\n            max_weight += boxes[i][1];\\n            if i == n - 1 || boxes[i][0] != boxes[i + 1][0] {\\n                need -= 1;\\n            }\\n        }\\n        dp[n]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2883275,
                "title": "python-solution-dynamic-programming-sliding-window-faster-than-55",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: dynamic programming + sliding window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int: \\n        num_boxes = len(boxes)\\n        left = -1 \\n        dp = [0 for _ in range(num_boxes)]\\n        res = 0\\n        for right in range(num_boxes): \\n            maxBoxes -= 1 \\n            maxWeight -= boxes[right][1]\\n            \\n            if right==left+1:\\n                res+=2 \\n            elif boxes[right][0] != boxes[right-1][0]:\\n                res+=1 \\n            \\n            while maxBoxes<0 or maxWeight<0 or (left<right-1 and dp[left]==dp[left+1]):  \\n                left += 1 \\n                maxBoxes += 1     \\n                maxWeight += boxes[left][1]\\n                if boxes[left][0] != boxes[left+1][0]:\\n                    res -= 1  \\n                 \\n            dp[right] = dp[left] + res   \\n        return dp[num_boxes-1]    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int: \\n        num_boxes = len(boxes)\\n        left = -1 \\n        dp = [0 for _ in range(num_boxes)]\\n        res = 0\\n        for right in range(num_boxes): \\n            maxBoxes -= 1 \\n            maxWeight -= boxes[right][1]\\n            \\n            if right==left+1:\\n                res+=2 \\n            elif boxes[right][0] != boxes[right-1][0]:\\n                res+=1 \\n            \\n            while maxBoxes<0 or maxWeight<0 or (left<right-1 and dp[left]==dp[left+1]):  \\n                left += 1 \\n                maxBoxes += 1     \\n                maxWeight += boxes[left][1]\\n                if boxes[left][0] != boxes[left+1][0]:\\n                    res -= 1  \\n                 \\n            dp[right] = dp[left] + res   \\n        return dp[num_boxes-1]    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851521,
                "title": "python-segment-tree",
                "content": "```\\n## segment tree\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.n = len(nums)\\n        self.data = [None] * self.n + nums\\n        for _i in range(1, self.n):\\n            i = self.n - _i\\n            self.data[i] = self.agg(i)\\n    \\n    def update(self, i, value):\\n        i += self.n\\n        self.data[i] = value\\n        while i > 1:\\n            i >>= 1\\n            self.data[i] = self.agg(i)\\n    \\n    def agg(self, i):\\n        # update if not sum\\n        \\n        left = 2 * i\\n        right = 2 * i + 1\\n        return min(self.data[left], self.data[right])\\n    \\n    # interval [l, r) \\n    def query_lclose_ropen(self, l, r):\\n        # update if not sum\\n        \\n        l += self.n\\n        r += self.n        \\n        rst = float(\\'inf\\')\\n        while l < r:\\n            if r & 1:\\n                r -= 1\\n                \\n                rst = min(rst, self.data[r])\\n            \\n            if l & 1:\\n                rst = min(rst, self.data[l])\\n                \\n                l += 1\\n            \\n            l >>= 1\\n            r >>= 1\\n        return rst\\n\\n\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        \\n        totals = [float(\\'inf\\')] * (n+1)\\n        singles = [float(\\'inf\\')] * (n+1)\\n        totals[0] = 0\\n        totals[1] = 2\\n        singles[0] = 2\\n        cum_trip = 0\\n        stt = 0\\n        cum_wt = boxes[0][1]\\n        my_tree = SegmentTree([totals[i] + singles[i] for i in range(n+1)])\\n        for i in range(1, n):\\n            p, w = boxes[i]\\n            if w > maxWeight:\\n                return 0\\n            \\n            cum_wt += w\\n            while cum_wt > maxWeight or stt <= i-maxBoxes:\\n                cum_wt -= boxes[stt][1]\\n                singles[stt] = float(\\'inf\\')\\n                my_tree.update(stt, float(\\'inf\\'))\\n                stt += 1\\n            \\n            if stt < i and p != boxes[i-1][0]:\\n                cum_trip += 1\\n            \\n            singles[i] = 2 - cum_trip\\n            my_tree.update(i, totals[i]+singles[i])\\n            \\n            totals[i+1] = my_tree.data[1]+cum_trip\\n        return totals[n]\\n```",
                "solutionTags": [],
                "code": "```\\n## segment tree\\nclass SegmentTree:\\n    def __init__(self, nums):\\n        self.n = len(nums)\\n        self.data = [None] * self.n + nums\\n        for _i in range(1, self.n):\\n            i = self.n - _i\\n            self.data[i] = self.agg(i)\\n    \\n    def update(self, i, value):\\n        i += self.n\\n        self.data[i] = value\\n        while i > 1:\\n            i >>= 1\\n            self.data[i] = self.agg(i)\\n    \\n    def agg(self, i):\\n        # update if not sum\\n        \\n        left = 2 * i\\n        right = 2 * i + 1\\n        return min(self.data[left], self.data[right])\\n    \\n    # interval [l, r) \\n    def query_lclose_ropen(self, l, r):\\n        # update if not sum\\n        \\n        l += self.n\\n        r += self.n        \\n        rst = float(\\'inf\\')\\n        while l < r:\\n            if r & 1:\\n                r -= 1\\n                \\n                rst = min(rst, self.data[r])\\n            \\n            if l & 1:\\n                rst = min(rst, self.data[l])\\n                \\n                l += 1\\n            \\n            l >>= 1\\n            r >>= 1\\n        return rst\\n\\n\\nclass Solution:\\n    def boxDelivering(self, boxes: List[List[int]], portsCount: int, maxBoxes: int, maxWeight: int) -> int:\\n        n = len(boxes)\\n        \\n        totals = [float(\\'inf\\')] * (n+1)\\n        singles = [float(\\'inf\\')] * (n+1)\\n        totals[0] = 0\\n        totals[1] = 2\\n        singles[0] = 2\\n        cum_trip = 0\\n        stt = 0\\n        cum_wt = boxes[0][1]\\n        my_tree = SegmentTree([totals[i] + singles[i] for i in range(n+1)])\\n        for i in range(1, n):\\n            p, w = boxes[i]\\n            if w > maxWeight:\\n                return 0\\n            \\n            cum_wt += w\\n            while cum_wt > maxWeight or stt <= i-maxBoxes:\\n                cum_wt -= boxes[stt][1]\\n                singles[stt] = float(\\'inf\\')\\n                my_tree.update(stt, float(\\'inf\\'))\\n                stt += 1\\n            \\n            if stt < i and p != boxes[i-1][0]:\\n                cum_trip += 1\\n            \\n            singles[i] = 2 - cum_trip\\n            my_tree.update(i, totals[i]+singles[i])\\n            \\n            totals[i+1] = my_tree.data[1]+cum_trip\\n        return totals[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528006,
                "title": "help-needed",
                "content": "class Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<pair<long long,long long>> a;\\n        vector<int> b_count;\\n        long long boxes_count = 1, weight = boxes[boxes.size()-1][1], port = boxes[boxes.size()-1][0]; \\n        for (int i = boxes.size() - 2; i >=0;i--) {\\n            int p1 = boxes[i][0], w1 = boxes[i][1];\\n            if (p1 == port && boxes_count + 1 <= maxBoxes && w1+weight <= maxWeight) {\\n                weight += w1;\\n                boxes_count++;\\n            }\\n            else {\\n                a.push_back({port,weight});\\n                b_count.push_back(boxes_count);\\n                port = p1;\\n                boxes_count = 1;\\n                \\n                weight = w1;\\n            }\\n        }\\n        a.push_back({port, weight});\\n        b_count.push_back(boxes_count);\\n        reverse(b_count.begin(), b_count.end());\\n        reverse(a.begin(), a.end());\\n        int ans = 0;\\n        boxes_count = b_count[0];\\n        weight= a[0].second;\\n        port = a[0].first;\\n        int unique = 1;\\n        for (int i = 1 ; i < a.size();i++) {\\n            int w = a[i].second, b = b_count[i];\\n            if (b + boxes_count <= maxBoxes && w + weight <= maxWeight) {\\n                if (a[i].first != port) {\\n                    unique++;\\n                    port = a[i].first;\\n                }\\n                boxes_count += b;\\n                weight += w;\\n            }\\n            else {\\n                ans += unique +1;\\n                unique = 1;\\n                boxes_count = b;\\n                weight = w;\\n                port = a[i].first;\\n            }\\n        }\\n        ans+=unique+1;\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int boxDelivering(vector<vector<int>>& boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        vector<pair<long long,long long>> a;\\n        vector<int> b_count;\\n        long long boxes_count = 1, weight = boxes[boxes.size()-1][1], port = boxes[boxes.size()-1][0]; \\n        for (int i = boxes.size() - 2; i >=0;i--) {\\n            int p1 = boxes[i][0], w1 = boxes[i][1];\\n            if (p1 == port && boxes_count + 1 <= maxBoxes && w1+weight <= maxWeight) {\\n                weight += w1;\\n                boxes_count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2330389,
                "title": "java-from-o-n-2-to-o-n-monoqueue-w-dp",
                "content": "This is a difficult problem. The O(n^2) DP solution is rather easy to come up with, but it will get TLE. It however helped me with coming up a `O(N)` solution, so let\\'s look at the code first.\\n\\nFor each index `i`, we search backwards and treat `j ... i` as a group. The cost would be `cost + dp[j-1]` for all valid `j`. \\n\\n#### TLE at Last 4 Test Cases\\n```Java\\n// class Solution {\\n//     public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n//         int n = boxes.length, INF = (int)1e9;\\n//         int[] dp = new int[n];\\n//         Arrays.fill(dp, INF);\\n//         dp[0]=2;\\n//         for (int i = 1 ; i<n; i++){\\n//             for (int j = i, w = 0, cur = 0; j >= 0; j--){\\n//                 w+=boxes[j][1];\\n//                 if (j==i||boxes[j][0]!=boxes[j+1][0]){\\n//                     cur++;\\n//                 }\\n//                 if (w <= maxWeight && cur <= maxBoxes){\\n//                     dp[i] = Math.min(dp[i], 1 + cur + (j==0?0:dp[j-1]));\\n//                 }else{\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return dp[n-1];\\n//     }\\n// }\\n```\\nso how do we optimize this into `O(n)`? \\nThis looks awfully like a mono queue to me. Because we want the minimum `DP[j] + cost form j+1 to i` from the subarray `j ... i`.\\nSo we should be able to do that with a mono queue.\\nWe must put the **adjusted** value into the mono queue, not `dp[i]`for it to work properly.\\nThen, we will get the min result from the TLE solution for each `dp[i]` in O(1).\\n\\n#### We Need\\n1. Index and adjusted weight inside the mono queue\\n2. A prefix weight array (long type) to check weight requirement\\n3. A diff array to compute the additional cost incurred by different type of parcels\\n\\n#### Edge Case\\nThere is one that took me a while to debug:\\n`diff[deque.peekFirst()[0]+1]`\\nWe must `+1` here. Consider 2 adjacent boxes . If the previous box is picked, the diff pointer should be at `i+1`, not `i`. Otherwise we will count extra. \\n#### Java\\n```Java\\n// Time Complexity: O(n)\\n// Space Complexity: O(n)\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n = boxes.length, INF = (int)1e9;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        Deque<int[]> deque = new ArrayDeque<>();\\n        long[] pre = new long[n+1];\\n        int[] diff= new int[n+1];\\n        for (int i = 1; i <= n; i++){ // prefix sum for weight \\n            pre[i]=boxes[i-1][1]+pre[i-1];\\n        }\\n        for (int i = 2; i <= n; i++){ // additional cost\\n            diff[i]=boxes[i-1][0]==boxes[i-2][0]?diff[i-1]:diff[i-1]+1;\\n        }\\n        deque.offer(new int[]{0, 0}); // base case \\n        for (int i = 1 ; i<=n; i++){\\n            while(i - deque.peekFirst()[0] > maxBoxes || pre[i] - pre[deque.peekFirst()[0]] > maxWeight){ // invalid, remove it\\n                deque.pollFirst();\\n            }\\n            dp[i]=diff[i]-diff[deque.peekFirst()[0]+1]+dp[deque.peekFirst()[0]]+2; // dp value\\n            int cur = dp[i] - diff[i==n?0:i+1];\\n            while(!deque.isEmpty() && cur < deque.peekLast()[1]){ // purge based on adjusted value, NOT dp value\\n                deque.pollLast();\\n            }\\n            deque.offerLast(new int[]{i, cur}); // put adjusted value into the mono queue.\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```Java\\n// class Solution {\\n//     public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n//         int n = boxes.length, INF = (int)1e9;\\n//         int[] dp = new int[n];\\n//         Arrays.fill(dp, INF);\\n//         dp[0]=2;\\n//         for (int i = 1 ; i<n; i++){\\n//             for (int j = i, w = 0, cur = 0; j >= 0; j--){\\n//                 w+=boxes[j][1];\\n//                 if (j==i||boxes[j][0]!=boxes[j+1][0]){\\n//                     cur++;\\n//                 }\\n//                 if (w <= maxWeight && cur <= maxBoxes){\\n//                     dp[i] = Math.min(dp[i], 1 + cur + (j==0?0:dp[j-1]));\\n//                 }else{\\n//                     break;\\n//                 }\\n//             }\\n//         }\\n//         return dp[n-1];\\n//     }\\n// }\\n```\n```Java\\n// Time Complexity: O(n)\\n// Space Complexity: O(n)\\nclass Solution {\\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\\n        int n = boxes.length, INF = (int)1e9;\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, INF);\\n        dp[0]=0;\\n        Deque<int[]> deque = new ArrayDeque<>();\\n        long[] pre = new long[n+1];\\n        int[] diff= new int[n+1];\\n        for (int i = 1; i <= n; i++){ // prefix sum for weight \\n            pre[i]=boxes[i-1][1]+pre[i-1];\\n        }\\n        for (int i = 2; i <= n; i++){ // additional cost\\n            diff[i]=boxes[i-1][0]==boxes[i-2][0]?diff[i-1]:diff[i-1]+1;\\n        }\\n        deque.offer(new int[]{0, 0}); // base case \\n        for (int i = 1 ; i<=n; i++){\\n            while(i - deque.peekFirst()[0] > maxBoxes || pre[i] - pre[deque.peekFirst()[0]] > maxWeight){ // invalid, remove it\\n                deque.pollFirst();\\n            }\\n            dp[i]=diff[i]-diff[deque.peekFirst()[0]+1]+dp[deque.peekFirst()[0]]+2; // dp value\\n            int cur = dp[i] - diff[i==n?0:i+1];\\n            while(!deque.isEmpty() && cur < deque.peekLast()[1]){ // purge based on adjusted value, NOT dp value\\n                deque.pollLast();\\n            }\\n            deque.offerLast(new int[]{i, cur}); // put adjusted value into the mono queue.\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1566182,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "The bar of being a programmer is so freaking high.\\nI\\'d rather lie flat \\uFF08\\u8EBA\\u5E73\\uFF09."
                    },
                    {
                        "username": "0icy",
                        "content": "does greedy work?"
                    },
                    {
                        "username": "0icy",
                        "content": "ok it doesnt\\n"
                    }
                ]
            },
            {
                "id": 1986007,
                "content": [
                    {
                        "username": "Wizmann",
                        "content": "The bar of being a programmer is so freaking high.\\nI\\'d rather lie flat \\uFF08\\u8EBA\\u5E73\\uFF09."
                    },
                    {
                        "username": "0icy",
                        "content": "does greedy work?"
                    },
                    {
                        "username": "0icy",
                        "content": "ok it doesnt\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Detect Squares",
        "question_content": "<p>You are given a stream of points on the X-Y plane. Design an algorithm that:</p>\n\n<ul>\n\t<li><strong>Adds</strong> new points from the stream into a data structure. <strong>Duplicate</strong> points are allowed and should be treated as different points.</li>\n\t<li>Given a query point, <strong>counts</strong> the number of ways to choose three points from the data structure such that the three points and the query point form an <strong>axis-aligned square</strong> with <strong>positive area</strong>.</li>\n</ul>\n\n<p>An <strong>axis-aligned square</strong> is a square whose edges are all the same length and are either parallel or perpendicular to the x-axis and y-axis.</p>\n\n<p>Implement the <code>DetectSquares</code> class:</p>\n\n<ul>\n\t<li><code>DetectSquares()</code> Initializes the object with an empty data structure.</li>\n\t<li><code>void add(int[] point)</code> Adds a new point <code>point = [x, y]</code> to the data structure.</li>\n\t<li><code>int count(int[] point)</code> Counts the number of ways to form <strong>axis-aligned squares</strong> with point <code>point = [x, y]</code> as described above.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/09/01/image.png\" style=\"width: 869px; height: 504px;\" />\n<pre>\n<strong>Input</strong>\n[&quot;DetectSquares&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;count&quot;, &quot;count&quot;, &quot;add&quot;, &quot;count&quot;]\n[[], [[3, 10]], [[11, 2]], [[3, 2]], [[11, 10]], [[14, 8]], [[11, 2]], [[11, 10]]]\n<strong>Output</strong>\n[null, null, null, null, 1, 0, null, 2]\n\n<strong>Explanation</strong>\nDetectSquares detectSquares = new DetectSquares();\ndetectSquares.add([3, 10]);\ndetectSquares.add([11, 2]);\ndetectSquares.add([3, 2]);\ndetectSquares.count([11, 10]); // return 1. You can choose:\n                               //   - The first, second, and third points\ndetectSquares.count([14, 8]);  // return 0. The query point cannot form a square with any points in the data structure.\ndetectSquares.add([11, 2]);    // Adding duplicate points is allowed.\ndetectSquares.count([11, 10]); // return 2. You can choose:\n                               //   - The first, second, and third points\n                               //   - The first, third, and fourth points\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>point.length == 2</code></li>\n\t<li><code>0 &lt;= x, y &lt;= 1000</code></li>\n\t<li>At most <code>3000</code> calls <strong>in total</strong> will be made to <code>add</code> and <code>count</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1471958,
                "title": "c-java-python-2-approaches-using-hashmap-with-picture-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Given p1, try all points p3 (p1 and p3 form diagonal)**\\n- To compute `count(p1)`:\\n\\t- We try all points `p3` which together with `p1` form the diagonal of non-empty square, it means `abs(p1.x-p3.x) == abs(p1.y-p3.y) && abs(p1.x-p3.x) > 0`\\n\\t- Since we have 2 points `p1` and `p3`, we can form a square by computing the positions of 2 remain points `p2`, `p4`.\\n\\t- `p2 = (p1.x, p3.y)`\\n\\t- `p4 = (p3.x, p1.y)`\\n\\n![image](https://assets.leetcode.com/users/images/3f33581d-baa5-4fd4-9516-a1098af539d1_1632034530.1139376.png)\\n\\n\\n<iframe src=\"https://leetcode.com/playground/jZWSRXp8/shared\" frameBorder=\"0\" width=\"100%\" height=\"420\"></iframe>\\n\\n**Complexity**\\n- Time: \\n\\t- add: `O(1)`\\n\\t- count: `O(T)`, where `T <= 5000` is total number of points after calling `add`. \\n- Space: `O(T)` in Python, `O(1000^2)` in C++/Java\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: Given p1, try all points p2 (same x-axis) then compute the positions of 2 remain points p3, p4**\\n- To compute `count(p1)`:\\n\\t- We try all the points `p2` which has the same x-axis with `p1`, it means `p2.x = p1.x`\\n\\t- Since we have 2 points `p1` and `p2`, we can form a square by computing the positions of 2 remain points `p3`, `p4`.\\n\\t\\t- Calculate `sideLen = abs(p1.y - p2.y)`\\n\\t\\t- Case 1: p3, p4 points are in the left side of line p1p2\\n\\t\\t\\t- `p3 = (p1.x - sideLen, p2.y)`\\n\\t\\t\\t- `p4 = (p1.x - sideLen, p1.y)`\\n\\t\\t- Case 2: p3, p4 points are in the right side of line p1p2\\n\\t\\t\\t- `p3 = (p1.x + sideLen, p2.y)`\\n\\t\\t\\t- `p4 = (p1.x + sideLen, p1.y)`\\n\\n![image](https://assets.leetcode.com/users/images/df4eb1e2-4eef-4af0-b520-3cf76bb340dd_1632033382.7016203.png)\\n\\n```python\\nclass DetectSquares:\\n    def __init__(self):\\n        self.xPoints = defaultdict(list)\\n        self.cnt = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.xPoints[x].append(y)\\n        self.cnt[(x, y)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x1, y1 = point\\n        ans = 0\\n        for y2 in self.xPoints[x1]:\\n            if y2 == y1: continue  # Skip empty square\\n            sideLen = abs(y2 - y1)\\n\\n            # Case: p3, p4 points are in the left side\\n            x3, y3 = x1 - sideLen, y2\\n            x4, y4 = x1 - sideLen, y1\\n            ans += self.cnt[(x3, y3)] * self.cnt[(x4, y4)]\\n\\n            # Case 2: p3, p4 points are in the left side\\n            x3, y3 = x1 + sideLen, y2\\n            x4, y4 = x1 + sideLen, y1\\n            ans += self.cnt[(x3, y3)] * self.cnt[(x4, y4)]\\n        return ans\\n```\\n**Complexity**\\n- Time: \\n\\t- add: `O(1)`\\n\\t- count: `O(T)`, where `T <= 5000` is total number of `add` call. \\n- Space: `O(T)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass DetectSquares:\\n    def __init__(self):\\n        self.xPoints = defaultdict(list)\\n        self.cnt = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.xPoints[x].append(y)\\n        self.cnt[(x, y)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x1, y1 = point\\n        ans = 0\\n        for y2 in self.xPoints[x1]:\\n            if y2 == y1: continue  # Skip empty square\\n            sideLen = abs(y2 - y1)\\n\\n            # Case: p3, p4 points are in the left side\\n            x3, y3 = x1 - sideLen, y2\\n            x4, y4 = x1 - sideLen, y1\\n            ans += self.cnt[(x3, y3)] * self.cnt[(x4, y4)]\\n\\n            # Case 2: p3, p4 points are in the left side\\n            x3, y3 = x1 + sideLen, y2\\n            x4, y4 = x1 + sideLen, y1\\n            ans += self.cnt[(x3, y3)] * self.cnt[(x4, y4)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471914,
                "title": "python-short-two-dictionaries-solution",
                "content": "The idea is to keep two pieces of infromation:\\n1. `self.d` is counter for points, that is how many times we have each of them.\\n2. `self.x_coord` is defaultdict of counter for each coordinate `x`, that is given `x` we can quickly find all point with this coordinate.\\n\\nWhat we need to do now:\\n1. for `add(self, point)` we just increment two counters.\\n2. for `count(self, point)` we need to find all points with the same coordinate `x`: points in the form `(x, y2)` and then reconstruct square: there will be two ways to do it: one above line and one below. Here we need to take into account frequences of our points, so we use `self.d` for this. Be careful to check that `y2 != y`, it costs me 5 minutes penalty on the contest.\\n\\n#### Complexity\\nTime complexity of `add` is `O(1)`. Time complexity of `count` is potentially `O(n)` but in practice it is less because usually we do not have a lot of points on the same line. Space complexity of all data structure is `O(n)`.\\n\\n#### Code\\n```python\\nclass DetectSquares:\\n    def __init__(self):\\n        self.d = Counter()\\n        self.x_coord = defaultdict(Counter)   # x -> all y coordinates with freqs\\n\\n    def add(self, point):\\n        x, y = point\\n        self.d[x, y] += 1\\n        self.x_coord[x][y] += 1\\n\\n    def count(self, point):\\n        x, y = point\\n        ans = 0\\n        for y2 in self.x_coord[x]:\\n            if y == y2: continue\\n            ans += self.d[x, y2] * self.d[x + y2 - y, y] * self.d[x + y2 - y, y2]\\n            ans += self.d[x, y2] * self.d[x + y - y2, y] * self.d[x + y - y2, y2]\\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math",
                    "Geometry"
                ],
                "code": "```python\\nclass DetectSquares:\\n    def __init__(self):\\n        self.d = Counter()\\n        self.x_coord = defaultdict(Counter)   # x -> all y coordinates with freqs\\n\\n    def add(self, point):\\n        x, y = point\\n        self.d[x, y] += 1\\n        self.x_coord[x][y] += 1\\n\\n    def count(self, point):\\n        x, y = point\\n        ans = 0\\n        for y2 in self.x_coord[x]:\\n            if y == y2: continue\\n            ans += self.d[x, y2] * self.d[x + y2 - y, y] * self.d[x + y2 - y, y2]\\n            ans += self.d[x, y2] * self.d[x + y - y2, y] * self.d[x + y - y2, y2]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472167,
                "title": "java-clean-solution-with-list-and-hashmap",
                "content": "1. Save all coordinates to a list, in the meanwhile count the frequencies of each coordinate in a hashmap\\n2. During count method, check if each coordinate form a square diagnol with the query point, if so, use the counts of the other two coordinates of the square to calculate the total\\n\\ne.g. \\n\\tx, y and px, py formed a diagnol for a square size of |px -x|, now we just need to see the counts of (x, py) and (px, y). \\n\\tusing @ for map coordinate keys\\n\\n```\\nclass DetectSquares {\\n    List<int[]> coordinates;\\n    Map<String, Integer> counts;\\n    \\n    public DetectSquares() {\\n        coordinates = new ArrayList<>();\\n        counts = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        coordinates.add(point);\\n        String key = point[0] + \"@\" + point[1];\\n        counts.put(key, counts.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int sum = 0, px = point[0], py = point[1];\\n        for (int[] coordinate : coordinates) {\\n            int x = coordinate[0], y = coordinate[1];\\n            if (px == x || py == y || (Math.abs(px - x) != Math.abs(py - y)))\\n                continue;\\n            sum += counts.getOrDefault(x + \"@\" + py, 0) * counts.getOrDefault(px + \"@\" + y, 0);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    List<int[]> coordinates;\\n    Map<String, Integer> counts;\\n    \\n    public DetectSquares() {\\n        coordinates = new ArrayList<>();\\n        counts = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        coordinates.add(point);\\n        String key = point[0] + \"@\" + point[1];\\n        counts.put(key, counts.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int sum = 0, px = point[0], py = point[1];\\n        for (int[] coordinate : coordinates) {\\n            int x = coordinate[0], y = coordinate[1];\\n            if (px == x || py == y || (Math.abs(px - x) != Math.abs(py - y)))\\n                continue;\\n            sum += counts.getOrDefault(x + \"@\" + py, 0) * counts.getOrDefault(px + \"@\" + y, 0);\\n        }\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472290,
                "title": "counting-matrix",
                "content": "Since coordinates are limited to `[0 ... 1000]`, we can count points using a matrix `m`.\\n\\nWhen we count squares, we go through all `x` coordinates, detect the square size, and check the other two points above and below.\\n\\n**C++**\\n```cpp\\nint m[1001][1001] = {};\\nvoid add(vector<int> p) { ++m[p[0]][p[1]]; }\\nint count(vector<int> p) { \\n    int i = p[0], j = p[1], cnt = 0;\\n    for (int x = 0; x <= 1000; ++x) {\\n        if (x != i && m[x][j]) {\\n            int sz = abs(x - i);\\n            if (j + sz <= 1000)\\n                cnt += m[x][j + sz] * m[i][j + sz] * m[x][j];\\n            if (j >= sz)\\n                cnt += m[x][j - sz] * m[i][j - sz] * m[x][j];\\n        }\\n    }\\n    return cnt; \\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint m[1001][1001] = {};\\nvoid add(vector<int> p) { ++m[p[0]][p[1]]; }\\nint count(vector<int> p) { \\n    int i = p[0], j = p[1], cnt = 0;\\n    for (int x = 0; x <= 1000; ++x) {\\n        if (x != i && m[x][j]) {\\n            int sz = abs(x - i);\\n            if (j + sz <= 1000)\\n                cnt += m[x][j + sz] * m[i][j + sz] * m[x][j];\\n            if (j >= sz)\\n                cnt += m[x][j - sz] * m[i][j - sz] * m[x][j];\\n        }\\n    }\\n    return cnt; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472289,
                "title": "intuition-explained-with-diagram-coordinate-geometry-c",
                "content": "**Intuition :** \\n\\n* Idea is to store count of all points lying on x-axis with x-coordinate as point[0]. And for each point on x-axis, we have corresponding y-coordinate. \\n\\t\\n\\t\\tx_axis[x][y] = count of points with coordinate {x,y}. \\n\\n* Now, for check, we need to pick all points lying on x = point[0]. For all such we calculate side length and find remaining two points at same distance on left and right side of x = point[0] (+-) side_length. \\n\\n\\n\\t\\t-> p1 = { x, y }    # This is given as input\\n\\t\\t-> p2 = { x, y\\' }   # We pick all the points p2 with x_coordinate = x  \\n\\t\\t* Thus side_length = abs(y - y\\')\\n\\t\\t\\n\\t\\t// We find all valid p3 and p4 lying on both sides of p1 and p2 along x & y axis\\n\\t\\t\\n\\t\\t// Square on right side of p1 & p2 with line x acting as mirror\\n\\t\\t-> p3\\' = { x + side_length , y }\\n\\t\\t-> p4\\' = { x + side_length , y\\' }\\n\\t\\t\\n\\t\\t// Square on left side of p1 & p2 with line x acting as mirror\\n\\t\\t-> p3\\'\\' = { x - side_length , y }\\n\\t\\t-> p4\\'\\' = { x - side_length , y\\' }\\n\\t\\t\\n\\t\\tNote : y\\' (p2) can lie anywhere, above or below p1(y). But that does not effect our calculations.\\n\\n\\n![image](https://assets.leetcode.com/users/images/424ef955-ea4b-4e02-8db3-636e509bed91_1632053370.123253.png)\\n\\n\\t\\t\\n\\n* Now, to get count we need to multiply count of all possible p2, p3, and p4 possible points.\\n\\n\\t\\tcount of right side squares = count(p2) * count(p4\\') * count(p3\\')\\n\\t\\tcount of left side squares = count(p2) * count(p4\\'\\') * count(p3\\'\\')\\n\\n\\t\\t=> result = (count of left side squares + count of right side squares)\\n# Code:\\n```\\nclass DetectSquares {\\npublic:\\n    vector<unordered_map<int, int>> x_axis;\\n    \\n    DetectSquares() {\\n        x_axis = vector<unordered_map<int, int>>(1005);\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        x_axis[x][y]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int res = 0;\\n        for (auto& it : x_axis[x]) {                // For all points lying on x_axis with value x_coordinate = x\\n            int y_coord = it.first;\\n            int countOcc = it.second;\\n            \\n            if (y == y_coord) continue;\\n            int sideLength = abs(y_coord - y);\\n            \\n\\t\\t\\t // counting for p3\\' and p4\\'\\n            if (x + sideLength <= 1000)    // x_coordinate should be within range [0, 1000]\\n            {\\n                int newX = x + sideLength;\\n                res += x_axis[x][y_coord] * x_axis[newX][y_coord] * x_axis[newX][y];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// counting for p3\\'\\' and p4\\'\\'\\n            if (x - sideLength >= 0)       // x_coordinate should be within range [0, 1000]\\n            {\\n                int newX = x - sideLength;\\n                res += x_axis[x][y_coord] * x_axis[newX][y_coord] * x_axis[newX][y];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Time :**\\n* **add() : O(1)**\\n* **count() : O(n)**\\n\\n**Space : O(n)**\\n\\n***If this solution helped you, please give it a like :)***\\n*Feel free to ask any doubt or correct me if there is something wrong.*",
                "solutionTags": [
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    vector<unordered_map<int, int>> x_axis;\\n    \\n    DetectSquares() {\\n        x_axis = vector<unordered_map<int, int>>(1005);\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        x_axis[x][y]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int res = 0;\\n        for (auto& it : x_axis[x]) {                // For all points lying on x_axis with value x_coordinate = x\\n            int y_coord = it.first;\\n            int countOcc = it.second;\\n            \\n            if (y == y_coord) continue;\\n            int sideLength = abs(y_coord - y);\\n            \\n\\t\\t\\t // counting for p3\\' and p4\\'\\n            if (x + sideLength <= 1000)    // x_coordinate should be within range [0, 1000]\\n            {\\n                int newX = x + sideLength;\\n                res += x_axis[x][y_coord] * x_axis[newX][y_coord] * x_axis[newX][y];\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// counting for p3\\'\\' and p4\\'\\'\\n            if (x - sideLength >= 0)       // x_coordinate should be within range [0, 1000]\\n            {\\n                int newX = x - sideLength;\\n                res += x_axis[x][y_coord] * x_axis[newX][y_coord] * x_axis[newX][y];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480590,
                "title": "c-solution",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x=point[0];\\n        int y=point[1];\\n        for(auto t:mp)\\n        {\\n            pair<int,int>it=t.first;\\n            if(it.first!=x&&it.second!=y&&(abs(it.first-x)==abs(it.second-y)))\\n            {\\n                int f1=mp[{it.first,it.second}];\\n                int f2=mp[{it.first,y}];\\n                int f3=mp[{x,it.second}];\\n                count+=f1*f2*f3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x=point[0];\\n        int y=point[1];\\n        for(auto t:mp)\\n        {\\n            pair<int,int>it=t.first;\\n            if(it.first!=x&&it.second!=y&&(abs(it.first-x)==abs(it.second-y)))\\n            {\\n                int f1=mp[{it.first,it.second}];\\n                int f2=mp[{it.first,y}];\\n                int f3=mp[{x,it.second}];\\n                count+=f1*f2*f3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471923,
                "title": "java-easy-and-concise-2-d-array-solution",
                "content": "```\\nclass DetectSquares {\\n    int[][] data;\\n    public DetectSquares() {\\n        data=new int[1001][1001]; // array to store count of each point (O(1) lookup in 2-D array)\\n    }\\n    \\n    public void add(int[] point) {\\n        int a=point[0];\\n        int b=point[1];\\n        data[a][b]+=1;\\n    }\\n    \\n    public int count(int[] point) {\\n        int a=point[0];\\n        int b=point[1];\\n        int count=0; // stores count of total squares with one vertex as (a,b)\\n        for(int i=1;i<=1000;i++){  //loop where i denotes square with edge length i , check for square in each of 4 quadrants wrt (a,b)\\n            \\n            if(isValid(a+i,b) && isValid(a,b+i) && isValid(a+i,b+i)){\\n                count+=(data[a+i][b]*data[a][b+i]*data[a+i][b+i]);\\n            }\\n            if(isValid(a+i,b) && isValid(a,b-i) && isValid(a+i,b-i)){\\n                count+=(data[a+i][b]*data[a][b-i]*data[a+i][b-i]);\\n            }\\n            if(isValid(a-i,b) && isValid(a,b+i) && isValid(a-i,b+i)){\\n                count+=(data[a-i][b]*data[a][b+i]*data[a-i][b+i]);\\n            }\\n            if(isValid(a-i,b) && isValid(a,b-i) && isValid(a-i,b-i)){\\n                count+=(data[a-i][b]*data[a][b-i]*data[a-i][b-i]);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    public boolean isValid(int x,int y){\\n        if(x>=0 && x<=1000 && y>=0 && y<=1000) return true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass DetectSquares {\\n    int[][] data;\\n    public DetectSquares() {\\n        data=new int[1001][1001]; // array to store count of each point (O(1) lookup in 2-D array)\\n    }\\n    \\n    public void add(int[] point) {\\n        int a=point[0];\\n        int b=point[1];\\n        data[a][b]+=1;\\n    }\\n    \\n    public int count(int[] point) {\\n        int a=point[0];\\n        int b=point[1];\\n        int count=0; // stores count of total squares with one vertex as (a,b)\\n        for(int i=1;i<=1000;i++){  //loop where i denotes square with edge length i , check for square in each of 4 quadrants wrt (a,b)\\n            \\n            if(isValid(a+i,b) && isValid(a,b+i) && isValid(a+i,b+i)){\\n                count+=(data[a+i][b]*data[a][b+i]*data[a+i][b+i]);\\n            }\\n            if(isValid(a+i,b) && isValid(a,b-i) && isValid(a+i,b-i)){\\n                count+=(data[a+i][b]*data[a][b-i]*data[a+i][b-i]);\\n            }\\n            if(isValid(a-i,b) && isValid(a,b+i) && isValid(a-i,b+i)){\\n                count+=(data[a-i][b]*data[a][b+i]*data[a-i][b+i]);\\n            }\\n            if(isValid(a-i,b) && isValid(a,b-i) && isValid(a-i,b-i)){\\n                count+=(data[a-i][b]*data[a][b-i]*data[a-i][b-i]);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    public boolean isValid(int x,int y){\\n        if(x>=0 && x<=1000 && y>=0 && y<=1000) return true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472093,
                "title": "c-using-map",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>, int>mp;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[{point[0], point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        int ans = 0;\\n        for(auto itr : mp)\\n        {\\n            pair<int,int>p = itr.first;\\n            if(p.first != point[0] and p.second != point[1] and (abs(point[0] - p.first) == abs(point[1] - p.second)))\\n            {\\n                int first = mp[{p.first, p.second}];\\n                int second = mp[{p.first, point[1]}];\\n                int third = mp[{point[0], p.second}];\\n                \\n                int cur = first * second * third;\\n                ans += cur;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>, int>mp;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[{point[0], point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        int ans = 0;\\n        for(auto itr : mp)\\n        {\\n            pair<int,int>p = itr.first;\\n            if(p.first != point[0] and p.second != point[1] and (abs(point[0] - p.first) == abs(point[1] - p.second)))\\n            {\\n                int first = mp[{p.first, p.second}];\\n                int second = mp[{p.first, point[1]}];\\n                int third = mp[{point[0], p.second}];\\n                \\n                int cur = first * second * third;\\n                ans += cur;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1471989,
                "title": "c-easy-map",
                "content": "Finding the diagonal elements which lie in the same line as the given point (both left & right) and finding whether the other two vertices exist\\n\\nThe two diagonals of a square which lies parallel to the axis are in the form of (x+y=k),(x-y=k)\\n\\nso we used two maps\\n\\n```\\nclass DetectSquares {\\npublic:\\n    map<int,vector<pair<int,int>>>sum,diff;\\n    int arr[1002][1002];\\n    DetectSquares() {\\n        sum.clear();\\n        diff.clear();\\n        memset(arr, 0, sizeof(arr[0][0]) * 1002 * 1002);\\n    }\\n    \\n    void add(vector<int> point) {\\n        sum[point[0]+point[1]].push_back({point[0],point[1]});\\n        diff[point[0]-point[1]].push_back({point[0],point[1]});\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x=point[0];\\n        int y=point[1];\\n        int ans=0;\\n        for(auto temp:sum[x+y]){\\n            if(temp.first==x&&temp.second==y)\\n                continue;\\n           if(abs(temp.first-x)==abs(temp.second-y))\\n                ans+= (arr[temp.first][y]*arr[x][temp.second]);\\n        }\\n        for(auto temp:diff[x-y]){\\n            if(temp.first==x&&temp.second==y)\\n                continue;\\n            if(abs(temp.first-x)==abs(temp.second-y))\\n                ans+= (arr[temp.first][y]*arr[x][temp.second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<int,vector<pair<int,int>>>sum,diff;\\n    int arr[1002][1002];\\n    DetectSquares() {\\n        sum.clear();\\n        diff.clear();\\n        memset(arr, 0, sizeof(arr[0][0]) * 1002 * 1002);\\n    }\\n    \\n    void add(vector<int> point) {\\n        sum[point[0]+point[1]].push_back({point[0],point[1]});\\n        diff[point[0]-point[1]].push_back({point[0],point[1]});\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x=point[0];\\n        int y=point[1];\\n        int ans=0;\\n        for(auto temp:sum[x+y]){\\n            if(temp.first==x&&temp.second==y)\\n                continue;\\n           if(abs(temp.first-x)==abs(temp.second-y))\\n                ans+= (arr[temp.first][y]*arr[x][temp.second]);\\n        }\\n        for(auto temp:diff[x-y]){\\n            if(temp.first==x&&temp.second==y)\\n                continue;\\n            if(abs(temp.first-x)==abs(temp.second-y))\\n                ans+= (arr[temp.first][y]*arr[x][temp.second]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732491,
                "title": "java-explained-how-to-form-square-use-diagonal-properties",
                "content": "// TC : add() -> O(1) => count() -> O(P) -> P = num of points\\n// SC : O(1000 * 1000) + O(P)\\n```\\nclass DetectSquares {\\n\\n    int[][] countPoints;\\n    List<int[]> points;\\n    public DetectSquares() {\\n        countPoints = new int[1001][1001];\\n        points = new ArrayList<>();\\n    }\\n    \\n    // Since a duplicate point is also handled as a different point so countPoints[][] will increase the cpunt of point\\n    public void add(int[] point) {\\n        countPoints[point[0]][point[1]]++;\\n        points.add(point);\\n    }\\n    \\n    // We first need to find the diagonal of SQUARE (using p1 and p3) and then we can find out if there exist p2 and p4 and multiply their value tp get total square\\n    // p2.x = p3.x, p2.y = p1.y\\n    // p4.x = p1.x, p4.y = p3.y\\n    // Find two coordinates p1 and p3 which are diagnal of square. Here are thr properties of diagnal of sqaure\\n    // 1. Diagonal points DO NOT lie in the same x-axis (so x1 and x3 cant be same to be a diagonal)\\n    // 2. the diff of \\'x\\' and \\'y\\' are equal\\n    public int count(int[] point) {\\n        int res = 0;\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        \\n        for(int[] p3 : points) {\\n            int x3 = p3[0];\\n            int y3 = p3[1];\\n            \\n            if(Math.abs(x1 - x3) == 0 || Math.abs(x1 - x3) != Math.abs(y1 - y3)) {\\n                continue;\\n            }\\n            int x2 = x3, y2 = y1;\\n            int x4 = x1, y4 = y3;\\n            \\n            res += countPoints[x2][y2] * countPoints[x4][y4];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n\\n    int[][] countPoints;\\n    List<int[]> points;\\n    public DetectSquares() {\\n        countPoints = new int[1001][1001];\\n        points = new ArrayList<>();\\n    }\\n    \\n    // Since a duplicate point is also handled as a different point so countPoints[][] will increase the cpunt of point\\n    public void add(int[] point) {\\n        countPoints[point[0]][point[1]]++;\\n        points.add(point);\\n    }\\n    \\n    // We first need to find the diagonal of SQUARE (using p1 and p3) and then we can find out if there exist p2 and p4 and multiply their value tp get total square\\n    // p2.x = p3.x, p2.y = p1.y\\n    // p4.x = p1.x, p4.y = p3.y\\n    // Find two coordinates p1 and p3 which are diagnal of square. Here are thr properties of diagnal of sqaure\\n    // 1. Diagonal points DO NOT lie in the same x-axis (so x1 and x3 cant be same to be a diagonal)\\n    // 2. the diff of \\'x\\' and \\'y\\' are equal\\n    public int count(int[] point) {\\n        int res = 0;\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        \\n        for(int[] p3 : points) {\\n            int x3 = p3[0];\\n            int y3 = p3[1];\\n            \\n            if(Math.abs(x1 - x3) == 0 || Math.abs(x1 - x3) != Math.abs(y1 - y3)) {\\n                continue;\\n            }\\n            int x2 = x3, y2 = y1;\\n            int x4 = x1, y4 = y3;\\n            \\n            res += countPoints[x2][y2] * countPoints[x4][y4];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764859,
                "title": "python3-simple-fast-elegant-beats-90",
                "content": "# Please upvote if helpful!\\n\\n# Approach\\n**Adding Points** - Since duplicate points can be used to form distinct, countable squares, we will use a dictionary to track the number of times that point has been added. In order for us to track the point in a dictionary, it must be hashable, so we will convert the point from a list (non-hashable) to a tuple (hashable).\\n\\n*Note: `defaultdict(int)` defaults to 0 for new values*\\n\\n\\n**Counting Squares** - To reduce the amount of iterating, we loop through the items of `self.points` searching for points that can serve as the opposite corner of a square. For each such point found, we check if `self.points` contains the other two necessary corners. If so, we calculate how many identical squares can be created by multiplying the instances of each of the three points in `self.points`. We add this number to the running count, which we return once the for loop is completed.\\n\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = collections.defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        square_count = 0\\n        x1, y1 = point\\n\\n        for (x2, y2), n in self.points.items():\\n            x_dist, y_dist = abs(x1 - x2), abs(y1 - y2)\\n            if x_dist == y_dist and x_dist > 0:\\n                corner1 = (x1, y2)\\n                corner2 = (x2, y1)\\n                if corner1 in self.points and corner2 in self.points:\\n                    square_count += n * self.points[corner1] * self.points[corner2]\\n\\n        return square_count\\n    \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Design",
                    "Counting"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = collections.defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        square_count = 0\\n        x1, y1 = point\\n\\n        for (x2, y2), n in self.points.items():\\n            x_dist, y_dist = abs(x1 - x2), abs(y1 - y2)\\n            if x_dist == y_dist and x_dist > 0:\\n                corner1 = (x1, y2)\\n                corner2 = (x2, y1)\\n                if corner1 in self.points and corner2 in self.points:\\n                    square_count += n * self.points[corner1] * self.points[corner2]\\n\\n        return square_count\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793191,
                "title": "python-solution-set-square-geometry-o-n-comments",
                "content": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.ptsFreq = defaultdict(int)\\n        self.pts = []\\n        \\n    def add(self, point: List[int]) -> None:\\n        self.pts.append(point)\\n        self.ptsFreq[(*point,)] += 1  # update freq count of this point\\n\\n    def count(self, point: List[int]) -> int:\\n        px, py = point # x & y corrdinate\\n        cnt = 0\\n        \\n        for x, y in self.pts:\\n            # 1. check diagonal option from available points to this given point\\n            if abs(px-x) == abs(py-y):\\n                # 2. Check if distance on diagonal axis between (x,y) & (px,py) is > 0\\n                if px != x:  # (py != y) also gets true (as both distance are same)\\n                    # Found 2 point of Possible square i.e (x,y) & (px,py)\\n                    # need to find 2 more points (x, py) & (px, y)\\n                    cnt += self.ptsFreq[(x, py)] * self.ptsFreq[(px, y)]\\n        \\n        return cnt\\n        \\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.ptsFreq = defaultdict(int)\\n        self.pts = []\\n        \\n    def add(self, point: List[int]) -> None:\\n        self.pts.append(point)\\n        self.ptsFreq[(*point,)] += 1  # update freq count of this point\\n\\n    def count(self, point: List[int]) -> int:\\n        px, py = point # x & y corrdinate\\n        cnt = 0\\n        \\n        for x, y in self.pts:\\n            # 1. check diagonal option from available points to this given point\\n            if abs(px-x) == abs(py-y):\\n                # 2. Check if distance on diagonal axis between (x,y) & (px,py) is > 0\\n                if px != x:  # (py != y) also gets true (as both distance are same)\\n                    # Found 2 point of Possible square i.e (x,y) & (px,py)\\n                    # need to find 2 more points (x, py) & (px, y)\\n                    cnt += self.ptsFreq[(x, py)] * self.ptsFreq[(px, y)]\\n        \\n        return cnt\\n        \\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472327,
                "title": "easy-to-understand-java-single-hashmap-with-intuition",
                "content": "```\\n/**\\n    Intuition: We keep track of points along with the counter in a hashmap during the add method. \\n    Every time count method is called, we iterate through each of the points in the hashmap. \\n    We consider each point from the HashMap (say (x,y)) as a diagonal point to the query \\n    point (say (px, py)). \\n    Since it is given the square needs to be axis-aligned , the condition for two points to \\n    form a axis-aligned square is that, the absolute distance between the x and y coordinates \\n    distances should be equal. If they are not equal it means they will form a rectangle instead\\n    of a square. This is a typical geometry property. Try to visualize it with couple of examples. \\n    Eg: Valid square diagonals are : (3,2) and (11,10) . The absolute coordinate distance \\n    differences are (11 - 3) and (10 - 2) which is 8 is both cases . So these points can form a square. \\n    So assuming these two diagonal points form a square , we construct two other diagonal points for eg: \\n    for diagonal points (x , y) , (px, py) other two diagonal points will be (x, py) , (px, y)\\n    So we check if these two diagonal points are present in map . If they are present we just \\n    count the total squares that can be formed by usign product of each of the diagonal points counts. \\n    \\n    Time Complexity: O(N)\\n    Space Complexity: O(N)\\n    \\n**/\\nclass DetectSquares {\\n\\n    public DetectSquares() {\\n        \\n    }\\n\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public void add(int[] point) {\\n        map.merge(point[0] + \"_\" + point[1], 1 , Integer::sum);\\n    }\\n    \\n    public int count(int[] point) {\\n        int px = point[0];\\n        int py = point[1];\\n        int res = 0; \\n        \\n        for(String key : map.keySet()) {\\n            int x = Integer.parseInt(key.split(\"_\")[0]);\\n            int y = Integer.parseInt(key.split(\"_\")[1]);\\n            \\n            if(Math.abs(x - px) == Math.abs(y - py) && x != px && y != py) {\\n                String diag1 = px + \"_\" + y;\\n                String diag2 = x + \"_\" + py;\\n                if(map.containsKey(diag1) && map.containsKey(diag2)) {\\n                    res += (map.get(diag1) * map.get(diag2) \\n                            * map.get(key));\\n                }    \\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Geometry"
                ],
                "code": "```\\n/**\\n    Intuition: We keep track of points along with the counter in a hashmap during the add method. \\n    Every time count method is called, we iterate through each of the points in the hashmap. \\n    We consider each point from the HashMap (say (x,y)) as a diagonal point to the query \\n    point (say (px, py)). \\n    Since it is given the square needs to be axis-aligned , the condition for two points to \\n    form a axis-aligned square is that, the absolute distance between the x and y coordinates \\n    distances should be equal. If they are not equal it means they will form a rectangle instead\\n    of a square. This is a typical geometry property. Try to visualize it with couple of examples. \\n    Eg: Valid square diagonals are : (3,2) and (11,10) . The absolute coordinate distance \\n    differences are (11 - 3) and (10 - 2) which is 8 is both cases . So these points can form a square. \\n    So assuming these two diagonal points form a square , we construct two other diagonal points for eg: \\n    for diagonal points (x , y) , (px, py) other two diagonal points will be (x, py) , (px, y)\\n    So we check if these two diagonal points are present in map . If they are present we just \\n    count the total squares that can be formed by usign product of each of the diagonal points counts. \\n    \\n    Time Complexity: O(N)\\n    Space Complexity: O(N)\\n    \\n**/\\nclass DetectSquares {\\n\\n    public DetectSquares() {\\n        \\n    }\\n\\n    Map<String, Integer> map = new HashMap<>();\\n    \\n    public void add(int[] point) {\\n        map.merge(point[0] + \"_\" + point[1], 1 , Integer::sum);\\n    }\\n    \\n    public int count(int[] point) {\\n        int px = point[0];\\n        int py = point[1];\\n        int res = 0; \\n        \\n        for(String key : map.keySet()) {\\n            int x = Integer.parseInt(key.split(\"_\")[0]);\\n            int y = Integer.parseInt(key.split(\"_\")[1]);\\n            \\n            if(Math.abs(x - px) == Math.abs(y - py) && x != px && y != py) {\\n                String diag1 = px + \"_\" + y;\\n                String diag2 = x + \"_\" + py;\\n                if(map.containsKey(diag1) && map.containsKey(diag2)) {\\n                    res += (map.get(diag1) * map.get(diag2) \\n                            * map.get(key));\\n                }    \\n            }\\n\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673552,
                "title": "why-this-test-case-is-expected-2",
                "content": "```\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[8,0]],[[9,0]],[[9,8]],[[1,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```\\n![image](https://assets.leetcode.com/users/images/c66e39b9-52bd-4e5e-b9fd-cc0293585e2f_1641580037.2189553.png)\\nMaybe I misunderstand the description. But why the correct anwser for this test case is 2 rather than 3?\\nThere are 3 squares:\\n`[[0,8],[0,0],[8,0],[8,8]]` *2   \\n`[[0,8],[0,0],[9,0],[9,8]]` * 1  \\nSo it should return 3",
                "solutionTags": [],
                "code": "```\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[8,0]],[[9,0]],[[9,8]],[[1,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1480697,
                "title": "no-need-to-complicate-counting-matrix-with-explanation-c",
                "content": "The basic idea is to store the occurences of every point in a 2-d matrix. Whenever we want to count the number of squares that have the given point as a corner, we just check for squares of length 1 to 1000 (max possible length as x,y <= 1000). We have a point on a square and we have the length of side of the square, thus we can obtain the rest of the 3 points. Check the same for all 4 directions and you are good to go!\\n\\n```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> p;\\n    \\n    DetectSquares() {\\n        for(int i = 0; i<1001; i++) {\\n            vector<int> temp(1001, 0);\\n            p.push_back(temp);\\n        }\\n    }\\n    \\n    void add(vector<int> point) {\\n        p[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int res = 0;\\n        int x = point[0], y = point[1];\\n        for(int len = 1; len < 1001; len++) {\\n            if(y + len <= 1000) {\\n                //First Quadrant\\n                if(x + len <= 1000) res += (p[x][y+len]*p[x+len][y]*p[x+len][y+len]);\\n                //Second Quadrant\\n                if(x - len >= 0) res += (p[x][y+len]*p[x-len][y]*p[x-len][y+len]);\\n            }\\n            if(y - len >= 0) {\\n                //Fourth Quadrant\\n                if(x + len <= 1000) res += (p[x][y-len]*p[x+len][y]*p[x+len][y-len]);\\n                //Third Quadrant\\n                if(x - len >= 0) {res += (p[x][y-len]*p[x-len][y]*p[x-len][y-len]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> p;\\n    \\n    DetectSquares() {\\n        for(int i = 0; i<1001; i++) {\\n            vector<int> temp(1001, 0);\\n            p.push_back(temp);\\n        }\\n    }\\n    \\n    void add(vector<int> point) {\\n        p[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int res = 0;\\n        int x = point[0], y = point[1];\\n        for(int len = 1; len < 1001; len++) {\\n            if(y + len <= 1000) {\\n                //First Quadrant\\n                if(x + len <= 1000) res += (p[x][y+len]*p[x+len][y]*p[x+len][y+len]);\\n                //Second Quadrant\\n                if(x - len >= 0) res += (p[x][y+len]*p[x-len][y]*p[x-len][y+len]);\\n            }\\n            if(y - len >= 0) {\\n                //Fourth Quadrant\\n                if(x + len <= 1000) res += (p[x][y-len]*p[x+len][y]*p[x+len][y-len]);\\n                //Third Quadrant\\n                if(x - len >= 0) {res += (p[x][y-len]*p[x-len][y]*p[x-len][y-len]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2577642,
                "title": "python-hashmap-solution",
                "content": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.mapp = {}\\n        \\n    def add(self, point: List[int]) -> None:\\n        if tuple(point) not in self.mapp:\\n            self.mapp[tuple(point)] = 0\\n        self.mapp[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0 \\n        px,py = point\\n        for x,y in self.mapp.keys():\\n            if abs(px - x) != abs(py - y) or px == x or py == y:\\n                continue\\n            if (x,py) in self.mapp and (px,y) in self.mapp:\\n                res += self.mapp[(x,py)] * self.mapp[(px,y)] * self.mapp[(x,y)]\\n        return res \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.mapp = {}\\n        \\n    def add(self, point: List[int]) -> None:\\n        if tuple(point) not in self.mapp:\\n            self.mapp[tuple(point)] = 0\\n        self.mapp[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0 \\n        px,py = point\\n        for x,y in self.mapp.keys():\\n            if abs(px - x) != abs(py - y) or px == x or py == y:\\n                continue\\n            if (x,py) in self.mapp and (px,y) in self.mapp:\\n                res += self.mapp[(x,py)] * self.mapp[(px,y)] * self.mapp[(x,y)]\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219713,
                "title": "java-very-easy-trick-using-hashmap",
                "content": "```\\nMap<String,Integer> pointsCount;\\n    List<int[]> coordinates;\\n    public DetectSquares() {\\n        pointsCount = new HashMap<>();\\n        coordinates = new ArrayList<>();\\n        \\n    }\\n    //store the frequency of all the points, look at the unique way of storing it splitting\\n    //the points int two parts and forming a string of a point\\n    public void add(int[] point) {\\n        coordinates.add(point);\\n        String strCoordinate = point[0] + \"#\" + point[1];\\n        int count = pointsCount.getOrDefault(strCoordinate,0);\\n        pointsCount.put(strCoordinate,++count);\\n    }\\n    \\n    public int count(int[] point) {\\n        int total=0;\\n        int x=point[0];\\n        int y=point[1];\\n        \\n        for(int[] key : coordinates){\\n            //check if a diagonal point exist whis is having x and y distance as same\\n            if(Math.abs(key[0]-x) !=0 && Math.abs(key[0]-x) == Math.abs(key[1]-y)){\\n                //take y of diagonal and x of current point\\n                String leftCoordinate = key[0] + \"#\" + y;\\n                //take x of diagonal and y of current point\\n                String rightCoordinate = x + \"#\" + key[1];\\n                total+=pointsCount.getOrDefault(leftCoordinate,0)\\n                    * pointsCount.getOrDefault(rightCoordinate,0);\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nMap<String,Integer> pointsCount;\\n    List<int[]> coordinates;\\n    public DetectSquares() {\\n        pointsCount = new HashMap<>();\\n        coordinates = new ArrayList<>();\\n        \\n    }\\n    //store the frequency of all the points, look at the unique way of storing it splitting\\n    //the points int two parts and forming a string of a point\\n    public void add(int[] point) {\\n        coordinates.add(point);\\n        String strCoordinate = point[0] + \"#\" + point[1];\\n        int count = pointsCount.getOrDefault(strCoordinate,0);\\n        pointsCount.put(strCoordinate,++count);\\n    }\\n    \\n    public int count(int[] point) {\\n        int total=0;\\n        int x=point[0];\\n        int y=point[1];\\n        \\n        for(int[] key : coordinates){\\n            //check if a diagonal point exist whis is having x and y distance as same\\n            if(Math.abs(key[0]-x) !=0 && Math.abs(key[0]-x) == Math.abs(key[1]-y)){\\n                //take y of diagonal and x of current point\\n                String leftCoordinate = key[0] + \"#\" + y;\\n                //take x of diagonal and y of current point\\n                String rightCoordinate = x + \"#\" + key[1];\\n                total+=pointsCount.getOrDefault(leftCoordinate,0)\\n                    * pointsCount.getOrDefault(rightCoordinate,0);\\n            }\\n        }\\n        return total;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1472016,
                "title": "c-using-map-count-points-easy-and-clean-solution",
                "content": "idea:\\nwith the given point find another vertex in existing points that are diagonally opposite to this point i.e, for each point just check that the X and Y difference is getting equal or not.\\n```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,long> m;\\n    DetectSquares() {   \\n    }\\n    \\n    void add(vector<int> p) {\\n        m[{p[0],p[1]}]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        long ans=0;\\n        for(auto x:m)\\n        {\\n            int a=x.first.first,b=x.first.second;\\n            if(a==p[0] and b==p[1])continue;\\n            int c=x.second;\\n             if(abs(a-p[0])==abs(b-p[1]))\\n\\t\\t\\t\\t\\tans+=(c)*m[{a,p[1]}]*m[{p[0],b}];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,long> m;\\n    DetectSquares() {   \\n    }\\n    \\n    void add(vector<int> p) {\\n        m[{p[0],p[1]}]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        long ans=0;\\n        for(auto x:m)\\n        {\\n            int a=x.first.first,b=x.first.second;\\n            if(a==p[0] and b==p[1])continue;\\n            int c=x.second;\\n             if(abs(a-p[0])==abs(b-p[1]))\\n\\t\\t\\t\\t\\tans+=(c)*m[{a,p[1]}]*m[{p[0],b}];\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695655,
                "title": "c-using-map-with-comments-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n      map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x1=point[0];\\n        int y1=point[1];\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x2 = (it->first).first;\\n            int y2 = (it->first).second;\\n            //the first two condition checks if the point coincides\\n            // if it does not coincide , then 3rd condition finds a diagnol point of a square .\\n            // the 4th and 5th condition finds two points corresponding to that diagnol to form a square. \\n            // if all conditions are satisfied , we muntiply the count of these 3 points and add to count. \\n            if(x1!=x2 && y1!=y2 && abs(x1-x2)==abs(y1-y2) && mp.find({x1,y2})!=mp.end() && mp.find({x2,y1})!=mp.end())\\n            {\\n                int c1 = mp[{x2,y2}];\\n                int c2 = mp[{x2,y1}];\\n                int c3 = mp[{x1,y2}];\\n                count += c1*c2*c3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n      map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x1=point[0];\\n        int y1=point[1];\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x2 = (it->first).first;\\n            int y2 = (it->first).second;\\n            //the first two condition checks if the point coincides\\n            // if it does not coincide , then 3rd condition finds a diagnol point of a square .\\n            // the 4th and 5th condition finds two points corresponding to that diagnol to form a square. \\n            // if all conditions are satisfied , we muntiply the count of these 3 points and add to count. \\n            if(x1!=x2 && y1!=y2 && abs(x1-x2)==abs(y1-y2) && mp.find({x1,y2})!=mp.end() && mp.find({x2,y1})!=mp.end())\\n            {\\n                int c1 = mp[{x2,y2}];\\n                int c2 = mp[{x2,y1}];\\n                int c3 = mp[{x1,y2}];\\n                count += c1*c2*c3;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622687,
                "title": "c-easy-to-understand-short",
                "content": "```\\nclass DetectSquares {\\n    unordered_map<int, unordered_map<int,int>> graph;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        graph[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0, x1 = point[0], y1 = point[1];\\n        \\n        for(auto &y2 : graph[x1]){\\n            if(y2.first == y1)\\n                continue;\\n            int diff = abs(y1 - y2.first);\\n            int xL = point[0] - diff;\\n            int xR = point[0] + diff;\\n            count += graph[xL][point[1]] * graph[xL][y2.first] * y2.second;\\n            count += graph[xR][point[1]] * graph[xR][y2.first] * y2.second; \\n        }\\n        return count;\\n        \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    unordered_map<int, unordered_map<int,int>> graph;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        graph[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0, x1 = point[0], y1 = point[1];\\n        \\n        for(auto &y2 : graph[x1]){\\n            if(y2.first == y1)\\n                continue;\\n            int diff = abs(y1 - y2.first);\\n            int xL = point[0] - diff;\\n            int xR = point[0] + diff;\\n            count += graph[xL][point[1]] * graph[xL][y2.first] * y2.second;\\n            count += graph[xR][point[1]] * graph[xR][y2.first] * y2.second; \\n        }\\n        return count;\\n        \\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2127484,
                "title": "c-solution-with-lookup-matrix",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    int points[1001][1001] = { 0 };\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int result = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        \\n        for (int i = 0; i <= 1000; i++)\\n        {\\n            if (i != x && points[i][y] > 0)\\n            {\\n                int len = abs(i - x);\\n                if (y + len <= 1000)\\n                {\\n                    result += points[i][y] * points[i][y+len] * points[x][y+len];\\n                }\\n                \\n                if (y - len >= 0)\\n                {\\n                    result += points[i][y] * points[i][y-len] * points[x][y-len];\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    int points[1001][1001] = { 0 };\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int result = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        \\n        for (int i = 0; i <= 1000; i++)\\n        {\\n            if (i != x && points[i][y] > 0)\\n            {\\n                int len = abs(i - x);\\n                if (y + len <= 1000)\\n                {\\n                    result += points[i][y] * points[i][y+len] * points[x][y+len];\\n                }\\n                \\n                if (y - len >= 0)\\n                {\\n                    result += points[i][y] * points[i][y-len] * points[x][y-len];\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969409,
                "title": "super-easy-to-understand-javascript-solution",
                "content": "```\\nclass DetectSquares {\\n    constructor() {\\n        this.points = new Map();\\n    }\\n    \\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\n    add(point) {\\n        const savedPoint = this.points.has(`${point[0]}_${point[1]}`) ?\\n              this.points.get(`${point[0]}_${point[1]}`) :\\n              {x: point[0], y: point[1], count: 0};;\\n        \\n        savedPoint.count = savedPoint.count + 1;\\n        \\n        this.points.set(`${point[0]}_${point[1]}`, savedPoint);\\n    }\\n    \\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\n    count(point) {\\n        let count = 0;\\n        \\n        for(const diagPoint of this.points.values()) {\\n            // if you are at the same x or y, you are not diagonal to me, and we cant form a square\\n            if(diagPoint.x === point[0] || diagPoint.y === point[1]) continue;\\n            \\n            // you might be diagonal to me, but do we form a square?\\n            if(Math.abs(diagPoint.x - point[0]) !== Math.abs(diagPoint.y - point[1])) continue;\\n            \\n            // we a 100% form a square\\n            const point1 = this.points.get(`${diagPoint.x}_${point[1]}`);\\n            const point2 = this.points.get(`${point[0]}_${diagPoint.y}`);\\n            \\n            // but do our missing points exist?\\n            if(!point1 || !point2) continue;\\n            \\n            count = count + point1.count * point2.count * diagPoint.count;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass DetectSquares {\\n    constructor() {\\n        this.points = new Map();\\n    }\\n    \\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\n    add(point) {\\n        const savedPoint = this.points.has(`${point[0]}_${point[1]}`) ?\\n              this.points.get(`${point[0]}_${point[1]}`) :\\n              {x: point[0], y: point[1], count: 0};;\\n        \\n        savedPoint.count = savedPoint.count + 1;\\n        \\n        this.points.set(`${point[0]}_${point[1]}`, savedPoint);\\n    }\\n    \\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\n    count(point) {\\n        let count = 0;\\n        \\n        for(const diagPoint of this.points.values()) {\\n            // if you are at the same x or y, you are not diagonal to me, and we cant form a square\\n            if(diagPoint.x === point[0] || diagPoint.y === point[1]) continue;\\n            \\n            // you might be diagonal to me, but do we form a square?\\n            if(Math.abs(diagPoint.x - point[0]) !== Math.abs(diagPoint.y - point[1])) continue;\\n            \\n            // we a 100% form a square\\n            const point1 = this.points.get(`${diagPoint.x}_${point[1]}`);\\n            const point2 = this.points.get(`${point[0]}_${diagPoint.y}`);\\n            \\n            // but do our missing points exist?\\n            if(!point1 || !point2) continue;\\n            \\n            count = count + point1.count * point2.count * diagPoint.count;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819978,
                "title": "python-count-o-n",
                "content": "I think we only have to maintain 1 dict, instead of a \"cnt\" and  a \"y\".\\nJust check all the points as the diagonal point in the square. It\\'s also O(N)\\nCheck the code.\\n\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[(point[0], point[1])] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        x0, y0 = point[0], point[1] \\n        cnt = 0\\n        for p in self.points:\\n            x1, y1 = p[0], p[1]\\n            if abs(x1-x0) == abs(y1-y0) and x0!=x1 and (x0,y1) in self.points and (x1,y0) in self.points:\\n                cnt += self.points[(x1, y1)] * self.points[(x0, y1)] * self.points[(x1, y0)]\\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[(point[0], point[1])] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        x0, y0 = point[0], point[1] \\n        cnt = 0\\n        for p in self.points:\\n            x1, y1 = p[0], p[1]\\n            if abs(x1-x0) == abs(y1-y0) and x0!=x1 and (x0,y1) in self.points and (x1,y0) in self.points:\\n                cnt += self.points[(x1, y1)] * self.points[(x0, y1)] * self.points[(x1, y0)]\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815495,
                "title": "java-single-map-beats-80",
                "content": "```\\nMap<Integer, Map<Integer, Integer>> map = new HashMap<>();\\npublic DetectSquares() {\\n}\\n\\npublic void add(int[] point) {\\n\\tmap.putIfAbsent(point[0], new HashMap<>());\\n\\tMap<Integer, Integer> xToYMap = map.get(point[0]);\\n\\txToYMap.put(point[1], xToYMap.getOrDefault(point[1], 0) + 1);\\n}\\n\\npublic int count(int[] point) {\\n\\tint x = point[0], y = point[1];\\n\\tif (!map.containsKey(x)) return 0;\\n\\n\\tint res = 0;\\n\\tfor (int potentialY : map.get(x).keySet()) {\\n\\t\\tif (potentialY == y) continue;\\n\\t\\tint len = Math.abs(potentialY - y);\\n\\t\\tint potentialX1 = x - len;\\n\\t\\tint potentialX2 = x + len;\\n\\t\\tif (map.containsKey(potentialX1)) {\\n\\t\\t\\tres += map.get(x).get(potentialY) * map.get(potentialX1).getOrDefault(y, 0) * \\n\\t\\t\\t\\tmap.get(potentialX1).getOrDefault(potentialY, 0);\\n\\t\\t}\\n\\t\\tif (map.containsKey(potentialX2)) {\\n\\t\\t\\tres += map.get(x).get(potentialY) * map.get(potentialX2).getOrDefault(y, 0) * \\n\\t\\t\\t\\tmap.get(potentialX2).getOrDefault(potentialY, 0);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nMap<Integer, Map<Integer, Integer>> map = new HashMap<>();\\npublic DetectSquares() {\\n}\\n\\npublic void add(int[] point) {\\n\\tmap.putIfAbsent(point[0], new HashMap<>());\\n\\tMap<Integer, Integer> xToYMap = map.get(point[0]);\\n\\txToYMap.put(point[1], xToYMap.getOrDefault(point[1], 0) + 1);\\n}\\n\\npublic int count(int[] point) {\\n\\tint x = point[0], y = point[1];\\n\\tif (!map.containsKey(x)) return 0;\\n\\n\\tint res = 0;\\n\\tfor (int potentialY : map.get(x).keySet()) {\\n\\t\\tif (potentialY == y) continue;\\n\\t\\tint len = Math.abs(potentialY - y);\\n\\t\\tint potentialX1 = x - len;\\n\\t\\tint potentialX2 = x + len;\\n\\t\\tif (map.containsKey(potentialX1)) {\\n\\t\\t\\tres += map.get(x).get(potentialY) * map.get(potentialX1).getOrDefault(y, 0) * \\n\\t\\t\\t\\tmap.get(potentialX1).getOrDefault(potentialY, 0);\\n\\t\\t}\\n\\t\\tif (map.containsKey(potentialX2)) {\\n\\t\\t\\tres += map.get(x).get(potentialY) * map.get(potentialX2).getOrDefault(y, 0) * \\n\\t\\t\\t\\tmap.get(potentialX2).getOrDefault(potentialY, 0);\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1745200,
                "title": "semi-intuitive-javascript-solution",
                "content": "Not a lot of Javascript solution on this question, so I thought I\\'d add to the discussions. I struggled with this one for a bit, but decided to share my approach to see if it helps anyone else out. \\uD83D\\uDE04\\n\\n**Approach**\\n- Keep track of the frequency or number of times of each `(x, y)` combinations in an object\\n- When `count(x1, y1)` is called\\n\\t- Iterate through all  `y` values stored at that same `x1` value ( `y2` in code).\\n\\t- Calculate the vertical distance between `y1` and each `y1`  (`const w = Math.abs(y1 - y2)`). Given that the all sides of the square are the same, you can calculate the expected horizontal values in our map `x1 - w`.\\n\\t- Check both the positive and negative distances between the points: \\n\\t\\t-  Negative `w` - Multiply the frequency for each of the points `[x1 - w][y1]` and `[x1 - w][y2]` and `[x1][y2]`\\n\\t\\t-  Positive `w` - Multiply the frequency for each of the points `[x1 + w][y1]` and `[x1 + w][y2]` and `[x1][y2]`\\n- Return the total count.\\n\\nHash Map Example:\\n```\\n{ \\'3\\': { \\'2\\': 1, \\'10\\': 1 }, \\'11\\': { \\'2\\': 2 } }\\n```\\n\\n\\n**Solution**\\n```\\nconst DetectSquares = function() {\\n    this.hashMap = {}; \\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\nDetectSquares.prototype.add = function(point) {\\n    const [x, y] = point; \\n    if(!this.hashMap[x] || !this.hashMap[x][y]) this.hashMap[x] = {...this.hashMap[x], [y]: 0}\\n    this.hashMap[x][y]++;\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\nDetectSquares.prototype.count = function(point) {\\n    const [x1, y1] = point; \\n    let count = 0;\\n    \\n    // Check for shared \\'x\\' values. \\n    // Cannot form a Square if you do not share any \\'x\\' values at \\'x1\\'\\n    if(this.hashMap[x1]) {\\n        // Iterate through all y values at each x1 value \\n        Object.keys(this.hashMap[x1]).forEach(y2 => {\\n            // Calculate vertical distance between y1 and y2\\n            const w = Math.abs(y1 - y2);\\n            \\n            // If the distance is greater than 0, then we have a positive area\\n            if (w > 0) {\\n                // Since we are tracking the frequency of each point at each x1, y1 value\\n                // We can multiply the occurrences at each point.\\n                if(this.hashMap[x1 - w] && this.hashMap[x1 - w][y2] && this.hashMap[x1 - w][y1]) {\\n                    count += this.hashMap[x1 - w][y1] * this.hashMap[x1 - w][y2] * this.hashMap[x1][y2];\\n                }\\n                if(this.hashMap[x1 + w] && this.hashMap[x1 + w][y2] && this.hashMap[x1 + w][y1]) {\\n                    count += this.hashMap[x1 + w][y1] * this.hashMap[x1 + w][y2] * this.hashMap[x1][y2];\\n                }\\n                    \\n            }\\n        })\\n    }\\n    \\n    return count;\\n};\\n```\\n\\nRuntime: 249 ms, faster than 83.59% of JavaScript online submissions for Detect Squares.\\nMemory Usage: 62.4 MB, less than 25.00% of JavaScript online submissions for Detect Squares.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n{ \\'3\\': { \\'2\\': 1, \\'10\\': 1 }, \\'11\\': { \\'2\\': 2 } }\\n```\n```\\nconst DetectSquares = function() {\\n    this.hashMap = {}; \\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\nDetectSquares.prototype.add = function(point) {\\n    const [x, y] = point; \\n    if(!this.hashMap[x] || !this.hashMap[x][y]) this.hashMap[x] = {...this.hashMap[x], [y]: 0}\\n    this.hashMap[x][y]++;\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\nDetectSquares.prototype.count = function(point) {\\n    const [x1, y1] = point; \\n    let count = 0;\\n    \\n    // Check for shared \\'x\\' values. \\n    // Cannot form a Square if you do not share any \\'x\\' values at \\'x1\\'\\n    if(this.hashMap[x1]) {\\n        // Iterate through all y values at each x1 value \\n        Object.keys(this.hashMap[x1]).forEach(y2 => {\\n            // Calculate vertical distance between y1 and y2\\n            const w = Math.abs(y1 - y2);\\n            \\n            // If the distance is greater than 0, then we have a positive area\\n            if (w > 0) {\\n                // Since we are tracking the frequency of each point at each x1, y1 value\\n                // We can multiply the occurrences at each point.\\n                if(this.hashMap[x1 - w] && this.hashMap[x1 - w][y2] && this.hashMap[x1 - w][y1]) {\\n                    count += this.hashMap[x1 - w][y1] * this.hashMap[x1 - w][y2] * this.hashMap[x1][y2];\\n                }\\n                if(this.hashMap[x1 + w] && this.hashMap[x1 + w][y2] && this.hashMap[x1 + w][y1]) {\\n                    count += this.hashMap[x1 + w][y1] * this.hashMap[x1 + w][y2] * this.hashMap[x1][y2];\\n                }\\n                    \\n            }\\n        })\\n    }\\n    \\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1684103,
                "title": "java-simple-solution-beats-99-with-custom-wrapper-to-hide-map-logic",
                "content": "Instead of trying to loop through every point that exists or every point that *might* exist we maintain the points in a two-layer HashMap. This lets us loop through ONLY the points which actually exist! We also can ignore all points except for one axis since there has to be a match on one of axis (in this case, X) in order to justify even checking the other axis.\\n\\nThere is no specific reason the Map has to be X-dominant, this function would work the same if we instead structured it around the Y-axis.\\n\\n```\\nclass DetectSquares {\\n\\n    // Custom wrapper for Map<Integer, Map<Integer, Integer>>\\n\\t// Structured as Map<int x, Map<int y, int count>>\\n    private PointMap pm;\\n\\n    public DetectSquares() {\\n        pm = new PointMap();\\n    }\\n    \\n    public void add(int[] point) {\\n        pm.add(point[0], point[1]);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int result = 0;\\n\\t\\t//  Entries consist of all Y-axis positions and counts, for all points matching this X-axis position\\n        for (Map.Entry<Integer, Integer> p2 : pm.getPoints(x1)) {\\n            int y2 = p2.getKey();\\n            int count1 = p2.getValue();\\n            if (y1 == y2) {\\n                // Don\\'t try to make squares with 0-length sides\\n                continue;\\n            }\\n            // No need to Math.abs() here - Doesn\\'t really matter whether \\n            // this is positive or negative since we use both values\\n            int distance = y2 - y1;\\n            // Need to check for squares in both directions\\n            int x2 = x1 + distance;\\n            int x3 = x1 - distance;\\n            // Calculate how many squares can be constructed\\n\\t\\t\\t// Both squares start with two known values - [x1,y1] provided by the function call\\n\\t\\t\\t// And [x1,y2] which started this loop\\n\\t\\t\\t// We then combine these by querying for counts of [x2,y1] and [x2,y2]\\n            result += count1 * pm.getCount(x2, y1) * pm.getCount(x2, y2);\\n\\t\\t\\t// And again - this time in the opposite direction, searching for [x3,y1] and [x3,y2]\\n            result += count1 * pm.getCount(x3, y1) * pm.getCount(x3, y2);\\n        }\\n        return result;\\n    }\\n}\\n\\n// This class is just useful to isolate all the Map-traversal\\n// code rather than doing it all inline.\\nclass PointMap {\\n\\t// Map<int x, Map<int y, int count>>\\n    private Map<Integer, Map<Integer, Integer>> points;\\n    \\n    public PointMap() {\\n        points = new HashMap<>();\\n    }\\n    \\n    public void add(int x, int y) {\\n        var yMap = points.get(x);\\n        if(yMap == null) {\\n            yMap = new HashMap<>();\\n        }\\n        yMap.put(y, yMap.getOrDefault(y, 0) +1);\\n        points.put(x, yMap);\\n    }\\n    \\n    public int getCount(int x, int y) {\\n        var yMap = points.get(x);\\n        if(yMap != null) {\\n            return yMap.getOrDefault(y, 0);\\n        }\\n        return 0;\\n    }\\n\\n\\t// Get all counts for points along this point on the X axis, indexed by Y position\\n    public Set<Map.Entry<Integer, Integer>> getPoints(int x) {\\n        if(points.get(x) == null) {\\n            return new HashSet<>();\\n        }\\n        return points.get(x).entrySet();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n\\n    // Custom wrapper for Map<Integer, Map<Integer, Integer>>\\n\\t// Structured as Map<int x, Map<int y, int count>>\\n    private PointMap pm;\\n\\n    public DetectSquares() {\\n        pm = new PointMap();\\n    }\\n    \\n    public void add(int[] point) {\\n        pm.add(point[0], point[1]);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int result = 0;\\n\\t\\t//  Entries consist of all Y-axis positions and counts, for all points matching this X-axis position\\n        for (Map.Entry<Integer, Integer> p2 : pm.getPoints(x1)) {\\n            int y2 = p2.getKey();\\n            int count1 = p2.getValue();\\n            if (y1 == y2) {\\n                // Don\\'t try to make squares with 0-length sides\\n                continue;\\n            }\\n            // No need to Math.abs() here - Doesn\\'t really matter whether \\n            // this is positive or negative since we use both values\\n            int distance = y2 - y1;\\n            // Need to check for squares in both directions\\n            int x2 = x1 + distance;\\n            int x3 = x1 - distance;\\n            // Calculate how many squares can be constructed\\n\\t\\t\\t// Both squares start with two known values - [x1,y1] provided by the function call\\n\\t\\t\\t// And [x1,y2] which started this loop\\n\\t\\t\\t// We then combine these by querying for counts of [x2,y1] and [x2,y2]\\n            result += count1 * pm.getCount(x2, y1) * pm.getCount(x2, y2);\\n\\t\\t\\t// And again - this time in the opposite direction, searching for [x3,y1] and [x3,y2]\\n            result += count1 * pm.getCount(x3, y1) * pm.getCount(x3, y2);\\n        }\\n        return result;\\n    }\\n}\\n\\n// This class is just useful to isolate all the Map-traversal\\n// code rather than doing it all inline.\\nclass PointMap {\\n\\t// Map<int x, Map<int y, int count>>\\n    private Map<Integer, Map<Integer, Integer>> points;\\n    \\n    public PointMap() {\\n        points = new HashMap<>();\\n    }\\n    \\n    public void add(int x, int y) {\\n        var yMap = points.get(x);\\n        if(yMap == null) {\\n            yMap = new HashMap<>();\\n        }\\n        yMap.put(y, yMap.getOrDefault(y, 0) +1);\\n        points.put(x, yMap);\\n    }\\n    \\n    public int getCount(int x, int y) {\\n        var yMap = points.get(x);\\n        if(yMap != null) {\\n            return yMap.getOrDefault(y, 0);\\n        }\\n        return 0;\\n    }\\n\\n\\t// Get all counts for points along this point on the X axis, indexed by Y position\\n    public Set<Map.Entry<Integer, Integer>> getPoints(int x) {\\n        if(points.get(x) == null) {\\n            return new HashSet<>();\\n        }\\n        return points.get(x).entrySet();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645355,
                "title": "c-easy-and-clean-solution-using-dictionary-add-o-1-count-o-n",
                "content": "```\\npublic class DetectSquares {\\n    // two-dimensional dictionary where the first dictionary key is x coordinate, \\n    // the second dictionary is y coordinate and value is the count of points\\n    private IDictionary<int, IDictionary<int, int>> _pointsDict;\\n\\n    public DetectSquares() {\\n        _pointsDict = new Dictionary<int, IDictionary<int, int>>();\\n    }\\n    \\n    public void Add(int[] point) {\\n        var x = point[0];\\n        var y = point[1];\\n        \\n        if(!_pointsDict.ContainsKey(x)) {\\n            _pointsDict[x] = new Dictionary<int, int>();\\n        }\\n        \\n        _pointsDict[x][y] = (_pointsDict[x].ContainsKey(y) ? _pointsDict[x][y] : 0) + 1;\\n    }\\n    \\n    public int Count(int[] point) {\\n        var inputX = point[0];\\n        var inputY = point[1];\\n        \\n        // if there aren\\'t points which can form squares \\n        if(!_pointsDict.ContainsKey(inputX)) return 0;\\n        \\n        var totalCount = 0;\\n        \\n        // checking all points on the same Y-vertical \\n        // whether possible to detect square and count them\\n        foreach(var pair in _pointsDict[inputX]) {\\n            var currentY = pair.Key;\\n            \\n            var sideLength = Math.Abs(currentY - inputY);\\n            \\n            // skip the same point\\n            if(sideLength == 0) continue;\\n            \\n            // count squares on the left side of Y-vertical \\n            totalCount += GetPointsCount(inputX, currentY) * GetPointsCount(inputX - sideLength, currentY) * GetPointsCount(inputX - sideLength, inputY);\\n             \\n            // count squares on the right side of Y-vertical  \\n            totalCount += GetPointsCount(inputX, currentY) * GetPointsCount(inputX + sideLength, currentY) * GetPointsCount(inputX + sideLength, inputY);\\n        }\\n        \\n        return totalCount;\\n    }\\n    \\n    private int GetPointsCount(int x, int y) {\\n        if(!_pointsDict.ContainsKey(x)) return 0;\\n        if(!_pointsDict[x].ContainsKey(y)) return 0;\\n        \\n        return _pointsDict[x][y];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic class DetectSquares {\\n    // two-dimensional dictionary where the first dictionary key is x coordinate, \\n    // the second dictionary is y coordinate and value is the count of points\\n    private IDictionary<int, IDictionary<int, int>> _pointsDict;\\n\\n    public DetectSquares() {\\n        _pointsDict = new Dictionary<int, IDictionary<int, int>>();\\n    }\\n    \\n    public void Add(int[] point) {\\n        var x = point[0];\\n        var y = point[1];\\n        \\n        if(!_pointsDict.ContainsKey(x)) {\\n            _pointsDict[x] = new Dictionary<int, int>();\\n        }\\n        \\n        _pointsDict[x][y] = (_pointsDict[x].ContainsKey(y) ? _pointsDict[x][y] : 0) + 1;\\n    }\\n    \\n    public int Count(int[] point) {\\n        var inputX = point[0];\\n        var inputY = point[1];\\n        \\n        // if there aren\\'t points which can form squares \\n        if(!_pointsDict.ContainsKey(inputX)) return 0;\\n        \\n        var totalCount = 0;\\n        \\n        // checking all points on the same Y-vertical \\n        // whether possible to detect square and count them\\n        foreach(var pair in _pointsDict[inputX]) {\\n            var currentY = pair.Key;\\n            \\n            var sideLength = Math.Abs(currentY - inputY);\\n            \\n            // skip the same point\\n            if(sideLength == 0) continue;\\n            \\n            // count squares on the left side of Y-vertical \\n            totalCount += GetPointsCount(inputX, currentY) * GetPointsCount(inputX - sideLength, currentY) * GetPointsCount(inputX - sideLength, inputY);\\n             \\n            // count squares on the right side of Y-vertical  \\n            totalCount += GetPointsCount(inputX, currentY) * GetPointsCount(inputX + sideLength, currentY) * GetPointsCount(inputX + sideLength, inputY);\\n        }\\n        \\n        return totalCount;\\n    }\\n    \\n    private int GetPointsCount(int x, int y) {\\n        if(!_pointsDict.ContainsKey(x)) return 0;\\n        if(!_pointsDict[x].ContainsKey(y)) return 0;\\n        \\n        return _pointsDict[x][y];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478878,
                "title": "python3-freq-table",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/acb743eb49f794773b70483bbd90cd6403c367b3) for solutions of weekly 259. \\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.freq = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.freq[point] = 1 + self.freq.get(point, 0)\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0 \\n        x, y = point\\n        for xx, yy in self.freq: \\n            if xx != x and abs(x-xx) == abs(y-yy): \\n                ans += self.freq[xx, yy] * self.freq.get((xx, y), 0) * self.freq.get((x, yy), 0)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.freq = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.freq[point] = 1 + self.freq.get(point, 0)\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0 \\n        x, y = point\\n        for xx, yy in self.freq: \\n            if xx != x and abs(x-xx) == abs(y-yy): \\n                ans += self.freq[xx, yy] * self.freq.get((xx, y), 0) * self.freq.get((x, yy), 0)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472203,
                "title": "c-unordered-map-o-1-simple-clean-and-concise",
                "content": "Create a unordered_map of key as x_coordinate and value as y_coordinate with its count.\\nExample add (1,4), add(1,3), add(1,4), add(2,9) then tha map would be like \\n{\\n{1,{{4,2},{3,1}},\\n{2,{9,1}}\\n};\\nYou will get more by looking into the code below , if you have any doubt please feel free to comment below.\\n```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int,unordered_map<int,int>>mp;\\n    \\n    void add(vector<int> point) {\\n        mp[point[0]][point[1]]+=1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans=0;\\n        int x=point[0];\\n        int y=point[1];\\n        for(auto it=mp[x].begin();it!=mp[x].end();it++){\\n            int y2=(*it).first;\\n            if(y2==y)continue;\\n            int side=abs(y-y2); //length of side of square.\\n            if(mp.find(x-side)!=mp.end()){\\n                if(mp[x-side].find(y)!=mp[x-side].end()&&mp[x-side].find(y2)!=mp[x-side].end()){\\n                    ans+=(mp[x-side][y]*mp[x-side][y2]*(*it).second);\\n                }\\n            }\\n             if(mp.find(x+side)!=mp.end()){\\n                if(mp[x+side].find(y)!=mp[x+side].end()&&mp[x+side].find(y2)!=mp[x+side].end()){\\n                    ans+=(mp[x+side][y]*mp[x+side][y2]*(*it).second);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int,unordered_map<int,int>>mp;\\n    \\n    void add(vector<int> point) {\\n        mp[point[0]][point[1]]+=1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans=0;\\n        int x=point[0];\\n        int y=point[1];\\n        for(auto it=mp[x].begin();it!=mp[x].end();it++){\\n            int y2=(*it).first;\\n            if(y2==y)continue;\\n            int side=abs(y-y2); //length of side of square.\\n            if(mp.find(x-side)!=mp.end()){\\n                if(mp[x-side].find(y)!=mp[x-side].end()&&mp[x-side].find(y2)!=mp[x-side].end()){\\n                    ans+=(mp[x-side][y]*mp[x-side][y2]*(*it).second);\\n                }\\n            }\\n             if(mp.find(x+side)!=mp.end()){\\n                if(mp[x+side].find(y)!=mp[x+side].end()&&mp[x+side].find(y2)!=mp[x+side].end()){\\n                    ans+=(mp[x+side][y]*mp[x+side][y2]*(*it).second);\\n                }\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472067,
                "title": "python-1-dictionary-solution",
                "content": "```python\\ndef __init__(self):\\n\\tself.h = Counter()\\n\\ndef add(self, point: List[int]) -> None:\\n\\tself.h[tuple(point)] += 1\\n\\ndef count(self, point: List[int]) -> int:\\n\\tresult = 0\\n\\tfor x, y in self.h:\\n\\t\\tif abs(x - point[0]) == abs(y - point[1]) and x != point[0]:\\n\\t\\t\\tresult += self.h[(x, y)] * self.h[(x, point[1])] * self.h[(point[0], y)]\\n\\treturn result\\n```",
                "solutionTags": [],
                "code": "```python\\ndef __init__(self):\\n\\tself.h = Counter()\\n\\ndef add(self, point: List[int]) -> None:\\n\\tself.h[tuple(point)] += 1\\n\\ndef count(self, point: List[int]) -> int:\\n\\tresult = 0\\n\\tfor x, y in self.h:\\n\\t\\tif abs(x - point[0]) == abs(y - point[1]) and x != point[0]:\\n\\t\\t\\tresult += self.h[(x, y)] * self.h[(x, point[1])] * self.h[(point[0], y)]\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2796950,
                "title": "c-unordered-map-try-using-square-property",
                "content": "```cpp\\nclass DetectSquares {\\npublic:\\n    const static int nax = 1e3 + 1;\\n    //x, {y, count}\\n    unordered_map<int, unordered_map<int, int>> countMap;\\n    DetectSquares() {\\n        countMap.clear();\\n    }\\n    \\n    void add(const vector<int> &point) {\\n        int x = point[0];\\n        int y = point[1];\\n        if (countMap.find(x) == countMap.end()) countMap[x] = {};\\n        countMap[x][y] = countMap[x][y] + 1;\\n    }\\n    \\n    int count(const vector<int> &point) {\\n        int res = 0;\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        //find point below using same X which we have mapped\\n        for (const auto &entry: countMap[x1]) {\\n            //to avoid processing the same points and building the\\n            //square out of them\\n            int y2 = entry.first;\\n            if (y2 == y1) continue;\\n            int diff = abs(y2 - y1);\\n            //x1 - diff\\n            int x2 = x1 - diff;\\n            if (x2 >= 0) {\\n                res += (countMap[x1][y2] * countMap[x2][y2] * countMap[x2][y1]);\\n            }\\n            x2 = x1 + diff;\\n            if (x2 < 1001)\\n                res += (countMap[x1][y2] * countMap[x2][y2] * countMap[x2][y1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass DetectSquares {\\npublic:\\n    const static int nax = 1e3 + 1;\\n    //x, {y, count}\\n    unordered_map<int, unordered_map<int, int>> countMap;\\n    DetectSquares() {\\n        countMap.clear();\\n    }\\n    \\n    void add(const vector<int> &point) {\\n        int x = point[0];\\n        int y = point[1];\\n        if (countMap.find(x) == countMap.end()) countMap[x] = {};\\n        countMap[x][y] = countMap[x][y] + 1;\\n    }\\n    \\n    int count(const vector<int> &point) {\\n        int res = 0;\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        //find point below using same X which we have mapped\\n        for (const auto &entry: countMap[x1]) {\\n            //to avoid processing the same points and building the\\n            //square out of them\\n            int y2 = entry.first;\\n            if (y2 == y1) continue;\\n            int diff = abs(y2 - y1);\\n            //x1 - diff\\n            int x2 = x1 - diff;\\n            if (x2 >= 0) {\\n                res += (countMap[x1][y2] * countMap[x2][y2] * countMap[x2][y1]);\\n            }\\n            x2 = x1 + diff;\\n            if (x2 < 1001)\\n                res += (countMap[x1][y2] * countMap[x2][y2] * countMap[x2][y1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2402192,
                "title": "python-o-n-nestest-hashmap-solution",
                "content": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.axis_x = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point[0], point[1]\\n        if x not in self.axis_x:\\n            self.axis_x[x] = {}\\n        if y not in self.axis_x[x]:\\n            self.axis_x[x][y] = 0\\n        self.axis_x[x][y] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point[0], point[1]\\n        if x not in self.axis_x:\\n            return 0\\n        res = 0\\n        for p_y in self.axis_x[x]:\\n            if p_y != y:\\n                distance = abs(y - p_y)\\n                l, r = x - distance, x + distance\\n                if l in self.axis_x and y in self.axis_x[l] and p_y in self.axis_x[l]:\\n                    res += self.axis_x[x][p_y] * self.axis_x[l][y] * self.axis_x[l][p_y]\\n                if r in self.axis_x and y in self.axis_x[r] and p_y in self.axis_x[r]:\\n                    res += self.axis_x[x][p_y] * self.axis_x[r][y] * self.axis_x[r][p_y]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.axis_x = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point[0], point[1]\\n        if x not in self.axis_x:\\n            self.axis_x[x] = {}\\n        if y not in self.axis_x[x]:\\n            self.axis_x[x][y] = 0\\n        self.axis_x[x][y] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point[0], point[1]\\n        if x not in self.axis_x:\\n            return 0\\n        res = 0\\n        for p_y in self.axis_x[x]:\\n            if p_y != y:\\n                distance = abs(y - p_y)\\n                l, r = x - distance, x + distance\\n                if l in self.axis_x and y in self.axis_x[l] and p_y in self.axis_x[l]:\\n                    res += self.axis_x[x][p_y] * self.axis_x[l][y] * self.axis_x[l][p_y]\\n                if r in self.axis_x and y in self.axis_x[r] and p_y in self.axis_x[r]:\\n                    res += self.axis_x[x][p_y] * self.axis_x[r][y] * self.axis_x[r][p_y]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2356635,
                "title": "python-counter-solution",
                "content": "```\\nclass DetectSquares:\\n    def __init__(self):\\n        self.ps = Counter()\\n\\n    def add(self, point: List[int]) -> None:\\n        self.ps[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0\\n        x1, y1 = point\\n        for x2, y2 in self.ps:\\n            if abs(x1-x2)==abs(y1-y2) and (x1!=x2 or y1!=y2):\\n                ans += self.ps[(x2, y2)]*self.ps[(x1, y2)]*self.ps[(x2, y1)]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n    def __init__(self):\\n        self.ps = Counter()\\n\\n    def add(self, point: List[int]) -> None:\\n        self.ps[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0\\n        x1, y1 = point\\n        for x2, y2 in self.ps:\\n            if abs(x1-x2)==abs(y1-y2) and (x1!=x2 or y1!=y2):\\n                ans += self.ps[(x2, y2)]*self.ps[(x1, y2)]*self.ps[(x2, y1)]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2355913,
                "title": "faster-than-98-super-fast-and-efficient-solution",
                "content": "```\\nclass PointAndCount{\\n    public int val,count;\\n    PointAndCount(int val,int count){\\n        this.val=val;\\n        this.count=count;\\n    }\\n}\\n\\nclass DetectSquares {\\n    private HashMap<Pair<Integer,Integer>,Integer> pointmap;\\n    private HashMap<Integer,List<PointAndCount>> mapx;\\n    \\n    public DetectSquares() {\\n        pointmap = new HashMap<Pair<Integer,Integer>,Integer>();\\n        mapx = new HashMap<Integer,List<PointAndCount>>();\\n    }\\n    \\n    public void add(int[] point) {\\n        Pair<Integer,Integer> pair = new Pair<>(point[0],point[1]);\\n        pointmap.put(pair,pointmap.getOrDefault(pair,0)+1);\\n        addValuesToMaps(mapx,point);\\n    }\\n    \\n    private void addValuesToMaps(HashMap<Integer,List<PointAndCount>> map,int[] point){\\n        List<PointAndCount> lis = map.getOrDefault(point[0],new ArrayList<PointAndCount>());\\n        int count=0;\\n        PointAndCount y=null;\\n        if(lis.size()==0){\\n            lis.add(new PointAndCount(point[1],1));\\n            map.put(point[0],lis);\\n        }else{\\n            for(PointAndCount ob : lis){\\n                if(ob.val==point[1]){\\n                    y=ob;\\n                    break;\\n                }\\n            }\\n            if(y==null){\\n                y=new PointAndCount(point[1],1);\\n                lis.add(y);\\n            }else\\n                y.count++;\\n        }   \\n    }\\n    \\n    public int count(int[] point) {\\n        int res=0;\\n        List<PointAndCount> lis = mapx.getOrDefault(point[0],new ArrayList<PointAndCount>());\\n        for(PointAndCount ob : lis){\\n            Pair<Integer,Integer> pointa=new Pair<>(ob.val-point[1]+point[0],point[1]);\\n            Pair<Integer,Integer> pointb=new Pair<>(ob.val-point[1]+point[0],ob.val);\\n            \\n            Pair<Integer,Integer> pointc=new Pair<>(-(ob.val-point[1])+point[0],point[1]);\\n            Pair<Integer,Integer> pointd=new Pair<>(-(ob.val-point[1])+point[0],ob.val);\\n            \\n            if((ob.val-point[1])!=0){\\n                res+=pointmap.getOrDefault(pointa,0)*pointmap.getOrDefault(pointb,0)*ob.count;\\n                res+=pointmap.getOrDefault(pointc,0)*pointmap.getOrDefault(pointd,0)*ob.count;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass PointAndCount{\\n    public int val,count;\\n    PointAndCount(int val,int count){\\n        this.val=val;\\n        this.count=count;\\n    }\\n}\\n\\nclass DetectSquares {\\n    private HashMap<Pair<Integer,Integer>,Integer> pointmap;\\n    private HashMap<Integer,List<PointAndCount>> mapx;\\n    \\n    public DetectSquares() {\\n        pointmap = new HashMap<Pair<Integer,Integer>,Integer>();\\n        mapx = new HashMap<Integer,List<PointAndCount>>();\\n    }\\n    \\n    public void add(int[] point) {\\n        Pair<Integer,Integer> pair = new Pair<>(point[0],point[1]);\\n        pointmap.put(pair,pointmap.getOrDefault(pair,0)+1);\\n        addValuesToMaps(mapx,point);\\n    }\\n    \\n    private void addValuesToMaps(HashMap<Integer,List<PointAndCount>> map,int[] point){\\n        List<PointAndCount> lis = map.getOrDefault(point[0],new ArrayList<PointAndCount>());\\n        int count=0;\\n        PointAndCount y=null;\\n        if(lis.size()==0){\\n            lis.add(new PointAndCount(point[1],1));\\n            map.put(point[0],lis);\\n        }else{\\n            for(PointAndCount ob : lis){\\n                if(ob.val==point[1]){\\n                    y=ob;\\n                    break;\\n                }\\n            }\\n            if(y==null){\\n                y=new PointAndCount(point[1],1);\\n                lis.add(y);\\n            }else\\n                y.count++;\\n        }   \\n    }\\n    \\n    public int count(int[] point) {\\n        int res=0;\\n        List<PointAndCount> lis = mapx.getOrDefault(point[0],new ArrayList<PointAndCount>());\\n        for(PointAndCount ob : lis){\\n            Pair<Integer,Integer> pointa=new Pair<>(ob.val-point[1]+point[0],point[1]);\\n            Pair<Integer,Integer> pointb=new Pair<>(ob.val-point[1]+point[0],ob.val);\\n            \\n            Pair<Integer,Integer> pointc=new Pair<>(-(ob.val-point[1])+point[0],point[1]);\\n            Pair<Integer,Integer> pointd=new Pair<>(-(ob.val-point[1])+point[0],ob.val);\\n            \\n            if((ob.val-point[1])!=0){\\n                res+=pointmap.getOrDefault(pointa,0)*pointmap.getOrDefault(pointb,0)*ob.count;\\n                res+=pointmap.getOrDefault(pointc,0)*pointmap.getOrDefault(pointd,0)*ob.count;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298694,
                "title": "python3-clean-code",
                "content": "As we are considering squares, we can specify two squares by two points with the same x (or y) coordinate.\\n\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(lambda: defaultdict(int))\\n        \\n    def add(self, point: List[int]) -> None:\\n        X,Y = point\\n        self.points[X][Y] += 1\\n            \\n    def count(self, point: List[int]) -> int:\\n        X,Y = point\\n        \\n        count = 0\\n        for y in self.points[X]:\\n            size = abs(y-Y)\\n            if size == 0:\\n                continue\\n            count += self.points[X][y]*self.points[(X-size)][y]*self.points[(X-size)][Y]\\n            count += self.points[X][y]*self.points[(X+size)][y]*self.points[(X+size)][Y]\\n            \\n        return count",
                "solutionTags": [],
                "code": "As we are considering squares, we can specify two squares by two points with the same x (or y) coordinate.\\n\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(lambda: defaultdict(int))\\n        \\n    def add(self, point: List[int]) -> None:\\n        X,Y = point\\n        self.points[X][Y] += 1\\n            \\n    def count(self, point: List[int]) -> int:\\n        X,Y = point\\n        \\n        count = 0\\n        for y in self.points[X]:\\n            size = abs(y-Y)\\n            if size == 0:\\n                continue\\n            count += self.points[X][y]*self.points[(X-size)][y]*self.points[(X-size)][Y]\\n            count += self.points[X][y]*self.points[(X+size)][y]*self.points[(X+size)][Y]\\n            \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 2224824,
                "title": "java-hashmap",
                "content": "```\\nclass DetectSquares {\\n    Map<String, Integer> map = new HashMap<>();\\n\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        String key = x + \"#\" + y;\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    }\\n\\n    public int count(int[] point) {\\n        int res = 0;\\n        int px = point[0];\\n        int py = point[1];\\n        for (String key : map.keySet()) {\\n            String[] p = key.split(\"#\");\\n            int x = Integer.parseInt(p[0]);\\n            int y = Integer.parseInt(p[1]);\\n            if (x == px || y == py || Math.abs(x - px) != Math.abs(y - py))\\n                continue;\\n            if (map.containsKey(px + \"#\" + y) && map.containsKey(x + \"#\" + py)) {\\n                res += map.get(x + \"#\" + y) * map.get(px + \"#\" + y) * map.get(x + \"#\" + py);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    Map<String, Integer> map = new HashMap<>();\\n\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n\\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        String key = x + \"#\" + y;\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    }\\n\\n    public int count(int[] point) {\\n        int res = 0;\\n        int px = point[0];\\n        int py = point[1];\\n        for (String key : map.keySet()) {\\n            String[] p = key.split(\"#\");\\n            int x = Integer.parseInt(p[0]);\\n            int y = Integer.parseInt(p[1]);\\n            if (x == px || y == py || Math.abs(x - px) != Math.abs(y - py))\\n                continue;\\n            if (map.containsKey(px + \"#\" + y) && map.containsKey(x + \"#\" + py)) {\\n                res += map.get(x + \"#\" + y) * map.get(px + \"#\" + y) * map.get(x + \"#\" + py);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2198903,
                "title": "c-hashmap-of-hashmap-320ms-beats-94",
                "content": "Use a hash map of hash map to store coordinates:\\nx-> hashmap of y -> y count\\n\\nadd: O(1)\\ncount: O(# of different yi added with x, as in query pts(x, y)) \\n\\nThis specific write-up, fastest can beat 95% C++ solution\\n\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        return;\\n    }\\n    \\n    void add(vector<int> point) {\\n        //cout << \"add: \" << point[0]<<\\' \\'<< point[1] << endl << endl;\\n        ++YatX[point[0]][point[1]];\\n    }\\n    \\n    int count(vector<int> point) {\\n\\n        int cnt = 0;\\n        int x = point[0], y = point[1];\\n        //cout << \"count: \" << x<<\\' \\'<< y << \\' \\';\\n        \\n        if (YatX.count(x)) {\\n            for (auto &elem : YatX[x]) {\\n                int yi = elem.first, ycnt = elem.second;\\n                int len = abs(y - yi); //sides of square\\n                //cout << len << \\' \\';\\n                if (len > 0) {\\n                    if (YatX.count(x - len)) \\n                        cnt += YatX[x - len][y] * YatX[x - len][yi] * ycnt;\\n                    if (YatX.count(x + len)) \\n                        cnt += YatX[x + len][y] * YatX[x + len][yi] * ycnt;   \\n                }\\n       \\n            }\\n        }\\n        //cout << cnt << endl << endl;\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> YatX; //x -> y -> cnt of y\\n};\\n```\\n\\nThis problem is good to practice with problme 939, in terms of how to store and search for squares in collection of pts\\nhttps://leetcode.com/problems/minimum-area-rectangle/\\n\\nAs an interesting comparison:\\nIf I use unordered_multiset in y coordinates, as in store all y pts, performance is downgraded badly.\\n```\\n    void add(vector<int> point) {\\n        //cout << \"add: \" << point[0]<<\\' \\'<< point[1] << endl << endl;\\n        YatX[point[0]].insert(point[1]);\\n    }\\n    \\n    int count(vector<int> point) {\\n\\n        int cnt = 0;\\n        int x = point[0], y = point[1];\\n        //cout << \"count: \" << x<<\\' \\'<< y << \\' \\';\\n        \\n        if (YatX.count(x)) {\\n            for (auto &yi : YatX[x]) {\\n                int len = abs(y - yi); //sides of square\\n                //cout << len << \\' \\';\\n                if (len > 0) {\\n                    if (YatX.count(x - len)) \\n                        cnt += (YatX[x - len].count(y) * YatX[x - len].count(yi));\\n                    if (YatX.count(x + len)) \\n                        cnt += (YatX[x + len].count(y) * YatX[x + len].count(yi));   \\n                }\\n       \\n            }\\n        }\\n        //cout << cnt << endl << endl;\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> YatX; //x -> list of y\\n```\\n \\nunordered_map<int, unordered_multiset<int>> YatX; //x -> list of y\\nAbove will loop thru all y pts, instead of different y pts. \\nThis seems to be performance critical for OJ test cases.\\n\\nOn another note, I noticed there are many array based solutions, as problem has constraints that pts.count < 1000\\nput here as a good reference.\\nhttps://leetcode.com/problems/detect-squares/discuss/1472290/Counting-Matrix",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        return;\\n    }\\n    \\n    void add(vector<int> point) {\\n        //cout << \"add: \" << point[0]<<\\' \\'<< point[1] << endl << endl;\\n        ++YatX[point[0]][point[1]];\\n    }\\n    \\n    int count(vector<int> point) {\\n\\n        int cnt = 0;\\n        int x = point[0], y = point[1];\\n        //cout << \"count: \" << x<<\\' \\'<< y << \\' \\';\\n        \\n        if (YatX.count(x)) {\\n            for (auto &elem : YatX[x]) {\\n                int yi = elem.first, ycnt = elem.second;\\n                int len = abs(y - yi); //sides of square\\n                //cout << len << \\' \\';\\n                if (len > 0) {\\n                    if (YatX.count(x - len)) \\n                        cnt += YatX[x - len][y] * YatX[x - len][yi] * ycnt;\\n                    if (YatX.count(x + len)) \\n                        cnt += YatX[x + len][y] * YatX[x + len][yi] * ycnt;   \\n                }\\n       \\n            }\\n        }\\n        //cout << cnt << endl << endl;\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> YatX; //x -> y -> cnt of y\\n};\\n```\n```\\n    void add(vector<int> point) {\\n        //cout << \"add: \" << point[0]<<\\' \\'<< point[1] << endl << endl;\\n        YatX[point[0]].insert(point[1]);\\n    }\\n    \\n    int count(vector<int> point) {\\n\\n        int cnt = 0;\\n        int x = point[0], y = point[1];\\n        //cout << \"count: \" << x<<\\' \\'<< y << \\' \\';\\n        \\n        if (YatX.count(x)) {\\n            for (auto &yi : YatX[x]) {\\n                int len = abs(y - yi); //sides of square\\n                //cout << len << \\' \\';\\n                if (len > 0) {\\n                    if (YatX.count(x - len)) \\n                        cnt += (YatX[x - len].count(y) * YatX[x - len].count(yi));\\n                    if (YatX.count(x + len)) \\n                        cnt += (YatX[x + len].count(y) * YatX[x + len].count(yi));   \\n                }\\n       \\n            }\\n        }\\n        //cout << cnt << endl << endl;\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> YatX; //x -> list of y\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2060005,
                "title": "can-anyone-explain-this-example",
                "content": "Test case:\\n```\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[8,0]],[[9,0]],[[9,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```\\n\\n\\nExpected Answer of count is 2, but total 3 square is possible since there are two point  at (8,0), so 2 distinct square with [(0,0), (8,0), (8,8), (0,8)] points and 1 square is forming with (9,0) => [(0,0), (8,0), (9,0), (9,8)]. \\n\\nWhy is expected answer 2 ?",
                "solutionTags": [],
                "code": "```\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[8,0]],[[9,0]],[[9,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2006163,
                "title": "python3",
                "content": "```class DetectSquares:\\n\\n    def __init__(self):\\n        self.points = Counter()\\n        \\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.points[(x, y)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        ret = 0\\n        for (x2, y2), cnt in self.points.items():\\n            if abs(x2-x) == abs(y2-y) and abs(x2-x) != 0:\\n                ret += cnt * self.points[(x, y2)] * self.points[(x2, y)]\\n        return ret\\n\\n                \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)",
                "solutionTags": [],
                "code": "```class DetectSquares:\\n\\n    def __init__(self):\\n        self.points = Counter()\\n        \\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.points[(x, y)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        ret = 0\\n        for (x2, y2), cnt in self.points.items():\\n            if abs(x2-x) == abs(y2-y) and abs(x2-x) != 0:\\n                ret += cnt * self.points[(x, y2)] * self.points[(x2, y)]\\n        return ret\\n\\n                \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)",
                "codeTag": "Java"
            },
            {
                "id": 2003305,
                "title": "c-o-n-one-dictionary",
                "content": "```\\npublic class DetectSquares {\\n    private Dictionary<Point, int> pointsCounter;\\n\\n    public DetectSquares() {\\n        pointsCounter = new Dictionary<Point, int>();\\n    }\\n    \\n    public void Add(int[] point) {\\n        var p = new Point(point[0], point[1]);\\n        if (!pointsCounter.ContainsKey(p))\\n            pointsCounter.Add(p, 0);\\n        \\n        pointsCounter[p]++;\\n    }\\n    \\n    public int Count(int[] point) {\\n        var result = 0;\\n        foreach (var p in pointsCounter)\\n        {\\n\\t\\t\\t// check if the p.Key is a diagonal point to the given point\\n            if (p.Key.x == point[0] \\n                || p.Key.y == point[1] \\n                || Math.Abs(p.Key.x - point[0]) != Math.Abs(p.Key.y - point[1]))\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get two other points counts\\n            var p1 = new Point(p.Key.x, point[1]);\\n            var p1Count = pointsCounter.ContainsKey(p1) ?\\n                pointsCounter[p1] : 0;\\n            \\n\\t\\t\\tvar p2 = new Point(point[0], p.Key.y);\\n            var p2Count = pointsCounter.ContainsKey(p2) ?\\n                pointsCounter[p2] : 0;\\n            \\n            result += p.Value * p1Count * p2Count;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class Point\\n    {\\n        public int x;\\n        public int y;\\n        \\n        public Point(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public override int GetHashCode()\\n        {\\n            return (x+1)*(y+1);\\n        }\\n        \\n        public override bool Equals(object o)\\n        {\\n            var other = (Point) o;\\n            return this.x == other.x && this.y == other.y;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Geometry"
                ],
                "code": "```\\npublic class DetectSquares {\\n    private Dictionary<Point, int> pointsCounter;\\n\\n    public DetectSquares() {\\n        pointsCounter = new Dictionary<Point, int>();\\n    }\\n    \\n    public void Add(int[] point) {\\n        var p = new Point(point[0], point[1]);\\n        if (!pointsCounter.ContainsKey(p))\\n            pointsCounter.Add(p, 0);\\n        \\n        pointsCounter[p]++;\\n    }\\n    \\n    public int Count(int[] point) {\\n        var result = 0;\\n        foreach (var p in pointsCounter)\\n        {\\n\\t\\t\\t// check if the p.Key is a diagonal point to the given point\\n            if (p.Key.x == point[0] \\n                || p.Key.y == point[1] \\n                || Math.Abs(p.Key.x - point[0]) != Math.Abs(p.Key.y - point[1]))\\n                continue;\\n\\t\\t\\t\\n\\t\\t\\t// get two other points counts\\n            var p1 = new Point(p.Key.x, point[1]);\\n            var p1Count = pointsCounter.ContainsKey(p1) ?\\n                pointsCounter[p1] : 0;\\n            \\n\\t\\t\\tvar p2 = new Point(point[0], p.Key.y);\\n            var p2Count = pointsCounter.ContainsKey(p2) ?\\n                pointsCounter[p2] : 0;\\n            \\n            result += p.Value * p1Count * p2Count;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class Point\\n    {\\n        public int x;\\n        public int y;\\n        \\n        public Point(int x, int y)\\n        {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        public override int GetHashCode()\\n        {\\n            return (x+1)*(y+1);\\n        }\\n        \\n        public override bool Equals(object o)\\n        {\\n            var other = (Point) o;\\n            return this.x == other.x && this.y == other.y;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982578,
                "title": "javascript-clean-code-with-detailed-explanation-with-picture",
                "content": "The most important point is how to detect a square ? \\n\\n\\n![image](https://assets.leetcode.com/users/images/288b6544-31be-413d-8f57-970895b8163d_1650932081.1237435.png)\\n\\n\\nWe notice that when check a point `[x, y]` can form a square, we need to have a point `[x1, y1]` which is statisfy the below conditions: \\n\\n- Difference between (`x` and `x1`) and (`y` and `y1`) should be same\\n- Difference between (`x` and `x1`) is not zero because we need space to build a square\\n\\nSo we need to **check if all three other points** exist (`[x1, y]`, `[x1, y1`, `[x, y1]` ) to form the square \\n\\n\\n**A note from the problem**\\n\\n**Duplicate** points are allowed and should be treated as different points.\\n\\n=> We should count duplicated points to avoid calculate it again. \\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />\\n\\n\\nNow, let\\'s start coding: \\n\\n<br/>\\n\\n<iframe src=\"https://leetcode.com/playground/SP4UsGVZ/shared\" frameBorder=\"0\" width=\"1200\" height=\"800\"></iframe>\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "The most important point is how to detect a square ? \\n\\n\\n![image](https://assets.leetcode.com/users/images/288b6544-31be-413d-8f57-970895b8163d_1650932081.1237435.png)\\n\\n\\nWe notice that when check a point `[x, y]` can form a square, we need to have a point `[x1, y1]` which is statisfy the below conditions: \\n\\n- Difference between (`x` and `x1`) and (`y` and `y1`) should be same\\n- Difference between (`x` and `x1`) is not zero because we need space to build a square\\n\\nSo we need to **check if all three other points** exist (`[x1, y]`, `[x1, y1`, `[x, y1]` ) to form the square \\n\\n\\n**A note from the problem**\\n\\n**Duplicate** points are allowed and should be treated as different points.\\n\\n=> We should count duplicated points to avoid calculate it again. \\n\\n<br />\\n\\n\\u2139\\uFE0F [My javascript solution collection](https://github.com/toantd90/leetcode-js-solutions)\\n\\n<br />\\n\\n\\nNow, let\\'s start coding: \\n\\n<br/>\\n\\n<iframe src=\"https://leetcode.com/playground/SP4UsGVZ/shared\" frameBorder=\"0\" width=\"1200\" height=\"800\"></iframe>\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1980221,
                "title": "python-faster-than-90-with-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/c4dcc766-e88d-44a3-b8e8-253ea214934b_1650861028.8248534.png)\\n\\n```\\n\"\"\"\\nStore every points and number of their appearance\\nGroup the points by their x value\\n\\nGiven a point(x1,y1) to count, try to find p2(x1,y2),p3(x2,y2),p4(x2,y1)\\nand add product of their appearances\\n\\nGo through every points that has same x1(except the point that is the same as (x1,y1), the length of the side of the square is decided by abd(y2-y1).\\n\\nUse the decided side length to calculate p3 and p4, see if they are in the dict. If do, add product of their appearances.\\n\\np3     p2     p3`\\n\\n\\np4     p1     p4`\\n\\nNotice that p3 and p4 can be on both left side and right side of side (p2,p1)\\n\\n\"\"\"\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.pts=defaultdict(int)\\n        self.by_x=defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.pts[(point[0],point[1])]+=1\\n        self.by_x[point[0]].add((point[0],point[1]))\\n\\n    def count(self, p1: List[int]) -> int:\\n        res=0\\n        x1,y1=p1[0],p1[1]\\n        if x1 in self.by_x:\\n            #p2:x1,y2\\n            for p2 in self.by_x[x1]:\\n                x2,y2=p2\\n                if y1==y2:\\n                    continue\\n                #length of side of square\\n                b=abs(y1-y2)\\n                #left side\\n                p3=(x1-b,y2)\\n                p4=(x1-b,y1)\\n                if p3 in self.pts and p4 in self.pts:\\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]\\n                #right side\\n                p3=(x1+b,y2)\\n                p4=(x1+b,y1)\\n                if p3 in self.pts and p4 in self.pts:\\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]                \\n        return res\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\nStore every points and number of their appearance\\nGroup the points by their x value\\n\\nGiven a point(x1,y1) to count, try to find p2(x1,y2),p3(x2,y2),p4(x2,y1)\\nand add product of their appearances\\n\\nGo through every points that has same x1(except the point that is the same as (x1,y1), the length of the side of the square is decided by abd(y2-y1).\\n\\nUse the decided side length to calculate p3 and p4, see if they are in the dict. If do, add product of their appearances.\\n\\np3     p2     p3`\\n\\n\\np4     p1     p4`\\n\\nNotice that p3 and p4 can be on both left side and right side of side (p2,p1)\\n\\n\"\"\"\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.pts=defaultdict(int)\\n        self.by_x=defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.pts[(point[0],point[1])]+=1\\n        self.by_x[point[0]].add((point[0],point[1]))\\n\\n    def count(self, p1: List[int]) -> int:\\n        res=0\\n        x1,y1=p1[0],p1[1]\\n        if x1 in self.by_x:\\n            #p2:x1,y2\\n            for p2 in self.by_x[x1]:\\n                x2,y2=p2\\n                if y1==y2:\\n                    continue\\n                #length of side of square\\n                b=abs(y1-y2)\\n                #left side\\n                p3=(x1-b,y2)\\n                p4=(x1-b,y1)\\n                if p3 in self.pts and p4 in self.pts:\\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]\\n                #right side\\n                p3=(x1+b,y2)\\n                p4=(x1+b,y1)\\n                if p3 in self.pts and p4 in self.pts:\\n                    res+=self.pts[p2]*self.pts[p3]*self.pts[p4]                \\n        return res\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924516,
                "title": "c-nested-hashmap",
                "content": "Use nested hashmap to store the points.\\nEnumerate every existing points, putting as the diagonal point.\\n\\n```\\nclass DetectSquares {\\npublic:\\n    // [x, [y, cnt]]\\n    unordered_map<int, unordered_map<int, int>> xToy;\\n    // distinct points\\n    vector<vector<int>> distinct;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int &x = point[0];\\n        int &y = point[1];\\n        if (!xToy.count(x) || !xToy[x].count(y)) {\\n            xToy[x][y] = 0;\\n            distinct.push_back(point);\\n        }\\n        xToy[x][y]++;\\n    }\\n    \\n    int queryCnt(int x,int y) {\\n        if (!xToy.count(x) || !xToy[x].count(y)) {\\n            return 0;\\n        }\\n        return xToy[x][y];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int &x1 = point[0];\\n        int &y1 = point[1];\\n        int res = 0;\\n        for (auto &ele : distinct) {\\n            int &x2 = ele[0];\\n            int &y2 = ele[1];\\n            if (x1 == x2 || y1 == y2) {\\n                continue;\\n            }\\n            if (abs(x1 - x2) != abs(y1 - y2)) {\\n                continue;\\n            }\\n            int cnt1 = queryCnt(x2, y2);\\n            int cnt2 = queryCnt(x1, y2);\\n            int cnt3 = queryCnt(x2, y1);\\n            res += cnt1 * cnt2 * cnt3;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    // [x, [y, cnt]]\\n    unordered_map<int, unordered_map<int, int>> xToy;\\n    // distinct points\\n    vector<vector<int>> distinct;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int &x = point[0];\\n        int &y = point[1];\\n        if (!xToy.count(x) || !xToy[x].count(y)) {\\n            xToy[x][y] = 0;\\n            distinct.push_back(point);\\n        }\\n        xToy[x][y]++;\\n    }\\n    \\n    int queryCnt(int x,int y) {\\n        if (!xToy.count(x) || !xToy[x].count(y)) {\\n            return 0;\\n        }\\n        return xToy[x][y];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int &x1 = point[0];\\n        int &y1 = point[1];\\n        int res = 0;\\n        for (auto &ele : distinct) {\\n            int &x2 = ele[0];\\n            int &y2 = ele[1];\\n            if (x1 == x2 || y1 == y2) {\\n                continue;\\n            }\\n            if (abs(x1 - x2) != abs(y1 - y2)) {\\n                continue;\\n            }\\n            int cnt1 = queryCnt(x2, y2);\\n            int cnt2 = queryCnt(x1, y2);\\n            int cnt3 = queryCnt(x2, y1);\\n            res += cnt1 * cnt2 * cnt3;\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892460,
                "title": "java-solution-beat-70-in-both-speed-and-space",
                "content": "The idea behind this solution is once we get the input point, we loop through all the unique point we have in the map and treat them as the opsite point of the square. Then check the map to see if we can find the rest of the two points to make a square. Once we found it, we update our rest.\\nA small trick here is to use the hashvalue of each point as the key of our map, this could save us some space.\\nAdd O(1)\\ncount O(n)\\n\\n```\\nclass DetectSquares {\\n    private HashMap<Integer, Integer> map;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int key = point[0] * 1001 + point[1];\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    } \\n    \\n    public int count(int[] point) {    \\n        int result = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for(int key : map.keySet()){\\n            int x1 = key / 1001;\\n            int y1 = key % 1001;\\n            if(x == x1 || y == y1 || Math.abs(x - x1) != Math.abs(y - y1)) continue;    \\n            int c1 = map.get(key);\\n\\n            int key2 = x1 * 1001 + y;\\n            if(!map.containsKey(key2)) continue;\\n            int c2 = map.get(key2);\\n            \\n            int key3 = x * 1001 + y1;\\n            if(!map.containsKey(key3)) continue;\\n            int c3 = map.get(key3);\\n\\n            result += c1 * c2 * c3;       \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    private HashMap<Integer, Integer> map;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int key = point[0] * 1001 + point[1];\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    } \\n    \\n    public int count(int[] point) {    \\n        int result = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for(int key : map.keySet()){\\n            int x1 = key / 1001;\\n            int y1 = key % 1001;\\n            if(x == x1 || y == y1 || Math.abs(x - x1) != Math.abs(y - y1)) continue;    \\n            int c1 = map.get(key);\\n\\n            int key2 = x1 * 1001 + y;\\n            if(!map.containsKey(key2)) continue;\\n            int c2 = map.get(key2);\\n            \\n            int key3 = x * 1001 + y1;\\n            if(!map.containsKey(key3)) continue;\\n            int c3 = map.get(key3);\\n\\n            result += c1 * c2 * c3;       \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855409,
                "title": "c-very-simple-solution-with-array",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    \\n    int arr[1001][1001] = {0,};\\n    int dx[4] = {-1,-1,1,1};\\n    int dy[4] = {-1,1,-1,1};\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    int get_count(int x1, int y1, int x2, int y2, int x3, int y3){\\n        if(x1 > 1000 || x1 < 0 || y1 > 1000 || y1 < 0) return 0;\\n        if(x2 > 1000 || x2 < 0 || y2 > 1000 || y2 < 0) return 0;\\n        if(x3 > 1000 || x3 < 0 || y3 > 1000 || y3 < 0) return 0;\\n        \\n        return arr[x1][y1] * arr[x2][y2] * arr[x3][y3];\\n    }\\n    \\n    void add(vector<int> point) {\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        int count_num = 0;\\n        \\n        int max_size = 1000;\\n        int ret_max = 0;\\n        for(int i=0;i<4;i++){\\n            for(int j=1;j<=max_size;j++){\\n                ret_max += get_count(x+dx[i]*j, y, x+dx[i]*j, y+dy[i]*j, x, y+dy[i]*j);\\n            }\\n        }\\n        \\n        return ret_max;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    \\n    int arr[1001][1001] = {0,};\\n    int dx[4] = {-1,-1,1,1};\\n    int dy[4] = {-1,1,-1,1};\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    int get_count(int x1, int y1, int x2, int y2, int x3, int y3){\\n        if(x1 > 1000 || x1 < 0 || y1 > 1000 || y1 < 0) return 0;\\n        if(x2 > 1000 || x2 < 0 || y2 > 1000 || y2 < 0) return 0;\\n        if(x3 > 1000 || x3 < 0 || y3 > 1000 || y3 < 0) return 0;\\n        \\n        return arr[x1][y1] * arr[x2][y2] * arr[x3][y3];\\n    }\\n    \\n    void add(vector<int> point) {\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        int count_num = 0;\\n        \\n        int max_size = 1000;\\n        int ret_max = 0;\\n        for(int i=0;i<4;i++){\\n            for(int j=1;j<=max_size;j++){\\n                ret_max += get_count(x+dx[i]*j, y, x+dx[i]*j, y+dy[i]*j, x, y+dy[i]*j);\\n            }\\n        }\\n        \\n        return ret_max;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788548,
                "title": "python3-easy-implementation-beats-95",
                "content": "```python\\nfrom collections import defaultdict\\n\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.cnts = defaultdict(int)\\n        self.y_vals = defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.cnts[(x, y)] += 1\\n        self.y_vals[x].add(y)\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        res = 0\\n        for yp in self.y_vals[x]: \\n            if y == yp:\\n                continue\\n            a = abs(y - yp)\\n            res += self.cnts[(x + a, y)] * self.cnts[(x, yp)] * self.cnts[(x + a, yp)]\\n            res += self.cnts[(x - a, y)] * self.cnts[(x, yp)] * self.cnts[(x - a, yp)]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\nfrom collections import defaultdict\\n\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.cnts = defaultdict(int)\\n        self.y_vals = defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.cnts[(x, y)] += 1\\n        self.y_vals[x].add(y)\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        res = 0\\n        for yp in self.y_vals[x]: \\n            if y == yp:\\n                continue\\n            a = abs(y - yp)\\n            res += self.cnts[(x + a, y)] * self.cnts[(x, yp)] * self.cnts[(x + a, yp)]\\n            res += self.cnts[(x - a, y)] * self.cnts[(x, yp)] * self.cnts[(x - a, yp)]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1750957,
                "title": "javascript-simple-approach-by-diagonal-properties",
                "content": "```\\nvar DetectSquares = function() {\\n  this.map = {}; // {\\'x1,y1\\': 1, \\'x2,y2\\': 4, ....}\\n  this.points = []; // [[x1, y1], [x2, y2], [x3, y3], ....]\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\nDetectSquares.prototype.add = function(point) {\\n  let str = point[0] + \\',\\' + point[1];\\n  if(!this.map[str])\\n    this.map[str] = 0;\\n  this.map[str]++;\\n  this.points.push(point); // because we want duplicate points as well!\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\nDetectSquares.prototype.count = function(point) {\\n  // find using diagonal properties\\n  // from the map find if p3 exists ( diagonal of given point i.e. p1)\\n  // conditions to check:\\n  // 1. They don\\'t lie on same X axis\\n  // 2. Difference of X and Y are equal\\n  let res = 0\\n  let [x1, y1] = point;\\n  for(let [x3, y3] of this.points) {\\n    if(x1 === x3 || Math.abs(x1 - x3) !== Math.abs(y1 - y3))\\n      continue;\\n    let [x2, y2] = [x3, y1];\\n    let [x4, y4] = [x1, y3];\\n    let p2 = x2 + \\',\\' + y2;\\n    let p4 = x4 + \\',\\' + y4;\\n    \\n    res = res + ((this.map[p2] || 0) * (this.map[p4] || 0));\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar DetectSquares = function() {\\n  this.map = {}; // {\\'x1,y1\\': 1, \\'x2,y2\\': 4, ....}\\n  this.points = []; // [[x1, y1], [x2, y2], [x3, y3], ....]\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {void}\\n */\\nDetectSquares.prototype.add = function(point) {\\n  let str = point[0] + \\',\\' + point[1];\\n  if(!this.map[str])\\n    this.map[str] = 0;\\n  this.map[str]++;\\n  this.points.push(point); // because we want duplicate points as well!\\n};\\n\\n/** \\n * @param {number[]} point\\n * @return {number}\\n */\\nDetectSquares.prototype.count = function(point) {\\n  // find using diagonal properties\\n  // from the map find if p3 exists ( diagonal of given point i.e. p1)\\n  // conditions to check:\\n  // 1. They don\\'t lie on same X axis\\n  // 2. Difference of X and Y are equal\\n  let res = 0\\n  let [x1, y1] = point;\\n  for(let [x3, y3] of this.points) {\\n    if(x1 === x3 || Math.abs(x1 - x3) !== Math.abs(y1 - y3))\\n      continue;\\n    let [x2, y2] = [x3, y1];\\n    let [x4, y4] = [x1, y3];\\n    let p2 = x2 + \\',\\' + y2;\\n    let p4 = x4 + \\',\\' + y4;\\n    \\n    res = res + ((this.map[p2] || 0) * (this.map[p4] || 0));\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1655147,
                "title": "java-solution-using-map",
                "content": "The solution I based on is on Property of Square.\\n\\nSo if you have one point of Square, (X,Y) you can find another point of square by Getting all the point that lies on same X- axis (/ Y-axis). \\nLet\\'s say the new point is ```(X,Y1)```\\nNow since you have two points you can calculate length of the side of the square which would be \\n```dist = Y-Y1```\\nTo find other two points, if we add AND subtract this ```dist```  to the current two points X-axis  we get our other two points.\\nAs we\\'ll need to find points based on X axis and Y axis. I store all the points in HashMap of HashMap so we can find frequency and existance of any point using the two key X-axis and Y-axis\\n\\n```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public DetectSquares() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        if(!map.containsKey(point[0])){\\n            map.put(point[0], new HashMap<>());\\n        }\\n        Map<Integer, Integer> xMap = map.get(point[0]);\\n        xMap.put(point[1], xMap.getOrDefault(point[1],0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int count = 0;\\n        Map<Integer, Integer> xMap = map.get(point[0]);\\n        if(xMap==null){\\n            return 0;\\n        }\\n        \\n        for(int y : xMap.keySet()){\\n            if(y!=point[1]){\\n                int dist = y-point[1];\\n                if(map.containsKey(point[0]+dist) &&\\n                   map.get(point[0]+dist).containsKey(point[1]) && map.get(point[0]+dist).containsKey(y)){\\n                    int tmpCount = 1*xMap.get(y)*map.get(point[0]+dist).get(point[1])*map.get(point[0]+dist).get(y);\\n                    count+=tmpCount;\\n                }\\n                if(map.containsKey(point[0]-dist) &&\\n                   map.get(point[0]-dist).containsKey(point[1]) && map.get(point[0]-dist).containsKey(y)){\\n                    int tmpCount = 1*xMap.get(y)*map.get(point[0]-dist).get(point[1])*map.get(point[0]-dist).get(y);\\n                    count+=tmpCount;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n ```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```(X,Y1)```\n```dist = Y-Y1```\n```dist```\n```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public DetectSquares() {\\n        this.map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        if(!map.containsKey(point[0])){\\n            map.put(point[0], new HashMap<>());\\n        }\\n        Map<Integer, Integer> xMap = map.get(point[0]);\\n        xMap.put(point[1], xMap.getOrDefault(point[1],0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int count = 0;\\n        Map<Integer, Integer> xMap = map.get(point[0]);\\n        if(xMap==null){\\n            return 0;\\n        }\\n        \\n        for(int y : xMap.keySet()){\\n            if(y!=point[1]){\\n                int dist = y-point[1];\\n                if(map.containsKey(point[0]+dist) &&\\n                   map.get(point[0]+dist).containsKey(point[1]) && map.get(point[0]+dist).containsKey(y)){\\n                    int tmpCount = 1*xMap.get(y)*map.get(point[0]+dist).get(point[1])*map.get(point[0]+dist).get(y);\\n                    count+=tmpCount;\\n                }\\n                if(map.containsKey(point[0]-dist) &&\\n                   map.get(point[0]-dist).containsKey(point[1]) && map.get(point[0]-dist).containsKey(y)){\\n                    int tmpCount = 1*xMap.get(y)*map.get(point[0]-dist).get(point[1])*map.get(point[0]-dist).get(y);\\n                    count+=tmpCount;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1472838,
                "title": "c-using-2-d-array-matrix",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    int cnt[1001][1001];\\n    DetectSquares() {\\n        memset(cnt,0,sizeof(cnt));\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        cnt[x][y]+=1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int ans = 0;\\n        \\n        for(int i=1;i<=1000;++i){\\n            // assumeing top-right(x,y) given\\n            if(x-i>=0 && x-i<=1000 && y-i>=0 && y-i<=1000) ans+=cnt[x-i][y]*cnt[x-i][y-i]*cnt[x][y-i];\\n            \\n            // assumeing top-left(x,y) given\\n            if(x+i>=0 && x+i<=1000 && y-i>=0 && y-i<=1000) ans+=cnt[x+i][y]*cnt[x][y-i]*cnt[x+i][y-i];\\n            \\n            // assumeing bottom-left(x,y) given\\n            if(x+i>=0 && x+i<=1000 && y+i>=0 && y+i<=1000) ans+=cnt[x+i][y]*cnt[x+i][y+i]*cnt[x][y+i];\\n            \\n            // assumeing bottom-right(x,y) given\\n            if(x-i>=0 && x-i<=1000 && y+i>=0 && y+i<=1000) ans+=cnt[x-i][y]*cnt[x-i][y+i]*cnt[x][y+i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    int cnt[1001][1001];\\n    DetectSquares() {\\n        memset(cnt,0,sizeof(cnt));\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        cnt[x][y]+=1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int ans = 0;\\n        \\n        for(int i=1;i<=1000;++i){\\n            // assumeing top-right(x,y) given\\n            if(x-i>=0 && x-i<=1000 && y-i>=0 && y-i<=1000) ans+=cnt[x-i][y]*cnt[x-i][y-i]*cnt[x][y-i];\\n            \\n            // assumeing top-left(x,y) given\\n            if(x+i>=0 && x+i<=1000 && y-i>=0 && y-i<=1000) ans+=cnt[x+i][y]*cnt[x][y-i]*cnt[x+i][y-i];\\n            \\n            // assumeing bottom-left(x,y) given\\n            if(x+i>=0 && x+i<=1000 && y+i>=0 && y+i<=1000) ans+=cnt[x+i][y]*cnt[x+i][y+i]*cnt[x][y+i];\\n            \\n            // assumeing bottom-right(x,y) given\\n            if(x-i>=0 && x-i<=1000 && y+i>=0 && y+i<=1000) ans+=cnt[x-i][y]*cnt[x-i][y+i]*cnt[x][y+i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472417,
                "title": "c-map-commented",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int> points;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        // First Point\\n        pair<int,int> p1={point[0],point[1]};        \\n        int ans=0;\\n        for(auto p:points){\\n            \\n            // Second Point\\n            pair<int,int> p2=p.first;\\n            \\n            // If Edge Between p1 and p2 is Vertical\\n            if(p2.first==p1.first){\\n                \\n                // Calculate Edge Length\\n                int side=abs(p2.second-p1.second);\\n                \\n                // If Both p1 and p2 coincide(Zero Area).\\n                if(side==0) continue;\\n                \\n                // 2 other points\\n                pair<int,int> p3,p4;\\n                \\n                // Case 1: Take p3 and p4 on left side of edge b/w p1 and p2.\\n                p3={p1.first-side,p1.second};\\n                p4={p2.first-side,p2.second};\\n                ans+=points[p2]*points[p3]*points[p4];\\n                \\n                // Case 1: Take p3 and p4 on right side of edge b/w p1 and p2.\\n                p3={p1.first+side,p1.second};\\n                p4={p2.first+side,p2.second};\\n                ans+=points[p2]*points[p3]*points[p4];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int> points;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        // First Point\\n        pair<int,int> p1={point[0],point[1]};        \\n        int ans=0;\\n        for(auto p:points){\\n            \\n            // Second Point\\n            pair<int,int> p2=p.first;\\n            \\n            // If Edge Between p1 and p2 is Vertical\\n            if(p2.first==p1.first){\\n                \\n                // Calculate Edge Length\\n                int side=abs(p2.second-p1.second);\\n                \\n                // If Both p1 and p2 coincide(Zero Area).\\n                if(side==0) continue;\\n                \\n                // 2 other points\\n                pair<int,int> p3,p4;\\n                \\n                // Case 1: Take p3 and p4 on left side of edge b/w p1 and p2.\\n                p3={p1.first-side,p1.second};\\n                p4={p2.first-side,p2.second};\\n                ans+=points[p2]*points[p3]*points[p4];\\n                \\n                // Case 1: Take p3 and p4 on right side of edge b/w p1 and p2.\\n                p3={p1.first+side,p1.second};\\n                p4={p2.first+side,p2.second};\\n                ans+=points[p2]*points[p3]*points[p4];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472331,
                "title": "c-o-n-enumerate-seen-x-values",
                "content": "## Solution 1. Enumerate seen `x` values\\n\\n**Intuition**: For query `(x, y)`, we try each `x` values we\\'ve seen, say `x1`, as the `x` value of the other vertical edge. Because we want to form **squares**, there are only two square candidates possible.\\n\\n**Algorithm**:\\n\\nGiven query `(x, y)`, we try each `x1` values we\\'ve seen. Another point must be `(x1, y)`.\\n\\nSince the side length `d = abs(x - x1)`, the `y` value of other horizontal side must be either `y1 = y + d` or `y2 = y - d`.\\n\\nSo the answer is `count(x1, y) * [ count(x, y1) * count(x1, y1) + count(x, y2) * count(x1, y2) ]`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/detect-squares/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      DetectSquares: O(1)\\n//      add: O(1)\\n//      count: O(N)\\n// Space: O(N)\\nclass DetectSquares {\\n    unordered_map<int, int> cnt;\\n    unordered_set<int> xs;\\n    int count(int x, int y) {\\n        int key = x * 10000 + y;\\n        return cnt.count(key) ? cnt[key] : 0;\\n    }\\npublic:\\n    DetectSquares() {}\\n    void add(vector<int> p) {\\n        cnt[p[0] * 10000 + p[1]]++;\\n        xs.insert(p[0]);\\n    }\\n    int count(vector<int> p) {\\n        int x = p[0], y = p[1], ans = 0;\\n        for (int x1 : xs) {\\n            if (x1 == x || cnt.count(x1 * 10000 + y) == 0) continue;\\n            int c1 = count(x1, y);\\n            if (c1 == 0) continue;\\n            int d = abs(x - x1), y1 = y - d, y2 = y + d;\\n            ans += c1 * (count(x, y1) * count(x1, y1) + count(x, y2) * count(x1, y2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/detect-squares/\\n// Author: github.com/lzl124631x\\n// Time:\\n//      DetectSquares: O(1)\\n//      add: O(1)\\n//      count: O(N)\\n// Space: O(N)\\nclass DetectSquares {\\n    unordered_map<int, int> cnt;\\n    unordered_set<int> xs;\\n    int count(int x, int y) {\\n        int key = x * 10000 + y;\\n        return cnt.count(key) ? cnt[key] : 0;\\n    }\\npublic:\\n    DetectSquares() {}\\n    void add(vector<int> p) {\\n        cnt[p[0] * 10000 + p[1]]++;\\n        xs.insert(p[0]);\\n    }\\n    int count(vector<int> p) {\\n        int x = p[0], y = p[1], ans = 0;\\n        for (int x1 : xs) {\\n            if (x1 == x || cnt.count(x1 * 10000 + y) == 0) continue;\\n            int c1 = count(x1, y);\\n            if (c1 == 0) continue;\\n            int d = abs(x - x1), y1 = y - d, y2 = y + d;\\n            ans += c1 * (count(x, y1) * count(x1, y1) + count(x, y2) * count(x1, y2));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472026,
                "title": "swift-solution",
                "content": "Swift solution\\n```swift\\nclass DetectSquares {\\n\\n    private var xs = [Int: [Int: Int]]()\\n    private var ys = [Int: [Int: Int]]()\\n    private var xys = [Int: [Int: Int]]()\\n\\n    init() {\\n        // nothing to do\\n    }\\n    \\n    func add(_ point: [Int]) {\\n        let x = point[0], y = point[1]\\n        xs[x, default: [Int: Int]()][y, default: Int(0)] += 1\\n        ys[y, default: [Int: Int]()][x, default: Int(0)] += 1\\n        xys[x + y, default: [Int: Int]()][x, default: Int(0)] += 1\\n    }\\n\\n    func count(_ point: [Int]) -> Int {\\n        let x = point[0], y = point[1]\\n        let result = checkBottomRight(x, y) + checkTopLeft(x, y) + checkBottomLeft(x, y) + checkTopRight(x, y)\\n        return result\\n    }\\n\\n    private func checkBottomRight(_ brX: Int, _ brY: Int) -> Int {\\n        let brCount = 1\\n        var result = 0\\n        for tlX in xys[brX + brY, default: [Int: Int]()].keys where brX > tlX {\\n            let tlY = brY + (brX - tlX)\\n            let tlCount = xs[tlX, default: [Int: Int]()][tlY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkTopLeft(_ tlX: Int, _ tlY: Int) -> Int {\\n        let tlCount = 1\\n        var result = 0\\n        for brX in xys[tlX + tlY, default: [Int: Int]()].keys where brX > tlX {\\n            let brY = tlY + (tlX - brX)\\n            let brCount = xs[brX, default: [Int: Int]()][brY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkBottomLeft(_ blX: Int, _ blY: Int) -> Int {\\n        let blCount = 1\\n        var result = 0\\n        for brX in ys[blY, default: [Int: Int]()].keys where brX > blX {\\n            let tlY = blY + (brX - blX)\\n            let brCount = xs[brX, default: [Int: Int]()][blY, default: 0]\\n            let tlCount = xs[blX, default: [Int: Int]()][tlY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkTopRight(_ trX: Int, _ trY: Int) -> Int {\\n        let trCount = 1\\n        var result = 0\\n        for brY in xs[trX, default: [Int: Int]()].keys where brY < trY {\\n            let tlX = trX + (brY - trY)\\n            let brCount = xs[trX, default: [Int: Int]()][brY, default: 0]\\n            let tlCount = xs[tlX, default: [Int: Int]()][trY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass DetectSquares {\\n\\n    private var xs = [Int: [Int: Int]]()\\n    private var ys = [Int: [Int: Int]]()\\n    private var xys = [Int: [Int: Int]]()\\n\\n    init() {\\n        // nothing to do\\n    }\\n    \\n    func add(_ point: [Int]) {\\n        let x = point[0], y = point[1]\\n        xs[x, default: [Int: Int]()][y, default: Int(0)] += 1\\n        ys[y, default: [Int: Int]()][x, default: Int(0)] += 1\\n        xys[x + y, default: [Int: Int]()][x, default: Int(0)] += 1\\n    }\\n\\n    func count(_ point: [Int]) -> Int {\\n        let x = point[0], y = point[1]\\n        let result = checkBottomRight(x, y) + checkTopLeft(x, y) + checkBottomLeft(x, y) + checkTopRight(x, y)\\n        return result\\n    }\\n\\n    private func checkBottomRight(_ brX: Int, _ brY: Int) -> Int {\\n        let brCount = 1\\n        var result = 0\\n        for tlX in xys[brX + brY, default: [Int: Int]()].keys where brX > tlX {\\n            let tlY = brY + (brX - tlX)\\n            let tlCount = xs[tlX, default: [Int: Int]()][tlY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkTopLeft(_ tlX: Int, _ tlY: Int) -> Int {\\n        let tlCount = 1\\n        var result = 0\\n        for brX in xys[tlX + tlY, default: [Int: Int]()].keys where brX > tlX {\\n            let brY = tlY + (tlX - brX)\\n            let brCount = xs[brX, default: [Int: Int]()][brY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkBottomLeft(_ blX: Int, _ blY: Int) -> Int {\\n        let blCount = 1\\n        var result = 0\\n        for brX in ys[blY, default: [Int: Int]()].keys where brX > blX {\\n            let tlY = blY + (brX - blX)\\n            let brCount = xs[brX, default: [Int: Int]()][blY, default: 0]\\n            let tlCount = xs[blX, default: [Int: Int]()][tlY, default: 0]\\n            let trCount = xs[brX, default: [Int: Int]()][tlY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n\\n    private func checkTopRight(_ trX: Int, _ trY: Int) -> Int {\\n        let trCount = 1\\n        var result = 0\\n        for brY in xs[trX, default: [Int: Int]()].keys where brY < trY {\\n            let tlX = trX + (brY - trY)\\n            let brCount = xs[trX, default: [Int: Int]()][brY, default: 0]\\n            let tlCount = xs[tlX, default: [Int: Int]()][trY, default: 0]\\n            let blCount = xs[tlX, default: [Int: Int]()][brY, default: 0]\\n            result += brCount * tlCount * blCount * trCount\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471926,
                "title": "c-easy",
                "content": "```\\nclass DetectSquares {\\npublic:\\n   map<vector<int,int>,int > points;\\n    \\n    DetectSquares() {\\n        points.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point]++;\\n       \\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans=0;\\n       \\n        for(auto  itr:points){\\n            \\n            \\n            if(itr.first[0]==point[0]){\\n                int x=point[0];\\n                int y1=point[1];\\n                int y2=itr.first[1];\\n                \\n           \\n                \\n                \\n                int c1=0,c2=0,c3=0;\\n                c1=points[itr.first];\\n                \\n                if(y2>y1)\\n                \\n                {\\n                 \\n                c2=points[{x+y2-y1,y1}];\\n               \\n                c3=points[{x+y2-y1,y2}];\\n                \\n                 ans=ans+c1*c2*c3;\\n \\n                c2=0; c3=0;\\n                             \\n                 c2=points[{x-y2+y1,y1}];\\n                \\n                 c3=points[{x-y2+y1,y2}];\\n               \\n                \\n                 ans=ans+c1*c2*c3;}\\n                \\n                \\n                else if(y1>y2)\\n                \\n                {c2=0; c3=0;\\n                                \\n                 c2=points[{x-y2+y1,y1}];\\n               \\n                 c3=points[{x-y2+y1,y2}];\\n              \\n                \\n                 ans=ans+c1*c2*c3;\\n                \\n                   c2=0; c3=0;\\n                            \\n                 c2=points[{x-y1+y2,y2}];\\n               \\n                 c3=points[{x-y1+y2,y1}];\\n               \\n                \\n                 ans=ans+c1*c2*c3;}\\n                \\n           }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n \\n \\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n   map<vector<int,int>,int > points;\\n    \\n    DetectSquares() {\\n        points.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point]++;\\n       \\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans=0;\\n       \\n        for(auto  itr:points){\\n            \\n            \\n            if(itr.first[0]==point[0]){\\n                int x=point[0];\\n                int y1=point[1];\\n                int y2=itr.first[1];\\n                \\n           \\n                \\n                \\n                int c1=0,c2=0,c3=0;\\n                c1=points[itr.first];\\n                \\n                if(y2>y1)\\n                \\n                {\\n                 \\n                c2=points[{x+y2-y1,y1}];\\n               \\n                c3=points[{x+y2-y1,y2}];\\n                \\n                 ans=ans+c1*c2*c3;\\n \\n                c2=0; c3=0;\\n                             \\n                 c2=points[{x-y2+y1,y1}];\\n                \\n                 c3=points[{x-y2+y1,y2}];\\n               \\n                \\n                 ans=ans+c1*c2*c3;}\\n                \\n                \\n                else if(y1>y2)\\n                \\n                {c2=0; c3=0;\\n                                \\n                 c2=points[{x-y2+y1,y1}];\\n               \\n                 c3=points[{x-y2+y1,y2}];\\n              \\n                \\n                 ans=ans+c1*c2*c3;\\n                \\n                   c2=0; c3=0;\\n                            \\n                 c2=points[{x-y1+y2,y2}];\\n               \\n                 c3=points[{x-y1+y2,y1}];\\n               \\n                \\n                 ans=ans+c1*c2*c3;}\\n                \\n           }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n \\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471919,
                "title": "java-easy-understand",
                "content": "```\\nclass DetectSquares {\\n    int[][] matrix;\\n    Map<Integer, Set<Integer>> coor;\\n    public DetectSquares() {\\n        this.matrix = new int[1001][1001];\\n        coor = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        this.matrix[point[0]][point[1]] += 1;\\n        coor.putIfAbsent(point[0], new HashSet<>());\\n        coor.get(point[0]).add(point[1]);\\n    }\\n    // Make point as one corner(left bottom or right top), \\n    // Select another point as another corner (right top or left bottom)\\n    // Check if it is valid or not\\n    public int count(int[] point) {\\n        int res = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : coor.keySet()) {\\n            Set<Integer> set = coor.get(i);\\n            for (int j : set) {\\n                if (matrix[i][j] > 0 && \\n                    matrix[x][j] > 0 && \\n                    matrix[i][y] > 0 && \\n                    i != x && j != y && \\n                    Math.abs(x - i) == Math.abs(y - j)) {\\n                    res += matrix[i][j] * matrix[x][j] * matrix[i][y];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    int[][] matrix;\\n    Map<Integer, Set<Integer>> coor;\\n    public DetectSquares() {\\n        this.matrix = new int[1001][1001];\\n        coor = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        this.matrix[point[0]][point[1]] += 1;\\n        coor.putIfAbsent(point[0], new HashSet<>());\\n        coor.get(point[0]).add(point[1]);\\n    }\\n    // Make point as one corner(left bottom or right top), \\n    // Select another point as another corner (right top or left bottom)\\n    // Check if it is valid or not\\n    public int count(int[] point) {\\n        int res = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : coor.keySet()) {\\n            Set<Integer> set = coor.get(i);\\n            for (int j : set) {\\n                if (matrix[i][j] > 0 && \\n                    matrix[x][j] > 0 && \\n                    matrix[i][y] > 0 && \\n                    i != x && j != y && \\n                    Math.abs(x - i) == Math.abs(y - j)) {\\n                    res += matrix[i][j] * matrix[x][j] * matrix[i][y];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690572,
                "title": "o-n-time-o-1-space-solution-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a hashmap to add and count the points.\\n\\nWe will be given a query point and need to choose the other three points and find the number of squares with a positive area. \\n\\nFor a square, we need four points. 1st point P1 is the query point\\nSearch for a diagonal point P2 in the hashmap. P1 and P2 can form a diagonal if the width and height difference is the same i.e P1x - P2x == P1y - P2y. We can get the other two points as:\\n    P3 = P1x - P2y\\n    P4 = P2x - P1y\\n\\nFor positive area, the points shouldn\\'t be in the same spot. No need to check all points, only check the x or y coordinates of P1 and P2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- init()\\n    - create a hashmap \\n    - hashmap key = point coordinates i.e x, y and value = frequency\\n- add()\\n    - increment the count of the point(x, y) in the hashmap\\n- count()\\n    - set a result variable res=0 to count the number of squares\\n    - get the coordinates x, y of the 1st point\\n    - iterate the points hashmap \\n        - if the 2nd point is not at the same spot, the 1st & 2nd points are diagonal, and the 3rd & 4th points are there, we can create a square. Multiply the count of the three points (2nd, 3rd, and 4th) to get the number of squares and update the res. No need to multiply all 4 points count because the count of the 1st point (query point) is always 1.\\n    - return res\\n\\n# Complexity\\n- Time complexity: O(n) for count(), O(1) for others\\n    - init() /constructor O(1)\\n    - add() O(1)\\n    - count O(hashmap iteration) \\u2192 O(hashmap size) \\u2192 O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n    - init() /constructor O(1)\\n    - add() O(1)\\n    - count O(1)\\n    - O(1) for all operations because the functions don\\'t need extra space for the computation. Size of hashmap will be n after n calls to add()\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        px, py = point\\n        for (x, y), count in self.points.items():\\n            if x != px and abs(px - x) == abs(py - y) and (px, y) in self.points and (x, py) in self.points:\\n                res += self.points[(px, y)] * self.points[(x, py)] * count\\n        return res\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        px, py = point\\n        for (x, y), count in self.points.items():\\n            if x != px and abs(px - x) == abs(py - y) and (px, y) in self.points and (x, py) in self.points:\\n                res += self.points[(px, y)] * self.points[(x, py)] * count\\n        return res\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485303,
                "title": "easy-solution-using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass DetectSquares {\\n\\n    Map<Integer, Map<Integer, Integer>> yx;\\n\\n\\n    public DetectSquares() {\\n        yx = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n\\n        if(yx.get(y) == null){\\n            yx.put(y, new HashMap<>());\\n        }\\n        yx.get(y).put(x, yx.get(y).getOrDefault(x, 0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n\\n        int x = point[0];\\n        int y = point[1];\\n\\n        int sum = 0;\\n\\n        if(yx.get(y) != null){\\n\\n            Map<Integer, Integer> map = yx.get(y);\\n\\n            for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n\\n                int x1 = entry.getKey();\\n\\n                if(Math.abs(x1 - x) > 0){\\n\\n                    int dist = Math.abs(x1 - x);\\n\\n                    int yNew = y + dist;\\n\\n                    if(yx.get(yNew) != null && yx.get(yNew).get(x) != null && yx.get(yNew).get(x1) != null){\\n                        sum = sum + yx.get(yNew).get(x)*entry.getValue()*yx.get(yNew).get(x1);\\n                    }\\n\\n                    yNew = y - dist;\\n\\n                    if(yx.get(yNew) != null && yx.get(yNew).get(x) != null && yx.get(yNew).get(x1) != null){\\n                        sum = sum + yx.get(yNew).get(x)*entry.getValue()*yx.get(yNew).get(x1);\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n\\n        return sum;\\n        \\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass DetectSquares {\\n\\n    Map<Integer, Map<Integer, Integer>> yx;\\n\\n\\n    public DetectSquares() {\\n        yx = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n\\n        if(yx.get(y) == null){\\n            yx.put(y, new HashMap<>());\\n        }\\n        yx.get(y).put(x, yx.get(y).getOrDefault(x, 0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n\\n        int x = point[0];\\n        int y = point[1];\\n\\n        int sum = 0;\\n\\n        if(yx.get(y) != null){\\n\\n            Map<Integer, Integer> map = yx.get(y);\\n\\n            for(Map.Entry<Integer, Integer> entry : map.entrySet()){\\n\\n                int x1 = entry.getKey();\\n\\n                if(Math.abs(x1 - x) > 0){\\n\\n                    int dist = Math.abs(x1 - x);\\n\\n                    int yNew = y + dist;\\n\\n                    if(yx.get(yNew) != null && yx.get(yNew).get(x) != null && yx.get(yNew).get(x1) != null){\\n                        sum = sum + yx.get(yNew).get(x)*entry.getValue()*yx.get(yNew).get(x1);\\n                    }\\n\\n                    yNew = y - dist;\\n\\n                    if(yx.get(yNew) != null && yx.get(yNew).get(x) != null && yx.get(yNew).get(x1) != null){\\n                        sum = sum + yx.get(yNew).get(x)*entry.getValue()*yx.get(yNew).get(x1);\\n                    }\\n\\n                }\\n\\n            }\\n\\n        }\\n\\n        return sum;\\n        \\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3402035,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n//-----------------------------------------\\n// C++\\n//-----------------------------------------\\nclass DetectSquares {\\n    unordered_map<int, unordered_map<int, int>> Map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        Map[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0, x1 = point[0], y1 = point[1];\\n        for(auto &[y2, _]: Map[x1]) {\\n            if(y2 == y1) continue;\\n            int dist = abs(y1 - y2);\\n            ans += Map[x1][y2] * (Map[x1 - dist][y2] * Map[x1 - dist][y1] + Map[x1 + dist][y2] * Map[x1 + dist][y1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n\\n\\n//-----------------------------------------\\n// Golang\\n//-----------------------------------------\\ntype DetectSquares struct {\\n    Map map[int]map[int]int\\n}\\n\\n\\nfunc Constructor() DetectSquares {\\n    return DetectSquares {\\n        Map: make(map[int]map[int]int),\\n    }\\n}\\n\\n\\nfunc (this *DetectSquares) Add(point []int)  {\\n    if _, ok := this.Map[point[0]]; !ok {\\n        this.Map[point[0]] = make(map[int]int)\\n    }\\n    this.Map[point[0]][point[1]]++\\n}\\n\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n    var ans, x1, y1 = 0, point[0], point[1]\\n    for y2, _ := range this.Map[x1] {\\n        if y2 == y1 {continue}\\n        var dist int = y1 - y2\\n        if y1 - y2 < 0 {dist = y2 - y1}\\n        ans += this.Map[x1][y2] * (this.Map[x1 - dist][y2] * this.Map[x1 - dist][y1] + this.Map[x1 + dist][y2] * this.Map[x1 + dist][y1])\\n    }\\n    return ans\\n}\\n\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(point);\\n * param_2 := obj.Count(point);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "Design",
                    "Counting"
                ],
                "code": "```\\n//-----------------------------------------\\n// C++\\n//-----------------------------------------\\nclass DetectSquares {\\n    unordered_map<int, unordered_map<int, int>> Map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        Map[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0, x1 = point[0], y1 = point[1];\\n        for(auto &[y2, _]: Map[x1]) {\\n            if(y2 == y1) continue;\\n            int dist = abs(y1 - y2);\\n            ans += Map[x1][y2] * (Map[x1 - dist][y2] * Map[x1 - dist][y1] + Map[x1 + dist][y2] * Map[x1 + dist][y1]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n\\n\\n//-----------------------------------------\\n// Golang\\n//-----------------------------------------\\ntype DetectSquares struct {\\n    Map map[int]map[int]int\\n}\\n\\n\\nfunc Constructor() DetectSquares {\\n    return DetectSquares {\\n        Map: make(map[int]map[int]int),\\n    }\\n}\\n\\n\\nfunc (this *DetectSquares) Add(point []int)  {\\n    if _, ok := this.Map[point[0]]; !ok {\\n        this.Map[point[0]] = make(map[int]int)\\n    }\\n    this.Map[point[0]][point[1]]++\\n}\\n\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n    var ans, x1, y1 = 0, point[0], point[1]\\n    for y2, _ := range this.Map[x1] {\\n        if y2 == y1 {continue}\\n        var dist int = y1 - y2\\n        if y1 - y2 < 0 {dist = y2 - y1}\\n        ans += this.Map[x1][y2] * (this.Map[x1 - dist][y2] * this.Map[x1 - dist][y1] + this.Map[x1 + dist][y2] * this.Map[x1 + dist][y1])\\n    }\\n    return ans\\n}\\n\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * obj := Constructor();\\n * obj.Add(point);\\n * param_2 := obj.Count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203146,
                "title": "this-question-does-not-need-time-and-space-optimization-just-brute-force-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUseless question - no need to optimise space and time\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> graph{1001, vector<int>(1001, 0)};\\n    DetectSquares() {\\n       \\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        graph[x][y]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        int count = 0;\\n\\n        /*For every point (x,y), we can find square around it of len = 1 to 1000\\n         _____________\\n        |  2   |  1   |\\n        |_____(x,y)___|\\n        |    3 |  4   |\\n        |______|______|\\n        */\\n\\n        for(int len = 1; len <=1000; len++){\\n            // finding any square 1 of len\\n            if(x-len >= 0 && y+len <= 1000)\\n                count += graph[x-len][y+len] * graph[x-len][y] * graph[x][y+len];\\n\\n            // finding any square 2 of len\\n            if(x-len >= 0 && y-len >= 0)\\n                count += graph[x-len][y-len] * graph[x-len][y] *  graph[x][y-len];\\n\\n            // finding any square 3 of len\\n            if(x+len <= 1000 && y-len >=0)\\n                count += graph[x+len][y-len] * graph[x+len][y] * graph[x][y-len];\\n\\n            // finding any square 4 of len\\n            if(x+len <=1000 && y+len <= 1000)\\n                count += graph[x+len][y+len] * graph[x+len][y] * graph[x][y+len];\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> graph{1001, vector<int>(1001, 0)};\\n    DetectSquares() {\\n       \\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        graph[x][y]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0];\\n        int y = point[1];\\n        int count = 0;\\n\\n        /*For every point (x,y), we can find square around it of len = 1 to 1000\\n         _____________\\n        |  2   |  1   |\\n        |_____(x,y)___|\\n        |    3 |  4   |\\n        |______|______|\\n        */\\n\\n        for(int len = 1; len <=1000; len++){\\n            // finding any square 1 of len\\n            if(x-len >= 0 && y+len <= 1000)\\n                count += graph[x-len][y+len] * graph[x-len][y] * graph[x][y+len];\\n\\n            // finding any square 2 of len\\n            if(x-len >= 0 && y-len >= 0)\\n                count += graph[x-len][y-len] * graph[x-len][y] *  graph[x][y-len];\\n\\n            // finding any square 3 of len\\n            if(x+len <= 1000 && y-len >=0)\\n                count += graph[x+len][y-len] * graph[x+len][y] * graph[x][y-len];\\n\\n            // finding any square 4 of len\\n            if(x+len <=1000 && y+len <= 1000)\\n                count += graph[x+len][y+len] * graph[x+len][y] * graph[x][y+len];\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834014,
                "title": "python3-using-hashmap",
                "content": "\\n```\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points=defaultdict(lambda :defaultdict(int))\\n    def add(self, point: List[int]) -> None:\\n        x,y = point\\n        self.points[y][x]+=1\\n    def count(self, point: List[int]) -> int:\\n        X,Y = point\\n        count = 0\\n        for x in self.points[Y]:\\n            d=abs(x-X)\\n            if d==0:continue\\n            count+=(self.points[Y-d][x]*self.points[Y-d][X]*self.points[Y][x])\\n            count+=(self.points[Y+d][x]*self.points[Y+d][X]*self.points[Y][x])\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points=defaultdict(lambda :defaultdict(int))\\n    def add(self, point: List[int]) -> None:\\n        x,y = point\\n        self.points[y][x]+=1\\n    def count(self, point: List[int]) -> int:\\n        X,Y = point\\n        count = 0\\n        for x in self.points[Y]:\\n            d=abs(x-X)\\n            if d==0:continue\\n            count+=(self.points[Y-d][x]*self.points[Y-d][X]*self.points[Y][x])\\n            count+=(self.points[Y+d][x]*self.points[Y+d][X]*self.points[Y][x])\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2763403,
                "title": "go-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(len(points))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(len(points))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npackage main\\n\\ntype DetectSquares struct {\\n\\tcnt map[[2]int]int\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{\\n\\t\\tcnt: map[[2]int]int{},\\n\\t}\\n}\\n\\nfunc (this *DetectSquares) Add(point []int) {\\n\\tthis.cnt[[2]int{point[0], point[1]}]++\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n\\tpx, py := point[0], point[1]\\n\\tx, y := px, py\\n\\n\\tres := 0\\n\\tfor k, cnt1 := range this.cnt {\\n\\t\\tx, y = k[0], k[1]\\n\\t\\tif abs(x-px) != abs(y-py) || (x == px && y == py) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcnt2, f2 := this.cnt[[2]int{x, py}]\\n\\t\\tcnt3, f3 := this.cnt[[2]int{px, y}]\\n\\t\\tif f2 && f3 {\\n\\t\\t\\tres += cnt1 * cnt2 * cnt3\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\npackage main\\n\\ntype DetectSquares struct {\\n\\tcnt map[[2]int]int\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{\\n\\t\\tcnt: map[[2]int]int{},\\n\\t}\\n}\\n\\nfunc (this *DetectSquares) Add(point []int) {\\n\\tthis.cnt[[2]int{point[0], point[1]}]++\\n}\\n\\nfunc abs(a int) int {\\n\\tif a < 0 {\\n\\t\\treturn -a\\n\\t}\\n\\treturn a\\n}\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n\\tpx, py := point[0], point[1]\\n\\tx, y := px, py\\n\\n\\tres := 0\\n\\tfor k, cnt1 := range this.cnt {\\n\\t\\tx, y = k[0], k[1]\\n\\t\\tif abs(x-px) != abs(y-py) || (x == px && y == py) {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tcnt2, f2 := this.cnt[[2]int{x, py}]\\n\\t\\tcnt3, f3 := this.cnt[[2]int{px, y}]\\n\\t\\tif f2 && f3 {\\n\\t\\t\\tres += cnt1 * cnt2 * cnt3\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2553595,
                "title": "c-using-hashmap-o-n-time-solution-asked-in-google-interview",
                "content": "**C++ Code:**\\n\\n```\\n  map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x1=point[0];\\n        int y1=point[1];\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x2 = (it->first).first;\\n            int y2 = (it->first).second;\\n            //abs(x1-x2)==abs(y1-y2)  => This Condition avoid the count of rectangle =>it comes from observation\\n            if(x1!=x2 && y1!=y2 && abs(x1-x2)==abs(y1-y2) && mp.find({x1,y2})!=mp.end() && mp.find({x2,y1})!=mp.end())\\n            {\\n                int f1 = mp[{x2,y2}];\\n                int f2 = mp[{x2,y1}];\\n                int f3 = mp[{x1,y2}];\\n                count += f1*f2*f3;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  map<pair<int,int>,int>mp;\\n    DetectSquares() \\n    {\\n        \\n    }\\n    void add(vector<int> point) \\n    {\\n        mp[{point[0],point[1]}]++;\\n    }\\n    int count(vector<int> point) \\n    {\\n        int count=0;\\n        int x1=point[0];\\n        int y1=point[1];\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            int x2 = (it->first).first;\\n            int y2 = (it->first).second;\\n            //abs(x1-x2)==abs(y1-y2)  => This Condition avoid the count of rectangle =>it comes from observation\\n            if(x1!=x2 && y1!=y2 && abs(x1-x2)==abs(y1-y2) && mp.find({x1,y2})!=mp.end() && mp.find({x2,y1})!=mp.end())\\n            {\\n                int f1 = mp[{x2,y2}];\\n                int f2 = mp[{x2,y1}];\\n                int f3 = mp[{x1,y2}];\\n                count += f1*f2*f3;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2513376,
                "title": "java-hashmap-pair-approach",
                "content": "class DetectSquares {\\n    HashMap<Pair<Integer, Integer>, Integer> map;\\n    List<Pair<Integer, Integer>> pointsLst;\\n    public DetectSquares() {\\n        pointsLst = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        Pair<Integer, Integer> pair = new Pair(point[0], point[1]);\\n        map.put(pair, map.getOrDefault(pair, 0) + 1);\\n        pointsLst.add(pair);\\n        \\n    }\\n    \\n    public int count(int[] point) {\\n        \\n        int res = 0;\\n        int qx = point[0];\\n        int qy = point[1];\\n        \\n        for (int i = 0; i < pointsLst.size(); i++) {\\n            int x = pointsLst.get(i).getKey();\\n            int y = pointsLst.get(i).getValue();\\n            if ((x == qx && y == qy) || Math.abs(x - qx) != Math.abs(y - qy)) {\\n                continue;\\n            }\\n            Pair<Integer, Integer> newKey = new Pair(x, qy);\\n            Pair<Integer, Integer> newKey1 = new Pair(qx, y);\\n            if (map.containsKey(newKey) && map.containsKey(newKey1)) {\\n                res += map.get(newKey) * map.get(newKey1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */",
                "solutionTags": [],
                "code": "class DetectSquares {\\n    HashMap<Pair<Integer, Integer>, Integer> map;\\n    List<Pair<Integer, Integer>> pointsLst;\\n    public DetectSquares() {\\n        pointsLst = new ArrayList<>();\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        Pair<Integer, Integer> pair = new Pair(point[0], point[1]);\\n        map.put(pair, map.getOrDefault(pair, 0) + 1);\\n        pointsLst.add(pair);\\n        \\n    }\\n    \\n    public int count(int[] point) {\\n        \\n        int res = 0;\\n        int qx = point[0];\\n        int qy = point[1];\\n        \\n        for (int i = 0; i < pointsLst.size(); i++) {\\n            int x = pointsLst.get(i).getKey();\\n            int y = pointsLst.get(i).getValue();\\n            if ((x == qx && y == qy) || Math.abs(x - qx) != Math.abs(y - qy)) {\\n                continue;\\n            }\\n            Pair<Integer, Integer> newKey = new Pair(x, qy);\\n            Pair<Integer, Integer> newKey1 = new Pair(qx, y);\\n            if (map.containsKey(newKey) && map.containsKey(newKey1)) {\\n                res += map.get(newKey) * map.get(newKey1);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 2512110,
                "title": "c-hashmap-with-comments-and-explanation-coordinate-geometry",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int, int>,int> mp;\\n    \\n    DetectSquares() {\\n        return ;\\n    }\\n    \\n    void add(vector<int> point) {\\n        // add the pair to the map to keep count of same numbers\\n        mp[{point[0],point[1]}]++;\\n        return ;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        int x1= point[0], y1 = point[1];\\n        \\n        // traverse the map to find the rest 3 points of square \\n        // considering x1,y1 is first point\\n        for(auto pt : mp){\\n            pair<int,int> it = pt.first;\\n            // find the diagonal point of x1,y1 i.e. find x3,y3\\n            if(it.first!=x1 && it.second!=y1 && (abs(it.first-x1)==abs(it.second-y1))){\\n                // now we need to find x2,y2 and x4,y4\\n                // there corrdinates are (x3,y1) and (x1,y3) \\n                // i.e. it.first,y1 & x1,it.second\\n                // number of squares will be multiply of counts of x2,y2 x3,y3 & x4,y4\\n                count += mp[{it.first,it.second}]*mp[{it.first,y1}]*mp[{x1,it.second}];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Geometry"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int, int>,int> mp;\\n    \\n    DetectSquares() {\\n        return ;\\n    }\\n    \\n    void add(vector<int> point) {\\n        // add the pair to the map to keep count of same numbers\\n        mp[{point[0],point[1]}]++;\\n        return ;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        int x1= point[0], y1 = point[1];\\n        \\n        // traverse the map to find the rest 3 points of square \\n        // considering x1,y1 is first point\\n        for(auto pt : mp){\\n            pair<int,int> it = pt.first;\\n            // find the diagonal point of x1,y1 i.e. find x3,y3\\n            if(it.first!=x1 && it.second!=y1 && (abs(it.first-x1)==abs(it.second-y1))){\\n                // now we need to find x2,y2 and x4,y4\\n                // there corrdinates are (x3,y1) and (x1,y3) \\n                // i.e. it.first,y1 & x1,it.second\\n                // number of squares will be multiply of counts of x2,y2 x3,y3 & x4,y4\\n                count += mp[{it.first,it.second}]*mp[{it.first,y1}]*mp[{x1,it.second}];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460739,
                "title": "kotlin-o-n",
                "content": "```\\n// Based on https://www.youtube.com/watch?v=bahebearrDc\\nclass DetectSquares() {\\n    private val points: MutableList<IntArray> = mutableListOf()\\n    private val pointCountMap: MutableMap<String, Int> = mutableMapOf()\\n\\n    fun add(point: IntArray) {\\n        val key = \"${point[0]}:${point[1]}\"\\n        if (pointCountMap.containsKey(key)) {\\n            pointCountMap.put(key, pointCountMap.getOrDefault(key, 0) + 1)\\n        } else {\\n            points.add(point)    \\n            pointCountMap.put(key, 1)\\n        }\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var x = point[0]\\n        var y = point[1]\\n        var result = 0\\n        \\n        points.forEach { p ->\\n            val notTheSamePoint = p[0] != x && p[1] != y\\n            // in a square the distance for x and y needs to be the same to be the diagonal point\\n            val isDiagonal = Math.abs(x - p[0]) == Math.abs(y - p[1])\\n            if (notTheSamePoint && isDiagonal) {\\n                val topLeft = pointCountMap.getOrDefault(\"$x:${p[1]}\", 0)\\n                val bottomRight = pointCountMap.getOrDefault(\"${p[0]}:$y\", 0)\\n                val diagonal = pointCountMap.getOrDefault(\"${p[0]}:${p[1]}\", 0)\\n                result += topLeft * bottomRight * diagonal\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Math",
                    "Geometry"
                ],
                "code": "```\\n// Based on https://www.youtube.com/watch?v=bahebearrDc\\nclass DetectSquares() {\\n    private val points: MutableList<IntArray> = mutableListOf()\\n    private val pointCountMap: MutableMap<String, Int> = mutableMapOf()\\n\\n    fun add(point: IntArray) {\\n        val key = \"${point[0]}:${point[1]}\"\\n        if (pointCountMap.containsKey(key)) {\\n            pointCountMap.put(key, pointCountMap.getOrDefault(key, 0) + 1)\\n        } else {\\n            points.add(point)    \\n            pointCountMap.put(key, 1)\\n        }\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var x = point[0]\\n        var y = point[1]\\n        var result = 0\\n        \\n        points.forEach { p ->\\n            val notTheSamePoint = p[0] != x && p[1] != y\\n            // in a square the distance for x and y needs to be the same to be the diagonal point\\n            val isDiagonal = Math.abs(x - p[0]) == Math.abs(y - p[1])\\n            if (notTheSamePoint && isDiagonal) {\\n                val topLeft = pointCountMap.getOrDefault(\"$x:${p[1]}\", 0)\\n                val bottomRight = pointCountMap.getOrDefault(\"${p[0]}:$y\", 0)\\n                val diagonal = pointCountMap.getOrDefault(\"${p[0]}:${p[1]}\", 0)\\n                result += topLeft * bottomRight * diagonal\\n            }\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419118,
                "title": "java-hashmap-beats-90-no-strings",
                "content": "We use a map to store the points and keep track of the number of duplicates.\\n\\ncount method:\\nWe iterate over each key in the hashmap, lets call it p3, to check if this is diagonal to the input point (p1).\\n\\nIf these points are diagonal to eachother, we multiply the count of each corner to get the number of squares we can create. If one corner doesnt exists we just add 0 to the res, since we use getOrDefault(point,0). We do this for each key in the map.\\n\\n\\n```java\\nclass DetectSquares {\\n        HashMap<List<Integer>,Integer> numberOfPoints = new HashMap<>();\\n        public DetectSquares() {}\\n\\n        public void add(int[] point) {\\n            List<Integer> p = List.of(point[0],point[1]);\\n            numberOfPoints.put(p,numberOfPoints.getOrDefault(p,0)+1);\\n        }\\n\\n        public int count(int[] p1) {\\n            int res = 0;\\n            int x = p1[0];\\n            int y = p1[1];\\n\\n            for (List<Integer> p3:numberOfPoints.keySet()) {\\n                if(Math.abs(p3.get(0)-x) !=0 && Math.abs(p3.get(0)-x) == Math.abs(p3.get(1)-y)){\\n                    res+=numberOfPoints.getOrDefault(List.of(p3.get(0),y),0)\\n                            *numberOfPoints.getOrDefault(List.of(x,p3.get(1)),0)\\n                    *numberOfPoints.get(p3);\\n                }\\n            }\\n            return res;\\n        }\\n\\t\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass DetectSquares {\\n        HashMap<List<Integer>,Integer> numberOfPoints = new HashMap<>();\\n        public DetectSquares() {}\\n\\n        public void add(int[] point) {\\n            List<Integer> p = List.of(point[0],point[1]);\\n            numberOfPoints.put(p,numberOfPoints.getOrDefault(p,0)+1);\\n        }\\n\\n        public int count(int[] p1) {\\n            int res = 0;\\n            int x = p1[0];\\n            int y = p1[1];\\n\\n            for (List<Integer> p3:numberOfPoints.keySet()) {\\n                if(Math.abs(p3.get(0)-x) !=0 && Math.abs(p3.get(0)-x) == Math.abs(p3.get(1)-y)){\\n                    res+=numberOfPoints.getOrDefault(List.of(p3.get(0),y),0)\\n                            *numberOfPoints.getOrDefault(List.of(x,p3.get(1)),0)\\n                    *numberOfPoints.get(p3);\\n                }\\n            }\\n            return res;\\n        }\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2322094,
                "title": "python-simple-hasmap",
                "content": "\\n    def __init__(self):\\n        self.dict1 = defaultdict(int)\\n\\n    def add(self, point):\\n        self.dict1[tuple(point)] += 1\\n\\n    def count(self, point):\\n        total = 0\\n        x1, y1 = point\\n        \\n        for x, y in self.dict1:\\n            if (x, y1) in self.dict1 and (x1, y) in self.dict1 and abs(x - x1) == abs(y - y1) and x != x1:\\n                total += self.dict1[(x,y)]*self.dict1[(x,y1)]*self.dict1[(x1,y)]\\n                \\n        return total",
                "solutionTags": [],
                "code": "\\n    def __init__(self):\\n        self.dict1 = defaultdict(int)\\n\\n    def add(self, point):\\n        self.dict1[tuple(point)] += 1\\n\\n    def count(self, point):\\n        total = 0\\n        x1, y1 = point\\n        \\n        for x, y in self.dict1:\\n            if (x, y1) in self.dict1 and (x1, y) in self.dict1 and abs(x - x1) == abs(y - y1) and x != x1:\\n                total += self.dict1[(x,y)]*self.dict1[(x,y1)]*self.dict1[(x1,y)]\\n                \\n        return total",
                "codeTag": "Python3"
            },
            {
                "id": 2276216,
                "title": "c-map",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> nums;\\n    int mp[2001][2001] = {0};\\n    DetectSquares() {\\n        nums = vector<vector<int>>(1001);\\n    }\\n    \\n    void add(vector<int> point) {\\n        nums[point[1]].push_back(point[0]);\\n        mp[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        int re = 0, i = p[0], j = p[1];  // point1 {i,j}\\n        for(int k = 0; k<nums[j].size();++k){\\n            int r = nums[j][k];  // point2 {r,j}\\n            int d = abs(r-i);\\n            if(d==0) continue;\\n            int a = i, b = j+d;   // possible point3 {a,b}\\n            int x = r, y = j+d;   // possible point4 {x,y}\\n            if(a>=0 && b>=0 && x>=0 && y>=0) re+= mp[a][b]*mp[r][y];\\n            a = i, b = j-d;    // possible point3 {a,b}\\n            x = r, y = j-d;   // possible point4 {x,y}\\n            if(a>=0 && b>=0 && x>=0 && y>=0) re+= mp[a][b]*mp[x][y];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> nums;\\n    int mp[2001][2001] = {0};\\n    DetectSquares() {\\n        nums = vector<vector<int>>(1001);\\n    }\\n    \\n    void add(vector<int> point) {\\n        nums[point[1]].push_back(point[0]);\\n        mp[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        int re = 0, i = p[0], j = p[1];  // point1 {i,j}\\n        for(int k = 0; k<nums[j].size();++k){\\n            int r = nums[j][k];  // point2 {r,j}\\n            int d = abs(r-i);\\n            if(d==0) continue;\\n            int a = i, b = j+d;   // possible point3 {a,b}\\n            int x = r, y = j+d;   // possible point4 {x,y}\\n            if(a>=0 && b>=0 && x>=0 && y>=0) re+= mp[a][b]*mp[r][y];\\n            a = i, b = j-d;    // possible point3 {a,b}\\n            x = r, y = j-d;   // possible point4 {x,y}\\n            if(a>=0 && b>=0 && x>=0 && y>=0) re+= mp[a][b]*mp[x][y];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256005,
                "title": "java-hashmap",
                "content": "```\\nclass DetectSquares {\\n    HashMap<Pair<Integer, Integer>, Integer> map;\\n    int maxRow;\\n    int maxCol;\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        maxRow = 0;\\n        maxCol = 0;\\n    }\\n    \\n    public void add(int[] point) {\\n        int r = point[1];\\n        int c = point[0];\\n        map.put(new Pair<>(r, c), map.getOrDefault(new Pair<>(r, c), 0) + 1);\\n        maxRow = Math.max(maxRow, r);\\n        maxCol = Math.max(maxCol, c);\\n    }\\n    \\n    public int count(int[] point) {\\n        int ans = 0;\\n        int r = point[1];\\n        int c = point[0];\\n        if (r > maxRow || c > maxCol) return ans;\\n        \\n        for (int row = 0; row <= maxRow; row++) {\\n            if (r != row && map.containsKey(new Pair<>(row, c))) {\\n                int len = Math.abs(row - r);\\n                ans += map.getOrDefault(new Pair<>(row, c), 0) * map.getOrDefault(new Pair<>(row, c - len), 0) * map.getOrDefault(new Pair<>(r, c - len), 0);\\n                ans += map.getOrDefault(new Pair<>(row, c), 0) * map.getOrDefault(new Pair<>(row, c + len), 0) * map.getOrDefault(new Pair<>(r, c + len), 0);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    HashMap<Pair<Integer, Integer>, Integer> map;\\n    int maxRow;\\n    int maxCol;\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        maxRow = 0;\\n        maxCol = 0;\\n    }\\n    \\n    public void add(int[] point) {\\n        int r = point[1];\\n        int c = point[0];\\n        map.put(new Pair<>(r, c), map.getOrDefault(new Pair<>(r, c), 0) + 1);\\n        maxRow = Math.max(maxRow, r);\\n        maxCol = Math.max(maxCol, c);\\n    }\\n    \\n    public int count(int[] point) {\\n        int ans = 0;\\n        int r = point[1];\\n        int c = point[0];\\n        if (r > maxRow || c > maxCol) return ans;\\n        \\n        for (int row = 0; row <= maxRow; row++) {\\n            if (r != row && map.containsKey(new Pair<>(row, c))) {\\n                int len = Math.abs(row - r);\\n                ans += map.getOrDefault(new Pair<>(row, c), 0) * map.getOrDefault(new Pair<>(row, c - len), 0) * map.getOrDefault(new Pair<>(r, c - len), 0);\\n                ans += map.getOrDefault(new Pair<>(row, c), 0) * map.getOrDefault(new Pair<>(row, c + len), 0) * map.getOrDefault(new Pair<>(r, c + len), 0);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238644,
                "title": "python-beats-99-7-with-description-o-min-unique-y-x-unique-x-y",
                "content": "### Summary:\\nThis solution exploits the definition of a square having vertices:\\n- `(x, y)`, `(x, yp)`, `(xp, y)`, `(xp, yp)`\\n- `dx = dy = abs(y - yp) = abs(x - yp)`\\n\\nFrom this we can infer that:\\n- We only need to determine: `xp, yp`. (`x` and `y` are given)\\n- If we have a valid `yp`, there are only two possible `xp`: `x +/- dx` (left, right)\\n- `dx = dy = (yp - y)`\\n\\nThis means that since `(x, y)` is given, we just need to search over `yp` that are known to coincide with `x` (which we can lookup in O(1) via a maintained map). For each valid `yp`, then the only valid `xp` is known to be `x +/- dx`, where `dx=yp-y`. We just need to check both `xp` cases for existence: left, right.\\n\\nHowever, we can do slightly better by:\\n- Rotating (swap x, y) to ensure we iterate over the smaller unique values of x or y\\n- Determine the smallest unique space to iterate over\\n- Maintaining counts of each (x, y) which we can use to compute duplicates\\n\\nNotes:\\n- add: O(1)\\n- count: O(min(unique x|y, unique y|x))\\n\\n```\\nfrom collections import defaultdict\\n\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.xs = defaultdict(dict) # {y: {x: count}}\\n        self.ys = defaultdict(dict)\\n        \\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        yxs = self.xs[y]\\n        yxs[x] = yxs.get(x, 0) + 1\\n        xys = self.ys[x]\\n        xys[y] = xys.get(y, 0) + 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        \\n        # Iterate over the fewest values\\n        if len(self.xs[y]) < len(self.ys[x]):\\n            ys = self.xs # rotate and make y x\\n            y, x = x, y\\n        else:\\n            ys = self.ys\\n        \\n        xy_count = 1\\n        new_squares = 0\\n        for yp, xyp_count in ys[x].items():\\n            if yp == y: continue # same as (x, y)\\n            dx = yp - y # abs(dx) > 0 since yp != y\\n            for xp in [x - dx, x + dx]: # try left/right xp\\n                xp_ys = ys[xp]\\n                if y in xp_ys and yp in xp_ys:\\n                    xpy_count = xp_ys[y]\\n                    xpyp_count = xp_ys[yp]\\n                    new_squares += (\\n                        xy_count *\\n                        xyp_count *\\n                        xpyp_count *\\n                        xpy_count\\n                    )\\n        \\n        return new_squares\\n```\\n",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.xs = defaultdict(dict) # {y: {x: count}}\\n        self.ys = defaultdict(dict)\\n        \\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        yxs = self.xs[y]\\n        yxs[x] = yxs.get(x, 0) + 1\\n        xys = self.ys[x]\\n        xys[y] = xys.get(y, 0) + 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        \\n        # Iterate over the fewest values\\n        if len(self.xs[y]) < len(self.ys[x]):\\n            ys = self.xs # rotate and make y x\\n            y, x = x, y\\n        else:\\n            ys = self.ys\\n        \\n        xy_count = 1\\n        new_squares = 0\\n        for yp, xyp_count in ys[x].items():\\n            if yp == y: continue # same as (x, y)\\n            dx = yp - y # abs(dx) > 0 since yp != y\\n            for xp in [x - dx, x + dx]: # try left/right xp\\n                xp_ys = ys[xp]\\n                if y in xp_ys and yp in xp_ys:\\n                    xpy_count = xp_ys[y]\\n                    xpyp_count = xp_ys[yp]\\n                    new_squares += (\\n                        xy_count *\\n                        xyp_count *\\n                        xpyp_count *\\n                        xpy_count\\n                    )\\n        \\n        return new_squares\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2107619,
                "title": "java-88-ms-using-pair-with-comments",
                "content": "```\\nclass DetectSquares {\\n\\n    /*\\n     * To maintain unique values and frequencies of each point.\\n     */\\n    Map<Pair<Integer, Integer>, Integer> point_counts;\\n    public DetectSquares() {\\n        point_counts = new HashMap<>();\\n    }\\n    \\n    /*\\n     * Add point in the map and check if it already exists. \\n     * If yes, increment the counter\\n     * If no, put 1\\n    */\\n    public void add(int[] point) {\\n       Pair<Integer, Integer> p = new Pair(point[0],point[1]);\\n       point_counts.put(p, point_counts.getOrDefault(p,0) + 1);\\n    }\\n    \\n    /*\\n     * This method goes through every entry in the map and checks if the respective entry is diagonal\\n     * If yes, \\n     *    1) check if row of the diagonal point and column of the input point exist in the map\\n     *    2) check if the column of diagonal point and row of the input point exist in the map\\n     *    3) If both the above conditions are correct check if the diagonal points have same distance (to verify that the points are square and NOT a rectangle)\\n     *          if all 3 conditions satisfy, multiply all their frequencies and add that the the resulting count variable (i.e. square_count)\\n     * \\n    */\\n    public int count(int[] point) {   \\n        int square_count = 0;\\n        for(Pair<Integer, Integer> diagonal_corner : point_counts.keySet()){\\n        \\n           \\n            int diagonal_row = diagonal_corner.getKey();\\n            int diagonal_col = diagonal_corner.getValue();\\n            \\n            boolean matching_row = (diagonal_row == point[0]);\\n            boolean matching_col = (diagonal_col == point[1]);\\n            boolean is_square = (Math.abs(diagonal_row - point[0]) == Math.abs(diagonal_col - point[1]));\\n            \\n            if( !matching_row && !matching_col && is_square){\\n                Pair<Integer, Integer> corner1 = new Pair(point[0],diagonal_col);\\n                Pair<Integer, Integer> corner2 = new Pair(diagonal_row, point[1]);\\n                \\n                int freq_diagonal = point_counts.getOrDefault(diagonal_corner,0);\\n                int freq1 = point_counts.getOrDefault(corner1,0);\\n                int freq2 = point_counts.getOrDefault(corner2,0);\\n                \\n                square_count += (freq_diagonal * freq1 * freq2);\\n            }\\n        }\\n        return  square_count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n\\n    /*\\n     * To maintain unique values and frequencies of each point.\\n     */\\n    Map<Pair<Integer, Integer>, Integer> point_counts;\\n    public DetectSquares() {\\n        point_counts = new HashMap<>();\\n    }\\n    \\n    /*\\n     * Add point in the map and check if it already exists. \\n     * If yes, increment the counter\\n     * If no, put 1\\n    */\\n    public void add(int[] point) {\\n       Pair<Integer, Integer> p = new Pair(point[0],point[1]);\\n       point_counts.put(p, point_counts.getOrDefault(p,0) + 1);\\n    }\\n    \\n    /*\\n     * This method goes through every entry in the map and checks if the respective entry is diagonal\\n     * If yes, \\n     *    1) check if row of the diagonal point and column of the input point exist in the map\\n     *    2) check if the column of diagonal point and row of the input point exist in the map\\n     *    3) If both the above conditions are correct check if the diagonal points have same distance (to verify that the points are square and NOT a rectangle)\\n     *          if all 3 conditions satisfy, multiply all their frequencies and add that the the resulting count variable (i.e. square_count)\\n     * \\n    */\\n    public int count(int[] point) {   \\n        int square_count = 0;\\n        for(Pair<Integer, Integer> diagonal_corner : point_counts.keySet()){\\n        \\n           \\n            int diagonal_row = diagonal_corner.getKey();\\n            int diagonal_col = diagonal_corner.getValue();\\n            \\n            boolean matching_row = (diagonal_row == point[0]);\\n            boolean matching_col = (diagonal_col == point[1]);\\n            boolean is_square = (Math.abs(diagonal_row - point[0]) == Math.abs(diagonal_col - point[1]));\\n            \\n            if( !matching_row && !matching_col && is_square){\\n                Pair<Integer, Integer> corner1 = new Pair(point[0],diagonal_col);\\n                Pair<Integer, Integer> corner2 = new Pair(diagonal_row, point[1]);\\n                \\n                int freq_diagonal = point_counts.getOrDefault(diagonal_corner,0);\\n                int freq1 = point_counts.getOrDefault(corner1,0);\\n                int freq2 = point_counts.getOrDefault(corner2,0);\\n                \\n                square_count += (freq_diagonal * freq1 * freq2);\\n            }\\n        }\\n        return  square_count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073266,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass DetectSquares {\\n    public Map<Pair<Integer, Integer>, Integer> map; // points\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    public void add(int[] point) {\\n        Pair<Integer, Integer> p = new Pair(point[0], point[1]);\\n        Integer c = map.get(p);\\n        if (c != null) {\\n            map.put(p, c + 1);\\n        } else {\\n            map.put(p, 1);\\n        }\\n    }\\n    \\n    public int count(int[] point) {\\n        if (map.size() < 3) {\\n            return 0;\\n        }\\n        int res = 0; // count\\n\\n        int x = point[0];\\n        int y = point[1];\\n        \\n        Pair<Integer, Integer> p = new Pair(x, y);\\n        \\n        for (Pair<Integer, Integer> p1 : map.keySet()) {\\n            // find first point, y1 = yp, but x1 != xp\\n            if (p1.getKey() != x && p1.getValue() == y) {\\n                int c1 = map.get(p1);\\n                int x1 = p1.getKey();\\n                int y1 = p1.getValue();\\n                \\n                // find 2nd point, Math.abs(y2 - y1) = Math.abs(x1 - xp), x2 == x1\\n                // find 3rd point, x3 = x, y3 = y2\\n                \\n                Pair<Integer, Integer> p2 = new Pair(x1, y1 + Math.abs(x1 - x));\\n                Pair<Integer, Integer> p3 = new Pair(x, y1 + Math.abs(x1 - x));\\n                \\n                if (map.containsKey(p2) && map.containsKey(p3)) {\\n                    res += c1 * map.get(p2) * map.get(p3);\\n                }\\n                \\n                p2 = new Pair(x1, y1 - Math.abs(x1 - x));\\n                p3 = new Pair(x, y1 - Math.abs(x1 - x));\\n                \\n                if (map.containsKey(p2) && map.containsKey(p3)) {\\n                    res += c1 * map.get(p2) * map.get(p3);\\n                }\\n            }\\n        }\\n        return res;     \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    public Map<Pair<Integer, Integer>, Integer> map; // points\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    public void add(int[] point) {\\n        Pair<Integer, Integer> p = new Pair(point[0], point[1]);\\n        Integer c = map.get(p);\\n        if (c != null) {\\n            map.put(p, c + 1);\\n        } else {\\n            map.put(p, 1);\\n        }\\n    }\\n    \\n    public int count(int[] point) {\\n        if (map.size() < 3) {\\n            return 0;\\n        }\\n        int res = 0; // count\\n\\n        int x = point[0];\\n        int y = point[1];\\n        \\n        Pair<Integer, Integer> p = new Pair(x, y);\\n        \\n        for (Pair<Integer, Integer> p1 : map.keySet()) {\\n            // find first point, y1 = yp, but x1 != xp\\n            if (p1.getKey() != x && p1.getValue() == y) {\\n                int c1 = map.get(p1);\\n                int x1 = p1.getKey();\\n                int y1 = p1.getValue();\\n                \\n                // find 2nd point, Math.abs(y2 - y1) = Math.abs(x1 - xp), x2 == x1\\n                // find 3rd point, x3 = x, y3 = y2\\n                \\n                Pair<Integer, Integer> p2 = new Pair(x1, y1 + Math.abs(x1 - x));\\n                Pair<Integer, Integer> p3 = new Pair(x, y1 + Math.abs(x1 - x));\\n                \\n                if (map.containsKey(p2) && map.containsKey(p3)) {\\n                    res += c1 * map.get(p2) * map.get(p3);\\n                }\\n                \\n                p2 = new Pair(x1, y1 - Math.abs(x1 - x));\\n                p3 = new Pair(x, y1 - Math.abs(x1 - x));\\n                \\n                if (map.containsKey(p2) && map.containsKey(p3)) {\\n                    res += c1 * map.get(p2) * map.get(p3);\\n                }\\n            }\\n        }\\n        return res;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2052608,
                "title": "java-solution-using-array",
                "content": "```\\nclass DetectSquares {\\n\\n    int[][] counts = new int[1001][1001];\\n    public DetectSquares() {\\n        for (int i = 0; i <= 1000; i++) {\\n            for (int j = 0; j <= 1000; j++) {\\n                counts[i][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    public void add(int[] point) {\\n        counts[point[0]][point[1]]++;\\n    }\\n    \\n    public int count(int[] point) {\\n        int res = 0;\\n        for (int i = 0; i <= 1000; i++) {\\n            int x = point[0], y = point[1];\\n            int d = Math.abs(x - i);\\n            if (d == 0) continue;\\n            int j = y + d;\\n            if (j >= 0 && j <= 1000) {\\n                res += counts[i][j] * counts[i][y] * counts[x][j];\\n            }\\n            j = y - d;\\n            if (j >= 0 && j <= 1000) {\\n                res += counts[i][j] * counts[i][y] * counts[x][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n\\n    int[][] counts = new int[1001][1001];\\n    public DetectSquares() {\\n        for (int i = 0; i <= 1000; i++) {\\n            for (int j = 0; j <= 1000; j++) {\\n                counts[i][j] = 0;\\n            }\\n        }\\n    }\\n    \\n    public void add(int[] point) {\\n        counts[point[0]][point[1]]++;\\n    }\\n    \\n    public int count(int[] point) {\\n        int res = 0;\\n        for (int i = 0; i <= 1000; i++) {\\n            int x = point[0], y = point[1];\\n            int d = Math.abs(x - i);\\n            if (d == 0) continue;\\n            int j = y + d;\\n            if (j >= 0 && j <= 1000) {\\n                res += counts[i][j] * counts[i][y] * counts[x][j];\\n            }\\n            j = y - d;\\n            if (j >= 0 && j <= 1000) {\\n                res += counts[i][j] * counts[i][y] * counts[x][j];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043168,
                "title": "python-easy-peasy-with-comments",
                "content": "# Solution\\n\\nIn this solution, we will be using a HashMap to store all points and their occurrences. Then, when counting the number of squares for a given point query (p1), we will iterate over all our points (p2), and if (p1) and (p2) can form a valid square, then we will look if (p3) and (p4) exist in our HashMap. If (p1), (p2), (p3), and (p4) exist, then we can obtain all the possible ways to build this square by multiplying the occurrences of (p2), (p3), and (p4).\\n\\nTime: O(n)\\nSpace: O(n)\\n\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n        \\n    def count(self, p1: List[int]) -> int:\\n        count = 0\\n        \\n        for p2 in self.points.keys():\\n            delt_x = abs(p2[0] - p1[0]) \\n            delt_y = abs(p2[1] - p1[1])\\n            valid_square = delt_x != 0 and delt_y != 0 and delt_x == delt_y \\n            \\n            p3 = (p1[0], p2[1])\\n            p4 = (p2[0], p1[1])\\n            \\n            if valid_square and p3 in self.points and p4 in self.points:\\n                count += self.points[p2] * self.points[p3] * self.points[p4]\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n        \\n    def count(self, p1: List[int]) -> int:\\n        count = 0\\n        \\n        for p2 in self.points.keys():\\n            delt_x = abs(p2[0] - p1[0]) \\n            delt_y = abs(p2[1] - p1[1])\\n            valid_square = delt_x != 0 and delt_y != 0 and delt_x == delt_y \\n            \\n            p3 = (p1[0], p2[1])\\n            p4 = (p2[0], p1[1])\\n            \\n            if valid_square and p3 in self.points and p4 in self.points:\\n                count += self.points[p2] * self.points[p3] * self.points[p4]\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2022123,
                "title": "wrong-test-case-really-not",
                "content": "```\\n[\"DetectSquares\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"count\"]\\n\\n[[],\\n[[5,10]],[[10,5]],[[10,10]],\\n[[3,0]],[[8,0]],[[8,5]],\\n[[9,0]],[[9,8]],[[1,8]],\\n[[0,0]],[[8,0]],[[8,8]],\\n[[0,8]]]\\n\\nor in test format:\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[5,10]],[[10,5]],[[10,10]],[[3,0]],[[8,0]],[[8,5]],[[9,0]],[[9,8]],[[1,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```\\nThe last point [0,8] has 3 Detect Squares: ([0,8] [0,0] [8,0]x2 [8,8])x2  ([0,8] [0,0] [9,0] [9,8]).\\nBut test case reports 2 as the right answer.\\n\\n",
                "solutionTags": [],
                "code": "```\\n[\"DetectSquares\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"add\",\"add\",\"add\",\\n\"count\"]\\n\\n[[],\\n[[5,10]],[[10,5]],[[10,10]],\\n[[3,0]],[[8,0]],[[8,5]],\\n[[9,0]],[[9,8]],[[1,8]],\\n[[0,0]],[[8,0]],[[8,8]],\\n[[0,8]]]\\n\\nor in test format:\\n[\"DetectSquares\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"add\",\"count\"]\\n[[],[[5,10]],[[10,5]],[[10,10]],[[3,0]],[[8,0]],[[8,5]],[[9,0]],[[9,8]],[[1,8]],[[0,0]],[[8,0]],[[8,8]],[[0,8]]]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1997514,
                "title": "clean-intuitive-python-with-explanation-and-base-implementation",
                "content": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points_x = defaultdict(set) # points_x[x] contains all points (px, py) with px = x\\n        self.points_y = defaultdict(set) # points_y[y] contains all points (px, py) with py = y\\n        self.points_count = defaultdict(lambda: 0) # points_count((x,y)) is the number of occurences of (x,y), i.e. how often it was added\\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.points_x[point[0]].add(point)\\n        self.points_y[point[1]].add(point)\\n        self.points_count[point] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0\\n        \\n        # Base implementation: This is intuitive, but not optimal, since we check for the square condition in the loop\\n        #for p_x in self.points_x[point[0]]: # all points (x0, y0) with the same x-coordinate as point\\n        #    for p_y in self.points_y[point[1]]: # all points (x1, y1) with the same y-coordinate as point\\n        #        target_point = (p_y[0], p_x[1]) # construct the third point (x1, y0)\\n        #        is_positive_square = abs(p_x[0] - p_y[0]) == abs(p_x[1] - p_y[1]) and abs(p_x[1] - p_y[1]) > 0 # square check, in a variable for readability\\n        #        if is_positive_square and target_point in self.points_count:\\n        #            ans += self.points_count[p_x] * self.points_count[p_y] * self.points_count[target_point]\\n        \\n        # Efficient implementation: Here we use the square condition to create 2 candidate points that would could form a square\\n        for p_x in self.points_x[point[0]]: # all points (x0, y0) with the same x-coordinate as point\\n            side_length = abs(point[1] - p_x[1]) # side length of the square; remember a square\\'s height equals its width or you could say dx == dy with dx, dy being the deltas\\n            for p_y in [(x, point[1]) for x in [point[0] - side_length, point[0] + side_length] if (x, point[1]) in self.points_count]:\\n                target_point = (p_y[0], p_x[1]) # construct the third point (x1, y0)\\n                is_positive_square = abs(p_x[0] - p_y[0]) == abs(p_x[1] - p_y[1]) and abs(p_x[1] - p_y[1]) > 0 # square check, in a variable for readability\\n                if is_positive_square and target_point in self.points_count:\\n                    ans += self.points_count[p_x] * self.points_count[p_y] * self.points_count[target_point]\\n                    \\n        return ans\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points_x = defaultdict(set) # points_x[x] contains all points (px, py) with px = x\\n        self.points_y = defaultdict(set) # points_y[y] contains all points (px, py) with py = y\\n        self.points_count = defaultdict(lambda: 0) # points_count((x,y)) is the number of occurences of (x,y), i.e. how often it was added\\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.points_x[point[0]].add(point)\\n        self.points_y[point[1]].add(point)\\n        self.points_count[point] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        ans = 0\\n        \\n        # Base implementation: This is intuitive, but not optimal, since we check for the square condition in the loop\\n        #for p_x in self.points_x[point[0]]: # all points (x0, y0) with the same x-coordinate as point\\n        #    for p_y in self.points_y[point[1]]: # all points (x1, y1) with the same y-coordinate as point\\n        #        target_point = (p_y[0], p_x[1]) # construct the third point (x1, y0)\\n        #        is_positive_square = abs(p_x[0] - p_y[0]) == abs(p_x[1] - p_y[1]) and abs(p_x[1] - p_y[1]) > 0 # square check, in a variable for readability\\n        #        if is_positive_square and target_point in self.points_count:\\n        #            ans += self.points_count[p_x] * self.points_count[p_y] * self.points_count[target_point]\\n        \\n        # Efficient implementation: Here we use the square condition to create 2 candidate points that would could form a square\\n        for p_x in self.points_x[point[0]]: # all points (x0, y0) with the same x-coordinate as point\\n            side_length = abs(point[1] - p_x[1]) # side length of the square; remember a square\\'s height equals its width or you could say dx == dy with dx, dy being the deltas\\n            for p_y in [(x, point[1]) for x in [point[0] - side_length, point[0] + side_length] if (x, point[1]) in self.points_count]:\\n                target_point = (p_y[0], p_x[1]) # construct the third point (x1, y0)\\n                is_positive_square = abs(p_x[0] - p_y[0]) == abs(p_x[1] - p_y[1]) and abs(p_x[1] - p_y[1]) > 0 # square check, in a variable for readability\\n                if is_positive_square and target_point in self.points_count:\\n                    ans += self.points_count[p_x] * self.points_count[p_y] * self.points_count[target_point]\\n                    \\n        return ans\\n                    \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1988727,
                "title": "simple-implementation",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    \\n    /*\\n        (x0, y1)      (x1, y1)\\n    \\n    \\n    \\n        (x0, y0)      (x1, y0)\\n    \\n    */\\n    \\n    \\n    short int point_count = 0, points[1001][1001] = {};\\n    vector <int> \\n    \\n    DetectSquares() {\\n        point_count = 0;\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    void debug(int x, int y) {\\n        if(points[x][y] < 0) {\\n            cout << x << \\' \\' << y << \\' \\' << points[x][y] << \\'\\\\n\\';\\n        }\\n    }\\n    \\n    int count(vector<int> point) {\\n        int square_count = 0;\\n        int x = point[0], y = point[1];\\n        for (int point_x = 0; point_x <= 1000; point_x++) {\\n            if (x != point_x && points[point_x][y]) {\\n                int side_length = abs(x - point_x);\\n                if (y + side_length <= 1000) {\\n                    square_count += (int)points[point_x][y] * points[x][y + side_length] * points[point_x][y + side_length];   \\n                }\\n                \\n                if (y - side_length >= 0) {\\n                    square_count += (int)points[point_x][y] * points[x][y - side_length] * points[point_x][y - side_length];\\n                }\\n            }\\n        }\\n        \\n        return square_count;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    \\n    /*\\n        (x0, y1)      (x1, y1)\\n    \\n    \\n    \\n        (x0, y0)      (x1, y0)\\n    \\n    */\\n    \\n    \\n    short int point_count = 0, points[1001][1001] = {};\\n    vector <int> \\n    \\n    DetectSquares() {\\n        point_count = 0;\\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    void debug(int x, int y) {\\n        if(points[x][y] < 0) {\\n            cout << x << \\' \\' << y << \\' \\' << points[x][y] << \\'\\\\n\\';\\n        }\\n    }\\n    \\n    int count(vector<int> point) {\\n        int square_count = 0;\\n        int x = point[0], y = point[1];\\n        for (int point_x = 0; point_x <= 1000; point_x++) {\\n            if (x != point_x && points[point_x][y]) {\\n                int side_length = abs(x - point_x);\\n                if (y + side_length <= 1000) {\\n                    square_count += (int)points[point_x][y] * points[x][y + side_length] * points[point_x][y + side_length];   \\n                }\\n                \\n                if (y - side_length >= 0) {\\n                    square_count += (int)points[point_x][y] * points[x][y - side_length] * points[point_x][y - side_length];\\n                }\\n            }\\n        }\\n        \\n        return square_count;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1967517,
                "title": "python-faster-than-99-solution",
                "content": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.xs = defaultdict(lambda: defaultdict(int))\\n        self.ys = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.xs[point[0]][point[1]] += 1\\n        self.ys[point[1]][point[0]] += 1\\n        \\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        ys = self.xs[x]\\n        xs = self.ys[y]\\n        \\n        cnt = 0\\n        \\n        for x2 in xs:\\n            dx = x - x2\\n            if dx == 0:\\n                continue\\n            y2 = y - dx\\n            cnt += xs[x2] * ys[y2] * self.xs[x2][y2]\\n            y2 = y + dx\\n            cnt += xs[x2] * ys[y2] * self.xs[x2][y2]\\n        \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.xs = defaultdict(lambda: defaultdict(int))\\n        self.ys = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.xs[point[0]][point[1]] += 1\\n        self.ys[point[1]][point[0]] += 1\\n        \\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        ys = self.xs[x]\\n        xs = self.ys[y]\\n        \\n        cnt = 0\\n        \\n        for x2 in xs:\\n            dx = x - x2\\n            if dx == 0:\\n                continue\\n            y2 = y - dx\\n            cnt += xs[x2] * ys[y2] * self.xs[x2][y2]\\n            y2 = y + dx\\n            cnt += xs[x2] * ys[y2] * self.xs[x2][y2]\\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1900366,
                "title": "c-solution-using-pair-as-key-in-map-99-faster",
                "content": "```\\n\\tstruct pair_hash\\n\\t\\t{\\n        size_t operator() (const pair<int, int>& pair) const {\\n            return hash<int>()(pair.first) ^ hash<int>()(pair.second);\\n        }\\n    };\\n    \\n    unordered_map< pair<int,int>, int, pair_hash> pointMap;\\n    \\n    DetectSquares() {}\\n    \\n    void add(vector<int> point) {\\n        pointMap[make_pair(point[0],point[1])]++;\\n    }\\n    \\n//            b           c\\n//            *-----------*\\n//            |           |\\n//            |           |\\n//            |           |\\n//            *-----------*  \\n//            a           d\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        for(auto itr=pointMap.begin(); itr!=pointMap.end(); itr++) {\\n            int x1 = point[0]; // a\\n            int y1 = point[1]; // a\\n            int x2 = (*itr).first.first; // c\\n            int y2 = (*itr).first.second; // c\\n            \\n            if(x1 != x2 && y1 != y2 // not same points\\n                && abs(x2-x1) == abs(y2-y1) // square\\n                && pointMap.find(make_pair(x1, y2)) != pointMap.end()\\n                && pointMap.find(make_pair(x2, y1)) != pointMap.end()) {\\n                \\n                    auto pB = pointMap.find(make_pair(x1, y2)); // b\\n                    auto pD = pointMap.find(make_pair(x2, y1)); // d\\n                    count += (*itr).second * (*pB).second * (*pD).second;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tstruct pair_hash\\n\\t\\t{\\n        size_t operator() (const pair<int, int>& pair) const {\\n            return hash<int>()(pair.first) ^ hash<int>()(pair.second);\\n        }\\n    };\\n    \\n    unordered_map< pair<int,int>, int, pair_hash> pointMap;\\n    \\n    DetectSquares() {}\\n    \\n    void add(vector<int> point) {\\n        pointMap[make_pair(point[0],point[1])]++;\\n    }\\n    \\n//            b           c\\n//            *-----------*\\n//            |           |\\n//            |           |\\n//            |           |\\n//            *-----------*  \\n//            a           d\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        for(auto itr=pointMap.begin(); itr!=pointMap.end(); itr++) {\\n            int x1 = point[0]; // a\\n            int y1 = point[1]; // a\\n            int x2 = (*itr).first.first; // c\\n            int y2 = (*itr).first.second; // c\\n            \\n            if(x1 != x2 && y1 != y2 // not same points\\n                && abs(x2-x1) == abs(y2-y1) // square\\n                && pointMap.find(make_pair(x1, y2)) != pointMap.end()\\n                && pointMap.find(make_pair(x2, y1)) != pointMap.end()) {\\n                \\n                    auto pB = pointMap.find(make_pair(x1, y2)); // b\\n                    auto pD = pointMap.find(make_pair(x2, y1)); // d\\n                    count += (*itr).second * (*pB).second * (*pD).second;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875602,
                "title": "simple-c-solution-with-explanation-faster-than-75-28-lesser-space-than-51-09",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> PointsInThisCol; //col, row, freq\\n    \\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        PointsInThisCol[y][x]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0], y1 = point[1];\\n        \\n        //get all points on with y=y1 having a different x to get one side of the square\\n        unordered_map <int, int> otherPoints = PointsInThisCol[y1];\\n        \\n        int numSquares = 0;\\n        \\n        unordered_map <int, int>::iterator it;\\n        for(it = otherPoints.begin(); it != otherPoints.end(); ++it)\\n        {\\n            int x2 = it->first, freq = it->second;\\n            \\n            //the point shouldn\\'t be itself\\n            if(x2 == x1) continue;\\n            \\n            //find length of side, this should be maintained on all sides for square\\n            int lenOfSide = abs(x2 - x1);\\n            \\n            //find if other points exist for the square\\n            //this would be at a different y\\n            //this new y could be above or below current y but lenOfSide should be same \\n            //i.e. y2 = y1 + lenOfSide or y2 = y1 - lenOfSide\\n            \\n            if(PointsInThisCol[y1 + lenOfSide][x1] && PointsInThisCol[y1 + lenOfSide][x2]) \\n            {\\n                numSquares += (freq * PointsInThisCol[y1 + lenOfSide][x1] * PointsInThisCol[y1 + lenOfSide][x2]);    \\n            }\\n            \\n            if(PointsInThisCol[y1 - lenOfSide][x1] && PointsInThisCol[y1 - lenOfSide][x2]) \\n            {\\n                numSquares += (freq * PointsInThisCol[y1 - lenOfSide][x1] * PointsInThisCol[y1 - lenOfSide][x2]);     \\n            }\\n            \\n        }\\n        \\n        return numSquares;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> PointsInThisCol; //col, row, freq\\n    \\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        PointsInThisCol[y][x]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0], y1 = point[1];\\n        \\n        //get all points on with y=y1 having a different x to get one side of the square\\n        unordered_map <int, int> otherPoints = PointsInThisCol[y1];\\n        \\n        int numSquares = 0;\\n        \\n        unordered_map <int, int>::iterator it;\\n        for(it = otherPoints.begin(); it != otherPoints.end(); ++it)\\n        {\\n            int x2 = it->first, freq = it->second;\\n            \\n            //the point shouldn\\'t be itself\\n            if(x2 == x1) continue;\\n            \\n            //find length of side, this should be maintained on all sides for square\\n            int lenOfSide = abs(x2 - x1);\\n            \\n            //find if other points exist for the square\\n            //this would be at a different y\\n            //this new y could be above or below current y but lenOfSide should be same \\n            //i.e. y2 = y1 + lenOfSide or y2 = y1 - lenOfSide\\n            \\n            if(PointsInThisCol[y1 + lenOfSide][x1] && PointsInThisCol[y1 + lenOfSide][x2]) \\n            {\\n                numSquares += (freq * PointsInThisCol[y1 + lenOfSide][x1] * PointsInThisCol[y1 + lenOfSide][x2]);    \\n            }\\n            \\n            if(PointsInThisCol[y1 - lenOfSide][x1] && PointsInThisCol[y1 - lenOfSide][x2]) \\n            {\\n                numSquares += (freq * PointsInThisCol[y1 - lenOfSide][x1] * PointsInThisCol[y1 - lenOfSide][x2]);     \\n            }\\n            \\n        }\\n        \\n        return numSquares;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863833,
                "title": "simple-c-hashtable-solution",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> row, col;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        row[x][y]++;\\n        col[y][x]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        unordered_map<int, int> mp = col[y];\\n        int count = 0;\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            int c = it->second, x1 = it->first;\\n            if (x == x1)    continue;\\n            int dis = abs(x - x1);\\n            int y1 = y + dis, y2 = y - dis;\\n            if (row[x1][y1] && row[x][y1])  count += (row[x1][y1] * row[x][y1] * c);\\n            if (row[x1][y2] && row[x][y2])  count += (row[x1][y2] * row[x][y2] * c);\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> row, col;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        row[x][y]++;\\n        col[y][x]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        unordered_map<int, int> mp = col[y];\\n        int count = 0;\\n        for (auto it = mp.begin(); it != mp.end(); it++) {\\n            int c = it->second, x1 = it->first;\\n            if (x == x1)    continue;\\n            int dis = abs(x - x1);\\n            int y1 = y + dis, y2 = y - dis;\\n            if (row[x1][y1] && row[x][y1])  count += (row[x1][y1] * row[x][y1] * c);\\n            if (row[x1][y2] && row[x][y2])  count += (row[x1][y2] * row[x][y2] * c);\\n        }\\n        \\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1789472,
                "title": "c-o-1001-no-map-solution",
                "content": "The idea is to use an 2D  (1001x1001) array to represent the appearance and frequrency of the input points. \\nWhen the count function called, try every x-axis, say if you can make a square between this x-axis and the input x. This can be easily done by caculating the length of the square, and check if you can find all the other three points.\\n\\nLet\\'s say the input is [x,y]: \\nSpecifally, we loop each x-axis (the array), suppose the index is  i: \\nthen the length of edge will be:   d = |x-i|  \\nNow, the problem is how to find othere 3 points.  There are two scenarios to form a squares:\\n**Scenario 1:**    the square is above y, which means:\\n   j=y+d    (suppose j the the y-axis we are looking for)\\n  in this scenario, the other 3 points will be (i, y+d)  (i, y) (x, y+d)\\n**Scenario 2:** the square is under y, which means \\n   j=y-d \\n  in this scenario, the other 3 points will be (i, y-d)  (i, y) (x, y-d)  \\n  \\n  The count can be easily counted by mulitiplying the frequency of these three points. If the frequency of this point is 0, then 0 be counted. If it is more than 1, then counted multi times. \\n  \\n  \\n```\\nclass DetectSquares {\\nprivate:\\n    int map[1001][1001];  // Be careful: 0 <= x, y <= 1000  intotal there are 1001 elements\\npublic:\\n    DetectSquares() {\\n        memset(map, 0, sizeof(int)*1001*1001);\\n    }\\n    \\n    void add(vector<int> point) {\\n        map[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int ret = 0;\\n        \\n        for (int i=0; i<1001; i++)\\n        {\\n            int d = abs(x-i);\\n            if (d==0) continue;\\n\\t\\t\\t\\n            int j = y-d;\\n            if (j>=0)\\n                ret += map[i][j]*map[i][y]*map[x][j];  // count by mulitiplying the three\\n            \\n            j = y+d;\\n            if (j<=1000)\\n                ret += map[i][j]*map[i][y]*map[x][j];  \\n        }        \\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\nprivate:\\n    int map[1001][1001];  // Be careful: 0 <= x, y <= 1000  intotal there are 1001 elements\\npublic:\\n    DetectSquares() {\\n        memset(map, 0, sizeof(int)*1001*1001);\\n    }\\n    \\n    void add(vector<int> point) {\\n        map[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int ret = 0;\\n        \\n        for (int i=0; i<1001; i++)\\n        {\\n            int d = abs(x-i);\\n            if (d==0) continue;\\n\\t\\t\\t\\n            int j = y-d;\\n            if (j>=0)\\n                ret += map[i][j]*map[i][y]*map[x][j];  // count by mulitiplying the three\\n            \\n            j = y+d;\\n            if (j<=1000)\\n                ret += map[i][j]*map[i][y]*map[x][j];  \\n        }        \\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767644,
                "title": "concise-java-solution-over-90-o-1-add-o-n-count",
                "content": "The idea is simple: given a point (x1, y1), we have to find the corresponding (x1, y2), (x2, y1), (x2, y2) to form a square. Then we just calculate the number of combinations of (x1, y2), (x2, y1), (x2, y2) to get the answer.\\n\\nComplexity \\nadd O(1)\\ncount O(N): N = Number of points that already exist\\n\\n\\n\\tMap<Integer, Set<Integer>> xMap;\\n    Map<Integer, Set<Integer>> yMap;\\n    int[][] cnt;\\n\\n    public DetectSquares() {\\n        xMap = new HashMap<>();\\n        yMap = new HashMap<>();\\n        cnt = new int[1001][1001];\\n    }\\n\\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        cnt[x][y]++;\\n        Set<Integer> xSet = xMap.computeIfAbsent(x, (k) -> new LinkedHashSet<>());\\n        xSet.add(y);\\n        Set<Integer> ySet = yMap.computeIfAbsent(y, (k) -> new LinkedHashSet<>());\\n        ySet.add(x);\\n    }\\n\\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int ans = 0;\\n        for (int y2 : xMap.getOrDefault(x1, Collections.emptySet())) {\\n            for (int x2 : yMap.getOrDefault(y2, Collections.emptySet())) {\\n                if (x1 != x2 && y1 != y2 && Math.abs(x1 - x2) == Math.abs(y1 - y2)) {\\n                    ans += cnt[x2][y2] * cnt[x1][y2] * cnt[x2][y1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is simple: given a point (x1, y1), we have to find the corresponding (x1, y2), (x2, y1), (x2, y2) to form a square. Then we just calculate the number of combinations of (x1, y2), (x2, y1), (x2, y2) to get the answer.\\n\\nComplexity \\nadd O(1)\\ncount O(N): N = Number of points that already exist\\n\\n\\n\\tMap<Integer, Set<Integer>> xMap;\\n    Map<Integer, Set<Integer>> yMap;\\n    int[][] cnt;\\n\\n    public DetectSquares() {\\n        xMap = new HashMap<>();\\n        yMap = new HashMap<>();\\n        cnt = new int[1001][1001];\\n    }\\n\\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        cnt[x][y]++;\\n        Set<Integer> xSet = xMap.computeIfAbsent(x, (k) -> new LinkedHashSet<>());\\n        xSet.add(y);\\n        Set<Integer> ySet = yMap.computeIfAbsent(y, (k) -> new LinkedHashSet<>());\\n        ySet.add(x);\\n    }\\n\\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int ans = 0;\\n        for (int y2 : xMap.getOrDefault(x1, Collections.emptySet())) {\\n            for (int x2 : yMap.getOrDefault(y2, Collections.emptySet())) {\\n                if (x1 != x2 && y1 != y2 && Math.abs(x1 - x2) == Math.abs(y1 - y2)) {\\n                    ans += cnt[x2][y2] * cnt[x1][y2] * cnt[x2][y1];\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1747515,
                "title": "simple-java-solution",
                "content": "```\\nclass DetectSquares {\\n    \\n    Map<Integer,Set<Integer>> map;\\n    Map<String,Integer> count;\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        count = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point[0]);\\n        sb.append(\"-\"); sb.append(point[1]);\\n        String str = sb.toString();\\n        \\n        count.put(str, count.getOrDefault(str,0) + 1);\\n        \\n        map.putIfAbsent(point[0],new HashSet<>());\\n        map.get(point[0]).add(point[1]);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0], y1 = point[1];\\n        \\n        if(!map.containsKey(x1)) return 0;\\n        \\n        Set<Integer> set = map.get(x1);\\n        int c = 0;\\n        \\n        for(int x2 : map.keySet()) {\\n            if(x1 == x2) continue;   \\n            \\n            Set<Integer> set2 = map.get(x2);\\n          \\n            if(!set2.contains(y1)) continue;\\n            \\n            for(int y2 : set2) {\\n                if(y1 == y2) continue;\\n                \\n                if(set.contains(y2)){\\n        \\n                    if(Math.abs(y2-y1) == Math.abs(x2-x1)){\\n                        \\n                        StringBuilder sb = new StringBuilder();                \\n                    \\n                        sb.append(x2);sb.append(\"-\"); sb.append(y2);\\n                        int res = count.get(sb.toString());\\n                    \\n                        sb = new StringBuilder();\\n                        sb.append(x2);sb.append(\"-\"); sb.append(y1);\\n                        res *= count.get(sb.toString());\\n\\n                        sb = new StringBuilder();\\n                        sb.append(x1);sb.append(\"-\"); sb.append(y2);\\n                        res *= count.get(sb.toString());\\n                    \\n                    c+=res;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return c;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    \\n    Map<Integer,Set<Integer>> map;\\n    Map<String,Integer> count;\\n    \\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        count = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(point[0]);\\n        sb.append(\"-\"); sb.append(point[1]);\\n        String str = sb.toString();\\n        \\n        count.put(str, count.getOrDefault(str,0) + 1);\\n        \\n        map.putIfAbsent(point[0],new HashSet<>());\\n        map.get(point[0]).add(point[1]);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0], y1 = point[1];\\n        \\n        if(!map.containsKey(x1)) return 0;\\n        \\n        Set<Integer> set = map.get(x1);\\n        int c = 0;\\n        \\n        for(int x2 : map.keySet()) {\\n            if(x1 == x2) continue;   \\n            \\n            Set<Integer> set2 = map.get(x2);\\n          \\n            if(!set2.contains(y1)) continue;\\n            \\n            for(int y2 : set2) {\\n                if(y1 == y2) continue;\\n                \\n                if(set.contains(y2)){\\n        \\n                    if(Math.abs(y2-y1) == Math.abs(x2-x1)){\\n                        \\n                        StringBuilder sb = new StringBuilder();                \\n                    \\n                        sb.append(x2);sb.append(\"-\"); sb.append(y2);\\n                        int res = count.get(sb.toString());\\n                    \\n                        sb = new StringBuilder();\\n                        sb.append(x2);sb.append(\"-\"); sb.append(y1);\\n                        res *= count.get(sb.toString());\\n\\n                        sb = new StringBuilder();\\n                        sb.append(x1);sb.append(\"-\"); sb.append(y2);\\n                        res *= count.get(sb.toString());\\n                    \\n                    c+=res;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        return c;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745272,
                "title": "ruby-beats-100-100",
                "content": "```\\nclass DetectSquares\\n    def initialize()\\n       @pts = Hash.new(0)\\n       @sums = Hash.new { |h, k| h[k] = [] }\\n       @difs = Hash.new { |h, k| h[k] = [] }\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Void\\n=end\\n    def add(point)\\n       @pts[point] += 1\\n       x, y = point\\n       @sums[x + y] << point\\n       @difs[x - y] << point\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Integer\\n=end\\n    def count(point)\\n       x, y = point\\n       (@sums[x + y] + @difs[x - y]).sum { |xx, yy| x == xx ? 0 : @pts[[x, yy]] * @pts[[xx, y]] }\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares\\n    def initialize()\\n       @pts = Hash.new(0)\\n       @sums = Hash.new { |h, k| h[k] = [] }\\n       @difs = Hash.new { |h, k| h[k] = [] }\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Void\\n=end\\n    def add(point)\\n       @pts[point] += 1\\n       x, y = point\\n       @sums[x + y] << point\\n       @difs[x - y] << point\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Integer\\n=end\\n    def count(point)\\n       x, y = point\\n       (@sums[x + y] + @difs[x - y]).sum { |xx, yy| x == xx ? 0 : @pts[[x, yy]] * @pts[[xx, y]] }\\n    end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729195,
                "title": "java-two-solutions-w-test",
                "content": "array and hashmap solution. \\n\\nfull Java class with test case.\\n\\n```\\npublic class DetectSquaresProblem {\\n\\n    public DetectSquaresProblem() {\\n        test();\\n    }\\n\\n    void test() {\\n\\n        {\\n            String[] commands=new String[]{\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"};\\n            Object command_args[]=new Object[][]{{}, {3, 10}, {11, 2}, {3, 2}, {11, 10}, {14, 8}, {11, 2}, {11, 10}};\\n            Object expected[] = new Object[] {null, null, null, null, 1, 0, null, 2};\\n            executeTest(commands, command_args, expected );\\n        }\\n\\n        {\\n            log(\"\\\\n\\\\n\");\\n            String[] commands = new String[]{\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\"};\\n            Object[] command_args = new Object[][]{{}, {5, 10}, {10, 5}, {10, 10}, {5, 5}, {3, 0}, {8, 0}, {8, 5}, {3, 5}, {9, 0}, {9, 8}, {1, 8}, {1, 0}, {0, 0}, {8, 0}, {8, 8}, {0, 8}, {1, 9}, {2, 9}, {2, 10}, {1, 10}, {7, 8}, {2, 3}, {2, 8}, {7, 3}, {9, 10}, {9, 5}, {4, 5}, {4, 10}, {0, 9}, {4, 5}, {4, 9}, {0, 5}, {1, 10}, {10, 1}, {10, 10}, {1, 1}, {10, 0}, {2, 0}, {2, 8}, {10, 8}, {7, 6}, {4, 6}, {4, 9}, {7, 9}, {10, 9}, {10, 0}, {1, 0}, {1, 9}, {0, 9}, {8, 1}, {0, 1}, {8, 9}, {3, 9}, {10, 9}, {3, 2}, {10, 2}, {3, 8}, {9, 2}, {3, 2}, {9, 8}, {0, 9}, {7, 9}, {0, 2}, {7, 2}, {10, 1}, {1, 10}, {10, 10}, {1, 1}, {6, 10}, {2, 6}, {6, 6}, {2, 10}, {6, 0}, {6, 2}, {8, 2}, {8, 0}, {6, 5}, {7, 4}, {6, 4}, {7, 5}, {2, 10}, {8, 4}, {2, 4}, {8, 10}, {2, 6}, {2, 5}, {1, 5}, {1, 6}, {10, 9}, {10, 0}, {1, 9}, {1, 0}, {0, 9}, {5, 9}, {0, 4}, {5, 4}, {3, 6}, {9, 0}, {3, 0}, {9, 6}, {0, 2}, {1, 1}, {0, 1}, {1, 2}, {1, 7}, {8, 0}, {8, 7}, {1, 0}, {2, 7}, {4, 5}, {2, 5}, {4, 7}, {6, 7}, {3, 7}, {6, 4}, {3, 4}, {10, 2}, {2, 10}, {2, 2}, {10, 10}, {10, 1}, {1, 10}, {1, 1}, {10, 10}, {2, 10}, {2, 9}, {3, 9}, {3, 10}, {10, 1}, {1, 10}, {1, 1}, {10, 10}, {10, 4}, {10, 3}, {9, 4}, {9, 3}, {6, 6}, {6, 10}, {10, 6}, {10, 10}, {9, 7}, {4, 7}, {9, 2}, {4, 2}, {2, 3}, {2, 1}, {0, 3}, {0, 1}, {2, 8}, {10, 8}, {2, 0}, {10, 0}, {8, 4}, {2, 10}, {8, 10}, {2, 4}, {0, 0}, {9, 9}, {0, 9}, {9, 0}, {5, 7}, {5, 8}, {4, 7}, {4, 8}, {10, 10}, {10, 1}, {1, 1}, {1, 10}, {6, 8}, {7, 8}, {6, 9}, {7, 9}, {4, 6}, {1, 6}, {4, 3}, {1, 3}, {10, 1}, {1, 10}, {10, 10}, {1, 1}, {7, 7}, {7, 10}, {4, 7}, {4, 10}, {0, 0}, {8, 0}, {0, 8}, {8, 8}, {3, 5}, {2, 4}, {3, 4}, {2, 5}, {0, 6}, {0, 2}, {4, 2}, {4, 6}, {5, 2}, {9, 6}, {9, 2}, {5, 6}, {1, 1}, {1, 10}, {10, 10}, {10, 1}, {7, 5}, {2, 0}, {2, 5}, {7, 0}, {1, 9}, {1, 2}, {8, 2}, {8, 9}, {3, 8}, {3, 3}, {8, 3}, {8, 8}, {3, 10}, {9, 10}, {3, 4}, {9, 4}, {0, 2}, {0, 10}, {8, 10}, {8, 2}, {9, 4}, {8, 4}, {8, 5}, {9, 5}, {9, 8}, {4, 3}, {4, 8}, {9, 3}, {4, 9}, {0, 5}, {0, 9}, {4, 5}, {1, 3}, {3, 5}, {1, 5}, {3, 3}, {0, 0}, {0, 8}, {8, 0}, {8, 8}, {2, 8}, {10, 0}, {10, 8}, {2, 0}, {8, 1}, {0, 9}, {8, 9}, {0, 1}, {4, 9}, {4, 6}, {1, 9}, {1, 6}, {0, 9}, {0, 8}, {1, 9}, {1, 8}, {5, 1}, {5, 6}, {10, 1}, {10, 6}, {9, 2}, {2, 2}, {2, 9}, {9, 9}, {5, 5}, {8, 5}, {5, 8}, {8, 8}, {8, 0}, {1, 0}, {8, 7}, {1, 7}, {8, 2}, {5, 5}, {5, 2}, {8, 5}, {6, 6}, {6, 8}, {8, 6}, {8, 8}, {2, 10}, {10, 2}, {2, 2}, {10, 10}, {1, 9}, {8, 2}, {1, 2}, {8, 9}, {7, 4}, {7, 2}, {9, 4}, {9, 2}, {1, 9}, {1, 0}, {10, 0}, {10, 9}, {2, 10}, {2, 3}, {9, 10}, {9, 3}, {10, 0}, {1, 0}, {1, 9}, {10, 9}, {8, 10}, {1, 10}, {1, 3}, {8, 3}, {0, 9}, {9, 9}, {0, 0}, {9, 0}, {7, 9}, {8, 9}, {7, 8}, {8, 8}, {3, 1}, {9, 7}, {9, 1}, {3, 7}, {5, 9}, {6, 9}, {5, 8}, {6, 8}, {0, 1}, {0, 10}, {9, 10}, {9, 1}, {8, 0}, {8, 2}, {10, 2}, {10, 0}, {8, 0}, {0, 8}, {8, 8}, {0, 0}, {6, 7}, {5, 8}, {5, 7}, {6, 8}, {0, 9}, {0, 2}, {7, 9}, {7, 2}, {5, 0}, {5, 5}, {10, 0}, {10, 5}, {1, 10}, {10, 10}, {10, 1}, {1, 1}, {9, 2}, {9, 10}, {1, 2}, {1, 10}, {1, 10}, {10, 1}, {10, 10}, {1, 1}, {9, 9}, {0, 9}, {0, 0}, {9, 0}, {9, 6}, {9, 3}, {6, 3}, {6, 6}, {10, 4}, {6, 0}, {10, 0}, {6, 4}, {6, 8}, {0, 2}, {0, 8}, {6, 2}, {7, 9}, {0, 9}, {7, 2}, {0, 2}, {9, 1}, {9, 10}, {0, 10}, {0, 1}, {10, 0}, {10, 9}, {1, 9}, {1, 0}, {1, 6}, {1, 9}, {4, 9}, {4, 6}, {0, 8}, {1, 9}, {0, 9}, {1, 8}, {1, 1}, {9, 1}, {1, 9}, {9, 9}, {2, 5}, {2, 9}, {6, 5}, {6, 9}, {7, 3}, {2, 3}, {2, 8}, {7, 8}, {9, 4}, {4, 4}, {9, 9}, {4, 9}, {4, 4}, {2, 4}, {4, 2}, {2, 2}, {0, 3}, {0, 2}, {1, 3}, {1, 2}, {10, 9}, {10, 2}, {3, 2}, {3, 9}, {5, 6}, {10, 6}, {10, 1}, {5, 1}, {9, 0}, {0, 9}, {9, 9}, {0, 0}, {5, 6}, {9, 2}, {9, 6}, {5, 2}, {3, 3}, {10, 3}, {10, 10}, {3, 10}, {2, 4}, {2, 10}, {8, 4}, {8, 10}, {4, 9}, {1, 9}, {4, 6}, {1, 6}, {1, 8}, {9, 0}, {1, 0}, {9, 8}, {10, 3}, {5, 8}, {5, 3}, {10, 8}, {8, 2}, {0, 10}, {8, 10}, {0, 2}, {9, 0}, {2, 7}, {9, 7}, {2, 0}, {0, 4}, {5, 9}, {0, 9}, {5, 4}, {5, 3}, {10, 3}, {5, 8}, {10, 8}, {6, 4}, {7, 4}, {6, 5}, {7, 5}, {9, 1}, {0, 1}, {9, 10}, {0, 10}, {5, 10}, {5, 7}, {8, 7}, {8, 10}, {8, 0}, {8, 7}, {1, 7}, {1, 0}, {1, 1}, {9, 9}, {1, 9}, {9, 1}, {3, 1}, {3, 5}, {7, 5}, {7, 1}, {5, 8}, {5, 3}, {10, 8}, {10, 3}, {0, 9}, {2, 7}, {2, 9}, {0, 7}, {9, 3}, {9, 7}, {5, 3}, {5, 7}, {0, 0}, {9, 0}, {9, 9}, {0, 9}, {6, 4}, {4, 2}, {4, 4}, {6, 2}, {1, 9}, {1, 5}, {5, 5}, {5, 9}, {7, 7}, {0, 7}, {0, 0}, {7, 0}, {1, 3}, {1, 9}, {7, 3}, {7, 9}, {0, 9}, {9, 9}, {9, 0}, {0, 0}, {1, 8}, {3, 6}, {3, 8}, {1, 6}};           \\n            Object[] expected = new Object[]{null, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 2, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 2, null, null, null, 2, null, null, null, 2, null, null, null, 2, null, null, null, 5, null, null, null, 6, null, null, null, 2, null, null, null, 3, null, null, null, 3, null, null, null, 14, null, null, null, 3, null, null, null, 1, null, null, null, 2, null, null, null, 2, null, null, null, 4, null, null, null, 20, null, null, null, 4, null, null, null, 5, null, null, null, 10, null, null, null, 26, null, null, null, 8, null, null, null, 3, null, null, null, 7, null, null, null, 21, null, null, null, 20, null, null, null, 52, null, null, null, 6, null, null, null, 56, null, null, null, 2, null, null, null, 5, null, null, null, 17, null, null, null, 18, null, null, null, 13, null, null, null, 19, null, null, null, 102, null, null, null, 9, null, null, null, 2, null, null, null, 157, null, null, null, 23, null, null, null, 29, null, null, null, 23, null, null, null, 15, null, null, null, 24, null, null, null, 186, null, null, null, 12, null, null, null, 32, null, null, null, 36, null, null, null, 10, null, null, null, 35, null, null, null, 20, null, null, null, 43, null, null, null, 48, null, null, null, 35, null, null, null, 73, null, null, null, 59, null, null, null, 56, null, null, null, 72, null, null, null, 198, null, null, null, 37, null, null, null, 145, null, null, null, 130, null, null, null, 45, null, null, null, 68, null, null, null, 172, null, null, null, 281, null, null, null, 147, null, null, null, 53, null, null, null, 160, null, null, null, 105, null, null, null, 253, null, null, null, 82, null, null, null, 103, null, null, null, 248, null, null, null, 75, null, null, null, 86, null, null, null, 312, null, null, null, 301, null, null, null, 273, null, null, null, 119, null, null, null, 191, null, null, null, 61, null, null, null, 584, null, null, null, 696, null, null, null, 802, null, null, null, 293, null, null, null, 104, null, null, null, 114, null, null, null, 242, null, null, null, 259, null, null, null, 300, null, null, null, 465, null, null, null, 180, null, null, null, 1082, null, null, null, 697, null, null, null, 187, null, null, null, 113, null, null, null, 201, null, null, null, 520, null, null, null, 652, null, null, null, 197, null, null, null, 91, null, null, null, 670, null, null, null, 159, null, null, null, 189, null, null, null, 386, null, null, null, 403, null, null, null, 204, null, null, null, 301, null, null, null, 378, null, null, null, 314, null, null, null, 292, null, null, null, 352, null, null, null, 174, null, null, null, 2778, null, null, null, 473, null, null, null, 869, null, null, null, 1568, null, null, null, 190, null, null, null, 198, null, null, null, 342, null, null, null, 286, null, null, null, 1062, null, null, null, 475, null, null, null, 354, null, null, null, 174, null, null, null, 574, null, null, null, 1605, null, null, null, 547};\\n            executeTest(commands, command_args, expected);\\n        }\\n    }\\n\\n    class DetectSquares {\\n\\n        Map<Integer,Set<Integer>> xy=new HashMap();\\n        Map<Integer,Set<Integer>> yx=new HashMap();\\n        int points[][]=new int[1000+1][1000+1];\\n\\n        public DetectSquares() {}\\n\\n        public void add(int[] point) {\\n            points[point[0]][point[1]]++;\\n            xy.computeIfAbsent(point[0],p->new HashSet()).add(point[1]);\\n            yx.computeIfAbsent(point[1],p->new HashSet()).add(point[0]);\\n        }\\n\\n        public int count(int[] point) {\\n            int count=0;\\n            int x1=point[0], y1=point[1];\\n\\n            if( !xy.containsKey(x1)) { return 0; }\\n\\n            for (int y2:xy.get(x1) ){\\n                int x2=x1;\\n                if( y1!=y2 ) {\\n                    int y3=y1, y4=y2;\\n                    for (int x3:yx.get(y2) ) {\\n                        int x4=x3;\\n                        if( x3!=x1 && points[x3][y3]>0 && points[x4][y4]>0 && Math.abs(x3-x2)==Math.abs(y2-y1) ) {\\n                            count+=points[x2][y2]*points[x3][y3]*points[x4][y4];\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    class DetectSquares2 {\\n\\n        int points[][]=new int[1000+1][1000+1];\\n\\n        public DetectSquares2() {}\\n\\n        public void add(int[] point) {\\n            points[point[0]][point[1]]++;\\n        }\\n\\n        public int count(int[] point) {\\n            int count=0;\\n            int x1=point[0], y1=point[1];\\n            // look for (x,y) on y line, excluding (x1,y1)\\n            for (int y2 = 0; y2 <=1000 ; y2++) {\\n                int x2=x1;\\n                if( points[x2][y2]>0 && y1!=y2 ) {\\n                    int y3=y1, y4=y2;\\n                    for (int x3 = 0; x3 <=1000 ; x3++) {\\n                        int x4=x3;\\n                        if( x3!=x1 && points[x3][y3]>0 && points[x4][y4]>0 && Math.abs(x3-x2)==Math.abs(y2-y1) ) {\\n                            count+=points[x2][y2]*points[x3][y3]*points[x4][y4];\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    void executeTest(String commands[], Object command_args[], Object expected[]) {\\n        log(\"command_args: \" + command_args.length );\\n\\n        DetectSquares squares=null;\\n        for (int i = 0; i < commands.length; i++) {\\n            String command=commands[i];\\n            Object arg=command_args[i];\\n            if( command.equalsIgnoreCase(\"DetectSquares\") ){\\n                squares=new DetectSquares();\\n            }\\n            else if( command.equalsIgnoreCase(\"add\") ){\\n                Object t[]=(Object[]) arg;\\n                int xy[]=new int[]{(Integer)t[0], (Integer)t[1]};\\n                squares.add(xy);\\n                //log(i + \", add: \" + Arrays.toString(xy) );\\n            }\\n            else if( command.equalsIgnoreCase(\"count\") ){\\n\\n                Object t[]=(Object[]) arg;\\n                int xy[]=new int[]{(Integer)t[0], (Integer)t[1]};\\n                int value=squares.count(xy);\\n                int e=(Integer)expected[i];\\n                log(i + \", count: \" + Arrays.toString(xy) + \", count: \" + value );\\n                Assert.assertEquals(e,value);\\n            }\\n            else {\\n                throw new IllegalArgumentException(\"Unparsed: \" + command );\\n            }\\n        }\\n\\n    }\\n\\n    public static void main(String args[]) {\\n        new DetectSquaresProblem();\\n    }\\n    public static void log(Object obj) {\\n        System.out.println(obj);  \\n    }\\n  \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class DetectSquaresProblem {\\n\\n    public DetectSquaresProblem() {\\n        test();\\n    }\\n\\n    void test() {\\n\\n        {\\n            String[] commands=new String[]{\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"count\", \"add\", \"count\"};\\n            Object command_args[]=new Object[][]{{}, {3, 10}, {11, 2}, {3, 2}, {11, 10}, {14, 8}, {11, 2}, {11, 10}};\\n            Object expected[] = new Object[] {null, null, null, null, 1, 0, null, 2};\\n            executeTest(commands, command_args, expected );\\n        }\\n\\n        {\\n            log(\"\\\\n\\\\n\");\\n            String[] commands = new String[]{\"DetectSquares\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\", \"add\", \"add\", \"add\", \"count\"};\\n            Object[] command_args = new Object[][]{{}, {5, 10}, {10, 5}, {10, 10}, {5, 5}, {3, 0}, {8, 0}, {8, 5}, {3, 5}, {9, 0}, {9, 8}, {1, 8}, {1, 0}, {0, 0}, {8, 0}, {8, 8}, {0, 8}, {1, 9}, {2, 9}, {2, 10}, {1, 10}, {7, 8}, {2, 3}, {2, 8}, {7, 3}, {9, 10}, {9, 5}, {4, 5}, {4, 10}, {0, 9}, {4, 5}, {4, 9}, {0, 5}, {1, 10}, {10, 1}, {10, 10}, {1, 1}, {10, 0}, {2, 0}, {2, 8}, {10, 8}, {7, 6}, {4, 6}, {4, 9}, {7, 9}, {10, 9}, {10, 0}, {1, 0}, {1, 9}, {0, 9}, {8, 1}, {0, 1}, {8, 9}, {3, 9}, {10, 9}, {3, 2}, {10, 2}, {3, 8}, {9, 2}, {3, 2}, {9, 8}, {0, 9}, {7, 9}, {0, 2}, {7, 2}, {10, 1}, {1, 10}, {10, 10}, {1, 1}, {6, 10}, {2, 6}, {6, 6}, {2, 10}, {6, 0}, {6, 2}, {8, 2}, {8, 0}, {6, 5}, {7, 4}, {6, 4}, {7, 5}, {2, 10}, {8, 4}, {2, 4}, {8, 10}, {2, 6}, {2, 5}, {1, 5}, {1, 6}, {10, 9}, {10, 0}, {1, 9}, {1, 0}, {0, 9}, {5, 9}, {0, 4}, {5, 4}, {3, 6}, {9, 0}, {3, 0}, {9, 6}, {0, 2}, {1, 1}, {0, 1}, {1, 2}, {1, 7}, {8, 0}, {8, 7}, {1, 0}, {2, 7}, {4, 5}, {2, 5}, {4, 7}, {6, 7}, {3, 7}, {6, 4}, {3, 4}, {10, 2}, {2, 10}, {2, 2}, {10, 10}, {10, 1}, {1, 10}, {1, 1}, {10, 10}, {2, 10}, {2, 9}, {3, 9}, {3, 10}, {10, 1}, {1, 10}, {1, 1}, {10, 10}, {10, 4}, {10, 3}, {9, 4}, {9, 3}, {6, 6}, {6, 10}, {10, 6}, {10, 10}, {9, 7}, {4, 7}, {9, 2}, {4, 2}, {2, 3}, {2, 1}, {0, 3}, {0, 1}, {2, 8}, {10, 8}, {2, 0}, {10, 0}, {8, 4}, {2, 10}, {8, 10}, {2, 4}, {0, 0}, {9, 9}, {0, 9}, {9, 0}, {5, 7}, {5, 8}, {4, 7}, {4, 8}, {10, 10}, {10, 1}, {1, 1}, {1, 10}, {6, 8}, {7, 8}, {6, 9}, {7, 9}, {4, 6}, {1, 6}, {4, 3}, {1, 3}, {10, 1}, {1, 10}, {10, 10}, {1, 1}, {7, 7}, {7, 10}, {4, 7}, {4, 10}, {0, 0}, {8, 0}, {0, 8}, {8, 8}, {3, 5}, {2, 4}, {3, 4}, {2, 5}, {0, 6}, {0, 2}, {4, 2}, {4, 6}, {5, 2}, {9, 6}, {9, 2}, {5, 6}, {1, 1}, {1, 10}, {10, 10}, {10, 1}, {7, 5}, {2, 0}, {2, 5}, {7, 0}, {1, 9}, {1, 2}, {8, 2}, {8, 9}, {3, 8}, {3, 3}, {8, 3}, {8, 8}, {3, 10}, {9, 10}, {3, 4}, {9, 4}, {0, 2}, {0, 10}, {8, 10}, {8, 2}, {9, 4}, {8, 4}, {8, 5}, {9, 5}, {9, 8}, {4, 3}, {4, 8}, {9, 3}, {4, 9}, {0, 5}, {0, 9}, {4, 5}, {1, 3}, {3, 5}, {1, 5}, {3, 3}, {0, 0}, {0, 8}, {8, 0}, {8, 8}, {2, 8}, {10, 0}, {10, 8}, {2, 0}, {8, 1}, {0, 9}, {8, 9}, {0, 1}, {4, 9}, {4, 6}, {1, 9}, {1, 6}, {0, 9}, {0, 8}, {1, 9}, {1, 8}, {5, 1}, {5, 6}, {10, 1}, {10, 6}, {9, 2}, {2, 2}, {2, 9}, {9, 9}, {5, 5}, {8, 5}, {5, 8}, {8, 8}, {8, 0}, {1, 0}, {8, 7}, {1, 7}, {8, 2}, {5, 5}, {5, 2}, {8, 5}, {6, 6}, {6, 8}, {8, 6}, {8, 8}, {2, 10}, {10, 2}, {2, 2}, {10, 10}, {1, 9}, {8, 2}, {1, 2}, {8, 9}, {7, 4}, {7, 2}, {9, 4}, {9, 2}, {1, 9}, {1, 0}, {10, 0}, {10, 9}, {2, 10}, {2, 3}, {9, 10}, {9, 3}, {10, 0}, {1, 0}, {1, 9}, {10, 9}, {8, 10}, {1, 10}, {1, 3}, {8, 3}, {0, 9}, {9, 9}, {0, 0}, {9, 0}, {7, 9}, {8, 9}, {7, 8}, {8, 8}, {3, 1}, {9, 7}, {9, 1}, {3, 7}, {5, 9}, {6, 9}, {5, 8}, {6, 8}, {0, 1}, {0, 10}, {9, 10}, {9, 1}, {8, 0}, {8, 2}, {10, 2}, {10, 0}, {8, 0}, {0, 8}, {8, 8}, {0, 0}, {6, 7}, {5, 8}, {5, 7}, {6, 8}, {0, 9}, {0, 2}, {7, 9}, {7, 2}, {5, 0}, {5, 5}, {10, 0}, {10, 5}, {1, 10}, {10, 10}, {10, 1}, {1, 1}, {9, 2}, {9, 10}, {1, 2}, {1, 10}, {1, 10}, {10, 1}, {10, 10}, {1, 1}, {9, 9}, {0, 9}, {0, 0}, {9, 0}, {9, 6}, {9, 3}, {6, 3}, {6, 6}, {10, 4}, {6, 0}, {10, 0}, {6, 4}, {6, 8}, {0, 2}, {0, 8}, {6, 2}, {7, 9}, {0, 9}, {7, 2}, {0, 2}, {9, 1}, {9, 10}, {0, 10}, {0, 1}, {10, 0}, {10, 9}, {1, 9}, {1, 0}, {1, 6}, {1, 9}, {4, 9}, {4, 6}, {0, 8}, {1, 9}, {0, 9}, {1, 8}, {1, 1}, {9, 1}, {1, 9}, {9, 9}, {2, 5}, {2, 9}, {6, 5}, {6, 9}, {7, 3}, {2, 3}, {2, 8}, {7, 8}, {9, 4}, {4, 4}, {9, 9}, {4, 9}, {4, 4}, {2, 4}, {4, 2}, {2, 2}, {0, 3}, {0, 2}, {1, 3}, {1, 2}, {10, 9}, {10, 2}, {3, 2}, {3, 9}, {5, 6}, {10, 6}, {10, 1}, {5, 1}, {9, 0}, {0, 9}, {9, 9}, {0, 0}, {5, 6}, {9, 2}, {9, 6}, {5, 2}, {3, 3}, {10, 3}, {10, 10}, {3, 10}, {2, 4}, {2, 10}, {8, 4}, {8, 10}, {4, 9}, {1, 9}, {4, 6}, {1, 6}, {1, 8}, {9, 0}, {1, 0}, {9, 8}, {10, 3}, {5, 8}, {5, 3}, {10, 8}, {8, 2}, {0, 10}, {8, 10}, {0, 2}, {9, 0}, {2, 7}, {9, 7}, {2, 0}, {0, 4}, {5, 9}, {0, 9}, {5, 4}, {5, 3}, {10, 3}, {5, 8}, {10, 8}, {6, 4}, {7, 4}, {6, 5}, {7, 5}, {9, 1}, {0, 1}, {9, 10}, {0, 10}, {5, 10}, {5, 7}, {8, 7}, {8, 10}, {8, 0}, {8, 7}, {1, 7}, {1, 0}, {1, 1}, {9, 9}, {1, 9}, {9, 1}, {3, 1}, {3, 5}, {7, 5}, {7, 1}, {5, 8}, {5, 3}, {10, 8}, {10, 3}, {0, 9}, {2, 7}, {2, 9}, {0, 7}, {9, 3}, {9, 7}, {5, 3}, {5, 7}, {0, 0}, {9, 0}, {9, 9}, {0, 9}, {6, 4}, {4, 2}, {4, 4}, {6, 2}, {1, 9}, {1, 5}, {5, 5}, {5, 9}, {7, 7}, {0, 7}, {0, 0}, {7, 0}, {1, 3}, {1, 9}, {7, 3}, {7, 9}, {0, 9}, {9, 9}, {9, 0}, {0, 0}, {1, 8}, {3, 6}, {3, 8}, {1, 6}};           \\n            Object[] expected = new Object[]{null, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 2, null, null, null, 1, null, null, null, 1, null, null, null, 1, null, null, null, 2, null, null, null, 2, null, null, null, 2, null, null, null, 2, null, null, null, 5, null, null, null, 6, null, null, null, 2, null, null, null, 3, null, null, null, 3, null, null, null, 14, null, null, null, 3, null, null, null, 1, null, null, null, 2, null, null, null, 2, null, null, null, 4, null, null, null, 20, null, null, null, 4, null, null, null, 5, null, null, null, 10, null, null, null, 26, null, null, null, 8, null, null, null, 3, null, null, null, 7, null, null, null, 21, null, null, null, 20, null, null, null, 52, null, null, null, 6, null, null, null, 56, null, null, null, 2, null, null, null, 5, null, null, null, 17, null, null, null, 18, null, null, null, 13, null, null, null, 19, null, null, null, 102, null, null, null, 9, null, null, null, 2, null, null, null, 157, null, null, null, 23, null, null, null, 29, null, null, null, 23, null, null, null, 15, null, null, null, 24, null, null, null, 186, null, null, null, 12, null, null, null, 32, null, null, null, 36, null, null, null, 10, null, null, null, 35, null, null, null, 20, null, null, null, 43, null, null, null, 48, null, null, null, 35, null, null, null, 73, null, null, null, 59, null, null, null, 56, null, null, null, 72, null, null, null, 198, null, null, null, 37, null, null, null, 145, null, null, null, 130, null, null, null, 45, null, null, null, 68, null, null, null, 172, null, null, null, 281, null, null, null, 147, null, null, null, 53, null, null, null, 160, null, null, null, 105, null, null, null, 253, null, null, null, 82, null, null, null, 103, null, null, null, 248, null, null, null, 75, null, null, null, 86, null, null, null, 312, null, null, null, 301, null, null, null, 273, null, null, null, 119, null, null, null, 191, null, null, null, 61, null, null, null, 584, null, null, null, 696, null, null, null, 802, null, null, null, 293, null, null, null, 104, null, null, null, 114, null, null, null, 242, null, null, null, 259, null, null, null, 300, null, null, null, 465, null, null, null, 180, null, null, null, 1082, null, null, null, 697, null, null, null, 187, null, null, null, 113, null, null, null, 201, null, null, null, 520, null, null, null, 652, null, null, null, 197, null, null, null, 91, null, null, null, 670, null, null, null, 159, null, null, null, 189, null, null, null, 386, null, null, null, 403, null, null, null, 204, null, null, null, 301, null, null, null, 378, null, null, null, 314, null, null, null, 292, null, null, null, 352, null, null, null, 174, null, null, null, 2778, null, null, null, 473, null, null, null, 869, null, null, null, 1568, null, null, null, 190, null, null, null, 198, null, null, null, 342, null, null, null, 286, null, null, null, 1062, null, null, null, 475, null, null, null, 354, null, null, null, 174, null, null, null, 574, null, null, null, 1605, null, null, null, 547};\\n            executeTest(commands, command_args, expected);\\n        }\\n    }\\n\\n    class DetectSquares {\\n\\n        Map<Integer,Set<Integer>> xy=new HashMap();\\n        Map<Integer,Set<Integer>> yx=new HashMap();\\n        int points[][]=new int[1000+1][1000+1];\\n\\n        public DetectSquares() {}\\n\\n        public void add(int[] point) {\\n            points[point[0]][point[1]]++;\\n            xy.computeIfAbsent(point[0],p->new HashSet()).add(point[1]);\\n            yx.computeIfAbsent(point[1],p->new HashSet()).add(point[0]);\\n        }\\n\\n        public int count(int[] point) {\\n            int count=0;\\n            int x1=point[0], y1=point[1];\\n\\n            if( !xy.containsKey(x1)) { return 0; }\\n\\n            for (int y2:xy.get(x1) ){\\n                int x2=x1;\\n                if( y1!=y2 ) {\\n                    int y3=y1, y4=y2;\\n                    for (int x3:yx.get(y2) ) {\\n                        int x4=x3;\\n                        if( x3!=x1 && points[x3][y3]>0 && points[x4][y4]>0 && Math.abs(x3-x2)==Math.abs(y2-y1) ) {\\n                            count+=points[x2][y2]*points[x3][y3]*points[x4][y4];\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    class DetectSquares2 {\\n\\n        int points[][]=new int[1000+1][1000+1];\\n\\n        public DetectSquares2() {}\\n\\n        public void add(int[] point) {\\n            points[point[0]][point[1]]++;\\n        }\\n\\n        public int count(int[] point) {\\n            int count=0;\\n            int x1=point[0], y1=point[1];\\n            // look for (x,y) on y line, excluding (x1,y1)\\n            for (int y2 = 0; y2 <=1000 ; y2++) {\\n                int x2=x1;\\n                if( points[x2][y2]>0 && y1!=y2 ) {\\n                    int y3=y1, y4=y2;\\n                    for (int x3 = 0; x3 <=1000 ; x3++) {\\n                        int x4=x3;\\n                        if( x3!=x1 && points[x3][y3]>0 && points[x4][y4]>0 && Math.abs(x3-x2)==Math.abs(y2-y1) ) {\\n                            count+=points[x2][y2]*points[x3][y3]*points[x4][y4];\\n                        }\\n                    }\\n                }\\n            }\\n            return count;\\n        }\\n    }\\n\\n    void executeTest(String commands[], Object command_args[], Object expected[]) {\\n        log(\"command_args: \" + command_args.length );\\n\\n        DetectSquares squares=null;\\n        for (int i = 0; i < commands.length; i++) {\\n            String command=commands[i];\\n            Object arg=command_args[i];\\n            if( command.equalsIgnoreCase(\"DetectSquares\") ){\\n                squares=new DetectSquares();\\n            }\\n            else if( command.equalsIgnoreCase(\"add\") ){\\n                Object t[]=(Object[]) arg;\\n                int xy[]=new int[]{(Integer)t[0], (Integer)t[1]};\\n                squares.add(xy);\\n                //log(i + \", add: \" + Arrays.toString(xy) );\\n            }\\n            else if( command.equalsIgnoreCase(\"count\") ){\\n\\n                Object t[]=(Object[]) arg;\\n                int xy[]=new int[]{(Integer)t[0], (Integer)t[1]};\\n                int value=squares.count(xy);\\n                int e=(Integer)expected[i];\\n                log(i + \", count: \" + Arrays.toString(xy) + \", count: \" + value );\\n                Assert.assertEquals(e,value);\\n            }\\n            else {\\n                throw new IllegalArgumentException(\"Unparsed: \" + command );\\n            }\\n        }\\n\\n    }\\n\\n    public static void main(String args[]) {\\n        new DetectSquaresProblem();\\n    }\\n    public static void log(Object obj) {\\n        System.out.println(obj);  \\n    }\\n  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721595,
                "title": "go",
                "content": "```go\\ntype DetectSquares struct {\\n\\tpoints map[int]map[int]int\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{\\n\\t\\tpoints: make(map[int]map[int]int),\\n\\t}\\n}\\n\\nfunc (this *DetectSquares) Add(point []int) {\\n\\tp, exist := this.points[point[0]]\\n\\tif !exist {\\n\\t\\tp = make(map[int]int)\\n\\t}\\n\\tp[point[1]]++\\n\\tthis.points[point[0]] = p\\n}\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n\\tp, exist := this.points[point[0]]\\n\\tif !exist {\\n\\t\\treturn 0\\n\\t}\\n\\tyLen := len(p)\\n\\txLen := len(this.points)\\n\\tans := 0\\n\\tif yLen <= xLen {\\n\\t\\tfor y, times := range p {\\n\\t\\t\\tl := y - point[1]\\n\\t\\t\\tif l == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif m, exist := this.points[point[0]+l]; exist {\\n\\t\\t\\t\\tans += times * m[y] * m[point[1]]\\n\\t\\t\\t}\\n\\t\\t\\tif m, exist := this.points[point[0]-l]; exist {\\n\\t\\t\\t\\tans += times * m[y] * m[point[1]]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x, m := range this.points {\\n\\t\\t\\tl := x - point[0]\\n\\t\\t\\tif l == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tans += m[point[1]] * p[point[1]+l] * m[point[1]+l]\\n\\t\\t\\tans += m[point[1]] * p[point[1]-l] * m[point[1]-l]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype DetectSquares struct {\\n\\tpoints map[int]map[int]int\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{\\n\\t\\tpoints: make(map[int]map[int]int),\\n\\t}\\n}\\n\\nfunc (this *DetectSquares) Add(point []int) {\\n\\tp, exist := this.points[point[0]]\\n\\tif !exist {\\n\\t\\tp = make(map[int]int)\\n\\t}\\n\\tp[point[1]]++\\n\\tthis.points[point[0]] = p\\n}\\n\\nfunc (this *DetectSquares) Count(point []int) int {\\n\\tp, exist := this.points[point[0]]\\n\\tif !exist {\\n\\t\\treturn 0\\n\\t}\\n\\tyLen := len(p)\\n\\txLen := len(this.points)\\n\\tans := 0\\n\\tif yLen <= xLen {\\n\\t\\tfor y, times := range p {\\n\\t\\t\\tl := y - point[1]\\n\\t\\t\\tif l == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tif m, exist := this.points[point[0]+l]; exist {\\n\\t\\t\\t\\tans += times * m[y] * m[point[1]]\\n\\t\\t\\t}\\n\\t\\t\\tif m, exist := this.points[point[0]-l]; exist {\\n\\t\\t\\t\\tans += times * m[y] * m[point[1]]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} else {\\n\\t\\tfor x, m := range this.points {\\n\\t\\t\\tl := x - point[0]\\n\\t\\t\\tif l == 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n\\t\\t\\tans += m[point[1]] * p[point[1]+l] * m[point[1]+l]\\n\\t\\t\\tans += m[point[1]] * p[point[1]-l] * m[point[1]-l]\\n\\t\\t}\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1720895,
                "title": "solution-for-java-using-hashmap",
                "content": "```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> row2Col = new HashMap<>();\\n    \\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        Map<Integer, Integer> col2Cnt = row2Col.getOrDefault(x, new HashMap<>());\\n        col2Cnt.put(y, col2Cnt.getOrDefault(y, 0) + 1);\\n        row2Col.put(x, col2Cnt);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0], y = point[1];\\n        int ans = 0;\\n        Map<Integer, Integer> col2Cnt = row2Col.getOrDefault(x, new HashMap<>());\\n        for (int ny : col2Cnt.keySet()) {\\n            if (ny == y) continue;\\n            int c1 = col2Cnt.get(ny);\\n            int len = y - ny;\\n            int[] nums = new int[]{x + len, x - len};\\n            for (int nx : nums) {\\n                Map<Integer, Integer> temp = row2Col.getOrDefault(nx, new HashMap<>());\\n                int c2 = temp.getOrDefault(y, 0), c3 = temp.getOrDefault(ny, 0);\\n                ans += c1 * c2 * c3;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> row2Col = new HashMap<>();\\n    \\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        Map<Integer, Integer> col2Cnt = row2Col.getOrDefault(x, new HashMap<>());\\n        col2Cnt.put(y, col2Cnt.getOrDefault(y, 0) + 1);\\n        row2Col.put(x, col2Cnt);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0], y = point[1];\\n        int ans = 0;\\n        Map<Integer, Integer> col2Cnt = row2Col.getOrDefault(x, new HashMap<>());\\n        for (int ny : col2Cnt.keySet()) {\\n            if (ny == y) continue;\\n            int c1 = col2Cnt.get(ny);\\n            int len = y - ny;\\n            int[] nums = new int[]{x + len, x - len};\\n            for (int nx : nums) {\\n                Map<Integer, Integer> temp = row2Col.getOrDefault(nx, new HashMap<>());\\n                int c2 = temp.getOrDefault(y, 0), c3 = temp.getOrDefault(ny, 0);\\n                ans += c1 * c2 * c3;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697855,
                "title": "c-2d-array-soln",
                "content": "This solution uses an array since we know that we have a limited number of possible positions (only 1001 x 1001). Using an array makes this function cache friendly (map is not). Count is quite fast since we do not need to check if a point exists, its value is already set to zero in the constructor. We just need to check that the positions we are looking for are in bounds. \\n\\nTime Complexity:\\nconstructor: O(n^2), with arrays we need to set all values equal to zero\\nadd: O(1)\\ncount: O(n)\\n\\n\\'\\'\\'\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        for(int i = 0; i < 1001; i ++)\\n            for(int j = 0; j < 1001; j ++)\\n                arr[i][j] = 0;\\n    }\\n    \\n    void add(vector<int> point) {\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0], y1 = point[1], res = 0;\\n        for(int x2 = 0; x2 < 1001; x2++) {\\n            if (x2 != x1) {\\n                int dist = abs(x1 - x2);\\n                int y2[2] = {y1 - dist, y1 + dist};\\n                for(int i = 0; i <= 1; i ++)\\n                    if(y2[i] >= 0 && y2[i] < 1001)\\n\\t\\t\\t\\t\\t\\t//dont multiply by point because it is zero in the array\\n                        res += arr[x1][y2[i]]*arr[x2][y1]*arr[x2][y2[i]]; \\n            }               \\n        }\\n        return res;\\n    }\\n\\nprivate:\\n\\tint arr[1001][1001]; //[x][y]\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "This solution uses an array since we know that we have a limited number of possible positions (only 1001 x 1001). Using an array makes this function cache friendly (map is not). Count is quite fast since we do not need to check if a point exists, its value is already set to zero in the constructor. We just need to check that the positions we are looking for are in bounds. \\n\\nTime Complexity:\\nconstructor: O(n^2), with arrays we need to set all values equal to zero\\nadd: O(1)\\ncount: O(n)\\n\\n\\'\\'\\'\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        for(int i = 0; i < 1001; i ++)\\n            for(int j = 0; j < 1001; j ++)\\n                arr[i][j] = 0;\\n    }\\n    \\n    void add(vector<int> point) {\\n        arr[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0], y1 = point[1], res = 0;\\n        for(int x2 = 0; x2 < 1001; x2++) {\\n            if (x2 != x1) {\\n                int dist = abs(x1 - x2);\\n                int y2[2] = {y1 - dist, y1 + dist};\\n                for(int i = 0; i <= 1; i ++)\\n                    if(y2[i] >= 0 && y2[i] < 1001)\\n\\t\\t\\t\\t\\t\\t//dont multiply by point because it is zero in the array\\n                        res += arr[x1][y2[i]]*arr[x2][y1]*arr[x2][y2[i]]; \\n            }               \\n        }\\n        return res;\\n    }\\n\\nprivate:\\n\\tint arr[1001][1001]; //[x][y]\\n};\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1640946,
                "title": "java-hashmap-minor-optimization",
                "content": "store the points by x, y axis separately. Minor optimizaiton by also storing count to reduce query time by sacrificing space and update time.\\n```\\nclass DetectSquares {\\n    private HashMap<Integer, List<Integer>> pointsByX = new HashMap<Integer, List<Integer>>();\\n    private HashMap<Integer, List<Integer>> pointsByY = new HashMap<Integer, List<Integer>>();\\n    \\n    private HashMap<Integer, Integer> pointCount = new HashMap<Integer, Integer>();\\n    \\n    public DetectSquares() {\\n        \\n    }\\n    \\n    public void add(int[] point) {\\n        // add count;\\n        int count = 0;\\n        int key = getKey(point);\\n        \\n        if(pointCount.containsKey(key)){\\n            count = pointCount.get(key);\\n        }\\n        else{\\n            // add new point to x map\\n            addPointToMap(pointsByX, point[0], point[1]);\\n        \\n            // add new point to y map\\n            addPointToMap(pointsByY, point[1], point[0]);\\n        }\\n        \\n        pointCount.put(key, ++count);\\n    }\\n    \\n    public int count(int[] point) {\\n        int result = 0;\\n        \\n        // get list of point matches x\\n        List<Integer> listY = pointsByX.get(point[0]);\\n            \\n        // get list of point matches y\\n        List<Integer> listX = pointsByY.get(point[1]);\\n        \\n        if(listX == null || listY == null){\\n            return result;\\n        }\\n        \\n        for(int x : listX){\\n            for(int y : listY){\\n                if(x == point[0] && y == point[1]){\\n                    continue;\\n                }\\n                \\n                int key = getKey(new int[]{x, y});\\n                \\n                if( Math.abs(x - point[0]) == Math.abs(y - point[1])\\n                    && pointCount.containsKey(key)){                    \\n                    int key1 = getKey(new int[]{point[0], y});\\n                    int key2 = getKey(new int[]{x, point[1]});\\n                    \\n                    result += pointCount.get(key) * pointCount.get(key1) * pointCount.get(key2);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int getKey(int[] point){\\n        return point[0] * 2000 + point[1];\\n    }\\n    \\n    private void addPointToMap(HashMap<Integer, List<Integer>> map, int key, int val){\\n        List<Integer> list;\\n        if(map.containsKey(key)){\\n            list = map.get(key);\\n        }\\n        else{\\n            list = new ArrayList<Integer>();\\n        }\\n        \\n        list.add(val);\\n        \\n        map.put(key, list);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n    private HashMap<Integer, List<Integer>> pointsByX = new HashMap<Integer, List<Integer>>();\\n    private HashMap<Integer, List<Integer>> pointsByY = new HashMap<Integer, List<Integer>>();\\n    \\n    private HashMap<Integer, Integer> pointCount = new HashMap<Integer, Integer>();\\n    \\n    public DetectSquares() {\\n        \\n    }\\n    \\n    public void add(int[] point) {\\n        // add count;\\n        int count = 0;\\n        int key = getKey(point);\\n        \\n        if(pointCount.containsKey(key)){\\n            count = pointCount.get(key);\\n        }\\n        else{\\n            // add new point to x map\\n            addPointToMap(pointsByX, point[0], point[1]);\\n        \\n            // add new point to y map\\n            addPointToMap(pointsByY, point[1], point[0]);\\n        }\\n        \\n        pointCount.put(key, ++count);\\n    }\\n    \\n    public int count(int[] point) {\\n        int result = 0;\\n        \\n        // get list of point matches x\\n        List<Integer> listY = pointsByX.get(point[0]);\\n            \\n        // get list of point matches y\\n        List<Integer> listX = pointsByY.get(point[1]);\\n        \\n        if(listX == null || listY == null){\\n            return result;\\n        }\\n        \\n        for(int x : listX){\\n            for(int y : listY){\\n                if(x == point[0] && y == point[1]){\\n                    continue;\\n                }\\n                \\n                int key = getKey(new int[]{x, y});\\n                \\n                if( Math.abs(x - point[0]) == Math.abs(y - point[1])\\n                    && pointCount.containsKey(key)){                    \\n                    int key1 = getKey(new int[]{point[0], y});\\n                    int key2 = getKey(new int[]{x, point[1]});\\n                    \\n                    result += pointCount.get(key) * pointCount.get(key1) * pointCount.get(key2);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int getKey(int[] point){\\n        return point[0] * 2000 + point[1];\\n    }\\n    \\n    private void addPointToMap(HashMap<Integer, List<Integer>> map, int key, int val){\\n        List<Integer> list;\\n        if(map.containsKey(key)){\\n            list = map.get(key);\\n        }\\n        else{\\n            list = new ArrayList<Integer>();\\n        }\\n        \\n        list.add(val);\\n        \\n        map.put(key, list);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632887,
                "title": "c-simple-and-fast-solution",
                "content": "We store each point in rows and columns - rows stands for values on the Y-axis, columns for values added on X-axis.\\nWhen querying the Count for a given point P = (x, y) we interate over all elements **from the same ROW** as P i.e. `row[P.y]` because `P.y` defines the row index. For each item in the same **ROW** we assume it\\'s the secon point of a square (first is queried point P) so we look for two additional points of the square by querying the **COLUMS** with a given square side length.\\n\\nWe could use generic ***List<>*** to simplify the code but runtime jumps to 2800ms, when using ***Dictionary*** the runtime is only 280ms\\n![image](https://assets.leetcode.com/users/images/c9d3ddb8-d4a4-4c74-805e-f989de755f8a_1639754685.1426885.png)\\n```\\npublic class DetectSquares\\n{\\n\\tDictionary<int, int>[] rows;\\n\\tDictionary<int, int>[] cols;\\n\\n\\tpublic DetectSquares()\\n\\t{\\n\\t\\trows = new Dictionary<int, int>[1001];\\n\\t\\tcols = new Dictionary<int, int>[1001];\\n\\t}\\n\\n\\tpublic void Add(int[] point)\\n\\t{\\n\\t\\tint x = point[0];\\n\\t\\tint y = point[1];\\n\\t\\tif (rows[y] == null)\\n\\t\\t\\trows[y] = new Dictionary<int, int>();\\n\\t\\tif (cols[x] == null)\\n\\t\\t\\tcols[x] = new Dictionary<int, int>();\\n\\t\\tif (!rows[y].ContainsKey(x))\\n\\t\\t\\trows[y].Add(x, 0);\\n\\t\\tif (!cols[x].ContainsKey(y))\\n\\t\\t\\tcols[x].Add(y, 0);\\n\\n\\t\\trows[y][x]++;\\n\\t\\tcols[x][y]++;\\n\\t}\\n\\n\\tpublic int Count(int[] point)\\n\\t{\\n\\t\\tint x = point[0];\\n\\t\\tint y = point[1];\\n\\t\\tint res = 0;\\n\\n\\t\\tif (rows[y] != null)\\n\\t\\t\\tforeach (var kvp in rows[y])    //all added points on the same Y-axis level\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar xprim = kvp.Key;\\n\\t\\t\\t\\tvar quantity = kvp.Value;\\n\\n\\t\\t\\t\\tif (xprim == x)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvar d = Math.Abs(x - xprim);\\n\\t\\t\\t\\t//count all squares alligned LEFT from the query point (x,y)\\n\\t\\t\\t\\tif (y - d >= 0 && cols[xprim]?.ContainsKey(y - d) == true && cols[x]?.ContainsKey(y - d) == true)\\n\\t\\t\\t\\t\\tres += quantity * cols[xprim][y - d] * cols[x][y - d];\\n\\t\\t\\t\\t//count all squares alligned RIGHT from the query point (x,y)\\n\\t\\t\\t\\tif (y + d <= 1000 && cols[xprim]?.ContainsKey(y + d) == true && cols[x]?.ContainsKey(y + d) == true)\\n\\t\\t\\t\\t\\tres += quantity * cols[xprim][y + d] * cols[x][y + d];\\n\\t\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class DetectSquares\\n{\\n\\tDictionary<int, int>[] rows;\\n\\tDictionary<int, int>[] cols;\\n\\n\\tpublic DetectSquares()\\n\\t{\\n\\t\\trows = new Dictionary<int, int>[1001];\\n\\t\\tcols = new Dictionary<int, int>[1001];\\n\\t}\\n\\n\\tpublic void Add(int[] point)\\n\\t{\\n\\t\\tint x = point[0];\\n\\t\\tint y = point[1];\\n\\t\\tif (rows[y] == null)\\n\\t\\t\\trows[y] = new Dictionary<int, int>();\\n\\t\\tif (cols[x] == null)\\n\\t\\t\\tcols[x] = new Dictionary<int, int>();\\n\\t\\tif (!rows[y].ContainsKey(x))\\n\\t\\t\\trows[y].Add(x, 0);\\n\\t\\tif (!cols[x].ContainsKey(y))\\n\\t\\t\\tcols[x].Add(y, 0);\\n\\n\\t\\trows[y][x]++;\\n\\t\\tcols[x][y]++;\\n\\t}\\n\\n\\tpublic int Count(int[] point)\\n\\t{\\n\\t\\tint x = point[0];\\n\\t\\tint y = point[1];\\n\\t\\tint res = 0;\\n\\n\\t\\tif (rows[y] != null)\\n\\t\\t\\tforeach (var kvp in rows[y])    //all added points on the same Y-axis level\\n\\t\\t\\t{\\n\\t\\t\\t\\tvar xprim = kvp.Key;\\n\\t\\t\\t\\tvar quantity = kvp.Value;\\n\\n\\t\\t\\t\\tif (xprim == x)\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\tvar d = Math.Abs(x - xprim);\\n\\t\\t\\t\\t//count all squares alligned LEFT from the query point (x,y)\\n\\t\\t\\t\\tif (y - d >= 0 && cols[xprim]?.ContainsKey(y - d) == true && cols[x]?.ContainsKey(y - d) == true)\\n\\t\\t\\t\\t\\tres += quantity * cols[xprim][y - d] * cols[x][y - d];\\n\\t\\t\\t\\t//count all squares alligned RIGHT from the query point (x,y)\\n\\t\\t\\t\\tif (y + d <= 1000 && cols[xprim]?.ContainsKey(y + d) == true && cols[x]?.ContainsKey(y + d) == true)\\n\\t\\t\\t\\t\\tres += quantity * cols[xprim][y + d] * cols[x][y + d];\\n\\t\\t\\t}\\n\\n\\t\\treturn res;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626061,
                "title": "easy-to-read-commented-c-solution-o-n-time-o-n-space-with-unordered-map",
                "content": "```\\n// IDEA:\\n//  add: Mark all coordinates in a map\\n//  count:\\n//      1. Iterate the map and find if there is a point\\n//         in the same Y-axis of the query point\\n//      2. If yes, get the side length of square\\n//         by finding the Y-distance between the two points\\n//      3. For the above two points find if there is a point\\n//         on the same Y-axis with X-distance == side length respectively.\\n//      4. If both points exists, we can construct a square.\\n//      5. The result is multiplication of frequency of each point.\\n//\\n// NOTE:\\n//  Special cases that are not mentioned in the question\\n//  NOTE 1) if the query point already exists, the existing points do not contribute to the query result\\n//  NOTE 2) square with side length 0 is not counted as squares (4 points on same coordinates)\\n//\\n// Complexity Analysis\\n//  Time:\\n//    - add: average O(1) insertion to unordered_map\\n//    - count: O(n) since we have to traverse each point in the map (O(1) average time for unordered_map operations)\\n//  Space: O(n) due to storing each point in map\\n\\n// pair hashing for unordered_map\\nstruct HashPair {\\npublic:\\n    size_t operator() (const pair<int, int> &p) const {\\n        size_t h1 = hash<int>{}(p.first);\\n        size_t h2 = hash<int>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass DetectSquares {\\nprivate:\\n    unordered_map<pair<int, int>, int, HashPair> map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n\\t// Push each point into map\\n    void add(vector<int> point) {\\n        map[{point[0], point[1]}]++;\\n    }\\n    \\n    // NOTE: p1, p2, p3 represents point 0, 1, 2, 3 of square\\n    int count(vector<int> point) {\\n        int res = 0;\\n        int p0X = point[0];\\n        int p0Y = point[1];\\n        \\n        for (auto &p1It : map) {\\n            int p1X = p1It.first.first;\\n            int p1Y = p1It.first.second;\\n            \\n\\t\\t\\t// check if this point is on the same X-axis\\n            if (p1X == p0X) {\\n                int diff = abs(p0Y - p1Y);\\n                \\n                if (diff == 0) continue; // refer to NOTE 2\\n                \\n                // check left side and see if we can form a square\\n                auto p2It = map.find({p0X - diff, p0Y});\\n                auto p3It = map.find({p1X - diff, p1Y});\\n                if (p2It != map.end() && p3It != map.end()) {\\n                    res += (p1It.second * p2It->second * p3It->second);\\n                }\\n                \\n                // check right side and see if we can form a square\\n                p2It = map.find({p0X + diff, p0Y});\\n                p3It = map.find({p1X + diff, p1Y});\\n                if (p2It != map.end() && p3It != map.end()) {\\n                    res += (p1It.second * p2It->second * p3It->second);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// IDEA:\\n//  add: Mark all coordinates in a map\\n//  count:\\n//      1. Iterate the map and find if there is a point\\n//         in the same Y-axis of the query point\\n//      2. If yes, get the side length of square\\n//         by finding the Y-distance between the two points\\n//      3. For the above two points find if there is a point\\n//         on the same Y-axis with X-distance == side length respectively.\\n//      4. If both points exists, we can construct a square.\\n//      5. The result is multiplication of frequency of each point.\\n//\\n// NOTE:\\n//  Special cases that are not mentioned in the question\\n//  NOTE 1) if the query point already exists, the existing points do not contribute to the query result\\n//  NOTE 2) square with side length 0 is not counted as squares (4 points on same coordinates)\\n//\\n// Complexity Analysis\\n//  Time:\\n//    - add: average O(1) insertion to unordered_map\\n//    - count: O(n) since we have to traverse each point in the map (O(1) average time for unordered_map operations)\\n//  Space: O(n) due to storing each point in map\\n\\n// pair hashing for unordered_map\\nstruct HashPair {\\npublic:\\n    size_t operator() (const pair<int, int> &p) const {\\n        size_t h1 = hash<int>{}(p.first);\\n        size_t h2 = hash<int>{}(p.second);\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass DetectSquares {\\nprivate:\\n    unordered_map<pair<int, int>, int, HashPair> map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n\\t// Push each point into map\\n    void add(vector<int> point) {\\n        map[{point[0], point[1]}]++;\\n    }\\n    \\n    // NOTE: p1, p2, p3 represents point 0, 1, 2, 3 of square\\n    int count(vector<int> point) {\\n        int res = 0;\\n        int p0X = point[0];\\n        int p0Y = point[1];\\n        \\n        for (auto &p1It : map) {\\n            int p1X = p1It.first.first;\\n            int p1Y = p1It.first.second;\\n            \\n\\t\\t\\t// check if this point is on the same X-axis\\n            if (p1X == p0X) {\\n                int diff = abs(p0Y - p1Y);\\n                \\n                if (diff == 0) continue; // refer to NOTE 2\\n                \\n                // check left side and see if we can form a square\\n                auto p2It = map.find({p0X - diff, p0Y});\\n                auto p3It = map.find({p1X - diff, p1Y});\\n                if (p2It != map.end() && p3It != map.end()) {\\n                    res += (p1It.second * p2It->second * p3It->second);\\n                }\\n                \\n                // check right side and see if we can form a square\\n                p2It = map.find({p0X + diff, p0Y});\\n                p3It = map.find({p1X + diff, p1Y});\\n                if (p2It != map.end() && p3It != map.end()) {\\n                    res += (p1It.second * p2It->second * p3It->second);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531786,
                "title": "python-simple-hashmap-solution-beats-95",
                "content": "Count the occurence for each added point using a dictionary. We can store all the points with the same height in a separate dictionary in order to limit the search space later. To count the valid squares we need to loop over all points that have the same height as the query. Then we simply check if the other two points of the square exist. The square can be above or below these 2 points, so we need to check these two options. The total amount is the product of all fequencies if we have a valid square.\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        self.y_points = defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        x,y = point\\n        self.points[(x,y)] += 1\\n        self.y_points[y].add(x)\\n\\n    def count(self, query: List[int]) -> int:\\n        qx,y = query\\n        csum = 0\\n        for x in self.y_points[y]:\\n            diff = abs(qx - x)\\n            if diff != 0:\\n                if (qx, y+diff) in self.points and (x, y+diff) in self.points:\\n                    csum += self.points[(x,y)]*self.points[(qx,y+diff)]*self.points[(x,y+diff)]\\n                if (qx, y-diff) in self.points and (x, y-diff) in self.points:\\n                    csum += self.points[(x,y)]*self.points[(qx,y-diff)]*self.points[(x,y-diff)]\\n        return csum",
                "solutionTags": [
                    "Python"
                ],
                "code": "Count the occurence for each added point using a dictionary. We can store all the points with the same height in a separate dictionary in order to limit the search space later. To count the valid squares we need to loop over all points that have the same height as the query. Then we simply check if the other two points of the square exist. The square can be above or below these 2 points, so we need to check these two options. The total amount is the product of all fequencies if we have a valid square.\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        self.y_points = defaultdict(set)\\n\\n    def add(self, point: List[int]) -> None:\\n        x,y = point\\n        self.points[(x,y)] += 1\\n        self.y_points[y].add(x)\\n\\n    def count(self, query: List[int]) -> int:\\n        qx,y = query\\n        csum = 0\\n        for x in self.y_points[y]:\\n            diff = abs(qx - x)\\n            if diff != 0:\\n                if (qx, y+diff) in self.points and (x, y+diff) in self.points:\\n                    csum += self.points[(x,y)]*self.points[(qx,y+diff)]*self.points[(x,y+diff)]\\n                if (qx, y-diff) in self.points and (x, y-diff) in self.points:\\n                    csum += self.points[(x,y)]*self.points[(qx,y-diff)]*self.points[(x,y-diff)]\\n        return csum",
                "codeTag": "Java"
            },
            {
                "id": 1524106,
                "title": "java-hashmap-with-customized-class-definition",
                "content": "A few answeres in discussion took advantage of the boundary `[0, 1000]` and iterate through that.\\nThis post aims to provide a low time complexity way when the input is unbounded.\\n```\\nclass DetectSquares {\\n\\n    private Map<Point, Integer> plane = new HashMap<>();\\n\\n    public DetectSquares() {\\n        \\n    }\\n    \\n    public void add(int[] point) {\\n        Point p = new Point(point[0], point[1]);\\n        plane.put(p, plane.getOrDefault(p, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int result = 0;\\n        for (Map.Entry<Point, Integer> e : plane.entrySet()) {\\n            Point p2 = e.getKey();\\n            int x2 = p2.x;\\n            int y2 = p2.y;\\n            if (x1 == x2 || y1 == y2 || Math.abs(x1 - x2) != Math.abs(y1 - y2)) {\\n                continue;\\n            }\\n            Point p3 = new Point(x1, y2);\\n            Point p4 = new Point(x2, y1);\\n            result += e.getValue() * plane.getOrDefault(p3, 0) * plane.getOrDefault(p4, 0);\\n        }\\n        return result;\\n    }\\n    \\n    private static class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return this.x * 1000 + this.y;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n            if (obj instanceof Point) {\\n                Point that = (Point) obj;\\n                return this.x == that.x && this.y == that.y;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n\\n    private Map<Point, Integer> plane = new HashMap<>();\\n\\n    public DetectSquares() {\\n        \\n    }\\n    \\n    public void add(int[] point) {\\n        Point p = new Point(point[0], point[1]);\\n        plane.put(p, plane.getOrDefault(p, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int result = 0;\\n        for (Map.Entry<Point, Integer> e : plane.entrySet()) {\\n            Point p2 = e.getKey();\\n            int x2 = p2.x;\\n            int y2 = p2.y;\\n            if (x1 == x2 || y1 == y2 || Math.abs(x1 - x2) != Math.abs(y1 - y2)) {\\n                continue;\\n            }\\n            Point p3 = new Point(x1, y2);\\n            Point p4 = new Point(x2, y1);\\n            result += e.getValue() * plane.getOrDefault(p3, 0) * plane.getOrDefault(p4, 0);\\n        }\\n        return result;\\n    }\\n    \\n    private static class Point {\\n        int x;\\n        int y;\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n        \\n        @Override\\n        public int hashCode() {\\n            return this.x * 1000 + this.y;\\n        }\\n        \\n        @Override\\n        public boolean equals(Object obj) {\\n            if (this == obj) {\\n                return true;\\n            }\\n            if (obj instanceof Point) {\\n                Point that = (Point) obj;\\n                return this.x == that.x && this.y == that.y;\\n            }\\n            return false;\\n        }\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1507926,
                "title": "c-python-100-faster-easy-solution-unorderedmap",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, map<int, int>> mp;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[point[1]][point[0]] += 1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        int px = point[0], py = point[1];\\n        for(auto it = mp[py].begin(); it != mp[py].end(); it++){\\n            if(it->first == px)\\n                continue;\\n            int x = it->first;\\n            int len = abs(x - px);\\n            if(py - len >= 0){\\n                ans += it->second * mp[py - len][x] * mp[py - len][px];\\n            }\\n            if(py + len <= 1000){\\n                ans += it->second * mp[py + len][x] * mp[py + len][px];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPython\\n```\\nclass DetectSquares(object):\\n\\n    def __init__(self):\\n        self.mp = collections.defaultdict(lambda:collections.defaultdict(int))\\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.mp[point[0]][point[1]] += 1\\n        \\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if point[0] not in self.mp:\\n            return 0\\n        ans = 0\\n        x = point[0]\\n        y = point[1]\\n        for ty in self.mp[x]:\\n            if ty == y:\\n                continue\\n            s = abs(y - ty)\\n            for tx in (x+s, x-s):\\n                if tx > 1000 or tx < 0:\\n                    continue\\n                ans += self.mp[x][ty] * self.mp[tx][y] * self.mp[tx][ty]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, map<int, int>> mp;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[point[1]][point[0]] += 1;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        int px = point[0], py = point[1];\\n        for(auto it = mp[py].begin(); it != mp[py].end(); it++){\\n            if(it->first == px)\\n                continue;\\n            int x = it->first;\\n            int len = abs(x - px);\\n            if(py - len >= 0){\\n                ans += it->second * mp[py - len][x] * mp[py - len][px];\\n            }\\n            if(py + len <= 1000){\\n                ans += it->second * mp[py + len][x] * mp[py + len][px];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass DetectSquares(object):\\n\\n    def __init__(self):\\n        self.mp = collections.defaultdict(lambda:collections.defaultdict(int))\\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.mp[point[0]][point[1]] += 1\\n        \\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if point[0] not in self.mp:\\n            return 0\\n        ans = 0\\n        x = point[0]\\n        y = point[1]\\n        for ty in self.mp[x]:\\n            if ty == y:\\n                continue\\n            s = abs(y - ty)\\n            for tx in (x+s, x-s):\\n                if tx > 1000 or tx < 0:\\n                    continue\\n                ans += self.mp[x][ty] * self.mp[tx][y] * self.mp[tx][ty]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1478111,
                "title": "advanced-o-n-2-3",
                "content": "```\\n/***************************************************\\nAuthor: hqztrue\\nhttps://github.com/hqztrue/LeetCodeSolutions\\nComplexity: O(n^{2/3}) per operation\\nIf you find this solution helpful, plz give a star:)\\n***************************************************/\\nconst int N=5005,M=1005;\\nint c[M][M],t[M][M],pre[M][M],x[N],y[N],p1;\\nvector<int> vx[M],vy[M];\\nvector<vector<int>> q;\\nclass DetectSquares {\\npublic:\\n\\tDetectSquares() {\\n\\t\\tp1=1; q.clear();\\n\\t\\tfor (int i=0;i<M;++i)vx[i].clear(),vy[i].clear();\\n\\t}\\n\\tvoid add(const vector<int> &p) {\\n\\t\\tint x0=p[0],y0=p[1];\\n\\t\\tx[p1]=x0; y[p1++]=y0;\\n\\t\\tif (++c[x0][y0]==1)vx[x0].push_back(y0),vy[y0].push_back(x0);\\n\\t}\\n\\tint count(const vector<int> &p) {\\n\\t\\tint x0=p[0],y0=p[1],S=(int)pow(p1,2./3)*2+1,ans=0,\\n\\t\\t\\ts1=vx[x0].size(),s2=vy[y0].size(),&t0=t[x0][y0];\\n\\t\\tq.push_back(p);\\n\\t\\tif (s1<=s2&&(s1<=S||p1-t0>S)){\\n\\t\\t\\tfor (int y1:vx[x0]){\\n\\t\\t\\t\\tint x1=x0-y1+y0,_c=c[x0][y1];\\n\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=_c*c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\tx1=x0+y1-y0;\\n\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=_c*c[x1][y0]*c[x1][y1];\\n\\t\\t\\t}\\n\\t\\t\\tans-=2*c[x0][y0]*c[x0][y0]*c[x0][y0];\\n\\t\\t}\\n\\t\\telse if (s1>s2&&(s2<=S||p1-t0>S)){\\n\\t\\t\\tfor (int x1:vy[y0]){\\n\\t\\t\\t\\tint y1=y0-x1+x0,_c=c[x1][y0];\\n\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*_c*c[x1][y1];\\n\\t\\t\\t\\ty1=y0+x1-x0;\\n\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*_c*c[x1][y1];\\n\\t\\t\\t}\\n\\t\\t\\tans-=2*c[x0][y0]*c[x0][y0]*c[x0][y0];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tans=pre[x0][y0];\\n\\t\\t\\tfor (int i=t0+1;i<p1;++i)--c[x[i]][y[i]];\\n\\t\\t\\tfor (int i=t0+1;i<p1;++i){\\n\\t\\t\\t\\tint X=x[i],Y=y[i]; ++c[X][Y];\\n\\t\\t\\t\\tif (X==x0&&Y==y0)continue;\\n\\t\\t\\t\\tif (X==x0){\\n\\t\\t\\t\\t\\tint y1=Y,x1=x0-y1+y0;\\n\\t\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\t\\tx1=x0+y1-y0;\\n\\t\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (Y==y0){\\n\\t\\t\\t\\t\\tint x1=X,y1=y0-x1+x0;\\n\\t\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*c[x1][y1];\\n\\t\\t\\t\\t\\ty1=y0+x1-x0;\\n\\t\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*c[x1][y1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (X-Y==x0-y0||X+Y==x0+y0)ans+=c[x0][Y]*c[X][y0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tt0=p1-1; pre[x0][y0]=ans;\\n\\t\\treturn ans;\\n\\t}\\n\\t~DetectSquares(){\\n\\t\\tfor (int i=1;i<p1;++i)c[x[i]][y[i]]=0;\\n\\t\\tfor (auto &p:q)t[p[0]][p[1]]=pre[p[0]][p[1]]=0;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/***************************************************\\nAuthor: hqztrue\\nhttps://github.com/hqztrue/LeetCodeSolutions\\nComplexity: O(n^{2/3}) per operation\\nIf you find this solution helpful, plz give a star:)\\n***************************************************/\\nconst int N=5005,M=1005;\\nint c[M][M],t[M][M],pre[M][M],x[N],y[N],p1;\\nvector<int> vx[M],vy[M];\\nvector<vector<int>> q;\\nclass DetectSquares {\\npublic:\\n\\tDetectSquares() {\\n\\t\\tp1=1; q.clear();\\n\\t\\tfor (int i=0;i<M;++i)vx[i].clear(),vy[i].clear();\\n\\t}\\n\\tvoid add(const vector<int> &p) {\\n\\t\\tint x0=p[0],y0=p[1];\\n\\t\\tx[p1]=x0; y[p1++]=y0;\\n\\t\\tif (++c[x0][y0]==1)vx[x0].push_back(y0),vy[y0].push_back(x0);\\n\\t}\\n\\tint count(const vector<int> &p) {\\n\\t\\tint x0=p[0],y0=p[1],S=(int)pow(p1,2./3)*2+1,ans=0,\\n\\t\\t\\ts1=vx[x0].size(),s2=vy[y0].size(),&t0=t[x0][y0];\\n\\t\\tq.push_back(p);\\n\\t\\tif (s1<=s2&&(s1<=S||p1-t0>S)){\\n\\t\\t\\tfor (int y1:vx[x0]){\\n\\t\\t\\t\\tint x1=x0-y1+y0,_c=c[x0][y1];\\n\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=_c*c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\tx1=x0+y1-y0;\\n\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=_c*c[x1][y0]*c[x1][y1];\\n\\t\\t\\t}\\n\\t\\t\\tans-=2*c[x0][y0]*c[x0][y0]*c[x0][y0];\\n\\t\\t}\\n\\t\\telse if (s1>s2&&(s2<=S||p1-t0>S)){\\n\\t\\t\\tfor (int x1:vy[y0]){\\n\\t\\t\\t\\tint y1=y0-x1+x0,_c=c[x1][y0];\\n\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*_c*c[x1][y1];\\n\\t\\t\\t\\ty1=y0+x1-x0;\\n\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*_c*c[x1][y1];\\n\\t\\t\\t}\\n\\t\\t\\tans-=2*c[x0][y0]*c[x0][y0]*c[x0][y0];\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tans=pre[x0][y0];\\n\\t\\t\\tfor (int i=t0+1;i<p1;++i)--c[x[i]][y[i]];\\n\\t\\t\\tfor (int i=t0+1;i<p1;++i){\\n\\t\\t\\t\\tint X=x[i],Y=y[i]; ++c[X][Y];\\n\\t\\t\\t\\tif (X==x0&&Y==y0)continue;\\n\\t\\t\\t\\tif (X==x0){\\n\\t\\t\\t\\t\\tint y1=Y,x1=x0-y1+y0;\\n\\t\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\t\\tx1=x0+y1-y0;\\n\\t\\t\\t\\t\\tif (x1>=0&&x1<M)ans+=c[x1][y0]*c[x1][y1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (Y==y0){\\n\\t\\t\\t\\t\\tint x1=X,y1=y0-x1+x0;\\n\\t\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*c[x1][y1];\\n\\t\\t\\t\\t\\ty1=y0+x1-x0;\\n\\t\\t\\t\\t\\tif (y1>=0&&y1<M)ans+=c[x0][y1]*c[x1][y1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (X-Y==x0-y0||X+Y==x0+y0)ans+=c[x0][Y]*c[X][y0];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tt0=p1-1; pre[x0][y0]=ans;\\n\\t\\treturn ans;\\n\\t}\\n\\t~DetectSquares(){\\n\\t\\tfor (int i=1;i<p1;++i)c[x[i]][y[i]]=0;\\n\\t\\tfor (auto &p:q)t[p[0]][p[1]]=pre[p[0]][p[1]]=0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474164,
                "title": "c-easy-solution-using-map",
                "content": "//Using map;\\n// first parameter of map saves points in pair form \\n//second parameter saves the occurence\\n\\nT.C=O(n);\\n\\nclass DetectSquares {\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\npublic:\\n     map<pair<int,int>, int>mp;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[{point[0], point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        int ans = 0;\\n        for(auto it : mp)\\n        {\\n            pair<int,int>p = it.first;\\n            //the first two condition checks coinciding points & third condition checks if its diagonal point or not\\n            if(p.first != point[0] and p.second != point[1] and (abs(point[0] - p.first) == abs(point[1] - p.second)))  \\n            { \\n                //if p is diagonal point then other points are\\n                \\n                int first = mp[{p.first, p.second}]; //diagonal\\n                int second = mp[{p.first, point[1]}];\\n                int third = mp[{point[0], p.second}];\\n                \\n                int cur = first * second * third;\\n                ans += cur;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "//Using map;\\n// first parameter of map saves points in pair form \\n//second parameter saves the occurence\\n\\nT.C=O(n);\\n\\nclass DetectSquares {\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\npublic:\\n     map<pair<int,int>, int>mp;\\n    \\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[{point[0], point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        \\n        int ans = 0;\\n        for(auto it : mp)\\n        {\\n            pair<int,int>p = it.first;\\n            //the first two condition checks coinciding points & third condition checks if its diagonal point or not\\n            if(p.first != point[0] and p.second != point[1] and (abs(point[0] - p.first) == abs(point[1] - p.second)))  \\n            { \\n                //if p is diagonal point then other points are\\n                \\n                int first = mp[{p.first, p.second}]; //diagonal\\n                int second = mp[{p.first, point[1]}];\\n                int third = mp[{point[0], p.second}];\\n                \\n                int cur = first * second * third;\\n                ans += cur;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 1472808,
                "title": "c-concise-solution-using-hashmap-with-intuition",
                "content": "Basically, the square from a point will be formed only when there is a point in a line parallel to (say x-axis). If there is one, we save the distance and if there are two more points on either side of the line and have the distance equal to what we stored, we can say that a square is formed.\\n```\\nclass DetectSquares {\\n    vector<vector<int>> x{1001};       \\n    vector<vector<int>> y{1001};  \\n    int cnt[2002][2002];\\n    \\npublic:\\n    DetectSquares() { \\n        memset(cnt,0,sizeof(cnt));\\n    }\\n    \\n    void add(vector<int> point) {\\n        x[point[0]].push_back(point[1]);\\n        y[point[1]].push_back(point[0]);\\n\\n\\t\\t//for storing the count\\n        cnt[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int xc=point[0];\\n        int yc=point[1];\\n        int ans=0;\\n        for(int ys:x[xc]){\\n            if(ys==yc)continue;\\n            int len=abs(yc-ys);\\n            int x3,x4,y3,y4;\\n\\t\\t\\t\\n\\t\\t\\t//case-1\\n            x3=xc-len;\\n            x4=x3, y3=ys, y4=yc;\\n            \\n            int a=(x3<0 or y3<0)?0:cnt[x3][y3];\\n            int b=(x4<0 or y4<0)?0:cnt[x4][y4];\\n            ans+=a*b;\\n                \\n\\t\\t\\t//case-2\\n            x3=xc+len;\\n            x4=x3, y3=ys, y4=yc;\\n\\n            a=(x3<0 or y3<0)?0:cnt[x3][y3];\\n            b=(x4<0 or y4<0)?0:cnt[x4][y4];\\n            ans+=a*b;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass DetectSquares {\\n    vector<vector<int>> x{1001};       \\n    vector<vector<int>> y{1001};  \\n    int cnt[2002][2002];\\n    \\npublic:\\n    DetectSquares() { \\n        memset(cnt,0,sizeof(cnt));\\n    }\\n    \\n    void add(vector<int> point) {\\n        x[point[0]].push_back(point[1]);\\n        y[point[1]].push_back(point[0]);\\n\\n\\t\\t//for storing the count\\n        cnt[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int xc=point[0];\\n        int yc=point[1];\\n        int ans=0;\\n        for(int ys:x[xc]){\\n            if(ys==yc)continue;\\n            int len=abs(yc-ys);\\n            int x3,x4,y3,y4;\\n\\t\\t\\t\\n\\t\\t\\t//case-1\\n            x3=xc-len;\\n            x4=x3, y3=ys, y4=yc;\\n            \\n            int a=(x3<0 or y3<0)?0:cnt[x3][y3];\\n            int b=(x4<0 or y4<0)?0:cnt[x4][y4];\\n            ans+=a*b;\\n                \\n\\t\\t\\t//case-2\\n            x3=xc+len;\\n            x4=x3, y3=ys, y4=yc;\\n\\n            a=(x3<0 or y3<0)?0:cnt[x3][y3];\\n            b=(x4<0 or y4<0)?0:cnt[x4][y4];\\n            ans+=a*b;\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472588,
                "title": "short-python-solution",
                "content": "Note that we are counting SQUARES not rectangles. So `abs(x1-x) == abs(y1-y)` is essential.\\n\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.counter = defaultdict(int)\\n\\n\\n    def add(self, point: List[int]) -> None:\\n        self.counter[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        x, y = point\\n        for (x1, y1), cnt in self.counter.items():\\n            if x1 != x and y1 != y and (x1, y) in self.counter and (x, y1) in self.counter \\\\\\n                and abs(x1-x) == abs(y1-y):\\n                res += cnt * self.counter[(x1, y)] * self.counter[(x, y1)]\\n\\n        return res\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.counter = defaultdict(int)\\n\\n\\n    def add(self, point: List[int]) -> None:\\n        self.counter[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        x, y = point\\n        for (x1, y1), cnt in self.counter.items():\\n            if x1 != x and y1 != y and (x1, y) in self.counter and (x, y1) in self.counter \\\\\\n                and abs(x1-x) == abs(y1-y):\\n                res += cnt * self.counter[(x1, y)] * self.counter[(x, y1)]\\n\\n        return res\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472086,
                "title": "python-elegant-understandable-solution",
                "content": "Upvote,\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.x = defaultdict(list)\\n        self.d = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        self.x[point[0]].append(point)\\n        self.d[tuple(point)] = self.d.get(tuple(point), 0) + 1\\n        \\n    def count(self, point: List[int]) -> int:\\n        # Get all points that lies X-axis of our point\\n        x = self.x.get(point[0])\\n        answer = 0\\n\\n        for node in x:\\n            # Cant form a square from same point\\n            if node == point:\\n                continue\\n                \\n             # Difference of our two points at Y-axis\\n\\t\\t\\t # Need to construct square\\n            diff = abs(node[1] - point[1])\\n            \\n            left, right = [point[0] - diff, node[1]], [node[0] - diff, point[1]]\\n            answer += (self.d.get(tuple(left)) * self.d.get(tuple(right), 0))\\n            \\n            left, right = [point[0] + diff, node[1]], [node[0] + diff, point[1]]\\n            answer += (self.d.get(tuple(left), 0) * self.d.get(tuple(right), 0))\\n            \\n        return answer\\n\\n    \\n\\'\\'\\'\\nwhy we are checking two left and right coordinates:\\n\\nSquare can be formed by \\n[5, 5], [10, 5], [0, 5], [0, 10]\\nand \\n[5, 5], [10, 5], [5, 10], [10, 10]\\n\\'\\'\\'\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.x = defaultdict(list)\\n        self.d = {}\\n\\n    def add(self, point: List[int]) -> None:\\n        self.x[point[0]].append(point)\\n        self.d[tuple(point)] = self.d.get(tuple(point), 0) + 1\\n        \\n    def count(self, point: List[int]) -> int:\\n        # Get all points that lies X-axis of our point\\n        x = self.x.get(point[0])\\n        answer = 0\\n\\n        for node in x:\\n            # Cant form a square from same point\\n            if node == point:\\n                continue\\n                \\n             # Difference of our two points at Y-axis\\n\\t\\t\\t # Need to construct square\\n            diff = abs(node[1] - point[1])\\n            \\n            left, right = [point[0] - diff, node[1]], [node[0] - diff, point[1]]\\n            answer += (self.d.get(tuple(left)) * self.d.get(tuple(right), 0))\\n            \\n            left, right = [point[0] + diff, node[1]], [node[0] + diff, point[1]]\\n            answer += (self.d.get(tuple(left), 0) * self.d.get(tuple(right), 0))\\n            \\n        return answer\\n\\n    \\n\\'\\'\\'\\nwhy we are checking two left and right coordinates:\\n\\nSquare can be formed by \\n[5, 5], [10, 5], [0, 5], [0, 10]\\nand \\n[5, 5], [10, 5], [5, 10], [10, 10]\\n\\'\\'\\'\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472072,
                "title": "python-counter-time-100-space-100-clean-solution",
                "content": "![image](https://assets.leetcode.com/users/images/48283af0-87e3-4fc7-ac27-d06135070021_1632026033.5955079.png)\\n\\nList is not hashable, we use tuple instead.\\n```\\nclass DetectSquares(object):\\n\\n    def __init__(self):\\n        self.points = []\\n        \\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.points.append((point[0], point[1]))\\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(self.points)\\n        count = 0\\n        counter = Counter(self.points)\\n        for i in range(n):\\n            if self.points[i][0] == point[0]:\\n                length = abs(self.points[i][1] - point[1])\\n                if length == 0:\\n                    continue\\n                if counter[(point[0] - length, point[1])] and counter[(point[0] - length, self.points[i][1])]:\\n                    count += counter[(point[0] - length, point[1])] * counter[(point[0] - length, self.points[i][1])]\\n                if counter[(point[0] + length, point[1])] and counter[(point[0] + length, self.points[i][1])]:\\n                    count += counter[(point[0] + length, point[1])] * counter[(point[0] + length, self.points[i][1])]\\n                    \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares(object):\\n\\n    def __init__(self):\\n        self.points = []\\n        \\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.points.append((point[0], point[1]))\\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(self.points)\\n        count = 0\\n        counter = Counter(self.points)\\n        for i in range(n):\\n            if self.points[i][0] == point[0]:\\n                length = abs(self.points[i][1] - point[1])\\n                if length == 0:\\n                    continue\\n                if counter[(point[0] - length, point[1])] and counter[(point[0] - length, self.points[i][1])]:\\n                    count += counter[(point[0] - length, point[1])] * counter[(point[0] - length, self.points[i][1])]\\n                if counter[(point[0] + length, point[1])] and counter[(point[0] + length, self.points[i][1])]:\\n                    count += counter[(point[0] + length, point[1])] * counter[(point[0] + length, self.points[i][1])]\\n                    \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472033,
                "title": "easy-2d-array-solution-in-c-accepted",
                "content": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> v;\\n    //x, y -> freq\\n    \\n    DetectSquares() {\\n        v.resize(1005);\\n        for (int i = 0; i < 1005; i++) {\\n            for (int j = 0; j < 1005; j++)\\n                v[i].push_back(0);\\n        }\\n    }\\n    \\n    void add(vector<int> point) {\\n        v[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        int x = point[0], y = point[1];\\n        for (int i = 0; i < 1001; i++) {\\n            if (i == x) continue;\\n            \\n            if (v[i][y] > 0) {\\n                int len = abs(i - x);\\n                if (y - len >= 0)\\n                    count += v[i][y] * v[i][y - len] * v[x][y - len];\\n\\n                if (y + len <= 1000)\\n                    count += v[i][y] * v[i][y + len] * v[x][y + len];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    vector<vector<int>> v;\\n    //x, y -> freq\\n    \\n    DetectSquares() {\\n        v.resize(1005);\\n        for (int i = 0; i < 1005; i++) {\\n            for (int j = 0; j < 1005; j++)\\n                v[i].push_back(0);\\n        }\\n    }\\n    \\n    void add(vector<int> point) {\\n        v[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int count = 0;\\n        int x = point[0], y = point[1];\\n        for (int i = 0; i < 1001; i++) {\\n            if (i == x) continue;\\n            \\n            if (v[i][y] > 0) {\\n                int len = abs(i - x);\\n                if (y - len >= 0)\\n                    count += v[i][y] * v[i][y - len] * v[x][y - len];\\n\\n                if (y + len <= 1000)\\n                    count += v[i][y] * v[i][y + len] * v[x][y + len];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472000,
                "title": "python-2d-dictionary",
                "content": "Would be even better to use two separate dictionaries for x and y coordinates and iterate over the one with fewer keys but that was making the code too long so I switched to this less optimal version.\\n\\nHere we count based on alignments on y-axis. The squares can exist to the left or right. They are simply the product of counts of points in the remaining three locations (i.e. `u1 * u2 * u3`).\\n\\n```python\\nclass DetectSquares:\\n    #initialize with a 2D dictionary\\n    def __init__(self):\\n        self.coor = dict()\\n    \\n    #add to the 2D dictionary\\n    def add(self, point):\\n        x, y = point\\n        if x in self.coor.keys():\\n            self.coor[x][y] += 1\\n        else:\\n            self.coor[x] = collections.defaultdict(int)\\n            self.coor[x][y] += 1\\n    \\n    #count left and right\\n    def count(self, point):\\n        x, y = point\\n        if x not in self.coor.keys(): \\n            return 0\\n        \\n        ans = 0\\n        for y0 in self.coor[x].keys():\\n            if y0 == y:\\n                continue\\n            side_len = abs(y - y0)\\n            #count left squares\\n            if (x - side_len) in self.coor.keys():\\n                u1 = self.coor[x][y0]\\n                u2 = self.coor[x - side_len][y] \\n                u3 = self.coor[x - side_len][y0] \\n                ans += u1 * u2 * u3\\n            #count right squares\\n            if (x + side_len) in self.coor.keys():\\n                u1 = self.coor[x][y0]\\n                u2 = self.coor[x + side_len][y] \\n                u3 = self.coor[x + side_len][y0]\\n                ans += u1 * u2 * u3\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass DetectSquares:\\n    #initialize with a 2D dictionary\\n    def __init__(self):\\n        self.coor = dict()\\n    \\n    #add to the 2D dictionary\\n    def add(self, point):\\n        x, y = point\\n        if x in self.coor.keys():\\n            self.coor[x][y] += 1\\n        else:\\n            self.coor[x] = collections.defaultdict(int)\\n            self.coor[x][y] += 1\\n    \\n    #count left and right\\n    def count(self, point):\\n        x, y = point\\n        if x not in self.coor.keys(): \\n            return 0\\n        \\n        ans = 0\\n        for y0 in self.coor[x].keys():\\n            if y0 == y:\\n                continue\\n            side_len = abs(y - y0)\\n            #count left squares\\n            if (x - side_len) in self.coor.keys():\\n                u1 = self.coor[x][y0]\\n                u2 = self.coor[x - side_len][y] \\n                u3 = self.coor[x - side_len][y0] \\n                ans += u1 * u2 * u3\\n            #count right squares\\n            if (x + side_len) in self.coor.keys():\\n                u1 = self.coor[x][y0]\\n                u2 = self.coor[x + side_len][y] \\n                u3 = self.coor[x + side_len][y0]\\n                ans += u1 * u2 * u3\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471935,
                "title": "kotlin-clean-short-o-n-solution",
                "content": "```\\nimport kotlin.math.abs\\n\\nclass DetectSquares() {\\n    // map(X, map(Y, count))\\n    private val mapXtoY = mutableMapOf<Int, MutableMap<Int, Int>>()\\n    private val mapYtoX = mutableMapOf<Int, MutableMap<Int, Int>>()\\n    \\n    fun add(point: IntArray) {\\n        mapXtoY.getOrPut(point[0], { mutableMapOf() }).let {\\n            it[point[1]] = (it[point[1]] ?: 0) + 1\\n        }\\n        mapYtoX.getOrPut(point[1], { mutableMapOf() }).let {\\n            it[point[0]] = (it[point[0]] ?: 0) + 1\\n        }\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        return mapXtoY[point[0]]?.entries?.fold(0) { acc, entryY ->\\n            acc + if (entryY.key != point[1]) {\\n                val edge = abs(entryY.key - point[1])\\n                mapYtoX[entryY.key]!!.entries.fold(0) { acc2, entryX ->\\n                    acc2 + if (entryX.key != point[0] && abs(entryX.key - point[0]) == edge) {\\n                        (mapXtoY[entryX.key]!![point[1]] ?: 0) * entryY.value * entryX.value\\n                    } else { 0 }\\n                }\\n            } else { 0 }\\n        } ?: 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.abs\\n\\nclass DetectSquares() {\\n    // map(X, map(Y, count))\\n    private val mapXtoY = mutableMapOf<Int, MutableMap<Int, Int>>()\\n    private val mapYtoX = mutableMapOf<Int, MutableMap<Int, Int>>()\\n    \\n    fun add(point: IntArray) {\\n        mapXtoY.getOrPut(point[0], { mutableMapOf() }).let {\\n            it[point[1]] = (it[point[1]] ?: 0) + 1\\n        }\\n        mapYtoX.getOrPut(point[1], { mutableMapOf() }).let {\\n            it[point[0]] = (it[point[0]] ?: 0) + 1\\n        }\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        return mapXtoY[point[0]]?.entries?.fold(0) { acc, entryY ->\\n            acc + if (entryY.key != point[1]) {\\n                val edge = abs(entryY.key - point[1])\\n                mapYtoX[entryY.key]!!.entries.fold(0) { acc2, entryX ->\\n                    acc2 + if (entryX.key != point[0] && abs(entryX.key - point[0]) == edge) {\\n                        (mapXtoY[entryX.key]!![point[1]] ?: 0) * entryY.value * entryX.value\\n                    } else { 0 }\\n                }\\n            } else { 0 }\\n        } ?: 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471931,
                "title": "java-2d-array-easy-to-understand",
                "content": "```\\nclass DetectSquares {\\n        int[][] plane;\\n        \\n    public DetectSquares() {\\n        //Initialize the plane to know the points added.\\n        plane = new int[1001][1001];\\n    }\\n    \\n    public void add(int[] point) {\\n        //Increment the value where the point is added.\\n        plane[point[0]][point[1]] += 1;\\n    }\\n    \\n    public int count(int[] point) {\\n        int count = 0;\\n        int x = point[0], y = point[1];\\n        for (int i = 0; i < 1001; i++) {\\n            //Ignore the current x value as a square is not possible\\n            if (i == x) continue;\\n            //Check if the value on the x - axis at same y - coordinate is greater than 0\\n            if (plane[i][y] > 0) {\\n                //Use the property of a square that it has equal lengths\\n                //If you found a point on the left, check for a square on both top and bottom \\n                if (i < x) {\\n                    int diff = x - i;\\n                    //Check on the left bottom side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y - diff >= 0\\n                    if (y - diff >= 0\\n                        && plane[i][y - diff] > 0\\n                        && plane[x][y - diff] > 0)\\n                        count += plane[i][y] * plane[i][y - diff] * plane[x][y - diff];\\n                    //Check on the left top side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y + diff <= 1000\\n                    if (y + diff <= 1000\\n                        && plane[i][y + diff] > 0\\n                        && plane[x][y + diff] > 0)\\n                        count += plane[i][y] * plane[i][y + diff] * plane[x][y + diff];\\n                //If you found a point on the right, check for a square on both top and bottom\\n                } else {\\n                   int diff = i - x;\\n                    //Check on the right bottom side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y - diff >= 0\\n                    if (y - diff >= 0\\n                        && plane[i][y - diff] > 0\\n                        && plane[x][y - diff] > 0)\\n                        count += plane[i][y] * plane[i][y - diff] * plane[x][y - diff];\\n                    //Check on the right top side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y + diff <= 1000\\n                    if (y + diff <= 1000\\n                        && plane[i][y + diff] > 0\\n                        && plane[x][y + diff] > 0)\\n                        count += plane[i][y] * plane[i][y + diff] * plane[x][y + diff]; \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n        int[][] plane;\\n        \\n    public DetectSquares() {\\n        //Initialize the plane to know the points added.\\n        plane = new int[1001][1001];\\n    }\\n    \\n    public void add(int[] point) {\\n        //Increment the value where the point is added.\\n        plane[point[0]][point[1]] += 1;\\n    }\\n    \\n    public int count(int[] point) {\\n        int count = 0;\\n        int x = point[0], y = point[1];\\n        for (int i = 0; i < 1001; i++) {\\n            //Ignore the current x value as a square is not possible\\n            if (i == x) continue;\\n            //Check if the value on the x - axis at same y - coordinate is greater than 0\\n            if (plane[i][y] > 0) {\\n                //Use the property of a square that it has equal lengths\\n                //If you found a point on the left, check for a square on both top and bottom \\n                if (i < x) {\\n                    int diff = x - i;\\n                    //Check on the left bottom side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y - diff >= 0\\n                    if (y - diff >= 0\\n                        && plane[i][y - diff] > 0\\n                        && plane[x][y - diff] > 0)\\n                        count += plane[i][y] * plane[i][y - diff] * plane[x][y - diff];\\n                    //Check on the left top side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y + diff <= 1000\\n                    if (y + diff <= 1000\\n                        && plane[i][y + diff] > 0\\n                        && plane[x][y + diff] > 0)\\n                        count += plane[i][y] * plane[i][y + diff] * plane[x][y + diff];\\n                //If you found a point on the right, check for a square on both top and bottom\\n                } else {\\n                   int diff = i - x;\\n                    //Check on the right bottom side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y - diff >= 0\\n                    if (y - diff >= 0\\n                        && plane[i][y - diff] > 0\\n                        && plane[x][y - diff] > 0)\\n                        count += plane[i][y] * plane[i][y - diff] * plane[x][y - diff];\\n                    //Check on the right top side of point and increment the count.\\n                    //Be careful to not to go beyond the plane i.e. y + diff <= 1000\\n                    if (y + diff <= 1000\\n                        && plane[i][y + diff] > 0\\n                        && plane[x][y + diff] > 0)\\n                        count += plane[i][y] * plane[i][y + diff] * plane[x][y + diff]; \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1471918,
                "title": "o-1-2-d-array",
                "content": "```\\nclass DetectSquares {\\n    // Array stores the count of each point so far.\\n    int[][] pc;\\n\\n    public DetectSquares() {\\n        // Since 0 <= x, y <= 1000.\\n        pc = new int[1001][1001];\\n    }\\n    \\n    public void add(int[] p) {\\n        // Add the point.\\n        pc[p[0]][p[1]]++;\\n    }\\n    \\n    public int count(int[] p) {\\n        // Stores the count of squares.\\n        int c = 0;\\n        \\n        // Traverse all 4 directions.\\n        // + , +\\n        int x=p[0]+1; int y = p[1]+1;\\n        while(x<=1000 && y <=1000) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x++; y++;\\n        }\\n        // - , +\\n        x=p[0]-1; y = p[1]-1;\\n        while(x>=0 && y >=0) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x--; y--;\\n        }\\n        // + , -\\n        x=p[0]+1; y = p[1]-1;\\n        while(x<=1000 && y >=0) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x++; y--;\\n        }\\n        // - , +\\n        x=p[0]-1; y = p[1]+1;\\n        while(x>=0 && y <=1000) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x--; y++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    // Array stores the count of each point so far.\\n    int[][] pc;\\n\\n    public DetectSquares() {\\n        // Since 0 <= x, y <= 1000.\\n        pc = new int[1001][1001];\\n    }\\n    \\n    public void add(int[] p) {\\n        // Add the point.\\n        pc[p[0]][p[1]]++;\\n    }\\n    \\n    public int count(int[] p) {\\n        // Stores the count of squares.\\n        int c = 0;\\n        \\n        // Traverse all 4 directions.\\n        // + , +\\n        int x=p[0]+1; int y = p[1]+1;\\n        while(x<=1000 && y <=1000) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x++; y++;\\n        }\\n        // - , +\\n        x=p[0]-1; y = p[1]-1;\\n        while(x>=0 && y >=0) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x--; y--;\\n        }\\n        // + , -\\n        x=p[0]+1; y = p[1]-1;\\n        while(x<=1000 && y >=0) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x++; y--;\\n        }\\n        // - , +\\n        x=p[0]-1; y = p[1]+1;\\n        while(x>=0 && y <=1000) {\\n            if(pc[x][y] > 0 && pc[p[0]][y] > 0 && pc[x][p[1]] > 0) c += pc[x][y]* pc[p[0]][y]* pc[x][p[1]];\\n            x--; y++;\\n        }\\n        \\n        return c;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 4088729,
                "title": "incorrect-test-cases-but-simple-code-passes-all-test-cases",
                "content": "# Intuition\\nFollowing is the solution that\\'s popular on the web. It\\'s straight forward -> add points to a map. Then in O(n) go through all points as potential diagonals of square and check if other two vertices exist. \\n\\nBUT THE TEST CASES ARE BUGGY! \\nTHE FOLLOWING CODE IS WRONG AFAIK - Please correct me if I\\'m wrong. [The code passes all testcases but I don\\'t think its correct].\\n\\nTake the simple example of \\n[[0,1], [1,2], [1,0]] and the queried point is [2,1].\\n\\nThis does form a square between points [0,1] and [2,1] diagonal where each size is of same length = sqrt(2) and diagonals are equal length = 2. (which is enough to prove that a quadrilateral is a square). However if you inspect the code the check we do is `(abs(dx - x) != abs(dy - y))` which doesn\\'t check for diagnoals that are parallel to x or y axis. \\n\\n\\n\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n\\n    unordered_map<string, int> m;\\n    unordered_map<string, vector<int>> k2m;\\n\\n    DetectSquares() {\\n    }\\n    \\n    string getkey(const vector<int>& p){\\n        return to_string(p[0]) + \"#\" + to_string(p[1]);\\n    }\\n\\n    void add(vector<int> point) {\\n        string k =getkey(point);\\n        k2m[k] = point;\\n        m[k] ++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int res = 0;\\n        for(auto k : k2m){\\n            auto d = k.second;\\n            int dx = d[0], dy = d[1];\\n            if((abs(dx - x) != abs(dy - y)) || (dx == x && y == dy))\\n                continue;\\n            \\n            string a =getkey({x, dy});\\n            string b = getkey({dx, y});\\n            if(m.count(a) > 0 && m.count(b) > 0){\\n                res += m[a] * m[b] * m[k.first];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n\\n    unordered_map<string, int> m;\\n    unordered_map<string, vector<int>> k2m;\\n\\n    DetectSquares() {\\n    }\\n    \\n    string getkey(const vector<int>& p){\\n        return to_string(p[0]) + \"#\" + to_string(p[1]);\\n    }\\n\\n    void add(vector<int> point) {\\n        string k =getkey(point);\\n        k2m[k] = point;\\n        m[k] ++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0], y = point[1];\\n        int res = 0;\\n        for(auto k : k2m){\\n            auto d = k.second;\\n            int dx = d[0], dy = d[1];\\n            if((abs(dx - x) != abs(dy - y)) || (dx == x && y == dy))\\n                continue;\\n            \\n            string a =getkey({x, dy});\\n            string b = getkey({dx, y});\\n            if(m.count(a) > 0 && m.count(b) > 0){\\n                res += m[a] * m[b] * m[k.first];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086284,
                "title": "says-beats-100-but-honestly-it-barely-passes-tough-problem",
                "content": "\\n# Code\\n```\\nclass DetectSquares\\n    def initialize()\\n        @points = {}\\n        @points[\"y\"] = {}\\n        @points[\"x\"] = {}\\n        @count_cache = {}\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Void\\n=end\\n    def add(point)\\n        # Add a point at hash key being y and x\\n        x = point[0]\\n        y = point[1]\\n        if !@points[\"x\"][x]\\n            @points[\"x\"][x] = []\\n        end\\n\\n        if !@points[\"y\"][y]\\n            @points[\"y\"][y] = []\\n        end\\n\\n        @points[\"x\"][x] << point\\n        @points[\"y\"][y] << point\\n\\n        # Reset count cache when a new point is added.\\n        @count_cache = {}       \\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Integer\\n=end\\n    def count(point)\\n        if @count_cache[point] \\n            return @count_cache[point] \\n        end\\n        \\n        answer = 0\\n\\n        x = point[0]\\n        y = point[1]\\n\\n        # find x possibilities\\n        x_possibilities = []\\n        if !@points[\"x\"][x]\\n            @points[\"x\"][x] = []\\n        else\\n            x_possibilities = @points[\"x\"][x]\\n        end\\n\\n        # find y possibilites\\n        y_possibilities = []\\n        if !@points[\"y\"][y]\\n            @points[\"y\"][y] = []\\n        else\\n            y_possibilities = @points[\"y\"][y]\\n        end\\n\\n        if x_possibilities.size == 0 || y_possibilities.size == 0\\n            return 0\\n        end\\n\\n        last_x_pos = nil\\n        last_x_pos_answer = 0\\n        x_possibilities.each do |x_pos|\\n            if last_x_pos\\n                if last_x_pos == x_pos and last_x_pos_answer\\n                    answer = answer + last_x_pos_answer\\n                    next\\n                end\\n            end\\n                \\n            # get distance from point to x_pos\\n            x_pos_y = x_pos[1]\\n            if y > x_pos_y\\n                dist = y - x_pos_y\\n            elsif y == x_pos_y\\n                dist = 0\\n            elsif y < x_pos_y\\n                dist = x_pos_y - y\\n            end\\n\\n            x_pos_answer = 0\\n            y_possibilities.each do |y_pos|\\n                y_pos_x = y_pos[0]\\n                x_dist = 0\\n                if x > y_pos_x\\n                    x_dist = x - y_pos_x\\n                elsif x == y_pos_x\\n                    x_dist = 0\\n                elsif x < y_pos_x\\n                    x_dist = y_pos_x - x\\n                end\\n\\n                if x_dist == dist and dist !=0\\n                    # find mirror points based on x and y possibilities\\n                    counter_hash = {}\\n                    counter_hash[\"x\"]= {}\\n                    counter_hash[\"y\"]= {}\\n                    x_s = [x, x_pos[0], y_pos[0]]\\n                    y_s = [y, x_pos[1], y_pos[1]]\\n                    x_s.each do |new_x|\\n                        if counter_hash[\"x\"][new_x]\\n                            counter_hash[\"x\"].delete new_x\\n                        else\\n                            counter_hash[\"x\"][new_x] = 1\\n                        end\\n                    end\\n                    y_s.each do |new_y|\\n                        if counter_hash[\"y\"][new_y]\\n                            counter_hash[\"y\"].delete new_y\\n                        else\\n                            counter_hash[\"y\"][new_y] = 1\\n                        end\\n                    end\\n\\n                    mirror_coordinates = [counter_hash[\"x\"].keys[0], counter_hash[\"y\"].keys[0]]\\n\\n                    exist = @points[\"x\"][mirror_coordinates[0]].select{|p| p[1] == mirror_coordinates[1]}\\n\\n                    x_pos_answer = x_pos_answer + exist.size\\n                end\\n            end\\n\\n            last_x_pos = x_pos\\n            last_x_pos_answer = x_pos_answer\\n            answer = answer + x_pos_answer\\n        end \\n\\n        @count_cache[point] = answer\\n        return answer\\n    end\\nend\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares.new()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass DetectSquares\\n    def initialize()\\n        @points = {}\\n        @points[\"y\"] = {}\\n        @points[\"x\"] = {}\\n        @count_cache = {}\\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Void\\n=end\\n    def add(point)\\n        # Add a point at hash key being y and x\\n        x = point[0]\\n        y = point[1]\\n        if !@points[\"x\"][x]\\n            @points[\"x\"][x] = []\\n        end\\n\\n        if !@points[\"y\"][y]\\n            @points[\"y\"][y] = []\\n        end\\n\\n        @points[\"x\"][x] << point\\n        @points[\"y\"][y] << point\\n\\n        # Reset count cache when a new point is added.\\n        @count_cache = {}       \\n    end\\n\\n\\n=begin\\n    :type point: Integer[]\\n    :rtype: Integer\\n=end\\n    def count(point)\\n        if @count_cache[point] \\n            return @count_cache[point] \\n        end\\n        \\n        answer = 0\\n\\n        x = point[0]\\n        y = point[1]\\n\\n        # find x possibilities\\n        x_possibilities = []\\n        if !@points[\"x\"][x]\\n            @points[\"x\"][x] = []\\n        else\\n            x_possibilities = @points[\"x\"][x]\\n        end\\n\\n        # find y possibilites\\n        y_possibilities = []\\n        if !@points[\"y\"][y]\\n            @points[\"y\"][y] = []\\n        else\\n            y_possibilities = @points[\"y\"][y]\\n        end\\n\\n        if x_possibilities.size == 0 || y_possibilities.size == 0\\n            return 0\\n        end\\n\\n        last_x_pos = nil\\n        last_x_pos_answer = 0\\n        x_possibilities.each do |x_pos|\\n            if last_x_pos\\n                if last_x_pos == x_pos and last_x_pos_answer\\n                    answer = answer + last_x_pos_answer\\n                    next\\n                end\\n            end\\n                \\n            # get distance from point to x_pos\\n            x_pos_y = x_pos[1]\\n            if y > x_pos_y\\n                dist = y - x_pos_y\\n            elsif y == x_pos_y\\n                dist = 0\\n            elsif y < x_pos_y\\n                dist = x_pos_y - y\\n            end\\n\\n            x_pos_answer = 0\\n            y_possibilities.each do |y_pos|\\n                y_pos_x = y_pos[0]\\n                x_dist = 0\\n                if x > y_pos_x\\n                    x_dist = x - y_pos_x\\n                elsif x == y_pos_x\\n                    x_dist = 0\\n                elsif x < y_pos_x\\n                    x_dist = y_pos_x - x\\n                end\\n\\n                if x_dist == dist and dist !=0\\n                    # find mirror points based on x and y possibilities\\n                    counter_hash = {}\\n                    counter_hash[\"x\"]= {}\\n                    counter_hash[\"y\"]= {}\\n                    x_s = [x, x_pos[0], y_pos[0]]\\n                    y_s = [y, x_pos[1], y_pos[1]]\\n                    x_s.each do |new_x|\\n                        if counter_hash[\"x\"][new_x]\\n                            counter_hash[\"x\"].delete new_x\\n                        else\\n                            counter_hash[\"x\"][new_x] = 1\\n                        end\\n                    end\\n                    y_s.each do |new_y|\\n                        if counter_hash[\"y\"][new_y]\\n                            counter_hash[\"y\"].delete new_y\\n                        else\\n                            counter_hash[\"y\"][new_y] = 1\\n                        end\\n                    end\\n\\n                    mirror_coordinates = [counter_hash[\"x\"].keys[0], counter_hash[\"y\"].keys[0]]\\n\\n                    exist = @points[\"x\"][mirror_coordinates[0]].select{|p| p[1] == mirror_coordinates[1]}\\n\\n                    x_pos_answer = x_pos_answer + exist.size\\n                end\\n            end\\n\\n            last_x_pos = x_pos\\n            last_x_pos_answer = x_pos_answer\\n            answer = answer + x_pos_answer\\n        end \\n\\n        @count_cache[point] = answer\\n        return answer\\n    end\\nend\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares.new()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4084595,
                "title": "2013-detect-squares",
                "content": "# Code\\n```\\nclass DetectSquares {\\n\\n    Map<String,Integer> x;\\n    List<int[]> coordinates;\\n\\n    public DetectSquares() {\\n    x = new HashMap<>();\\n    coordinates = new ArrayList<>();\\n    }\\n    \\n    public void add(int[] point) {\\n    coordinates.add(point);\\n    String key = point[0] + \"@\" + point[1];\\n    x.put(key, x.getOrDefault(key,0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n    int count = 0, pointX = point[0], pointY = point[1];\\n    for(int[] c: coordinates){\\n        int x1 = c[0], y= c[1];\\n        if(pointX==x1 || pointY==y || (Math.abs(pointX - x1) != Math.abs(pointY - y))){\\n            continue;\\n        }\\n            count += x.getOrDefault(x1 + \"@\" + pointY,0) * x.getOrDefault(pointX+\"@\"+y,0);\\n    }\\n    return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass DetectSquares {\\n\\n    Map<String,Integer> x;\\n    List<int[]> coordinates;\\n\\n    public DetectSquares() {\\n    x = new HashMap<>();\\n    coordinates = new ArrayList<>();\\n    }\\n    \\n    public void add(int[] point) {\\n    coordinates.add(point);\\n    String key = point[0] + \"@\" + point[1];\\n    x.put(key, x.getOrDefault(key,0)+1);\\n    }\\n    \\n    public int count(int[] point) {\\n    int count = 0, pointX = point[0], pointY = point[1];\\n    for(int[] c: coordinates){\\n        int x1 = c[0], y= c[1];\\n        if(pointX==x1 || pointY==y || (Math.abs(pointX - x1) != Math.abs(pointY - y))){\\n            continue;\\n        }\\n            count += x.getOrDefault(x1 + \"@\" + pointY,0) * x.getOrDefault(pointX+\"@\"+y,0);\\n    }\\n    return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076543,
                "title": "kotlin-runtime-faster-than-96-30-memory-usage-less-than-88-89",
                "content": "![image](https://assets.leetcode.com/users/images/1a1c276f-e24c-42e6-8b39-168fe945db72_1695384409.0003273.png)\\n\\nSolution based on this video https://www.youtube.com/watch?v=bahebearrDc **with minor modification to use only a map.**\\n\\n```\\ndata class Point(\\n    val x: Int,\\n    val y: Int,\\n)\\n\\nclass DetectSquares() {\\n    val pointsCounter = mutableMapOf<Point, Int>()\\n\\n    fun add(point: IntArray) {\\n        pointsCounter[Point(point[0], point[1])] = pointsCounter.getOrDefault(Point(point[0], point[1]), 0) + 1\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var result = 0\\n        pointsCounter.keys.forEach { diagonalPoint ->\\n            val xDiff = abs(diagonalPoint.x - point[0])\\n            if (xDiff != 0 &&\\n                xDiff == abs(diagonalPoint.y - point[1]) &&\\n                pointsCounter.contains(Point(point[0], diagonalPoint.y)) &&\\n                pointsCounter.contains(Point(diagonalPoint.x, point[1]))\\n            ) {\\n                result += (\\n                        pointsCounter.getOrDefault(Point(point[0], diagonalPoint.y), 0) *\\n                                pointsCounter.getOrDefault(Point(diagonalPoint.x, point[1]), 0) *\\n                                pointsCounter.getOrDefault(diagonalPoint, 0)\\n                        )\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\nThe above solution was the submitted one (optmized). \\nSharing another version with more readable code, incorporating additional variables.\\n\\n```\\nprivate data class Point(\\n    val x: Int,\\n    val y: Int,\\n)\\n\\nprivate class DetectSquares() {\\n    val pointsCounter = mutableMapOf<Point, Int>()\\n\\n    fun add(point: IntArray) {\\n        val pointToAdd = Point(point[0], point[1])\\n        pointsCounter[pointToAdd] = pointsCounter.getOrDefault(pointToAdd, 0) + 1\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var result = 0\\n        pointsCounter.keys.forEach { diagonalPoint ->\\n            val xDiff = abs(diagonalPoint.x - point[0])\\n            val yDiff = abs(diagonalPoint.y - point[1])\\n\\n            val pointWithSameX = Point(point[0], diagonalPoint.y)\\n            val pointWithSameY = Point(diagonalPoint.x, point[1])\\n            val pointWithSameXCount = pointsCounter.getOrDefault(pointWithSameX, 0)\\n            val pointWithSameYCount = pointsCounter.getOrDefault(pointWithSameY, 0)\\n            val diagonalPointCount = pointsCounter.getOrDefault(diagonalPoint, 0)\\n\\n            if (xDiff != 0 && xDiff == yDiff &&\\n                pointsCounter.contains(pointWithSameX) && pointsCounter.contains(pointWithSameY)\\n            ) {\\n                result += (pointWithSameXCount * pointWithSameYCount * diagonalPointCount)\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\ndata class Point(\\n    val x: Int,\\n    val y: Int,\\n)\\n\\nclass DetectSquares() {\\n    val pointsCounter = mutableMapOf<Point, Int>()\\n\\n    fun add(point: IntArray) {\\n        pointsCounter[Point(point[0], point[1])] = pointsCounter.getOrDefault(Point(point[0], point[1]), 0) + 1\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var result = 0\\n        pointsCounter.keys.forEach { diagonalPoint ->\\n            val xDiff = abs(diagonalPoint.x - point[0])\\n            if (xDiff != 0 &&\\n                xDiff == abs(diagonalPoint.y - point[1]) &&\\n                pointsCounter.contains(Point(point[0], diagonalPoint.y)) &&\\n                pointsCounter.contains(Point(diagonalPoint.x, point[1]))\\n            ) {\\n                result += (\\n                        pointsCounter.getOrDefault(Point(point[0], diagonalPoint.y), 0) *\\n                                pointsCounter.getOrDefault(Point(diagonalPoint.x, point[1]), 0) *\\n                                pointsCounter.getOrDefault(diagonalPoint, 0)\\n                        )\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```\\nprivate data class Point(\\n    val x: Int,\\n    val y: Int,\\n)\\n\\nprivate class DetectSquares() {\\n    val pointsCounter = mutableMapOf<Point, Int>()\\n\\n    fun add(point: IntArray) {\\n        val pointToAdd = Point(point[0], point[1])\\n        pointsCounter[pointToAdd] = pointsCounter.getOrDefault(pointToAdd, 0) + 1\\n    }\\n\\n    fun count(point: IntArray): Int {\\n        var result = 0\\n        pointsCounter.keys.forEach { diagonalPoint ->\\n            val xDiff = abs(diagonalPoint.x - point[0])\\n            val yDiff = abs(diagonalPoint.y - point[1])\\n\\n            val pointWithSameX = Point(point[0], diagonalPoint.y)\\n            val pointWithSameY = Point(diagonalPoint.x, point[1])\\n            val pointWithSameXCount = pointsCounter.getOrDefault(pointWithSameX, 0)\\n            val pointWithSameYCount = pointsCounter.getOrDefault(pointWithSameY, 0)\\n            val diagonalPointCount = pointsCounter.getOrDefault(diagonalPoint, 0)\\n\\n            if (xDiff != 0 && xDiff == yDiff &&\\n                pointsCounter.contains(pointWithSameX) && pointsCounter.contains(pointWithSameY)\\n            ) {\\n                result += (pointWithSameXCount * pointWithSameYCount * diagonalPointCount)\\n            }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003826,
                "title": "simple-and-easy-solution-using-defaultdict",
                "content": "\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        from collections import defaultdict\\n        self.square= defaultdict(int)\\n        self.ptcnt =[]\\n\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.square[tuple(point)] += 1\\n        self.ptcnt.append(point)\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        res= 0 \\n\\n        a,b = point\\n\\n        for i, j in self.ptcnt:\\n            if abs(a-i) != abs(b-j) or a==i or b==j:\\n                continue\\n\\n            res += self.square[(i,b)] * self.square[(a,j)]\\n\\n        return res        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        from collections import defaultdict\\n        self.square= defaultdict(int)\\n        self.ptcnt =[]\\n\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.square[tuple(point)] += 1\\n        self.ptcnt.append(point)\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        res= 0 \\n\\n        a,b = point\\n\\n        for i, j in self.ptcnt:\\n            if abs(a-i) != abs(b-j) or a==i or b==j:\\n                continue\\n\\n            res += self.square[(i,b)] * self.square[(a,j)]\\n\\n        return res        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958444,
                "title": "easy-solution-with-hashmap-runtime-beats-87-97-memory-92-7",
                "content": "# Intuition\\nIt\\'s comfortable to use HashMap to store <Point, int> values where int - number of points with the same x and y, Point - simple class with  fields x and y. Also, we need to define equals() and hashCode() to store points properly in the Map.\\n\\n# Approach\\nadd() method:\\n - we add point to hashmap and update count.\\n\\ncount() method:\\n - we go through all points from the hashmap and check 2 moments:\\n      1. They have equal distnace between x and y coordinates to make diagonal of square.\\n      2. They are not equal because we are allowed to count squares only with positive area.\\n - if we have this point in hashmap, we need to check if we have 2 points with appropriate coordinates to make a square:\\n \\n![image.png](https://assets.leetcode.com/users/images/7da9d4ce-2e14-41c9-aa81-db87ac737c88_1692965951.3181722.png)\\n - Than we update res variable by multiplying number of occurences of three dots.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n    public class Point {\\n        int x;\\n        int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public int getX() {\\n            return x;\\n        }\\n\\n        public void setX(int x) {\\n            this.x = x;\\n        }\\n\\n        public int getY() {\\n            return y;\\n        }\\n\\n        public void setY(int y) {\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    class DetectSquares {\\n        Map<Point, Integer> points;\\n\\n        public DetectSquares() {\\n            this.points = new HashMap<>();\\n        }\\n\\n        public void add(int[] point) {\\n            Point nextPoint = new Point(point[0], point[1]);\\n            if (!points.containsKey(nextPoint)) {\\n                points.put(nextPoint, 0);\\n            }\\n            points.put(nextPoint, points.get(nextPoint) + 1);\\n        }\\n\\n        public int count(int[] point) {\\n            int res = 0;\\n            Point queryPoint = new Point(point[0], point[1]);\\n            for (Point dot : points.keySet()) {\\n                if (Math.abs(queryPoint.getX() - dot.getX()) == Math.abs(queryPoint.getY() - dot.getY()) && !queryPoint.equals(dot)) {\\n                    Point dot1 = new Point(queryPoint.getX(), dot.getY());\\n                    Point dot2 = new Point(dot.getX(), queryPoint.getY());\\n                    if (points.containsKey(dot1) && points.containsKey(dot2)) {\\n                        res += points.get(dot1) * points.get(dot2) * points.get(dot);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public class Point {\\n        int x;\\n        int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public int getX() {\\n            return x;\\n        }\\n\\n        public void setX(int x) {\\n            this.x = x;\\n        }\\n\\n        public int getY() {\\n            return y;\\n        }\\n\\n        public void setY(int y) {\\n            this.y = y;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Point point = (Point) o;\\n            return x == point.x && y == point.y;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(x, y);\\n        }\\n\\n        @Override\\n        public String toString() {\\n            return \"Point{\" +\\n                    \"x=\" + x +\\n                    \", y=\" + y +\\n                    \\'}\\';\\n        }\\n    }\\n\\n    class DetectSquares {\\n        Map<Point, Integer> points;\\n\\n        public DetectSquares() {\\n            this.points = new HashMap<>();\\n        }\\n\\n        public void add(int[] point) {\\n            Point nextPoint = new Point(point[0], point[1]);\\n            if (!points.containsKey(nextPoint)) {\\n                points.put(nextPoint, 0);\\n            }\\n            points.put(nextPoint, points.get(nextPoint) + 1);\\n        }\\n\\n        public int count(int[] point) {\\n            int res = 0;\\n            Point queryPoint = new Point(point[0], point[1]);\\n            for (Point dot : points.keySet()) {\\n                if (Math.abs(queryPoint.getX() - dot.getX()) == Math.abs(queryPoint.getY() - dot.getY()) && !queryPoint.equals(dot)) {\\n                    Point dot1 = new Point(queryPoint.getX(), dot.getY());\\n                    Point dot2 = new Point(dot.getX(), queryPoint.getY());\\n                    if (points.containsKey(dot1) && points.containsKey(dot2)) {\\n                        res += points.get(dot1) * points.get(dot2) * points.get(dot);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919983,
                "title": "hashmap-unordered-map-c-solution",
                "content": "# Code\\n```\\nstruct PointHash {\\n    size_t operator() (const vector<int> a) const {\\n        return a[0] ^ a[1];\\n    }\\n};\\n\\nclass DetectSquares {\\npublic:\\n    unordered_map<vector<int>, int, PointHash> pCount;\\n    unordered_map<int, unordered_set<vector<int>, PointHash>> yPoints;\\n\\n    DetectSquares() {}\\n\\n    void add(vector<int> point) {\\n        pCount[point]++;\\n        yPoints[point[1]].insert(point);\\n    }\\n\\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (vector<int> t1 : yPoints[point[1]]) { // Look for all y-equal point (t1), where dx != 0\\n            int dim = abs(point[0] - t1[0]);\\n            if (dim == 0) continue;\\n            if (pCount.count({ t1[0], t1[1] + dim })) { // Look for point above t1 (b1)\\n                vector<int> b1 = { t1[0], t1[1] + dim };\\n                if (pCount.count({point[0], point[1] + dim})) { // Look for point above p (b2)\\n                    vector<int> b2 = { point[0], point[1] + dim };\\n                    ans += pCount[t1] * pCount[b1] * pCount[b2];\\n                }\\n            }\\n            if (pCount.count({ t1[0], t1[1] - dim })) { // Look below\\n                vector<int> b1 = { t1[0], t1[1] - dim };\\n                if (pCount.count({ point[0], point[1] - dim })) {\\n                    vector<int> b2 = { point[0], point[1] - dim };\\n                    ans += pCount[t1] * pCount[b1] * pCount[b2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct PointHash {\\n    size_t operator() (const vector<int> a) const {\\n        return a[0] ^ a[1];\\n    }\\n};\\n\\nclass DetectSquares {\\npublic:\\n    unordered_map<vector<int>, int, PointHash> pCount;\\n    unordered_map<int, unordered_set<vector<int>, PointHash>> yPoints;\\n\\n    DetectSquares() {}\\n\\n    void add(vector<int> point) {\\n        pCount[point]++;\\n        yPoints[point[1]].insert(point);\\n    }\\n\\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (vector<int> t1 : yPoints[point[1]]) { // Look for all y-equal point (t1), where dx != 0\\n            int dim = abs(point[0] - t1[0]);\\n            if (dim == 0) continue;\\n            if (pCount.count({ t1[0], t1[1] + dim })) { // Look for point above t1 (b1)\\n                vector<int> b1 = { t1[0], t1[1] + dim };\\n                if (pCount.count({point[0], point[1] + dim})) { // Look for point above p (b2)\\n                    vector<int> b2 = { point[0], point[1] + dim };\\n                    ans += pCount[t1] * pCount[b1] * pCount[b2];\\n                }\\n            }\\n            if (pCount.count({ t1[0], t1[1] - dim })) { // Look below\\n                vector<int> b1 = { t1[0], t1[1] - dim };\\n                if (pCount.count({ point[0], point[1] - dim })) {\\n                    vector<int> b2 = { point[0], point[1] - dim };\\n                    ans += pCount[t1] * pCount[b1] * pCount[b2];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3904220,
                "title": "array-of-unordered-maps-only-scanning-points-with-same-x-axis",
                "content": "# Approach\\nScan points with same axis and find other 2 points geometrically.\\n\\n# Code\\n```\\nclass DetectSquares {\\n    array<unordered_map<int, int>, 1001> x;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        ++x[point[0]][point[1]];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (const auto& [y, v] : x[point[0]]) {\\n            if (y == point[1]) continue;\\n            int s = abs(point[1] - y);\\n            int x1 = point[0] + s;\\n            int x2 = point[0] - s;\\n            if (x1 >= 0 && x1 <= 1000 && x[x1].contains(point[1]) && x[x1].contains(y)) {\\n                ans += x[x1][point[1]] * x[x1][y] * v;\\n            }\\n            if (x2 >= 0 && x2 <= 1000 && x[x2].contains(point[1]) && x[x2].contains(y)) {\\n                ans += x[x2][point[1]] * x[x2][y] * v;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass DetectSquares {\\n    array<unordered_map<int, int>, 1001> x;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        ++x[point[0]][point[1]];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (const auto& [y, v] : x[point[0]]) {\\n            if (y == point[1]) continue;\\n            int s = abs(point[1] - y);\\n            int x1 = point[0] + s;\\n            int x2 = point[0] - s;\\n            if (x1 >= 0 && x1 <= 1000 && x[x1].contains(point[1]) && x[x1].contains(y)) {\\n                ans += x[x1][point[1]] * x[x1][y] * v;\\n            }\\n            if (x2 >= 0 && x2 <= 1000 && x[x2].contains(point[1]) && x[x2].contains(y)) {\\n                ans += x[x2][point[1]] * x[x2][y] * v;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3887710,
                "title": "c-solutionn-with-explaination",
                "content": "\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[point[0]][point[1]]++;\\n    }\\n    \\n    // 1. Loop Through all the points\\n    // 2. If (p,q) formas diagonal with any of the points, then we found a square\\n    int count(vector<int> point) {\\n        int p=point[0];\\n        int q=point[1];\\n\\n        int ans=0;\\n        for(auto v1: mp){\\n            int x=v1.first;\\n            for(auto v2:v1.second){\\n                int y=v2.first;\\n                \\n                // 3. Skip if the point (p,q) is in the same x or y axis as (x,y)\\n                if(p==x || q==y) continue;\\n                \\n                // 4. Counting the frequency of other 3 points in the square besides (p,q)\\n                //    Check if the distance between (p,q) and (x,y) is equal in both dimensions (forms a diagonal)\\n                if(abs(x-p)==abs(y-q)) ans+= mp[x][y] * mp[x][q] * mp[p][y];\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    // {x, {y, count}} \\n    unordered_map<int, unordered_map<int, int>> mp;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        mp[point[0]][point[1]]++;\\n    }\\n    \\n    // 1. Loop Through all the points\\n    // 2. If (p,q) formas diagonal with any of the points, then we found a square\\n    int count(vector<int> point) {\\n        int p=point[0];\\n        int q=point[1];\\n\\n        int ans=0;\\n        for(auto v1: mp){\\n            int x=v1.first;\\n            for(auto v2:v1.second){\\n                int y=v2.first;\\n                \\n                // 3. Skip if the point (p,q) is in the same x or y axis as (x,y)\\n                if(p==x || q==y) continue;\\n                \\n                // 4. Counting the frequency of other 3 points in the square besides (p,q)\\n                //    Check if the distance between (p,q) and (x,y) is equal in both dimensions (forms a diagonal)\\n                if(abs(x-p)==abs(y-q)) ans+= mp[x][y] * mp[x][q] * mp[p][y];\\n            }\\n        }\\n        return ans;\\n    }\\n\\nprivate:\\n    // {x, {y, count}} \\n    unordered_map<int, unordered_map<int, int>> mp;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835555,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        \\n        int result = 0;\\n        \\n        for (auto x = points.begin(); x != points.end(); x++) {\\n            unordered_map<int, int> yPoints = x->second;\\n            for (auto y = yPoints.begin(); y != yPoints.end(); y++) {\\n                int x3 = x->first;\\n                int y3 = y->first;\\n                \\n                // skip points on same x-axis or y-axis\\n                if (abs(x3 - x1) == 0 || abs(x3 - x1) != abs(y3 - y1)) {\\n                    continue;\\n                }\\n                \\n                result += points[x3][y3] * points[x1][y3] * points[x3][y1];\\n            }\\n        }\\n        \\n        return result;\\n    }\\nprivate:\\n    // {x -> {y -> count}}\\n    unordered_map<int, unordered_map<int, int>> points;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points[point[0]][point[1]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        \\n        int result = 0;\\n        \\n        for (auto x = points.begin(); x != points.end(); x++) {\\n            unordered_map<int, int> yPoints = x->second;\\n            for (auto y = yPoints.begin(); y != yPoints.end(); y++) {\\n                int x3 = x->first;\\n                int y3 = y->first;\\n                \\n                // skip points on same x-axis or y-axis\\n                if (abs(x3 - x1) == 0 || abs(x3 - x1) != abs(y3 - y1)) {\\n                    continue;\\n                }\\n                \\n                result += points[x3][y3] * points[x1][y3] * points[x3][y1];\\n            }\\n        }\\n        \\n        return result;\\n    }\\nprivate:\\n    // {x -> {y -> count}}\\n    unordered_map<int, unordered_map<int, int>> points;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3829170,
                "title": "python-3-math-problem",
                "content": "# Intuition\\nCheck if four points can form a square\\n# Approach\\nMath\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[(point[0], point[1])] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        \\n        sameCol = set()\\n        px, py = point\\n        ans: int = 0\\n\\n        for x, y in self.points:\\n            if px == x:\\n                sameCol.add((x, y))\\n\\n        for x, y in sameCol:\\n\\n            if x == px and y == py:\\n                continue\\n\\n            times: int = self.points[(x, y)]\\n            distance: int = abs(py - y)\\n            if (x - distance, y) in self.points and (x - distance, py) in self.points:\\n                ans += times * self.points[(x - distance, y)] * self.points[(x - distance, py)]\\n            if (x + distance, y) in self.points and (x + distance, py) in self.points:\\n                ans += times * self.points[(x + distance, y)] * self.points[(x + distance, py)]\\n\\n        return ans\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        self.points[(point[0], point[1])] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        \\n        sameCol = set()\\n        px, py = point\\n        ans: int = 0\\n\\n        for x, y in self.points:\\n            if px == x:\\n                sameCol.add((x, y))\\n\\n        for x, y in sameCol:\\n\\n            if x == px and y == py:\\n                continue\\n\\n            times: int = self.points[(x, y)]\\n            distance: int = abs(py - y)\\n            if (x - distance, y) in self.points and (x - distance, py) in self.points:\\n                ans += times * self.points[(x - distance, y)] * self.points[(x - distance, py)]\\n            if (x + distance, y) in self.points and (x + distance, py) in self.points:\\n                ans += times * self.points[(x + distance, y)] * self.points[(x + distance, py)]\\n\\n        return ans\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757000,
                "title": "javascript-clean-and-descriptive-time-o-n-space-o-n",
                "content": "```js\\n/*\\n * Hash Map\\n * Array\\n * Time O(N) | Space O(N)\\n * https://leetcode.com/problems/detect-squares \\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\nclass DetectSquares {\\n    constructor () {\\n        this.map = new Map();/* Space O(N) */\\n        this.points = [];    /* Space O(N) */\\n    }\\n    \\n    add (point, { map, points } = this) {\\n        const [ x, y ] = point;\\n        const key = this.getKey(x, y);\\n        const value = ((map.get(key) ?? 0) + 1);\\n\\n        map.set(key, value);/* Space O(N) */\\n        points.push(point); /* Space O(N) */\\n    }\\n\\n    count (point, { points } = this, score = 0) {\\n        const [ x1, y1 ] = point;\\n\\n        for (const [ x2, y2 ] of points) {/* Time O(N) */\\n            const isSame = (Math.abs(x2 - x1) === Math.abs(y2 - y1));\\n            const isEqual = ((x1 === x2) || (y1 === y2));\\n            const canSkip = (!isSame || isEqual);\\n            if (canSkip) continue;\\n\\n            score += this.getScore(x1, y1, x2, y2);\\n        }\\n\\n        return score;\\n    };\\n\\n    getKey (x, y) {\\n        return `${x},${y}`;\\n    }\\n\\n    getScore (x1, y1, x2, y2, { map } = this) {\\n        const [ aKey, bKey ] = [ this.getKey(x1, y2), this.getKey(x2, y1) ];\\n        const [ aScore, bScore ] = [ (map.get(aKey) ?? 0), (map.get(bKey) ?? 0) ];\\n    \\n        return (aScore * bScore);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/*\\n * Hash Map\\n * Array\\n * Time O(N) | Space O(N)\\n * https://leetcode.com/problems/detect-squares \\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\nclass DetectSquares {\\n    constructor () {\\n        this.map = new Map();/* Space O(N) */\\n        this.points = [];    /* Space O(N) */\\n    }\\n    \\n    add (point, { map, points } = this) {\\n        const [ x, y ] = point;\\n        const key = this.getKey(x, y);\\n        const value = ((map.get(key) ?? 0) + 1);\\n\\n        map.set(key, value);/* Space O(N) */\\n        points.push(point); /* Space O(N) */\\n    }\\n\\n    count (point, { points } = this, score = 0) {\\n        const [ x1, y1 ] = point;\\n\\n        for (const [ x2, y2 ] of points) {/* Time O(N) */\\n            const isSame = (Math.abs(x2 - x1) === Math.abs(y2 - y1));\\n            const isEqual = ((x1 === x2) || (y1 === y2));\\n            const canSkip = (!isSame || isEqual);\\n            if (canSkip) continue;\\n\\n            score += this.getScore(x1, y1, x2, y2);\\n        }\\n\\n        return score;\\n    };\\n\\n    getKey (x, y) {\\n        return `${x},${y}`;\\n    }\\n\\n    getScore (x1, y1, x2, y2, { map } = this) {\\n        const [ aKey, bKey ] = [ this.getKey(x1, y2), this.getKey(x2, y1) ];\\n        const [ aScore, bScore ] = [ (map.get(aKey) ?? 0), (map.get(bKey) ?? 0) ];\\n    \\n        return (aScore * bScore);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3670020,
                "title": "java-oop-friendly-solution",
                "content": "# Approach\\n1. Store data for the points in a map, where the end value is the count of the points in the same coordinates\\n\\n2. Whenever a square check is asked, find all points in the X axis, check the length for each of them between the searched point. Find if there are two points in the same distance as the calculated length.\\n\\n3. If there is 2 found points, then multiply the count of the 2 found + the one in the X axis, because each point is treated as different one and thus there can be multiple combinations.\\n\\n# Code\\n```\\n class Point {\\n        int x;\\n        int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public  boolean isAbove(Point point) {\\n            return this.y > point.y;\\n        }\\n\\n        public  boolean isBelow(Point point) {\\n            return this.y < point.y;\\n        }\\n    }\\n\\n     class DetectSquares {\\n\\n        private Map<Integer, Map<Integer, Integer>> xYCount;\\n\\n        public DetectSquares() {\\n            this.xYCount = new HashMap<>();\\n        }\\n\\n        public void add(int[] point) {\\n            Point pointObject = new Point(point[0], point[1]);\\n            this.add(pointObject);\\n        }\\n\\n        public void add(Point point) {\\n            if (!this.xYCount.containsKey(point.x))\\n                this.xYCount.put(point.x, new HashMap<>());\\n\\n            if (!this.xYCount.get(point.x).containsKey(point.y))\\n                this.xYCount.get(point.x).put(point.y, 1);\\n            else\\n                this.xYCount.get(point.x).put(point.y, this.xYCount.get(point.x).get(point.y) + 1);\\n        }\\n\\n        public int count(int[] point) {\\n            Point searchPoint = new Point(point[0], point[1]);\\n\\n            if (!this.xYCount.containsKey(searchPoint.x))\\n                return 0;\\n\\n            Map<Integer, Integer> pointsInXAxis = this.xYCount.get(searchPoint.x);\\n\\n            int count = 0;\\n            for (Map.Entry<Integer, Integer> pointInXAxis : pointsInXAxis.entrySet()) {\\n                Point foundPoint = new Point(searchPoint.x, pointInXAxis.getKey());\\n\\n                if (foundPoint.isAbove(searchPoint))\\n                    count += this.getCountAbove(searchPoint, foundPoint);\\n\\n                if (foundPoint.isBelow(searchPoint))\\n                    count += this.getCountBelow(searchPoint, foundPoint);\\n            }\\n\\n            return count;\\n        }\\n\\n        private int getCountAbove(Point search, Point above) {\\n            int length = above.y - search.y;\\n            int count = 0;\\n\\n            Point rightP1 = new Point(search.x + length, above.y);\\n            Point rightP2 = new Point(search.x + length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(rightP1, rightP2, new Point(above.x, above.y));\\n\\n            Point leftP1 = new Point(search.x - length, above.y);\\n            Point leftP2 = new Point(search.x - length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(leftP1, leftP2, new Point(above.x, above.y));\\n\\n            return count;\\n        }\\n\\n        private int getCountBelow(Point search, Point below) {\\n            int length = search.y - below.y;\\n            int count = 0;\\n\\n            Point rightP1 = new Point(search.x + length, below.y);\\n            Point rightP2 = new Point(search.x + length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(rightP1, rightP2, new Point(below.x, below.y));\\n\\n            Point leftP1 = new Point(search.x - length, search.y);\\n            Point leftP2 = new Point(search.x - length, below.y);\\n\\n            count += this.getThreePointsSquaresCount(leftP1, leftP2, new Point(below.x, below.y));\\n\\n            return count;\\n        }\\n\\n        private int getThreePointsSquaresCount(Point p1, Point p2, Point p3) {\\n\\n            if (!this.isPointPresent(p1, p2, p3))\\n                return 0;\\n\\n            return this.getPointsCount(p1) * this.getPointsCount(p2) * this.getPointsCount(p3);\\n        }\\n\\n        private int getPointsCount(Point point) {\\n            return this.xYCount.get(point.x).get(point.y);\\n        }\\n\\n        private boolean isPointPresent(Point... points) {\\n\\n            for (Point point : points) {\\n\\n                if (!this.xYCount.containsKey(point.x))\\n                    return false;\\n\\n                if (!this.xYCount.get(point.x).containsKey(point.y))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Point {\\n        int x;\\n        int y;\\n\\n        public Point(int x, int y) {\\n            this.x = x;\\n            this.y = y;\\n        }\\n\\n        public  boolean isAbove(Point point) {\\n            return this.y > point.y;\\n        }\\n\\n        public  boolean isBelow(Point point) {\\n            return this.y < point.y;\\n        }\\n    }\\n\\n     class DetectSquares {\\n\\n        private Map<Integer, Map<Integer, Integer>> xYCount;\\n\\n        public DetectSquares() {\\n            this.xYCount = new HashMap<>();\\n        }\\n\\n        public void add(int[] point) {\\n            Point pointObject = new Point(point[0], point[1]);\\n            this.add(pointObject);\\n        }\\n\\n        public void add(Point point) {\\n            if (!this.xYCount.containsKey(point.x))\\n                this.xYCount.put(point.x, new HashMap<>());\\n\\n            if (!this.xYCount.get(point.x).containsKey(point.y))\\n                this.xYCount.get(point.x).put(point.y, 1);\\n            else\\n                this.xYCount.get(point.x).put(point.y, this.xYCount.get(point.x).get(point.y) + 1);\\n        }\\n\\n        public int count(int[] point) {\\n            Point searchPoint = new Point(point[0], point[1]);\\n\\n            if (!this.xYCount.containsKey(searchPoint.x))\\n                return 0;\\n\\n            Map<Integer, Integer> pointsInXAxis = this.xYCount.get(searchPoint.x);\\n\\n            int count = 0;\\n            for (Map.Entry<Integer, Integer> pointInXAxis : pointsInXAxis.entrySet()) {\\n                Point foundPoint = new Point(searchPoint.x, pointInXAxis.getKey());\\n\\n                if (foundPoint.isAbove(searchPoint))\\n                    count += this.getCountAbove(searchPoint, foundPoint);\\n\\n                if (foundPoint.isBelow(searchPoint))\\n                    count += this.getCountBelow(searchPoint, foundPoint);\\n            }\\n\\n            return count;\\n        }\\n\\n        private int getCountAbove(Point search, Point above) {\\n            int length = above.y - search.y;\\n            int count = 0;\\n\\n            Point rightP1 = new Point(search.x + length, above.y);\\n            Point rightP2 = new Point(search.x + length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(rightP1, rightP2, new Point(above.x, above.y));\\n\\n            Point leftP1 = new Point(search.x - length, above.y);\\n            Point leftP2 = new Point(search.x - length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(leftP1, leftP2, new Point(above.x, above.y));\\n\\n            return count;\\n        }\\n\\n        private int getCountBelow(Point search, Point below) {\\n            int length = search.y - below.y;\\n            int count = 0;\\n\\n            Point rightP1 = new Point(search.x + length, below.y);\\n            Point rightP2 = new Point(search.x + length, search.y);\\n\\n            count += this.getThreePointsSquaresCount(rightP1, rightP2, new Point(below.x, below.y));\\n\\n            Point leftP1 = new Point(search.x - length, search.y);\\n            Point leftP2 = new Point(search.x - length, below.y);\\n\\n            count += this.getThreePointsSquaresCount(leftP1, leftP2, new Point(below.x, below.y));\\n\\n            return count;\\n        }\\n\\n        private int getThreePointsSquaresCount(Point p1, Point p2, Point p3) {\\n\\n            if (!this.isPointPresent(p1, p2, p3))\\n                return 0;\\n\\n            return this.getPointsCount(p1) * this.getPointsCount(p2) * this.getPointsCount(p3);\\n        }\\n\\n        private int getPointsCount(Point point) {\\n            return this.xYCount.get(point.x).get(point.y);\\n        }\\n\\n        private boolean isPointPresent(Point... points) {\\n\\n            for (Point point : points) {\\n\\n                if (!this.xYCount.containsKey(point.x))\\n                    return false;\\n\\n                if (!this.xYCount.get(point.x).containsKey(point.y))\\n                    return false;\\n            }\\n\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658608,
                "title": "python-beats-99-5-simple-elegant-o-n-solution-defaultdict-of-defaultdict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nInstead of storing points as tuples in a map or using both an x and y map, store points within defaultdict of x values mapped to defaultdict of y values.\\n\\n---\\n\\n\\n![Screen Shot 2023-06-19 at 3.42.03 PM.png](https://assets.leetcode.com/users/images/7f3a89da-c855-4b5b-bbed-49d505c9c9e5_1687203747.6406536.png)\\n<!-- Describe your approach to solving the problem. -->\\n\\n---\\n\\n\\n# Add:\\nCreate a defaultdict of defaultdicts where the first defaultdict maps x values of added points to defauldicts which map the corresponding y values of added points with the x value to the frequency of the point (x, y).\\n\\ni.e.\\n1. P = {}\\n2. Add (1, 1) - P = {1: {1: 1}}\\n2. Add (2, 1) - P = {1: {1: 1}, 2: {1: 1}}\\n3. Add (1, 4) - P = {1: {1: 1, 4: 1}, 2: {1: 1}}\\n4. Add (1, 1) - P = {1: {1: 2, 4: 1}, 2: {1: 1}}\\n\\n---\\n\\n\\n## Count:\\nGiven point (x, y), count squares by iterating through possible values for the other x value in the square *\"x2\"* in P[y].\\n\\nThen, the other y value in the square *\"y2\"* must be either $$(y + (x2 - x2)$$ or $$y - (x2 - x))$$.\\nThen if x and x2 exist in P[y2], that means that we can form the square:\\n$$(x, y), (x, y2), (x2, y), (x2, y2)$$\\n\\nHowever, we need to account for duplicate squares formed by duplicate points:\\n\\nSince each of the three points besides the input (x, y) can have duplicates, the total number of possible squares formed is the product of the number of points at $$(x2, y), (x2, y2), (x, y2)$$.\\n\\nThus, for each possible set of valid points we find, we add P[y][x2] * P[y2][x2] * P[x][y2] to res and return.\\n\\n# Complexity\\nNotice that we never have to loop through all added points, only the points that have the same y value as the input!\\n- Time complexity: Worst Case: **O(N)**, Average Case: **O(\\u221An)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.P = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.P[point[0]][point[1]] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        c = 0\\n        for y2 in self.P[x]:\\n            if y2 != y:\\n                t = 0\\n                for x2 in (x + y2 - y, x + y - y2):\\n                    if x2 in self.P and y in self.P[x2] and y2 in self.P[x2]:\\n                        t += self.P[x2][y] * self.P[x2][y2]\\n                c += t * self.P[x][y2]\\n        return c\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.P = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.P[point[0]][point[1]] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        c = 0\\n        for y2 in self.P[x]:\\n            if y2 != y:\\n                t = 0\\n                for x2 in (x + y2 - y, x + y - y2):\\n                    if x2 in self.P and y in self.P[x2] and y2 in self.P[x2]:\\n                        t += self.P[x2][y] * self.P[x2][y2]\\n                c += t * self.P[x][y2]\\n        return c\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653520,
                "title": "java-solution-90",
                "content": "\\n```\\nclass DetectSquares {\\n    public int[][] matrix; // SC: Max O(1001x1001) => O(1)\\n    public Map<Integer, HashSet<Integer>> dict; // SC: Max O(1001x1001) => O(1) // we use this to store the points present per line, so that we don\\'t have to traverse the entore matrix when searching\\'\\n\\n    public DetectSquares() {\\n        matrix = new int[1001][1001];\\n        dict = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) { // O(1)\\n        matrix[point[0]][point[1]]++;\\n        HashSet<Integer> points = dict.getOrDefault(point[0], new HashSet<Integer>());\\n        points.add(point[1]);\\n        dict.put(point[0], points);\\n    }\\n    \\n    public int count(int[] point) {\\n        int row = point[0];\\n        int col = point[1];\\n        int sum = 0;\\n\\n        // O(n*n), but limited to 1001*1001 => O(1)\\n        if(dict.containsKey(row)) {\\n            HashSet<Integer> points = dict.get(row);\\n            for(int newCol: points) {\\n                if(matrix[row][newCol] > 0) {\\n                    int distance = col - newCol;\\n                    int newRow = row - distance;\\n                    if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)){\\n                        sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n                    }\\n                    newRow = row + distance;\\n                    if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)) {\\n                        sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Previous version traversing the matrix each time\\n        // for(int newCol = 0; newCol < 1001; newCol++) {\\n        //     if(matrix[row][newCol] > 0) {\\n        //         int distance = col - newCol;\\n        //         int newRow = row - distance;\\n        //         if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)){\\n        //             sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n        //         }\\n        //         newRow = row + distance;\\n        //         if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)) {\\n        //             sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n        //         }\\n        //     }\\n        // }\\n\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    public int[][] matrix; // SC: Max O(1001x1001) => O(1)\\n    public Map<Integer, HashSet<Integer>> dict; // SC: Max O(1001x1001) => O(1) // we use this to store the points present per line, so that we don\\'t have to traverse the entore matrix when searching\\'\\n\\n    public DetectSquares() {\\n        matrix = new int[1001][1001];\\n        dict = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) { // O(1)\\n        matrix[point[0]][point[1]]++;\\n        HashSet<Integer> points = dict.getOrDefault(point[0], new HashSet<Integer>());\\n        points.add(point[1]);\\n        dict.put(point[0], points);\\n    }\\n    \\n    public int count(int[] point) {\\n        int row = point[0];\\n        int col = point[1];\\n        int sum = 0;\\n\\n        // O(n*n), but limited to 1001*1001 => O(1)\\n        if(dict.containsKey(row)) {\\n            HashSet<Integer> points = dict.get(row);\\n            for(int newCol: points) {\\n                if(matrix[row][newCol] > 0) {\\n                    int distance = col - newCol;\\n                    int newRow = row - distance;\\n                    if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)){\\n                        sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n                    }\\n                    newRow = row + distance;\\n                    if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)) {\\n                        sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Previous version traversing the matrix each time\\n        // for(int newCol = 0; newCol < 1001; newCol++) {\\n        //     if(matrix[row][newCol] > 0) {\\n        //         int distance = col - newCol;\\n        //         int newRow = row - distance;\\n        //         if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)){\\n        //             sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n        //         }\\n        //         newRow = row + distance;\\n        //         if(newRow >= 0 && newRow < 1001 && !(newRow == row && newCol == col)) {\\n        //             sum = sum + matrix[row][newCol] * matrix[newRow][col] * matrix[newRow][newCol];\\n        //         }\\n        //     }\\n        // }\\n\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649707,
                "title": "java-using-hashmap",
                "content": "\\n# Code\\n```\\nclass DetectSquares {\\n    // (x, (y, count))\\n    Map<Integer, Map<Integer, Integer>> map;\\n\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        map.putIfAbsent(x, new HashMap<>());\\n        Map<Integer, Integer> mapY = map.get(x);\\n        mapY.put(y, mapY.getOrDefault(y, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        if (!map.containsKey(x))\\n            return 0;\\n        Map<Integer, Integer> mapY = map.get(x);\\n        int res = 0;\\n        for (int py: mapY.keySet()) {\\n            if (py == y)\\n                continue;\\n            int len = Math.abs(y-py);\\n            if (map.containsKey(x+len) && map.get(x+len).containsKey(y) && map.get(x+len).containsKey(py))\\n                res += mapY.get(py) * map.get(x+len).get(y) * map.get(x+len).get(py);\\n            if (map.containsKey(x-len) && map.get(x-len).containsKey(y) && map.get(x-len).containsKey(py))\\n                res += mapY.get(py) * map.get(x-len).get(y) * map.get(x-len).get(py);\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    // (x, (y, count))\\n    Map<Integer, Map<Integer, Integer>> map;\\n\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        map.putIfAbsent(x, new HashMap<>());\\n        Map<Integer, Integer> mapY = map.get(x);\\n        mapY.put(y, mapY.getOrDefault(y, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0];\\n        int y = point[1];\\n        if (!map.containsKey(x))\\n            return 0;\\n        Map<Integer, Integer> mapY = map.get(x);\\n        int res = 0;\\n        for (int py: mapY.keySet()) {\\n            if (py == y)\\n                continue;\\n            int len = Math.abs(y-py);\\n            if (map.containsKey(x+len) && map.get(x+len).containsKey(y) && map.get(x+len).containsKey(py))\\n                res += mapY.get(py) * map.get(x+len).get(y) * map.get(x+len).get(py);\\n            if (map.containsKey(x-len) && map.get(x-len).containsKey(y) && map.get(x-len).containsKey(py))\\n                res += mapY.get(py) * map.get(x-len).get(y) * map.get(x-len).get(py);\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613869,
                "title": "c",
                "content": "Time complexity: add() - O(1), count() - O(n). Space complexity: O(n)\\n\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]][point[1]]++;\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (auto i : dots[x]) {\\n            int y_i = i.first;\\n            int len = abs(y_i - y);\\n            if (len) {\\n                cnt += dots[x][y_i] * dots[x - len][y_i] * dots[x - len][y];\\n                cnt += dots[x][y_i] * dots[x + len][y_i] * dots[x + len][y];\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> dots;\\n};\\n```\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {      \\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]].insert(point[1]);\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        unordered_set<int> done;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : dots[x]) {\\n            if (done.count(i) || (i == y)) {\\n                continue;\\n            }\\n            int len = abs(i - y);\\n            cnt += dots[x].count(i) * dots[x - len].count(i) * dots[x - len].count(y);\\n            cnt += dots[x].count(i) * dots[x + len].count(i) * dots[x + len].count(y);\\n            done.insert(i);\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> dots;\\n};\\n```\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {        \\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]].insert(point[1]);\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : dots[x]) {\\n            if (i != y) {\\n                int len = abs(i - y);\\n                cnt += dots[x - len].count(i) * dots[x - len].count(y);\\n                cnt += dots[x + len].count(i) * dots[x + len].count(y);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> dots;\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]][point[1]]++;\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (auto i : dots[x]) {\\n            int y_i = i.first;\\n            int len = abs(y_i - y);\\n            if (len) {\\n                cnt += dots[x][y_i] * dots[x - len][y_i] * dots[x - len][y];\\n                cnt += dots[x][y_i] * dots[x + len][y_i] * dots[x + len][y];\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_map<int, int>> dots;\\n};\\n```\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {      \\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]].insert(point[1]);\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        unordered_set<int> done;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : dots[x]) {\\n            if (done.count(i) || (i == y)) {\\n                continue;\\n            }\\n            int len = abs(i - y);\\n            cnt += dots[x].count(i) * dots[x - len].count(i) * dots[x - len].count(y);\\n            cnt += dots[x].count(i) * dots[x + len].count(i) * dots[x + len].count(y);\\n            done.insert(i);\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> dots;\\n};\\n```\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {        \\n    }\\n    \\n    void add(vector<int> point) {\\n        dots[point[0]].insert(point[1]);\\n    }\\n\\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        int x = point[0];\\n        int y = point[1];\\n        for (int i : dots[x]) {\\n            if (i != y) {\\n                int len = abs(i - y);\\n                cnt += dots[x - len].count(i) * dots[x - len].count(y);\\n                cnt += dots[x + len].count(i) * dots[x + len].count(y);\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n\\nprivate:\\n    unordered_map<int, unordered_multiset<int>> dots;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3583881,
                "title": "100-beating-time-complexity-using-the-little-bit-of-geometry-not-traversing-all-points",
                "content": "# Intuition\\nI realized, using the geometry knowledge and constraints in problem will make it easier.\\nFor any point when added, we\\'ll add it once, then we\\'ll increase the counter.\\nFor any query point, we\\'ll find all points for same x, for these 2 points, we\\'ll find squares left side and right side.\\n\\n# Approach\\nadd: save all points in a plain object. `points[x][y] = count of this same point`\\ncount: find other y values for given x, for each of these points, find distance, if distance is positive find other two points at -d side and +d side, multiply occurances of all 3 points.\\n\\n# Complexity\\n- Time complexity:\\nWorst case time complexity - O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DetectSquares {\\n    points:{[k:number]:{[k:number]:number}}\\n    constructor() {\\n        this.points = {}\\n    }\\n\\n    add(point: number[]): void {\\n        const [x,y] = point\\n        this.points[x] = this.points[x] || {}\\n        this.points[x][y] = this.points[x][y] || 0\\n        this.points[x][y]++\\n    }\\n\\n    count(point: number[]): number {\\n        let [gx,gy] = point\\n        let otherYs = this.points[gx]\\n        if(!otherYs) return 0\\n        let s=0\\n        for(let ey in otherYs){\\n            let d = Math.abs(Number(ey)-gy)\\n            if(d<=0) continue\\n            // find left side square\\n            if(this.points[gx-d]?.[ey] && this.points[gx-d]?.[gy]) {\\n               s+=  this.points[gx-d][ey]*this.points[gx-d][gy]*this.points[gx][ey]\\n            }\\n            // find right side square\\n            if(this.points[gx+d]?.[ey] && this.points[gx+d]?.[gy]) {\\n               s+=  this.points[gx+d][ey]*this.points[gx+d][gy]*this.points[gx][ey]\\n            }\\n        }\\n        return s\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\n```\\n\\n---\\n## Reminder for reader: drink water! correct you posture! and UPVOTE! :)",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Design",
                    "Geometry"
                ],
                "code": "```\\nclass DetectSquares {\\n    points:{[k:number]:{[k:number]:number}}\\n    constructor() {\\n        this.points = {}\\n    }\\n\\n    add(point: number[]): void {\\n        const [x,y] = point\\n        this.points[x] = this.points[x] || {}\\n        this.points[x][y] = this.points[x][y] || 0\\n        this.points[x][y]++\\n    }\\n\\n    count(point: number[]): number {\\n        let [gx,gy] = point\\n        let otherYs = this.points[gx]\\n        if(!otherYs) return 0\\n        let s=0\\n        for(let ey in otherYs){\\n            let d = Math.abs(Number(ey)-gy)\\n            if(d<=0) continue\\n            // find left side square\\n            if(this.points[gx-d]?.[ey] && this.points[gx-d]?.[gy]) {\\n               s+=  this.points[gx-d][ey]*this.points[gx-d][gy]*this.points[gx][ey]\\n            }\\n            // find right side square\\n            if(this.points[gx+d]?.[ey] && this.points[gx+d]?.[gy]) {\\n               s+=  this.points[gx+d][ey]*this.points[gx+d][gy]*this.points[gx][ey]\\n            }\\n        }\\n        return s\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578930,
                "title": "simple-and-elegant-python-code-beats-90-w-r-t-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor a given point, check if there exists other points at the same x-coordinate.\\nIf so iterate over each of them. `abs(y_coordinate - y)` will give you the breadth of the square.\\n\\ncheck if there are any point to the left, and right of the given point at breadth distance. If so, finally check the diagonal point. \\n\\n# Complexity\\n- Time complexity:\\nadd -> O(1)\\ncount -> O(N). N -> Number of point at a given y coordinate\\n\\n- Space complexity:\\nO(Total number of points)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        self.x_coordinates = defaultdict(dict)\\n        self.y_coordinates = defaultdict(dict)\\n\\n    def add(self, point) -> None:\\n        x, y = point\\n        self.points[(x, y)] += 1\\n\\n        if x not in self.x_coordinates[y]:\\n            self.x_coordinates[y][x] = 0\\n        self.x_coordinates[y][x] += 1\\n\\n        if y not in self.y_coordinates[x]:\\n            self.y_coordinates[x][y] = 0\\n        self.y_coordinates[x][y] += 1\\n\\n    def count(self, point):\\n        ans = 0\\n        x, y = point\\n        \\n        x_coordinates = self.x_coordinates[y]\\n        \\n        for y_coordinate, y_count in self.y_coordinates[x].items():\\n            breadth = abs(y_coordinate - y)\\n\\n            if (x - breadth) in x_coordinates:\\n                x_coordinate, x_count = x - breadth, x_coordinates[x - breadth]\\n                if (x_coordinate, y_coordinate) in self.points and (x_coordinate, y_coordinate) != (x, y):\\n                    ans +=  (x_count * y_count * self.points[(x_coordinate, y_coordinate)])\\n\\n            if (x + breadth) in x_coordinates:\\n                x_coordinate, x_count = x + breadth, x_coordinates[x + breadth]\\n                if (x_coordinate, y_coordinate) in self.points and (x_coordinate, y_coordinate) != (x, y):\\n                    ans +=  (x_count * y_count * self.points[(x_coordinate, y_coordinate)])\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        self.x_coordinates = defaultdict(dict)\\n        self.y_coordinates = defaultdict(dict)\\n\\n    def add(self, point) -> None:\\n        x, y = point\\n        self.points[(x, y)] += 1\\n\\n        if x not in self.x_coordinates[y]:\\n            self.x_coordinates[y][x] = 0\\n        self.x_coordinates[y][x] += 1\\n\\n        if y not in self.y_coordinates[x]:\\n            self.y_coordinates[x][y] = 0\\n        self.y_coordinates[x][y] += 1\\n\\n    def count(self, point):\\n        ans = 0\\n        x, y = point\\n        \\n        x_coordinates = self.x_coordinates[y]\\n        \\n        for y_coordinate, y_count in self.y_coordinates[x].items():\\n            breadth = abs(y_coordinate - y)\\n\\n            if (x - breadth) in x_coordinates:\\n                x_coordinate, x_count = x - breadth, x_coordinates[x - breadth]\\n                if (x_coordinate, y_coordinate) in self.points and (x_coordinate, y_coordinate) != (x, y):\\n                    ans +=  (x_count * y_count * self.points[(x_coordinate, y_coordinate)])\\n\\n            if (x + breadth) in x_coordinates:\\n                x_coordinate, x_count = x + breadth, x_coordinates[x + breadth]\\n                if (x_coordinate, y_coordinate) in self.points and (x_coordinate, y_coordinate) != (x, y):\\n                    ans +=  (x_count * y_count * self.points[(x_coordinate, y_coordinate)])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532454,
                "title": "where-am-i-going-wrong-here",
                "content": "I\\'m getting an error about defaultdict not being callable..I\\'m struggling to understand where I\\'m going wrong here. \\n\\n# Code\\n```\\nclass DetectSquares(object):\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.count[tuple(point)] += 1         \\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        x2,y2 = point \\n        total = 0\\n        for (x,y), count in self.count.items():\\n            #since it\\'s a square, the difference between the two x points and two y point should be the same. \\n            if abs(x-x2) != abs(y-y2):\\n                continue \\n            #it\\'s not a square if either point is overlapping with the other\\n            if x == x2 or y == y2:\\n                continue\\n            total += self.count[(x,y2)] * self.count[(x2,y)] * count \\n        return total \\n\\n```\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass DetectSquares(object):\\n    def __init__(self):\\n        self.count = defaultdict(int)\\n\\n    def add(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: None\\n        \"\"\"\\n        self.count[tuple(point)] += 1         \\n\\n    def count(self, point):\\n        \"\"\"\\n        :type point: List[int]\\n        :rtype: int\\n        \"\"\"\\n        x2,y2 = point \\n        total = 0\\n        for (x,y), count in self.count.items():\\n            #since it\\'s a square, the difference between the two x points and two y point should be the same. \\n            if abs(x-x2) != abs(y-y2):\\n                continue \\n            #it\\'s not a square if either point is overlapping with the other\\n            if x == x2 or y == y2:\\n                continue\\n            total += self.count[(x,y2)] * self.count[(x2,y)] * count \\n        return total \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493808,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.pointsCount = defaultdict(int)\\n        self.pointsList = []\\n\\n    def add(self, point: List[int]) -> None:\\n        self.pointsCount[tuple(point)] += 1\\n        self.pointsList.append(point)\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        px, py = point\\n\\n        for (x, y) in self.pointsList:\\n            if abs(x-px) != abs(y-py) or px == x or py == y:\\n                continue\\n            res += self.pointsCount[(x,py)] * self.pointsCount[(px,y)]\\n\\n        return res \\n\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.pointsCount = defaultdict(int)\\n        self.pointsList = []\\n\\n    def add(self, point: List[int]) -> None:\\n        self.pointsCount[tuple(point)] += 1\\n        self.pointsList.append(point)\\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        px, py = point\\n\\n        for (x, y) in self.pointsList:\\n            if abs(x-px) != abs(y-py) or px == x or py == y:\\n                continue\\n            res += self.pointsCount[(x,py)] * self.pointsCount[(px,y)]\\n\\n        return res \\n\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478519,
                "title": "c-two-hashmap-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass DetectSquares {\\n    std::unordered_map<int, std::unordered_map<int, int>> row_map;\\n    std::unordered_map<int, std::unordered_map<int, int>> col_map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        row_map[point[0]][point[1]]++;\\n        col_map[point[1]][point[0]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (auto [col, cnt] : row_map[point[0]]) {\\n            if (col == point[1]) continue;\\n            for (auto [row, cnt1] : col_map[point[1]]) {\\n                if (row == point[0] || abs(row - point[0]) != abs(col - point[1])) continue;\\n                ans += (cnt * cnt1 * row_map[row][col]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\n    std::unordered_map<int, std::unordered_map<int, int>> row_map;\\n    std::unordered_map<int, std::unordered_map<int, int>> col_map;\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        row_map[point[0]][point[1]]++;\\n        col_map[point[1]][point[0]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int ans = 0;\\n        for (auto [col, cnt] : row_map[point[0]]) {\\n            if (col == point[1]) continue;\\n            for (auto [row, cnt1] : col_map[point[1]]) {\\n                if (row == point[0] || abs(row - point[0]) != abs(col - point[1])) continue;\\n                ans += (cnt * cnt1 * row_map[row][col]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428552,
                "title": "my-solutions",
                "content": "**Solution I**\\n```\\nclass DetectSquares {\\n private:\\n  using point_t = vector<int>;\\n\\n  class Hash {\\n   public:\\n    size_t operator()(const point_t &point) const noexcept {\\n      constexpr size_t magic = 0x9e3779b9;\\n      size_t ret = 0U;\\n      for (const int coordinate : point) {\\n        ret ^= magic + coordinate + (ret << 6) + (ret >> 2);\\n      }\\n      return ret;\\n    }\\n  };\\n\\n public:\\n  DetectSquares() {\\n  }\\n\\n  void add(const vector<int> &point) {\\n    if (++point_to_count_[point] == 1) {\\n      x_to_ys_[point.front()].emplace_back(point.back());\\n    }\\n  }\\n\\n  int count(const vector<int> &point) {\\n    const int x = point.front();\\n    const int y = point.back();\\n    auto itr_x = x_to_ys_.find(x);\\n    if (itr_x == x_to_ys_.end()) {\\n      return 0;\\n    }\\n\\n    int ret = 0;\\n    for (const int another_y : itr_x->second) {\\n      if (another_y == y) {\\n        continue;\\n      }\\n\\n      const int side_length = abs(another_y - y);\\n      ret += get_count({\\n        point_t{x, another_y},\\n        point_t{x - side_length, y},\\n        point_t{x - side_length, another_y}\\n      });\\n      ret += get_count({\\n        point_t{x, another_y},\\n        point_t{x + side_length, y},\\n        point_t{x + side_length, another_y}\\n      });\\n    }\\n    return ret;\\n  }\\n\\n private:\\n  int get_count(const vector<point_t> &points) {\\n    int ret = 1;\\n    for (const point_t &point : points) {\\n      auto itr = point_to_count_.find(point);\\n      if (itr == point_to_count_.end()) {\\n        ret = 0;\\n        break;\\n      }\\n      ret *= itr->second;\\n    }\\n    return ret;\\n  }\\n\\n  unordered_map<int, vector<int>> x_to_ys_;\\n  unordered_map<point_t, int, Hash> point_to_count_;\\n};\\n```\\n**Solution II**\\n```\\nclass DetectSquares {\\n public:\\n  DetectSquares() {\\n  }\\n\\n  void add(const vector<int> &point) {\\n    ++x_to_y_to_count_[point.front()][point.back()];\\n  }\\n\\n  int count(const vector<int> &point) {\\n    const int x1 = point.front();\\n    const int y1 = point.back();\\n    auto itr_x1 = x_to_y_to_count_.find(x1);\\n    if (itr_x1 == x_to_y_to_count_.end()) {\\n      return 0;\\n    }\\n    \\n    int ret = 0;\\n    const unordered_map<int, int> &y_to_count = itr_x1->second;\\n    for (const auto [y2, count] : y_to_count) {\\n      if (y1 == y2) {\\n        continue;\\n      }\\n      \\n      const int side_length = abs(y1 - y2);\\n      ret += get_count(count, x1 - side_length, y1, y2);\\n      ret += get_count(count, x1 + side_length, y1, y2);\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_count(const int count, const int x2, const int y1, const int y2) {\\n    int ret = count;\\n    auto itr_x = x_to_y_to_count_.find(x2);\\n    if (itr_x == x_to_y_to_count_.end()) {\\n      return 0;\\n    }\\n    \\n    const unordered_map<int, int> &y_to_count = itr_x->second;\\n    for (const int y : {y1, y2}) {\\n      auto itr_xy = y_to_count.find(y);\\n      if (itr_xy == y_to_count.end()) {\\n        return 0;\\n      }\\n      ret *= itr_xy->second;\\n    }\\n    return ret;\\n  }\\n  \\n  unordered_map<int, unordered_map<int, int>> x_to_y_to_count_;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\n private:\\n  using point_t = vector<int>;\\n\\n  class Hash {\\n   public:\\n    size_t operator()(const point_t &point) const noexcept {\\n      constexpr size_t magic = 0x9e3779b9;\\n      size_t ret = 0U;\\n      for (const int coordinate : point) {\\n        ret ^= magic + coordinate + (ret << 6) + (ret >> 2);\\n      }\\n      return ret;\\n    }\\n  };\\n\\n public:\\n  DetectSquares() {\\n  }\\n\\n  void add(const vector<int> &point) {\\n    if (++point_to_count_[point] == 1) {\\n      x_to_ys_[point.front()].emplace_back(point.back());\\n    }\\n  }\\n\\n  int count(const vector<int> &point) {\\n    const int x = point.front();\\n    const int y = point.back();\\n    auto itr_x = x_to_ys_.find(x);\\n    if (itr_x == x_to_ys_.end()) {\\n      return 0;\\n    }\\n\\n    int ret = 0;\\n    for (const int another_y : itr_x->second) {\\n      if (another_y == y) {\\n        continue;\\n      }\\n\\n      const int side_length = abs(another_y - y);\\n      ret += get_count({\\n        point_t{x, another_y},\\n        point_t{x - side_length, y},\\n        point_t{x - side_length, another_y}\\n      });\\n      ret += get_count({\\n        point_t{x, another_y},\\n        point_t{x + side_length, y},\\n        point_t{x + side_length, another_y}\\n      });\\n    }\\n    return ret;\\n  }\\n\\n private:\\n  int get_count(const vector<point_t> &points) {\\n    int ret = 1;\\n    for (const point_t &point : points) {\\n      auto itr = point_to_count_.find(point);\\n      if (itr == point_to_count_.end()) {\\n        ret = 0;\\n        break;\\n      }\\n      ret *= itr->second;\\n    }\\n    return ret;\\n  }\\n\\n  unordered_map<int, vector<int>> x_to_ys_;\\n  unordered_map<point_t, int, Hash> point_to_count_;\\n};\\n```\n```\\nclass DetectSquares {\\n public:\\n  DetectSquares() {\\n  }\\n\\n  void add(const vector<int> &point) {\\n    ++x_to_y_to_count_[point.front()][point.back()];\\n  }\\n\\n  int count(const vector<int> &point) {\\n    const int x1 = point.front();\\n    const int y1 = point.back();\\n    auto itr_x1 = x_to_y_to_count_.find(x1);\\n    if (itr_x1 == x_to_y_to_count_.end()) {\\n      return 0;\\n    }\\n    \\n    int ret = 0;\\n    const unordered_map<int, int> &y_to_count = itr_x1->second;\\n    for (const auto [y2, count] : y_to_count) {\\n      if (y1 == y2) {\\n        continue;\\n      }\\n      \\n      const int side_length = abs(y1 - y2);\\n      ret += get_count(count, x1 - side_length, y1, y2);\\n      ret += get_count(count, x1 + side_length, y1, y2);\\n    }\\n    return ret;\\n  }\\n  \\n private:\\n  int get_count(const int count, const int x2, const int y1, const int y2) {\\n    int ret = count;\\n    auto itr_x = x_to_y_to_count_.find(x2);\\n    if (itr_x == x_to_y_to_count_.end()) {\\n      return 0;\\n    }\\n    \\n    const unordered_map<int, int> &y_to_count = itr_x->second;\\n    for (const int y : {y1, y2}) {\\n      auto itr_xy = y_to_count.find(y);\\n      if (itr_xy == y_to_count.end()) {\\n        return 0;\\n      }\\n      ret *= itr_xy->second;\\n    }\\n    return ret;\\n  }\\n  \\n  unordered_map<int, unordered_map<int, int>> x_to_y_to_count_;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3419665,
                "title": "ts-book-solution-using-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Self Solution, after book consultation, Time Complexity: O(n), Space Complexity: O(n)(for storing the data)\\nclass DetectSquares {\\n    public map: Map<string, number>;\\n    public points: number[][];\\n    constructor() {\\n        this.map = new Map();\\n        this.points = [];\\n    }\\n\\n    add(point: number[]): void {\\n        const key: string = this.getKey(point[0], point[1]);\\n        const count: number = 1 + (this.map.get(key) || 0);\\n        this.map.set(key, count);\\n        this.points.push(point);\\n    }\\n\\n    count(point: number[]): number {\\n        let count: number = 0;\\n\\n\\n        // Second solution without using extra space of points array\\n        // for ( const key of this.map.keys() ) {\\n        //     let [x, y] = [Number(key.split(\\',\\')[0]), Number(key.split(\\',\\')[1])];\\n        //     if ( !(Math.abs(x - point[0]) === Math.abs(y - point[1])) || x === point[0] || y === point[1] ) continue;\\n        //     const key1 = this.getKey(x, point[1]);\\n        //     const key2 = this.getKey(point[0], y);\\n        //     count += this.map.get(key) * ((this.map.get(key1) || 0) * (this.map.get(key2) || 0));\\n        // }\\n\\n\\n        for ( const [x, y] of this.points ) {\\n            if ( !(Math.abs(x - point[0]) === Math.abs(y - point[1])) || x === point[0] || y === point[1] ) continue;\\n            const key1 = this.getKey(x, point[1]);\\n            const key2 = this.getKey(point[0], y);\\n            count += ((this.map.get(key1) || 0) * (this.map.get(key2) || 0));\\n        }\\n        return count;\\n    }\\n\\n    getKey(x: number, y: number): string {\\n        return x + \\',\\' + y;\\n    }\\n}\\n\\n// Book Solution, Same as self solution, since self was after book consultation\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Self Solution, after book consultation, Time Complexity: O(n), Space Complexity: O(n)(for storing the data)\\nclass DetectSquares {\\n    public map: Map<string, number>;\\n    public points: number[][];\\n    constructor() {\\n        this.map = new Map();\\n        this.points = [];\\n    }\\n\\n    add(point: number[]): void {\\n        const key: string = this.getKey(point[0], point[1]);\\n        const count: number = 1 + (this.map.get(key) || 0);\\n        this.map.set(key, count);\\n        this.points.push(point);\\n    }\\n\\n    count(point: number[]): number {\\n        let count: number = 0;\\n\\n\\n        // Second solution without using extra space of points array\\n        // for ( const key of this.map.keys() ) {\\n        //     let [x, y] = [Number(key.split(\\',\\')[0]), Number(key.split(\\',\\')[1])];\\n        //     if ( !(Math.abs(x - point[0]) === Math.abs(y - point[1])) || x === point[0] || y === point[1] ) continue;\\n        //     const key1 = this.getKey(x, point[1]);\\n        //     const key2 = this.getKey(point[0], y);\\n        //     count += this.map.get(key) * ((this.map.get(key1) || 0) * (this.map.get(key2) || 0));\\n        // }\\n\\n\\n        for ( const [x, y] of this.points ) {\\n            if ( !(Math.abs(x - point[0]) === Math.abs(y - point[1])) || x === point[0] || y === point[1] ) continue;\\n            const key1 = this.getKey(x, point[1]);\\n            const key2 = this.getKey(point[0], y);\\n            count += ((this.map.get(key1) || 0) * (this.map.get(key2) || 0));\\n        }\\n        return count;\\n    }\\n\\n    getKey(x: number, y: number): string {\\n        return x + \\',\\' + y;\\n    }\\n}\\n\\n// Book Solution, Same as self solution, since self was after book consultation\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * var obj = new DetectSquares()\\n * obj.add(point)\\n * var param_2 = obj.count(point)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416862,
                "title": "java-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\n    private Map<String, Integer> mMap;\\n    public DetectSquares() {\\n        mMap = new HashMap<>();\\n    }\\n    public void add(int[] point) {\\n        String key = hash(point);\\n        mMap.put(key, mMap.getOrDefault(key, 0) + 1);\\n    }\\n    public int count(int[] point) {\\n        int mul = 1;\\n        if (mMap.containsKey(point)) {\\n            mul =  mMap.get(hash(point)) + 1;\\n        }\\n        int count = 0;\\n        for (String key: mMap.keySet()) {\\n            if (point[0] == x(key)) {\\n                int distance = Math.abs(point[1] - y(key));\\n                int[] rightPoint = new int[]{point[0] + distance, point[1]};\\n                int[] leftPoint = new int[]{point[0] - distance, point[1]};\\n                if (mMap.containsKey(hash(rightPoint))) {\\n                    if (point[1] < y(key)) {\\n                        int[] topRight = new int[]{point[0] + distance, point[1] + distance};\\n                        if (mMap.containsKey(hash(topRight))) {\\n                            count += mul * mMap.get(hash(rightPoint)) * mMap.get(key) * mMap.get(hash(topRight));\\n                        }\\n                    } else if (point[1] > y(key)) {\\n                        int[] bottomRight = new int[]{point[0] + distance, point[1] - distance};\\n                        if (mMap.containsKey(hash(bottomRight))) {\\n                            count += mul * mMap.get(hash(rightPoint)) * mMap.get(key) * mMap.get(hash(bottomRight));\\n                        }\\n                    }\\n                }\\n                if (mMap.containsKey(hash(leftPoint))) {\\n                    if (point[1] < y(key)) {\\n                        int[] topLeft = new int[]{point[0] - distance, point[1] + distance};\\n                        if (mMap.containsKey(hash(topLeft))) {\\n                            count += mul * mMap.get(hash(leftPoint)) * mMap.get(key) * mMap.get(hash(topLeft));\\n                        }\\n                    } else if (point[1] > y(key)) {\\n                        int[] bottomLeft = new int[]{point[0] - distance, point[1] - distance};\\n                        if (mMap.containsKey(hash(bottomLeft))) {\\n                            count += mul * mMap.get(hash(leftPoint)) * mMap.get(key) * mMap.get(hash(bottomLeft));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private String hash(int[] point) { //O(1)\\n        return point[0] + \":\" + point[1];\\n    }\\n    private int x(String hash) { //O(1)\\n        return Integer.valueOf(hash.split(\":\")[0]);\\n    }\\n    private int y(String hash) { //O(1)\\n        return Integer.valueOf(hash.split(\":\")[1]);\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    private Map<String, Integer> mMap;\\n    public DetectSquares() {\\n        mMap = new HashMap<>();\\n    }\\n    public void add(int[] point) {\\n        String key = hash(point);\\n        mMap.put(key, mMap.getOrDefault(key, 0) + 1);\\n    }\\n    public int count(int[] point) {\\n        int mul = 1;\\n        if (mMap.containsKey(point)) {\\n            mul =  mMap.get(hash(point)) + 1;\\n        }\\n        int count = 0;\\n        for (String key: mMap.keySet()) {\\n            if (point[0] == x(key)) {\\n                int distance = Math.abs(point[1] - y(key));\\n                int[] rightPoint = new int[]{point[0] + distance, point[1]};\\n                int[] leftPoint = new int[]{point[0] - distance, point[1]};\\n                if (mMap.containsKey(hash(rightPoint))) {\\n                    if (point[1] < y(key)) {\\n                        int[] topRight = new int[]{point[0] + distance, point[1] + distance};\\n                        if (mMap.containsKey(hash(topRight))) {\\n                            count += mul * mMap.get(hash(rightPoint)) * mMap.get(key) * mMap.get(hash(topRight));\\n                        }\\n                    } else if (point[1] > y(key)) {\\n                        int[] bottomRight = new int[]{point[0] + distance, point[1] - distance};\\n                        if (mMap.containsKey(hash(bottomRight))) {\\n                            count += mul * mMap.get(hash(rightPoint)) * mMap.get(key) * mMap.get(hash(bottomRight));\\n                        }\\n                    }\\n                }\\n                if (mMap.containsKey(hash(leftPoint))) {\\n                    if (point[1] < y(key)) {\\n                        int[] topLeft = new int[]{point[0] - distance, point[1] + distance};\\n                        if (mMap.containsKey(hash(topLeft))) {\\n                            count += mul * mMap.get(hash(leftPoint)) * mMap.get(key) * mMap.get(hash(topLeft));\\n                        }\\n                    } else if (point[1] > y(key)) {\\n                        int[] bottomLeft = new int[]{point[0] - distance, point[1] - distance};\\n                        if (mMap.containsKey(hash(bottomLeft))) {\\n                            count += mul * mMap.get(hash(leftPoint)) * mMap.get(key) * mMap.get(hash(bottomLeft));\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    private String hash(int[] point) { //O(1)\\n        return point[0] + \":\" + point[1];\\n    }\\n    private int x(String hash) { //O(1)\\n        return Integer.valueOf(hash.split(\":\")[0]);\\n    }\\n    private int y(String hash) { //O(1)\\n        return Integer.valueOf(hash.split(\":\")[1]);\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401824,
                "title": "hashmap-elementary-school-consideration-about-squares",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe sides of a square are all the same length. If two points have the same X coordinate but different Y coordinates there are only two potential axis-aligned squares that can be formed -> one to the left and one to the right. So we need to check two potential points to the left for the left square and two potential points to the right for the right square. With defaultdict(int) we can avoid a lot of checks for the presence of points and just count...\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nADD - O(1)\\nCOUNT - O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.x_pts = defaultdict(set)\\n        self.pts_count = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.x_pts[x].add(y)\\n        self.pts_count[(x, y)] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        res = 0\\n        for candidate_y in self.x_pts[x]:\\n            if y == candidate_y:\\n                continue\\n            diff = y - candidate_y\\n            res += self.pts_count[(x - diff, y)] * self.pts_count[(x - diff, candidate_y)] * self.pts_count[(x, candidate_y)]\\n            res += self.pts_count[(x + diff, y)] * self.pts_count[(x + diff, candidate_y)] * self.pts_count[(x, candidate_y)]\\n        return res\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.x_pts = defaultdict(set)\\n        self.pts_count = defaultdict(int)\\n\\n    def add(self, point: List[int]) -> None:\\n        x, y = point\\n        self.x_pts[x].add(y)\\n        self.pts_count[(x, y)] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        x, y = point\\n        res = 0\\n        for candidate_y in self.x_pts[x]:\\n            if y == candidate_y:\\n                continue\\n            diff = y - candidate_y\\n            res += self.pts_count[(x - diff, y)] * self.pts_count[(x - diff, candidate_y)] * self.pts_count[(x, candidate_y)]\\n            res += self.pts_count[(x + diff, y)] * self.pts_count[(x + diff, candidate_y)] * self.pts_count[(x, candidate_y)]\\n        return res\\n        \\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400047,
                "title": "easy-java-solution-using-hashmap-and-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\n    HashMap<List<Integer>, Integer> map;\\n    List<int[]> pts;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        pts = new ArrayList<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        pts.add(point);\\n        List<Integer> lt = new ArrayList();\\n        lt.add(point[0]);\\n        lt.add(point[1]);\\n        if(!map.containsKey(lt))\\n        {\\n            map.put(lt, 1);\\n        }\\n        else\\n        {\\n            map.put(lt, map.get(lt) + 1);\\n        }\\n    }\\n    \\n    public int count(int[] point) {\\n        int px = point[0];\\n        int py = point[1];\\n        int res = 0;\\n        for(int i = 0; i < pts.size(); i++)\\n        {\\n            int x = pts.get(i)[0];\\n            int y = pts.get(i)[1];\\n            if(Math.abs(x - px) != Math.abs(y - py) || x == px || y == py)\\n            {\\n                continue;\\n            }\\n            List<Integer> lt = new ArrayList();\\n            lt.add(x);\\n            lt.add(py);\\n\\n            List<Integer> lt1 = new ArrayList();\\n            lt1.add(px);\\n            lt1.add(y);\\n\\n            res += map.getOrDefault(lt, 0) * map.getOrDefault(lt1, 0);\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    HashMap<List<Integer>, Integer> map;\\n    List<int[]> pts;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n        pts = new ArrayList<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        pts.add(point);\\n        List<Integer> lt = new ArrayList();\\n        lt.add(point[0]);\\n        lt.add(point[1]);\\n        if(!map.containsKey(lt))\\n        {\\n            map.put(lt, 1);\\n        }\\n        else\\n        {\\n            map.put(lt, map.get(lt) + 1);\\n        }\\n    }\\n    \\n    public int count(int[] point) {\\n        int px = point[0];\\n        int py = point[1];\\n        int res = 0;\\n        for(int i = 0; i < pts.size(); i++)\\n        {\\n            int x = pts.get(i)[0];\\n            int y = pts.get(i)[1];\\n            if(Math.abs(x - px) != Math.abs(y - py) || x == px || y == py)\\n            {\\n                continue;\\n            }\\n            List<Integer> lt = new ArrayList();\\n            lt.add(x);\\n            lt.add(py);\\n\\n            List<Integer> lt1 = new ArrayList();\\n            lt1.add(px);\\n            lt1.add(y);\\n\\n            res += map.getOrDefault(lt, 0) * map.getOrDefault(lt1, 0);\\n        }\\n        return res;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385517,
                "title": "7-lines-beats-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nadd function makes a set for all points on each row. \\nGiven a point p, go through each points on its row. We know that a square can be generated using 2 points to the right or two points to the left. \\nMultiply the number of each of those possbile verticies and add it to the result. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\ncount is O(k) for k is the number of distinct neighbors of a node (Note: k <= n). Faster than other approaches I\\'ve seen. \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares:\\n    def __init__(self):\\n        self.rowcount = defaultdict(set)\\n        self.points = defaultdict(int)\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.points[point] += 1\\n        self.rowcount[point[0]].add(point)\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        point = tuple(point)\\n        return sum(\\n            self.points[p1] * self.points[topright] * self.points[bottomright]\\n            for p1 in self.rowcount[point[0]]\\n            if p1 != point\\n            for diff in (abs(p1[1] - point[1]),)\\n            for topright in ((p1[0] + diff, p1[1]), (p1[0] - diff, p1[1]))\\n            for bottomright in ((topright[0], point[1]),)\\n            if topright in self.points and bottomright in self.points\\n        )\\n\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n    def __init__(self):\\n        self.rowcount = defaultdict(set)\\n        self.points = defaultdict(int)\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        point = tuple(point)\\n        self.points[point] += 1\\n        self.rowcount[point[0]].add(point)\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        point = tuple(point)\\n        return sum(\\n            self.points[p1] * self.points[topright] * self.points[bottomright]\\n            for p1 in self.rowcount[point[0]]\\n            if p1 != point\\n            for diff in (abs(p1[1] - point[1]),)\\n            for topright in ((p1[0] + diff, p1[1]), (p1[0] - diff, p1[1]))\\n            for bottomright in ((topright[0], point[1]),)\\n            if topright in self.points and bottomright in self.points\\n        )\\n\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378827,
                "title": "c-hash-map",
                "content": "\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int> m;\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            int x2 = i.first.first;\\n            int y2 = i.first.second;\\n            int a2 = m[{x2,y2}];\\n            if(y2==y1)\\n            {\\n                int len = abs(x1-x2);\\n                int cntp1=0,cntp2=0,cntn1=0,cntn2=0;\\n                for(auto &j:m)\\n                {\\n                    int x3 = j.first.first;\\n                    int y3 = j.first.second;\\n                    if(x3==x1 && y3>y1 && y3-y1==len)\\n                    {\\n                        cntp1+=m[{x3,y3}];\\n                    }\\n                    if(x3==x2 && y3>y1 && y3-y1==len)\\n                    {\\n                        cntp2+=m[{x3,y3}];\\n                    }\\n                }\\n                ans+=cntp1*cntp2*a2;\\n                for(auto &j:m)\\n                {\\n                    int x3 = j.first.first;\\n                    int y3 = j.first.second;\\n                    if(x3==x1 && y1>y3 && y1-y3==len)\\n                    {\\n                        cntn1+=m[{x3,y3}];\\n                    }\\n                    if(x3==x2 && y1>y3 && y1-y3==len)\\n                    {\\n                        cntn2+=m[{x3,y3}];\\n                    }\\n                }\\n                ans+=cntn2*cntn1*a2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    map<pair<int,int>,int> m;\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0];\\n        int y1 = point[1];\\n        int ans=0;\\n        for(auto &i:m)\\n        {\\n            int x2 = i.first.first;\\n            int y2 = i.first.second;\\n            int a2 = m[{x2,y2}];\\n            if(y2==y1)\\n            {\\n                int len = abs(x1-x2);\\n                int cntp1=0,cntp2=0,cntn1=0,cntn2=0;\\n                for(auto &j:m)\\n                {\\n                    int x3 = j.first.first;\\n                    int y3 = j.first.second;\\n                    if(x3==x1 && y3>y1 && y3-y1==len)\\n                    {\\n                        cntp1+=m[{x3,y3}];\\n                    }\\n                    if(x3==x2 && y3>y1 && y3-y1==len)\\n                    {\\n                        cntp2+=m[{x3,y3}];\\n                    }\\n                }\\n                ans+=cntp1*cntp2*a2;\\n                for(auto &j:m)\\n                {\\n                    int x3 = j.first.first;\\n                    int y3 = j.first.second;\\n                    if(x3==x1 && y1>y3 && y1-y3==len)\\n                    {\\n                        cntn1+=m[{x3,y3}];\\n                    }\\n                    if(x3==x2 && y1>y3 && y1-y3==len)\\n                    {\\n                        cntn2+=m[{x3,y3}];\\n                    }\\n                }\\n                ans+=cntn2*cntn1*a2;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346181,
                "title": "javascript-2013-detect-squares",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n```\\n                    qx,y            qx+side,y\\n                    side\\n                    qx,qy   side    qx+side,qy\\n```\\n\\n\\n```\\nqx-side,y   side    qx,y            qx+side,y\\n                    side\\nqx-side,qy  side    qx,qy   side    qx+side,qy\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar DetectSquares = function () {\\n    const x_col_count = new Map();\\n    return {\\n        add([x, y]) {\\n            if (!x_col_count.has(x)) {\\n                x_col_count.set(x, new Map());\\n            }\\n            const qxcol = x_col_count.get(x);\\n            qxcol.set(y, (qxcol.get(y) || 0) + 1);\\n        },\\n        count([qx, qy]) {\\n            const qxcol = x_col_count.get(qx);\\n            if (!qxcol) return 0;\\n\\n            let ans = 0;\\n            for (const a_y_on_qxcol of qxcol.keys()) {\\n                const side = Math.abs(qy - a_y_on_qxcol);\\n                if (!side) continue;\\n\\n                const right_col = x_col_count.get(qx + side);\\n                if (right_col?.has(qy) && right_col?.has(a_y_on_qxcol)) {\\n                    ans +=\\n                        right_col.get(qy) *\\n                        qxcol.get(a_y_on_qxcol) *\\n                        right_col.get(a_y_on_qxcol);\\n                }\\n\\n                const left_col = x_col_count.get(qx - side);\\n                if (left_col?.has(qy) && left_col?.has(a_y_on_qxcol)) {\\n                    ans +=\\n                        left_col.get(qy) *\\n                        qxcol.get(a_y_on_qxcol) *\\n                        left_col.get(a_y_on_qxcol);\\n                }\\n            }\\n            return ans;\\n        },\\n    };\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/acc55ec5-2978-4dec-b99c-f77b24e19cbf_1679891947.5314693.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n                    qx,y            qx+side,y\\n                    side\\n                    qx,qy   side    qx+side,qy\\n```\n```\\nqx-side,y   side    qx,y            qx+side,y\\n                    side\\nqx-side,qy  side    qx,qy   side    qx+side,qy\\n```\n```\\nvar DetectSquares = function () {\\n    const x_col_count = new Map();\\n    return {\\n        add([x, y]) {\\n            if (!x_col_count.has(x)) {\\n                x_col_count.set(x, new Map());\\n            }\\n            const qxcol = x_col_count.get(x);\\n            qxcol.set(y, (qxcol.get(y) || 0) + 1);\\n        },\\n        count([qx, qy]) {\\n            const qxcol = x_col_count.get(qx);\\n            if (!qxcol) return 0;\\n\\n            let ans = 0;\\n            for (const a_y_on_qxcol of qxcol.keys()) {\\n                const side = Math.abs(qy - a_y_on_qxcol);\\n                if (!side) continue;\\n\\n                const right_col = x_col_count.get(qx + side);\\n                if (right_col?.has(qy) && right_col?.has(a_y_on_qxcol)) {\\n                    ans +=\\n                        right_col.get(qy) *\\n                        qxcol.get(a_y_on_qxcol) *\\n                        right_col.get(a_y_on_qxcol);\\n                }\\n\\n                const left_col = x_col_count.get(qx - side);\\n                if (left_col?.has(qy) && left_col?.has(a_y_on_qxcol)) {\\n                    ans +=\\n                        left_col.get(qy) *\\n                        qxcol.get(a_y_on_qxcol) *\\n                        left_col.get(a_y_on_qxcol);\\n                }\\n            }\\n            return ans;\\n        },\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3339603,
                "title": "c",
                "content": "```\\nclass DetectSquares {\\nprivate:\\n    unordered_map<int, int>pointCount ; //{point, count}\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int hash = (point[0] << 10) + point[1] ;\\n        pointCount[hash]++ ;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0] ;\\n        int y1 = point[1] ;\\n        int hash1 = (x1 <<10) + y1 ;\\n        int ret = 0 ;\\n        for(auto& [hash3, count3] : pointCount){\\n            int x3 = (hash3 >> 10) ;\\n            int y3 = hash3 & 1023 ;\\n            if(hash3!= hash1 && abs(x1-x3) == abs(y1-y3)){\\n                int hash2 = (x1 << 10) + y3 ;\\n                int hash4 = (x3 << 10) + y1 ;\\n                if(pointCount.find(hash2) != pointCount.end()\\\\\\n                   && pointCount.find(hash4) != pointCount.end())\\n                {\\n                    int count2 =  pointCount[hash2] ;\\n                    int count4 =  pointCount[hash4] ;\\n                    ret += count3 * count2 * count4 ;\\n                } \\n            } \\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass DetectSquares {\\nprivate:\\n    unordered_map<int, int>pointCount ; //{point, count}\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        int hash = (point[0] << 10) + point[1] ;\\n        pointCount[hash]++ ;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int x1 = point[0] ;\\n        int y1 = point[1] ;\\n        int hash1 = (x1 <<10) + y1 ;\\n        int ret = 0 ;\\n        for(auto& [hash3, count3] : pointCount){\\n            int x3 = (hash3 >> 10) ;\\n            int y3 = hash3 & 1023 ;\\n            if(hash3!= hash1 && abs(x1-x3) == abs(y1-y3)){\\n                int hash2 = (x1 << 10) + y3 ;\\n                int hash4 = (x3 << 10) + y1 ;\\n                if(pointCount.find(hash2) != pointCount.end()\\\\\\n                   && pointCount.find(hash4) != pointCount.end())\\n                {\\n                    int count2 =  pointCount[hash2] ;\\n                    int count4 =  pointCount[hash4] ;\\n                    ret += count3 * count2 * count4 ;\\n                } \\n            } \\n        }\\n        return ret ;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3267332,
                "title": "easy-approach-without-hashmap-only-with-array",
                "content": "```\\nclass DetectSquares {\\n    int data[][] = new int[1001][1001];\\n    public DetectSquares() {\\n        \\n    }\\n    public void add(int[] point) {\\n        data[point[0]][point[1]]++;\\n    }\\n    public int count(int[] point) {\\n        int output = 0;\\n        for(int i=0;i<=1000;i++){if(i!=point[1]){\\n            if(data[point[0]][i]!=0){ int cal = (int)Math.abs(point[1]-i);\\n            if((point[0]+cal)<1001&&data[point[0]+cal][point[1]]!=0&&data[point[0]+cal][i]!=0)\\n                output += data[point[0]][i]*data[point[0]+cal][point[1]]*data[point[0]+cal][i];\\n            if((point[0]-cal)>=0&&data[point[0]-cal][point[1]]!=0&&data[point[0]-cal][i]!=0)\\n                output += data[point[0]][i]*data[point[0]-cal][point[1]]*data[point[0]-cal][i];\\n            }\\n        }}\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass DetectSquares {\\n    int data[][] = new int[1001][1001];\\n    public DetectSquares() {\\n        \\n    }\\n    public void add(int[] point) {\\n        data[point[0]][point[1]]++;\\n    }\\n    public int count(int[] point) {\\n        int output = 0;\\n        for(int i=0;i<=1000;i++){if(i!=point[1]){\\n            if(data[point[0]][i]!=0){ int cal = (int)Math.abs(point[1]-i);\\n            if((point[0]+cal)<1001&&data[point[0]+cal][point[1]]!=0&&data[point[0]+cal][i]!=0)\\n                output += data[point[0]][i]*data[point[0]+cal][point[1]]*data[point[0]+cal][i];\\n            if((point[0]-cal)>=0&&data[point[0]-cal][point[1]]!=0&&data[point[0]-cal][i]!=0)\\n                output += data[point[0]][i]*data[point[0]-cal][point[1]]*data[point[0]-cal][i];\\n            }\\n        }}\\n        return output;\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3261914,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        \\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        \\n        px,py = point\\n        \\n        x_li = []\\n        y_li = []\\n\\n        for ele in self.points:\\n            u,v = ele\\n\\n            if u == px and v-py != 0 :\\n                x_li.append(ele)\\n            if v == py and u-px != 0 :\\n                y_li.append(ele)\\n\\n        if len(x_li) == 0 or len(y_li) == 0:\\n            return 0   \\n\\n        else:\\n            ans = 0\\n\\n            for x_match in x_li:\\n                y_dis = py - x_match[1]\\n\\n                for y_match in y_li:\\n                    x_dis = px - y_match[0]\\n\\n                    if abs(y_dis) == abs(x_dis):                        \\n                        last_point = (y_match[0],x_match[1])                        \\n\\n                        if last_point in self.points:\\n                            # print(self.points[last_point])\\n                            ans += self.points[last_point] * self.points[tuple(x_match)] * self.points[tuple(y_match)]\\n\\n        return ans\\n\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```\\n\\nPlease upvote \\u2B06\\uFE0F if you found this usefull and comment if you need any clarification/explanation \\uD83D\\uDCA1 for any part, I\\'m happy to help \\uD83D\\uDE07",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.points = defaultdict(int)\\n        \\n    def add(self, point: List[int]) -> None:\\n        self.points[tuple(point)] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        \\n        px,py = point\\n        \\n        x_li = []\\n        y_li = []\\n\\n        for ele in self.points:\\n            u,v = ele\\n\\n            if u == px and v-py != 0 :\\n                x_li.append(ele)\\n            if v == py and u-px != 0 :\\n                y_li.append(ele)\\n\\n        if len(x_li) == 0 or len(y_li) == 0:\\n            return 0   \\n\\n        else:\\n            ans = 0\\n\\n            for x_match in x_li:\\n                y_dis = py - x_match[1]\\n\\n                for y_match in y_li:\\n                    x_dis = px - y_match[0]\\n\\n                    if abs(y_dis) == abs(x_dis):                        \\n                        last_point = (y_match[0],x_match[1])                        \\n\\n                        if last_point in self.points:\\n                            # print(self.points[last_point])\\n                            ans += self.points[last_point] * self.points[tuple(x_match)] * self.points[tuple(y_match)]\\n\\n        return ans\\n\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255340,
                "title": "java-hashmap-2d-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.use 2D array\\nThe 2D array records how many times each points are added.\\nThe key of the map is the x-coordinate, the corresponding value is the collection of the y-coordinates of the points that have this x-coordinate.\\n2.use HashMap\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nadd: O(1)\\ncount: O(T), where T <= 5000 is total number of add call.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1000^2)\\n# Code\\n1.use 2d array:\\n```\\nclass DetectSquares {\\n    Map<Integer, List<Integer>> mx;\\n    int[][] points;\\n    public DetectSquares() {\\n        mx = new HashMap<>();\\n        points = new int[1001][1001];\\n    }\\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        points[x][y]++;\\n        if(!mx.containsKey(x)) mx.put(x, new ArrayList<>());\\n        mx.get(x).add(y);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0], y = point[1];\\n        if(!mx.containsKey(x)) return(0);\\n        int res = 0;\\n        for(int b: mx.get(x)){\\n            int d = Math.abs(y - b);\\n            if(d == 0) continue;\\n\\n            if(x - d >= 0) res += points[x - d][y] * points[x - d][b];\\n            if(x + d <= 1000) res += points[x + d][y] * points[x + d][b];\\n            \\n        }\\n\\n        return(res);\\n\\n    }\\n}\\n\\n```\\n\\n2.use HashMap<>():\\n```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        if(!map.containsKey(x)) map.put(x, new HashMap<>());\\n        map.get(x).put(y, map.get(x).getOrDefault(y, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int res = 0;\\n        int x = point[0], y = point[1];\\n        if(map.get(x) == null) return(0);\\n        for(int ny: map.get(x).keySet()){\\n            int distance = Math.abs(y - ny);\\n            int minus = x - distance;\\n            if(minus > 0 && map.get(minus) != null && map.get(minus).containsKey(y) && map.get(minus).containsKey(ny)){\\n                res += map.get(x).get(ny) * map.get(minus).get(y) * map.get(minus).get(ny);\\n            }\\n\\n            int plus = x + distance;\\n            if(map.get(plus) != null && map.get(plus).containsKey(y) && map.get(plus).containsKey(ny)){\\n                res += map.get(x).get(ny) * map.get(plus).get(y) * map.get(plus).get(ny);\\n            }\\n        }\\n\\n        return(res);\\n\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n    Map<Integer, List<Integer>> mx;\\n    int[][] points;\\n    public DetectSquares() {\\n        mx = new HashMap<>();\\n        points = new int[1001][1001];\\n    }\\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        points[x][y]++;\\n        if(!mx.containsKey(x)) mx.put(x, new ArrayList<>());\\n        mx.get(x).add(y);\\n    }\\n    \\n    public int count(int[] point) {\\n        int x = point[0], y = point[1];\\n        if(!mx.containsKey(x)) return(0);\\n        int res = 0;\\n        for(int b: mx.get(x)){\\n            int d = Math.abs(y - b);\\n            if(d == 0) continue;\\n\\n            if(x - d >= 0) res += points[x - d][y] * points[x - d][b];\\n            if(x + d <= 1000) res += points[x + d][y] * points[x + d][b];\\n            \\n        }\\n\\n        return(res);\\n\\n    }\\n}\\n\\n```\n```\\nclass DetectSquares {\\n    Map<Integer, Map<Integer, Integer>> map;\\n    public DetectSquares() {\\n        map = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n        int x = point[0], y = point[1];\\n        if(!map.containsKey(x)) map.put(x, new HashMap<>());\\n        map.get(x).put(y, map.get(x).getOrDefault(y, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n        int res = 0;\\n        int x = point[0], y = point[1];\\n        if(map.get(x) == null) return(0);\\n        for(int ny: map.get(x).keySet()){\\n            int distance = Math.abs(y - ny);\\n            int minus = x - distance;\\n            if(minus > 0 && map.get(minus) != null && map.get(minus).containsKey(y) && map.get(minus).containsKey(ny)){\\n                res += map.get(x).get(ny) * map.get(minus).get(y) * map.get(minus).get(ny);\\n            }\\n\\n            int plus = x + distance;\\n            if(map.get(plus) != null && map.get(plus).containsKey(y) && map.get(plus).containsKey(ny)){\\n                res += map.get(x).get(ny) * map.get(plus).get(y) * map.get(plus).get(ny);\\n            }\\n        }\\n\\n        return(res);\\n\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253879,
                "title": "golang-70-ms-7-7-mb",
                "content": "```\\ntype DetectSquares struct {\\n\\txy map[int16]map[int16]uint16\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{xy: make(map[int16]map[int16]uint16)}\\n}\\n\\nfunc (d *DetectSquares) Add(point []int) {\\n\\tx := int16(point[0])\\n\\ty := int16(point[1])\\n\\tif d.xy[x] == nil {\\n\\t\\td.xy[x] = make(map[int16]uint16)\\n\\t}\\n\\td.xy[x][y]++\\n}\\n\\nfunc (d *DetectSquares) Count(point []int) int {\\n\\tvar result int\\n\\tx1 := int16(point[0])\\n\\ty1 := int16(point[1])\\n\\tfor y2, count := range d.xy[x1] {\\n\\t\\tif y2 == y1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\twidth := y2 - y1\\n\\t\\tif width < 0 {\\n\\t\\t\\twidth = -width\\n\\t\\t}\\n\\t\\tx2 := x1 - width\\n\\t\\tresult += int(count) * int(d.xy[x2][y1]) * int(d.xy[x2][y2])\\n\\t\\tx2 = x1 + width\\n\\t\\tresult += int(count) * int(d.xy[x2][y1]) * int(d.xy[x2][y2])\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype DetectSquares struct {\\n\\txy map[int16]map[int16]uint16\\n}\\n\\nfunc Constructor() DetectSquares {\\n\\treturn DetectSquares{xy: make(map[int16]map[int16]uint16)}\\n}\\n\\nfunc (d *DetectSquares) Add(point []int) {\\n\\tx := int16(point[0])\\n\\ty := int16(point[1])\\n\\tif d.xy[x] == nil {\\n\\t\\td.xy[x] = make(map[int16]uint16)\\n\\t}\\n\\td.xy[x][y]++\\n}\\n\\nfunc (d *DetectSquares) Count(point []int) int {\\n\\tvar result int\\n\\tx1 := int16(point[0])\\n\\ty1 := int16(point[1])\\n\\tfor y2, count := range d.xy[x1] {\\n\\t\\tif y2 == y1 {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\twidth := y2 - y1\\n\\t\\tif width < 0 {\\n\\t\\t\\twidth = -width\\n\\t\\t}\\n\\t\\tx2 := x1 - width\\n\\t\\tresult += int(count) * int(d.xy[x2][y1]) * int(d.xy[x2][y2])\\n\\t\\tx2 = x1 + width\\n\\t\\tresult += int(count) * int(d.xy[x2][y1]) * int(d.xy[x2][y2])\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3248444,
                "title": "c-basic-intuition-with-simple-implementation",
                "content": "# Intuition\\nIt\\'s enough to know 2 points along the diagonal in the square.\\n\\n# Approach\\nIterate over every point and see whether we can form a square using two other points in the data set.\\n\\nthis is done by using a histogram to search for the 2 other points, and making sure they form a square and NOT a rectangle or a degenerate square.\\n\\nwe handle duplicates by multiplying to find the number of possibilities.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#define W (1001)\\nclass DetectSquares {\\nprivate:\\n    vector<pair<int, int>> PointArr;\\n    vector<int> Cells;\\n\\npublic:\\n    DetectSquares() {\\n        Cells.reserve(W * W);\\n        for (int i = 0; i < W * W; i++)\\n            Cells.push_back(0);\\n    }\\n    \\n    void add(vector<int> point) {\\n        PointArr.push_back(pair(point[0], point[1]));\\n        Cells[point[0] + point[1] * W]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int Res = 0;\\n\\n        for (const pair<int, int> &p : PointArr) {\\n            /* Avoid 0 area. */\\n            if (p.first == point[0] || p.second == point[1])\\n                continue;\\n\\n            /* Make sure it\\'s square. */\\n            if (abs(p.first - point[0]) != abs(p.second - point[1]))\\n                continue;\\n\\n            Res += Cells[point[0] + p.second * W] * Cells[p.first + point[1] * W];   \\n        }\\n\\n        return Res;\\n    }\\n};\\n###### heading",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\nIt\\'s enough to know 2 points along the diagonal in the square.\\n\\n# Approach\\nIterate over every point and see whether we can form a square using two other points in the data set.\\n\\nthis is done by using a histogram to search for the 2 other points, and making sure they form a square and NOT a rectangle or a degenerate square.\\n\\nwe handle duplicates by multiplying to find the number of possibilities.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n#define W (1001)\\nclass DetectSquares {\\nprivate:\\n    vector<pair<int, int>> PointArr;\\n    vector<int> Cells;\\n\\npublic:\\n    DetectSquares() {\\n        Cells.reserve(W * W);\\n        for (int i = 0; i < W * W; i++)\\n            Cells.push_back(0);\\n    }\\n    \\n    void add(vector<int> point) {\\n        PointArr.push_back(pair(point[0], point[1]));\\n        Cells[point[0] + point[1] * W]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int Res = 0;\\n\\n        for (const pair<int, int> &p : PointArr) {\\n            /* Avoid 0 area. */\\n            if (p.first == point[0] || p.second == point[1])\\n                continue;\\n\\n            /* Make sure it\\'s square. */\\n            if (abs(p.first - point[0]) != abs(p.second - point[1]))\\n                continue;\\n\\n            Res += Cells[point[0] + p.second * W] * Cells[p.first + point[1] * W];   \\n        }\\n\\n        return Res;\\n    }\\n};\\n###### heading",
                "codeTag": "Java"
            },
            {
                "id": 3213155,
                "title": "java-solution-with-only-a-single-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse only a Map to get to the solution. There is no need to maintain a separate list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\n\\n    Map<Pair<Integer, Integer>, Integer> pointCounts;\\n\\n    public DetectSquares() {\\n        pointCounts = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n\\n        Pair<Integer, Integer> key = new Pair<>(point[0], point[1]);\\n\\n        pointCounts.put(key, pointCounts.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n\\n        int count = 0;\\n\\n        for (Pair<Integer, Integer> pointKey : pointCounts.keySet()) {\\n            int xDist = Math.abs(point[0] - pointKey.getKey());\\n            int yDist = Math.abs(point[1] - pointKey.getValue());\\n\\n            // If it is not diagonal or it is the same point, ignore\\n            if (xDist != yDist || xDist == 0) continue;\\n\\n            Pair<Integer, Integer> point1 = new Pair<>(pointKey.getKey(), point[1]);\\n            Pair<Integer, Integer> point2 = new Pair<>(point[0], pointKey.getValue());\\n\\n            count += pointCounts.get(pointKey) * pointCounts.getOrDefault(point1, 0) *\\n                pointCounts.getOrDefault(point2, 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass DetectSquares {\\n\\n    Map<Pair<Integer, Integer>, Integer> pointCounts;\\n\\n    public DetectSquares() {\\n        pointCounts = new HashMap<>();\\n    }\\n    \\n    public void add(int[] point) {\\n\\n        Pair<Integer, Integer> key = new Pair<>(point[0], point[1]);\\n\\n        pointCounts.put(key, pointCounts.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int count(int[] point) {\\n\\n        int count = 0;\\n\\n        for (Pair<Integer, Integer> pointKey : pointCounts.keySet()) {\\n            int xDist = Math.abs(point[0] - pointKey.getKey());\\n            int yDist = Math.abs(point[1] - pointKey.getValue());\\n\\n            // If it is not diagonal or it is the same point, ignore\\n            if (xDist != yDist || xDist == 0) continue;\\n\\n            Pair<Integer, Integer> point1 = new Pair<>(pointKey.getKey(), point[1]);\\n            Pair<Integer, Integer> point2 = new Pair<>(point[0], pointKey.getValue());\\n\\n            count += pointCounts.get(pointKey) * pointCounts.getOrDefault(point1, 0) *\\n                pointCounts.getOrDefault(point2, 0);\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares obj = new DetectSquares();\\n * obj.add(point);\\n * int param_2 = obj.count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207838,
                "title": "c-using-unordered-map-without-looping-whole-map-beat-90",
                "content": "# Code\\n```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> mp;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> p) {\\n        mp[p[0]][p[1]]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        int x = p[0], y = p[1];\\n        int res = 0;\\n        for (auto m : mp[x]) {\\n            int y1 = m.first, count = m.second;\\n            int sideLen = y - y1;\\n            if (sideLen == 0)   continue;\\n\\n            if (x + sideLen >= 0 && \\n                mp[x + sideLen][y] && mp[x + sideLen][y1]) {\\n                res += mp[x + sideLen][y] * mp[x + sideLen][y1] * count;\\n            }\\n\\n            if (x - sideLen >= 0 && \\n                mp[x - sideLen][y] && mp[x - sideLen][y1]) {\\n                res += mp[x - sideLen][y] * mp[x - sideLen][y1] * count;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    unordered_map<int, unordered_map<int, int>> mp;\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> p) {\\n        mp[p[0]][p[1]]++;\\n    }\\n    \\n    int count(vector<int> p) {\\n        int x = p[0], y = p[1];\\n        int res = 0;\\n        for (auto m : mp[x]) {\\n            int y1 = m.first, count = m.second;\\n            int sideLen = y - y1;\\n            if (sideLen == 0)   continue;\\n\\n            if (x + sideLen >= 0 && \\n                mp[x + sideLen][y] && mp[x + sideLen][y1]) {\\n                res += mp[x + sideLen][y] * mp[x + sideLen][y1] * count;\\n            }\\n\\n            if (x - sideLen >= 0 && \\n                mp[x - sideLen][y] && mp[x - sideLen][y1]) {\\n                res += mp[x - sideLen][y] * mp[x - sideLen][y1] * count;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207479,
                "title": "swift-beats-85",
                "content": "# Intuition\\nCheck for a diagonal. Keep track of the counts with a hash table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\n    var hashMap = [[Int]: Int]()\\n\\n    init() {\\n        \\n    }\\n    \\n    func add(_ point: [Int]) {\\n        if hashMap[point] == nil { hashMap[point] = 0}\\n        hashMap[point]! += 1\\n    }\\n    \\n    func count(_ point: [Int]) -> Int {\\n\\n        var result = 0\\n\\n        for (key, value) in hashMap {\\n            if key == point { continue }\\n            if abs((point[0] - key[0])) != abs((point[1] - key[1])) { continue }\\n\\n            let point1 = [point[0], key[1]]\\n            let point2 = [key[0], point[1]]\\n\\n            guard let numPoint1 = hashMap[point1] else { continue }\\n            guard let numPoint2 = hashMap[point2] else { continue }\\n\\n            result +=  (value * numPoint1 * numPoint2)\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * let obj = DetectSquares()\\n * obj.add(point)\\n * let ret_2: Int = obj.count(point)\\n */\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass DetectSquares {\\n    var hashMap = [[Int]: Int]()\\n\\n    init() {\\n        \\n    }\\n    \\n    func add(_ point: [Int]) {\\n        if hashMap[point] == nil { hashMap[point] = 0}\\n        hashMap[point]! += 1\\n    }\\n    \\n    func count(_ point: [Int]) -> Int {\\n\\n        var result = 0\\n\\n        for (key, value) in hashMap {\\n            if key == point { continue }\\n            if abs((point[0] - key[0])) != abs((point[1] - key[1])) { continue }\\n\\n            let point1 = [point[0], key[1]]\\n            let point2 = [key[0], point[1]]\\n\\n            guard let numPoint1 = hashMap[point1] else { continue }\\n            guard let numPoint2 = hashMap[point2] else { continue }\\n\\n            result +=  (value * numPoint1 * numPoint2)\\n        }\\n\\n        return result\\n    }\\n}\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * let obj = DetectSquares()\\n * obj.add(point)\\n * let ret_2: Int = obj.count(point)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125719,
                "title": "python-learn-something-new-a-defaultdict-of-a-defaultdict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMainly wanted to post as I learned that you can use a defaultdict inside a default dict if you instiate with a lambda. This makes the follow on code a lot easier as you don\\'t have to bounds check anything.\\n\\n\\n# Code\\n```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.mapping = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.mapping[point[0]][point[1]] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        count = 0\\n        for y, num in self.mapping[point[0]].items():\\n            edgeLength = abs(point[1] - y)\\n            if edgeLength > 0:\\n                count += num * self.mapping[point[0] - edgeLength][y] * self.mapping[point[0] - edgeLength][point[1]]\\n                count += num * self.mapping[point[0] + edgeLength][y] * self.mapping[point[0] + edgeLength][point[1]]\\n\\n        return count\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.mapping = defaultdict(lambda: defaultdict(int))\\n\\n    def add(self, point: List[int]) -> None:\\n        self.mapping[point[0]][point[1]] += 1\\n\\n    def count(self, point: List[int]) -> int:\\n        count = 0\\n        for y, num in self.mapping[point[0]].items():\\n            edgeLength = abs(point[1] - y)\\n            if edgeLength > 0:\\n                count += num * self.mapping[point[0] - edgeLength][y] * self.mapping[point[0] - edgeLength][point[1]]\\n                count += num * self.mapping[point[0] + edgeLength][y] * self.mapping[point[0] + edgeLength][point[1]]\\n\\n        return count\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124857,
                "title": "c-easy-solution-using-two-unordered-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe though process is as follows: when we query a point, we must first find all the pairs of points where point 1 lies on the same x as the query point and point 2 lies on the same y as the query point and the distance to both of these points from the query point is the same.\\n\\nOnce we have these pairs, we check if we have the required diagonal point to make an entire square. We then count all the combinations of these points that we could make a square out of since there could be duplicates.\\n\\nOne way to easily search for these points is to use two nested unordered_maps. One that stores the y values and associated count of all points that lie on a given x line, and another that stores the x values and associated count of all points that lie on a given y line.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse two nested unordered_maps as described above and insert to them trivially in add().\\n\\nIn count(), we first grab all points that lie on the same x and all points that lie on the same y. We then loop through all the pairs of these points and check if they are the same distance from the query point.\\n\\nIf so, we then check how many diagonal points we have to finish off the square. We then multiple the count of each of the three points we have to go with the query point together to account for all combinations we could get from duplicates.\\n\\n# Complexity\\n- Time complexity: O(N^2), where N is the number of points.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points_on_x[point[0]][point[1]]++;\\n        points_on_y[point[1]][point[0]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        // Get all points on same x and y as square.\\n        unordered_map<int, int> ys = points_on_x[point[0]];\\n        unordered_map<int, int> xs = points_on_y[point[1]];\\n\\n        // For all combinations, determine if they form a square.\\n        int count = 0;\\n\\n        // For each y value of each point on the same x vertical\\n        for (const auto& y : ys) {\\n            // For each x value of each point on the same y horizontal\\n            for (const auto& x : xs) {\\n                // Check same dimensions and size\\n                if (abs(y.first - point[1]) != abs(x.first - point[0]) || abs(y.first - point[1]) == 0 || abs(x.first - point[0]) == 0) {\\n                    continue;\\n                }\\n\\n                // Valid square, add as many as there are duplicate diagonal points.\\n                int num_diag_duplicates = points_on_x[x.first][y.first];\\n                count += num_diag_duplicates * x.second * y.second;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    // Store all y values that lie on each x vertical and the count of each\\n    unordered_map<int, unordered_map<int,int>> points_on_x;\\n\\n    // Store all x values that lie on each y horizontal and the count of each\\n    unordered_map<int, unordered_map<int,int>> points_on_y;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n        \\n    }\\n    \\n    void add(vector<int> point) {\\n        points_on_x[point[0]][point[1]]++;\\n        points_on_y[point[1]][point[0]]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        // Get all points on same x and y as square.\\n        unordered_map<int, int> ys = points_on_x[point[0]];\\n        unordered_map<int, int> xs = points_on_y[point[1]];\\n\\n        // For all combinations, determine if they form a square.\\n        int count = 0;\\n\\n        // For each y value of each point on the same x vertical\\n        for (const auto& y : ys) {\\n            // For each x value of each point on the same y horizontal\\n            for (const auto& x : xs) {\\n                // Check same dimensions and size\\n                if (abs(y.first - point[1]) != abs(x.first - point[0]) || abs(y.first - point[1]) == 0 || abs(x.first - point[0]) == 0) {\\n                    continue;\\n                }\\n\\n                // Valid square, add as many as there are duplicate diagonal points.\\n                int num_diag_duplicates = points_on_x[x.first][y.first];\\n                count += num_diag_duplicates * x.second * y.second;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\nprivate:\\n    // Store all y values that lie on each x vertical and the count of each\\n    unordered_map<int, unordered_map<int,int>> points_on_x;\\n\\n    // Store all x values that lie on each y horizontal and the count of each\\n    unordered_map<int, unordered_map<int,int>> points_on_y;\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044289,
                "title": "python-easy-solution",
                "content": "# Code\\n```\\nfrom collections import Counter\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.counter = Counter()\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.counter[tuple(point)] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        x, y = point\\n        for x0, y0 in self.counter.keys():\\n            if abs(x-x0) == abs(y-y0) and abs(x-x0):\\n                res += self.counter[(x0,y0)]*self.counter[(x0,y)]*self.counter[(x,y0)]\\n        return res\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass DetectSquares:\\n\\n    def __init__(self):\\n        self.counter = Counter()\\n        \\n\\n    def add(self, point: List[int]) -> None:\\n        self.counter[tuple(point)] += 1\\n        \\n\\n    def count(self, point: List[int]) -> int:\\n        res = 0\\n        x, y = point\\n        for x0, y0 in self.counter.keys():\\n            if abs(x-x0) == abs(y-y0) and abs(x-x0):\\n                res += self.counter[(x0,y0)]*self.counter[(x0,y)]*self.counter[(x,y0)]\\n        return res\\n\\n\\n# Your DetectSquares object will be instantiated and called as such:\\n# obj = DetectSquares()\\n# obj.add(point)\\n# param_2 = obj.count(point)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029679,
                "title": "c-hash-map",
                "content": "To solve this problem we can utilize a hash function to map each point to a unique integer, allowing us to store its occurrence in a hashmap. When we perform the `count()` function, we can check if there is a point that can be found on the diagonal to the queried point `q` when they are in a square, this requires us to find a point `p` such that `abs(p.x - q.x) == abs(p.y - q.y) and (p.x - q.x) != 0`.\\n```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        ++cnts[hash_(point[0], point[1])];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        for(auto &[p, p_cnt] : cnts) {\\n            int x = (p >> 10), y = (p & ((1 << 10) - 1));\\n            if(abs(x - point[0]) == abs(y - point[1]) && (x - point[0]) != 0) {\\n                auto it1 = cnts.find(hash_(x, point[1]));\\n                auto it2 = cnts.find(hash_(point[0], y));\\n                if(it1 != cnts.end() && it2 != cnts.end()) {\\n                    cnt += (it1->second * it2->second * p_cnt);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    unordered_map<int, int> cnts;\\n    int hash_(int x, int y) {\\n        return ((x << 10) | y);\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass DetectSquares {\\npublic:\\n    DetectSquares() {\\n    }\\n    \\n    void add(vector<int> point) {\\n        ++cnts[hash_(point[0], point[1])];\\n    }\\n    \\n    int count(vector<int> point) {\\n        int cnt = 0;\\n        for(auto &[p, p_cnt] : cnts) {\\n            int x = (p >> 10), y = (p & ((1 << 10) - 1));\\n            if(abs(x - point[0]) == abs(y - point[1]) && (x - point[0]) != 0) {\\n                auto it1 = cnts.find(hash_(x, point[1]));\\n                auto it2 = cnts.find(hash_(point[0], y));\\n                if(it1 != cnts.end() && it2 != cnts.end()) {\\n                    cnt += (it1->second * it2->second * p_cnt);\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\nprivate:\\n    unordered_map<int, int> cnts;\\n    int hash_(int x, int y) {\\n        return ((x << 10) | y);\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024688,
                "title": "c-unoptimized-and-optimized-solutions-faster-than-85",
                "content": "# 2013. Detect Squares\\nC++ solutions with an approach and it\\'s optimization.\\n![Screenshot 2023-01-09 173205.jpg](https://assets.leetcode.com/users/images/2cb1dd16-8cf8-4b4f-bbc3-f708f5fed1bd_1673265824.886406.jpeg)\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause we need to store a value at first and then count some desired values by iterating through a current set of values, the use of maps comes to mind. Because we have to store a pair of values and C++ doesn\\'t support pair<int,int> as key in unordered_maps, we\\'ll have to use an ordered one.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe `add()` function is fairly easy. We just need to update our map with new value (which may or may not be duplicate).\\n### Approach: 1 - Verdict: TLE (tc. 44/54)\\nIn the `count` function, we have to either choose a point which has the same x-value or same y-value as the given point (because the square has to be parallel to the axes).\\nWe iterate through our map and for all the points which satisfy this aforementioned condition, we calcute `a` or the length of the side of the square.\\nThen we simply multiply the values of the number of occurences of each such point and it to the final sum.\\n\\nHere we need to make sure that we don\\'t use the already counted square\\'s point again hence, we use a visited map.\\n\\n#### Code:\\n```\\nclass DetectSquares {\\n    map<pair<int,int>,int> m;\\npublic:\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int sum = 0;\\n        map<pair<int,int>,int> vis;\\n        for(auto&i:m){\\n            if((i.first.first==point[0]||i.first.second==point[1])&&vis[{i.first.first,i.first.second}]==0){\\n                int a = (i.first.first==point[0]) ? abs(i.first.second-point[1]):abs(i.first.first-point[0]);\\n                int temp = 0;\\n                if(a!=0){\\n                    if(i.first.first==point[0]){\\n                        temp+=m[{i.first.first-a,i.first.second}]*m[{point[0]-a,point[1]}];\\n                        temp+=m[{i.first.first+a,i.first.second}]*m[{point[0]+a,point[1]}];\\n                        vis[{i.first.first-a,i.first.second}]++;\\n                        vis[{i.first.first+a,i.first.second}]++;\\n                        vis[{point[0]-a,point[1]}]++;\\n                        vis[{point[0]+a,point[1]}]++;\\n                    }\\n                    else{\\n                        temp+=m[{i.first.first,i.first.second-a}]*m[{point[0],point[1]-a}];\\n                        temp+=m[{i.first.first,i.first.second+a}]*m[{point[0],point[1]+a}];\\n                        vis[{i.first.first,i.first.second-a}]++;\\n                        vis[{i.first.first,i.first.second+a}]++;\\n                        vis[{point[0],point[1]-a}]++;\\n                        vis[{point[0],point[1]+a}]++;\\n                    }\\n                }\\n                sum+=temp*i.second;\\n\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```\\n### Approach: 2 - Verdict: Accepted (Beats 85.76%)\\nThe only difference in this approach and the previous one is that there is no visited map in this one. If we think smartly, we can just select the points which have either the same x or same y (in given code I\\'ve chosen x) and add them. This ensures we don\\'t choose the same square twice as the same y one is not considered anyways. \\n\\nHere we save the `n*log(n)` insertion time and `n*log(n)` search time with visited map.\\n\\n### Code\\n```\\nclass DetectSquares {\\n    map<pair<int,int>,int> m;\\npublic:\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int sum = 0;\\n       \\n        for(auto&i:m){\\n            if(i.first.first==point[0]||i.first.second==point[1]){\\n                int a = (i.first.first==point[0]) ? abs(i.first.second-point[1]):0;\\n                int temp = 0;\\n                if(a!=0){\\n                    if(i.first.first==point[0]){\\n                        temp+=m[{i.first.first-a,i.first.second}]*m[{point[0]-a,point[1]}];\\n                        temp+=m[{i.first.first+a,i.first.second}]*m[{point[0]+a,point[1]}];\\n                    }\\n                    \\n                }\\n                sum+=temp*i.second;\\n\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```\\n\\n\\n\\n\\nThanks for reading!\\n\\n",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass DetectSquares {\\n    map<pair<int,int>,int> m;\\npublic:\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int sum = 0;\\n        map<pair<int,int>,int> vis;\\n        for(auto&i:m){\\n            if((i.first.first==point[0]||i.first.second==point[1])&&vis[{i.first.first,i.first.second}]==0){\\n                int a = (i.first.first==point[0]) ? abs(i.first.second-point[1]):abs(i.first.first-point[0]);\\n                int temp = 0;\\n                if(a!=0){\\n                    if(i.first.first==point[0]){\\n                        temp+=m[{i.first.first-a,i.first.second}]*m[{point[0]-a,point[1]}];\\n                        temp+=m[{i.first.first+a,i.first.second}]*m[{point[0]+a,point[1]}];\\n                        vis[{i.first.first-a,i.first.second}]++;\\n                        vis[{i.first.first+a,i.first.second}]++;\\n                        vis[{point[0]-a,point[1]}]++;\\n                        vis[{point[0]+a,point[1]}]++;\\n                    }\\n                    else{\\n                        temp+=m[{i.first.first,i.first.second-a}]*m[{point[0],point[1]-a}];\\n                        temp+=m[{i.first.first,i.first.second+a}]*m[{point[0],point[1]+a}];\\n                        vis[{i.first.first,i.first.second-a}]++;\\n                        vis[{i.first.first,i.first.second+a}]++;\\n                        vis[{point[0],point[1]-a}]++;\\n                        vis[{point[0],point[1]+a}]++;\\n                    }\\n                }\\n                sum+=temp*i.second;\\n\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```\n```\\nclass DetectSquares {\\n    map<pair<int,int>,int> m;\\npublic:\\n    DetectSquares() {\\n        m.clear();\\n    }\\n    \\n    void add(vector<int> point) {\\n        m[{point[0],point[1]}]++;\\n    }\\n    \\n    int count(vector<int> point) {\\n        int sum = 0;\\n       \\n        for(auto&i:m){\\n            if(i.first.first==point[0]||i.first.second==point[1]){\\n                int a = (i.first.first==point[0]) ? abs(i.first.second-point[1]):0;\\n                int temp = 0;\\n                if(a!=0){\\n                    if(i.first.first==point[0]){\\n                        temp+=m[{i.first.first-a,i.first.second}]*m[{point[0]-a,point[1]}];\\n                        temp+=m[{i.first.first+a,i.first.second}]*m[{point[0]+a,point[1]}];\\n                    }\\n                    \\n                }\\n                sum+=temp*i.second;\\n\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your DetectSquares object will be instantiated and called as such:\\n * DetectSquares* obj = new DetectSquares();\\n * obj->add(point);\\n * int param_2 = obj->count(point);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014401,
                "title": "concise-solution-c-map",
                "content": "```\\nunordered_map <int,map<int,int>> umap;\\n    \\n    void add(vector<int> point) { umap[point[0]][point[1]]++; }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0],y = point[1],cnt = 0;\\n        \\n        for(auto iter : umap){\\n            int dx = iter.first;auto it = iter.second;\\n            for(auto i : it){\\n                int dy = i.first;\\n                if(umap.find(x)==umap.end()){ continue; }\\n                if(umap.find(dx)==umap.end()){ continue; }\\n                if(abs(dx-x)!=abs(dy-y)){ continue; }\\n                if(dx==x || dy==y){ continue; }\\n                auto map1 = umap[x],map2 = umap[dx];\\n                if(map1.find(dy)!=map1.end() && map2.find(y)!=map2.end()){\\n                    cnt+=(map1[dy]*map2[y]*i.second);\\n                }\\n            }\\n        } return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map <int,map<int,int>> umap;\\n    \\n    void add(vector<int> point) { umap[point[0]][point[1]]++; }\\n    \\n    int count(vector<int> point) {\\n        int x = point[0],y = point[1],cnt = 0;\\n        \\n        for(auto iter : umap){\\n            int dx = iter.first;auto it = iter.second;\\n            for(auto i : it){\\n                int dy = i.first;\\n                if(umap.find(x)==umap.end()){ continue; }\\n                if(umap.find(dx)==umap.end()){ continue; }\\n                if(abs(dx-x)!=abs(dy-y)){ continue; }\\n                if(dx==x || dy==y){ continue; }\\n                auto map1 = umap[x],map2 = umap[dx];\\n                if(map1.find(dy)!=map1.end() && map2.find(y)!=map2.end()){\\n                    cnt+=(map1[dy]*map2[y]*i.second);\\n                }\\n            }\\n        } return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1903520,
                "content": [
                    {
                        "username": "feliposz",
                        "content": "Axis-aligned SQUARE... not rectangle!!!"
                    },
                    {
                        "username": "tb950110",
                        "content": "thank you!"
                    },
                    {
                        "username": "tonari",
                        "content": "For data structure, think about how you can access # of points in reduced time (ideally constant). Then think about additional info from the problem you can use that\\'s Math-y"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Another tricky Question"
                    }
                ]
            },
            {
                "id": 1829467,
                "content": [
                    {
                        "username": "feliposz",
                        "content": "Axis-aligned SQUARE... not rectangle!!!"
                    },
                    {
                        "username": "tb950110",
                        "content": "thank you!"
                    },
                    {
                        "username": "tonari",
                        "content": "For data structure, think about how you can access # of points in reduced time (ideally constant). Then think about additional info from the problem you can use that\\'s Math-y"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Another tricky Question"
                    }
                ]
            },
            {
                "id": 1813962,
                "content": [
                    {
                        "username": "feliposz",
                        "content": "Axis-aligned SQUARE... not rectangle!!!"
                    },
                    {
                        "username": "tb950110",
                        "content": "thank you!"
                    },
                    {
                        "username": "tonari",
                        "content": "For data structure, think about how you can access # of points in reduced time (ideally constant). Then think about additional info from the problem you can use that\\'s Math-y"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Another tricky Question"
                    }
                ]
            }
        ]
    }
]